var ype = Object.defineProperty;
var xpe = (o, a, c) => a in o ? ype(o, a, { enumerable: !0, configurable: !0, writable: !0, value: c }) : o[a] = c;
var Vae = (o, a, c) => xpe(o, typeof a != "symbol" ? a + "" : a, c);
function eO(o) {
  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
}
var kce = { exports: {} }, EV = {}, _ce = { exports: {} }, ea = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var DI = Symbol.for("react.element"), wpe = Symbol.for("react.portal"), Cpe = Symbol.for("react.fragment"), Spe = Symbol.for("react.strict_mode"), kpe = Symbol.for("react.profiler"), _pe = Symbol.for("react.provider"), Epe = Symbol.for("react.context"), Tpe = Symbol.for("react.forward_ref"), Ape = Symbol.for("react.suspense"), Ope = Symbol.for("react.memo"), Dpe = Symbol.for("react.lazy"), Uae = Symbol.iterator;
function Rpe(o) {
  return o === null || typeof o != "object" ? null : (o = Uae && o[Uae] || o["@@iterator"], typeof o == "function" ? o : null);
}
var Ece = { isMounted: function() {
  return !1;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, Tce = Object.assign, Ace = {};
function tO(o, a, c) {
  this.props = o, this.context = a, this.refs = Ace, this.updater = c || Ece;
}
tO.prototype.isReactComponent = {};
tO.prototype.setState = function(o, a) {
  if (typeof o != "object" && typeof o != "function" && o != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, o, a, "setState");
};
tO.prototype.forceUpdate = function(o) {
  this.updater.enqueueForceUpdate(this, o, "forceUpdate");
};
function Oce() {
}
Oce.prototype = tO.prototype;
function ioe(o, a, c) {
  this.props = o, this.context = a, this.refs = Ace, this.updater = c || Ece;
}
var loe = ioe.prototype = new Oce();
loe.constructor = ioe;
Tce(loe, tO.prototype);
loe.isPureReactComponent = !0;
var jae = Array.isArray, Dce = Object.prototype.hasOwnProperty, coe = { current: null }, Rce = { key: !0, ref: !0, __self: !0, __source: !0 };
function Nce(o, a, c) {
  var f, g = {}, x = null, k = null;
  if (a != null) for (f in a.ref !== void 0 && (k = a.ref), a.key !== void 0 && (x = "" + a.key), a) Dce.call(a, f) && !Rce.hasOwnProperty(f) && (g[f] = a[f]);
  var A = arguments.length - 2;
  if (A === 1) g.children = c;
  else if (1 < A) {
    for (var N = Array(A), H = 0; H < A; H++) N[H] = arguments[H + 2];
    g.children = N;
  }
  if (o && o.defaultProps) for (f in A = o.defaultProps, A) g[f] === void 0 && (g[f] = A[f]);
  return { $$typeof: DI, type: o, key: x, ref: k, props: g, _owner: coe.current };
}
function Npe(o, a) {
  return { $$typeof: DI, type: o.type, key: a, ref: o.ref, props: o.props, _owner: o._owner };
}
function uoe(o) {
  return typeof o == "object" && o !== null && o.$$typeof === DI;
}
function Ppe(o) {
  var a = { "=": "=0", ":": "=2" };
  return "$" + o.replace(/[=:]/g, function(c) {
    return a[c];
  });
}
var Wae = /\/+/g;
function Bee(o, a) {
  return typeof o == "object" && o !== null && o.key != null ? Ppe("" + o.key) : a.toString(36);
}
function E9(o, a, c, f, g) {
  var x = typeof o;
  (x === "undefined" || x === "boolean") && (o = null);
  var k = !1;
  if (o === null) k = !0;
  else switch (x) {
    case "string":
    case "number":
      k = !0;
      break;
    case "object":
      switch (o.$$typeof) {
        case DI:
        case wpe:
          k = !0;
      }
  }
  if (k) return k = o, g = g(k), o = f === "" ? "." + Bee(k, 0) : f, jae(g) ? (c = "", o != null && (c = o.replace(Wae, "$&/") + "/"), E9(g, a, c, "", function(H) {
    return H;
  })) : g != null && (uoe(g) && (g = Npe(g, c + (!g.key || k && k.key === g.key ? "" : ("" + g.key).replace(Wae, "$&/") + "/") + o)), a.push(g)), 1;
  if (k = 0, f = f === "" ? "." : f + ":", jae(o)) for (var A = 0; A < o.length; A++) {
    x = o[A];
    var N = f + Bee(x, A);
    k += E9(x, a, c, N, g);
  }
  else if (N = Rpe(o), typeof N == "function") for (o = N.call(o), A = 0; !(x = o.next()).done; ) x = x.value, N = f + Bee(x, A++), k += E9(x, a, c, N, g);
  else if (x === "object") throw a = String(o), Error("Objects are not valid as a React child (found: " + (a === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : a) + "). If you meant to render a collection of children, use an array instead.");
  return k;
}
function Wz(o, a, c) {
  if (o == null) return o;
  var f = [], g = 0;
  return E9(o, f, "", "", function(x) {
    return a.call(c, x, g++);
  }), f;
}
function Mpe(o) {
  if (o._status === -1) {
    var a = o._result;
    a = a(), a.then(function(c) {
      (o._status === 0 || o._status === -1) && (o._status = 1, o._result = c);
    }, function(c) {
      (o._status === 0 || o._status === -1) && (o._status = 2, o._result = c);
    }), o._status === -1 && (o._status = 0, o._result = a);
  }
  if (o._status === 1) return o._result.default;
  throw o._result;
}
var Pf = { current: null }, T9 = { transition: null }, Ipe = { ReactCurrentDispatcher: Pf, ReactCurrentBatchConfig: T9, ReactCurrentOwner: coe };
function Pce() {
  throw Error("act(...) is not supported in production builds of React.");
}
ea.Children = { map: Wz, forEach: function(o, a, c) {
  Wz(o, function() {
    a.apply(this, arguments);
  }, c);
}, count: function(o) {
  var a = 0;
  return Wz(o, function() {
    a++;
  }), a;
}, toArray: function(o) {
  return Wz(o, function(a) {
    return a;
  }) || [];
}, only: function(o) {
  if (!uoe(o)) throw Error("React.Children.only expected to receive a single React element child.");
  return o;
} };
ea.Component = tO;
ea.Fragment = Cpe;
ea.Profiler = kpe;
ea.PureComponent = ioe;
ea.StrictMode = Spe;
ea.Suspense = Ape;
ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Ipe;
ea.act = Pce;
ea.cloneElement = function(o, a, c) {
  if (o == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + o + ".");
  var f = Tce({}, o.props), g = o.key, x = o.ref, k = o._owner;
  if (a != null) {
    if (a.ref !== void 0 && (x = a.ref, k = coe.current), a.key !== void 0 && (g = "" + a.key), o.type && o.type.defaultProps) var A = o.type.defaultProps;
    for (N in a) Dce.call(a, N) && !Rce.hasOwnProperty(N) && (f[N] = a[N] === void 0 && A !== void 0 ? A[N] : a[N]);
  }
  var N = arguments.length - 2;
  if (N === 1) f.children = c;
  else if (1 < N) {
    A = Array(N);
    for (var H = 0; H < N; H++) A[H] = arguments[H + 2];
    f.children = A;
  }
  return { $$typeof: DI, type: o.type, key: g, ref: x, props: f, _owner: k };
};
ea.createContext = function(o) {
  return o = { $$typeof: Epe, _currentValue: o, _currentValue2: o, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, o.Provider = { $$typeof: _pe, _context: o }, o.Consumer = o;
};
ea.createElement = Nce;
ea.createFactory = function(o) {
  var a = Nce.bind(null, o);
  return a.type = o, a;
};
ea.createRef = function() {
  return { current: null };
};
ea.forwardRef = function(o) {
  return { $$typeof: Tpe, render: o };
};
ea.isValidElement = uoe;
ea.lazy = function(o) {
  return { $$typeof: Dpe, _payload: { _status: -1, _result: o }, _init: Mpe };
};
ea.memo = function(o, a) {
  return { $$typeof: Ope, type: o, compare: a === void 0 ? null : a };
};
ea.startTransition = function(o) {
  var a = T9.transition;
  T9.transition = {};
  try {
    o();
  } finally {
    T9.transition = a;
  }
};
ea.unstable_act = Pce;
ea.useCallback = function(o, a) {
  return Pf.current.useCallback(o, a);
};
ea.useContext = function(o) {
  return Pf.current.useContext(o);
};
ea.useDebugValue = function() {
};
ea.useDeferredValue = function(o) {
  return Pf.current.useDeferredValue(o);
};
ea.useEffect = function(o, a) {
  return Pf.current.useEffect(o, a);
};
ea.useId = function() {
  return Pf.current.useId();
};
ea.useImperativeHandle = function(o, a, c) {
  return Pf.current.useImperativeHandle(o, a, c);
};
ea.useInsertionEffect = function(o, a) {
  return Pf.current.useInsertionEffect(o, a);
};
ea.useLayoutEffect = function(o, a) {
  return Pf.current.useLayoutEffect(o, a);
};
ea.useMemo = function(o, a) {
  return Pf.current.useMemo(o, a);
};
ea.useReducer = function(o, a, c) {
  return Pf.current.useReducer(o, a, c);
};
ea.useRef = function(o) {
  return Pf.current.useRef(o);
};
ea.useState = function(o) {
  return Pf.current.useState(o);
};
ea.useSyncExternalStore = function(o, a, c) {
  return Pf.current.useSyncExternalStore(o, a, c);
};
ea.useTransition = function() {
  return Pf.current.useTransition();
};
ea.version = "18.3.1";
_ce.exports = ea;
var tt = _ce.exports;
const Ve = /* @__PURE__ */ eO(tt);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Fpe = tt, Bpe = Symbol.for("react.element"), Lpe = Symbol.for("react.fragment"), $pe = Object.prototype.hasOwnProperty, Hpe = Fpe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, zpe = { key: !0, ref: !0, __self: !0, __source: !0 };
function Mce(o, a, c) {
  var f, g = {}, x = null, k = null;
  c !== void 0 && (x = "" + c), a.key !== void 0 && (x = "" + a.key), a.ref !== void 0 && (k = a.ref);
  for (f in a) $pe.call(a, f) && !zpe.hasOwnProperty(f) && (g[f] = a[f]);
  if (o && o.defaultProps) for (f in a = o.defaultProps, a) g[f] === void 0 && (g[f] = a[f]);
  return { $$typeof: Bpe, type: o, key: x, ref: k, props: g, _owner: Hpe.current };
}
EV.Fragment = Lpe;
EV.jsx = Mce;
EV.jsxs = Mce;
kce.exports = EV;
var Ws = kce.exports, Ice = { exports: {} }, gp = {}, Fce = { exports: {} }, Bce = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(o) {
  function a(ze, jt) {
    var Tt = ze.length;
    ze.push(jt);
    e: for (; 0 < Tt; ) {
      var Je = Tt - 1 >>> 1, pn = ze[Je];
      if (0 < g(pn, jt)) ze[Je] = jt, ze[Tt] = pn, Tt = Je;
      else break e;
    }
  }
  function c(ze) {
    return ze.length === 0 ? null : ze[0];
  }
  function f(ze) {
    if (ze.length === 0) return null;
    var jt = ze[0], Tt = ze.pop();
    if (Tt !== jt) {
      ze[0] = Tt;
      e: for (var Je = 0, pn = ze.length, Ro = pn >>> 1; Je < Ro; ) {
        var Rt = 2 * (Je + 1) - 1, Cn = ze[Rt], et = Rt + 1, xt = ze[et];
        if (0 > g(Cn, Tt)) et < pn && 0 > g(xt, Cn) ? (ze[Je] = xt, ze[et] = Tt, Je = et) : (ze[Je] = Cn, ze[Rt] = Tt, Je = Rt);
        else if (et < pn && 0 > g(xt, Tt)) ze[Je] = xt, ze[et] = Tt, Je = et;
        else break e;
      }
    }
    return jt;
  }
  function g(ze, jt) {
    var Tt = ze.sortIndex - jt.sortIndex;
    return Tt !== 0 ? Tt : ze.id - jt.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var x = performance;
    o.unstable_now = function() {
      return x.now();
    };
  } else {
    var k = Date, A = k.now();
    o.unstable_now = function() {
      return k.now() - A;
    };
  }
  var N = [], H = [], Z = 1, K = null, J = 3, pe = !1, Se = !1, be = !1, ye = typeof setTimeout == "function" ? setTimeout : null, re = typeof clearTimeout == "function" ? clearTimeout : null, oe = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function U(ze) {
    for (var jt = c(H); jt !== null; ) {
      if (jt.callback === null) f(H);
      else if (jt.startTime <= ze) f(H), jt.sortIndex = jt.expirationTime, a(N, jt);
      else break;
      jt = c(H);
    }
  }
  function ve(ze) {
    if (be = !1, U(ze), !Se) if (c(N) !== null) Se = !0, B(Ze);
    else {
      var jt = c(H);
      jt !== null && fn(ve, jt.startTime - ze);
    }
  }
  function Ze(ze, jt) {
    Se = !1, be && (be = !1, re(lt), lt = -1), pe = !0;
    var Tt = J;
    try {
      for (U(jt), K = c(N); K !== null && (!(K.expirationTime > jt) || ze && !Ue()); ) {
        var Je = K.callback;
        if (typeof Je == "function") {
          K.callback = null, J = K.priorityLevel;
          var pn = Je(K.expirationTime <= jt);
          jt = o.unstable_now(), typeof pn == "function" ? K.callback = pn : K === c(N) && f(N), U(jt);
        } else f(N);
        K = c(N);
      }
      if (K !== null) var Ro = !0;
      else {
        var Rt = c(H);
        Rt !== null && fn(ve, Rt.startTime - jt), Ro = !1;
      }
      return Ro;
    } finally {
      K = null, J = Tt, pe = !1;
    }
  }
  var rt = !1, ee = null, lt = -1, wt = 5, Vt = -1;
  function Ue() {
    return !(o.unstable_now() - Vt < wt);
  }
  function Ce() {
    if (ee !== null) {
      var ze = o.unstable_now();
      Vt = ze;
      var jt = !0;
      try {
        jt = ee(!0, ze);
      } finally {
        jt ? Rn() : (rt = !1, ee = null);
      }
    } else rt = !1;
  }
  var Rn;
  if (typeof oe == "function") Rn = function() {
    oe(Ce);
  };
  else if (typeof MessageChannel < "u") {
    var _t = new MessageChannel(), ot = _t.port2;
    _t.port1.onmessage = Ce, Rn = function() {
      ot.postMessage(null);
    };
  } else Rn = function() {
    ye(Ce, 0);
  };
  function B(ze) {
    ee = ze, rt || (rt = !0, Rn());
  }
  function fn(ze, jt) {
    lt = ye(function() {
      ze(o.unstable_now());
    }, jt);
  }
  o.unstable_IdlePriority = 5, o.unstable_ImmediatePriority = 1, o.unstable_LowPriority = 4, o.unstable_NormalPriority = 3, o.unstable_Profiling = null, o.unstable_UserBlockingPriority = 2, o.unstable_cancelCallback = function(ze) {
    ze.callback = null;
  }, o.unstable_continueExecution = function() {
    Se || pe || (Se = !0, B(Ze));
  }, o.unstable_forceFrameRate = function(ze) {
    0 > ze || 125 < ze ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : wt = 0 < ze ? Math.floor(1e3 / ze) : 5;
  }, o.unstable_getCurrentPriorityLevel = function() {
    return J;
  }, o.unstable_getFirstCallbackNode = function() {
    return c(N);
  }, o.unstable_next = function(ze) {
    switch (J) {
      case 1:
      case 2:
      case 3:
        var jt = 3;
        break;
      default:
        jt = J;
    }
    var Tt = J;
    J = jt;
    try {
      return ze();
    } finally {
      J = Tt;
    }
  }, o.unstable_pauseExecution = function() {
  }, o.unstable_requestPaint = function() {
  }, o.unstable_runWithPriority = function(ze, jt) {
    switch (ze) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        ze = 3;
    }
    var Tt = J;
    J = ze;
    try {
      return jt();
    } finally {
      J = Tt;
    }
  }, o.unstable_scheduleCallback = function(ze, jt, Tt) {
    var Je = o.unstable_now();
    switch (typeof Tt == "object" && Tt !== null ? (Tt = Tt.delay, Tt = typeof Tt == "number" && 0 < Tt ? Je + Tt : Je) : Tt = Je, ze) {
      case 1:
        var pn = -1;
        break;
      case 2:
        pn = 250;
        break;
      case 5:
        pn = 1073741823;
        break;
      case 4:
        pn = 1e4;
        break;
      default:
        pn = 5e3;
    }
    return pn = Tt + pn, ze = { id: Z++, callback: jt, priorityLevel: ze, startTime: Tt, expirationTime: pn, sortIndex: -1 }, Tt > Je ? (ze.sortIndex = Tt, a(H, ze), c(N) === null && ze === c(H) && (be ? (re(lt), lt = -1) : be = !0, fn(ve, Tt - Je))) : (ze.sortIndex = pn, a(N, ze), Se || pe || (Se = !0, B(Ze))), ze;
  }, o.unstable_shouldYield = Ue, o.unstable_wrapCallback = function(ze) {
    var jt = J;
    return function() {
      var Tt = J;
      J = jt;
      try {
        return ze.apply(this, arguments);
      } finally {
        J = Tt;
      }
    };
  };
})(Bce);
Fce.exports = Bce;
var Vpe = Fce.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Upe = tt, pp = Vpe;
function no(o) {
  for (var a = "https://reactjs.org/docs/error-decoder.html?invariant=" + o, c = 1; c < arguments.length; c++) a += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + o + "; visit " + a + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var Lce = /* @__PURE__ */ new Set(), J5 = {};
function Jk(o, a) {
  L4(o, a), L4(o + "Capture", a);
}
function L4(o, a) {
  for (J5[o] = a, o = 0; o < a.length; o++) Lce.add(a[o]);
}
var F0 = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Pte = Object.prototype.hasOwnProperty, jpe = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Zae = {}, Gae = {};
function Wpe(o) {
  return Pte.call(Gae, o) ? !0 : Pte.call(Zae, o) ? !1 : jpe.test(o) ? Gae[o] = !0 : (Zae[o] = !0, !1);
}
function Zpe(o, a, c, f) {
  if (c !== null && c.type === 0) return !1;
  switch (typeof a) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return f ? !1 : c !== null ? !c.acceptsBooleans : (o = o.toLowerCase().slice(0, 5), o !== "data-" && o !== "aria-");
    default:
      return !1;
  }
}
function Gpe(o, a, c, f) {
  if (a === null || typeof a > "u" || Zpe(o, a, c, f)) return !0;
  if (f) return !1;
  if (c !== null) switch (c.type) {
    case 3:
      return !a;
    case 4:
      return a === !1;
    case 5:
      return isNaN(a);
    case 6:
      return isNaN(a) || 1 > a;
  }
  return !1;
}
function Mf(o, a, c, f, g, x, k) {
  this.acceptsBooleans = a === 2 || a === 3 || a === 4, this.attributeName = f, this.attributeNamespace = g, this.mustUseProperty = c, this.propertyName = o, this.type = a, this.sanitizeURL = x, this.removeEmptyString = k;
}
var dd = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(o) {
  dd[o] = new Mf(o, 0, !1, o, null, !1, !1);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(o) {
  var a = o[0];
  dd[a] = new Mf(a, 1, !1, o[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(o) {
  dd[o] = new Mf(o, 2, !1, o.toLowerCase(), null, !1, !1);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(o) {
  dd[o] = new Mf(o, 2, !1, o, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(o) {
  dd[o] = new Mf(o, 3, !1, o.toLowerCase(), null, !1, !1);
});
["checked", "multiple", "muted", "selected"].forEach(function(o) {
  dd[o] = new Mf(o, 3, !0, o, null, !1, !1);
});
["capture", "download"].forEach(function(o) {
  dd[o] = new Mf(o, 4, !1, o, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function(o) {
  dd[o] = new Mf(o, 6, !1, o, null, !1, !1);
});
["rowSpan", "start"].forEach(function(o) {
  dd[o] = new Mf(o, 5, !1, o.toLowerCase(), null, !1, !1);
});
var doe = /[\-:]([a-z])/g;
function foe(o) {
  return o[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(o) {
  var a = o.replace(
    doe,
    foe
  );
  dd[a] = new Mf(a, 1, !1, o, null, !1, !1);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(o) {
  var a = o.replace(doe, foe);
  dd[a] = new Mf(a, 1, !1, o, "http://www.w3.org/1999/xlink", !1, !1);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(o) {
  var a = o.replace(doe, foe);
  dd[a] = new Mf(a, 1, !1, o, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function(o) {
  dd[o] = new Mf(o, 1, !1, o.toLowerCase(), null, !1, !1);
});
dd.xlinkHref = new Mf("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(o) {
  dd[o] = new Mf(o, 1, !1, o.toLowerCase(), null, !0, !0);
});
function moe(o, a, c, f) {
  var g = dd.hasOwnProperty(a) ? dd[a] : null;
  (g !== null ? g.type !== 0 : f || !(2 < a.length) || a[0] !== "o" && a[0] !== "O" || a[1] !== "n" && a[1] !== "N") && (Gpe(a, c, g, f) && (c = null), f || g === null ? Wpe(a) && (c === null ? o.removeAttribute(a) : o.setAttribute(a, "" + c)) : g.mustUseProperty ? o[g.propertyName] = c === null ? g.type === 3 ? !1 : "" : c : (a = g.attributeName, f = g.attributeNamespace, c === null ? o.removeAttribute(a) : (g = g.type, c = g === 3 || g === 4 && c === !0 ? "" : "" + c, f ? o.setAttributeNS(f, a, c) : o.setAttribute(a, c))));
}
var W0 = Upe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Zz = Symbol.for("react.element"), d4 = Symbol.for("react.portal"), f4 = Symbol.for("react.fragment"), poe = Symbol.for("react.strict_mode"), Mte = Symbol.for("react.profiler"), $ce = Symbol.for("react.provider"), Hce = Symbol.for("react.context"), hoe = Symbol.for("react.forward_ref"), Ite = Symbol.for("react.suspense"), Fte = Symbol.for("react.suspense_list"), goe = Symbol.for("react.memo"), C2 = Symbol.for("react.lazy"), zce = Symbol.for("react.offscreen"), qae = Symbol.iterator;
function S5(o) {
  return o === null || typeof o != "object" ? null : (o = qae && o[qae] || o["@@iterator"], typeof o == "function" ? o : null);
}
var Fl = Object.assign, Lee;
function P5(o) {
  if (Lee === void 0) try {
    throw Error();
  } catch (c) {
    var a = c.stack.trim().match(/\n( *(at )?)/);
    Lee = a && a[1] || "";
  }
  return `
` + Lee + o;
}
var $ee = !1;
function Hee(o, a) {
  if (!o || $ee) return "";
  $ee = !0;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (a) if (a = function() {
      throw Error();
    }, Object.defineProperty(a.prototype, "props", { set: function() {
      throw Error();
    } }), typeof Reflect == "object" && Reflect.construct) {
      try {
        Reflect.construct(a, []);
      } catch (H) {
        var f = H;
      }
      Reflect.construct(o, [], a);
    } else {
      try {
        a.call();
      } catch (H) {
        f = H;
      }
      o.call(a.prototype);
    }
    else {
      try {
        throw Error();
      } catch (H) {
        f = H;
      }
      o();
    }
  } catch (H) {
    if (H && f && typeof H.stack == "string") {
      for (var g = H.stack.split(`
`), x = f.stack.split(`
`), k = g.length - 1, A = x.length - 1; 1 <= k && 0 <= A && g[k] !== x[A]; ) A--;
      for (; 1 <= k && 0 <= A; k--, A--) if (g[k] !== x[A]) {
        if (k !== 1 || A !== 1)
          do
            if (k--, A--, 0 > A || g[k] !== x[A]) {
              var N = `
` + g[k].replace(" at new ", " at ");
              return o.displayName && N.includes("<anonymous>") && (N = N.replace("<anonymous>", o.displayName)), N;
            }
          while (1 <= k && 0 <= A);
        break;
      }
    }
  } finally {
    $ee = !1, Error.prepareStackTrace = c;
  }
  return (o = o ? o.displayName || o.name : "") ? P5(o) : "";
}
function qpe(o) {
  switch (o.tag) {
    case 5:
      return P5(o.type);
    case 16:
      return P5("Lazy");
    case 13:
      return P5("Suspense");
    case 19:
      return P5("SuspenseList");
    case 0:
    case 2:
    case 15:
      return o = Hee(o.type, !1), o;
    case 11:
      return o = Hee(o.type.render, !1), o;
    case 1:
      return o = Hee(o.type, !0), o;
    default:
      return "";
  }
}
function Bte(o) {
  if (o == null) return null;
  if (typeof o == "function") return o.displayName || o.name || null;
  if (typeof o == "string") return o;
  switch (o) {
    case f4:
      return "Fragment";
    case d4:
      return "Portal";
    case Mte:
      return "Profiler";
    case poe:
      return "StrictMode";
    case Ite:
      return "Suspense";
    case Fte:
      return "SuspenseList";
  }
  if (typeof o == "object") switch (o.$$typeof) {
    case Hce:
      return (o.displayName || "Context") + ".Consumer";
    case $ce:
      return (o._context.displayName || "Context") + ".Provider";
    case hoe:
      var a = o.render;
      return o = o.displayName, o || (o = a.displayName || a.name || "", o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"), o;
    case goe:
      return a = o.displayName || null, a !== null ? a : Bte(o.type) || "Memo";
    case C2:
      a = o._payload, o = o._init;
      try {
        return Bte(o(a));
      } catch {
      }
  }
  return null;
}
function Kpe(o) {
  var a = o.type;
  switch (o.tag) {
    case 24:
      return "Cache";
    case 9:
      return (a.displayName || "Context") + ".Consumer";
    case 10:
      return (a._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return o = a.render, o = o.displayName || o.name || "", a.displayName || (o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return a;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Bte(a);
    case 8:
      return a === poe ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof a == "function") return a.displayName || a.name || null;
      if (typeof a == "string") return a;
  }
  return null;
}
function H2(o) {
  switch (typeof o) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return o;
    case "object":
      return o;
    default:
      return "";
  }
}
function Vce(o) {
  var a = o.type;
  return (o = o.nodeName) && o.toLowerCase() === "input" && (a === "checkbox" || a === "radio");
}
function Ype(o) {
  var a = Vce(o) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(o.constructor.prototype, a), f = "" + o[a];
  if (!o.hasOwnProperty(a) && typeof c < "u" && typeof c.get == "function" && typeof c.set == "function") {
    var g = c.get, x = c.set;
    return Object.defineProperty(o, a, { configurable: !0, get: function() {
      return g.call(this);
    }, set: function(k) {
      f = "" + k, x.call(this, k);
    } }), Object.defineProperty(o, a, { enumerable: c.enumerable }), { getValue: function() {
      return f;
    }, setValue: function(k) {
      f = "" + k;
    }, stopTracking: function() {
      o._valueTracker = null, delete o[a];
    } };
  }
}
function Gz(o) {
  o._valueTracker || (o._valueTracker = Ype(o));
}
function Uce(o) {
  if (!o) return !1;
  var a = o._valueTracker;
  if (!a) return !0;
  var c = a.getValue(), f = "";
  return o && (f = Vce(o) ? o.checked ? "true" : "false" : o.value), o = f, o !== c ? (a.setValue(o), !0) : !1;
}
function W9(o) {
  if (o = o || (typeof document < "u" ? document : void 0), typeof o > "u") return null;
  try {
    return o.activeElement || o.body;
  } catch {
    return o.body;
  }
}
function Lte(o, a) {
  var c = a.checked;
  return Fl({}, a, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c ?? o._wrapperState.initialChecked });
}
function Kae(o, a) {
  var c = a.defaultValue == null ? "" : a.defaultValue, f = a.checked != null ? a.checked : a.defaultChecked;
  c = H2(a.value != null ? a.value : c), o._wrapperState = { initialChecked: f, initialValue: c, controlled: a.type === "checkbox" || a.type === "radio" ? a.checked != null : a.value != null };
}
function jce(o, a) {
  a = a.checked, a != null && moe(o, "checked", a, !1);
}
function $te(o, a) {
  jce(o, a);
  var c = H2(a.value), f = a.type;
  if (c != null) f === "number" ? (c === 0 && o.value === "" || o.value != c) && (o.value = "" + c) : o.value !== "" + c && (o.value = "" + c);
  else if (f === "submit" || f === "reset") {
    o.removeAttribute("value");
    return;
  }
  a.hasOwnProperty("value") ? Hte(o, a.type, c) : a.hasOwnProperty("defaultValue") && Hte(o, a.type, H2(a.defaultValue)), a.checked == null && a.defaultChecked != null && (o.defaultChecked = !!a.defaultChecked);
}
function Yae(o, a, c) {
  if (a.hasOwnProperty("value") || a.hasOwnProperty("defaultValue")) {
    var f = a.type;
    if (!(f !== "submit" && f !== "reset" || a.value !== void 0 && a.value !== null)) return;
    a = "" + o._wrapperState.initialValue, c || a === o.value || (o.value = a), o.defaultValue = a;
  }
  c = o.name, c !== "" && (o.name = ""), o.defaultChecked = !!o._wrapperState.initialChecked, c !== "" && (o.name = c);
}
function Hte(o, a, c) {
  (a !== "number" || W9(o.ownerDocument) !== o) && (c == null ? o.defaultValue = "" + o._wrapperState.initialValue : o.defaultValue !== "" + c && (o.defaultValue = "" + c));
}
var M5 = Array.isArray;
function A4(o, a, c, f) {
  if (o = o.options, a) {
    a = {};
    for (var g = 0; g < c.length; g++) a["$" + c[g]] = !0;
    for (c = 0; c < o.length; c++) g = a.hasOwnProperty("$" + o[c].value), o[c].selected !== g && (o[c].selected = g), g && f && (o[c].defaultSelected = !0);
  } else {
    for (c = "" + H2(c), a = null, g = 0; g < o.length; g++) {
      if (o[g].value === c) {
        o[g].selected = !0, f && (o[g].defaultSelected = !0);
        return;
      }
      a !== null || o[g].disabled || (a = o[g]);
    }
    a !== null && (a.selected = !0);
  }
}
function zte(o, a) {
  if (a.dangerouslySetInnerHTML != null) throw Error(no(91));
  return Fl({}, a, { value: void 0, defaultValue: void 0, children: "" + o._wrapperState.initialValue });
}
function Xae(o, a) {
  var c = a.value;
  if (c == null) {
    if (c = a.children, a = a.defaultValue, c != null) {
      if (a != null) throw Error(no(92));
      if (M5(c)) {
        if (1 < c.length) throw Error(no(93));
        c = c[0];
      }
      a = c;
    }
    a == null && (a = ""), c = a;
  }
  o._wrapperState = { initialValue: H2(c) };
}
function Wce(o, a) {
  var c = H2(a.value), f = H2(a.defaultValue);
  c != null && (c = "" + c, c !== o.value && (o.value = c), a.defaultValue == null && o.defaultValue !== c && (o.defaultValue = c)), f != null && (o.defaultValue = "" + f);
}
function Qae(o) {
  var a = o.textContent;
  a === o._wrapperState.initialValue && a !== "" && a !== null && (o.value = a);
}
function Zce(o) {
  switch (o) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function Vte(o, a) {
  return o == null || o === "http://www.w3.org/1999/xhtml" ? Zce(a) : o === "http://www.w3.org/2000/svg" && a === "foreignObject" ? "http://www.w3.org/1999/xhtml" : o;
}
var qz, Gce = function(o) {
  return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(a, c, f, g) {
    MSApp.execUnsafeLocalFunction(function() {
      return o(a, c, f, g);
    });
  } : o;
}(function(o, a) {
  if (o.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in o) o.innerHTML = a;
  else {
    for (qz = qz || document.createElement("div"), qz.innerHTML = "<svg>" + a.valueOf().toString() + "</svg>", a = qz.firstChild; o.firstChild; ) o.removeChild(o.firstChild);
    for (; a.firstChild; ) o.appendChild(a.firstChild);
  }
});
function eI(o, a) {
  if (a) {
    var c = o.firstChild;
    if (c && c === o.lastChild && c.nodeType === 3) {
      c.nodeValue = a;
      return;
    }
  }
  o.textContent = a;
}
var $5 = {
  animationIterationCount: !0,
  aspectRatio: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridArea: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
}, Xpe = ["Webkit", "ms", "Moz", "O"];
Object.keys($5).forEach(function(o) {
  Xpe.forEach(function(a) {
    a = a + o.charAt(0).toUpperCase() + o.substring(1), $5[a] = $5[o];
  });
});
function qce(o, a, c) {
  return a == null || typeof a == "boolean" || a === "" ? "" : c || typeof a != "number" || a === 0 || $5.hasOwnProperty(o) && $5[o] ? ("" + a).trim() : a + "px";
}
function Kce(o, a) {
  o = o.style;
  for (var c in a) if (a.hasOwnProperty(c)) {
    var f = c.indexOf("--") === 0, g = qce(c, a[c], f);
    c === "float" && (c = "cssFloat"), f ? o.setProperty(c, g) : o[c] = g;
  }
}
var Qpe = Fl({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
function Ute(o, a) {
  if (a) {
    if (Qpe[o] && (a.children != null || a.dangerouslySetInnerHTML != null)) throw Error(no(137, o));
    if (a.dangerouslySetInnerHTML != null) {
      if (a.children != null) throw Error(no(60));
      if (typeof a.dangerouslySetInnerHTML != "object" || !("__html" in a.dangerouslySetInnerHTML)) throw Error(no(61));
    }
    if (a.style != null && typeof a.style != "object") throw Error(no(62));
  }
}
function jte(o, a) {
  if (o.indexOf("-") === -1) return typeof a.is == "string";
  switch (o) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var Wte = null;
function voe(o) {
  return o = o.target || o.srcElement || window, o.correspondingUseElement && (o = o.correspondingUseElement), o.nodeType === 3 ? o.parentNode : o;
}
var Zte = null, O4 = null, D4 = null;
function Jae(o) {
  if (o = PI(o)) {
    if (typeof Zte != "function") throw Error(no(280));
    var a = o.stateNode;
    a && (a = RV(a), Zte(o.stateNode, o.type, a));
  }
}
function Yce(o) {
  O4 ? D4 ? D4.push(o) : D4 = [o] : O4 = o;
}
function Xce() {
  if (O4) {
    var o = O4, a = D4;
    if (D4 = O4 = null, Jae(o), a) for (o = 0; o < a.length; o++) Jae(a[o]);
  }
}
function Qce(o, a) {
  return o(a);
}
function Jce() {
}
var zee = !1;
function eue(o, a, c) {
  if (zee) return o(a, c);
  zee = !0;
  try {
    return Qce(o, a, c);
  } finally {
    zee = !1, (O4 !== null || D4 !== null) && (Jce(), Xce());
  }
}
function tI(o, a) {
  var c = o.stateNode;
  if (c === null) return null;
  var f = RV(c);
  if (f === null) return null;
  c = f[a];
  e: switch (a) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (f = !f.disabled) || (o = o.type, f = !(o === "button" || o === "input" || o === "select" || o === "textarea")), o = !f;
      break e;
    default:
      o = !1;
  }
  if (o) return null;
  if (c && typeof c != "function") throw Error(no(231, a, typeof c));
  return c;
}
var Gte = !1;
if (F0) try {
  var k5 = {};
  Object.defineProperty(k5, "passive", { get: function() {
    Gte = !0;
  } }), window.addEventListener("test", k5, k5), window.removeEventListener("test", k5, k5);
} catch {
  Gte = !1;
}
function Jpe(o, a, c, f, g, x, k, A, N) {
  var H = Array.prototype.slice.call(arguments, 3);
  try {
    a.apply(c, H);
  } catch (Z) {
    this.onError(Z);
  }
}
var H5 = !1, Z9 = null, G9 = !1, qte = null, ehe = { onError: function(o) {
  H5 = !0, Z9 = o;
} };
function the(o, a, c, f, g, x, k, A, N) {
  H5 = !1, Z9 = null, Jpe.apply(ehe, arguments);
}
function nhe(o, a, c, f, g, x, k, A, N) {
  if (the.apply(this, arguments), H5) {
    if (H5) {
      var H = Z9;
      H5 = !1, Z9 = null;
    } else throw Error(no(198));
    G9 || (G9 = !0, qte = H);
  }
}
function e_(o) {
  var a = o, c = o;
  if (o.alternate) for (; a.return; ) a = a.return;
  else {
    o = a;
    do
      a = o, a.flags & 4098 && (c = a.return), o = a.return;
    while (o);
  }
  return a.tag === 3 ? c : null;
}
function tue(o) {
  if (o.tag === 13) {
    var a = o.memoizedState;
    if (a === null && (o = o.alternate, o !== null && (a = o.memoizedState)), a !== null) return a.dehydrated;
  }
  return null;
}
function eie(o) {
  if (e_(o) !== o) throw Error(no(188));
}
function ohe(o) {
  var a = o.alternate;
  if (!a) {
    if (a = e_(o), a === null) throw Error(no(188));
    return a !== o ? null : o;
  }
  for (var c = o, f = a; ; ) {
    var g = c.return;
    if (g === null) break;
    var x = g.alternate;
    if (x === null) {
      if (f = g.return, f !== null) {
        c = f;
        continue;
      }
      break;
    }
    if (g.child === x.child) {
      for (x = g.child; x; ) {
        if (x === c) return eie(g), o;
        if (x === f) return eie(g), a;
        x = x.sibling;
      }
      throw Error(no(188));
    }
    if (c.return !== f.return) c = g, f = x;
    else {
      for (var k = !1, A = g.child; A; ) {
        if (A === c) {
          k = !0, c = g, f = x;
          break;
        }
        if (A === f) {
          k = !0, f = g, c = x;
          break;
        }
        A = A.sibling;
      }
      if (!k) {
        for (A = x.child; A; ) {
          if (A === c) {
            k = !0, c = x, f = g;
            break;
          }
          if (A === f) {
            k = !0, f = x, c = g;
            break;
          }
          A = A.sibling;
        }
        if (!k) throw Error(no(189));
      }
    }
    if (c.alternate !== f) throw Error(no(190));
  }
  if (c.tag !== 3) throw Error(no(188));
  return c.stateNode.current === c ? o : a;
}
function nue(o) {
  return o = ohe(o), o !== null ? oue(o) : null;
}
function oue(o) {
  if (o.tag === 5 || o.tag === 6) return o;
  for (o = o.child; o !== null; ) {
    var a = oue(o);
    if (a !== null) return a;
    o = o.sibling;
  }
  return null;
}
var sue = pp.unstable_scheduleCallback, tie = pp.unstable_cancelCallback, she = pp.unstable_shouldYield, rhe = pp.unstable_requestPaint, yc = pp.unstable_now, ahe = pp.unstable_getCurrentPriorityLevel, boe = pp.unstable_ImmediatePriority, rue = pp.unstable_UserBlockingPriority, q9 = pp.unstable_NormalPriority, ihe = pp.unstable_LowPriority, aue = pp.unstable_IdlePriority, TV = null, Ib = null;
function lhe(o) {
  if (Ib && typeof Ib.onCommitFiberRoot == "function") try {
    Ib.onCommitFiberRoot(TV, o, void 0, (o.current.flags & 128) === 128);
  } catch {
  }
}
var sv = Math.clz32 ? Math.clz32 : dhe, che = Math.log, uhe = Math.LN2;
function dhe(o) {
  return o >>>= 0, o === 0 ? 32 : 31 - (che(o) / uhe | 0) | 0;
}
var Kz = 64, Yz = 4194304;
function I5(o) {
  switch (o & -o) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return o & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return o & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return o;
  }
}
function K9(o, a) {
  var c = o.pendingLanes;
  if (c === 0) return 0;
  var f = 0, g = o.suspendedLanes, x = o.pingedLanes, k = c & 268435455;
  if (k !== 0) {
    var A = k & ~g;
    A !== 0 ? f = I5(A) : (x &= k, x !== 0 && (f = I5(x)));
  } else k = c & ~g, k !== 0 ? f = I5(k) : x !== 0 && (f = I5(x));
  if (f === 0) return 0;
  if (a !== 0 && a !== f && !(a & g) && (g = f & -f, x = a & -a, g >= x || g === 16 && (x & 4194240) !== 0)) return a;
  if (f & 4 && (f |= c & 16), a = o.entangledLanes, a !== 0) for (o = o.entanglements, a &= f; 0 < a; ) c = 31 - sv(a), g = 1 << c, f |= o[c], a &= ~g;
  return f;
}
function fhe(o, a) {
  switch (o) {
    case 1:
    case 2:
    case 4:
      return a + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function mhe(o, a) {
  for (var c = o.suspendedLanes, f = o.pingedLanes, g = o.expirationTimes, x = o.pendingLanes; 0 < x; ) {
    var k = 31 - sv(x), A = 1 << k, N = g[k];
    N === -1 ? (!(A & c) || A & f) && (g[k] = fhe(A, a)) : N <= a && (o.expiredLanes |= A), x &= ~A;
  }
}
function Kte(o) {
  return o = o.pendingLanes & -1073741825, o !== 0 ? o : o & 1073741824 ? 1073741824 : 0;
}
function iue() {
  var o = Kz;
  return Kz <<= 1, !(Kz & 4194240) && (Kz = 64), o;
}
function Vee(o) {
  for (var a = [], c = 0; 31 > c; c++) a.push(o);
  return a;
}
function RI(o, a, c) {
  o.pendingLanes |= a, a !== 536870912 && (o.suspendedLanes = 0, o.pingedLanes = 0), o = o.eventTimes, a = 31 - sv(a), o[a] = c;
}
function phe(o, a) {
  var c = o.pendingLanes & ~a;
  o.pendingLanes = a, o.suspendedLanes = 0, o.pingedLanes = 0, o.expiredLanes &= a, o.mutableReadLanes &= a, o.entangledLanes &= a, a = o.entanglements;
  var f = o.eventTimes;
  for (o = o.expirationTimes; 0 < c; ) {
    var g = 31 - sv(c), x = 1 << g;
    a[g] = 0, f[g] = -1, o[g] = -1, c &= ~x;
  }
}
function yoe(o, a) {
  var c = o.entangledLanes |= a;
  for (o = o.entanglements; c; ) {
    var f = 31 - sv(c), g = 1 << f;
    g & a | o[f] & a && (o[f] |= a), c &= ~g;
  }
}
var ri = 0;
function lue(o) {
  return o &= -o, 1 < o ? 4 < o ? o & 268435455 ? 16 : 536870912 : 4 : 1;
}
var cue, xoe, uue, due, fue, Yte = !1, Xz = [], D2 = null, R2 = null, N2 = null, nI = /* @__PURE__ */ new Map(), oI = /* @__PURE__ */ new Map(), _2 = [], hhe = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function nie(o, a) {
  switch (o) {
    case "focusin":
    case "focusout":
      D2 = null;
      break;
    case "dragenter":
    case "dragleave":
      R2 = null;
      break;
    case "mouseover":
    case "mouseout":
      N2 = null;
      break;
    case "pointerover":
    case "pointerout":
      nI.delete(a.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      oI.delete(a.pointerId);
  }
}
function _5(o, a, c, f, g, x) {
  return o === null || o.nativeEvent !== x ? (o = { blockedOn: a, domEventName: c, eventSystemFlags: f, nativeEvent: x, targetContainers: [g] }, a !== null && (a = PI(a), a !== null && xoe(a)), o) : (o.eventSystemFlags |= f, a = o.targetContainers, g !== null && a.indexOf(g) === -1 && a.push(g), o);
}
function ghe(o, a, c, f, g) {
  switch (a) {
    case "focusin":
      return D2 = _5(D2, o, a, c, f, g), !0;
    case "dragenter":
      return R2 = _5(R2, o, a, c, f, g), !0;
    case "mouseover":
      return N2 = _5(N2, o, a, c, f, g), !0;
    case "pointerover":
      var x = g.pointerId;
      return nI.set(x, _5(nI.get(x) || null, o, a, c, f, g)), !0;
    case "gotpointercapture":
      return x = g.pointerId, oI.set(x, _5(oI.get(x) || null, o, a, c, f, g)), !0;
  }
  return !1;
}
function mue(o) {
  var a = Rk(o.target);
  if (a !== null) {
    var c = e_(a);
    if (c !== null) {
      if (a = c.tag, a === 13) {
        if (a = tue(c), a !== null) {
          o.blockedOn = a, fue(o.priority, function() {
            uue(c);
          });
          return;
        }
      } else if (a === 3 && c.stateNode.current.memoizedState.isDehydrated) {
        o.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
        return;
      }
    }
  }
  o.blockedOn = null;
}
function A9(o) {
  if (o.blockedOn !== null) return !1;
  for (var a = o.targetContainers; 0 < a.length; ) {
    var c = Xte(o.domEventName, o.eventSystemFlags, a[0], o.nativeEvent);
    if (c === null) {
      c = o.nativeEvent;
      var f = new c.constructor(c.type, c);
      Wte = f, c.target.dispatchEvent(f), Wte = null;
    } else return a = PI(c), a !== null && xoe(a), o.blockedOn = c, !1;
    a.shift();
  }
  return !0;
}
function oie(o, a, c) {
  A9(o) && c.delete(a);
}
function vhe() {
  Yte = !1, D2 !== null && A9(D2) && (D2 = null), R2 !== null && A9(R2) && (R2 = null), N2 !== null && A9(N2) && (N2 = null), nI.forEach(oie), oI.forEach(oie);
}
function E5(o, a) {
  o.blockedOn === a && (o.blockedOn = null, Yte || (Yte = !0, pp.unstable_scheduleCallback(pp.unstable_NormalPriority, vhe)));
}
function sI(o) {
  function a(g) {
    return E5(g, o);
  }
  if (0 < Xz.length) {
    E5(Xz[0], o);
    for (var c = 1; c < Xz.length; c++) {
      var f = Xz[c];
      f.blockedOn === o && (f.blockedOn = null);
    }
  }
  for (D2 !== null && E5(D2, o), R2 !== null && E5(R2, o), N2 !== null && E5(N2, o), nI.forEach(a), oI.forEach(a), c = 0; c < _2.length; c++) f = _2[c], f.blockedOn === o && (f.blockedOn = null);
  for (; 0 < _2.length && (c = _2[0], c.blockedOn === null); ) mue(c), c.blockedOn === null && _2.shift();
}
var R4 = W0.ReactCurrentBatchConfig, Y9 = !0;
function bhe(o, a, c, f) {
  var g = ri, x = R4.transition;
  R4.transition = null;
  try {
    ri = 1, woe(o, a, c, f);
  } finally {
    ri = g, R4.transition = x;
  }
}
function yhe(o, a, c, f) {
  var g = ri, x = R4.transition;
  R4.transition = null;
  try {
    ri = 4, woe(o, a, c, f);
  } finally {
    ri = g, R4.transition = x;
  }
}
function woe(o, a, c, f) {
  if (Y9) {
    var g = Xte(o, a, c, f);
    if (g === null) Qee(o, a, f, X9, c), nie(o, f);
    else if (ghe(g, o, a, c, f)) f.stopPropagation();
    else if (nie(o, f), a & 4 && -1 < hhe.indexOf(o)) {
      for (; g !== null; ) {
        var x = PI(g);
        if (x !== null && cue(x), x = Xte(o, a, c, f), x === null && Qee(o, a, f, X9, c), x === g) break;
        g = x;
      }
      g !== null && f.stopPropagation();
    } else Qee(o, a, f, null, c);
  }
}
var X9 = null;
function Xte(o, a, c, f) {
  if (X9 = null, o = voe(f), o = Rk(o), o !== null) if (a = e_(o), a === null) o = null;
  else if (c = a.tag, c === 13) {
    if (o = tue(a), o !== null) return o;
    o = null;
  } else if (c === 3) {
    if (a.stateNode.current.memoizedState.isDehydrated) return a.tag === 3 ? a.stateNode.containerInfo : null;
    o = null;
  } else a !== o && (o = null);
  return X9 = o, null;
}
function pue(o) {
  switch (o) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ahe()) {
        case boe:
          return 1;
        case rue:
          return 4;
        case q9:
        case ihe:
          return 16;
        case aue:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var T2 = null, Coe = null, O9 = null;
function hue() {
  if (O9) return O9;
  var o, a = Coe, c = a.length, f, g = "value" in T2 ? T2.value : T2.textContent, x = g.length;
  for (o = 0; o < c && a[o] === g[o]; o++) ;
  var k = c - o;
  for (f = 1; f <= k && a[c - f] === g[x - f]; f++) ;
  return O9 = g.slice(o, 1 < f ? 1 - f : void 0);
}
function D9(o) {
  var a = o.keyCode;
  return "charCode" in o ? (o = o.charCode, o === 0 && a === 13 && (o = 13)) : o = a, o === 10 && (o = 13), 32 <= o || o === 13 ? o : 0;
}
function Qz() {
  return !0;
}
function sie() {
  return !1;
}
function vp(o) {
  function a(c, f, g, x, k) {
    this._reactName = c, this._targetInst = g, this.type = f, this.nativeEvent = x, this.target = k, this.currentTarget = null;
    for (var A in o) o.hasOwnProperty(A) && (c = o[A], this[A] = c ? c(x) : x[A]);
    return this.isDefaultPrevented = (x.defaultPrevented != null ? x.defaultPrevented : x.returnValue === !1) ? Qz : sie, this.isPropagationStopped = sie, this;
  }
  return Fl(a.prototype, { preventDefault: function() {
    this.defaultPrevented = !0;
    var c = this.nativeEvent;
    c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1), this.isDefaultPrevented = Qz);
  }, stopPropagation: function() {
    var c = this.nativeEvent;
    c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0), this.isPropagationStopped = Qz);
  }, persist: function() {
  }, isPersistent: Qz }), a;
}
var nO = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(o) {
  return o.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, Soe = vp(nO), NI = Fl({}, nO, { view: 0, detail: 0 }), xhe = vp(NI), Uee, jee, T5, AV = Fl({}, NI, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: koe, button: 0, buttons: 0, relatedTarget: function(o) {
  return o.relatedTarget === void 0 ? o.fromElement === o.srcElement ? o.toElement : o.fromElement : o.relatedTarget;
}, movementX: function(o) {
  return "movementX" in o ? o.movementX : (o !== T5 && (T5 && o.type === "mousemove" ? (Uee = o.screenX - T5.screenX, jee = o.screenY - T5.screenY) : jee = Uee = 0, T5 = o), Uee);
}, movementY: function(o) {
  return "movementY" in o ? o.movementY : jee;
} }), rie = vp(AV), whe = Fl({}, AV, { dataTransfer: 0 }), Che = vp(whe), She = Fl({}, NI, { relatedTarget: 0 }), Wee = vp(She), khe = Fl({}, nO, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), _he = vp(khe), Ehe = Fl({}, nO, { clipboardData: function(o) {
  return "clipboardData" in o ? o.clipboardData : window.clipboardData;
} }), The = vp(Ehe), Ahe = Fl({}, nO, { data: 0 }), aie = vp(Ahe), Ohe = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Dhe = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Rhe = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Nhe(o) {
  var a = this.nativeEvent;
  return a.getModifierState ? a.getModifierState(o) : (o = Rhe[o]) ? !!a[o] : !1;
}
function koe() {
  return Nhe;
}
var Phe = Fl({}, NI, { key: function(o) {
  if (o.key) {
    var a = Ohe[o.key] || o.key;
    if (a !== "Unidentified") return a;
  }
  return o.type === "keypress" ? (o = D9(o), o === 13 ? "Enter" : String.fromCharCode(o)) : o.type === "keydown" || o.type === "keyup" ? Dhe[o.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: koe, charCode: function(o) {
  return o.type === "keypress" ? D9(o) : 0;
}, keyCode: function(o) {
  return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
}, which: function(o) {
  return o.type === "keypress" ? D9(o) : o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
} }), Mhe = vp(Phe), Ihe = Fl({}, AV, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), iie = vp(Ihe), Fhe = Fl({}, NI, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: koe }), Bhe = vp(Fhe), Lhe = Fl({}, nO, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), $he = vp(Lhe), Hhe = Fl({}, AV, {
  deltaX: function(o) {
    return "deltaX" in o ? o.deltaX : "wheelDeltaX" in o ? -o.wheelDeltaX : 0;
  },
  deltaY: function(o) {
    return "deltaY" in o ? o.deltaY : "wheelDeltaY" in o ? -o.wheelDeltaY : "wheelDelta" in o ? -o.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), zhe = vp(Hhe), Vhe = [9, 13, 27, 32], _oe = F0 && "CompositionEvent" in window, z5 = null;
F0 && "documentMode" in document && (z5 = document.documentMode);
var Uhe = F0 && "TextEvent" in window && !z5, gue = F0 && (!_oe || z5 && 8 < z5 && 11 >= z5), lie = " ", cie = !1;
function vue(o, a) {
  switch (o) {
    case "keyup":
      return Vhe.indexOf(a.keyCode) !== -1;
    case "keydown":
      return a.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function bue(o) {
  return o = o.detail, typeof o == "object" && "data" in o ? o.data : null;
}
var m4 = !1;
function jhe(o, a) {
  switch (o) {
    case "compositionend":
      return bue(a);
    case "keypress":
      return a.which !== 32 ? null : (cie = !0, lie);
    case "textInput":
      return o = a.data, o === lie && cie ? null : o;
    default:
      return null;
  }
}
function Whe(o, a) {
  if (m4) return o === "compositionend" || !_oe && vue(o, a) ? (o = hue(), O9 = Coe = T2 = null, m4 = !1, o) : null;
  switch (o) {
    case "paste":
      return null;
    case "keypress":
      if (!(a.ctrlKey || a.altKey || a.metaKey) || a.ctrlKey && a.altKey) {
        if (a.char && 1 < a.char.length) return a.char;
        if (a.which) return String.fromCharCode(a.which);
      }
      return null;
    case "compositionend":
      return gue && a.locale !== "ko" ? null : a.data;
    default:
      return null;
  }
}
var Zhe = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
function uie(o) {
  var a = o && o.nodeName && o.nodeName.toLowerCase();
  return a === "input" ? !!Zhe[o.type] : a === "textarea";
}
function yue(o, a, c, f) {
  Yce(f), a = Q9(a, "onChange"), 0 < a.length && (c = new Soe("onChange", "change", null, c, f), o.push({ event: c, listeners: a }));
}
var V5 = null, rI = null;
function Ghe(o) {
  Due(o, 0);
}
function OV(o) {
  var a = g4(o);
  if (Uce(a)) return o;
}
function qhe(o, a) {
  if (o === "change") return a;
}
var xue = !1;
if (F0) {
  var Zee;
  if (F0) {
    var Gee = "oninput" in document;
    if (!Gee) {
      var die = document.createElement("div");
      die.setAttribute("oninput", "return;"), Gee = typeof die.oninput == "function";
    }
    Zee = Gee;
  } else Zee = !1;
  xue = Zee && (!document.documentMode || 9 < document.documentMode);
}
function fie() {
  V5 && (V5.detachEvent("onpropertychange", wue), rI = V5 = null);
}
function wue(o) {
  if (o.propertyName === "value" && OV(rI)) {
    var a = [];
    yue(a, rI, o, voe(o)), eue(Ghe, a);
  }
}
function Khe(o, a, c) {
  o === "focusin" ? (fie(), V5 = a, rI = c, V5.attachEvent("onpropertychange", wue)) : o === "focusout" && fie();
}
function Yhe(o) {
  if (o === "selectionchange" || o === "keyup" || o === "keydown") return OV(rI);
}
function Xhe(o, a) {
  if (o === "click") return OV(a);
}
function Qhe(o, a) {
  if (o === "input" || o === "change") return OV(a);
}
function Jhe(o, a) {
  return o === a && (o !== 0 || 1 / o === 1 / a) || o !== o && a !== a;
}
var av = typeof Object.is == "function" ? Object.is : Jhe;
function aI(o, a) {
  if (av(o, a)) return !0;
  if (typeof o != "object" || o === null || typeof a != "object" || a === null) return !1;
  var c = Object.keys(o), f = Object.keys(a);
  if (c.length !== f.length) return !1;
  for (f = 0; f < c.length; f++) {
    var g = c[f];
    if (!Pte.call(a, g) || !av(o[g], a[g])) return !1;
  }
  return !0;
}
function mie(o) {
  for (; o && o.firstChild; ) o = o.firstChild;
  return o;
}
function pie(o, a) {
  var c = mie(o);
  o = 0;
  for (var f; c; ) {
    if (c.nodeType === 3) {
      if (f = o + c.textContent.length, o <= a && f >= a) return { node: c, offset: a - o };
      o = f;
    }
    e: {
      for (; c; ) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break e;
        }
        c = c.parentNode;
      }
      c = void 0;
    }
    c = mie(c);
  }
}
function Cue(o, a) {
  return o && a ? o === a ? !0 : o && o.nodeType === 3 ? !1 : a && a.nodeType === 3 ? Cue(o, a.parentNode) : "contains" in o ? o.contains(a) : o.compareDocumentPosition ? !!(o.compareDocumentPosition(a) & 16) : !1 : !1;
}
function Sue() {
  for (var o = window, a = W9(); a instanceof o.HTMLIFrameElement; ) {
    try {
      var c = typeof a.contentWindow.location.href == "string";
    } catch {
      c = !1;
    }
    if (c) o = a.contentWindow;
    else break;
    a = W9(o.document);
  }
  return a;
}
function Eoe(o) {
  var a = o && o.nodeName && o.nodeName.toLowerCase();
  return a && (a === "input" && (o.type === "text" || o.type === "search" || o.type === "tel" || o.type === "url" || o.type === "password") || a === "textarea" || o.contentEditable === "true");
}
function ege(o) {
  var a = Sue(), c = o.focusedElem, f = o.selectionRange;
  if (a !== c && c && c.ownerDocument && Cue(c.ownerDocument.documentElement, c)) {
    if (f !== null && Eoe(c)) {
      if (a = f.start, o = f.end, o === void 0 && (o = a), "selectionStart" in c) c.selectionStart = a, c.selectionEnd = Math.min(o, c.value.length);
      else if (o = (a = c.ownerDocument || document) && a.defaultView || window, o.getSelection) {
        o = o.getSelection();
        var g = c.textContent.length, x = Math.min(f.start, g);
        f = f.end === void 0 ? x : Math.min(f.end, g), !o.extend && x > f && (g = f, f = x, x = g), g = pie(c, x);
        var k = pie(
          c,
          f
        );
        g && k && (o.rangeCount !== 1 || o.anchorNode !== g.node || o.anchorOffset !== g.offset || o.focusNode !== k.node || o.focusOffset !== k.offset) && (a = a.createRange(), a.setStart(g.node, g.offset), o.removeAllRanges(), x > f ? (o.addRange(a), o.extend(k.node, k.offset)) : (a.setEnd(k.node, k.offset), o.addRange(a)));
      }
    }
    for (a = [], o = c; o = o.parentNode; ) o.nodeType === 1 && a.push({ element: o, left: o.scrollLeft, top: o.scrollTop });
    for (typeof c.focus == "function" && c.focus(), c = 0; c < a.length; c++) o = a[c], o.element.scrollLeft = o.left, o.element.scrollTop = o.top;
  }
}
var tge = F0 && "documentMode" in document && 11 >= document.documentMode, p4 = null, Qte = null, U5 = null, Jte = !1;
function hie(o, a, c) {
  var f = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
  Jte || p4 == null || p4 !== W9(f) || (f = p4, "selectionStart" in f && Eoe(f) ? f = { start: f.selectionStart, end: f.selectionEnd } : (f = (f.ownerDocument && f.ownerDocument.defaultView || window).getSelection(), f = { anchorNode: f.anchorNode, anchorOffset: f.anchorOffset, focusNode: f.focusNode, focusOffset: f.focusOffset }), U5 && aI(U5, f) || (U5 = f, f = Q9(Qte, "onSelect"), 0 < f.length && (a = new Soe("onSelect", "select", null, a, c), o.push({ event: a, listeners: f }), a.target = p4)));
}
function Jz(o, a) {
  var c = {};
  return c[o.toLowerCase()] = a.toLowerCase(), c["Webkit" + o] = "webkit" + a, c["Moz" + o] = "moz" + a, c;
}
var h4 = { animationend: Jz("Animation", "AnimationEnd"), animationiteration: Jz("Animation", "AnimationIteration"), animationstart: Jz("Animation", "AnimationStart"), transitionend: Jz("Transition", "TransitionEnd") }, qee = {}, kue = {};
F0 && (kue = document.createElement("div").style, "AnimationEvent" in window || (delete h4.animationend.animation, delete h4.animationiteration.animation, delete h4.animationstart.animation), "TransitionEvent" in window || delete h4.transitionend.transition);
function DV(o) {
  if (qee[o]) return qee[o];
  if (!h4[o]) return o;
  var a = h4[o], c;
  for (c in a) if (a.hasOwnProperty(c) && c in kue) return qee[o] = a[c];
  return o;
}
var _ue = DV("animationend"), Eue = DV("animationiteration"), Tue = DV("animationstart"), Aue = DV("transitionend"), Oue = /* @__PURE__ */ new Map(), gie = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function Z2(o, a) {
  Oue.set(o, a), Jk(a, [o]);
}
for (var Kee = 0; Kee < gie.length; Kee++) {
  var Yee = gie[Kee], nge = Yee.toLowerCase(), oge = Yee[0].toUpperCase() + Yee.slice(1);
  Z2(nge, "on" + oge);
}
Z2(_ue, "onAnimationEnd");
Z2(Eue, "onAnimationIteration");
Z2(Tue, "onAnimationStart");
Z2("dblclick", "onDoubleClick");
Z2("focusin", "onFocus");
Z2("focusout", "onBlur");
Z2(Aue, "onTransitionEnd");
L4("onMouseEnter", ["mouseout", "mouseover"]);
L4("onMouseLeave", ["mouseout", "mouseover"]);
L4("onPointerEnter", ["pointerout", "pointerover"]);
L4("onPointerLeave", ["pointerout", "pointerover"]);
Jk("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Jk("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Jk("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Jk("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Jk("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Jk("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var F5 = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), sge = new Set("cancel close invalid load scroll toggle".split(" ").concat(F5));
function vie(o, a, c) {
  var f = o.type || "unknown-event";
  o.currentTarget = c, nhe(f, a, void 0, o), o.currentTarget = null;
}
function Due(o, a) {
  a = (a & 4) !== 0;
  for (var c = 0; c < o.length; c++) {
    var f = o[c], g = f.event;
    f = f.listeners;
    e: {
      var x = void 0;
      if (a) for (var k = f.length - 1; 0 <= k; k--) {
        var A = f[k], N = A.instance, H = A.currentTarget;
        if (A = A.listener, N !== x && g.isPropagationStopped()) break e;
        vie(g, A, H), x = N;
      }
      else for (k = 0; k < f.length; k++) {
        if (A = f[k], N = A.instance, H = A.currentTarget, A = A.listener, N !== x && g.isPropagationStopped()) break e;
        vie(g, A, H), x = N;
      }
    }
  }
  if (G9) throw o = qte, G9 = !1, qte = null, o;
}
function rl(o, a) {
  var c = a[sne];
  c === void 0 && (c = a[sne] = /* @__PURE__ */ new Set());
  var f = o + "__bubble";
  c.has(f) || (Rue(a, o, 2, !1), c.add(f));
}
function Xee(o, a, c) {
  var f = 0;
  a && (f |= 4), Rue(c, o, f, a);
}
var e9 = "_reactListening" + Math.random().toString(36).slice(2);
function iI(o) {
  if (!o[e9]) {
    o[e9] = !0, Lce.forEach(function(c) {
      c !== "selectionchange" && (sge.has(c) || Xee(c, !1, o), Xee(c, !0, o));
    });
    var a = o.nodeType === 9 ? o : o.ownerDocument;
    a === null || a[e9] || (a[e9] = !0, Xee("selectionchange", !1, a));
  }
}
function Rue(o, a, c, f) {
  switch (pue(a)) {
    case 1:
      var g = bhe;
      break;
    case 4:
      g = yhe;
      break;
    default:
      g = woe;
  }
  c = g.bind(null, a, c, o), g = void 0, !Gte || a !== "touchstart" && a !== "touchmove" && a !== "wheel" || (g = !0), f ? g !== void 0 ? o.addEventListener(a, c, { capture: !0, passive: g }) : o.addEventListener(a, c, !0) : g !== void 0 ? o.addEventListener(a, c, { passive: g }) : o.addEventListener(a, c, !1);
}
function Qee(o, a, c, f, g) {
  var x = f;
  if (!(a & 1) && !(a & 2) && f !== null) e: for (; ; ) {
    if (f === null) return;
    var k = f.tag;
    if (k === 3 || k === 4) {
      var A = f.stateNode.containerInfo;
      if (A === g || A.nodeType === 8 && A.parentNode === g) break;
      if (k === 4) for (k = f.return; k !== null; ) {
        var N = k.tag;
        if ((N === 3 || N === 4) && (N = k.stateNode.containerInfo, N === g || N.nodeType === 8 && N.parentNode === g)) return;
        k = k.return;
      }
      for (; A !== null; ) {
        if (k = Rk(A), k === null) return;
        if (N = k.tag, N === 5 || N === 6) {
          f = x = k;
          continue e;
        }
        A = A.parentNode;
      }
    }
    f = f.return;
  }
  eue(function() {
    var H = x, Z = voe(c), K = [];
    e: {
      var J = Oue.get(o);
      if (J !== void 0) {
        var pe = Soe, Se = o;
        switch (o) {
          case "keypress":
            if (D9(c) === 0) break e;
          case "keydown":
          case "keyup":
            pe = Mhe;
            break;
          case "focusin":
            Se = "focus", pe = Wee;
            break;
          case "focusout":
            Se = "blur", pe = Wee;
            break;
          case "beforeblur":
          case "afterblur":
            pe = Wee;
            break;
          case "click":
            if (c.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            pe = rie;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            pe = Che;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            pe = Bhe;
            break;
          case _ue:
          case Eue:
          case Tue:
            pe = _he;
            break;
          case Aue:
            pe = $he;
            break;
          case "scroll":
            pe = xhe;
            break;
          case "wheel":
            pe = zhe;
            break;
          case "copy":
          case "cut":
          case "paste":
            pe = The;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            pe = iie;
        }
        var be = (a & 4) !== 0, ye = !be && o === "scroll", re = be ? J !== null ? J + "Capture" : null : J;
        be = [];
        for (var oe = H, U; oe !== null; ) {
          U = oe;
          var ve = U.stateNode;
          if (U.tag === 5 && ve !== null && (U = ve, re !== null && (ve = tI(oe, re), ve != null && be.push(lI(oe, ve, U)))), ye) break;
          oe = oe.return;
        }
        0 < be.length && (J = new pe(J, Se, null, c, Z), K.push({ event: J, listeners: be }));
      }
    }
    if (!(a & 7)) {
      e: {
        if (J = o === "mouseover" || o === "pointerover", pe = o === "mouseout" || o === "pointerout", J && c !== Wte && (Se = c.relatedTarget || c.fromElement) && (Rk(Se) || Se[B0])) break e;
        if ((pe || J) && (J = Z.window === Z ? Z : (J = Z.ownerDocument) ? J.defaultView || J.parentWindow : window, pe ? (Se = c.relatedTarget || c.toElement, pe = H, Se = Se ? Rk(Se) : null, Se !== null && (ye = e_(Se), Se !== ye || Se.tag !== 5 && Se.tag !== 6) && (Se = null)) : (pe = null, Se = H), pe !== Se)) {
          if (be = rie, ve = "onMouseLeave", re = "onMouseEnter", oe = "mouse", (o === "pointerout" || o === "pointerover") && (be = iie, ve = "onPointerLeave", re = "onPointerEnter", oe = "pointer"), ye = pe == null ? J : g4(pe), U = Se == null ? J : g4(Se), J = new be(ve, oe + "leave", pe, c, Z), J.target = ye, J.relatedTarget = U, ve = null, Rk(Z) === H && (be = new be(re, oe + "enter", Se, c, Z), be.target = U, be.relatedTarget = ye, ve = be), ye = ve, pe && Se) t: {
            for (be = pe, re = Se, oe = 0, U = be; U; U = a4(U)) oe++;
            for (U = 0, ve = re; ve; ve = a4(ve)) U++;
            for (; 0 < oe - U; ) be = a4(be), oe--;
            for (; 0 < U - oe; ) re = a4(re), U--;
            for (; oe--; ) {
              if (be === re || re !== null && be === re.alternate) break t;
              be = a4(be), re = a4(re);
            }
            be = null;
          }
          else be = null;
          pe !== null && bie(K, J, pe, be, !1), Se !== null && ye !== null && bie(K, ye, Se, be, !0);
        }
      }
      e: {
        if (J = H ? g4(H) : window, pe = J.nodeName && J.nodeName.toLowerCase(), pe === "select" || pe === "input" && J.type === "file") var Ze = qhe;
        else if (uie(J)) if (xue) Ze = Qhe;
        else {
          Ze = Yhe;
          var rt = Khe;
        }
        else (pe = J.nodeName) && pe.toLowerCase() === "input" && (J.type === "checkbox" || J.type === "radio") && (Ze = Xhe);
        if (Ze && (Ze = Ze(o, H))) {
          yue(K, Ze, c, Z);
          break e;
        }
        rt && rt(o, J, H), o === "focusout" && (rt = J._wrapperState) && rt.controlled && J.type === "number" && Hte(J, "number", J.value);
      }
      switch (rt = H ? g4(H) : window, o) {
        case "focusin":
          (uie(rt) || rt.contentEditable === "true") && (p4 = rt, Qte = H, U5 = null);
          break;
        case "focusout":
          U5 = Qte = p4 = null;
          break;
        case "mousedown":
          Jte = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Jte = !1, hie(K, c, Z);
          break;
        case "selectionchange":
          if (tge) break;
        case "keydown":
        case "keyup":
          hie(K, c, Z);
      }
      var ee;
      if (_oe) e: {
        switch (o) {
          case "compositionstart":
            var lt = "onCompositionStart";
            break e;
          case "compositionend":
            lt = "onCompositionEnd";
            break e;
          case "compositionupdate":
            lt = "onCompositionUpdate";
            break e;
        }
        lt = void 0;
      }
      else m4 ? vue(o, c) && (lt = "onCompositionEnd") : o === "keydown" && c.keyCode === 229 && (lt = "onCompositionStart");
      lt && (gue && c.locale !== "ko" && (m4 || lt !== "onCompositionStart" ? lt === "onCompositionEnd" && m4 && (ee = hue()) : (T2 = Z, Coe = "value" in T2 ? T2.value : T2.textContent, m4 = !0)), rt = Q9(H, lt), 0 < rt.length && (lt = new aie(lt, o, null, c, Z), K.push({ event: lt, listeners: rt }), ee ? lt.data = ee : (ee = bue(c), ee !== null && (lt.data = ee)))), (ee = Uhe ? jhe(o, c) : Whe(o, c)) && (H = Q9(H, "onBeforeInput"), 0 < H.length && (Z = new aie("onBeforeInput", "beforeinput", null, c, Z), K.push({ event: Z, listeners: H }), Z.data = ee));
    }
    Due(K, a);
  });
}
function lI(o, a, c) {
  return { instance: o, listener: a, currentTarget: c };
}
function Q9(o, a) {
  for (var c = a + "Capture", f = []; o !== null; ) {
    var g = o, x = g.stateNode;
    g.tag === 5 && x !== null && (g = x, x = tI(o, c), x != null && f.unshift(lI(o, x, g)), x = tI(o, a), x != null && f.push(lI(o, x, g))), o = o.return;
  }
  return f;
}
function a4(o) {
  if (o === null) return null;
  do
    o = o.return;
  while (o && o.tag !== 5);
  return o || null;
}
function bie(o, a, c, f, g) {
  for (var x = a._reactName, k = []; c !== null && c !== f; ) {
    var A = c, N = A.alternate, H = A.stateNode;
    if (N !== null && N === f) break;
    A.tag === 5 && H !== null && (A = H, g ? (N = tI(c, x), N != null && k.unshift(lI(c, N, A))) : g || (N = tI(c, x), N != null && k.push(lI(c, N, A)))), c = c.return;
  }
  k.length !== 0 && o.push({ event: a, listeners: k });
}
var rge = /\r\n?/g, age = /\u0000|\uFFFD/g;
function yie(o) {
  return (typeof o == "string" ? o : "" + o).replace(rge, `
`).replace(age, "");
}
function t9(o, a, c) {
  if (a = yie(a), yie(o) !== a && c) throw Error(no(425));
}
function J9() {
}
var ene = null, tne = null;
function nne(o, a) {
  return o === "textarea" || o === "noscript" || typeof a.children == "string" || typeof a.children == "number" || typeof a.dangerouslySetInnerHTML == "object" && a.dangerouslySetInnerHTML !== null && a.dangerouslySetInnerHTML.__html != null;
}
var one = typeof setTimeout == "function" ? setTimeout : void 0, ige = typeof clearTimeout == "function" ? clearTimeout : void 0, xie = typeof Promise == "function" ? Promise : void 0, lge = typeof queueMicrotask == "function" ? queueMicrotask : typeof xie < "u" ? function(o) {
  return xie.resolve(null).then(o).catch(cge);
} : one;
function cge(o) {
  setTimeout(function() {
    throw o;
  });
}
function Jee(o, a) {
  var c = a, f = 0;
  do {
    var g = c.nextSibling;
    if (o.removeChild(c), g && g.nodeType === 8) if (c = g.data, c === "/$") {
      if (f === 0) {
        o.removeChild(g), sI(a);
        return;
      }
      f--;
    } else c !== "$" && c !== "$?" && c !== "$!" || f++;
    c = g;
  } while (c);
  sI(a);
}
function P2(o) {
  for (; o != null; o = o.nextSibling) {
    var a = o.nodeType;
    if (a === 1 || a === 3) break;
    if (a === 8) {
      if (a = o.data, a === "$" || a === "$!" || a === "$?") break;
      if (a === "/$") return null;
    }
  }
  return o;
}
function wie(o) {
  o = o.previousSibling;
  for (var a = 0; o; ) {
    if (o.nodeType === 8) {
      var c = o.data;
      if (c === "$" || c === "$!" || c === "$?") {
        if (a === 0) return o;
        a--;
      } else c === "/$" && a++;
    }
    o = o.previousSibling;
  }
  return null;
}
var oO = Math.random().toString(36).slice(2), Nb = "__reactFiber$" + oO, cI = "__reactProps$" + oO, B0 = "__reactContainer$" + oO, sne = "__reactEvents$" + oO, uge = "__reactListeners$" + oO, dge = "__reactHandles$" + oO;
function Rk(o) {
  var a = o[Nb];
  if (a) return a;
  for (var c = o.parentNode; c; ) {
    if (a = c[B0] || c[Nb]) {
      if (c = a.alternate, a.child !== null || c !== null && c.child !== null) for (o = wie(o); o !== null; ) {
        if (c = o[Nb]) return c;
        o = wie(o);
      }
      return a;
    }
    o = c, c = o.parentNode;
  }
  return null;
}
function PI(o) {
  return o = o[Nb] || o[B0], !o || o.tag !== 5 && o.tag !== 6 && o.tag !== 13 && o.tag !== 3 ? null : o;
}
function g4(o) {
  if (o.tag === 5 || o.tag === 6) return o.stateNode;
  throw Error(no(33));
}
function RV(o) {
  return o[cI] || null;
}
var rne = [], v4 = -1;
function G2(o) {
  return { current: o };
}
function il(o) {
  0 > v4 || (o.current = rne[v4], rne[v4] = null, v4--);
}
function Ui(o, a) {
  v4++, rne[v4] = o.current, o.current = a;
}
var z2 = {}, Kd = G2(z2), Cm = G2(!1), jk = z2;
function $4(o, a) {
  var c = o.type.contextTypes;
  if (!c) return z2;
  var f = o.stateNode;
  if (f && f.__reactInternalMemoizedUnmaskedChildContext === a) return f.__reactInternalMemoizedMaskedChildContext;
  var g = {}, x;
  for (x in c) g[x] = a[x];
  return f && (o = o.stateNode, o.__reactInternalMemoizedUnmaskedChildContext = a, o.__reactInternalMemoizedMaskedChildContext = g), g;
}
function Sm(o) {
  return o = o.childContextTypes, o != null;
}
function eV() {
  il(Cm), il(Kd);
}
function Cie(o, a, c) {
  if (Kd.current !== z2) throw Error(no(168));
  Ui(Kd, a), Ui(Cm, c);
}
function Nue(o, a, c) {
  var f = o.stateNode;
  if (a = a.childContextTypes, typeof f.getChildContext != "function") return c;
  f = f.getChildContext();
  for (var g in f) if (!(g in a)) throw Error(no(108, Kpe(o) || "Unknown", g));
  return Fl({}, c, f);
}
function tV(o) {
  return o = (o = o.stateNode) && o.__reactInternalMemoizedMergedChildContext || z2, jk = Kd.current, Ui(Kd, o), Ui(Cm, Cm.current), !0;
}
function Sie(o, a, c) {
  var f = o.stateNode;
  if (!f) throw Error(no(169));
  c ? (o = Nue(o, a, jk), f.__reactInternalMemoizedMergedChildContext = o, il(Cm), il(Kd), Ui(Kd, o)) : il(Cm), Ui(Cm, c);
}
var R0 = null, NV = !1, ete = !1;
function Pue(o) {
  R0 === null ? R0 = [o] : R0.push(o);
}
function fge(o) {
  NV = !0, Pue(o);
}
function q2() {
  if (!ete && R0 !== null) {
    ete = !0;
    var o = 0, a = ri;
    try {
      var c = R0;
      for (ri = 1; o < c.length; o++) {
        var f = c[o];
        do
          f = f(!0);
        while (f !== null);
      }
      R0 = null, NV = !1;
    } catch (g) {
      throw R0 !== null && (R0 = R0.slice(o + 1)), sue(boe, q2), g;
    } finally {
      ri = a, ete = !1;
    }
  }
  return null;
}
var b4 = [], y4 = 0, nV = null, oV = 0, Rh = [], Nh = 0, Wk = null, P0 = 1, M0 = "";
function Tk(o, a) {
  b4[y4++] = oV, b4[y4++] = nV, nV = o, oV = a;
}
function Mue(o, a, c) {
  Rh[Nh++] = P0, Rh[Nh++] = M0, Rh[Nh++] = Wk, Wk = o;
  var f = P0;
  o = M0;
  var g = 32 - sv(f) - 1;
  f &= ~(1 << g), c += 1;
  var x = 32 - sv(a) + g;
  if (30 < x) {
    var k = g - g % 5;
    x = (f & (1 << k) - 1).toString(32), f >>= k, g -= k, P0 = 1 << 32 - sv(a) + g | c << g | f, M0 = x + o;
  } else P0 = 1 << x | c << g | f, M0 = o;
}
function Toe(o) {
  o.return !== null && (Tk(o, 1), Mue(o, 1, 0));
}
function Aoe(o) {
  for (; o === nV; ) nV = b4[--y4], b4[y4] = null, oV = b4[--y4], b4[y4] = null;
  for (; o === Wk; ) Wk = Rh[--Nh], Rh[Nh] = null, M0 = Rh[--Nh], Rh[Nh] = null, P0 = Rh[--Nh], Rh[Nh] = null;
}
var mp = null, fp = null, xl = !1, nv = null;
function Iue(o, a) {
  var c = Ph(5, null, null, 0);
  c.elementType = "DELETED", c.stateNode = a, c.return = o, a = o.deletions, a === null ? (o.deletions = [c], o.flags |= 16) : a.push(c);
}
function kie(o, a) {
  switch (o.tag) {
    case 5:
      var c = o.type;
      return a = a.nodeType !== 1 || c.toLowerCase() !== a.nodeName.toLowerCase() ? null : a, a !== null ? (o.stateNode = a, mp = o, fp = P2(a.firstChild), !0) : !1;
    case 6:
      return a = o.pendingProps === "" || a.nodeType !== 3 ? null : a, a !== null ? (o.stateNode = a, mp = o, fp = null, !0) : !1;
    case 13:
      return a = a.nodeType !== 8 ? null : a, a !== null ? (c = Wk !== null ? { id: P0, overflow: M0 } : null, o.memoizedState = { dehydrated: a, treeContext: c, retryLane: 1073741824 }, c = Ph(18, null, null, 0), c.stateNode = a, c.return = o, o.child = c, mp = o, fp = null, !0) : !1;
    default:
      return !1;
  }
}
function ane(o) {
  return (o.mode & 1) !== 0 && (o.flags & 128) === 0;
}
function ine(o) {
  if (xl) {
    var a = fp;
    if (a) {
      var c = a;
      if (!kie(o, a)) {
        if (ane(o)) throw Error(no(418));
        a = P2(c.nextSibling);
        var f = mp;
        a && kie(o, a) ? Iue(f, c) : (o.flags = o.flags & -4097 | 2, xl = !1, mp = o);
      }
    } else {
      if (ane(o)) throw Error(no(418));
      o.flags = o.flags & -4097 | 2, xl = !1, mp = o;
    }
  }
}
function _ie(o) {
  for (o = o.return; o !== null && o.tag !== 5 && o.tag !== 3 && o.tag !== 13; ) o = o.return;
  mp = o;
}
function n9(o) {
  if (o !== mp) return !1;
  if (!xl) return _ie(o), xl = !0, !1;
  var a;
  if ((a = o.tag !== 3) && !(a = o.tag !== 5) && (a = o.type, a = a !== "head" && a !== "body" && !nne(o.type, o.memoizedProps)), a && (a = fp)) {
    if (ane(o)) throw Fue(), Error(no(418));
    for (; a; ) Iue(o, a), a = P2(a.nextSibling);
  }
  if (_ie(o), o.tag === 13) {
    if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(no(317));
    e: {
      for (o = o.nextSibling, a = 0; o; ) {
        if (o.nodeType === 8) {
          var c = o.data;
          if (c === "/$") {
            if (a === 0) {
              fp = P2(o.nextSibling);
              break e;
            }
            a--;
          } else c !== "$" && c !== "$!" && c !== "$?" || a++;
        }
        o = o.nextSibling;
      }
      fp = null;
    }
  } else fp = mp ? P2(o.stateNode.nextSibling) : null;
  return !0;
}
function Fue() {
  for (var o = fp; o; ) o = P2(o.nextSibling);
}
function H4() {
  fp = mp = null, xl = !1;
}
function Ooe(o) {
  nv === null ? nv = [o] : nv.push(o);
}
var mge = W0.ReactCurrentBatchConfig;
function A5(o, a, c) {
  if (o = c.ref, o !== null && typeof o != "function" && typeof o != "object") {
    if (c._owner) {
      if (c = c._owner, c) {
        if (c.tag !== 1) throw Error(no(309));
        var f = c.stateNode;
      }
      if (!f) throw Error(no(147, o));
      var g = f, x = "" + o;
      return a !== null && a.ref !== null && typeof a.ref == "function" && a.ref._stringRef === x ? a.ref : (a = function(k) {
        var A = g.refs;
        k === null ? delete A[x] : A[x] = k;
      }, a._stringRef = x, a);
    }
    if (typeof o != "string") throw Error(no(284));
    if (!c._owner) throw Error(no(290, o));
  }
  return o;
}
function o9(o, a) {
  throw o = Object.prototype.toString.call(a), Error(no(31, o === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : o));
}
function Eie(o) {
  var a = o._init;
  return a(o._payload);
}
function Bue(o) {
  function a(re, oe) {
    if (o) {
      var U = re.deletions;
      U === null ? (re.deletions = [oe], re.flags |= 16) : U.push(oe);
    }
  }
  function c(re, oe) {
    if (!o) return null;
    for (; oe !== null; ) a(re, oe), oe = oe.sibling;
    return null;
  }
  function f(re, oe) {
    for (re = /* @__PURE__ */ new Map(); oe !== null; ) oe.key !== null ? re.set(oe.key, oe) : re.set(oe.index, oe), oe = oe.sibling;
    return re;
  }
  function g(re, oe) {
    return re = B2(re, oe), re.index = 0, re.sibling = null, re;
  }
  function x(re, oe, U) {
    return re.index = U, o ? (U = re.alternate, U !== null ? (U = U.index, U < oe ? (re.flags |= 2, oe) : U) : (re.flags |= 2, oe)) : (re.flags |= 1048576, oe);
  }
  function k(re) {
    return o && re.alternate === null && (re.flags |= 2), re;
  }
  function A(re, oe, U, ve) {
    return oe === null || oe.tag !== 6 ? (oe = ite(U, re.mode, ve), oe.return = re, oe) : (oe = g(oe, U), oe.return = re, oe);
  }
  function N(re, oe, U, ve) {
    var Ze = U.type;
    return Ze === f4 ? Z(re, oe, U.props.children, ve, U.key) : oe !== null && (oe.elementType === Ze || typeof Ze == "object" && Ze !== null && Ze.$$typeof === C2 && Eie(Ze) === oe.type) ? (ve = g(oe, U.props), ve.ref = A5(re, oe, U), ve.return = re, ve) : (ve = B9(U.type, U.key, U.props, null, re.mode, ve), ve.ref = A5(re, oe, U), ve.return = re, ve);
  }
  function H(re, oe, U, ve) {
    return oe === null || oe.tag !== 4 || oe.stateNode.containerInfo !== U.containerInfo || oe.stateNode.implementation !== U.implementation ? (oe = lte(U, re.mode, ve), oe.return = re, oe) : (oe = g(oe, U.children || []), oe.return = re, oe);
  }
  function Z(re, oe, U, ve, Ze) {
    return oe === null || oe.tag !== 7 ? (oe = Hk(U, re.mode, ve, Ze), oe.return = re, oe) : (oe = g(oe, U), oe.return = re, oe);
  }
  function K(re, oe, U) {
    if (typeof oe == "string" && oe !== "" || typeof oe == "number") return oe = ite("" + oe, re.mode, U), oe.return = re, oe;
    if (typeof oe == "object" && oe !== null) {
      switch (oe.$$typeof) {
        case Zz:
          return U = B9(oe.type, oe.key, oe.props, null, re.mode, U), U.ref = A5(re, null, oe), U.return = re, U;
        case d4:
          return oe = lte(oe, re.mode, U), oe.return = re, oe;
        case C2:
          var ve = oe._init;
          return K(re, ve(oe._payload), U);
      }
      if (M5(oe) || S5(oe)) return oe = Hk(oe, re.mode, U, null), oe.return = re, oe;
      o9(re, oe);
    }
    return null;
  }
  function J(re, oe, U, ve) {
    var Ze = oe !== null ? oe.key : null;
    if (typeof U == "string" && U !== "" || typeof U == "number") return Ze !== null ? null : A(re, oe, "" + U, ve);
    if (typeof U == "object" && U !== null) {
      switch (U.$$typeof) {
        case Zz:
          return U.key === Ze ? N(re, oe, U, ve) : null;
        case d4:
          return U.key === Ze ? H(re, oe, U, ve) : null;
        case C2:
          return Ze = U._init, J(
            re,
            oe,
            Ze(U._payload),
            ve
          );
      }
      if (M5(U) || S5(U)) return Ze !== null ? null : Z(re, oe, U, ve, null);
      o9(re, U);
    }
    return null;
  }
  function pe(re, oe, U, ve, Ze) {
    if (typeof ve == "string" && ve !== "" || typeof ve == "number") return re = re.get(U) || null, A(oe, re, "" + ve, Ze);
    if (typeof ve == "object" && ve !== null) {
      switch (ve.$$typeof) {
        case Zz:
          return re = re.get(ve.key === null ? U : ve.key) || null, N(oe, re, ve, Ze);
        case d4:
          return re = re.get(ve.key === null ? U : ve.key) || null, H(oe, re, ve, Ze);
        case C2:
          var rt = ve._init;
          return pe(re, oe, U, rt(ve._payload), Ze);
      }
      if (M5(ve) || S5(ve)) return re = re.get(U) || null, Z(oe, re, ve, Ze, null);
      o9(oe, ve);
    }
    return null;
  }
  function Se(re, oe, U, ve) {
    for (var Ze = null, rt = null, ee = oe, lt = oe = 0, wt = null; ee !== null && lt < U.length; lt++) {
      ee.index > lt ? (wt = ee, ee = null) : wt = ee.sibling;
      var Vt = J(re, ee, U[lt], ve);
      if (Vt === null) {
        ee === null && (ee = wt);
        break;
      }
      o && ee && Vt.alternate === null && a(re, ee), oe = x(Vt, oe, lt), rt === null ? Ze = Vt : rt.sibling = Vt, rt = Vt, ee = wt;
    }
    if (lt === U.length) return c(re, ee), xl && Tk(re, lt), Ze;
    if (ee === null) {
      for (; lt < U.length; lt++) ee = K(re, U[lt], ve), ee !== null && (oe = x(ee, oe, lt), rt === null ? Ze = ee : rt.sibling = ee, rt = ee);
      return xl && Tk(re, lt), Ze;
    }
    for (ee = f(re, ee); lt < U.length; lt++) wt = pe(ee, re, lt, U[lt], ve), wt !== null && (o && wt.alternate !== null && ee.delete(wt.key === null ? lt : wt.key), oe = x(wt, oe, lt), rt === null ? Ze = wt : rt.sibling = wt, rt = wt);
    return o && ee.forEach(function(Ue) {
      return a(re, Ue);
    }), xl && Tk(re, lt), Ze;
  }
  function be(re, oe, U, ve) {
    var Ze = S5(U);
    if (typeof Ze != "function") throw Error(no(150));
    if (U = Ze.call(U), U == null) throw Error(no(151));
    for (var rt = Ze = null, ee = oe, lt = oe = 0, wt = null, Vt = U.next(); ee !== null && !Vt.done; lt++, Vt = U.next()) {
      ee.index > lt ? (wt = ee, ee = null) : wt = ee.sibling;
      var Ue = J(re, ee, Vt.value, ve);
      if (Ue === null) {
        ee === null && (ee = wt);
        break;
      }
      o && ee && Ue.alternate === null && a(re, ee), oe = x(Ue, oe, lt), rt === null ? Ze = Ue : rt.sibling = Ue, rt = Ue, ee = wt;
    }
    if (Vt.done) return c(
      re,
      ee
    ), xl && Tk(re, lt), Ze;
    if (ee === null) {
      for (; !Vt.done; lt++, Vt = U.next()) Vt = K(re, Vt.value, ve), Vt !== null && (oe = x(Vt, oe, lt), rt === null ? Ze = Vt : rt.sibling = Vt, rt = Vt);
      return xl && Tk(re, lt), Ze;
    }
    for (ee = f(re, ee); !Vt.done; lt++, Vt = U.next()) Vt = pe(ee, re, lt, Vt.value, ve), Vt !== null && (o && Vt.alternate !== null && ee.delete(Vt.key === null ? lt : Vt.key), oe = x(Vt, oe, lt), rt === null ? Ze = Vt : rt.sibling = Vt, rt = Vt);
    return o && ee.forEach(function(Ce) {
      return a(re, Ce);
    }), xl && Tk(re, lt), Ze;
  }
  function ye(re, oe, U, ve) {
    if (typeof U == "object" && U !== null && U.type === f4 && U.key === null && (U = U.props.children), typeof U == "object" && U !== null) {
      switch (U.$$typeof) {
        case Zz:
          e: {
            for (var Ze = U.key, rt = oe; rt !== null; ) {
              if (rt.key === Ze) {
                if (Ze = U.type, Ze === f4) {
                  if (rt.tag === 7) {
                    c(re, rt.sibling), oe = g(rt, U.props.children), oe.return = re, re = oe;
                    break e;
                  }
                } else if (rt.elementType === Ze || typeof Ze == "object" && Ze !== null && Ze.$$typeof === C2 && Eie(Ze) === rt.type) {
                  c(re, rt.sibling), oe = g(rt, U.props), oe.ref = A5(re, rt, U), oe.return = re, re = oe;
                  break e;
                }
                c(re, rt);
                break;
              } else a(re, rt);
              rt = rt.sibling;
            }
            U.type === f4 ? (oe = Hk(U.props.children, re.mode, ve, U.key), oe.return = re, re = oe) : (ve = B9(U.type, U.key, U.props, null, re.mode, ve), ve.ref = A5(re, oe, U), ve.return = re, re = ve);
          }
          return k(re);
        case d4:
          e: {
            for (rt = U.key; oe !== null; ) {
              if (oe.key === rt) if (oe.tag === 4 && oe.stateNode.containerInfo === U.containerInfo && oe.stateNode.implementation === U.implementation) {
                c(re, oe.sibling), oe = g(oe, U.children || []), oe.return = re, re = oe;
                break e;
              } else {
                c(re, oe);
                break;
              }
              else a(re, oe);
              oe = oe.sibling;
            }
            oe = lte(U, re.mode, ve), oe.return = re, re = oe;
          }
          return k(re);
        case C2:
          return rt = U._init, ye(re, oe, rt(U._payload), ve);
      }
      if (M5(U)) return Se(re, oe, U, ve);
      if (S5(U)) return be(re, oe, U, ve);
      o9(re, U);
    }
    return typeof U == "string" && U !== "" || typeof U == "number" ? (U = "" + U, oe !== null && oe.tag === 6 ? (c(re, oe.sibling), oe = g(oe, U), oe.return = re, re = oe) : (c(re, oe), oe = ite(U, re.mode, ve), oe.return = re, re = oe), k(re)) : c(re, oe);
  }
  return ye;
}
var z4 = Bue(!0), Lue = Bue(!1), sV = G2(null), rV = null, x4 = null, Doe = null;
function Roe() {
  Doe = x4 = rV = null;
}
function Noe(o) {
  var a = sV.current;
  il(sV), o._currentValue = a;
}
function lne(o, a, c) {
  for (; o !== null; ) {
    var f = o.alternate;
    if ((o.childLanes & a) !== a ? (o.childLanes |= a, f !== null && (f.childLanes |= a)) : f !== null && (f.childLanes & a) !== a && (f.childLanes |= a), o === c) break;
    o = o.return;
  }
}
function N4(o, a) {
  rV = o, Doe = x4 = null, o = o.dependencies, o !== null && o.firstContext !== null && (o.lanes & a && (wm = !0), o.firstContext = null);
}
function Fh(o) {
  var a = o._currentValue;
  if (Doe !== o) if (o = { context: o, memoizedValue: a, next: null }, x4 === null) {
    if (rV === null) throw Error(no(308));
    x4 = o, rV.dependencies = { lanes: 0, firstContext: o };
  } else x4 = x4.next = o;
  return a;
}
var Nk = null;
function Poe(o) {
  Nk === null ? Nk = [o] : Nk.push(o);
}
function $ue(o, a, c, f) {
  var g = a.interleaved;
  return g === null ? (c.next = c, Poe(a)) : (c.next = g.next, g.next = c), a.interleaved = c, L0(o, f);
}
function L0(o, a) {
  o.lanes |= a;
  var c = o.alternate;
  for (c !== null && (c.lanes |= a), c = o, o = o.return; o !== null; ) o.childLanes |= a, c = o.alternate, c !== null && (c.childLanes |= a), c = o, o = o.return;
  return c.tag === 3 ? c.stateNode : null;
}
var S2 = !1;
function Moe(o) {
  o.updateQueue = { baseState: o.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function Hue(o, a) {
  o = o.updateQueue, a.updateQueue === o && (a.updateQueue = { baseState: o.baseState, firstBaseUpdate: o.firstBaseUpdate, lastBaseUpdate: o.lastBaseUpdate, shared: o.shared, effects: o.effects });
}
function I0(o, a) {
  return { eventTime: o, lane: a, tag: 0, payload: null, callback: null, next: null };
}
function M2(o, a, c) {
  var f = o.updateQueue;
  if (f === null) return null;
  if (f = f.shared, Sa & 2) {
    var g = f.pending;
    return g === null ? a.next = a : (a.next = g.next, g.next = a), f.pending = a, L0(o, c);
  }
  return g = f.interleaved, g === null ? (a.next = a, Poe(f)) : (a.next = g.next, g.next = a), f.interleaved = a, L0(o, c);
}
function R9(o, a, c) {
  if (a = a.updateQueue, a !== null && (a = a.shared, (c & 4194240) !== 0)) {
    var f = a.lanes;
    f &= o.pendingLanes, c |= f, a.lanes = c, yoe(o, c);
  }
}
function Tie(o, a) {
  var c = o.updateQueue, f = o.alternate;
  if (f !== null && (f = f.updateQueue, c === f)) {
    var g = null, x = null;
    if (c = c.firstBaseUpdate, c !== null) {
      do {
        var k = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
        x === null ? g = x = k : x = x.next = k, c = c.next;
      } while (c !== null);
      x === null ? g = x = a : x = x.next = a;
    } else g = x = a;
    c = { baseState: f.baseState, firstBaseUpdate: g, lastBaseUpdate: x, shared: f.shared, effects: f.effects }, o.updateQueue = c;
    return;
  }
  o = c.lastBaseUpdate, o === null ? c.firstBaseUpdate = a : o.next = a, c.lastBaseUpdate = a;
}
function aV(o, a, c, f) {
  var g = o.updateQueue;
  S2 = !1;
  var x = g.firstBaseUpdate, k = g.lastBaseUpdate, A = g.shared.pending;
  if (A !== null) {
    g.shared.pending = null;
    var N = A, H = N.next;
    N.next = null, k === null ? x = H : k.next = H, k = N;
    var Z = o.alternate;
    Z !== null && (Z = Z.updateQueue, A = Z.lastBaseUpdate, A !== k && (A === null ? Z.firstBaseUpdate = H : A.next = H, Z.lastBaseUpdate = N));
  }
  if (x !== null) {
    var K = g.baseState;
    k = 0, Z = H = N = null, A = x;
    do {
      var J = A.lane, pe = A.eventTime;
      if ((f & J) === J) {
        Z !== null && (Z = Z.next = {
          eventTime: pe,
          lane: 0,
          tag: A.tag,
          payload: A.payload,
          callback: A.callback,
          next: null
        });
        e: {
          var Se = o, be = A;
          switch (J = a, pe = c, be.tag) {
            case 1:
              if (Se = be.payload, typeof Se == "function") {
                K = Se.call(pe, K, J);
                break e;
              }
              K = Se;
              break e;
            case 3:
              Se.flags = Se.flags & -65537 | 128;
            case 0:
              if (Se = be.payload, J = typeof Se == "function" ? Se.call(pe, K, J) : Se, J == null) break e;
              K = Fl({}, K, J);
              break e;
            case 2:
              S2 = !0;
          }
        }
        A.callback !== null && A.lane !== 0 && (o.flags |= 64, J = g.effects, J === null ? g.effects = [A] : J.push(A));
      } else pe = { eventTime: pe, lane: J, tag: A.tag, payload: A.payload, callback: A.callback, next: null }, Z === null ? (H = Z = pe, N = K) : Z = Z.next = pe, k |= J;
      if (A = A.next, A === null) {
        if (A = g.shared.pending, A === null) break;
        J = A, A = J.next, J.next = null, g.lastBaseUpdate = J, g.shared.pending = null;
      }
    } while (!0);
    if (Z === null && (N = K), g.baseState = N, g.firstBaseUpdate = H, g.lastBaseUpdate = Z, a = g.shared.interleaved, a !== null) {
      g = a;
      do
        k |= g.lane, g = g.next;
      while (g !== a);
    } else x === null && (g.shared.lanes = 0);
    Gk |= k, o.lanes = k, o.memoizedState = K;
  }
}
function Aie(o, a, c) {
  if (o = a.effects, a.effects = null, o !== null) for (a = 0; a < o.length; a++) {
    var f = o[a], g = f.callback;
    if (g !== null) {
      if (f.callback = null, f = c, typeof g != "function") throw Error(no(191, g));
      g.call(f);
    }
  }
}
var MI = {}, Fb = G2(MI), uI = G2(MI), dI = G2(MI);
function Pk(o) {
  if (o === MI) throw Error(no(174));
  return o;
}
function Ioe(o, a) {
  switch (Ui(dI, a), Ui(uI, o), Ui(Fb, MI), o = a.nodeType, o) {
    case 9:
    case 11:
      a = (a = a.documentElement) ? a.namespaceURI : Vte(null, "");
      break;
    default:
      o = o === 8 ? a.parentNode : a, a = o.namespaceURI || null, o = o.tagName, a = Vte(a, o);
  }
  il(Fb), Ui(Fb, a);
}
function V4() {
  il(Fb), il(uI), il(dI);
}
function zue(o) {
  Pk(dI.current);
  var a = Pk(Fb.current), c = Vte(a, o.type);
  a !== c && (Ui(uI, o), Ui(Fb, c));
}
function Foe(o) {
  uI.current === o && (il(Fb), il(uI));
}
var Ml = G2(0);
function iV(o) {
  for (var a = o; a !== null; ) {
    if (a.tag === 13) {
      var c = a.memoizedState;
      if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || c.data === "$!")) return a;
    } else if (a.tag === 19 && a.memoizedProps.revealOrder !== void 0) {
      if (a.flags & 128) return a;
    } else if (a.child !== null) {
      a.child.return = a, a = a.child;
      continue;
    }
    if (a === o) break;
    for (; a.sibling === null; ) {
      if (a.return === null || a.return === o) return null;
      a = a.return;
    }
    a.sibling.return = a.return, a = a.sibling;
  }
  return null;
}
var tte = [];
function Boe() {
  for (var o = 0; o < tte.length; o++) tte[o]._workInProgressVersionPrimary = null;
  tte.length = 0;
}
var N9 = W0.ReactCurrentDispatcher, nte = W0.ReactCurrentBatchConfig, Zk = 0, Il = null, iu = null, Pu = null, lV = !1, j5 = !1, fI = 0, pge = 0;
function Vd() {
  throw Error(no(321));
}
function Loe(o, a) {
  if (a === null) return !1;
  for (var c = 0; c < a.length && c < o.length; c++) if (!av(o[c], a[c])) return !1;
  return !0;
}
function $oe(o, a, c, f, g, x) {
  if (Zk = x, Il = a, a.memoizedState = null, a.updateQueue = null, a.lanes = 0, N9.current = o === null || o.memoizedState === null ? bge : yge, o = c(f, g), j5) {
    x = 0;
    do {
      if (j5 = !1, fI = 0, 25 <= x) throw Error(no(301));
      x += 1, Pu = iu = null, a.updateQueue = null, N9.current = xge, o = c(f, g);
    } while (j5);
  }
  if (N9.current = cV, a = iu !== null && iu.next !== null, Zk = 0, Pu = iu = Il = null, lV = !1, a) throw Error(no(300));
  return o;
}
function Hoe() {
  var o = fI !== 0;
  return fI = 0, o;
}
function Rb() {
  var o = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  return Pu === null ? Il.memoizedState = Pu = o : Pu = Pu.next = o, Pu;
}
function Bh() {
  if (iu === null) {
    var o = Il.alternate;
    o = o !== null ? o.memoizedState : null;
  } else o = iu.next;
  var a = Pu === null ? Il.memoizedState : Pu.next;
  if (a !== null) Pu = a, iu = o;
  else {
    if (o === null) throw Error(no(310));
    iu = o, o = { memoizedState: iu.memoizedState, baseState: iu.baseState, baseQueue: iu.baseQueue, queue: iu.queue, next: null }, Pu === null ? Il.memoizedState = Pu = o : Pu = Pu.next = o;
  }
  return Pu;
}
function mI(o, a) {
  return typeof a == "function" ? a(o) : a;
}
function ote(o) {
  var a = Bh(), c = a.queue;
  if (c === null) throw Error(no(311));
  c.lastRenderedReducer = o;
  var f = iu, g = f.baseQueue, x = c.pending;
  if (x !== null) {
    if (g !== null) {
      var k = g.next;
      g.next = x.next, x.next = k;
    }
    f.baseQueue = g = x, c.pending = null;
  }
  if (g !== null) {
    x = g.next, f = f.baseState;
    var A = k = null, N = null, H = x;
    do {
      var Z = H.lane;
      if ((Zk & Z) === Z) N !== null && (N = N.next = { lane: 0, action: H.action, hasEagerState: H.hasEagerState, eagerState: H.eagerState, next: null }), f = H.hasEagerState ? H.eagerState : o(f, H.action);
      else {
        var K = {
          lane: Z,
          action: H.action,
          hasEagerState: H.hasEagerState,
          eagerState: H.eagerState,
          next: null
        };
        N === null ? (A = N = K, k = f) : N = N.next = K, Il.lanes |= Z, Gk |= Z;
      }
      H = H.next;
    } while (H !== null && H !== x);
    N === null ? k = f : N.next = A, av(f, a.memoizedState) || (wm = !0), a.memoizedState = f, a.baseState = k, a.baseQueue = N, c.lastRenderedState = f;
  }
  if (o = c.interleaved, o !== null) {
    g = o;
    do
      x = g.lane, Il.lanes |= x, Gk |= x, g = g.next;
    while (g !== o);
  } else g === null && (c.lanes = 0);
  return [a.memoizedState, c.dispatch];
}
function ste(o) {
  var a = Bh(), c = a.queue;
  if (c === null) throw Error(no(311));
  c.lastRenderedReducer = o;
  var f = c.dispatch, g = c.pending, x = a.memoizedState;
  if (g !== null) {
    c.pending = null;
    var k = g = g.next;
    do
      x = o(x, k.action), k = k.next;
    while (k !== g);
    av(x, a.memoizedState) || (wm = !0), a.memoizedState = x, a.baseQueue === null && (a.baseState = x), c.lastRenderedState = x;
  }
  return [x, f];
}
function Vue() {
}
function Uue(o, a) {
  var c = Il, f = Bh(), g = a(), x = !av(f.memoizedState, g);
  if (x && (f.memoizedState = g, wm = !0), f = f.queue, zoe(Zue.bind(null, c, f, o), [o]), f.getSnapshot !== a || x || Pu !== null && Pu.memoizedState.tag & 1) {
    if (c.flags |= 2048, pI(9, Wue.bind(null, c, f, g, a), void 0, null), Mu === null) throw Error(no(349));
    Zk & 30 || jue(c, a, g);
  }
  return g;
}
function jue(o, a, c) {
  o.flags |= 16384, o = { getSnapshot: a, value: c }, a = Il.updateQueue, a === null ? (a = { lastEffect: null, stores: null }, Il.updateQueue = a, a.stores = [o]) : (c = a.stores, c === null ? a.stores = [o] : c.push(o));
}
function Wue(o, a, c, f) {
  a.value = c, a.getSnapshot = f, Gue(a) && que(o);
}
function Zue(o, a, c) {
  return c(function() {
    Gue(a) && que(o);
  });
}
function Gue(o) {
  var a = o.getSnapshot;
  o = o.value;
  try {
    var c = a();
    return !av(o, c);
  } catch {
    return !0;
  }
}
function que(o) {
  var a = L0(o, 1);
  a !== null && rv(a, o, 1, -1);
}
function Oie(o) {
  var a = Rb();
  return typeof o == "function" && (o = o()), a.memoizedState = a.baseState = o, o = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: mI, lastRenderedState: o }, a.queue = o, o = o.dispatch = vge.bind(null, Il, o), [a.memoizedState, o];
}
function pI(o, a, c, f) {
  return o = { tag: o, create: a, destroy: c, deps: f, next: null }, a = Il.updateQueue, a === null ? (a = { lastEffect: null, stores: null }, Il.updateQueue = a, a.lastEffect = o.next = o) : (c = a.lastEffect, c === null ? a.lastEffect = o.next = o : (f = c.next, c.next = o, o.next = f, a.lastEffect = o)), o;
}
function Kue() {
  return Bh().memoizedState;
}
function P9(o, a, c, f) {
  var g = Rb();
  Il.flags |= o, g.memoizedState = pI(1 | a, c, void 0, f === void 0 ? null : f);
}
function PV(o, a, c, f) {
  var g = Bh();
  f = f === void 0 ? null : f;
  var x = void 0;
  if (iu !== null) {
    var k = iu.memoizedState;
    if (x = k.destroy, f !== null && Loe(f, k.deps)) {
      g.memoizedState = pI(a, c, x, f);
      return;
    }
  }
  Il.flags |= o, g.memoizedState = pI(1 | a, c, x, f);
}
function Die(o, a) {
  return P9(8390656, 8, o, a);
}
function zoe(o, a) {
  return PV(2048, 8, o, a);
}
function Yue(o, a) {
  return PV(4, 2, o, a);
}
function Xue(o, a) {
  return PV(4, 4, o, a);
}
function Que(o, a) {
  if (typeof a == "function") return o = o(), a(o), function() {
    a(null);
  };
  if (a != null) return o = o(), a.current = o, function() {
    a.current = null;
  };
}
function Jue(o, a, c) {
  return c = c != null ? c.concat([o]) : null, PV(4, 4, Que.bind(null, a, o), c);
}
function Voe() {
}
function ede(o, a) {
  var c = Bh();
  a = a === void 0 ? null : a;
  var f = c.memoizedState;
  return f !== null && a !== null && Loe(a, f[1]) ? f[0] : (c.memoizedState = [o, a], o);
}
function tde(o, a) {
  var c = Bh();
  a = a === void 0 ? null : a;
  var f = c.memoizedState;
  return f !== null && a !== null && Loe(a, f[1]) ? f[0] : (o = o(), c.memoizedState = [o, a], o);
}
function nde(o, a, c) {
  return Zk & 21 ? (av(c, a) || (c = iue(), Il.lanes |= c, Gk |= c, o.baseState = !0), a) : (o.baseState && (o.baseState = !1, wm = !0), o.memoizedState = c);
}
function hge(o, a) {
  var c = ri;
  ri = c !== 0 && 4 > c ? c : 4, o(!0);
  var f = nte.transition;
  nte.transition = {};
  try {
    o(!1), a();
  } finally {
    ri = c, nte.transition = f;
  }
}
function ode() {
  return Bh().memoizedState;
}
function gge(o, a, c) {
  var f = F2(o);
  if (c = { lane: f, action: c, hasEagerState: !1, eagerState: null, next: null }, sde(o)) rde(a, c);
  else if (c = $ue(o, a, c, f), c !== null) {
    var g = Nf();
    rv(c, o, f, g), ade(c, a, f);
  }
}
function vge(o, a, c) {
  var f = F2(o), g = { lane: f, action: c, hasEagerState: !1, eagerState: null, next: null };
  if (sde(o)) rde(a, g);
  else {
    var x = o.alternate;
    if (o.lanes === 0 && (x === null || x.lanes === 0) && (x = a.lastRenderedReducer, x !== null)) try {
      var k = a.lastRenderedState, A = x(k, c);
      if (g.hasEagerState = !0, g.eagerState = A, av(A, k)) {
        var N = a.interleaved;
        N === null ? (g.next = g, Poe(a)) : (g.next = N.next, N.next = g), a.interleaved = g;
        return;
      }
    } catch {
    } finally {
    }
    c = $ue(o, a, g, f), c !== null && (g = Nf(), rv(c, o, f, g), ade(c, a, f));
  }
}
function sde(o) {
  var a = o.alternate;
  return o === Il || a !== null && a === Il;
}
function rde(o, a) {
  j5 = lV = !0;
  var c = o.pending;
  c === null ? a.next = a : (a.next = c.next, c.next = a), o.pending = a;
}
function ade(o, a, c) {
  if (c & 4194240) {
    var f = a.lanes;
    f &= o.pendingLanes, c |= f, a.lanes = c, yoe(o, c);
  }
}
var cV = { readContext: Fh, useCallback: Vd, useContext: Vd, useEffect: Vd, useImperativeHandle: Vd, useInsertionEffect: Vd, useLayoutEffect: Vd, useMemo: Vd, useReducer: Vd, useRef: Vd, useState: Vd, useDebugValue: Vd, useDeferredValue: Vd, useTransition: Vd, useMutableSource: Vd, useSyncExternalStore: Vd, useId: Vd, unstable_isNewReconciler: !1 }, bge = { readContext: Fh, useCallback: function(o, a) {
  return Rb().memoizedState = [o, a === void 0 ? null : a], o;
}, useContext: Fh, useEffect: Die, useImperativeHandle: function(o, a, c) {
  return c = c != null ? c.concat([o]) : null, P9(
    4194308,
    4,
    Que.bind(null, a, o),
    c
  );
}, useLayoutEffect: function(o, a) {
  return P9(4194308, 4, o, a);
}, useInsertionEffect: function(o, a) {
  return P9(4, 2, o, a);
}, useMemo: function(o, a) {
  var c = Rb();
  return a = a === void 0 ? null : a, o = o(), c.memoizedState = [o, a], o;
}, useReducer: function(o, a, c) {
  var f = Rb();
  return a = c !== void 0 ? c(a) : a, f.memoizedState = f.baseState = a, o = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: o, lastRenderedState: a }, f.queue = o, o = o.dispatch = gge.bind(null, Il, o), [f.memoizedState, o];
}, useRef: function(o) {
  var a = Rb();
  return o = { current: o }, a.memoizedState = o;
}, useState: Oie, useDebugValue: Voe, useDeferredValue: function(o) {
  return Rb().memoizedState = o;
}, useTransition: function() {
  var o = Oie(!1), a = o[0];
  return o = hge.bind(null, o[1]), Rb().memoizedState = o, [a, o];
}, useMutableSource: function() {
}, useSyncExternalStore: function(o, a, c) {
  var f = Il, g = Rb();
  if (xl) {
    if (c === void 0) throw Error(no(407));
    c = c();
  } else {
    if (c = a(), Mu === null) throw Error(no(349));
    Zk & 30 || jue(f, a, c);
  }
  g.memoizedState = c;
  var x = { value: c, getSnapshot: a };
  return g.queue = x, Die(Zue.bind(
    null,
    f,
    x,
    o
  ), [o]), f.flags |= 2048, pI(9, Wue.bind(null, f, x, c, a), void 0, null), c;
}, useId: function() {
  var o = Rb(), a = Mu.identifierPrefix;
  if (xl) {
    var c = M0, f = P0;
    c = (f & ~(1 << 32 - sv(f) - 1)).toString(32) + c, a = ":" + a + "R" + c, c = fI++, 0 < c && (a += "H" + c.toString(32)), a += ":";
  } else c = pge++, a = ":" + a + "r" + c.toString(32) + ":";
  return o.memoizedState = a;
}, unstable_isNewReconciler: !1 }, yge = {
  readContext: Fh,
  useCallback: ede,
  useContext: Fh,
  useEffect: zoe,
  useImperativeHandle: Jue,
  useInsertionEffect: Yue,
  useLayoutEffect: Xue,
  useMemo: tde,
  useReducer: ote,
  useRef: Kue,
  useState: function() {
    return ote(mI);
  },
  useDebugValue: Voe,
  useDeferredValue: function(o) {
    var a = Bh();
    return nde(a, iu.memoizedState, o);
  },
  useTransition: function() {
    var o = ote(mI)[0], a = Bh().memoizedState;
    return [o, a];
  },
  useMutableSource: Vue,
  useSyncExternalStore: Uue,
  useId: ode,
  unstable_isNewReconciler: !1
}, xge = { readContext: Fh, useCallback: ede, useContext: Fh, useEffect: zoe, useImperativeHandle: Jue, useInsertionEffect: Yue, useLayoutEffect: Xue, useMemo: tde, useReducer: ste, useRef: Kue, useState: function() {
  return ste(mI);
}, useDebugValue: Voe, useDeferredValue: function(o) {
  var a = Bh();
  return iu === null ? a.memoizedState = o : nde(a, iu.memoizedState, o);
}, useTransition: function() {
  var o = ste(mI)[0], a = Bh().memoizedState;
  return [o, a];
}, useMutableSource: Vue, useSyncExternalStore: Uue, useId: ode, unstable_isNewReconciler: !1 };
function Jg(o, a) {
  if (o && o.defaultProps) {
    a = Fl({}, a), o = o.defaultProps;
    for (var c in o) a[c] === void 0 && (a[c] = o[c]);
    return a;
  }
  return a;
}
function cne(o, a, c, f) {
  a = o.memoizedState, c = c(f, a), c = c == null ? a : Fl({}, a, c), o.memoizedState = c, o.lanes === 0 && (o.updateQueue.baseState = c);
}
var MV = { isMounted: function(o) {
  return (o = o._reactInternals) ? e_(o) === o : !1;
}, enqueueSetState: function(o, a, c) {
  o = o._reactInternals;
  var f = Nf(), g = F2(o), x = I0(f, g);
  x.payload = a, c != null && (x.callback = c), a = M2(o, x, g), a !== null && (rv(a, o, g, f), R9(a, o, g));
}, enqueueReplaceState: function(o, a, c) {
  o = o._reactInternals;
  var f = Nf(), g = F2(o), x = I0(f, g);
  x.tag = 1, x.payload = a, c != null && (x.callback = c), a = M2(o, x, g), a !== null && (rv(a, o, g, f), R9(a, o, g));
}, enqueueForceUpdate: function(o, a) {
  o = o._reactInternals;
  var c = Nf(), f = F2(o), g = I0(c, f);
  g.tag = 2, a != null && (g.callback = a), a = M2(o, g, f), a !== null && (rv(a, o, f, c), R9(a, o, f));
} };
function Rie(o, a, c, f, g, x, k) {
  return o = o.stateNode, typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(f, x, k) : a.prototype && a.prototype.isPureReactComponent ? !aI(c, f) || !aI(g, x) : !0;
}
function ide(o, a, c) {
  var f = !1, g = z2, x = a.contextType;
  return typeof x == "object" && x !== null ? x = Fh(x) : (g = Sm(a) ? jk : Kd.current, f = a.contextTypes, x = (f = f != null) ? $4(o, g) : z2), a = new a(c, x), o.memoizedState = a.state !== null && a.state !== void 0 ? a.state : null, a.updater = MV, o.stateNode = a, a._reactInternals = o, f && (o = o.stateNode, o.__reactInternalMemoizedUnmaskedChildContext = g, o.__reactInternalMemoizedMaskedChildContext = x), a;
}
function Nie(o, a, c, f) {
  o = a.state, typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps(c, f), typeof a.UNSAFE_componentWillReceiveProps == "function" && a.UNSAFE_componentWillReceiveProps(c, f), a.state !== o && MV.enqueueReplaceState(a, a.state, null);
}
function une(o, a, c, f) {
  var g = o.stateNode;
  g.props = c, g.state = o.memoizedState, g.refs = {}, Moe(o);
  var x = a.contextType;
  typeof x == "object" && x !== null ? g.context = Fh(x) : (x = Sm(a) ? jk : Kd.current, g.context = $4(o, x)), g.state = o.memoizedState, x = a.getDerivedStateFromProps, typeof x == "function" && (cne(o, a, x, c), g.state = o.memoizedState), typeof a.getDerivedStateFromProps == "function" || typeof g.getSnapshotBeforeUpdate == "function" || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (a = g.state, typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount(), a !== g.state && MV.enqueueReplaceState(g, g.state, null), aV(o, c, g, f), g.state = o.memoizedState), typeof g.componentDidMount == "function" && (o.flags |= 4194308);
}
function U4(o, a) {
  try {
    var c = "", f = a;
    do
      c += qpe(f), f = f.return;
    while (f);
    var g = c;
  } catch (x) {
    g = `
Error generating stack: ` + x.message + `
` + x.stack;
  }
  return { value: o, source: a, stack: g, digest: null };
}
function rte(o, a, c) {
  return { value: o, source: null, stack: c ?? null, digest: a ?? null };
}
function dne(o, a) {
  try {
    console.error(a.value);
  } catch (c) {
    setTimeout(function() {
      throw c;
    });
  }
}
var wge = typeof WeakMap == "function" ? WeakMap : Map;
function lde(o, a, c) {
  c = I0(-1, c), c.tag = 3, c.payload = { element: null };
  var f = a.value;
  return c.callback = function() {
    dV || (dV = !0, wne = f), dne(o, a);
  }, c;
}
function cde(o, a, c) {
  c = I0(-1, c), c.tag = 3;
  var f = o.type.getDerivedStateFromError;
  if (typeof f == "function") {
    var g = a.value;
    c.payload = function() {
      return f(g);
    }, c.callback = function() {
      dne(o, a);
    };
  }
  var x = o.stateNode;
  return x !== null && typeof x.componentDidCatch == "function" && (c.callback = function() {
    dne(o, a), typeof f != "function" && (I2 === null ? I2 = /* @__PURE__ */ new Set([this]) : I2.add(this));
    var k = a.stack;
    this.componentDidCatch(a.value, { componentStack: k !== null ? k : "" });
  }), c;
}
function Pie(o, a, c) {
  var f = o.pingCache;
  if (f === null) {
    f = o.pingCache = new wge();
    var g = /* @__PURE__ */ new Set();
    f.set(a, g);
  } else g = f.get(a), g === void 0 && (g = /* @__PURE__ */ new Set(), f.set(a, g));
  g.has(c) || (g.add(c), o = Ige.bind(null, o, a, c), a.then(o, o));
}
function Mie(o) {
  do {
    var a;
    if ((a = o.tag === 13) && (a = o.memoizedState, a = a !== null ? a.dehydrated !== null : !0), a) return o;
    o = o.return;
  } while (o !== null);
  return null;
}
function Iie(o, a, c, f, g) {
  return o.mode & 1 ? (o.flags |= 65536, o.lanes = g, o) : (o === a ? o.flags |= 65536 : (o.flags |= 128, c.flags |= 131072, c.flags &= -52805, c.tag === 1 && (c.alternate === null ? c.tag = 17 : (a = I0(-1, 1), a.tag = 2, M2(c, a, 1))), c.lanes |= 1), o);
}
var Cge = W0.ReactCurrentOwner, wm = !1;
function Rf(o, a, c, f) {
  a.child = o === null ? Lue(a, null, c, f) : z4(a, o.child, c, f);
}
function Fie(o, a, c, f, g) {
  c = c.render;
  var x = a.ref;
  return N4(a, g), f = $oe(o, a, c, f, x, g), c = Hoe(), o !== null && !wm ? (a.updateQueue = o.updateQueue, a.flags &= -2053, o.lanes &= ~g, $0(o, a, g)) : (xl && c && Toe(a), a.flags |= 1, Rf(o, a, f, g), a.child);
}
function Bie(o, a, c, f, g) {
  if (o === null) {
    var x = c.type;
    return typeof x == "function" && !Yoe(x) && x.defaultProps === void 0 && c.compare === null && c.defaultProps === void 0 ? (a.tag = 15, a.type = x, ude(o, a, x, f, g)) : (o = B9(c.type, null, f, a, a.mode, g), o.ref = a.ref, o.return = a, a.child = o);
  }
  if (x = o.child, !(o.lanes & g)) {
    var k = x.memoizedProps;
    if (c = c.compare, c = c !== null ? c : aI, c(k, f) && o.ref === a.ref) return $0(o, a, g);
  }
  return a.flags |= 1, o = B2(x, f), o.ref = a.ref, o.return = a, a.child = o;
}
function ude(o, a, c, f, g) {
  if (o !== null) {
    var x = o.memoizedProps;
    if (aI(x, f) && o.ref === a.ref) if (wm = !1, a.pendingProps = f = x, (o.lanes & g) !== 0) o.flags & 131072 && (wm = !0);
    else return a.lanes = o.lanes, $0(o, a, g);
  }
  return fne(o, a, c, f, g);
}
function dde(o, a, c) {
  var f = a.pendingProps, g = f.children, x = o !== null ? o.memoizedState : null;
  if (f.mode === "hidden") if (!(a.mode & 1)) a.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Ui(C4, up), up |= c;
  else {
    if (!(c & 1073741824)) return o = x !== null ? x.baseLanes | c : c, a.lanes = a.childLanes = 1073741824, a.memoizedState = { baseLanes: o, cachePool: null, transitions: null }, a.updateQueue = null, Ui(C4, up), up |= o, null;
    a.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, f = x !== null ? x.baseLanes : c, Ui(C4, up), up |= f;
  }
  else x !== null ? (f = x.baseLanes | c, a.memoizedState = null) : f = c, Ui(C4, up), up |= f;
  return Rf(o, a, g, c), a.child;
}
function fde(o, a) {
  var c = a.ref;
  (o === null && c !== null || o !== null && o.ref !== c) && (a.flags |= 512, a.flags |= 2097152);
}
function fne(o, a, c, f, g) {
  var x = Sm(c) ? jk : Kd.current;
  return x = $4(a, x), N4(a, g), c = $oe(o, a, c, f, x, g), f = Hoe(), o !== null && !wm ? (a.updateQueue = o.updateQueue, a.flags &= -2053, o.lanes &= ~g, $0(o, a, g)) : (xl && f && Toe(a), a.flags |= 1, Rf(o, a, c, g), a.child);
}
function Lie(o, a, c, f, g) {
  if (Sm(c)) {
    var x = !0;
    tV(a);
  } else x = !1;
  if (N4(a, g), a.stateNode === null) M9(o, a), ide(a, c, f), une(a, c, f, g), f = !0;
  else if (o === null) {
    var k = a.stateNode, A = a.memoizedProps;
    k.props = A;
    var N = k.context, H = c.contextType;
    typeof H == "object" && H !== null ? H = Fh(H) : (H = Sm(c) ? jk : Kd.current, H = $4(a, H));
    var Z = c.getDerivedStateFromProps, K = typeof Z == "function" || typeof k.getSnapshotBeforeUpdate == "function";
    K || typeof k.UNSAFE_componentWillReceiveProps != "function" && typeof k.componentWillReceiveProps != "function" || (A !== f || N !== H) && Nie(a, k, f, H), S2 = !1;
    var J = a.memoizedState;
    k.state = J, aV(a, f, k, g), N = a.memoizedState, A !== f || J !== N || Cm.current || S2 ? (typeof Z == "function" && (cne(a, c, Z, f), N = a.memoizedState), (A = S2 || Rie(a, c, A, f, J, N, H)) ? (K || typeof k.UNSAFE_componentWillMount != "function" && typeof k.componentWillMount != "function" || (typeof k.componentWillMount == "function" && k.componentWillMount(), typeof k.UNSAFE_componentWillMount == "function" && k.UNSAFE_componentWillMount()), typeof k.componentDidMount == "function" && (a.flags |= 4194308)) : (typeof k.componentDidMount == "function" && (a.flags |= 4194308), a.memoizedProps = f, a.memoizedState = N), k.props = f, k.state = N, k.context = H, f = A) : (typeof k.componentDidMount == "function" && (a.flags |= 4194308), f = !1);
  } else {
    k = a.stateNode, Hue(o, a), A = a.memoizedProps, H = a.type === a.elementType ? A : Jg(a.type, A), k.props = H, K = a.pendingProps, J = k.context, N = c.contextType, typeof N == "object" && N !== null ? N = Fh(N) : (N = Sm(c) ? jk : Kd.current, N = $4(a, N));
    var pe = c.getDerivedStateFromProps;
    (Z = typeof pe == "function" || typeof k.getSnapshotBeforeUpdate == "function") || typeof k.UNSAFE_componentWillReceiveProps != "function" && typeof k.componentWillReceiveProps != "function" || (A !== K || J !== N) && Nie(a, k, f, N), S2 = !1, J = a.memoizedState, k.state = J, aV(a, f, k, g);
    var Se = a.memoizedState;
    A !== K || J !== Se || Cm.current || S2 ? (typeof pe == "function" && (cne(a, c, pe, f), Se = a.memoizedState), (H = S2 || Rie(a, c, H, f, J, Se, N) || !1) ? (Z || typeof k.UNSAFE_componentWillUpdate != "function" && typeof k.componentWillUpdate != "function" || (typeof k.componentWillUpdate == "function" && k.componentWillUpdate(f, Se, N), typeof k.UNSAFE_componentWillUpdate == "function" && k.UNSAFE_componentWillUpdate(f, Se, N)), typeof k.componentDidUpdate == "function" && (a.flags |= 4), typeof k.getSnapshotBeforeUpdate == "function" && (a.flags |= 1024)) : (typeof k.componentDidUpdate != "function" || A === o.memoizedProps && J === o.memoizedState || (a.flags |= 4), typeof k.getSnapshotBeforeUpdate != "function" || A === o.memoizedProps && J === o.memoizedState || (a.flags |= 1024), a.memoizedProps = f, a.memoizedState = Se), k.props = f, k.state = Se, k.context = N, f = H) : (typeof k.componentDidUpdate != "function" || A === o.memoizedProps && J === o.memoizedState || (a.flags |= 4), typeof k.getSnapshotBeforeUpdate != "function" || A === o.memoizedProps && J === o.memoizedState || (a.flags |= 1024), f = !1);
  }
  return mne(o, a, c, f, x, g);
}
function mne(o, a, c, f, g, x) {
  fde(o, a);
  var k = (a.flags & 128) !== 0;
  if (!f && !k) return g && Sie(a, c, !1), $0(o, a, x);
  f = a.stateNode, Cge.current = a;
  var A = k && typeof c.getDerivedStateFromError != "function" ? null : f.render();
  return a.flags |= 1, o !== null && k ? (a.child = z4(a, o.child, null, x), a.child = z4(a, null, A, x)) : Rf(o, a, A, x), a.memoizedState = f.state, g && Sie(a, c, !0), a.child;
}
function mde(o) {
  var a = o.stateNode;
  a.pendingContext ? Cie(o, a.pendingContext, a.pendingContext !== a.context) : a.context && Cie(o, a.context, !1), Ioe(o, a.containerInfo);
}
function $ie(o, a, c, f, g) {
  return H4(), Ooe(g), a.flags |= 256, Rf(o, a, c, f), a.child;
}
var pne = { dehydrated: null, treeContext: null, retryLane: 0 };
function hne(o) {
  return { baseLanes: o, cachePool: null, transitions: null };
}
function pde(o, a, c) {
  var f = a.pendingProps, g = Ml.current, x = !1, k = (a.flags & 128) !== 0, A;
  if ((A = k) || (A = o !== null && o.memoizedState === null ? !1 : (g & 2) !== 0), A ? (x = !0, a.flags &= -129) : (o === null || o.memoizedState !== null) && (g |= 1), Ui(Ml, g & 1), o === null)
    return ine(a), o = a.memoizedState, o !== null && (o = o.dehydrated, o !== null) ? (a.mode & 1 ? o.data === "$!" ? a.lanes = 8 : a.lanes = 1073741824 : a.lanes = 1, null) : (k = f.children, o = f.fallback, x ? (f = a.mode, x = a.child, k = { mode: "hidden", children: k }, !(f & 1) && x !== null ? (x.childLanes = 0, x.pendingProps = k) : x = BV(k, f, 0, null), o = Hk(o, f, c, null), x.return = a, o.return = a, x.sibling = o, a.child = x, a.child.memoizedState = hne(c), a.memoizedState = pne, o) : Uoe(a, k));
  if (g = o.memoizedState, g !== null && (A = g.dehydrated, A !== null)) return Sge(o, a, k, f, A, g, c);
  if (x) {
    x = f.fallback, k = a.mode, g = o.child, A = g.sibling;
    var N = { mode: "hidden", children: f.children };
    return !(k & 1) && a.child !== g ? (f = a.child, f.childLanes = 0, f.pendingProps = N, a.deletions = null) : (f = B2(g, N), f.subtreeFlags = g.subtreeFlags & 14680064), A !== null ? x = B2(A, x) : (x = Hk(x, k, c, null), x.flags |= 2), x.return = a, f.return = a, f.sibling = x, a.child = f, f = x, x = a.child, k = o.child.memoizedState, k = k === null ? hne(c) : { baseLanes: k.baseLanes | c, cachePool: null, transitions: k.transitions }, x.memoizedState = k, x.childLanes = o.childLanes & ~c, a.memoizedState = pne, f;
  }
  return x = o.child, o = x.sibling, f = B2(x, { mode: "visible", children: f.children }), !(a.mode & 1) && (f.lanes = c), f.return = a, f.sibling = null, o !== null && (c = a.deletions, c === null ? (a.deletions = [o], a.flags |= 16) : c.push(o)), a.child = f, a.memoizedState = null, f;
}
function Uoe(o, a) {
  return a = BV({ mode: "visible", children: a }, o.mode, 0, null), a.return = o, o.child = a;
}
function s9(o, a, c, f) {
  return f !== null && Ooe(f), z4(a, o.child, null, c), o = Uoe(a, a.pendingProps.children), o.flags |= 2, a.memoizedState = null, o;
}
function Sge(o, a, c, f, g, x, k) {
  if (c)
    return a.flags & 256 ? (a.flags &= -257, f = rte(Error(no(422))), s9(o, a, k, f)) : a.memoizedState !== null ? (a.child = o.child, a.flags |= 128, null) : (x = f.fallback, g = a.mode, f = BV({ mode: "visible", children: f.children }, g, 0, null), x = Hk(x, g, k, null), x.flags |= 2, f.return = a, x.return = a, f.sibling = x, a.child = f, a.mode & 1 && z4(a, o.child, null, k), a.child.memoizedState = hne(k), a.memoizedState = pne, x);
  if (!(a.mode & 1)) return s9(o, a, k, null);
  if (g.data === "$!") {
    if (f = g.nextSibling && g.nextSibling.dataset, f) var A = f.dgst;
    return f = A, x = Error(no(419)), f = rte(x, f, void 0), s9(o, a, k, f);
  }
  if (A = (k & o.childLanes) !== 0, wm || A) {
    if (f = Mu, f !== null) {
      switch (k & -k) {
        case 4:
          g = 2;
          break;
        case 16:
          g = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          g = 32;
          break;
        case 536870912:
          g = 268435456;
          break;
        default:
          g = 0;
      }
      g = g & (f.suspendedLanes | k) ? 0 : g, g !== 0 && g !== x.retryLane && (x.retryLane = g, L0(o, g), rv(f, o, g, -1));
    }
    return Koe(), f = rte(Error(no(421))), s9(o, a, k, f);
  }
  return g.data === "$?" ? (a.flags |= 128, a.child = o.child, a = Fge.bind(null, o), g._reactRetry = a, null) : (o = x.treeContext, fp = P2(g.nextSibling), mp = a, xl = !0, nv = null, o !== null && (Rh[Nh++] = P0, Rh[Nh++] = M0, Rh[Nh++] = Wk, P0 = o.id, M0 = o.overflow, Wk = a), a = Uoe(a, f.children), a.flags |= 4096, a);
}
function Hie(o, a, c) {
  o.lanes |= a;
  var f = o.alternate;
  f !== null && (f.lanes |= a), lne(o.return, a, c);
}
function ate(o, a, c, f, g) {
  var x = o.memoizedState;
  x === null ? o.memoizedState = { isBackwards: a, rendering: null, renderingStartTime: 0, last: f, tail: c, tailMode: g } : (x.isBackwards = a, x.rendering = null, x.renderingStartTime = 0, x.last = f, x.tail = c, x.tailMode = g);
}
function hde(o, a, c) {
  var f = a.pendingProps, g = f.revealOrder, x = f.tail;
  if (Rf(o, a, f.children, c), f = Ml.current, f & 2) f = f & 1 | 2, a.flags |= 128;
  else {
    if (o !== null && o.flags & 128) e: for (o = a.child; o !== null; ) {
      if (o.tag === 13) o.memoizedState !== null && Hie(o, c, a);
      else if (o.tag === 19) Hie(o, c, a);
      else if (o.child !== null) {
        o.child.return = o, o = o.child;
        continue;
      }
      if (o === a) break e;
      for (; o.sibling === null; ) {
        if (o.return === null || o.return === a) break e;
        o = o.return;
      }
      o.sibling.return = o.return, o = o.sibling;
    }
    f &= 1;
  }
  if (Ui(Ml, f), !(a.mode & 1)) a.memoizedState = null;
  else switch (g) {
    case "forwards":
      for (c = a.child, g = null; c !== null; ) o = c.alternate, o !== null && iV(o) === null && (g = c), c = c.sibling;
      c = g, c === null ? (g = a.child, a.child = null) : (g = c.sibling, c.sibling = null), ate(a, !1, g, c, x);
      break;
    case "backwards":
      for (c = null, g = a.child, a.child = null; g !== null; ) {
        if (o = g.alternate, o !== null && iV(o) === null) {
          a.child = g;
          break;
        }
        o = g.sibling, g.sibling = c, c = g, g = o;
      }
      ate(a, !0, c, null, x);
      break;
    case "together":
      ate(a, !1, null, null, void 0);
      break;
    default:
      a.memoizedState = null;
  }
  return a.child;
}
function M9(o, a) {
  !(a.mode & 1) && o !== null && (o.alternate = null, a.alternate = null, a.flags |= 2);
}
function $0(o, a, c) {
  if (o !== null && (a.dependencies = o.dependencies), Gk |= a.lanes, !(c & a.childLanes)) return null;
  if (o !== null && a.child !== o.child) throw Error(no(153));
  if (a.child !== null) {
    for (o = a.child, c = B2(o, o.pendingProps), a.child = c, c.return = a; o.sibling !== null; ) o = o.sibling, c = c.sibling = B2(o, o.pendingProps), c.return = a;
    c.sibling = null;
  }
  return a.child;
}
function kge(o, a, c) {
  switch (a.tag) {
    case 3:
      mde(a), H4();
      break;
    case 5:
      zue(a);
      break;
    case 1:
      Sm(a.type) && tV(a);
      break;
    case 4:
      Ioe(a, a.stateNode.containerInfo);
      break;
    case 10:
      var f = a.type._context, g = a.memoizedProps.value;
      Ui(sV, f._currentValue), f._currentValue = g;
      break;
    case 13:
      if (f = a.memoizedState, f !== null)
        return f.dehydrated !== null ? (Ui(Ml, Ml.current & 1), a.flags |= 128, null) : c & a.child.childLanes ? pde(o, a, c) : (Ui(Ml, Ml.current & 1), o = $0(o, a, c), o !== null ? o.sibling : null);
      Ui(Ml, Ml.current & 1);
      break;
    case 19:
      if (f = (c & a.childLanes) !== 0, o.flags & 128) {
        if (f) return hde(o, a, c);
        a.flags |= 128;
      }
      if (g = a.memoizedState, g !== null && (g.rendering = null, g.tail = null, g.lastEffect = null), Ui(Ml, Ml.current), f) break;
      return null;
    case 22:
    case 23:
      return a.lanes = 0, dde(o, a, c);
  }
  return $0(o, a, c);
}
var gde, gne, vde, bde;
gde = function(o, a) {
  for (var c = a.child; c !== null; ) {
    if (c.tag === 5 || c.tag === 6) o.appendChild(c.stateNode);
    else if (c.tag !== 4 && c.child !== null) {
      c.child.return = c, c = c.child;
      continue;
    }
    if (c === a) break;
    for (; c.sibling === null; ) {
      if (c.return === null || c.return === a) return;
      c = c.return;
    }
    c.sibling.return = c.return, c = c.sibling;
  }
};
gne = function() {
};
vde = function(o, a, c, f) {
  var g = o.memoizedProps;
  if (g !== f) {
    o = a.stateNode, Pk(Fb.current);
    var x = null;
    switch (c) {
      case "input":
        g = Lte(o, g), f = Lte(o, f), x = [];
        break;
      case "select":
        g = Fl({}, g, { value: void 0 }), f = Fl({}, f, { value: void 0 }), x = [];
        break;
      case "textarea":
        g = zte(o, g), f = zte(o, f), x = [];
        break;
      default:
        typeof g.onClick != "function" && typeof f.onClick == "function" && (o.onclick = J9);
    }
    Ute(c, f);
    var k;
    c = null;
    for (H in g) if (!f.hasOwnProperty(H) && g.hasOwnProperty(H) && g[H] != null) if (H === "style") {
      var A = g[H];
      for (k in A) A.hasOwnProperty(k) && (c || (c = {}), c[k] = "");
    } else H !== "dangerouslySetInnerHTML" && H !== "children" && H !== "suppressContentEditableWarning" && H !== "suppressHydrationWarning" && H !== "autoFocus" && (J5.hasOwnProperty(H) ? x || (x = []) : (x = x || []).push(H, null));
    for (H in f) {
      var N = f[H];
      if (A = g != null ? g[H] : void 0, f.hasOwnProperty(H) && N !== A && (N != null || A != null)) if (H === "style") if (A) {
        for (k in A) !A.hasOwnProperty(k) || N && N.hasOwnProperty(k) || (c || (c = {}), c[k] = "");
        for (k in N) N.hasOwnProperty(k) && A[k] !== N[k] && (c || (c = {}), c[k] = N[k]);
      } else c || (x || (x = []), x.push(
        H,
        c
      )), c = N;
      else H === "dangerouslySetInnerHTML" ? (N = N ? N.__html : void 0, A = A ? A.__html : void 0, N != null && A !== N && (x = x || []).push(H, N)) : H === "children" ? typeof N != "string" && typeof N != "number" || (x = x || []).push(H, "" + N) : H !== "suppressContentEditableWarning" && H !== "suppressHydrationWarning" && (J5.hasOwnProperty(H) ? (N != null && H === "onScroll" && rl("scroll", o), x || A === N || (x = [])) : (x = x || []).push(H, N));
    }
    c && (x = x || []).push("style", c);
    var H = x;
    (a.updateQueue = H) && (a.flags |= 4);
  }
};
bde = function(o, a, c, f) {
  c !== f && (a.flags |= 4);
};
function O5(o, a) {
  if (!xl) switch (o.tailMode) {
    case "hidden":
      a = o.tail;
      for (var c = null; a !== null; ) a.alternate !== null && (c = a), a = a.sibling;
      c === null ? o.tail = null : c.sibling = null;
      break;
    case "collapsed":
      c = o.tail;
      for (var f = null; c !== null; ) c.alternate !== null && (f = c), c = c.sibling;
      f === null ? a || o.tail === null ? o.tail = null : o.tail.sibling = null : f.sibling = null;
  }
}
function Ud(o) {
  var a = o.alternate !== null && o.alternate.child === o.child, c = 0, f = 0;
  if (a) for (var g = o.child; g !== null; ) c |= g.lanes | g.childLanes, f |= g.subtreeFlags & 14680064, f |= g.flags & 14680064, g.return = o, g = g.sibling;
  else for (g = o.child; g !== null; ) c |= g.lanes | g.childLanes, f |= g.subtreeFlags, f |= g.flags, g.return = o, g = g.sibling;
  return o.subtreeFlags |= f, o.childLanes = c, a;
}
function _ge(o, a, c) {
  var f = a.pendingProps;
  switch (Aoe(a), a.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return Ud(a), null;
    case 1:
      return Sm(a.type) && eV(), Ud(a), null;
    case 3:
      return f = a.stateNode, V4(), il(Cm), il(Kd), Boe(), f.pendingContext && (f.context = f.pendingContext, f.pendingContext = null), (o === null || o.child === null) && (n9(a) ? a.flags |= 4 : o === null || o.memoizedState.isDehydrated && !(a.flags & 256) || (a.flags |= 1024, nv !== null && (kne(nv), nv = null))), gne(o, a), Ud(a), null;
    case 5:
      Foe(a);
      var g = Pk(dI.current);
      if (c = a.type, o !== null && a.stateNode != null) vde(o, a, c, f, g), o.ref !== a.ref && (a.flags |= 512, a.flags |= 2097152);
      else {
        if (!f) {
          if (a.stateNode === null) throw Error(no(166));
          return Ud(a), null;
        }
        if (o = Pk(Fb.current), n9(a)) {
          f = a.stateNode, c = a.type;
          var x = a.memoizedProps;
          switch (f[Nb] = a, f[cI] = x, o = (a.mode & 1) !== 0, c) {
            case "dialog":
              rl("cancel", f), rl("close", f);
              break;
            case "iframe":
            case "object":
            case "embed":
              rl("load", f);
              break;
            case "video":
            case "audio":
              for (g = 0; g < F5.length; g++) rl(F5[g], f);
              break;
            case "source":
              rl("error", f);
              break;
            case "img":
            case "image":
            case "link":
              rl(
                "error",
                f
              ), rl("load", f);
              break;
            case "details":
              rl("toggle", f);
              break;
            case "input":
              Kae(f, x), rl("invalid", f);
              break;
            case "select":
              f._wrapperState = { wasMultiple: !!x.multiple }, rl("invalid", f);
              break;
            case "textarea":
              Xae(f, x), rl("invalid", f);
          }
          Ute(c, x), g = null;
          for (var k in x) if (x.hasOwnProperty(k)) {
            var A = x[k];
            k === "children" ? typeof A == "string" ? f.textContent !== A && (x.suppressHydrationWarning !== !0 && t9(f.textContent, A, o), g = ["children", A]) : typeof A == "number" && f.textContent !== "" + A && (x.suppressHydrationWarning !== !0 && t9(
              f.textContent,
              A,
              o
            ), g = ["children", "" + A]) : J5.hasOwnProperty(k) && A != null && k === "onScroll" && rl("scroll", f);
          }
          switch (c) {
            case "input":
              Gz(f), Yae(f, x, !0);
              break;
            case "textarea":
              Gz(f), Qae(f);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof x.onClick == "function" && (f.onclick = J9);
          }
          f = g, a.updateQueue = f, f !== null && (a.flags |= 4);
        } else {
          k = g.nodeType === 9 ? g : g.ownerDocument, o === "http://www.w3.org/1999/xhtml" && (o = Zce(c)), o === "http://www.w3.org/1999/xhtml" ? c === "script" ? (o = k.createElement("div"), o.innerHTML = "<script><\/script>", o = o.removeChild(o.firstChild)) : typeof f.is == "string" ? o = k.createElement(c, { is: f.is }) : (o = k.createElement(c), c === "select" && (k = o, f.multiple ? k.multiple = !0 : f.size && (k.size = f.size))) : o = k.createElementNS(o, c), o[Nb] = a, o[cI] = f, gde(o, a, !1, !1), a.stateNode = o;
          e: {
            switch (k = jte(c, f), c) {
              case "dialog":
                rl("cancel", o), rl("close", o), g = f;
                break;
              case "iframe":
              case "object":
              case "embed":
                rl("load", o), g = f;
                break;
              case "video":
              case "audio":
                for (g = 0; g < F5.length; g++) rl(F5[g], o);
                g = f;
                break;
              case "source":
                rl("error", o), g = f;
                break;
              case "img":
              case "image":
              case "link":
                rl(
                  "error",
                  o
                ), rl("load", o), g = f;
                break;
              case "details":
                rl("toggle", o), g = f;
                break;
              case "input":
                Kae(o, f), g = Lte(o, f), rl("invalid", o);
                break;
              case "option":
                g = f;
                break;
              case "select":
                o._wrapperState = { wasMultiple: !!f.multiple }, g = Fl({}, f, { value: void 0 }), rl("invalid", o);
                break;
              case "textarea":
                Xae(o, f), g = zte(o, f), rl("invalid", o);
                break;
              default:
                g = f;
            }
            Ute(c, g), A = g;
            for (x in A) if (A.hasOwnProperty(x)) {
              var N = A[x];
              x === "style" ? Kce(o, N) : x === "dangerouslySetInnerHTML" ? (N = N ? N.__html : void 0, N != null && Gce(o, N)) : x === "children" ? typeof N == "string" ? (c !== "textarea" || N !== "") && eI(o, N) : typeof N == "number" && eI(o, "" + N) : x !== "suppressContentEditableWarning" && x !== "suppressHydrationWarning" && x !== "autoFocus" && (J5.hasOwnProperty(x) ? N != null && x === "onScroll" && rl("scroll", o) : N != null && moe(o, x, N, k));
            }
            switch (c) {
              case "input":
                Gz(o), Yae(o, f, !1);
                break;
              case "textarea":
                Gz(o), Qae(o);
                break;
              case "option":
                f.value != null && o.setAttribute("value", "" + H2(f.value));
                break;
              case "select":
                o.multiple = !!f.multiple, x = f.value, x != null ? A4(o, !!f.multiple, x, !1) : f.defaultValue != null && A4(
                  o,
                  !!f.multiple,
                  f.defaultValue,
                  !0
                );
                break;
              default:
                typeof g.onClick == "function" && (o.onclick = J9);
            }
            switch (c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                f = !!f.autoFocus;
                break e;
              case "img":
                f = !0;
                break e;
              default:
                f = !1;
            }
          }
          f && (a.flags |= 4);
        }
        a.ref !== null && (a.flags |= 512, a.flags |= 2097152);
      }
      return Ud(a), null;
    case 6:
      if (o && a.stateNode != null) bde(o, a, o.memoizedProps, f);
      else {
        if (typeof f != "string" && a.stateNode === null) throw Error(no(166));
        if (c = Pk(dI.current), Pk(Fb.current), n9(a)) {
          if (f = a.stateNode, c = a.memoizedProps, f[Nb] = a, (x = f.nodeValue !== c) && (o = mp, o !== null)) switch (o.tag) {
            case 3:
              t9(f.nodeValue, c, (o.mode & 1) !== 0);
              break;
            case 5:
              o.memoizedProps.suppressHydrationWarning !== !0 && t9(f.nodeValue, c, (o.mode & 1) !== 0);
          }
          x && (a.flags |= 4);
        } else f = (c.nodeType === 9 ? c : c.ownerDocument).createTextNode(f), f[Nb] = a, a.stateNode = f;
      }
      return Ud(a), null;
    case 13:
      if (il(Ml), f = a.memoizedState, o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) {
        if (xl && fp !== null && a.mode & 1 && !(a.flags & 128)) Fue(), H4(), a.flags |= 98560, x = !1;
        else if (x = n9(a), f !== null && f.dehydrated !== null) {
          if (o === null) {
            if (!x) throw Error(no(318));
            if (x = a.memoizedState, x = x !== null ? x.dehydrated : null, !x) throw Error(no(317));
            x[Nb] = a;
          } else H4(), !(a.flags & 128) && (a.memoizedState = null), a.flags |= 4;
          Ud(a), x = !1;
        } else nv !== null && (kne(nv), nv = null), x = !0;
        if (!x) return a.flags & 65536 ? a : null;
      }
      return a.flags & 128 ? (a.lanes = c, a) : (f = f !== null, f !== (o !== null && o.memoizedState !== null) && f && (a.child.flags |= 8192, a.mode & 1 && (o === null || Ml.current & 1 ? lu === 0 && (lu = 3) : Koe())), a.updateQueue !== null && (a.flags |= 4), Ud(a), null);
    case 4:
      return V4(), gne(o, a), o === null && iI(a.stateNode.containerInfo), Ud(a), null;
    case 10:
      return Noe(a.type._context), Ud(a), null;
    case 17:
      return Sm(a.type) && eV(), Ud(a), null;
    case 19:
      if (il(Ml), x = a.memoizedState, x === null) return Ud(a), null;
      if (f = (a.flags & 128) !== 0, k = x.rendering, k === null) if (f) O5(x, !1);
      else {
        if (lu !== 0 || o !== null && o.flags & 128) for (o = a.child; o !== null; ) {
          if (k = iV(o), k !== null) {
            for (a.flags |= 128, O5(x, !1), f = k.updateQueue, f !== null && (a.updateQueue = f, a.flags |= 4), a.subtreeFlags = 0, f = c, c = a.child; c !== null; ) x = c, o = f, x.flags &= 14680066, k = x.alternate, k === null ? (x.childLanes = 0, x.lanes = o, x.child = null, x.subtreeFlags = 0, x.memoizedProps = null, x.memoizedState = null, x.updateQueue = null, x.dependencies = null, x.stateNode = null) : (x.childLanes = k.childLanes, x.lanes = k.lanes, x.child = k.child, x.subtreeFlags = 0, x.deletions = null, x.memoizedProps = k.memoizedProps, x.memoizedState = k.memoizedState, x.updateQueue = k.updateQueue, x.type = k.type, o = k.dependencies, x.dependencies = o === null ? null : { lanes: o.lanes, firstContext: o.firstContext }), c = c.sibling;
            return Ui(Ml, Ml.current & 1 | 2), a.child;
          }
          o = o.sibling;
        }
        x.tail !== null && yc() > j4 && (a.flags |= 128, f = !0, O5(x, !1), a.lanes = 4194304);
      }
      else {
        if (!f) if (o = iV(k), o !== null) {
          if (a.flags |= 128, f = !0, c = o.updateQueue, c !== null && (a.updateQueue = c, a.flags |= 4), O5(x, !0), x.tail === null && x.tailMode === "hidden" && !k.alternate && !xl) return Ud(a), null;
        } else 2 * yc() - x.renderingStartTime > j4 && c !== 1073741824 && (a.flags |= 128, f = !0, O5(x, !1), a.lanes = 4194304);
        x.isBackwards ? (k.sibling = a.child, a.child = k) : (c = x.last, c !== null ? c.sibling = k : a.child = k, x.last = k);
      }
      return x.tail !== null ? (a = x.tail, x.rendering = a, x.tail = a.sibling, x.renderingStartTime = yc(), a.sibling = null, c = Ml.current, Ui(Ml, f ? c & 1 | 2 : c & 1), a) : (Ud(a), null);
    case 22:
    case 23:
      return qoe(), f = a.memoizedState !== null, o !== null && o.memoizedState !== null !== f && (a.flags |= 8192), f && a.mode & 1 ? up & 1073741824 && (Ud(a), a.subtreeFlags & 6 && (a.flags |= 8192)) : Ud(a), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(no(156, a.tag));
}
function Ege(o, a) {
  switch (Aoe(a), a.tag) {
    case 1:
      return Sm(a.type) && eV(), o = a.flags, o & 65536 ? (a.flags = o & -65537 | 128, a) : null;
    case 3:
      return V4(), il(Cm), il(Kd), Boe(), o = a.flags, o & 65536 && !(o & 128) ? (a.flags = o & -65537 | 128, a) : null;
    case 5:
      return Foe(a), null;
    case 13:
      if (il(Ml), o = a.memoizedState, o !== null && o.dehydrated !== null) {
        if (a.alternate === null) throw Error(no(340));
        H4();
      }
      return o = a.flags, o & 65536 ? (a.flags = o & -65537 | 128, a) : null;
    case 19:
      return il(Ml), null;
    case 4:
      return V4(), null;
    case 10:
      return Noe(a.type._context), null;
    case 22:
    case 23:
      return qoe(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var r9 = !1, jd = !1, Tge = typeof WeakSet == "function" ? WeakSet : Set, qo = null;
function w4(o, a) {
  var c = o.ref;
  if (c !== null) if (typeof c == "function") try {
    c(null);
  } catch (f) {
    Kl(o, a, f);
  }
  else c.current = null;
}
function vne(o, a, c) {
  try {
    c();
  } catch (f) {
    Kl(o, a, f);
  }
}
var zie = !1;
function Age(o, a) {
  if (ene = Y9, o = Sue(), Eoe(o)) {
    if ("selectionStart" in o) var c = { start: o.selectionStart, end: o.selectionEnd };
    else e: {
      c = (c = o.ownerDocument) && c.defaultView || window;
      var f = c.getSelection && c.getSelection();
      if (f && f.rangeCount !== 0) {
        c = f.anchorNode;
        var g = f.anchorOffset, x = f.focusNode;
        f = f.focusOffset;
        try {
          c.nodeType, x.nodeType;
        } catch {
          c = null;
          break e;
        }
        var k = 0, A = -1, N = -1, H = 0, Z = 0, K = o, J = null;
        t: for (; ; ) {
          for (var pe; K !== c || g !== 0 && K.nodeType !== 3 || (A = k + g), K !== x || f !== 0 && K.nodeType !== 3 || (N = k + f), K.nodeType === 3 && (k += K.nodeValue.length), (pe = K.firstChild) !== null; )
            J = K, K = pe;
          for (; ; ) {
            if (K === o) break t;
            if (J === c && ++H === g && (A = k), J === x && ++Z === f && (N = k), (pe = K.nextSibling) !== null) break;
            K = J, J = K.parentNode;
          }
          K = pe;
        }
        c = A === -1 || N === -1 ? null : { start: A, end: N };
      } else c = null;
    }
    c = c || { start: 0, end: 0 };
  } else c = null;
  for (tne = { focusedElem: o, selectionRange: c }, Y9 = !1, qo = a; qo !== null; ) if (a = qo, o = a.child, (a.subtreeFlags & 1028) !== 0 && o !== null) o.return = a, qo = o;
  else for (; qo !== null; ) {
    a = qo;
    try {
      var Se = a.alternate;
      if (a.flags & 1024) switch (a.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (Se !== null) {
            var be = Se.memoizedProps, ye = Se.memoizedState, re = a.stateNode, oe = re.getSnapshotBeforeUpdate(a.elementType === a.type ? be : Jg(a.type, be), ye);
            re.__reactInternalSnapshotBeforeUpdate = oe;
          }
          break;
        case 3:
          var U = a.stateNode.containerInfo;
          U.nodeType === 1 ? U.textContent = "" : U.nodeType === 9 && U.documentElement && U.removeChild(U.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(no(163));
      }
    } catch (ve) {
      Kl(a, a.return, ve);
    }
    if (o = a.sibling, o !== null) {
      o.return = a.return, qo = o;
      break;
    }
    qo = a.return;
  }
  return Se = zie, zie = !1, Se;
}
function W5(o, a, c) {
  var f = a.updateQueue;
  if (f = f !== null ? f.lastEffect : null, f !== null) {
    var g = f = f.next;
    do {
      if ((g.tag & o) === o) {
        var x = g.destroy;
        g.destroy = void 0, x !== void 0 && vne(a, c, x);
      }
      g = g.next;
    } while (g !== f);
  }
}
function IV(o, a) {
  if (a = a.updateQueue, a = a !== null ? a.lastEffect : null, a !== null) {
    var c = a = a.next;
    do {
      if ((c.tag & o) === o) {
        var f = c.create;
        c.destroy = f();
      }
      c = c.next;
    } while (c !== a);
  }
}
function bne(o) {
  var a = o.ref;
  if (a !== null) {
    var c = o.stateNode;
    switch (o.tag) {
      case 5:
        o = c;
        break;
      default:
        o = c;
    }
    typeof a == "function" ? a(o) : a.current = o;
  }
}
function yde(o) {
  var a = o.alternate;
  a !== null && (o.alternate = null, yde(a)), o.child = null, o.deletions = null, o.sibling = null, o.tag === 5 && (a = o.stateNode, a !== null && (delete a[Nb], delete a[cI], delete a[sne], delete a[uge], delete a[dge])), o.stateNode = null, o.return = null, o.dependencies = null, o.memoizedProps = null, o.memoizedState = null, o.pendingProps = null, o.stateNode = null, o.updateQueue = null;
}
function xde(o) {
  return o.tag === 5 || o.tag === 3 || o.tag === 4;
}
function Vie(o) {
  e: for (; ; ) {
    for (; o.sibling === null; ) {
      if (o.return === null || xde(o.return)) return null;
      o = o.return;
    }
    for (o.sibling.return = o.return, o = o.sibling; o.tag !== 5 && o.tag !== 6 && o.tag !== 18; ) {
      if (o.flags & 2 || o.child === null || o.tag === 4) continue e;
      o.child.return = o, o = o.child;
    }
    if (!(o.flags & 2)) return o.stateNode;
  }
}
function yne(o, a, c) {
  var f = o.tag;
  if (f === 5 || f === 6) o = o.stateNode, a ? c.nodeType === 8 ? c.parentNode.insertBefore(o, a) : c.insertBefore(o, a) : (c.nodeType === 8 ? (a = c.parentNode, a.insertBefore(o, c)) : (a = c, a.appendChild(o)), c = c._reactRootContainer, c != null || a.onclick !== null || (a.onclick = J9));
  else if (f !== 4 && (o = o.child, o !== null)) for (yne(o, a, c), o = o.sibling; o !== null; ) yne(o, a, c), o = o.sibling;
}
function xne(o, a, c) {
  var f = o.tag;
  if (f === 5 || f === 6) o = o.stateNode, a ? c.insertBefore(o, a) : c.appendChild(o);
  else if (f !== 4 && (o = o.child, o !== null)) for (xne(o, a, c), o = o.sibling; o !== null; ) xne(o, a, c), o = o.sibling;
}
var ld = null, ev = !1;
function x2(o, a, c) {
  for (c = c.child; c !== null; ) wde(o, a, c), c = c.sibling;
}
function wde(o, a, c) {
  if (Ib && typeof Ib.onCommitFiberUnmount == "function") try {
    Ib.onCommitFiberUnmount(TV, c);
  } catch {
  }
  switch (c.tag) {
    case 5:
      jd || w4(c, a);
    case 6:
      var f = ld, g = ev;
      ld = null, x2(o, a, c), ld = f, ev = g, ld !== null && (ev ? (o = ld, c = c.stateNode, o.nodeType === 8 ? o.parentNode.removeChild(c) : o.removeChild(c)) : ld.removeChild(c.stateNode));
      break;
    case 18:
      ld !== null && (ev ? (o = ld, c = c.stateNode, o.nodeType === 8 ? Jee(o.parentNode, c) : o.nodeType === 1 && Jee(o, c), sI(o)) : Jee(ld, c.stateNode));
      break;
    case 4:
      f = ld, g = ev, ld = c.stateNode.containerInfo, ev = !0, x2(o, a, c), ld = f, ev = g;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!jd && (f = c.updateQueue, f !== null && (f = f.lastEffect, f !== null))) {
        g = f = f.next;
        do {
          var x = g, k = x.destroy;
          x = x.tag, k !== void 0 && (x & 2 || x & 4) && vne(c, a, k), g = g.next;
        } while (g !== f);
      }
      x2(o, a, c);
      break;
    case 1:
      if (!jd && (w4(c, a), f = c.stateNode, typeof f.componentWillUnmount == "function")) try {
        f.props = c.memoizedProps, f.state = c.memoizedState, f.componentWillUnmount();
      } catch (A) {
        Kl(c, a, A);
      }
      x2(o, a, c);
      break;
    case 21:
      x2(o, a, c);
      break;
    case 22:
      c.mode & 1 ? (jd = (f = jd) || c.memoizedState !== null, x2(o, a, c), jd = f) : x2(o, a, c);
      break;
    default:
      x2(o, a, c);
  }
}
function Uie(o) {
  var a = o.updateQueue;
  if (a !== null) {
    o.updateQueue = null;
    var c = o.stateNode;
    c === null && (c = o.stateNode = new Tge()), a.forEach(function(f) {
      var g = Bge.bind(null, o, f);
      c.has(f) || (c.add(f), f.then(g, g));
    });
  }
}
function Qg(o, a) {
  var c = a.deletions;
  if (c !== null) for (var f = 0; f < c.length; f++) {
    var g = c[f];
    try {
      var x = o, k = a, A = k;
      e: for (; A !== null; ) {
        switch (A.tag) {
          case 5:
            ld = A.stateNode, ev = !1;
            break e;
          case 3:
            ld = A.stateNode.containerInfo, ev = !0;
            break e;
          case 4:
            ld = A.stateNode.containerInfo, ev = !0;
            break e;
        }
        A = A.return;
      }
      if (ld === null) throw Error(no(160));
      wde(x, k, g), ld = null, ev = !1;
      var N = g.alternate;
      N !== null && (N.return = null), g.return = null;
    } catch (H) {
      Kl(g, a, H);
    }
  }
  if (a.subtreeFlags & 12854) for (a = a.child; a !== null; ) Cde(a, o), a = a.sibling;
}
function Cde(o, a) {
  var c = o.alternate, f = o.flags;
  switch (o.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if (Qg(a, o), Db(o), f & 4) {
        try {
          W5(3, o, o.return), IV(3, o);
        } catch (be) {
          Kl(o, o.return, be);
        }
        try {
          W5(5, o, o.return);
        } catch (be) {
          Kl(o, o.return, be);
        }
      }
      break;
    case 1:
      Qg(a, o), Db(o), f & 512 && c !== null && w4(c, c.return);
      break;
    case 5:
      if (Qg(a, o), Db(o), f & 512 && c !== null && w4(c, c.return), o.flags & 32) {
        var g = o.stateNode;
        try {
          eI(g, "");
        } catch (be) {
          Kl(o, o.return, be);
        }
      }
      if (f & 4 && (g = o.stateNode, g != null)) {
        var x = o.memoizedProps, k = c !== null ? c.memoizedProps : x, A = o.type, N = o.updateQueue;
        if (o.updateQueue = null, N !== null) try {
          A === "input" && x.type === "radio" && x.name != null && jce(g, x), jte(A, k);
          var H = jte(A, x);
          for (k = 0; k < N.length; k += 2) {
            var Z = N[k], K = N[k + 1];
            Z === "style" ? Kce(g, K) : Z === "dangerouslySetInnerHTML" ? Gce(g, K) : Z === "children" ? eI(g, K) : moe(g, Z, K, H);
          }
          switch (A) {
            case "input":
              $te(g, x);
              break;
            case "textarea":
              Wce(g, x);
              break;
            case "select":
              var J = g._wrapperState.wasMultiple;
              g._wrapperState.wasMultiple = !!x.multiple;
              var pe = x.value;
              pe != null ? A4(g, !!x.multiple, pe, !1) : J !== !!x.multiple && (x.defaultValue != null ? A4(
                g,
                !!x.multiple,
                x.defaultValue,
                !0
              ) : A4(g, !!x.multiple, x.multiple ? [] : "", !1));
          }
          g[cI] = x;
        } catch (be) {
          Kl(o, o.return, be);
        }
      }
      break;
    case 6:
      if (Qg(a, o), Db(o), f & 4) {
        if (o.stateNode === null) throw Error(no(162));
        g = o.stateNode, x = o.memoizedProps;
        try {
          g.nodeValue = x;
        } catch (be) {
          Kl(o, o.return, be);
        }
      }
      break;
    case 3:
      if (Qg(a, o), Db(o), f & 4 && c !== null && c.memoizedState.isDehydrated) try {
        sI(a.containerInfo);
      } catch (be) {
        Kl(o, o.return, be);
      }
      break;
    case 4:
      Qg(a, o), Db(o);
      break;
    case 13:
      Qg(a, o), Db(o), g = o.child, g.flags & 8192 && (x = g.memoizedState !== null, g.stateNode.isHidden = x, !x || g.alternate !== null && g.alternate.memoizedState !== null || (Zoe = yc())), f & 4 && Uie(o);
      break;
    case 22:
      if (Z = c !== null && c.memoizedState !== null, o.mode & 1 ? (jd = (H = jd) || Z, Qg(a, o), jd = H) : Qg(a, o), Db(o), f & 8192) {
        if (H = o.memoizedState !== null, (o.stateNode.isHidden = H) && !Z && o.mode & 1) for (qo = o, Z = o.child; Z !== null; ) {
          for (K = qo = Z; qo !== null; ) {
            switch (J = qo, pe = J.child, J.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                W5(4, J, J.return);
                break;
              case 1:
                w4(J, J.return);
                var Se = J.stateNode;
                if (typeof Se.componentWillUnmount == "function") {
                  f = J, c = J.return;
                  try {
                    a = f, Se.props = a.memoizedProps, Se.state = a.memoizedState, Se.componentWillUnmount();
                  } catch (be) {
                    Kl(f, c, be);
                  }
                }
                break;
              case 5:
                w4(J, J.return);
                break;
              case 22:
                if (J.memoizedState !== null) {
                  Wie(K);
                  continue;
                }
            }
            pe !== null ? (pe.return = J, qo = pe) : Wie(K);
          }
          Z = Z.sibling;
        }
        e: for (Z = null, K = o; ; ) {
          if (K.tag === 5) {
            if (Z === null) {
              Z = K;
              try {
                g = K.stateNode, H ? (x = g.style, typeof x.setProperty == "function" ? x.setProperty("display", "none", "important") : x.display = "none") : (A = K.stateNode, N = K.memoizedProps.style, k = N != null && N.hasOwnProperty("display") ? N.display : null, A.style.display = qce("display", k));
              } catch (be) {
                Kl(o, o.return, be);
              }
            }
          } else if (K.tag === 6) {
            if (Z === null) try {
              K.stateNode.nodeValue = H ? "" : K.memoizedProps;
            } catch (be) {
              Kl(o, o.return, be);
            }
          } else if ((K.tag !== 22 && K.tag !== 23 || K.memoizedState === null || K === o) && K.child !== null) {
            K.child.return = K, K = K.child;
            continue;
          }
          if (K === o) break e;
          for (; K.sibling === null; ) {
            if (K.return === null || K.return === o) break e;
            Z === K && (Z = null), K = K.return;
          }
          Z === K && (Z = null), K.sibling.return = K.return, K = K.sibling;
        }
      }
      break;
    case 19:
      Qg(a, o), Db(o), f & 4 && Uie(o);
      break;
    case 21:
      break;
    default:
      Qg(
        a,
        o
      ), Db(o);
  }
}
function Db(o) {
  var a = o.flags;
  if (a & 2) {
    try {
      e: {
        for (var c = o.return; c !== null; ) {
          if (xde(c)) {
            var f = c;
            break e;
          }
          c = c.return;
        }
        throw Error(no(160));
      }
      switch (f.tag) {
        case 5:
          var g = f.stateNode;
          f.flags & 32 && (eI(g, ""), f.flags &= -33);
          var x = Vie(o);
          xne(o, x, g);
          break;
        case 3:
        case 4:
          var k = f.stateNode.containerInfo, A = Vie(o);
          yne(o, A, k);
          break;
        default:
          throw Error(no(161));
      }
    } catch (N) {
      Kl(o, o.return, N);
    }
    o.flags &= -3;
  }
  a & 4096 && (o.flags &= -4097);
}
function Oge(o, a, c) {
  qo = o, Sde(o);
}
function Sde(o, a, c) {
  for (var f = (o.mode & 1) !== 0; qo !== null; ) {
    var g = qo, x = g.child;
    if (g.tag === 22 && f) {
      var k = g.memoizedState !== null || r9;
      if (!k) {
        var A = g.alternate, N = A !== null && A.memoizedState !== null || jd;
        A = r9;
        var H = jd;
        if (r9 = k, (jd = N) && !H) for (qo = g; qo !== null; ) k = qo, N = k.child, k.tag === 22 && k.memoizedState !== null ? Zie(g) : N !== null ? (N.return = k, qo = N) : Zie(g);
        for (; x !== null; ) qo = x, Sde(x), x = x.sibling;
        qo = g, r9 = A, jd = H;
      }
      jie(o);
    } else g.subtreeFlags & 8772 && x !== null ? (x.return = g, qo = x) : jie(o);
  }
}
function jie(o) {
  for (; qo !== null; ) {
    var a = qo;
    if (a.flags & 8772) {
      var c = a.alternate;
      try {
        if (a.flags & 8772) switch (a.tag) {
          case 0:
          case 11:
          case 15:
            jd || IV(5, a);
            break;
          case 1:
            var f = a.stateNode;
            if (a.flags & 4 && !jd) if (c === null) f.componentDidMount();
            else {
              var g = a.elementType === a.type ? c.memoizedProps : Jg(a.type, c.memoizedProps);
              f.componentDidUpdate(g, c.memoizedState, f.__reactInternalSnapshotBeforeUpdate);
            }
            var x = a.updateQueue;
            x !== null && Aie(a, x, f);
            break;
          case 3:
            var k = a.updateQueue;
            if (k !== null) {
              if (c = null, a.child !== null) switch (a.child.tag) {
                case 5:
                  c = a.child.stateNode;
                  break;
                case 1:
                  c = a.child.stateNode;
              }
              Aie(a, k, c);
            }
            break;
          case 5:
            var A = a.stateNode;
            if (c === null && a.flags & 4) {
              c = A;
              var N = a.memoizedProps;
              switch (a.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  N.autoFocus && c.focus();
                  break;
                case "img":
                  N.src && (c.src = N.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (a.memoizedState === null) {
              var H = a.alternate;
              if (H !== null) {
                var Z = H.memoizedState;
                if (Z !== null) {
                  var K = Z.dehydrated;
                  K !== null && sI(K);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(no(163));
        }
        jd || a.flags & 512 && bne(a);
      } catch (J) {
        Kl(a, a.return, J);
      }
    }
    if (a === o) {
      qo = null;
      break;
    }
    if (c = a.sibling, c !== null) {
      c.return = a.return, qo = c;
      break;
    }
    qo = a.return;
  }
}
function Wie(o) {
  for (; qo !== null; ) {
    var a = qo;
    if (a === o) {
      qo = null;
      break;
    }
    var c = a.sibling;
    if (c !== null) {
      c.return = a.return, qo = c;
      break;
    }
    qo = a.return;
  }
}
function Zie(o) {
  for (; qo !== null; ) {
    var a = qo;
    try {
      switch (a.tag) {
        case 0:
        case 11:
        case 15:
          var c = a.return;
          try {
            IV(4, a);
          } catch (N) {
            Kl(a, c, N);
          }
          break;
        case 1:
          var f = a.stateNode;
          if (typeof f.componentDidMount == "function") {
            var g = a.return;
            try {
              f.componentDidMount();
            } catch (N) {
              Kl(a, g, N);
            }
          }
          var x = a.return;
          try {
            bne(a);
          } catch (N) {
            Kl(a, x, N);
          }
          break;
        case 5:
          var k = a.return;
          try {
            bne(a);
          } catch (N) {
            Kl(a, k, N);
          }
      }
    } catch (N) {
      Kl(a, a.return, N);
    }
    if (a === o) {
      qo = null;
      break;
    }
    var A = a.sibling;
    if (A !== null) {
      A.return = a.return, qo = A;
      break;
    }
    qo = a.return;
  }
}
var Dge = Math.ceil, uV = W0.ReactCurrentDispatcher, joe = W0.ReactCurrentOwner, Mh = W0.ReactCurrentBatchConfig, Sa = 0, Mu = null, Ic = null, ud = 0, up = 0, C4 = G2(0), lu = 0, hI = null, Gk = 0, FV = 0, Woe = 0, Z5 = null, xm = null, Zoe = 0, j4 = 1 / 0, D0 = null, dV = !1, wne = null, I2 = null, a9 = !1, A2 = null, fV = 0, G5 = 0, Cne = null, I9 = -1, F9 = 0;
function Nf() {
  return Sa & 6 ? yc() : I9 !== -1 ? I9 : I9 = yc();
}
function F2(o) {
  return o.mode & 1 ? Sa & 2 && ud !== 0 ? ud & -ud : mge.transition !== null ? (F9 === 0 && (F9 = iue()), F9) : (o = ri, o !== 0 || (o = window.event, o = o === void 0 ? 16 : pue(o.type)), o) : 1;
}
function rv(o, a, c, f) {
  if (50 < G5) throw G5 = 0, Cne = null, Error(no(185));
  RI(o, c, f), (!(Sa & 2) || o !== Mu) && (o === Mu && (!(Sa & 2) && (FV |= c), lu === 4 && E2(o, ud)), km(o, f), c === 1 && Sa === 0 && !(a.mode & 1) && (j4 = yc() + 500, NV && q2()));
}
function km(o, a) {
  var c = o.callbackNode;
  mhe(o, a);
  var f = K9(o, o === Mu ? ud : 0);
  if (f === 0) c !== null && tie(c), o.callbackNode = null, o.callbackPriority = 0;
  else if (a = f & -f, o.callbackPriority !== a) {
    if (c != null && tie(c), a === 1) o.tag === 0 ? fge(Gie.bind(null, o)) : Pue(Gie.bind(null, o)), lge(function() {
      !(Sa & 6) && q2();
    }), c = null;
    else {
      switch (lue(f)) {
        case 1:
          c = boe;
          break;
        case 4:
          c = rue;
          break;
        case 16:
          c = q9;
          break;
        case 536870912:
          c = aue;
          break;
        default:
          c = q9;
      }
      c = Rde(c, kde.bind(null, o));
    }
    o.callbackPriority = a, o.callbackNode = c;
  }
}
function kde(o, a) {
  if (I9 = -1, F9 = 0, Sa & 6) throw Error(no(327));
  var c = o.callbackNode;
  if (P4() && o.callbackNode !== c) return null;
  var f = K9(o, o === Mu ? ud : 0);
  if (f === 0) return null;
  if (f & 30 || f & o.expiredLanes || a) a = mV(o, f);
  else {
    a = f;
    var g = Sa;
    Sa |= 2;
    var x = Ede();
    (Mu !== o || ud !== a) && (D0 = null, j4 = yc() + 500, $k(o, a));
    do
      try {
        Pge();
        break;
      } catch (A) {
        _de(o, A);
      }
    while (!0);
    Roe(), uV.current = x, Sa = g, Ic !== null ? a = 0 : (Mu = null, ud = 0, a = lu);
  }
  if (a !== 0) {
    if (a === 2 && (g = Kte(o), g !== 0 && (f = g, a = Sne(o, g))), a === 1) throw c = hI, $k(o, 0), E2(o, f), km(o, yc()), c;
    if (a === 6) E2(o, f);
    else {
      if (g = o.current.alternate, !(f & 30) && !Rge(g) && (a = mV(o, f), a === 2 && (x = Kte(o), x !== 0 && (f = x, a = Sne(o, x))), a === 1)) throw c = hI, $k(o, 0), E2(o, f), km(o, yc()), c;
      switch (o.finishedWork = g, o.finishedLanes = f, a) {
        case 0:
        case 1:
          throw Error(no(345));
        case 2:
          Ak(o, xm, D0);
          break;
        case 3:
          if (E2(o, f), (f & 130023424) === f && (a = Zoe + 500 - yc(), 10 < a)) {
            if (K9(o, 0) !== 0) break;
            if (g = o.suspendedLanes, (g & f) !== f) {
              Nf(), o.pingedLanes |= o.suspendedLanes & g;
              break;
            }
            o.timeoutHandle = one(Ak.bind(null, o, xm, D0), a);
            break;
          }
          Ak(o, xm, D0);
          break;
        case 4:
          if (E2(o, f), (f & 4194240) === f) break;
          for (a = o.eventTimes, g = -1; 0 < f; ) {
            var k = 31 - sv(f);
            x = 1 << k, k = a[k], k > g && (g = k), f &= ~x;
          }
          if (f = g, f = yc() - f, f = (120 > f ? 120 : 480 > f ? 480 : 1080 > f ? 1080 : 1920 > f ? 1920 : 3e3 > f ? 3e3 : 4320 > f ? 4320 : 1960 * Dge(f / 1960)) - f, 10 < f) {
            o.timeoutHandle = one(Ak.bind(null, o, xm, D0), f);
            break;
          }
          Ak(o, xm, D0);
          break;
        case 5:
          Ak(o, xm, D0);
          break;
        default:
          throw Error(no(329));
      }
    }
  }
  return km(o, yc()), o.callbackNode === c ? kde.bind(null, o) : null;
}
function Sne(o, a) {
  var c = Z5;
  return o.current.memoizedState.isDehydrated && ($k(o, a).flags |= 256), o = mV(o, a), o !== 2 && (a = xm, xm = c, a !== null && kne(a)), o;
}
function kne(o) {
  xm === null ? xm = o : xm.push.apply(xm, o);
}
function Rge(o) {
  for (var a = o; ; ) {
    if (a.flags & 16384) {
      var c = a.updateQueue;
      if (c !== null && (c = c.stores, c !== null)) for (var f = 0; f < c.length; f++) {
        var g = c[f], x = g.getSnapshot;
        g = g.value;
        try {
          if (!av(x(), g)) return !1;
        } catch {
          return !1;
        }
      }
    }
    if (c = a.child, a.subtreeFlags & 16384 && c !== null) c.return = a, a = c;
    else {
      if (a === o) break;
      for (; a.sibling === null; ) {
        if (a.return === null || a.return === o) return !0;
        a = a.return;
      }
      a.sibling.return = a.return, a = a.sibling;
    }
  }
  return !0;
}
function E2(o, a) {
  for (a &= ~Woe, a &= ~FV, o.suspendedLanes |= a, o.pingedLanes &= ~a, o = o.expirationTimes; 0 < a; ) {
    var c = 31 - sv(a), f = 1 << c;
    o[c] = -1, a &= ~f;
  }
}
function Gie(o) {
  if (Sa & 6) throw Error(no(327));
  P4();
  var a = K9(o, 0);
  if (!(a & 1)) return km(o, yc()), null;
  var c = mV(o, a);
  if (o.tag !== 0 && c === 2) {
    var f = Kte(o);
    f !== 0 && (a = f, c = Sne(o, f));
  }
  if (c === 1) throw c = hI, $k(o, 0), E2(o, a), km(o, yc()), c;
  if (c === 6) throw Error(no(345));
  return o.finishedWork = o.current.alternate, o.finishedLanes = a, Ak(o, xm, D0), km(o, yc()), null;
}
function Goe(o, a) {
  var c = Sa;
  Sa |= 1;
  try {
    return o(a);
  } finally {
    Sa = c, Sa === 0 && (j4 = yc() + 500, NV && q2());
  }
}
function qk(o) {
  A2 !== null && A2.tag === 0 && !(Sa & 6) && P4();
  var a = Sa;
  Sa |= 1;
  var c = Mh.transition, f = ri;
  try {
    if (Mh.transition = null, ri = 1, o) return o();
  } finally {
    ri = f, Mh.transition = c, Sa = a, !(Sa & 6) && q2();
  }
}
function qoe() {
  up = C4.current, il(C4);
}
function $k(o, a) {
  o.finishedWork = null, o.finishedLanes = 0;
  var c = o.timeoutHandle;
  if (c !== -1 && (o.timeoutHandle = -1, ige(c)), Ic !== null) for (c = Ic.return; c !== null; ) {
    var f = c;
    switch (Aoe(f), f.tag) {
      case 1:
        f = f.type.childContextTypes, f != null && eV();
        break;
      case 3:
        V4(), il(Cm), il(Kd), Boe();
        break;
      case 5:
        Foe(f);
        break;
      case 4:
        V4();
        break;
      case 13:
        il(Ml);
        break;
      case 19:
        il(Ml);
        break;
      case 10:
        Noe(f.type._context);
        break;
      case 22:
      case 23:
        qoe();
    }
    c = c.return;
  }
  if (Mu = o, Ic = o = B2(o.current, null), ud = up = a, lu = 0, hI = null, Woe = FV = Gk = 0, xm = Z5 = null, Nk !== null) {
    for (a = 0; a < Nk.length; a++) if (c = Nk[a], f = c.interleaved, f !== null) {
      c.interleaved = null;
      var g = f.next, x = c.pending;
      if (x !== null) {
        var k = x.next;
        x.next = g, f.next = k;
      }
      c.pending = f;
    }
    Nk = null;
  }
  return o;
}
function _de(o, a) {
  do {
    var c = Ic;
    try {
      if (Roe(), N9.current = cV, lV) {
        for (var f = Il.memoizedState; f !== null; ) {
          var g = f.queue;
          g !== null && (g.pending = null), f = f.next;
        }
        lV = !1;
      }
      if (Zk = 0, Pu = iu = Il = null, j5 = !1, fI = 0, joe.current = null, c === null || c.return === null) {
        lu = 1, hI = a, Ic = null;
        break;
      }
      e: {
        var x = o, k = c.return, A = c, N = a;
        if (a = ud, A.flags |= 32768, N !== null && typeof N == "object" && typeof N.then == "function") {
          var H = N, Z = A, K = Z.tag;
          if (!(Z.mode & 1) && (K === 0 || K === 11 || K === 15)) {
            var J = Z.alternate;
            J ? (Z.updateQueue = J.updateQueue, Z.memoizedState = J.memoizedState, Z.lanes = J.lanes) : (Z.updateQueue = null, Z.memoizedState = null);
          }
          var pe = Mie(k);
          if (pe !== null) {
            pe.flags &= -257, Iie(pe, k, A, x, a), pe.mode & 1 && Pie(x, H, a), a = pe, N = H;
            var Se = a.updateQueue;
            if (Se === null) {
              var be = /* @__PURE__ */ new Set();
              be.add(N), a.updateQueue = be;
            } else Se.add(N);
            break e;
          } else {
            if (!(a & 1)) {
              Pie(x, H, a), Koe();
              break e;
            }
            N = Error(no(426));
          }
        } else if (xl && A.mode & 1) {
          var ye = Mie(k);
          if (ye !== null) {
            !(ye.flags & 65536) && (ye.flags |= 256), Iie(ye, k, A, x, a), Ooe(U4(N, A));
            break e;
          }
        }
        x = N = U4(N, A), lu !== 4 && (lu = 2), Z5 === null ? Z5 = [x] : Z5.push(x), x = k;
        do {
          switch (x.tag) {
            case 3:
              x.flags |= 65536, a &= -a, x.lanes |= a;
              var re = lde(x, N, a);
              Tie(x, re);
              break e;
            case 1:
              A = N;
              var oe = x.type, U = x.stateNode;
              if (!(x.flags & 128) && (typeof oe.getDerivedStateFromError == "function" || U !== null && typeof U.componentDidCatch == "function" && (I2 === null || !I2.has(U)))) {
                x.flags |= 65536, a &= -a, x.lanes |= a;
                var ve = cde(x, A, a);
                Tie(x, ve);
                break e;
              }
          }
          x = x.return;
        } while (x !== null);
      }
      Ade(c);
    } catch (Ze) {
      a = Ze, Ic === c && c !== null && (Ic = c = c.return);
      continue;
    }
    break;
  } while (!0);
}
function Ede() {
  var o = uV.current;
  return uV.current = cV, o === null ? cV : o;
}
function Koe() {
  (lu === 0 || lu === 3 || lu === 2) && (lu = 4), Mu === null || !(Gk & 268435455) && !(FV & 268435455) || E2(Mu, ud);
}
function mV(o, a) {
  var c = Sa;
  Sa |= 2;
  var f = Ede();
  (Mu !== o || ud !== a) && (D0 = null, $k(o, a));
  do
    try {
      Nge();
      break;
    } catch (g) {
      _de(o, g);
    }
  while (!0);
  if (Roe(), Sa = c, uV.current = f, Ic !== null) throw Error(no(261));
  return Mu = null, ud = 0, lu;
}
function Nge() {
  for (; Ic !== null; ) Tde(Ic);
}
function Pge() {
  for (; Ic !== null && !she(); ) Tde(Ic);
}
function Tde(o) {
  var a = Dde(o.alternate, o, up);
  o.memoizedProps = o.pendingProps, a === null ? Ade(o) : Ic = a, joe.current = null;
}
function Ade(o) {
  var a = o;
  do {
    var c = a.alternate;
    if (o = a.return, a.flags & 32768) {
      if (c = Ege(c, a), c !== null) {
        c.flags &= 32767, Ic = c;
        return;
      }
      if (o !== null) o.flags |= 32768, o.subtreeFlags = 0, o.deletions = null;
      else {
        lu = 6, Ic = null;
        return;
      }
    } else if (c = _ge(c, a, up), c !== null) {
      Ic = c;
      return;
    }
    if (a = a.sibling, a !== null) {
      Ic = a;
      return;
    }
    Ic = a = o;
  } while (a !== null);
  lu === 0 && (lu = 5);
}
function Ak(o, a, c) {
  var f = ri, g = Mh.transition;
  try {
    Mh.transition = null, ri = 1, Mge(o, a, c, f);
  } finally {
    Mh.transition = g, ri = f;
  }
  return null;
}
function Mge(o, a, c, f) {
  do
    P4();
  while (A2 !== null);
  if (Sa & 6) throw Error(no(327));
  c = o.finishedWork;
  var g = o.finishedLanes;
  if (c === null) return null;
  if (o.finishedWork = null, o.finishedLanes = 0, c === o.current) throw Error(no(177));
  o.callbackNode = null, o.callbackPriority = 0;
  var x = c.lanes | c.childLanes;
  if (phe(o, x), o === Mu && (Ic = Mu = null, ud = 0), !(c.subtreeFlags & 2064) && !(c.flags & 2064) || a9 || (a9 = !0, Rde(q9, function() {
    return P4(), null;
  })), x = (c.flags & 15990) !== 0, c.subtreeFlags & 15990 || x) {
    x = Mh.transition, Mh.transition = null;
    var k = ri;
    ri = 1;
    var A = Sa;
    Sa |= 4, joe.current = null, Age(o, c), Cde(c, o), ege(tne), Y9 = !!ene, tne = ene = null, o.current = c, Oge(c), rhe(), Sa = A, ri = k, Mh.transition = x;
  } else o.current = c;
  if (a9 && (a9 = !1, A2 = o, fV = g), x = o.pendingLanes, x === 0 && (I2 = null), lhe(c.stateNode), km(o, yc()), a !== null) for (f = o.onRecoverableError, c = 0; c < a.length; c++) g = a[c], f(g.value, { componentStack: g.stack, digest: g.digest });
  if (dV) throw dV = !1, o = wne, wne = null, o;
  return fV & 1 && o.tag !== 0 && P4(), x = o.pendingLanes, x & 1 ? o === Cne ? G5++ : (G5 = 0, Cne = o) : G5 = 0, q2(), null;
}
function P4() {
  if (A2 !== null) {
    var o = lue(fV), a = Mh.transition, c = ri;
    try {
      if (Mh.transition = null, ri = 16 > o ? 16 : o, A2 === null) var f = !1;
      else {
        if (o = A2, A2 = null, fV = 0, Sa & 6) throw Error(no(331));
        var g = Sa;
        for (Sa |= 4, qo = o.current; qo !== null; ) {
          var x = qo, k = x.child;
          if (qo.flags & 16) {
            var A = x.deletions;
            if (A !== null) {
              for (var N = 0; N < A.length; N++) {
                var H = A[N];
                for (qo = H; qo !== null; ) {
                  var Z = qo;
                  switch (Z.tag) {
                    case 0:
                    case 11:
                    case 15:
                      W5(8, Z, x);
                  }
                  var K = Z.child;
                  if (K !== null) K.return = Z, qo = K;
                  else for (; qo !== null; ) {
                    Z = qo;
                    var J = Z.sibling, pe = Z.return;
                    if (yde(Z), Z === H) {
                      qo = null;
                      break;
                    }
                    if (J !== null) {
                      J.return = pe, qo = J;
                      break;
                    }
                    qo = pe;
                  }
                }
              }
              var Se = x.alternate;
              if (Se !== null) {
                var be = Se.child;
                if (be !== null) {
                  Se.child = null;
                  do {
                    var ye = be.sibling;
                    be.sibling = null, be = ye;
                  } while (be !== null);
                }
              }
              qo = x;
            }
          }
          if (x.subtreeFlags & 2064 && k !== null) k.return = x, qo = k;
          else e: for (; qo !== null; ) {
            if (x = qo, x.flags & 2048) switch (x.tag) {
              case 0:
              case 11:
              case 15:
                W5(9, x, x.return);
            }
            var re = x.sibling;
            if (re !== null) {
              re.return = x.return, qo = re;
              break e;
            }
            qo = x.return;
          }
        }
        var oe = o.current;
        for (qo = oe; qo !== null; ) {
          k = qo;
          var U = k.child;
          if (k.subtreeFlags & 2064 && U !== null) U.return = k, qo = U;
          else e: for (k = oe; qo !== null; ) {
            if (A = qo, A.flags & 2048) try {
              switch (A.tag) {
                case 0:
                case 11:
                case 15:
                  IV(9, A);
              }
            } catch (Ze) {
              Kl(A, A.return, Ze);
            }
            if (A === k) {
              qo = null;
              break e;
            }
            var ve = A.sibling;
            if (ve !== null) {
              ve.return = A.return, qo = ve;
              break e;
            }
            qo = A.return;
          }
        }
        if (Sa = g, q2(), Ib && typeof Ib.onPostCommitFiberRoot == "function") try {
          Ib.onPostCommitFiberRoot(TV, o);
        } catch {
        }
        f = !0;
      }
      return f;
    } finally {
      ri = c, Mh.transition = a;
    }
  }
  return !1;
}
function qie(o, a, c) {
  a = U4(c, a), a = lde(o, a, 1), o = M2(o, a, 1), a = Nf(), o !== null && (RI(o, 1, a), km(o, a));
}
function Kl(o, a, c) {
  if (o.tag === 3) qie(o, o, c);
  else for (; a !== null; ) {
    if (a.tag === 3) {
      qie(a, o, c);
      break;
    } else if (a.tag === 1) {
      var f = a.stateNode;
      if (typeof a.type.getDerivedStateFromError == "function" || typeof f.componentDidCatch == "function" && (I2 === null || !I2.has(f))) {
        o = U4(c, o), o = cde(a, o, 1), a = M2(a, o, 1), o = Nf(), a !== null && (RI(a, 1, o), km(a, o));
        break;
      }
    }
    a = a.return;
  }
}
function Ige(o, a, c) {
  var f = o.pingCache;
  f !== null && f.delete(a), a = Nf(), o.pingedLanes |= o.suspendedLanes & c, Mu === o && (ud & c) === c && (lu === 4 || lu === 3 && (ud & 130023424) === ud && 500 > yc() - Zoe ? $k(o, 0) : Woe |= c), km(o, a);
}
function Ode(o, a) {
  a === 0 && (o.mode & 1 ? (a = Yz, Yz <<= 1, !(Yz & 130023424) && (Yz = 4194304)) : a = 1);
  var c = Nf();
  o = L0(o, a), o !== null && (RI(o, a, c), km(o, c));
}
function Fge(o) {
  var a = o.memoizedState, c = 0;
  a !== null && (c = a.retryLane), Ode(o, c);
}
function Bge(o, a) {
  var c = 0;
  switch (o.tag) {
    case 13:
      var f = o.stateNode, g = o.memoizedState;
      g !== null && (c = g.retryLane);
      break;
    case 19:
      f = o.stateNode;
      break;
    default:
      throw Error(no(314));
  }
  f !== null && f.delete(a), Ode(o, c);
}
var Dde;
Dde = function(o, a, c) {
  if (o !== null) if (o.memoizedProps !== a.pendingProps || Cm.current) wm = !0;
  else {
    if (!(o.lanes & c) && !(a.flags & 128)) return wm = !1, kge(o, a, c);
    wm = !!(o.flags & 131072);
  }
  else wm = !1, xl && a.flags & 1048576 && Mue(a, oV, a.index);
  switch (a.lanes = 0, a.tag) {
    case 2:
      var f = a.type;
      M9(o, a), o = a.pendingProps;
      var g = $4(a, Kd.current);
      N4(a, c), g = $oe(null, a, f, o, g, c);
      var x = Hoe();
      return a.flags |= 1, typeof g == "object" && g !== null && typeof g.render == "function" && g.$$typeof === void 0 ? (a.tag = 1, a.memoizedState = null, a.updateQueue = null, Sm(f) ? (x = !0, tV(a)) : x = !1, a.memoizedState = g.state !== null && g.state !== void 0 ? g.state : null, Moe(a), g.updater = MV, a.stateNode = g, g._reactInternals = a, une(a, f, o, c), a = mne(null, a, f, !0, x, c)) : (a.tag = 0, xl && x && Toe(a), Rf(null, a, g, c), a = a.child), a;
    case 16:
      f = a.elementType;
      e: {
        switch (M9(o, a), o = a.pendingProps, g = f._init, f = g(f._payload), a.type = f, g = a.tag = $ge(f), o = Jg(f, o), g) {
          case 0:
            a = fne(null, a, f, o, c);
            break e;
          case 1:
            a = Lie(null, a, f, o, c);
            break e;
          case 11:
            a = Fie(null, a, f, o, c);
            break e;
          case 14:
            a = Bie(null, a, f, Jg(f.type, o), c);
            break e;
        }
        throw Error(no(
          306,
          f,
          ""
        ));
      }
      return a;
    case 0:
      return f = a.type, g = a.pendingProps, g = a.elementType === f ? g : Jg(f, g), fne(o, a, f, g, c);
    case 1:
      return f = a.type, g = a.pendingProps, g = a.elementType === f ? g : Jg(f, g), Lie(o, a, f, g, c);
    case 3:
      e: {
        if (mde(a), o === null) throw Error(no(387));
        f = a.pendingProps, x = a.memoizedState, g = x.element, Hue(o, a), aV(a, f, null, c);
        var k = a.memoizedState;
        if (f = k.element, x.isDehydrated) if (x = { element: f, isDehydrated: !1, cache: k.cache, pendingSuspenseBoundaries: k.pendingSuspenseBoundaries, transitions: k.transitions }, a.updateQueue.baseState = x, a.memoizedState = x, a.flags & 256) {
          g = U4(Error(no(423)), a), a = $ie(o, a, f, c, g);
          break e;
        } else if (f !== g) {
          g = U4(Error(no(424)), a), a = $ie(o, a, f, c, g);
          break e;
        } else for (fp = P2(a.stateNode.containerInfo.firstChild), mp = a, xl = !0, nv = null, c = Lue(a, null, f, c), a.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
        else {
          if (H4(), f === g) {
            a = $0(o, a, c);
            break e;
          }
          Rf(o, a, f, c);
        }
        a = a.child;
      }
      return a;
    case 5:
      return zue(a), o === null && ine(a), f = a.type, g = a.pendingProps, x = o !== null ? o.memoizedProps : null, k = g.children, nne(f, g) ? k = null : x !== null && nne(f, x) && (a.flags |= 32), fde(o, a), Rf(o, a, k, c), a.child;
    case 6:
      return o === null && ine(a), null;
    case 13:
      return pde(o, a, c);
    case 4:
      return Ioe(a, a.stateNode.containerInfo), f = a.pendingProps, o === null ? a.child = z4(a, null, f, c) : Rf(o, a, f, c), a.child;
    case 11:
      return f = a.type, g = a.pendingProps, g = a.elementType === f ? g : Jg(f, g), Fie(o, a, f, g, c);
    case 7:
      return Rf(o, a, a.pendingProps, c), a.child;
    case 8:
      return Rf(o, a, a.pendingProps.children, c), a.child;
    case 12:
      return Rf(o, a, a.pendingProps.children, c), a.child;
    case 10:
      e: {
        if (f = a.type._context, g = a.pendingProps, x = a.memoizedProps, k = g.value, Ui(sV, f._currentValue), f._currentValue = k, x !== null) if (av(x.value, k)) {
          if (x.children === g.children && !Cm.current) {
            a = $0(o, a, c);
            break e;
          }
        } else for (x = a.child, x !== null && (x.return = a); x !== null; ) {
          var A = x.dependencies;
          if (A !== null) {
            k = x.child;
            for (var N = A.firstContext; N !== null; ) {
              if (N.context === f) {
                if (x.tag === 1) {
                  N = I0(-1, c & -c), N.tag = 2;
                  var H = x.updateQueue;
                  if (H !== null) {
                    H = H.shared;
                    var Z = H.pending;
                    Z === null ? N.next = N : (N.next = Z.next, Z.next = N), H.pending = N;
                  }
                }
                x.lanes |= c, N = x.alternate, N !== null && (N.lanes |= c), lne(
                  x.return,
                  c,
                  a
                ), A.lanes |= c;
                break;
              }
              N = N.next;
            }
          } else if (x.tag === 10) k = x.type === a.type ? null : x.child;
          else if (x.tag === 18) {
            if (k = x.return, k === null) throw Error(no(341));
            k.lanes |= c, A = k.alternate, A !== null && (A.lanes |= c), lne(k, c, a), k = x.sibling;
          } else k = x.child;
          if (k !== null) k.return = x;
          else for (k = x; k !== null; ) {
            if (k === a) {
              k = null;
              break;
            }
            if (x = k.sibling, x !== null) {
              x.return = k.return, k = x;
              break;
            }
            k = k.return;
          }
          x = k;
        }
        Rf(o, a, g.children, c), a = a.child;
      }
      return a;
    case 9:
      return g = a.type, f = a.pendingProps.children, N4(a, c), g = Fh(g), f = f(g), a.flags |= 1, Rf(o, a, f, c), a.child;
    case 14:
      return f = a.type, g = Jg(f, a.pendingProps), g = Jg(f.type, g), Bie(o, a, f, g, c);
    case 15:
      return ude(o, a, a.type, a.pendingProps, c);
    case 17:
      return f = a.type, g = a.pendingProps, g = a.elementType === f ? g : Jg(f, g), M9(o, a), a.tag = 1, Sm(f) ? (o = !0, tV(a)) : o = !1, N4(a, c), ide(a, f, g), une(a, f, g, c), mne(null, a, f, !0, o, c);
    case 19:
      return hde(o, a, c);
    case 22:
      return dde(o, a, c);
  }
  throw Error(no(156, a.tag));
};
function Rde(o, a) {
  return sue(o, a);
}
function Lge(o, a, c, f) {
  this.tag = o, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = a, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = f, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
}
function Ph(o, a, c, f) {
  return new Lge(o, a, c, f);
}
function Yoe(o) {
  return o = o.prototype, !(!o || !o.isReactComponent);
}
function $ge(o) {
  if (typeof o == "function") return Yoe(o) ? 1 : 0;
  if (o != null) {
    if (o = o.$$typeof, o === hoe) return 11;
    if (o === goe) return 14;
  }
  return 2;
}
function B2(o, a) {
  var c = o.alternate;
  return c === null ? (c = Ph(o.tag, a, o.key, o.mode), c.elementType = o.elementType, c.type = o.type, c.stateNode = o.stateNode, c.alternate = o, o.alternate = c) : (c.pendingProps = a, c.type = o.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = o.flags & 14680064, c.childLanes = o.childLanes, c.lanes = o.lanes, c.child = o.child, c.memoizedProps = o.memoizedProps, c.memoizedState = o.memoizedState, c.updateQueue = o.updateQueue, a = o.dependencies, c.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }, c.sibling = o.sibling, c.index = o.index, c.ref = o.ref, c;
}
function B9(o, a, c, f, g, x) {
  var k = 2;
  if (f = o, typeof o == "function") Yoe(o) && (k = 1);
  else if (typeof o == "string") k = 5;
  else e: switch (o) {
    case f4:
      return Hk(c.children, g, x, a);
    case poe:
      k = 8, g |= 8;
      break;
    case Mte:
      return o = Ph(12, c, a, g | 2), o.elementType = Mte, o.lanes = x, o;
    case Ite:
      return o = Ph(13, c, a, g), o.elementType = Ite, o.lanes = x, o;
    case Fte:
      return o = Ph(19, c, a, g), o.elementType = Fte, o.lanes = x, o;
    case zce:
      return BV(c, g, x, a);
    default:
      if (typeof o == "object" && o !== null) switch (o.$$typeof) {
        case $ce:
          k = 10;
          break e;
        case Hce:
          k = 9;
          break e;
        case hoe:
          k = 11;
          break e;
        case goe:
          k = 14;
          break e;
        case C2:
          k = 16, f = null;
          break e;
      }
      throw Error(no(130, o == null ? o : typeof o, ""));
  }
  return a = Ph(k, c, a, g), a.elementType = o, a.type = f, a.lanes = x, a;
}
function Hk(o, a, c, f) {
  return o = Ph(7, o, f, a), o.lanes = c, o;
}
function BV(o, a, c, f) {
  return o = Ph(22, o, f, a), o.elementType = zce, o.lanes = c, o.stateNode = { isHidden: !1 }, o;
}
function ite(o, a, c) {
  return o = Ph(6, o, null, a), o.lanes = c, o;
}
function lte(o, a, c) {
  return a = Ph(4, o.children !== null ? o.children : [], o.key, a), a.lanes = c, a.stateNode = { containerInfo: o.containerInfo, pendingChildren: null, implementation: o.implementation }, a;
}
function Hge(o, a, c, f, g) {
  this.tag = a, this.containerInfo = o, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Vee(0), this.expirationTimes = Vee(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Vee(0), this.identifierPrefix = f, this.onRecoverableError = g, this.mutableSourceEagerHydrationData = null;
}
function Xoe(o, a, c, f, g, x, k, A, N) {
  return o = new Hge(o, a, c, A, N), a === 1 ? (a = 1, x === !0 && (a |= 8)) : a = 0, x = Ph(3, null, null, a), o.current = x, x.stateNode = o, x.memoizedState = { element: f, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Moe(x), o;
}
function zge(o, a, c) {
  var f = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return { $$typeof: d4, key: f == null ? null : "" + f, children: o, containerInfo: a, implementation: c };
}
function Nde(o) {
  if (!o) return z2;
  o = o._reactInternals;
  e: {
    if (e_(o) !== o || o.tag !== 1) throw Error(no(170));
    var a = o;
    do {
      switch (a.tag) {
        case 3:
          a = a.stateNode.context;
          break e;
        case 1:
          if (Sm(a.type)) {
            a = a.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      a = a.return;
    } while (a !== null);
    throw Error(no(171));
  }
  if (o.tag === 1) {
    var c = o.type;
    if (Sm(c)) return Nue(o, c, a);
  }
  return a;
}
function Pde(o, a, c, f, g, x, k, A, N) {
  return o = Xoe(c, f, !0, o, g, x, k, A, N), o.context = Nde(null), c = o.current, f = Nf(), g = F2(c), x = I0(f, g), x.callback = a ?? null, M2(c, x, g), o.current.lanes = g, RI(o, g, f), km(o, f), o;
}
function LV(o, a, c, f) {
  var g = a.current, x = Nf(), k = F2(g);
  return c = Nde(c), a.context === null ? a.context = c : a.pendingContext = c, a = I0(x, k), a.payload = { element: o }, f = f === void 0 ? null : f, f !== null && (a.callback = f), o = M2(g, a, k), o !== null && (rv(o, g, k, x), R9(o, g, k)), k;
}
function pV(o) {
  if (o = o.current, !o.child) return null;
  switch (o.child.tag) {
    case 5:
      return o.child.stateNode;
    default:
      return o.child.stateNode;
  }
}
function Kie(o, a) {
  if (o = o.memoizedState, o !== null && o.dehydrated !== null) {
    var c = o.retryLane;
    o.retryLane = c !== 0 && c < a ? c : a;
  }
}
function Qoe(o, a) {
  Kie(o, a), (o = o.alternate) && Kie(o, a);
}
function Vge() {
  return null;
}
var Mde = typeof reportError == "function" ? reportError : function(o) {
  console.error(o);
};
function Joe(o) {
  this._internalRoot = o;
}
$V.prototype.render = Joe.prototype.render = function(o) {
  var a = this._internalRoot;
  if (a === null) throw Error(no(409));
  LV(o, a, null, null);
};
$V.prototype.unmount = Joe.prototype.unmount = function() {
  var o = this._internalRoot;
  if (o !== null) {
    this._internalRoot = null;
    var a = o.containerInfo;
    qk(function() {
      LV(null, o, null, null);
    }), a[B0] = null;
  }
};
function $V(o) {
  this._internalRoot = o;
}
$V.prototype.unstable_scheduleHydration = function(o) {
  if (o) {
    var a = due();
    o = { blockedOn: null, target: o, priority: a };
    for (var c = 0; c < _2.length && a !== 0 && a < _2[c].priority; c++) ;
    _2.splice(c, 0, o), c === 0 && mue(o);
  }
};
function ese(o) {
  return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11);
}
function HV(o) {
  return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11 && (o.nodeType !== 8 || o.nodeValue !== " react-mount-point-unstable "));
}
function Yie() {
}
function Uge(o, a, c, f, g) {
  if (g) {
    if (typeof f == "function") {
      var x = f;
      f = function() {
        var H = pV(k);
        x.call(H);
      };
    }
    var k = Pde(a, f, o, 0, null, !1, !1, "", Yie);
    return o._reactRootContainer = k, o[B0] = k.current, iI(o.nodeType === 8 ? o.parentNode : o), qk(), k;
  }
  for (; g = o.lastChild; ) o.removeChild(g);
  if (typeof f == "function") {
    var A = f;
    f = function() {
      var H = pV(N);
      A.call(H);
    };
  }
  var N = Xoe(o, 0, !1, null, null, !1, !1, "", Yie);
  return o._reactRootContainer = N, o[B0] = N.current, iI(o.nodeType === 8 ? o.parentNode : o), qk(function() {
    LV(a, N, c, f);
  }), N;
}
function zV(o, a, c, f, g) {
  var x = c._reactRootContainer;
  if (x) {
    var k = x;
    if (typeof g == "function") {
      var A = g;
      g = function() {
        var N = pV(k);
        A.call(N);
      };
    }
    LV(a, k, o, g);
  } else k = Uge(c, a, o, g, f);
  return pV(k);
}
cue = function(o) {
  switch (o.tag) {
    case 3:
      var a = o.stateNode;
      if (a.current.memoizedState.isDehydrated) {
        var c = I5(a.pendingLanes);
        c !== 0 && (yoe(a, c | 1), km(a, yc()), !(Sa & 6) && (j4 = yc() + 500, q2()));
      }
      break;
    case 13:
      qk(function() {
        var f = L0(o, 1);
        if (f !== null) {
          var g = Nf();
          rv(f, o, 1, g);
        }
      }), Qoe(o, 1);
  }
};
xoe = function(o) {
  if (o.tag === 13) {
    var a = L0(o, 134217728);
    if (a !== null) {
      var c = Nf();
      rv(a, o, 134217728, c);
    }
    Qoe(o, 134217728);
  }
};
uue = function(o) {
  if (o.tag === 13) {
    var a = F2(o), c = L0(o, a);
    if (c !== null) {
      var f = Nf();
      rv(c, o, a, f);
    }
    Qoe(o, a);
  }
};
due = function() {
  return ri;
};
fue = function(o, a) {
  var c = ri;
  try {
    return ri = o, a();
  } finally {
    ri = c;
  }
};
Zte = function(o, a, c) {
  switch (a) {
    case "input":
      if ($te(o, c), a = c.name, c.type === "radio" && a != null) {
        for (c = o; c.parentNode; ) c = c.parentNode;
        for (c = c.querySelectorAll("input[name=" + JSON.stringify("" + a) + '][type="radio"]'), a = 0; a < c.length; a++) {
          var f = c[a];
          if (f !== o && f.form === o.form) {
            var g = RV(f);
            if (!g) throw Error(no(90));
            Uce(f), $te(f, g);
          }
        }
      }
      break;
    case "textarea":
      Wce(o, c);
      break;
    case "select":
      a = c.value, a != null && A4(o, !!c.multiple, a, !1);
  }
};
Qce = Goe;
Jce = qk;
var jge = { usingClientEntryPoint: !1, Events: [PI, g4, RV, Yce, Xce, Goe] }, D5 = { findFiberByHostInstance: Rk, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, Wge = { bundleType: D5.bundleType, version: D5.version, rendererPackageName: D5.rendererPackageName, rendererConfig: D5.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: W0.ReactCurrentDispatcher, findHostInstanceByFiber: function(o) {
  return o = nue(o), o === null ? null : o.stateNode;
}, findFiberByHostInstance: D5.findFiberByHostInstance || Vge, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var i9 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!i9.isDisabled && i9.supportsFiber) try {
    TV = i9.inject(Wge), Ib = i9;
  } catch {
  }
}
gp.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = jge;
gp.createPortal = function(o, a) {
  var c = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!ese(a)) throw Error(no(200));
  return zge(o, a, null, c);
};
gp.createRoot = function(o, a) {
  if (!ese(o)) throw Error(no(299));
  var c = !1, f = "", g = Mde;
  return a != null && (a.unstable_strictMode === !0 && (c = !0), a.identifierPrefix !== void 0 && (f = a.identifierPrefix), a.onRecoverableError !== void 0 && (g = a.onRecoverableError)), a = Xoe(o, 1, !1, null, null, c, !1, f, g), o[B0] = a.current, iI(o.nodeType === 8 ? o.parentNode : o), new Joe(a);
};
gp.findDOMNode = function(o) {
  if (o == null) return null;
  if (o.nodeType === 1) return o;
  var a = o._reactInternals;
  if (a === void 0)
    throw typeof o.render == "function" ? Error(no(188)) : (o = Object.keys(o).join(","), Error(no(268, o)));
  return o = nue(a), o = o === null ? null : o.stateNode, o;
};
gp.flushSync = function(o) {
  return qk(o);
};
gp.hydrate = function(o, a, c) {
  if (!HV(a)) throw Error(no(200));
  return zV(null, o, a, !0, c);
};
gp.hydrateRoot = function(o, a, c) {
  if (!ese(o)) throw Error(no(405));
  var f = c != null && c.hydratedSources || null, g = !1, x = "", k = Mde;
  if (c != null && (c.unstable_strictMode === !0 && (g = !0), c.identifierPrefix !== void 0 && (x = c.identifierPrefix), c.onRecoverableError !== void 0 && (k = c.onRecoverableError)), a = Pde(a, null, o, 1, c ?? null, g, !1, x, k), o[B0] = a.current, iI(o), f) for (o = 0; o < f.length; o++) c = f[o], g = c._getVersion, g = g(c._source), a.mutableSourceEagerHydrationData == null ? a.mutableSourceEagerHydrationData = [c, g] : a.mutableSourceEagerHydrationData.push(
    c,
    g
  );
  return new $V(a);
};
gp.render = function(o, a, c) {
  if (!HV(a)) throw Error(no(200));
  return zV(null, o, a, !1, c);
};
gp.unmountComponentAtNode = function(o) {
  if (!HV(o)) throw Error(no(40));
  return o._reactRootContainer ? (qk(function() {
    zV(null, null, o, !1, function() {
      o._reactRootContainer = null, o[B0] = null;
    });
  }), !0) : !1;
};
gp.unstable_batchedUpdates = Goe;
gp.unstable_renderSubtreeIntoContainer = function(o, a, c, f) {
  if (!HV(c)) throw Error(no(200));
  if (o == null || o._reactInternals === void 0) throw Error(no(38));
  return zV(o, a, c, !1, f);
};
gp.version = "18.3.1-next-f1338f8080-20240426";
function Ide() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Ide);
    } catch (o) {
      console.error(o);
    }
}
Ide(), Ice.exports = gp;
var tse = Ice.exports;
const Mk = /* @__PURE__ */ eO(tse);
var Fde, Xie = tse;
Fde = Xie.createRoot, Xie.hydrateRoot;
var Bde = { exports: {} }, Zge = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED", Gge = Zge, qge = Gge;
function Lde() {
}
function $de() {
}
$de.resetWarningCache = Lde;
var Kge = function() {
  function o(f, g, x, k, A, N) {
    if (N !== qge) {
      var H = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      throw H.name = "Invariant Violation", H;
    }
  }
  o.isRequired = o;
  function a() {
    return o;
  }
  var c = {
    array: o,
    bigint: o,
    bool: o,
    func: o,
    number: o,
    object: o,
    string: o,
    symbol: o,
    any: o,
    arrayOf: a,
    element: o,
    elementType: o,
    instanceOf: a,
    node: o,
    objectOf: a,
    oneOf: a,
    oneOfType: a,
    shape: a,
    exact: a,
    checkPropTypes: $de,
    resetWarningCache: Lde
  };
  return c.PropTypes = c, c;
};
Bde.exports = Kge();
var Pn = Bde.exports;
const ce = /* @__PURE__ */ eO(Pn);
var Hde = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(o) {
  (function() {
    var a = {}.hasOwnProperty;
    function c() {
      for (var x = "", k = 0; k < arguments.length; k++) {
        var A = arguments[k];
        A && (x = g(x, f(A)));
      }
      return x;
    }
    function f(x) {
      if (typeof x == "string" || typeof x == "number")
        return x;
      if (typeof x != "object")
        return "";
      if (Array.isArray(x))
        return c.apply(null, x);
      if (x.toString !== Object.prototype.toString && !x.toString.toString().includes("[native code]"))
        return x.toString();
      var k = "";
      for (var A in x)
        a.call(x, A) && x[A] && (k = g(k, A));
      return k;
    }
    function g(x, k) {
      return k ? x ? x + " " + k : x + k : x;
    }
    o.exports ? (c.default = c, o.exports = c) : window.classNames = c;
  })();
})(Hde);
var Yge = Hde.exports;
const er = /* @__PURE__ */ eO(Yge);
function Zs() {
  return Zs = Object.assign ? Object.assign.bind() : function(o) {
    for (var a = 1; a < arguments.length; a++) {
      var c = arguments[a];
      for (var f in c) ({}).hasOwnProperty.call(c, f) && (o[f] = c[f]);
    }
    return o;
  }, Zs.apply(null, arguments);
}
function Ei(o, a) {
  if (o == null) return {};
  var c = {};
  for (var f in o) if ({}.hasOwnProperty.call(o, f)) {
    if (a.indexOf(f) >= 0) continue;
    c[f] = o[f];
  }
  return c;
}
var nse = /* @__PURE__ */ Ve.createContext({});
nse.Consumer;
nse.Provider;
function Fc(o, a) {
  var c = tt.useContext(nse);
  return o || c[a] || a;
}
function Xge() {
  for (var o = arguments.length, a = new Array(o), c = 0; c < o; c++)
    a[c] = arguments[c];
  return a.filter(function(f) {
    return f != null;
  }).reduce(function(f, g) {
    if (typeof g != "function")
      throw new Error("Invalid Argument Type, must only provide functions, undefined, or null.");
    return f === null ? g : function() {
      for (var k = arguments.length, A = new Array(k), N = 0; N < k; N++)
        A[N] = arguments[N];
      f.apply(this, A), g.apply(this, A);
    };
  }, null);
}
var Qge = ["as", "disabled", "onKeyDown"];
function Qie(o) {
  return !o || o.trim() === "#";
}
var zde = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  var c = o.as, f = c === void 0 ? "a" : c, g = o.disabled, x = o.onKeyDown, k = Ei(o, Qge), A = function(Z) {
    var K = k.href, J = k.onClick;
    if ((g || Qie(K)) && Z.preventDefault(), g) {
      Z.stopPropagation();
      return;
    }
    J && J(Z);
  }, N = function(Z) {
    Z.key === " " && (Z.preventDefault(), A(Z));
  };
  return Qie(k.href) && (k.role = k.role || "button", k.href = k.href || "#"), g && (k.tabIndex = -1, k["aria-disabled"] = !0), /* @__PURE__ */ Ve.createElement(f, Zs({
    ref: a
  }, k, {
    onClick: A,
    onKeyDown: Xge(N, x)
  }));
});
zde.displayName = "SafeAnchor";
var Jge = ["bsPrefix", "variant", "size", "active", "className", "block", "type", "as"], eve = {
  variant: "primary",
  active: !1,
  disabled: !1
}, ose = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  var c = o.bsPrefix, f = o.variant, g = o.size, x = o.active, k = o.className, A = o.block, N = o.type, H = o.as, Z = Ei(o, Jge), K = Fc(c, "btn"), J = er(k, K, x && "active", f && K + "-" + f, A && K + "-block", g && K + "-" + g);
  if (Z.href)
    return /* @__PURE__ */ Ve.createElement(zde, Zs({}, Z, {
      as: H,
      ref: a,
      className: er(J, Z.disabled && "disabled")
    }));
  a && (Z.ref = a), N ? Z.type = N : H || (Z.type = "button");
  var pe = H || "button";
  return /* @__PURE__ */ Ve.createElement(pe, Zs({}, Z, {
    className: J
  }));
});
ose.displayName = "Button";
ose.defaultProps = eve;
var tve = ["bsPrefix", "size", "toggle", "vertical", "className", "as"], nve = {
  vertical: !1,
  toggle: !1,
  role: "group"
}, sse = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  var c = o.bsPrefix, f = o.size, g = o.toggle, x = o.vertical, k = o.className, A = o.as, N = A === void 0 ? "div" : A, H = Ei(o, tve), Z = Fc(c, "btn-group"), K = Z;
  return x && (K = Z + "-vertical"), /* @__PURE__ */ Ve.createElement(N, Zs({}, H, {
    ref: a,
    className: er(k, K, f && Z + "-" + f, g && Z + "-toggle")
  }));
});
sse.displayName = "ButtonGroup";
sse.defaultProps = nve;
var ove = ["bsPrefix", "className"], sve = {
  role: "toolbar"
}, rse = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  var c = o.bsPrefix, f = o.className, g = Ei(o, ove), x = Fc(c, "btn-toolbar");
  return /* @__PURE__ */ Ve.createElement("div", Zs({}, g, {
    ref: a,
    className: er(f, x)
  }));
});
rse.displayName = "ButtonToolbar";
rse.defaultProps = sve;
let Ik = /* @__PURE__ */ function(o) {
  return o.MOVED = "MOVED", o.REMOVED = "REMOVED", o.FORMAT = "FORMAT", o.MOVED_AND_FORMAT = "MOVED_AND_FORMAT", o;
}({});
function Vde(o, a, c) {
  class f extends Ve.Component {
    constructor(x) {
      super(x), this.transformProps = this.transformProps.bind(this);
    }
    warn(x) {
    }
    transformProps(x, k) {
      if (c[k] === void 0)
        return x[k] = this.props[k], x;
      const {
        deprType: A,
        newName: N,
        expect: H,
        transform: Z,
        message: K
      } = c[k];
      switch (A) {
        case Ik.MOVED:
          this.warn(`${a}: The prop '${k}' has been moved to '${N}'.`), x[N] = this.props[k];
          break;
        case Ik.REMOVED:
          this.warn(`${a}: The prop '${k}' has been removed. '${K}'`);
          break;
        case Ik.FORMAT:
          H(this.props[k]) ? x[k] = this.props[k] : (this.warn(`${a}: The prop '${k}' expects a new format. ${K}`), x[k] = Z(this.props[k], this.props));
          break;
        case Ik.MOVED_AND_FORMAT: {
          const J = this.props[k];
          let pe = `${a}: The prop '${k}' has been moved to '${N}'`;
          H && !H(J) && (pe += " and expects a new format"), pe += K ? `. ${K}` : "", this.warn(pe), x[N] = Z ? Z(J, this.props) : J;
          break;
        }
        default:
          x[k] = this.props[k];
          break;
      }
      return x;
    }
    render() {
      const {
        children: x,
        ...k
      } = Object.keys(this.props).reduce(this.transformProps, {});
      return /* @__PURE__ */ Ve.createElement(o, {
        ...k
      }, this.props.children || x);
    }
  }
  return (
    // eslint-disable-next-line react/static-property-placement
    Vae(f, "displayName", `withDeprecatedProps(${a})`), f
  );
}
class ase extends Ve.Component {
  constructor(a) {
    super(a);
    const {
      onBlur: c,
      onKeyDown: f
    } = a;
    this.onBlur = c.bind(this), this.onKeyDown = f.bind(this), this.onClick = this.onClick.bind(this), this.setRefs = this.setRefs.bind(this);
  }
  /*
    The button component is given focus explicitly in its onClick to account
    for the fact that an HTML <button> element in Firefox and Safari does not get
    focus on onClick.
     See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button.
  */
  onClick(a) {
    this.buttonRef.focus(), this.props.onClick(a);
  }
  /*
    The button component needs a ref to itself to be able to force
    focus in its onClick function (buttonRef). It also needs to accept
    a callback function from parent components to give those parents
    a reference to their child button (e.g. for the modal component).
    Therefore, both have been wrapped in a function bound on the class,
    since one cannot set two ref attributes on a component.
  */
  setRefs(a) {
    this.buttonRef = a, this.props.inputRef(a);
  }
  render() {
    const {
      buttonType: a,
      className: c,
      children: f,
      isClose: g,
      type: x,
      /* inputRef is not used directly in the render, but it needs to be assigned
        here to prevent it from being passed to the HTML button component as part
        of other.
      */
      inputRef: k,
      ...A
    } = this.props;
    return /* @__PURE__ */ Ve.createElement("button", {
      ...A,
      className: er(["btn", c], {
        [`btn-${a}`]: a !== void 0
      }, {
        close: g
      }),
      onBlur: this.onBlur,
      onClick: this.onClick,
      onKeyDown: this.onKeyDown,
      type: x,
      ref: this.setRefs
    }, f);
  }
}
const rve = {
  /** Used to determine the type of button to be rendered.  See [Bootstrap's buttons documentation](https://getbootstrap.com/docs/4.0/components/buttons/) for a list of applicable button types. For example, `buttonType="light"`. The default is `undefined`. */
  buttonType: ce.string,
  /** Specifies Bootstrap class names to apply to the button. See [Bootstrap's buttons documentation](https://getbootstrap.com/docs/4.0/components/buttons/) for a list of applicable class names. The default is an empty array. */
  className: ce.string,
  /** Specifies the text that is displayed within the button. */
  children: ce.node.isRequired,
  // eslint-disable-next-line max-len
  /** A function that defines a reference for the button. An example `inputRef` from the calling component could look something like: `inputRef={(input) => { this.button = input; }}`. The default is an empty function. */
  inputRef: ce.oneOfType([ce.func, ce.shape({
    current: ce.instanceOf(ce.element)
  })]),
  /** Used to determine if the button is a "Close" style button to leverage bootstrap styling. Example use case is with the Status Alert [dismiss button](https://getbootstrap.com/docs/4.0/components/alerts/#dismissing). The default is false. */
  isClose: ce.bool,
  // eslint-disable-next-line max-len
  /** A function that would specify what the button should do when the `onBlur` event is triggered. For example, the button could change in color or `buttonType` when focus is changed. The default is an empty function. */
  onBlur: ce.func,
  // eslint-disable-next-line max-len
  /** A function that would specify what the button should do when the `onClick` event is triggered. For example, the button could launch a `Modal`. The default is an empty function. */
  onClick: ce.func,
  // eslint-disable-next-line max-len
  /** A function that would specify what the button should do when the `onKeyDown` event is triggered.  For example, this could handle using the `Escape` key to trigger the button's action. The default is an empty function. */
  onKeyDown: ce.func,
  /** Used to set the `type` attribute on the `button` tag.  The default type is `button`. */
  type: ce.string,
  /** Specifies variant to use. */
  variant: ce.oneOf(["primary", "secondary", "success", "danger", "warning", "info", "dark", "light", "link", "outline-primary", "outline-secondary", "outline-success", "outline-danger", "outline-warning", "outline-info", "outline-dark", "outline-light"])
};
ase.propTypes = rve;
ase.defaultProps = {
  buttonType: void 0,
  className: void 0,
  inputRef: () => {
  },
  isClose: !1,
  onBlur: () => {
  },
  onKeyDown: () => {
  },
  onClick: () => {
  },
  type: "button",
  variant: "outline-primary"
};
const ave = Vde(ase, "Button", {
  label: {
    deprType: Ik.MOVED,
    newName: "children"
  },
  className: {
    deprType: Ik.FORMAT,
    expect: (o) => typeof o == "string",
    transform: (o) => Array.isArray(o) ? o.join(" ") : o,
    message: "It should be a string."
  }
});
let Jie = 0;
const ise = function() {
  let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
  return Jie += 1, `${o}${Jie}`;
};
function lse(o) {
  let {
    src: a,
    id: c,
    className: f,
    hidden: g,
    screenReaderText: x,
    svgAttrs: k,
    size: A,
    ...N
  } = o;
  if (a) {
    const H = k["aria-label"] || k["aria-labelledby"], Z = {
      ...k
    };
    return H || (Z["aria-label"] = void 0, Z["aria-hidden"] = !0), /* @__PURE__ */ Ve.createElement("span", {
      className: er("pgn__icon", {
        [`pgn__icon__${A}`]: !!A
      }, f),
      id: c,
      ...N
    }, /* @__PURE__ */ Ve.createElement(a, {
      role: "img",
      focusable: !1,
      ...Z
    }), x && /* @__PURE__ */ Ve.createElement("span", {
      className: "sr-only"
    }, x));
  }
  return /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, /* @__PURE__ */ Ve.createElement("span", {
    id: c || ise("Icon"),
    className: f,
    "aria-hidden": g
  }), x && /* @__PURE__ */ Ve.createElement("span", {
    className: "sr-only"
  }, x));
}
lse.propTypes = {
  /**
   * An icon component to render.
   * Example import of a Paragon icon component: `import { Check } from '@openedx/paragon/icons';`
   */
  src: ce.elementType,
  /** HTML element attributes to pass through to the underlying svg element */
  svgAttrs: ce.shape({
    "aria-label": ce.string,
    "aria-labelledby": ce.string
  }),
  /**
   * the `id` property of the Icon element, by default this value is generated
   * with the `newId` function with the `prefix` of `Icon`.
   */
  id: ce.string,
  /** The size of the icon. */
  size: ce.oneOf(["xs", "sm", "md", "lg"]),
  /** A class name that will define what the Icon looks like. */
  className: ce.string,
  /**
   * a boolean that determines the value of `aria-hidden` attribute on the Icon span,
   * this value is `true` by default.
   */
  hidden: ce.bool,
  /**
   * a string or an element that will be used on a secondary span leveraging the `sr-only` style
   * for screenreader only text, this value is `undefined` by default. This value is recommended for use unless
   * the Icon is being used in a way that is purely decorative or provides no additional context for screen
   * reader users. This field should be thought of the same way an `alt` attribute would be used for `image` tags.
   */
  screenReaderText: ce.oneOfType([ce.string, ce.element])
};
lse.defaultProps = {
  src: null,
  svgAttrs: {},
  id: void 0,
  hidden: !0,
  screenReaderText: void 0,
  size: void 0,
  className: void 0
};
const W4 = Vde(lse, "Icon", {
  className: {
    deprType: Ik.FORMAT,
    expect: (o) => typeof o == "string",
    transform: (o) => Array.isArray(o) ? o.join(" ") : o,
    message: "It should be a string."
  }
}), L2 = /* @__PURE__ */ Ve.forwardRef((o, a) => {
  let {
    children: c,
    iconAfter: f,
    iconBefore: g,
    size: x,
    ...k
  } = o;
  return /* @__PURE__ */ Ve.createElement(ose, {
    size: x,
    ...k,
    className: er(k.className),
    ref: a
  }, g && /* @__PURE__ */ Ve.createElement(W4, {
    className: "btn-icon-before",
    size: x,
    src: g
  }), c, f && /* @__PURE__ */ Ve.createElement(W4, {
    className: "btn-icon-after",
    size: x,
    src: f
  }));
});
L2.propTypes = {
  /** Specifies class name to apply to the button */
  className: ce.string,
  /** Disables the Button, preventing mouse events, even if the underlying component is an `<a>` element */
  disabled: ce.bool,
  /** Specifies the text that is displayed within the button. */
  children: ce.node.isRequired,
  /** A function that would specify what the button should do when the `onClick` event is triggered.
   * For example, the button could launch a `Modal`. The default is an empty function. */
  onClick: ce.func,
  /** A function that would specify what the button should do when the `onKeyDown` event is triggered.
   * For example, this could handle using the `Escape` key to trigger the button's action.
   * The default is an empty function. */
  onKeyDown: ce.func,
  /** Used to set the `type` attribute on the `button` tag.  The default type is `button`. */
  type: ce.string,
  /** Specifies variant to use.
   * Can be on of the base variants: `primary`, `secondary`, `success`, `danger`, `warning`, `info`, `dark`,
   * `light`, `link`
   *
   * as well as one of the customized variants (= base variant prefixed with `inverse-`, `outline-`
   * or `inverse-outline-`)
   * */
  variant: ce.string,
  /** An icon component to render.
  * Example import of a Paragon icon component: `import { Check } from '@openedx/paragon/icons';` */
  iconBefore: ce.elementType,
  /** An icon component to render.
  * Example import of a Paragon icon component: `import { Check } from '@openedx/paragon/icons';` */
  iconAfter: ce.elementType
  // The 'as' type casting above is required for TypeScript checking, because the 'PropTypes.elementType' type normally
  // allows strings as a value (for use cases like 'div') but we don't support that for <Icon />/iconBefore/iconAfter.
  // The React TypeScript type definitions are more specific (React.ComponentType vs React.ElementType).
};
L2.defaultProps = {
  ...L2.defaultProps,
  children: void 0,
  className: void 0,
  iconBefore: void 0,
  iconAfter: void 0,
  disabled: !1
};
L2.Deprecated = ave;
const Ude = /* @__PURE__ */ Ve.forwardRef((o, a) => {
  let {
    size: c,
    ...f
  } = o;
  return /* @__PURE__ */ Ve.createElement(sse, {
    size: c,
    ...f,
    ref: a
  });
});
Ude.propTypes = {
  /** Specifies element type for this component. */
  as: ce.elementType,
  /** An ARIA role describing the button group. */
  role: ce.string,
  /** Specifies the size for all Buttons in the group. */
  size: ce.oneOf(["sm", "md", "lg", "inline"]),
  /** Display as a button toggle group. */
  toggle: ce.bool,
  /** Specifies if the set of Buttons should appear vertically stacked. */
  vertical: ce.bool,
  /** Overrides underlying component base CSS class name */
  bsPrefix: ce.string
};
Ude.defaultProps = {
  as: "div",
  role: "group",
  toggle: !1,
  vertical: !1,
  bsPrefix: "btn-group",
  size: "md"
};
const jde = /* @__PURE__ */ Ve.forwardRef((o, a) => /* @__PURE__ */ Ve.createElement(rse, {
  ...o,
  ref: a
}));
jde.propTypes = {
  /** An ARIA role describing the button group. */
  role: ce.string,
  /** Overrides underlying component base CSS class name */
  bsPrefix: ce.string
};
jde.defaultProps = {
  role: "toolbar",
  bsPrefix: "btn-toolbar"
};
const ive = (o, a, c) => (f, g, x, ...k) => a(f) && f[g] === void 0 ? new Error(
  `${x}: ${g} is required when ${c}`
) : o(f, g, x, ...k), lve = (o, a) => a.every((c) => o[c] !== void 0), cte = (o, a) => ive(
  o,
  (c) => Array.isArray(a) ? lve(c, a) : c[a] === !0,
  `${a} ${Array.isArray(a) ? "are defined" : "is truthy"}`
);
function ele(o, a) {
  var c = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var f = Object.getOwnPropertySymbols(o);
    a && (f = f.filter(function(g) {
      return Object.getOwnPropertyDescriptor(o, g).enumerable;
    })), c.push.apply(c, f);
  }
  return c;
}
function Wo(o) {
  for (var a = 1; a < arguments.length; a++) {
    var c = arguments[a] != null ? arguments[a] : {};
    a % 2 ? ele(Object(c), !0).forEach(function(f) {
      cu(o, f, c[f]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(c)) : ele(Object(c)).forEach(function(f) {
      Object.defineProperty(o, f, Object.getOwnPropertyDescriptor(c, f));
    });
  }
  return o;
}
function hV(o) {
  "@babel/helpers - typeof";
  return hV = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(a) {
    return typeof a;
  } : function(a) {
    return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
  }, hV(o);
}
function cve(o, a) {
  if (!(o instanceof a))
    throw new TypeError("Cannot call a class as a function");
}
function uve(o, a) {
  for (var c = 0; c < a.length; c++) {
    var f = a[c];
    f.enumerable = f.enumerable || !1, f.configurable = !0, "value" in f && (f.writable = !0), Object.defineProperty(o, f.key, f);
  }
}
function dve(o, a, c) {
  return a && uve(o.prototype, a), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function cu(o, a, c) {
  return a in o ? Object.defineProperty(o, a, {
    value: c,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : o[a] = c, o;
}
function cse(o, a) {
  return mve(o) || hve(o, a) || Wde(o, a) || vve();
}
function II(o) {
  return fve(o) || pve(o) || Wde(o) || gve();
}
function fve(o) {
  if (Array.isArray(o)) return _ne(o);
}
function mve(o) {
  if (Array.isArray(o)) return o;
}
function pve(o) {
  if (typeof Symbol < "u" && o[Symbol.iterator] != null || o["@@iterator"] != null) return Array.from(o);
}
function hve(o, a) {
  var c = o == null ? null : typeof Symbol < "u" && o[Symbol.iterator] || o["@@iterator"];
  if (c != null) {
    var f = [], g = !0, x = !1, k, A;
    try {
      for (c = c.call(o); !(g = (k = c.next()).done) && (f.push(k.value), !(a && f.length === a)); g = !0)
        ;
    } catch (N) {
      x = !0, A = N;
    } finally {
      try {
        !g && c.return != null && c.return();
      } finally {
        if (x) throw A;
      }
    }
    return f;
  }
}
function Wde(o, a) {
  if (o) {
    if (typeof o == "string") return _ne(o, a);
    var c = Object.prototype.toString.call(o).slice(8, -1);
    if (c === "Object" && o.constructor && (c = o.constructor.name), c === "Map" || c === "Set") return Array.from(o);
    if (c === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c)) return _ne(o, a);
  }
}
function _ne(o, a) {
  (a == null || a > o.length) && (a = o.length);
  for (var c = 0, f = new Array(a); c < a; c++) f[c] = o[c];
  return f;
}
function gve() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function vve() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var tle = function() {
}, use = {}, Zde = {}, Gde = null, qde = {
  mark: tle,
  measure: tle
};
try {
  typeof window < "u" && (use = window), typeof document < "u" && (Zde = document), typeof MutationObserver < "u" && (Gde = MutationObserver), typeof performance < "u" && (qde = performance);
} catch {
}
var bve = use.navigator || {}, nle = bve.userAgent, ole = nle === void 0 ? "" : nle, V2 = use, ll = Zde, sle = Gde, l9 = qde;
V2.document;
var Z0 = !!ll.documentElement && !!ll.head && typeof ll.addEventListener == "function" && typeof ll.createElement == "function", Kde = ~ole.indexOf("MSIE") || ~ole.indexOf("Trident/"), c9, u9, d9, f9, m9, H0 = "___FONT_AWESOME___", Ene = 16, Yde = "fa", Xde = "svg-inline--fa", Kk = "data-fa-i2svg", Tne = "data-fa-pseudo-element", yve = "data-fa-pseudo-element-pending", dse = "data-prefix", fse = "data-icon", rle = "fontawesome-i2svg", xve = "async", wve = ["HTML", "HEAD", "STYLE", "SCRIPT"], Qde = function() {
  try {
    return !0;
  } catch {
    return !1;
  }
}(), al = "classic", Yl = "sharp", mse = [al, Yl];
function FI(o) {
  return new Proxy(o, {
    get: function(c, f) {
      return f in c ? c[f] : c[al];
    }
  });
}
var gI = FI((c9 = {}, cu(c9, al, {
  fa: "solid",
  fas: "solid",
  "fa-solid": "solid",
  far: "regular",
  "fa-regular": "regular",
  fal: "light",
  "fa-light": "light",
  fat: "thin",
  "fa-thin": "thin",
  fad: "duotone",
  "fa-duotone": "duotone",
  fab: "brands",
  "fa-brands": "brands",
  fak: "kit",
  fakd: "kit",
  "fa-kit": "kit",
  "fa-kit-duotone": "kit"
}), cu(c9, Yl, {
  fa: "solid",
  fass: "solid",
  "fa-solid": "solid",
  fasr: "regular",
  "fa-regular": "regular",
  fasl: "light",
  "fa-light": "light",
  fast: "thin",
  "fa-thin": "thin"
}), c9)), vI = FI((u9 = {}, cu(u9, al, {
  solid: "fas",
  regular: "far",
  light: "fal",
  thin: "fat",
  duotone: "fad",
  brands: "fab",
  kit: "fak"
}), cu(u9, Yl, {
  solid: "fass",
  regular: "fasr",
  light: "fasl",
  thin: "fast"
}), u9)), bI = FI((d9 = {}, cu(d9, al, {
  fab: "fa-brands",
  fad: "fa-duotone",
  fak: "fa-kit",
  fal: "fa-light",
  far: "fa-regular",
  fas: "fa-solid",
  fat: "fa-thin"
}), cu(d9, Yl, {
  fass: "fa-solid",
  fasr: "fa-regular",
  fasl: "fa-light",
  fast: "fa-thin"
}), d9)), Cve = FI((f9 = {}, cu(f9, al, {
  "fa-brands": "fab",
  "fa-duotone": "fad",
  "fa-kit": "fak",
  "fa-light": "fal",
  "fa-regular": "far",
  "fa-solid": "fas",
  "fa-thin": "fat"
}), cu(f9, Yl, {
  "fa-solid": "fass",
  "fa-regular": "fasr",
  "fa-light": "fasl",
  "fa-thin": "fast"
}), f9)), Sve = /fa(s|r|l|t|d|b|k|ss|sr|sl|st)?[\-\ ]/, Jde = "fa-layers-text", kve = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp|Kit)?.*/i, _ve = FI((m9 = {}, cu(m9, al, {
  900: "fas",
  400: "far",
  normal: "far",
  300: "fal",
  100: "fat"
}), cu(m9, Yl, {
  900: "fass",
  400: "fasr",
  300: "fasl",
  100: "fast"
}), m9)), efe = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], Eve = efe.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), Tve = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], Fk = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, yI = /* @__PURE__ */ new Set();
Object.keys(vI[al]).map(yI.add.bind(yI));
Object.keys(vI[Yl]).map(yI.add.bind(yI));
var Ave = [].concat(mse, II(yI), ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", Fk.GROUP, Fk.SWAP_OPACITY, Fk.PRIMARY, Fk.SECONDARY]).concat(efe.map(function(o) {
  return "".concat(o, "x");
})).concat(Eve.map(function(o) {
  return "w-".concat(o);
})), q5 = V2.FontAwesomeConfig || {};
function Ove(o) {
  var a = ll.querySelector("script[" + o + "]");
  if (a)
    return a.getAttribute(o);
}
function Dve(o) {
  return o === "" ? !0 : o === "false" ? !1 : o === "true" ? !0 : o;
}
if (ll && typeof ll.querySelector == "function") {
  var Rve = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
  Rve.forEach(function(o) {
    var a = cse(o, 2), c = a[0], f = a[1], g = Dve(Ove(c));
    g != null && (q5[f] = g);
  });
}
var tfe = {
  styleDefault: "solid",
  familyDefault: "classic",
  cssPrefix: Yde,
  replacementClass: Xde,
  autoReplaceSvg: !0,
  autoAddCss: !0,
  autoA11y: !0,
  searchPseudoElements: !1,
  observeMutations: !0,
  mutateApproach: "async",
  keepOriginalSource: !0,
  measurePerformance: !1,
  showMissingIcons: !0
};
q5.familyPrefix && (q5.cssPrefix = q5.familyPrefix);
var Z4 = Wo(Wo({}, tfe), q5);
Z4.autoReplaceSvg || (Z4.observeMutations = !1);
var ps = {};
Object.keys(tfe).forEach(function(o) {
  Object.defineProperty(ps, o, {
    enumerable: !0,
    set: function(c) {
      Z4[o] = c, K5.forEach(function(f) {
        return f(ps);
      });
    },
    get: function() {
      return Z4[o];
    }
  });
});
Object.defineProperty(ps, "familyPrefix", {
  enumerable: !0,
  set: function(a) {
    Z4.cssPrefix = a, K5.forEach(function(c) {
      return c(ps);
    });
  },
  get: function() {
    return Z4.cssPrefix;
  }
});
V2.FontAwesomeConfig = ps;
var K5 = [];
function Nve(o) {
  return K5.push(o), function() {
    K5.splice(K5.indexOf(o), 1);
  };
}
var w2 = Ene, Pb = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: !1,
  flipY: !1
};
function Pve(o) {
  if (!(!o || !Z0)) {
    var a = ll.createElement("style");
    a.setAttribute("type", "text/css"), a.innerHTML = o;
    for (var c = ll.head.childNodes, f = null, g = c.length - 1; g > -1; g--) {
      var x = c[g], k = (x.tagName || "").toUpperCase();
      ["STYLE", "LINK"].indexOf(k) > -1 && (f = x);
    }
    return ll.head.insertBefore(a, f), o;
  }
}
var Mve = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function xI() {
  for (var o = 12, a = ""; o-- > 0; )
    a += Mve[Math.random() * 62 | 0];
  return a;
}
function sO(o) {
  for (var a = [], c = (o || []).length >>> 0; c--; )
    a[c] = o[c];
  return a;
}
function pse(o) {
  return o.classList ? sO(o.classList) : (o.getAttribute("class") || "").split(" ").filter(function(a) {
    return a;
  });
}
function nfe(o) {
  return "".concat(o).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function Ive(o) {
  return Object.keys(o || {}).reduce(function(a, c) {
    return a + "".concat(c, '="').concat(nfe(o[c]), '" ');
  }, "").trim();
}
function VV(o) {
  return Object.keys(o || {}).reduce(function(a, c) {
    return a + "".concat(c, ": ").concat(o[c].trim(), ";");
  }, "");
}
function hse(o) {
  return o.size !== Pb.size || o.x !== Pb.x || o.y !== Pb.y || o.rotate !== Pb.rotate || o.flipX || o.flipY;
}
function Fve(o) {
  var a = o.transform, c = o.containerWidth, f = o.iconWidth, g = {
    transform: "translate(".concat(c / 2, " 256)")
  }, x = "translate(".concat(a.x * 32, ", ").concat(a.y * 32, ") "), k = "scale(".concat(a.size / 16 * (a.flipX ? -1 : 1), ", ").concat(a.size / 16 * (a.flipY ? -1 : 1), ") "), A = "rotate(".concat(a.rotate, " 0 0)"), N = {
    transform: "".concat(x, " ").concat(k, " ").concat(A)
  }, H = {
    transform: "translate(".concat(f / 2 * -1, " -256)")
  };
  return {
    outer: g,
    inner: N,
    path: H
  };
}
function Bve(o) {
  var a = o.transform, c = o.width, f = c === void 0 ? Ene : c, g = o.height, x = g === void 0 ? Ene : g, k = o.startCentered, A = k === void 0 ? !1 : k, N = "";
  return A && Kde ? N += "translate(".concat(a.x / w2 - f / 2, "em, ").concat(a.y / w2 - x / 2, "em) ") : A ? N += "translate(calc(-50% + ".concat(a.x / w2, "em), calc(-50% + ").concat(a.y / w2, "em)) ") : N += "translate(".concat(a.x / w2, "em, ").concat(a.y / w2, "em) "), N += "scale(".concat(a.size / w2 * (a.flipX ? -1 : 1), ", ").concat(a.size / w2 * (a.flipY ? -1 : 1), ") "), N += "rotate(".concat(a.rotate, "deg) "), N;
}
var Lve = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Solid";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Regular";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Light";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Thin";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  -webkit-transform: scale(var(--fa-counter-scale, 0.25));
          transform: scale(var(--fa-counter-scale, 0.25));
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: bottom right;
          transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: bottom left;
          transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: top left;
          transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(var(--fa-li-width, 2em) * -1);
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  -webkit-animation-name: fa-beat;
          animation-name: fa-beat;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);
          animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  -webkit-animation-name: fa-bounce;
          animation-name: fa-bounce;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  -webkit-animation-name: fa-fade;
          animation-name: fa-fade;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  -webkit-animation-name: fa-beat-fade;
          animation-name: fa-beat-fade;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  -webkit-animation-name: fa-flip;
          animation-name: fa-flip;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);
          animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  -webkit-animation-name: fa-shake;
          animation-name: fa-shake;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, linear);
          animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  -webkit-animation-name: fa-spin;
          animation-name: fa-spin;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 2s);
          animation-duration: var(--fa-animation-duration, 2s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, linear);
          animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  -webkit-animation-name: fa-spin;
          animation-name: fa-spin;
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, steps(8));
          animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    -webkit-animation-delay: -1ms;
            animation-delay: -1ms;
    -webkit-animation-duration: 1ms;
            animation-duration: 1ms;
    -webkit-animation-iteration-count: 1;
            animation-iteration-count: 1;
    -webkit-transition-delay: 0s;
            transition-delay: 0s;
    -webkit-transition-duration: 0s;
            transition-duration: 0s;
  }
}
@-webkit-keyframes fa-beat {
  0%, 90% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  45% {
    -webkit-transform: scale(var(--fa-beat-scale, 1.25));
            transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-beat {
  0%, 90% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  45% {
    -webkit-transform: scale(var(--fa-beat-scale, 1.25));
            transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@-webkit-keyframes fa-bounce {
  0% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  10% {
    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  100% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-bounce {
  0% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  10% {
    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  100% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
}
@-webkit-keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@-webkit-keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  50% {
    opacity: 1;
    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
            transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  50% {
    opacity: 1;
    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
            transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@-webkit-keyframes fa-flip {
  50% {
    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-flip {
  50% {
    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@-webkit-keyframes fa-shake {
  0% {
    -webkit-transform: rotate(-15deg);
            transform: rotate(-15deg);
  }
  4% {
    -webkit-transform: rotate(15deg);
            transform: rotate(15deg);
  }
  8%, 24% {
    -webkit-transform: rotate(-18deg);
            transform: rotate(-18deg);
  }
  12%, 28% {
    -webkit-transform: rotate(18deg);
            transform: rotate(18deg);
  }
  16% {
    -webkit-transform: rotate(-22deg);
            transform: rotate(-22deg);
  }
  20% {
    -webkit-transform: rotate(22deg);
            transform: rotate(22deg);
  }
  32% {
    -webkit-transform: rotate(-12deg);
            transform: rotate(-12deg);
  }
  36% {
    -webkit-transform: rotate(12deg);
            transform: rotate(12deg);
  }
  40%, 100% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
}
@keyframes fa-shake {
  0% {
    -webkit-transform: rotate(-15deg);
            transform: rotate(-15deg);
  }
  4% {
    -webkit-transform: rotate(15deg);
            transform: rotate(15deg);
  }
  8%, 24% {
    -webkit-transform: rotate(-18deg);
            transform: rotate(-18deg);
  }
  12%, 28% {
    -webkit-transform: rotate(18deg);
            transform: rotate(18deg);
  }
  16% {
    -webkit-transform: rotate(-22deg);
            transform: rotate(-22deg);
  }
  20% {
    -webkit-transform: rotate(22deg);
            transform: rotate(22deg);
  }
  32% {
    -webkit-transform: rotate(-12deg);
            transform: rotate(-12deg);
  }
  36% {
    -webkit-transform: rotate(12deg);
            transform: rotate(12deg);
  }
  40%, 100% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
}
@-webkit-keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
@keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  -webkit-transform: rotate(90deg);
          transform: rotate(90deg);
}

.fa-rotate-180 {
  -webkit-transform: rotate(180deg);
          transform: rotate(180deg);
}

.fa-rotate-270 {
  -webkit-transform: rotate(270deg);
          transform: rotate(270deg);
}

.fa-flip-horizontal {
  -webkit-transform: scale(-1, 1);
          transform: scale(-1, 1);
}

.fa-flip-vertical {
  -webkit-transform: scale(1, -1);
          transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  -webkit-transform: scale(-1, -1);
          transform: scale(-1, -1);
}

.fa-rotate-by {
  -webkit-transform: rotate(var(--fa-rotate-angle, 0));
          transform: rotate(var(--fa-rotate-angle, 0));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.fad.fa-inverse,
.fa-duotone.fa-inverse {
  color: var(--fa-inverse, #fff);
}`;
function ofe() {
  var o = Yde, a = Xde, c = ps.cssPrefix, f = ps.replacementClass, g = Lve;
  if (c !== o || f !== a) {
    var x = new RegExp("\\.".concat(o, "\\-"), "g"), k = new RegExp("\\--".concat(o, "\\-"), "g"), A = new RegExp("\\.".concat(a), "g");
    g = g.replace(x, ".".concat(c, "-")).replace(k, "--".concat(c, "-")).replace(A, ".".concat(f));
  }
  return g;
}
var ale = !1;
function ute() {
  ps.autoAddCss && !ale && (Pve(ofe()), ale = !0);
}
var $ve = {
  mixout: function() {
    return {
      dom: {
        css: ofe,
        insertCss: ute
      }
    };
  },
  hooks: function() {
    return {
      beforeDOMElementCreation: function() {
        ute();
      },
      beforeI2svg: function() {
        ute();
      }
    };
  }
}, z0 = V2 || {};
z0[H0] || (z0[H0] = {});
z0[H0].styles || (z0[H0].styles = {});
z0[H0].hooks || (z0[H0].hooks = {});
z0[H0].shims || (z0[H0].shims = []);
var ov = z0[H0], sfe = [], Hve = function o() {
  ll.removeEventListener("DOMContentLoaded", o), gV = 1, sfe.map(function(a) {
    return a();
  });
}, gV = !1;
Z0 && (gV = (ll.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(ll.readyState), gV || ll.addEventListener("DOMContentLoaded", Hve));
function zve(o) {
  Z0 && (gV ? setTimeout(o, 0) : sfe.push(o));
}
function BI(o) {
  var a = o.tag, c = o.attributes, f = c === void 0 ? {} : c, g = o.children, x = g === void 0 ? [] : g;
  return typeof o == "string" ? nfe(o) : "<".concat(a, " ").concat(Ive(f), ">").concat(x.map(BI).join(""), "</").concat(a, ">");
}
function ile(o, a, c) {
  if (o && o[a] && o[a][c])
    return {
      prefix: a,
      iconName: c,
      icon: o[a][c]
    };
}
var dte = function(a, c, f, g) {
  var x = Object.keys(a), k = x.length, A = c, N, H, Z;
  for (f === void 0 ? (N = 1, Z = a[x[0]]) : (N = 0, Z = f); N < k; N++)
    H = x[N], Z = A(Z, a[H], H, a);
  return Z;
};
function Vve(o) {
  for (var a = [], c = 0, f = o.length; c < f; ) {
    var g = o.charCodeAt(c++);
    if (g >= 55296 && g <= 56319 && c < f) {
      var x = o.charCodeAt(c++);
      (x & 64512) == 56320 ? a.push(((g & 1023) << 10) + (x & 1023) + 65536) : (a.push(g), c--);
    } else
      a.push(g);
  }
  return a;
}
function Ane(o) {
  var a = Vve(o);
  return a.length === 1 ? a[0].toString(16) : null;
}
function Uve(o, a) {
  var c = o.length, f = o.charCodeAt(a), g;
  return f >= 55296 && f <= 56319 && c > a + 1 && (g = o.charCodeAt(a + 1), g >= 56320 && g <= 57343) ? (f - 55296) * 1024 + g - 56320 + 65536 : f;
}
function lle(o) {
  return Object.keys(o).reduce(function(a, c) {
    var f = o[c], g = !!f.icon;
    return g ? a[f.iconName] = f.icon : a[c] = f, a;
  }, {});
}
function One(o, a) {
  var c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, f = c.skipHooks, g = f === void 0 ? !1 : f, x = lle(a);
  typeof ov.hooks.addPack == "function" && !g ? ov.hooks.addPack(o, lle(a)) : ov.styles[o] = Wo(Wo({}, ov.styles[o] || {}), x), o === "fas" && One("fa", a);
}
var p9, h9, g9, S4 = ov.styles, jve = ov.shims, Wve = (p9 = {}, cu(p9, al, Object.values(bI[al])), cu(p9, Yl, Object.values(bI[Yl])), p9), gse = null, rfe = {}, afe = {}, ife = {}, lfe = {}, cfe = {}, Zve = (h9 = {}, cu(h9, al, Object.keys(gI[al])), cu(h9, Yl, Object.keys(gI[Yl])), h9);
function Gve(o) {
  return ~Ave.indexOf(o);
}
function qve(o, a) {
  var c = a.split("-"), f = c[0], g = c.slice(1).join("-");
  return f === o && g !== "" && !Gve(g) ? g : null;
}
var ufe = function() {
  var a = function(x) {
    return dte(S4, function(k, A, N) {
      return k[N] = dte(A, x, {}), k;
    }, {});
  };
  rfe = a(function(g, x, k) {
    if (x[3] && (g[x[3]] = k), x[2]) {
      var A = x[2].filter(function(N) {
        return typeof N == "number";
      });
      A.forEach(function(N) {
        g[N.toString(16)] = k;
      });
    }
    return g;
  }), afe = a(function(g, x, k) {
    if (g[k] = k, x[2]) {
      var A = x[2].filter(function(N) {
        return typeof N == "string";
      });
      A.forEach(function(N) {
        g[N] = k;
      });
    }
    return g;
  }), cfe = a(function(g, x, k) {
    var A = x[2];
    return g[k] = k, A.forEach(function(N) {
      g[N] = k;
    }), g;
  });
  var c = "far" in S4 || ps.autoFetchSvg, f = dte(jve, function(g, x) {
    var k = x[0], A = x[1], N = x[2];
    return A === "far" && !c && (A = "fas"), typeof k == "string" && (g.names[k] = {
      prefix: A,
      iconName: N
    }), typeof k == "number" && (g.unicodes[k.toString(16)] = {
      prefix: A,
      iconName: N
    }), g;
  }, {
    names: {},
    unicodes: {}
  });
  ife = f.names, lfe = f.unicodes, gse = UV(ps.styleDefault, {
    family: ps.familyDefault
  });
};
Nve(function(o) {
  gse = UV(o.styleDefault, {
    family: ps.familyDefault
  });
});
ufe();
function vse(o, a) {
  return (rfe[o] || {})[a];
}
function Kve(o, a) {
  return (afe[o] || {})[a];
}
function Bk(o, a) {
  return (cfe[o] || {})[a];
}
function dfe(o) {
  return ife[o] || {
    prefix: null,
    iconName: null
  };
}
function Yve(o) {
  var a = lfe[o], c = vse("fas", o);
  return a || (c ? {
    prefix: "fas",
    iconName: c
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function U2() {
  return gse;
}
var bse = function() {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function UV(o) {
  var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, c = a.family, f = c === void 0 ? al : c, g = gI[f][o], x = vI[f][o] || vI[f][g], k = o in ov.styles ? o : null;
  return x || k || null;
}
var cle = (g9 = {}, cu(g9, al, Object.keys(bI[al])), cu(g9, Yl, Object.keys(bI[Yl])), g9);
function jV(o) {
  var a, c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, f = c.skipLookups, g = f === void 0 ? !1 : f, x = (a = {}, cu(a, al, "".concat(ps.cssPrefix, "-").concat(al)), cu(a, Yl, "".concat(ps.cssPrefix, "-").concat(Yl)), a), k = null, A = al;
  (o.includes(x[al]) || o.some(function(H) {
    return cle[al].includes(H);
  })) && (A = al), (o.includes(x[Yl]) || o.some(function(H) {
    return cle[Yl].includes(H);
  })) && (A = Yl);
  var N = o.reduce(function(H, Z) {
    var K = qve(ps.cssPrefix, Z);
    if (S4[Z] ? (Z = Wve[A].includes(Z) ? Cve[A][Z] : Z, k = Z, H.prefix = Z) : Zve[A].indexOf(Z) > -1 ? (k = Z, H.prefix = UV(Z, {
      family: A
    })) : K ? H.iconName = K : Z !== ps.replacementClass && Z !== x[al] && Z !== x[Yl] && H.rest.push(Z), !g && H.prefix && H.iconName) {
      var J = k === "fa" ? dfe(H.iconName) : {}, pe = Bk(H.prefix, H.iconName);
      J.prefix && (k = null), H.iconName = J.iconName || pe || H.iconName, H.prefix = J.prefix || H.prefix, H.prefix === "far" && !S4.far && S4.fas && !ps.autoFetchSvg && (H.prefix = "fas");
    }
    return H;
  }, bse());
  return (o.includes("fa-brands") || o.includes("fab")) && (N.prefix = "fab"), (o.includes("fa-duotone") || o.includes("fad")) && (N.prefix = "fad"), !N.prefix && A === Yl && (S4.fass || ps.autoFetchSvg) && (N.prefix = "fass", N.iconName = Bk(N.prefix, N.iconName) || N.iconName), (N.prefix === "fa" || k === "fa") && (N.prefix = U2() || "fas"), N;
}
var Xve = /* @__PURE__ */ function() {
  function o() {
    cve(this, o), this.definitions = {};
  }
  return dve(o, [{
    key: "add",
    value: function() {
      for (var c = this, f = arguments.length, g = new Array(f), x = 0; x < f; x++)
        g[x] = arguments[x];
      var k = g.reduce(this._pullDefinitions, {});
      Object.keys(k).forEach(function(A) {
        c.definitions[A] = Wo(Wo({}, c.definitions[A] || {}), k[A]), One(A, k[A]);
        var N = bI[al][A];
        N && One(N, k[A]), ufe();
      });
    }
  }, {
    key: "reset",
    value: function() {
      this.definitions = {};
    }
  }, {
    key: "_pullDefinitions",
    value: function(c, f) {
      var g = f.prefix && f.iconName && f.icon ? {
        0: f
      } : f;
      return Object.keys(g).map(function(x) {
        var k = g[x], A = k.prefix, N = k.iconName, H = k.icon, Z = H[2];
        c[A] || (c[A] = {}), Z.length > 0 && Z.forEach(function(K) {
          typeof K == "string" && (c[A][K] = H);
        }), c[A][N] = H;
      }), c;
    }
  }]), o;
}(), ule = [], k4 = {}, M4 = {}, Qve = Object.keys(M4);
function Jve(o, a) {
  var c = a.mixoutsTo;
  return ule = o, k4 = {}, Object.keys(M4).forEach(function(f) {
    Qve.indexOf(f) === -1 && delete M4[f];
  }), ule.forEach(function(f) {
    var g = f.mixout ? f.mixout() : {};
    if (Object.keys(g).forEach(function(k) {
      typeof g[k] == "function" && (c[k] = g[k]), hV(g[k]) === "object" && Object.keys(g[k]).forEach(function(A) {
        c[k] || (c[k] = {}), c[k][A] = g[k][A];
      });
    }), f.hooks) {
      var x = f.hooks();
      Object.keys(x).forEach(function(k) {
        k4[k] || (k4[k] = []), k4[k].push(x[k]);
      });
    }
    f.provides && f.provides(M4);
  }), c;
}
function Dne(o, a) {
  for (var c = arguments.length, f = new Array(c > 2 ? c - 2 : 0), g = 2; g < c; g++)
    f[g - 2] = arguments[g];
  var x = k4[o] || [];
  return x.forEach(function(k) {
    a = k.apply(null, [a].concat(f));
  }), a;
}
function Yk(o) {
  for (var a = arguments.length, c = new Array(a > 1 ? a - 1 : 0), f = 1; f < a; f++)
    c[f - 1] = arguments[f];
  var g = k4[o] || [];
  g.forEach(function(x) {
    x.apply(null, c);
  });
}
function V0() {
  var o = arguments[0], a = Array.prototype.slice.call(arguments, 1);
  return M4[o] ? M4[o].apply(null, a) : void 0;
}
function Rne(o) {
  o.prefix === "fa" && (o.prefix = "fas");
  var a = o.iconName, c = o.prefix || U2();
  if (a)
    return a = Bk(c, a) || a, ile(ffe.definitions, c, a) || ile(ov.styles, c, a);
}
var ffe = new Xve(), ebe = function() {
  ps.autoReplaceSvg = !1, ps.observeMutations = !1, Yk("noAuto");
}, tbe = {
  i2svg: function() {
    var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Z0 ? (Yk("beforeI2svg", a), V0("pseudoElements2svg", a), V0("i2svg", a)) : Promise.reject("Operation requires a DOM of some kind.");
  },
  watch: function() {
    var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, c = a.autoReplaceSvgRoot;
    ps.autoReplaceSvg === !1 && (ps.autoReplaceSvg = !0), ps.observeMutations = !0, zve(function() {
      obe({
        autoReplaceSvgRoot: c
      }), Yk("watch", a);
    });
  }
}, nbe = {
  icon: function(a) {
    if (a === null)
      return null;
    if (hV(a) === "object" && a.prefix && a.iconName)
      return {
        prefix: a.prefix,
        iconName: Bk(a.prefix, a.iconName) || a.iconName
      };
    if (Array.isArray(a) && a.length === 2) {
      var c = a[1].indexOf("fa-") === 0 ? a[1].slice(3) : a[1], f = UV(a[0]);
      return {
        prefix: f,
        iconName: Bk(f, c) || c
      };
    }
    if (typeof a == "string" && (a.indexOf("".concat(ps.cssPrefix, "-")) > -1 || a.match(Sve))) {
      var g = jV(a.split(" "), {
        skipLookups: !0
      });
      return {
        prefix: g.prefix || U2(),
        iconName: Bk(g.prefix, g.iconName) || g.iconName
      };
    }
    if (typeof a == "string") {
      var x = U2();
      return {
        prefix: x,
        iconName: Bk(x, a) || a
      };
    }
  }
}, bp = {
  noAuto: ebe,
  config: ps,
  dom: tbe,
  parse: nbe,
  library: ffe,
  findIconDefinition: Rne,
  toHtml: BI
}, obe = function() {
  var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, c = a.autoReplaceSvgRoot, f = c === void 0 ? ll : c;
  (Object.keys(ov.styles).length > 0 || ps.autoFetchSvg) && Z0 && ps.autoReplaceSvg && bp.dom.i2svg({
    node: f
  });
};
function WV(o, a) {
  return Object.defineProperty(o, "abstract", {
    get: a
  }), Object.defineProperty(o, "html", {
    get: function() {
      return o.abstract.map(function(f) {
        return BI(f);
      });
    }
  }), Object.defineProperty(o, "node", {
    get: function() {
      if (Z0) {
        var f = ll.createElement("div");
        return f.innerHTML = o.html, f.children;
      }
    }
  }), o;
}
function sbe(o) {
  var a = o.children, c = o.main, f = o.mask, g = o.attributes, x = o.styles, k = o.transform;
  if (hse(k) && c.found && !f.found) {
    var A = c.width, N = c.height, H = {
      x: A / N / 2,
      y: 0.5
    };
    g.style = VV(Wo(Wo({}, x), {}, {
      "transform-origin": "".concat(H.x + k.x / 16, "em ").concat(H.y + k.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes: g,
    children: a
  }];
}
function rbe(o) {
  var a = o.prefix, c = o.iconName, f = o.children, g = o.attributes, x = o.symbol, k = x === !0 ? "".concat(a, "-").concat(ps.cssPrefix, "-").concat(c) : x;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: Wo(Wo({}, g), {}, {
        id: k
      }),
      children: f
    }]
  }];
}
function yse(o) {
  var a = o.icons, c = a.main, f = a.mask, g = o.prefix, x = o.iconName, k = o.transform, A = o.symbol, N = o.title, H = o.maskId, Z = o.titleId, K = o.extra, J = o.watchable, pe = J === void 0 ? !1 : J, Se = f.found ? f : c, be = Se.width, ye = Se.height, re = g === "fak", oe = [ps.replacementClass, x ? "".concat(ps.cssPrefix, "-").concat(x) : ""].filter(function(wt) {
    return K.classes.indexOf(wt) === -1;
  }).filter(function(wt) {
    return wt !== "" || !!wt;
  }).concat(K.classes).join(" "), U = {
    children: [],
    attributes: Wo(Wo({}, K.attributes), {}, {
      "data-prefix": g,
      "data-icon": x,
      class: oe,
      role: K.attributes.role || "img",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 ".concat(be, " ").concat(ye)
    })
  }, ve = re && !~K.classes.indexOf("fa-fw") ? {
    width: "".concat(be / ye * 16 * 0.0625, "em")
  } : {};
  pe && (U.attributes[Kk] = ""), N && (U.children.push({
    tag: "title",
    attributes: {
      id: U.attributes["aria-labelledby"] || "title-".concat(Z || xI())
    },
    children: [N]
  }), delete U.attributes.title);
  var Ze = Wo(Wo({}, U), {}, {
    prefix: g,
    iconName: x,
    main: c,
    mask: f,
    maskId: H,
    transform: k,
    symbol: A,
    styles: Wo(Wo({}, ve), K.styles)
  }), rt = f.found && c.found ? V0("generateAbstractMask", Ze) || {
    children: [],
    attributes: {}
  } : V0("generateAbstractIcon", Ze) || {
    children: [],
    attributes: {}
  }, ee = rt.children, lt = rt.attributes;
  return Ze.children = ee, Ze.attributes = lt, A ? rbe(Ze) : sbe(Ze);
}
function dle(o) {
  var a = o.content, c = o.width, f = o.height, g = o.transform, x = o.title, k = o.extra, A = o.watchable, N = A === void 0 ? !1 : A, H = Wo(Wo(Wo({}, k.attributes), x ? {
    title: x
  } : {}), {}, {
    class: k.classes.join(" ")
  });
  N && (H[Kk] = "");
  var Z = Wo({}, k.styles);
  hse(g) && (Z.transform = Bve({
    transform: g,
    startCentered: !0,
    width: c,
    height: f
  }), Z["-webkit-transform"] = Z.transform);
  var K = VV(Z);
  K.length > 0 && (H.style = K);
  var J = [];
  return J.push({
    tag: "span",
    attributes: H,
    children: [a]
  }), x && J.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [x]
  }), J;
}
function abe(o) {
  var a = o.content, c = o.title, f = o.extra, g = Wo(Wo(Wo({}, f.attributes), c ? {
    title: c
  } : {}), {}, {
    class: f.classes.join(" ")
  }), x = VV(f.styles);
  x.length > 0 && (g.style = x);
  var k = [];
  return k.push({
    tag: "span",
    attributes: g,
    children: [a]
  }), c && k.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [c]
  }), k;
}
var fte = ov.styles;
function Nne(o) {
  var a = o[0], c = o[1], f = o.slice(4), g = cse(f, 1), x = g[0], k = null;
  return Array.isArray(x) ? k = {
    tag: "g",
    attributes: {
      class: "".concat(ps.cssPrefix, "-").concat(Fk.GROUP)
    },
    children: [{
      tag: "path",
      attributes: {
        class: "".concat(ps.cssPrefix, "-").concat(Fk.SECONDARY),
        fill: "currentColor",
        d: x[0]
      }
    }, {
      tag: "path",
      attributes: {
        class: "".concat(ps.cssPrefix, "-").concat(Fk.PRIMARY),
        fill: "currentColor",
        d: x[1]
      }
    }]
  } : k = {
    tag: "path",
    attributes: {
      fill: "currentColor",
      d: x
    }
  }, {
    found: !0,
    width: a,
    height: c,
    icon: k
  };
}
var ibe = {
  found: !1,
  width: 512,
  height: 512
};
function lbe(o, a) {
  !Qde && !ps.showMissingIcons && o && console.error('Icon with name "'.concat(o, '" and prefix "').concat(a, '" is missing.'));
}
function Pne(o, a) {
  var c = a;
  return a === "fa" && ps.styleDefault !== null && (a = U2()), new Promise(function(f, g) {
    if (V0("missingIconAbstract"), c === "fa") {
      var x = dfe(o) || {};
      o = x.iconName || o, a = x.prefix || a;
    }
    if (o && a && fte[a] && fte[a][o]) {
      var k = fte[a][o];
      return f(Nne(k));
    }
    lbe(o, a), f(Wo(Wo({}, ibe), {}, {
      icon: ps.showMissingIcons && o ? V0("missingIconAbstract") || {} : {}
    }));
  });
}
var fle = function() {
}, Mne = ps.measurePerformance && l9 && l9.mark && l9.measure ? l9 : {
  mark: fle,
  measure: fle
}, B5 = 'FA "6.5.2"', cbe = function(a) {
  return Mne.mark("".concat(B5, " ").concat(a, " begins")), function() {
    return mfe(a);
  };
}, mfe = function(a) {
  Mne.mark("".concat(B5, " ").concat(a, " ends")), Mne.measure("".concat(B5, " ").concat(a), "".concat(B5, " ").concat(a, " begins"), "".concat(B5, " ").concat(a, " ends"));
}, xse = {
  begin: cbe,
  end: mfe
}, L9 = function() {
};
function mle(o) {
  var a = o.getAttribute ? o.getAttribute(Kk) : null;
  return typeof a == "string";
}
function ube(o) {
  var a = o.getAttribute ? o.getAttribute(dse) : null, c = o.getAttribute ? o.getAttribute(fse) : null;
  return a && c;
}
function dbe(o) {
  return o && o.classList && o.classList.contains && o.classList.contains(ps.replacementClass);
}
function fbe() {
  if (ps.autoReplaceSvg === !0)
    return $9.replace;
  var o = $9[ps.autoReplaceSvg];
  return o || $9.replace;
}
function mbe(o) {
  return ll.createElementNS("http://www.w3.org/2000/svg", o);
}
function pbe(o) {
  return ll.createElement(o);
}
function pfe(o) {
  var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, c = a.ceFn, f = c === void 0 ? o.tag === "svg" ? mbe : pbe : c;
  if (typeof o == "string")
    return ll.createTextNode(o);
  var g = f(o.tag);
  Object.keys(o.attributes || []).forEach(function(k) {
    g.setAttribute(k, o.attributes[k]);
  });
  var x = o.children || [];
  return x.forEach(function(k) {
    g.appendChild(pfe(k, {
      ceFn: f
    }));
  }), g;
}
function hbe(o) {
  var a = " ".concat(o.outerHTML, " ");
  return a = "".concat(a, "Font Awesome fontawesome.com "), a;
}
var $9 = {
  replace: function(a) {
    var c = a[0];
    if (c.parentNode)
      if (a[1].forEach(function(g) {
        c.parentNode.insertBefore(pfe(g), c);
      }), c.getAttribute(Kk) === null && ps.keepOriginalSource) {
        var f = ll.createComment(hbe(c));
        c.parentNode.replaceChild(f, c);
      } else
        c.remove();
  },
  nest: function(a) {
    var c = a[0], f = a[1];
    if (~pse(c).indexOf(ps.replacementClass))
      return $9.replace(a);
    var g = new RegExp("".concat(ps.cssPrefix, "-.*"));
    if (delete f[0].attributes.id, f[0].attributes.class) {
      var x = f[0].attributes.class.split(" ").reduce(function(A, N) {
        return N === ps.replacementClass || N.match(g) ? A.toSvg.push(N) : A.toNode.push(N), A;
      }, {
        toNode: [],
        toSvg: []
      });
      f[0].attributes.class = x.toSvg.join(" "), x.toNode.length === 0 ? c.removeAttribute("class") : c.setAttribute("class", x.toNode.join(" "));
    }
    var k = f.map(function(A) {
      return BI(A);
    }).join(`
`);
    c.setAttribute(Kk, ""), c.innerHTML = k;
  }
};
function ple(o) {
  o();
}
function hfe(o, a) {
  var c = typeof a == "function" ? a : L9;
  if (o.length === 0)
    c();
  else {
    var f = ple;
    ps.mutateApproach === xve && (f = V2.requestAnimationFrame || ple), f(function() {
      var g = fbe(), x = xse.begin("mutate");
      o.map(g), x(), c();
    });
  }
}
var wse = !1;
function gfe() {
  wse = !0;
}
function Ine() {
  wse = !1;
}
var vV = null;
function hle(o) {
  if (sle && ps.observeMutations) {
    var a = o.treeCallback, c = a === void 0 ? L9 : a, f = o.nodeCallback, g = f === void 0 ? L9 : f, x = o.pseudoElementsCallback, k = x === void 0 ? L9 : x, A = o.observeMutationsRoot, N = A === void 0 ? ll : A;
    vV = new sle(function(H) {
      if (!wse) {
        var Z = U2();
        sO(H).forEach(function(K) {
          if (K.type === "childList" && K.addedNodes.length > 0 && !mle(K.addedNodes[0]) && (ps.searchPseudoElements && k(K.target), c(K.target)), K.type === "attributes" && K.target.parentNode && ps.searchPseudoElements && k(K.target.parentNode), K.type === "attributes" && mle(K.target) && ~Tve.indexOf(K.attributeName))
            if (K.attributeName === "class" && ube(K.target)) {
              var J = jV(pse(K.target)), pe = J.prefix, Se = J.iconName;
              K.target.setAttribute(dse, pe || Z), Se && K.target.setAttribute(fse, Se);
            } else dbe(K.target) && g(K.target);
        });
      }
    }), Z0 && vV.observe(N, {
      childList: !0,
      attributes: !0,
      characterData: !0,
      subtree: !0
    });
  }
}
function gbe() {
  vV && vV.disconnect();
}
function vbe(o) {
  var a = o.getAttribute("style"), c = [];
  return a && (c = a.split(";").reduce(function(f, g) {
    var x = g.split(":"), k = x[0], A = x.slice(1);
    return k && A.length > 0 && (f[k] = A.join(":").trim()), f;
  }, {})), c;
}
function bbe(o) {
  var a = o.getAttribute("data-prefix"), c = o.getAttribute("data-icon"), f = o.innerText !== void 0 ? o.innerText.trim() : "", g = jV(pse(o));
  return g.prefix || (g.prefix = U2()), a && c && (g.prefix = a, g.iconName = c), g.iconName && g.prefix || (g.prefix && f.length > 0 && (g.iconName = Kve(g.prefix, o.innerText) || vse(g.prefix, Ane(o.innerText))), !g.iconName && ps.autoFetchSvg && o.firstChild && o.firstChild.nodeType === Node.TEXT_NODE && (g.iconName = o.firstChild.data)), g;
}
function ybe(o) {
  var a = sO(o.attributes).reduce(function(g, x) {
    return g.name !== "class" && g.name !== "style" && (g[x.name] = x.value), g;
  }, {}), c = o.getAttribute("title"), f = o.getAttribute("data-fa-title-id");
  return ps.autoA11y && (c ? a["aria-labelledby"] = "".concat(ps.replacementClass, "-title-").concat(f || xI()) : (a["aria-hidden"] = "true", a.focusable = "false")), a;
}
function xbe() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: Pb,
    symbol: !1,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function gle(o) {
  var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: !0
  }, c = bbe(o), f = c.iconName, g = c.prefix, x = c.rest, k = ybe(o), A = Dne("parseNodeAttributes", {}, o), N = a.styleParser ? vbe(o) : [];
  return Wo({
    iconName: f,
    title: o.getAttribute("title"),
    titleId: o.getAttribute("data-fa-title-id"),
    prefix: g,
    transform: Pb,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: !1,
    extra: {
      classes: x,
      styles: N,
      attributes: k
    }
  }, A);
}
var wbe = ov.styles;
function vfe(o) {
  var a = ps.autoReplaceSvg === "nest" ? gle(o, {
    styleParser: !1
  }) : gle(o);
  return ~a.extra.classes.indexOf(Jde) ? V0("generateLayersText", o, a) : V0("generateSvgReplacementMutation", o, a);
}
var j2 = /* @__PURE__ */ new Set();
mse.map(function(o) {
  j2.add("fa-".concat(o));
});
Object.keys(gI[al]).map(j2.add.bind(j2));
Object.keys(gI[Yl]).map(j2.add.bind(j2));
j2 = II(j2);
function vle(o) {
  var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!Z0) return Promise.resolve();
  var c = ll.documentElement.classList, f = function(K) {
    return c.add("".concat(rle, "-").concat(K));
  }, g = function(K) {
    return c.remove("".concat(rle, "-").concat(K));
  }, x = ps.autoFetchSvg ? j2 : mse.map(function(Z) {
    return "fa-".concat(Z);
  }).concat(Object.keys(wbe));
  x.includes("fa") || x.push("fa");
  var k = [".".concat(Jde, ":not([").concat(Kk, "])")].concat(x.map(function(Z) {
    return ".".concat(Z, ":not([").concat(Kk, "])");
  })).join(", ");
  if (k.length === 0)
    return Promise.resolve();
  var A = [];
  try {
    A = sO(o.querySelectorAll(k));
  } catch {
  }
  if (A.length > 0)
    f("pending"), g("complete");
  else
    return Promise.resolve();
  var N = xse.begin("onTree"), H = A.reduce(function(Z, K) {
    try {
      var J = vfe(K);
      J && Z.push(J);
    } catch (pe) {
      Qde || pe.name === "MissingIcon" && console.error(pe);
    }
    return Z;
  }, []);
  return new Promise(function(Z, K) {
    Promise.all(H).then(function(J) {
      hfe(J, function() {
        f("active"), f("complete"), g("pending"), typeof a == "function" && a(), N(), Z();
      });
    }).catch(function(J) {
      N(), K(J);
    });
  });
}
function Cbe(o) {
  var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  vfe(o).then(function(c) {
    c && hfe([c], a);
  });
}
function Sbe(o) {
  return function(a) {
    var c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, f = (a || {}).icon ? a : Rne(a || {}), g = c.mask;
    return g && (g = (g || {}).icon ? g : Rne(g || {})), o(f, Wo(Wo({}, c), {}, {
      mask: g
    }));
  };
}
var kbe = function(a) {
  var c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, f = c.transform, g = f === void 0 ? Pb : f, x = c.symbol, k = x === void 0 ? !1 : x, A = c.mask, N = A === void 0 ? null : A, H = c.maskId, Z = H === void 0 ? null : H, K = c.title, J = K === void 0 ? null : K, pe = c.titleId, Se = pe === void 0 ? null : pe, be = c.classes, ye = be === void 0 ? [] : be, re = c.attributes, oe = re === void 0 ? {} : re, U = c.styles, ve = U === void 0 ? {} : U;
  if (a) {
    var Ze = a.prefix, rt = a.iconName, ee = a.icon;
    return WV(Wo({
      type: "icon"
    }, a), function() {
      return Yk("beforeDOMElementCreation", {
        iconDefinition: a,
        params: c
      }), ps.autoA11y && (J ? oe["aria-labelledby"] = "".concat(ps.replacementClass, "-title-").concat(Se || xI()) : (oe["aria-hidden"] = "true", oe.focusable = "false")), yse({
        icons: {
          main: Nne(ee),
          mask: N ? Nne(N.icon) : {
            found: !1,
            width: null,
            height: null,
            icon: {}
          }
        },
        prefix: Ze,
        iconName: rt,
        transform: Wo(Wo({}, Pb), g),
        symbol: k,
        title: J,
        maskId: Z,
        titleId: Se,
        extra: {
          attributes: oe,
          styles: ve,
          classes: ye
        }
      });
    });
  }
}, _be = {
  mixout: function() {
    return {
      icon: Sbe(kbe)
    };
  },
  hooks: function() {
    return {
      mutationObserverCallbacks: function(c) {
        return c.treeCallback = vle, c.nodeCallback = Cbe, c;
      }
    };
  },
  provides: function(a) {
    a.i2svg = function(c) {
      var f = c.node, g = f === void 0 ? ll : f, x = c.callback, k = x === void 0 ? function() {
      } : x;
      return vle(g, k);
    }, a.generateSvgReplacementMutation = function(c, f) {
      var g = f.iconName, x = f.title, k = f.titleId, A = f.prefix, N = f.transform, H = f.symbol, Z = f.mask, K = f.maskId, J = f.extra;
      return new Promise(function(pe, Se) {
        Promise.all([Pne(g, A), Z.iconName ? Pne(Z.iconName, Z.prefix) : Promise.resolve({
          found: !1,
          width: 512,
          height: 512,
          icon: {}
        })]).then(function(be) {
          var ye = cse(be, 2), re = ye[0], oe = ye[1];
          pe([c, yse({
            icons: {
              main: re,
              mask: oe
            },
            prefix: A,
            iconName: g,
            transform: N,
            symbol: H,
            maskId: K,
            title: x,
            titleId: k,
            extra: J,
            watchable: !0
          })]);
        }).catch(Se);
      });
    }, a.generateAbstractIcon = function(c) {
      var f = c.children, g = c.attributes, x = c.main, k = c.transform, A = c.styles, N = VV(A);
      N.length > 0 && (g.style = N);
      var H;
      return hse(k) && (H = V0("generateAbstractTransformGrouping", {
        main: x,
        transform: k,
        containerWidth: x.width,
        iconWidth: x.width
      })), f.push(H || x.icon), {
        children: f,
        attributes: g
      };
    };
  }
}, Ebe = {
  mixout: function() {
    return {
      layer: function(c) {
        var f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, g = f.classes, x = g === void 0 ? [] : g;
        return WV({
          type: "layer"
        }, function() {
          Yk("beforeDOMElementCreation", {
            assembler: c,
            params: f
          });
          var k = [];
          return c(function(A) {
            Array.isArray(A) ? A.map(function(N) {
              k = k.concat(N.abstract);
            }) : k = k.concat(A.abstract);
          }), [{
            tag: "span",
            attributes: {
              class: ["".concat(ps.cssPrefix, "-layers")].concat(II(x)).join(" ")
            },
            children: k
          }];
        });
      }
    };
  }
}, Tbe = {
  mixout: function() {
    return {
      counter: function(c) {
        var f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, g = f.title, x = g === void 0 ? null : g, k = f.classes, A = k === void 0 ? [] : k, N = f.attributes, H = N === void 0 ? {} : N, Z = f.styles, K = Z === void 0 ? {} : Z;
        return WV({
          type: "counter",
          content: c
        }, function() {
          return Yk("beforeDOMElementCreation", {
            content: c,
            params: f
          }), abe({
            content: c.toString(),
            title: x,
            extra: {
              attributes: H,
              styles: K,
              classes: ["".concat(ps.cssPrefix, "-layers-counter")].concat(II(A))
            }
          });
        });
      }
    };
  }
}, Abe = {
  mixout: function() {
    return {
      text: function(c) {
        var f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, g = f.transform, x = g === void 0 ? Pb : g, k = f.title, A = k === void 0 ? null : k, N = f.classes, H = N === void 0 ? [] : N, Z = f.attributes, K = Z === void 0 ? {} : Z, J = f.styles, pe = J === void 0 ? {} : J;
        return WV({
          type: "text",
          content: c
        }, function() {
          return Yk("beforeDOMElementCreation", {
            content: c,
            params: f
          }), dle({
            content: c,
            transform: Wo(Wo({}, Pb), x),
            title: A,
            extra: {
              attributes: K,
              styles: pe,
              classes: ["".concat(ps.cssPrefix, "-layers-text")].concat(II(H))
            }
          });
        });
      }
    };
  },
  provides: function(a) {
    a.generateLayersText = function(c, f) {
      var g = f.title, x = f.transform, k = f.extra, A = null, N = null;
      if (Kde) {
        var H = parseInt(getComputedStyle(c).fontSize, 10), Z = c.getBoundingClientRect();
        A = Z.width / H, N = Z.height / H;
      }
      return ps.autoA11y && !g && (k.attributes["aria-hidden"] = "true"), Promise.resolve([c, dle({
        content: c.innerHTML,
        width: A,
        height: N,
        transform: x,
        title: g,
        extra: k,
        watchable: !0
      })]);
    };
  }
}, Obe = new RegExp('"', "ug"), ble = [1105920, 1112319];
function Dbe(o) {
  var a = o.replace(Obe, ""), c = Uve(a, 0), f = c >= ble[0] && c <= ble[1], g = a.length === 2 ? a[0] === a[1] : !1;
  return {
    value: Ane(g ? a[0] : a),
    isSecondary: f || g
  };
}
function yle(o, a) {
  var c = "".concat(yve).concat(a.replace(":", "-"));
  return new Promise(function(f, g) {
    if (o.getAttribute(c) !== null)
      return f();
    var x = sO(o.children), k = x.filter(function(ee) {
      return ee.getAttribute(Tne) === a;
    })[0], A = V2.getComputedStyle(o, a), N = A.getPropertyValue("font-family").match(kve), H = A.getPropertyValue("font-weight"), Z = A.getPropertyValue("content");
    if (k && !N)
      return o.removeChild(k), f();
    if (N && Z !== "none" && Z !== "") {
      var K = A.getPropertyValue("content"), J = ~["Sharp"].indexOf(N[2]) ? Yl : al, pe = ~["Solid", "Regular", "Light", "Thin", "Duotone", "Brands", "Kit"].indexOf(N[2]) ? vI[J][N[2].toLowerCase()] : _ve[J][H], Se = Dbe(K), be = Se.value, ye = Se.isSecondary, re = N[0].startsWith("FontAwesome"), oe = vse(pe, be), U = oe;
      if (re) {
        var ve = Yve(be);
        ve.iconName && ve.prefix && (oe = ve.iconName, pe = ve.prefix);
      }
      if (oe && !ye && (!k || k.getAttribute(dse) !== pe || k.getAttribute(fse) !== U)) {
        o.setAttribute(c, U), k && o.removeChild(k);
        var Ze = xbe(), rt = Ze.extra;
        rt.attributes[Tne] = a, Pne(oe, pe).then(function(ee) {
          var lt = yse(Wo(Wo({}, Ze), {}, {
            icons: {
              main: ee,
              mask: bse()
            },
            prefix: pe,
            iconName: U,
            extra: rt,
            watchable: !0
          })), wt = ll.createElementNS("http://www.w3.org/2000/svg", "svg");
          a === "::before" ? o.insertBefore(wt, o.firstChild) : o.appendChild(wt), wt.outerHTML = lt.map(function(Vt) {
            return BI(Vt);
          }).join(`
`), o.removeAttribute(c), f();
        }).catch(g);
      } else
        f();
    } else
      f();
  });
}
function Rbe(o) {
  return Promise.all([yle(o, "::before"), yle(o, "::after")]);
}
function Nbe(o) {
  return o.parentNode !== document.head && !~wve.indexOf(o.tagName.toUpperCase()) && !o.getAttribute(Tne) && (!o.parentNode || o.parentNode.tagName !== "svg");
}
function xle(o) {
  if (Z0)
    return new Promise(function(a, c) {
      var f = sO(o.querySelectorAll("*")).filter(Nbe).map(Rbe), g = xse.begin("searchPseudoElements");
      gfe(), Promise.all(f).then(function() {
        g(), Ine(), a();
      }).catch(function() {
        g(), Ine(), c();
      });
    });
}
var Pbe = {
  hooks: function() {
    return {
      mutationObserverCallbacks: function(c) {
        return c.pseudoElementsCallback = xle, c;
      }
    };
  },
  provides: function(a) {
    a.pseudoElements2svg = function(c) {
      var f = c.node, g = f === void 0 ? ll : f;
      ps.searchPseudoElements && xle(g);
    };
  }
}, wle = !1, Mbe = {
  mixout: function() {
    return {
      dom: {
        unwatch: function() {
          gfe(), wle = !0;
        }
      }
    };
  },
  hooks: function() {
    return {
      bootstrap: function() {
        hle(Dne("mutationObserverCallbacks", {}));
      },
      noAuto: function() {
        gbe();
      },
      watch: function(c) {
        var f = c.observeMutationsRoot;
        wle ? Ine() : hle(Dne("mutationObserverCallbacks", {
          observeMutationsRoot: f
        }));
      }
    };
  }
}, Cle = function(a) {
  var c = {
    size: 16,
    x: 0,
    y: 0,
    flipX: !1,
    flipY: !1,
    rotate: 0
  };
  return a.toLowerCase().split(" ").reduce(function(f, g) {
    var x = g.toLowerCase().split("-"), k = x[0], A = x.slice(1).join("-");
    if (k && A === "h")
      return f.flipX = !0, f;
    if (k && A === "v")
      return f.flipY = !0, f;
    if (A = parseFloat(A), isNaN(A))
      return f;
    switch (k) {
      case "grow":
        f.size = f.size + A;
        break;
      case "shrink":
        f.size = f.size - A;
        break;
      case "left":
        f.x = f.x - A;
        break;
      case "right":
        f.x = f.x + A;
        break;
      case "up":
        f.y = f.y - A;
        break;
      case "down":
        f.y = f.y + A;
        break;
      case "rotate":
        f.rotate = f.rotate + A;
        break;
    }
    return f;
  }, c);
}, Ibe = {
  mixout: function() {
    return {
      parse: {
        transform: function(c) {
          return Cle(c);
        }
      }
    };
  },
  hooks: function() {
    return {
      parseNodeAttributes: function(c, f) {
        var g = f.getAttribute("data-fa-transform");
        return g && (c.transform = Cle(g)), c;
      }
    };
  },
  provides: function(a) {
    a.generateAbstractTransformGrouping = function(c) {
      var f = c.main, g = c.transform, x = c.containerWidth, k = c.iconWidth, A = {
        transform: "translate(".concat(x / 2, " 256)")
      }, N = "translate(".concat(g.x * 32, ", ").concat(g.y * 32, ") "), H = "scale(".concat(g.size / 16 * (g.flipX ? -1 : 1), ", ").concat(g.size / 16 * (g.flipY ? -1 : 1), ") "), Z = "rotate(".concat(g.rotate, " 0 0)"), K = {
        transform: "".concat(N, " ").concat(H, " ").concat(Z)
      }, J = {
        transform: "translate(".concat(k / 2 * -1, " -256)")
      }, pe = {
        outer: A,
        inner: K,
        path: J
      };
      return {
        tag: "g",
        attributes: Wo({}, pe.outer),
        children: [{
          tag: "g",
          attributes: Wo({}, pe.inner),
          children: [{
            tag: f.icon.tag,
            children: f.icon.children,
            attributes: Wo(Wo({}, f.icon.attributes), pe.path)
          }]
        }]
      };
    };
  }
}, mte = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function Sle(o) {
  var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return o.attributes && (o.attributes.fill || a) && (o.attributes.fill = "black"), o;
}
function Fbe(o) {
  return o.tag === "g" ? o.children : [o];
}
var Bbe = {
  hooks: function() {
    return {
      parseNodeAttributes: function(c, f) {
        var g = f.getAttribute("data-fa-mask"), x = g ? jV(g.split(" ").map(function(k) {
          return k.trim();
        })) : bse();
        return x.prefix || (x.prefix = U2()), c.mask = x, c.maskId = f.getAttribute("data-fa-mask-id"), c;
      }
    };
  },
  provides: function(a) {
    a.generateAbstractMask = function(c) {
      var f = c.children, g = c.attributes, x = c.main, k = c.mask, A = c.maskId, N = c.transform, H = x.width, Z = x.icon, K = k.width, J = k.icon, pe = Fve({
        transform: N,
        containerWidth: K,
        iconWidth: H
      }), Se = {
        tag: "rect",
        attributes: Wo(Wo({}, mte), {}, {
          fill: "white"
        })
      }, be = Z.children ? {
        children: Z.children.map(Sle)
      } : {}, ye = {
        tag: "g",
        attributes: Wo({}, pe.inner),
        children: [Sle(Wo({
          tag: Z.tag,
          attributes: Wo(Wo({}, Z.attributes), pe.path)
        }, be))]
      }, re = {
        tag: "g",
        attributes: Wo({}, pe.outer),
        children: [ye]
      }, oe = "mask-".concat(A || xI()), U = "clip-".concat(A || xI()), ve = {
        tag: "mask",
        attributes: Wo(Wo({}, mte), {}, {
          id: oe,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        }),
        children: [Se, re]
      }, Ze = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: U
          },
          children: Fbe(J)
        }, ve]
      };
      return f.push(Ze, {
        tag: "rect",
        attributes: Wo({
          fill: "currentColor",
          "clip-path": "url(#".concat(U, ")"),
          mask: "url(#".concat(oe, ")")
        }, mte)
      }), {
        children: f,
        attributes: g
      };
    };
  }
}, Lbe = {
  provides: function(a) {
    var c = !1;
    V2.matchMedia && (c = V2.matchMedia("(prefers-reduced-motion: reduce)").matches), a.missingIconAbstract = function() {
      var f = [], g = {
        fill: "currentColor"
      }, x = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      f.push({
        tag: "path",
        attributes: Wo(Wo({}, g), {}, {
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        })
      });
      var k = Wo(Wo({}, x), {}, {
        attributeName: "opacity"
      }), A = {
        tag: "circle",
        attributes: Wo(Wo({}, g), {}, {
          cx: "256",
          cy: "364",
          r: "28"
        }),
        children: []
      };
      return c || A.children.push({
        tag: "animate",
        attributes: Wo(Wo({}, x), {}, {
          attributeName: "r",
          values: "28;14;28;28;14;28;"
        })
      }, {
        tag: "animate",
        attributes: Wo(Wo({}, k), {}, {
          values: "1;0;1;1;0;1;"
        })
      }), f.push(A), f.push({
        tag: "path",
        attributes: Wo(Wo({}, g), {}, {
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        }),
        children: c ? [] : [{
          tag: "animate",
          attributes: Wo(Wo({}, k), {}, {
            values: "1;0;0;0;0;1;"
          })
        }]
      }), c || f.push({
        tag: "path",
        attributes: Wo(Wo({}, g), {}, {
          opacity: "0",
          d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
        }),
        children: [{
          tag: "animate",
          attributes: Wo(Wo({}, k), {}, {
            values: "0;0;1;1;0;0;"
          })
        }]
      }), {
        tag: "g",
        attributes: {
          class: "missing"
        },
        children: f
      };
    };
  }
}, $be = {
  hooks: function() {
    return {
      parseNodeAttributes: function(c, f) {
        var g = f.getAttribute("data-fa-symbol"), x = g === null ? !1 : g === "" ? !0 : g;
        return c.symbol = x, c;
      }
    };
  }
}, Hbe = [$ve, _be, Ebe, Tbe, Abe, Pbe, Mbe, Ibe, Bbe, Lbe, $be];
Jve(Hbe, {
  mixoutsTo: bp
});
bp.noAuto;
bp.config;
bp.library;
bp.dom;
var Fne = bp.parse;
bp.findIconDefinition;
bp.toHtml;
var zbe = bp.icon;
bp.layer;
bp.text;
bp.counter;
function kle(o, a) {
  var c = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var f = Object.getOwnPropertySymbols(o);
    a && (f = f.filter(function(g) {
      return Object.getOwnPropertyDescriptor(o, g).enumerable;
    })), c.push.apply(c, f);
  }
  return c;
}
function O2(o) {
  for (var a = 1; a < arguments.length; a++) {
    var c = arguments[a] != null ? arguments[a] : {};
    a % 2 ? kle(Object(c), !0).forEach(function(f) {
      _4(o, f, c[f]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(c)) : kle(Object(c)).forEach(function(f) {
      Object.defineProperty(o, f, Object.getOwnPropertyDescriptor(c, f));
    });
  }
  return o;
}
function bV(o) {
  "@babel/helpers - typeof";
  return bV = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(a) {
    return typeof a;
  } : function(a) {
    return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
  }, bV(o);
}
function _4(o, a, c) {
  return a in o ? Object.defineProperty(o, a, {
    value: c,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : o[a] = c, o;
}
function Vbe(o, a) {
  if (o == null) return {};
  var c = {}, f = Object.keys(o), g, x;
  for (x = 0; x < f.length; x++)
    g = f[x], !(a.indexOf(g) >= 0) && (c[g] = o[g]);
  return c;
}
function bfe(o, a) {
  if (o == null) return {};
  var c = Vbe(o, a), f, g;
  if (Object.getOwnPropertySymbols) {
    var x = Object.getOwnPropertySymbols(o);
    for (g = 0; g < x.length; g++)
      f = x[g], !(a.indexOf(f) >= 0) && Object.prototype.propertyIsEnumerable.call(o, f) && (c[f] = o[f]);
  }
  return c;
}
function Bne(o) {
  return Ube(o) || jbe(o) || Wbe(o) || Zbe();
}
function Ube(o) {
  if (Array.isArray(o)) return Lne(o);
}
function jbe(o) {
  if (typeof Symbol < "u" && o[Symbol.iterator] != null || o["@@iterator"] != null) return Array.from(o);
}
function Wbe(o, a) {
  if (o) {
    if (typeof o == "string") return Lne(o, a);
    var c = Object.prototype.toString.call(o).slice(8, -1);
    if (c === "Object" && o.constructor && (c = o.constructor.name), c === "Map" || c === "Set") return Array.from(o);
    if (c === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c)) return Lne(o, a);
  }
}
function Lne(o, a) {
  (a == null || a > o.length) && (a = o.length);
  for (var c = 0, f = new Array(a); c < a; c++) f[c] = o[c];
  return f;
}
function Zbe() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Gbe(o) {
  var a, c = o.beat, f = o.fade, g = o.beatFade, x = o.bounce, k = o.shake, A = o.flash, N = o.spin, H = o.spinPulse, Z = o.spinReverse, K = o.pulse, J = o.fixedWidth, pe = o.inverse, Se = o.border, be = o.listItem, ye = o.flip, re = o.size, oe = o.rotation, U = o.pull, ve = (a = {
    "fa-beat": c,
    "fa-fade": f,
    "fa-beat-fade": g,
    "fa-bounce": x,
    "fa-shake": k,
    "fa-flash": A,
    "fa-spin": N,
    "fa-spin-reverse": Z,
    "fa-spin-pulse": H,
    "fa-pulse": K,
    "fa-fw": J,
    "fa-inverse": pe,
    "fa-border": Se,
    "fa-li": be,
    "fa-flip": ye === !0,
    "fa-flip-horizontal": ye === "horizontal" || ye === "both",
    "fa-flip-vertical": ye === "vertical" || ye === "both"
  }, _4(a, "fa-".concat(re), typeof re < "u" && re !== null), _4(a, "fa-rotate-".concat(oe), typeof oe < "u" && oe !== null && oe !== 0), _4(a, "fa-pull-".concat(U), typeof U < "u" && U !== null), _4(a, "fa-swap-opacity", o.swapOpacity), a);
  return Object.keys(ve).map(function(Ze) {
    return ve[Ze] ? Ze : null;
  }).filter(function(Ze) {
    return Ze;
  });
}
function qbe(o) {
  return o = o - 0, o === o;
}
function yfe(o) {
  return qbe(o) ? o : (o = o.replace(/[\-_\s]+(.)?/g, function(a, c) {
    return c ? c.toUpperCase() : "";
  }), o.substr(0, 1).toLowerCase() + o.substr(1));
}
var Kbe = ["style"];
function Ybe(o) {
  return o.charAt(0).toUpperCase() + o.slice(1);
}
function Xbe(o) {
  return o.split(";").map(function(a) {
    return a.trim();
  }).filter(function(a) {
    return a;
  }).reduce(function(a, c) {
    var f = c.indexOf(":"), g = yfe(c.slice(0, f)), x = c.slice(f + 1).trim();
    return g.startsWith("webkit") ? a[Ybe(g)] = x : a[g] = x, a;
  }, {});
}
function xfe(o, a) {
  var c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof a == "string")
    return a;
  var f = (a.children || []).map(function(N) {
    return xfe(o, N);
  }), g = Object.keys(a.attributes || {}).reduce(function(N, H) {
    var Z = a.attributes[H];
    switch (H) {
      case "class":
        N.attrs.className = Z, delete a.attributes.class;
        break;
      case "style":
        N.attrs.style = Xbe(Z);
        break;
      default:
        H.indexOf("aria-") === 0 || H.indexOf("data-") === 0 ? N.attrs[H.toLowerCase()] = Z : N.attrs[yfe(H)] = Z;
    }
    return N;
  }, {
    attrs: {}
  }), x = c.style, k = x === void 0 ? {} : x, A = bfe(c, Kbe);
  return g.attrs.style = O2(O2({}, g.attrs.style), k), o.apply(void 0, [a.tag, O2(O2({}, g.attrs), A)].concat(Bne(f)));
}
var wfe = !1;
try {
  wfe = !0;
} catch {
}
function Qbe() {
  if (!wfe && console && typeof console.error == "function") {
    var o;
    (o = console).error.apply(o, arguments);
  }
}
function _le(o) {
  if (o && bV(o) === "object" && o.prefix && o.iconName && o.icon)
    return o;
  if (Fne.icon)
    return Fne.icon(o);
  if (o === null)
    return null;
  if (o && bV(o) === "object" && o.prefix && o.iconName)
    return o;
  if (Array.isArray(o) && o.length === 2)
    return {
      prefix: o[0],
      iconName: o[1]
    };
  if (typeof o == "string")
    return {
      prefix: "fas",
      iconName: o
    };
}
function pte(o, a) {
  return Array.isArray(a) && a.length > 0 || !Array.isArray(a) && a ? _4({}, o, a) : {};
}
var Jbe = ["forwardedRef"];
function LI(o) {
  var a = o.forwardedRef, c = bfe(o, Jbe), f = c.icon, g = c.mask, x = c.symbol, k = c.className, A = c.title, N = c.titleId, H = c.maskId, Z = _le(f), K = pte("classes", [].concat(Bne(Gbe(c)), Bne(k.split(" ")))), J = pte("transform", typeof c.transform == "string" ? Fne.transform(c.transform) : c.transform), pe = pte("mask", _le(g)), Se = zbe(Z, O2(O2(O2(O2({}, K), J), pe), {}, {
    symbol: x,
    title: A,
    titleId: N,
    maskId: H
  }));
  if (!Se)
    return Qbe("Could not find icon", Z), null;
  var be = Se.abstract, ye = {
    ref: a
  };
  return Object.keys(c).forEach(function(re) {
    LI.defaultProps.hasOwnProperty(re) || (ye[re] = c[re]);
  }), e1e(be[0], ye);
}
LI.displayName = "FontAwesomeIcon";
LI.propTypes = {
  beat: ce.bool,
  border: ce.bool,
  beatFade: ce.bool,
  bounce: ce.bool,
  className: ce.string,
  fade: ce.bool,
  flash: ce.bool,
  mask: ce.oneOfType([ce.object, ce.array, ce.string]),
  maskId: ce.string,
  fixedWidth: ce.bool,
  inverse: ce.bool,
  flip: ce.oneOf([!0, !1, "horizontal", "vertical", "both"]),
  icon: ce.oneOfType([ce.object, ce.array, ce.string]),
  listItem: ce.bool,
  pull: ce.oneOf(["right", "left"]),
  pulse: ce.bool,
  rotation: ce.oneOf([0, 90, 180, 270]),
  shake: ce.bool,
  size: ce.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
  spin: ce.bool,
  spinPulse: ce.bool,
  spinReverse: ce.bool,
  symbol: ce.oneOfType([ce.bool, ce.string]),
  title: ce.string,
  titleId: ce.string,
  transform: ce.oneOfType([ce.string, ce.object]),
  swapOpacity: ce.bool
};
LI.defaultProps = {
  border: !1,
  className: "",
  mask: null,
  maskId: null,
  fixedWidth: !1,
  inverse: !1,
  flip: !1,
  icon: null,
  listItem: !1,
  pull: null,
  pulse: !1,
  rotation: null,
  size: null,
  spin: !1,
  spinPulse: !1,
  spinReverse: !1,
  beat: !1,
  fade: !1,
  beatFade: !1,
  bounce: !1,
  shake: !1,
  symbol: !1,
  title: "",
  titleId: null,
  transform: null,
  swapOpacity: !1
};
var e1e = xfe.bind(null, Ve.createElement);
function Ele() {
  return tt.useState(null);
}
const Tle = (o) => !o || typeof o == "function" ? o : (a) => {
  o.current = a;
};
function t1e(o, a) {
  const c = Tle(o), f = Tle(a);
  return (g) => {
    c && c(g), f && f(g);
  };
}
function n1e(o, a) {
  return tt.useMemo(() => t1e(o, a), [o, a]);
}
var _m = "top", Lh = "bottom", $h = "right", Em = "left", Cse = "auto", $I = [_m, Lh, $h, Em], G4 = "start", wI = "end", o1e = "clippingParents", Cfe = "viewport", R5 = "popper", s1e = "reference", Ale = /* @__PURE__ */ $I.reduce(function(o, a) {
  return o.concat([a + "-" + G4, a + "-" + wI]);
}, []), Sse = /* @__PURE__ */ [].concat($I, [Cse]).reduce(function(o, a) {
  return o.concat([a, a + "-" + G4, a + "-" + wI]);
}, []), r1e = "beforeRead", a1e = "read", i1e = "afterRead", l1e = "beforeMain", c1e = "main", u1e = "afterMain", d1e = "beforeWrite", f1e = "write", m1e = "afterWrite", p1e = [r1e, a1e, i1e, l1e, c1e, u1e, d1e, f1e, m1e];
function Bb(o) {
  return o.split("-")[0];
}
function hp(o) {
  if (o == null)
    return window;
  if (o.toString() !== "[object Window]") {
    var a = o.ownerDocument;
    return a && a.defaultView || window;
  }
  return o;
}
function Xk(o) {
  var a = hp(o).Element;
  return o instanceof a || o instanceof Element;
}
function Ih(o) {
  var a = hp(o).HTMLElement;
  return o instanceof a || o instanceof HTMLElement;
}
function kse(o) {
  if (typeof ShadowRoot > "u")
    return !1;
  var a = hp(o).ShadowRoot;
  return o instanceof a || o instanceof ShadowRoot;
}
var zk = Math.max, yV = Math.min, q4 = Math.round;
function $ne() {
  var o = navigator.userAgentData;
  return o != null && o.brands && Array.isArray(o.brands) ? o.brands.map(function(a) {
    return a.brand + "/" + a.version;
  }).join(" ") : navigator.userAgent;
}
function Sfe() {
  return !/^((?!chrome|android).)*safari/i.test($ne());
}
function K4(o, a, c) {
  a === void 0 && (a = !1), c === void 0 && (c = !1);
  var f = o.getBoundingClientRect(), g = 1, x = 1;
  a && Ih(o) && (g = o.offsetWidth > 0 && q4(f.width) / o.offsetWidth || 1, x = o.offsetHeight > 0 && q4(f.height) / o.offsetHeight || 1);
  var k = Xk(o) ? hp(o) : window, A = k.visualViewport, N = !Sfe() && c, H = (f.left + (N && A ? A.offsetLeft : 0)) / g, Z = (f.top + (N && A ? A.offsetTop : 0)) / x, K = f.width / g, J = f.height / x;
  return {
    width: K,
    height: J,
    top: Z,
    right: H + K,
    bottom: Z + J,
    left: H,
    x: H,
    y: Z
  };
}
function _se(o) {
  var a = K4(o), c = o.offsetWidth, f = o.offsetHeight;
  return Math.abs(a.width - c) <= 1 && (c = a.width), Math.abs(a.height - f) <= 1 && (f = a.height), {
    x: o.offsetLeft,
    y: o.offsetTop,
    width: c,
    height: f
  };
}
function kfe(o, a) {
  var c = a.getRootNode && a.getRootNode();
  if (o.contains(a))
    return !0;
  if (c && kse(c)) {
    var f = a;
    do {
      if (f && o.isSameNode(f))
        return !0;
      f = f.parentNode || f.host;
    } while (f);
  }
  return !1;
}
function Lb(o) {
  return o ? (o.nodeName || "").toLowerCase() : null;
}
function U0(o) {
  return hp(o).getComputedStyle(o);
}
function h1e(o) {
  return ["table", "td", "th"].indexOf(Lb(o)) >= 0;
}
function K2(o) {
  return ((Xk(o) ? o.ownerDocument : (
    // $FlowFixMe[prop-missing]
    o.document
  )) || window.document).documentElement;
}
function ZV(o) {
  return Lb(o) === "html" ? o : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    o.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    o.parentNode || // DOM Element detected
    (kse(o) ? o.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    K2(o)
  );
}
function Ole(o) {
  return !Ih(o) || // https://github.com/popperjs/popper-core/issues/837
  U0(o).position === "fixed" ? null : o.offsetParent;
}
function g1e(o) {
  var a = /firefox/i.test($ne()), c = /Trident/i.test($ne());
  if (c && Ih(o)) {
    var f = U0(o);
    if (f.position === "fixed")
      return null;
  }
  var g = ZV(o);
  for (kse(g) && (g = g.host); Ih(g) && ["html", "body"].indexOf(Lb(g)) < 0; ) {
    var x = U0(g);
    if (x.transform !== "none" || x.perspective !== "none" || x.contain === "paint" || ["transform", "perspective"].indexOf(x.willChange) !== -1 || a && x.willChange === "filter" || a && x.filter && x.filter !== "none")
      return g;
    g = g.parentNode;
  }
  return null;
}
function HI(o) {
  for (var a = hp(o), c = Ole(o); c && h1e(c) && U0(c).position === "static"; )
    c = Ole(c);
  return c && (Lb(c) === "html" || Lb(c) === "body" && U0(c).position === "static") ? a : c || g1e(o) || a;
}
function Ese(o) {
  return ["top", "bottom"].indexOf(o) >= 0 ? "x" : "y";
}
function Y5(o, a, c) {
  return zk(o, yV(a, c));
}
function v1e(o, a, c) {
  var f = Y5(o, a, c);
  return f > c ? c : f;
}
function _fe() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function Efe(o) {
  return Object.assign({}, _fe(), o);
}
function Tfe(o, a) {
  return a.reduce(function(c, f) {
    return c[f] = o, c;
  }, {});
}
var b1e = function(a, c) {
  return a = typeof a == "function" ? a(Object.assign({}, c.rects, {
    placement: c.placement
  })) : a, Efe(typeof a != "number" ? a : Tfe(a, $I));
};
function y1e(o) {
  var a, c = o.state, f = o.name, g = o.options, x = c.elements.arrow, k = c.modifiersData.popperOffsets, A = Bb(c.placement), N = Ese(A), H = [Em, $h].indexOf(A) >= 0, Z = H ? "height" : "width";
  if (!(!x || !k)) {
    var K = b1e(g.padding, c), J = _se(x), pe = N === "y" ? _m : Em, Se = N === "y" ? Lh : $h, be = c.rects.reference[Z] + c.rects.reference[N] - k[N] - c.rects.popper[Z], ye = k[N] - c.rects.reference[N], re = HI(x), oe = re ? N === "y" ? re.clientHeight || 0 : re.clientWidth || 0 : 0, U = be / 2 - ye / 2, ve = K[pe], Ze = oe - J[Z] - K[Se], rt = oe / 2 - J[Z] / 2 + U, ee = Y5(ve, rt, Ze), lt = N;
    c.modifiersData[f] = (a = {}, a[lt] = ee, a.centerOffset = ee - rt, a);
  }
}
function x1e(o) {
  var a = o.state, c = o.options, f = c.element, g = f === void 0 ? "[data-popper-arrow]" : f;
  g != null && (typeof g == "string" && (g = a.elements.popper.querySelector(g), !g) || kfe(a.elements.popper, g) && (a.elements.arrow = g));
}
const Afe = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: y1e,
  effect: x1e,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Y4(o) {
  return o.split("-")[1];
}
var w1e = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function C1e(o, a) {
  var c = o.x, f = o.y, g = a.devicePixelRatio || 1;
  return {
    x: q4(c * g) / g || 0,
    y: q4(f * g) / g || 0
  };
}
function Dle(o) {
  var a, c = o.popper, f = o.popperRect, g = o.placement, x = o.variation, k = o.offsets, A = o.position, N = o.gpuAcceleration, H = o.adaptive, Z = o.roundOffsets, K = o.isFixed, J = k.x, pe = J === void 0 ? 0 : J, Se = k.y, be = Se === void 0 ? 0 : Se, ye = typeof Z == "function" ? Z({
    x: pe,
    y: be
  }) : {
    x: pe,
    y: be
  };
  pe = ye.x, be = ye.y;
  var re = k.hasOwnProperty("x"), oe = k.hasOwnProperty("y"), U = Em, ve = _m, Ze = window;
  if (H) {
    var rt = HI(c), ee = "clientHeight", lt = "clientWidth";
    if (rt === hp(c) && (rt = K2(c), U0(rt).position !== "static" && A === "absolute" && (ee = "scrollHeight", lt = "scrollWidth")), rt = rt, g === _m || (g === Em || g === $h) && x === wI) {
      ve = Lh;
      var wt = K && rt === Ze && Ze.visualViewport ? Ze.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        rt[ee]
      );
      be -= wt - f.height, be *= N ? 1 : -1;
    }
    if (g === Em || (g === _m || g === Lh) && x === wI) {
      U = $h;
      var Vt = K && rt === Ze && Ze.visualViewport ? Ze.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        rt[lt]
      );
      pe -= Vt - f.width, pe *= N ? 1 : -1;
    }
  }
  var Ue = Object.assign({
    position: A
  }, H && w1e), Ce = Z === !0 ? C1e({
    x: pe,
    y: be
  }, hp(c)) : {
    x: pe,
    y: be
  };
  if (pe = Ce.x, be = Ce.y, N) {
    var Rn;
    return Object.assign({}, Ue, (Rn = {}, Rn[ve] = oe ? "0" : "", Rn[U] = re ? "0" : "", Rn.transform = (Ze.devicePixelRatio || 1) <= 1 ? "translate(" + pe + "px, " + be + "px)" : "translate3d(" + pe + "px, " + be + "px, 0)", Rn));
  }
  return Object.assign({}, Ue, (a = {}, a[ve] = oe ? be + "px" : "", a[U] = re ? pe + "px" : "", a.transform = "", a));
}
function S1e(o) {
  var a = o.state, c = o.options, f = c.gpuAcceleration, g = f === void 0 ? !0 : f, x = c.adaptive, k = x === void 0 ? !0 : x, A = c.roundOffsets, N = A === void 0 ? !0 : A, H = {
    placement: Bb(a.placement),
    variation: Y4(a.placement),
    popper: a.elements.popper,
    popperRect: a.rects.popper,
    gpuAcceleration: g,
    isFixed: a.options.strategy === "fixed"
  };
  a.modifiersData.popperOffsets != null && (a.styles.popper = Object.assign({}, a.styles.popper, Dle(Object.assign({}, H, {
    offsets: a.modifiersData.popperOffsets,
    position: a.options.strategy,
    adaptive: k,
    roundOffsets: N
  })))), a.modifiersData.arrow != null && (a.styles.arrow = Object.assign({}, a.styles.arrow, Dle(Object.assign({}, H, {
    offsets: a.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: N
  })))), a.attributes.popper = Object.assign({}, a.attributes.popper, {
    "data-popper-placement": a.placement
  });
}
const Ofe = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: S1e,
  data: {}
};
var v9 = {
  passive: !0
};
function k1e(o) {
  var a = o.state, c = o.instance, f = o.options, g = f.scroll, x = g === void 0 ? !0 : g, k = f.resize, A = k === void 0 ? !0 : k, N = hp(a.elements.popper), H = [].concat(a.scrollParents.reference, a.scrollParents.popper);
  return x && H.forEach(function(Z) {
    Z.addEventListener("scroll", c.update, v9);
  }), A && N.addEventListener("resize", c.update, v9), function() {
    x && H.forEach(function(Z) {
      Z.removeEventListener("scroll", c.update, v9);
    }), A && N.removeEventListener("resize", c.update, v9);
  };
}
const Dfe = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: k1e,
  data: {}
};
var _1e = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function H9(o) {
  return o.replace(/left|right|bottom|top/g, function(a) {
    return _1e[a];
  });
}
var E1e = {
  start: "end",
  end: "start"
};
function Rle(o) {
  return o.replace(/start|end/g, function(a) {
    return E1e[a];
  });
}
function Tse(o) {
  var a = hp(o), c = a.pageXOffset, f = a.pageYOffset;
  return {
    scrollLeft: c,
    scrollTop: f
  };
}
function Ase(o) {
  return K4(K2(o)).left + Tse(o).scrollLeft;
}
function T1e(o, a) {
  var c = hp(o), f = K2(o), g = c.visualViewport, x = f.clientWidth, k = f.clientHeight, A = 0, N = 0;
  if (g) {
    x = g.width, k = g.height;
    var H = Sfe();
    (H || !H && a === "fixed") && (A = g.offsetLeft, N = g.offsetTop);
  }
  return {
    width: x,
    height: k,
    x: A + Ase(o),
    y: N
  };
}
function A1e(o) {
  var a, c = K2(o), f = Tse(o), g = (a = o.ownerDocument) == null ? void 0 : a.body, x = zk(c.scrollWidth, c.clientWidth, g ? g.scrollWidth : 0, g ? g.clientWidth : 0), k = zk(c.scrollHeight, c.clientHeight, g ? g.scrollHeight : 0, g ? g.clientHeight : 0), A = -f.scrollLeft + Ase(o), N = -f.scrollTop;
  return U0(g || c).direction === "rtl" && (A += zk(c.clientWidth, g ? g.clientWidth : 0) - x), {
    width: x,
    height: k,
    x: A,
    y: N
  };
}
function Ose(o) {
  var a = U0(o), c = a.overflow, f = a.overflowX, g = a.overflowY;
  return /auto|scroll|overlay|hidden/.test(c + g + f);
}
function Rfe(o) {
  return ["html", "body", "#document"].indexOf(Lb(o)) >= 0 ? o.ownerDocument.body : Ih(o) && Ose(o) ? o : Rfe(ZV(o));
}
function X5(o, a) {
  var c;
  a === void 0 && (a = []);
  var f = Rfe(o), g = f === ((c = o.ownerDocument) == null ? void 0 : c.body), x = hp(f), k = g ? [x].concat(x.visualViewport || [], Ose(f) ? f : []) : f, A = a.concat(k);
  return g ? A : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    A.concat(X5(ZV(k)))
  );
}
function Hne(o) {
  return Object.assign({}, o, {
    left: o.x,
    top: o.y,
    right: o.x + o.width,
    bottom: o.y + o.height
  });
}
function O1e(o, a) {
  var c = K4(o, !1, a === "fixed");
  return c.top = c.top + o.clientTop, c.left = c.left + o.clientLeft, c.bottom = c.top + o.clientHeight, c.right = c.left + o.clientWidth, c.width = o.clientWidth, c.height = o.clientHeight, c.x = c.left, c.y = c.top, c;
}
function Nle(o, a, c) {
  return a === Cfe ? Hne(T1e(o, c)) : Xk(a) ? O1e(a, c) : Hne(A1e(K2(o)));
}
function D1e(o) {
  var a = X5(ZV(o)), c = ["absolute", "fixed"].indexOf(U0(o).position) >= 0, f = c && Ih(o) ? HI(o) : o;
  return Xk(f) ? a.filter(function(g) {
    return Xk(g) && kfe(g, f) && Lb(g) !== "body";
  }) : [];
}
function R1e(o, a, c, f) {
  var g = a === "clippingParents" ? D1e(o) : [].concat(a), x = [].concat(g, [c]), k = x[0], A = x.reduce(function(N, H) {
    var Z = Nle(o, H, f);
    return N.top = zk(Z.top, N.top), N.right = yV(Z.right, N.right), N.bottom = yV(Z.bottom, N.bottom), N.left = zk(Z.left, N.left), N;
  }, Nle(o, k, f));
  return A.width = A.right - A.left, A.height = A.bottom - A.top, A.x = A.left, A.y = A.top, A;
}
function Nfe(o) {
  var a = o.reference, c = o.element, f = o.placement, g = f ? Bb(f) : null, x = f ? Y4(f) : null, k = a.x + a.width / 2 - c.width / 2, A = a.y + a.height / 2 - c.height / 2, N;
  switch (g) {
    case _m:
      N = {
        x: k,
        y: a.y - c.height
      };
      break;
    case Lh:
      N = {
        x: k,
        y: a.y + a.height
      };
      break;
    case $h:
      N = {
        x: a.x + a.width,
        y: A
      };
      break;
    case Em:
      N = {
        x: a.x - c.width,
        y: A
      };
      break;
    default:
      N = {
        x: a.x,
        y: a.y
      };
  }
  var H = g ? Ese(g) : null;
  if (H != null) {
    var Z = H === "y" ? "height" : "width";
    switch (x) {
      case G4:
        N[H] = N[H] - (a[Z] / 2 - c[Z] / 2);
        break;
      case wI:
        N[H] = N[H] + (a[Z] / 2 - c[Z] / 2);
        break;
    }
  }
  return N;
}
function CI(o, a) {
  a === void 0 && (a = {});
  var c = a, f = c.placement, g = f === void 0 ? o.placement : f, x = c.strategy, k = x === void 0 ? o.strategy : x, A = c.boundary, N = A === void 0 ? o1e : A, H = c.rootBoundary, Z = H === void 0 ? Cfe : H, K = c.elementContext, J = K === void 0 ? R5 : K, pe = c.altBoundary, Se = pe === void 0 ? !1 : pe, be = c.padding, ye = be === void 0 ? 0 : be, re = Efe(typeof ye != "number" ? ye : Tfe(ye, $I)), oe = J === R5 ? s1e : R5, U = o.rects.popper, ve = o.elements[Se ? oe : J], Ze = R1e(Xk(ve) ? ve : ve.contextElement || K2(o.elements.popper), N, Z, k), rt = K4(o.elements.reference), ee = Nfe({
    reference: rt,
    element: U,
    strategy: "absolute",
    placement: g
  }), lt = Hne(Object.assign({}, U, ee)), wt = J === R5 ? lt : rt, Vt = {
    top: Ze.top - wt.top + re.top,
    bottom: wt.bottom - Ze.bottom + re.bottom,
    left: Ze.left - wt.left + re.left,
    right: wt.right - Ze.right + re.right
  }, Ue = o.modifiersData.offset;
  if (J === R5 && Ue) {
    var Ce = Ue[g];
    Object.keys(Vt).forEach(function(Rn) {
      var _t = [$h, Lh].indexOf(Rn) >= 0 ? 1 : -1, ot = [_m, Lh].indexOf(Rn) >= 0 ? "y" : "x";
      Vt[Rn] += Ce[ot] * _t;
    });
  }
  return Vt;
}
function N1e(o, a) {
  a === void 0 && (a = {});
  var c = a, f = c.placement, g = c.boundary, x = c.rootBoundary, k = c.padding, A = c.flipVariations, N = c.allowedAutoPlacements, H = N === void 0 ? Sse : N, Z = Y4(f), K = Z ? A ? Ale : Ale.filter(function(Se) {
    return Y4(Se) === Z;
  }) : $I, J = K.filter(function(Se) {
    return H.indexOf(Se) >= 0;
  });
  J.length === 0 && (J = K);
  var pe = J.reduce(function(Se, be) {
    return Se[be] = CI(o, {
      placement: be,
      boundary: g,
      rootBoundary: x,
      padding: k
    })[Bb(be)], Se;
  }, {});
  return Object.keys(pe).sort(function(Se, be) {
    return pe[Se] - pe[be];
  });
}
function P1e(o) {
  if (Bb(o) === Cse)
    return [];
  var a = H9(o);
  return [Rle(o), a, Rle(a)];
}
function M1e(o) {
  var a = o.state, c = o.options, f = o.name;
  if (!a.modifiersData[f]._skip) {
    for (var g = c.mainAxis, x = g === void 0 ? !0 : g, k = c.altAxis, A = k === void 0 ? !0 : k, N = c.fallbackPlacements, H = c.padding, Z = c.boundary, K = c.rootBoundary, J = c.altBoundary, pe = c.flipVariations, Se = pe === void 0 ? !0 : pe, be = c.allowedAutoPlacements, ye = a.options.placement, re = Bb(ye), oe = re === ye, U = N || (oe || !Se ? [H9(ye)] : P1e(ye)), ve = [ye].concat(U).reduce(function(Rt, Cn) {
      return Rt.concat(Bb(Cn) === Cse ? N1e(a, {
        placement: Cn,
        boundary: Z,
        rootBoundary: K,
        padding: H,
        flipVariations: Se,
        allowedAutoPlacements: be
      }) : Cn);
    }, []), Ze = a.rects.reference, rt = a.rects.popper, ee = /* @__PURE__ */ new Map(), lt = !0, wt = ve[0], Vt = 0; Vt < ve.length; Vt++) {
      var Ue = ve[Vt], Ce = Bb(Ue), Rn = Y4(Ue) === G4, _t = [_m, Lh].indexOf(Ce) >= 0, ot = _t ? "width" : "height", B = CI(a, {
        placement: Ue,
        boundary: Z,
        rootBoundary: K,
        altBoundary: J,
        padding: H
      }), fn = _t ? Rn ? $h : Em : Rn ? Lh : _m;
      Ze[ot] > rt[ot] && (fn = H9(fn));
      var ze = H9(fn), jt = [];
      if (x && jt.push(B[Ce] <= 0), A && jt.push(B[fn] <= 0, B[ze] <= 0), jt.every(function(Rt) {
        return Rt;
      })) {
        wt = Ue, lt = !1;
        break;
      }
      ee.set(Ue, jt);
    }
    if (lt)
      for (var Tt = Se ? 3 : 1, Je = function(Cn) {
        var et = ve.find(function(xt) {
          var X = ee.get(xt);
          if (X)
            return X.slice(0, Cn).every(function(ds) {
              return ds;
            });
        });
        if (et)
          return wt = et, "break";
      }, pn = Tt; pn > 0; pn--) {
        var Ro = Je(pn);
        if (Ro === "break") break;
      }
    a.placement !== wt && (a.modifiersData[f]._skip = !0, a.placement = wt, a.reset = !0);
  }
}
const Pfe = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: M1e,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function Ple(o, a, c) {
  return c === void 0 && (c = {
    x: 0,
    y: 0
  }), {
    top: o.top - a.height - c.y,
    right: o.right - a.width + c.x,
    bottom: o.bottom - a.height + c.y,
    left: o.left - a.width - c.x
  };
}
function Mle(o) {
  return [_m, $h, Lh, Em].some(function(a) {
    return o[a] >= 0;
  });
}
function I1e(o) {
  var a = o.state, c = o.name, f = a.rects.reference, g = a.rects.popper, x = a.modifiersData.preventOverflow, k = CI(a, {
    elementContext: "reference"
  }), A = CI(a, {
    altBoundary: !0
  }), N = Ple(k, f), H = Ple(A, g, x), Z = Mle(N), K = Mle(H);
  a.modifiersData[c] = {
    referenceClippingOffsets: N,
    popperEscapeOffsets: H,
    isReferenceHidden: Z,
    hasPopperEscaped: K
  }, a.attributes.popper = Object.assign({}, a.attributes.popper, {
    "data-popper-reference-hidden": Z,
    "data-popper-escaped": K
  });
}
const Mfe = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: I1e
};
function F1e(o, a, c) {
  var f = Bb(o), g = [Em, _m].indexOf(f) >= 0 ? -1 : 1, x = typeof c == "function" ? c(Object.assign({}, a, {
    placement: o
  })) : c, k = x[0], A = x[1];
  return k = k || 0, A = (A || 0) * g, [Em, $h].indexOf(f) >= 0 ? {
    x: A,
    y: k
  } : {
    x: k,
    y: A
  };
}
function B1e(o) {
  var a = o.state, c = o.options, f = o.name, g = c.offset, x = g === void 0 ? [0, 0] : g, k = Sse.reduce(function(Z, K) {
    return Z[K] = F1e(K, a.rects, x), Z;
  }, {}), A = k[a.placement], N = A.x, H = A.y;
  a.modifiersData.popperOffsets != null && (a.modifiersData.popperOffsets.x += N, a.modifiersData.popperOffsets.y += H), a.modifiersData[f] = k;
}
const Ife = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: B1e
};
function L1e(o) {
  var a = o.state, c = o.name;
  a.modifiersData[c] = Nfe({
    reference: a.rects.reference,
    element: a.rects.popper,
    strategy: "absolute",
    placement: a.placement
  });
}
const Ffe = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: L1e,
  data: {}
};
function $1e(o) {
  return o === "x" ? "y" : "x";
}
function H1e(o) {
  var a = o.state, c = o.options, f = o.name, g = c.mainAxis, x = g === void 0 ? !0 : g, k = c.altAxis, A = k === void 0 ? !1 : k, N = c.boundary, H = c.rootBoundary, Z = c.altBoundary, K = c.padding, J = c.tether, pe = J === void 0 ? !0 : J, Se = c.tetherOffset, be = Se === void 0 ? 0 : Se, ye = CI(a, {
    boundary: N,
    rootBoundary: H,
    padding: K,
    altBoundary: Z
  }), re = Bb(a.placement), oe = Y4(a.placement), U = !oe, ve = Ese(re), Ze = $1e(ve), rt = a.modifiersData.popperOffsets, ee = a.rects.reference, lt = a.rects.popper, wt = typeof be == "function" ? be(Object.assign({}, a.rects, {
    placement: a.placement
  })) : be, Vt = typeof wt == "number" ? {
    mainAxis: wt,
    altAxis: wt
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, wt), Ue = a.modifiersData.offset ? a.modifiersData.offset[a.placement] : null, Ce = {
    x: 0,
    y: 0
  };
  if (rt) {
    if (x) {
      var Rn, _t = ve === "y" ? _m : Em, ot = ve === "y" ? Lh : $h, B = ve === "y" ? "height" : "width", fn = rt[ve], ze = fn + ye[_t], jt = fn - ye[ot], Tt = pe ? -lt[B] / 2 : 0, Je = oe === G4 ? ee[B] : lt[B], pn = oe === G4 ? -lt[B] : -ee[B], Ro = a.elements.arrow, Rt = pe && Ro ? _se(Ro) : {
        width: 0,
        height: 0
      }, Cn = a.modifiersData["arrow#persistent"] ? a.modifiersData["arrow#persistent"].padding : _fe(), et = Cn[_t], xt = Cn[ot], X = Y5(0, ee[B], Rt[B]), ds = U ? ee[B] / 2 - Tt - X - et - Vt.mainAxis : Je - X - et - Vt.mainAxis, So = U ? -ee[B] / 2 + Tt + X + xt + Vt.mainAxis : pn + X + xt + Vt.mainAxis, At = a.elements.arrow && HI(a.elements.arrow), Pt = At ? ve === "y" ? At.clientTop || 0 : At.clientLeft || 0 : 0, Hn = (Rn = Ue == null ? void 0 : Ue[ve]) != null ? Rn : 0, Nt = fn + ds - Hn - Pt, Vn = fn + So - Hn, tn = Y5(pe ? yV(ze, Nt) : ze, fn, pe ? zk(jt, Vn) : jt);
      rt[ve] = tn, Ce[ve] = tn - fn;
    }
    if (A) {
      var je, An = ve === "x" ? _m : Em, qn = ve === "x" ? Lh : $h, on = rt[Ze], zt = Ze === "y" ? "height" : "width", vt = on + ye[An], oo = on - ye[qn], Dn = [_m, Em].indexOf(re) !== -1, ao = (je = Ue == null ? void 0 : Ue[Ze]) != null ? je : 0, xs = Dn ? vt : on - ee[zt] - lt[zt] - ao + Vt.altAxis, rs = Dn ? on + ee[zt] + lt[zt] - ao - Vt.altAxis : oo, Qo = pe && Dn ? v1e(xs, on, rs) : Y5(pe ? xs : vt, on, pe ? rs : oo);
      rt[Ze] = Qo, Ce[Ze] = Qo - on;
    }
    a.modifiersData[f] = Ce;
  }
}
const Bfe = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: H1e,
  requiresIfExists: ["offset"]
};
function z1e(o) {
  return {
    scrollLeft: o.scrollLeft,
    scrollTop: o.scrollTop
  };
}
function V1e(o) {
  return o === hp(o) || !Ih(o) ? Tse(o) : z1e(o);
}
function U1e(o) {
  var a = o.getBoundingClientRect(), c = q4(a.width) / o.offsetWidth || 1, f = q4(a.height) / o.offsetHeight || 1;
  return c !== 1 || f !== 1;
}
function j1e(o, a, c) {
  c === void 0 && (c = !1);
  var f = Ih(a), g = Ih(a) && U1e(a), x = K2(a), k = K4(o, g, c), A = {
    scrollLeft: 0,
    scrollTop: 0
  }, N = {
    x: 0,
    y: 0
  };
  return (f || !f && !c) && ((Lb(a) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  Ose(x)) && (A = V1e(a)), Ih(a) ? (N = K4(a, !0), N.x += a.clientLeft, N.y += a.clientTop) : x && (N.x = Ase(x))), {
    x: k.left + A.scrollLeft - N.x,
    y: k.top + A.scrollTop - N.y,
    width: k.width,
    height: k.height
  };
}
function W1e(o) {
  var a = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Set(), f = [];
  o.forEach(function(x) {
    a.set(x.name, x);
  });
  function g(x) {
    c.add(x.name);
    var k = [].concat(x.requires || [], x.requiresIfExists || []);
    k.forEach(function(A) {
      if (!c.has(A)) {
        var N = a.get(A);
        N && g(N);
      }
    }), f.push(x);
  }
  return o.forEach(function(x) {
    c.has(x.name) || g(x);
  }), f;
}
function Z1e(o) {
  var a = W1e(o);
  return p1e.reduce(function(c, f) {
    return c.concat(a.filter(function(g) {
      return g.phase === f;
    }));
  }, []);
}
function G1e(o) {
  var a;
  return function() {
    return a || (a = new Promise(function(c) {
      Promise.resolve().then(function() {
        a = void 0, c(o());
      });
    })), a;
  };
}
function q1e(o) {
  var a = o.reduce(function(c, f) {
    var g = c[f.name];
    return c[f.name] = g ? Object.assign({}, g, f, {
      options: Object.assign({}, g.options, f.options),
      data: Object.assign({}, g.data, f.data)
    }) : f, c;
  }, {});
  return Object.keys(a).map(function(c) {
    return a[c];
  });
}
var Ile = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function Fle() {
  for (var o = arguments.length, a = new Array(o), c = 0; c < o; c++)
    a[c] = arguments[c];
  return !a.some(function(f) {
    return !(f && typeof f.getBoundingClientRect == "function");
  });
}
function Lfe(o) {
  o === void 0 && (o = {});
  var a = o, c = a.defaultModifiers, f = c === void 0 ? [] : c, g = a.defaultOptions, x = g === void 0 ? Ile : g;
  return function(A, N, H) {
    H === void 0 && (H = x);
    var Z = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, Ile, x),
      modifiersData: {},
      elements: {
        reference: A,
        popper: N
      },
      attributes: {},
      styles: {}
    }, K = [], J = !1, pe = {
      state: Z,
      setOptions: function(re) {
        var oe = typeof re == "function" ? re(Z.options) : re;
        be(), Z.options = Object.assign({}, x, Z.options, oe), Z.scrollParents = {
          reference: Xk(A) ? X5(A) : A.contextElement ? X5(A.contextElement) : [],
          popper: X5(N)
        };
        var U = Z1e(q1e([].concat(f, Z.options.modifiers)));
        return Z.orderedModifiers = U.filter(function(ve) {
          return ve.enabled;
        }), Se(), pe.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!J) {
          var re = Z.elements, oe = re.reference, U = re.popper;
          if (Fle(oe, U)) {
            Z.rects = {
              reference: j1e(oe, HI(U), Z.options.strategy === "fixed"),
              popper: _se(U)
            }, Z.reset = !1, Z.placement = Z.options.placement, Z.orderedModifiers.forEach(function(Vt) {
              return Z.modifiersData[Vt.name] = Object.assign({}, Vt.data);
            });
            for (var ve = 0; ve < Z.orderedModifiers.length; ve++) {
              if (Z.reset === !0) {
                Z.reset = !1, ve = -1;
                continue;
              }
              var Ze = Z.orderedModifiers[ve], rt = Ze.fn, ee = Ze.options, lt = ee === void 0 ? {} : ee, wt = Ze.name;
              typeof rt == "function" && (Z = rt({
                state: Z,
                options: lt,
                name: wt,
                instance: pe
              }) || Z);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: G1e(function() {
        return new Promise(function(ye) {
          pe.forceUpdate(), ye(Z);
        });
      }),
      destroy: function() {
        be(), J = !0;
      }
    };
    if (!Fle(A, N))
      return pe;
    pe.setOptions(H).then(function(ye) {
      !J && H.onFirstUpdate && H.onFirstUpdate(ye);
    });
    function Se() {
      Z.orderedModifiers.forEach(function(ye) {
        var re = ye.name, oe = ye.options, U = oe === void 0 ? {} : oe, ve = ye.effect;
        if (typeof ve == "function") {
          var Ze = ve({
            state: Z,
            name: re,
            instance: pe,
            options: U
          }), rt = function() {
          };
          K.push(Ze || rt);
        }
      });
    }
    function be() {
      K.forEach(function(ye) {
        return ye();
      }), K = [];
    }
    return pe;
  };
}
var K1e = Lfe({
  defaultModifiers: [Mfe, Ffe, Ofe, Dfe, Ife, Pfe, Bfe, Afe]
});
function $fe() {
  const o = tt.useRef(!0), a = tt.useRef(() => o.current);
  return tt.useEffect(() => (o.current = !0, () => {
    o.current = !1;
  }), []), a.current;
}
function Y1e(o) {
  const a = $fe();
  return [o[0], tt.useCallback((c) => {
    if (a())
      return o[1](c);
  }, [a, o[1]])];
}
var Ble = function(a) {
  return {
    position: a,
    top: "0",
    left: "0",
    opacity: "0",
    pointerEvents: "none"
  };
}, X1e = {
  name: "applyStyles",
  enabled: !1
}, Q1e = {
  name: "ariaDescribedBy",
  enabled: !0,
  phase: "afterWrite",
  effect: function(a) {
    var c = a.state;
    return function() {
      var f = c.elements, g = f.reference, x = f.popper;
      if ("removeAttribute" in g) {
        var k = (g.getAttribute("aria-describedby") || "").split(",").filter(function(A) {
          return A.trim() !== x.id;
        });
        k.length ? g.setAttribute("aria-describedby", k.join(",")) : g.removeAttribute("aria-describedby");
      }
    };
  },
  fn: function(a) {
    var c, f = a.state, g = f.elements, x = g.popper, k = g.reference, A = (c = x.getAttribute("role")) == null ? void 0 : c.toLowerCase();
    if (x.id && A === "tooltip" && "setAttribute" in k) {
      var N = k.getAttribute("aria-describedby");
      if (N && N.split(",").indexOf(x.id) !== -1)
        return;
      k.setAttribute("aria-describedby", N ? N + "," + x.id : x.id);
    }
  }
}, J1e = [];
function e0e(o, a, c) {
  var f = c === void 0 ? {} : c, g = f.enabled, x = g === void 0 ? !0 : g, k = f.placement, A = k === void 0 ? "bottom" : k, N = f.strategy, H = N === void 0 ? "absolute" : N, Z = f.modifiers, K = Z === void 0 ? J1e : Z, J = Ei(f, ["enabled", "placement", "strategy", "modifiers"]), pe = tt.useRef(), Se = tt.useCallback(function() {
    var ve;
    (ve = pe.current) == null || ve.update();
  }, []), be = tt.useCallback(function() {
    var ve;
    (ve = pe.current) == null || ve.forceUpdate();
  }, []), ye = Y1e(tt.useState({
    placement: A,
    update: Se,
    forceUpdate: be,
    attributes: {},
    styles: {
      popper: Ble(H),
      arrow: {}
    }
  })), re = ye[0], oe = ye[1], U = tt.useMemo(function() {
    return {
      name: "updateStateModifier",
      enabled: !0,
      phase: "write",
      requires: ["computeStyles"],
      fn: function(Ze) {
        var rt = Ze.state, ee = {}, lt = {};
        Object.keys(rt.elements).forEach(function(wt) {
          ee[wt] = rt.styles[wt], lt[wt] = rt.attributes[wt];
        }), oe({
          state: rt,
          styles: ee,
          attributes: lt,
          update: Se,
          forceUpdate: be,
          placement: rt.placement
        });
      }
    };
  }, [Se, be, oe]);
  return tt.useEffect(function() {
    !pe.current || !x || pe.current.setOptions({
      placement: A,
      strategy: H,
      modifiers: [].concat(K, [U, X1e])
    });
  }, [H, A, U, x]), tt.useEffect(function() {
    if (!(!x || o == null || a == null))
      return pe.current = K1e(o, a, Zs({}, J, {
        placement: A,
        strategy: H,
        modifiers: [].concat(K, [Q1e, U])
      })), function() {
        pe.current != null && (pe.current.destroy(), pe.current = void 0, oe(function(ve) {
          return Zs({}, ve, {
            attributes: {},
            styles: {
              popper: Ble(H)
            }
          });
        }));
      };
  }, [x, o, a]), re;
}
function Hfe(o, a) {
  if (o.contains) return o.contains(a);
  if (o.compareDocumentPosition) return o === a || !!(o.compareDocumentPosition(a) & 16);
}
const t0e = !!(typeof window < "u" && window.document && window.document.createElement);
var zne = !1, Vne = !1;
try {
  var hte = {
    get passive() {
      return zne = !0;
    },
    get once() {
      return Vne = zne = !0;
    }
  };
  t0e && (window.addEventListener("test", hte, hte), window.removeEventListener("test", hte, !0));
} catch {
}
function n0e(o, a, c, f) {
  if (f && typeof f != "boolean" && !Vne) {
    var g = f.once, x = f.capture, k = c;
    !Vne && g && (k = c.__once || function A(N) {
      this.removeEventListener(a, A, x), c.call(this, N);
    }, c.__once = k), o.addEventListener(a, k, zne ? f : x);
  }
  o.addEventListener(a, c, f);
}
function o0e(o, a, c, f) {
  var g = f && typeof f != "boolean" ? f.capture : f;
  o.removeEventListener(a, c, g), c.__once && o.removeEventListener(a, c.__once, g);
}
function E4(o, a, c, f) {
  return n0e(o, a, c, f), function() {
    o0e(o, a, c, f);
  };
}
function s0e(o) {
  const a = tt.useRef(o);
  return tt.useEffect(() => {
    a.current = o;
  }, [o]), a;
}
function Lle(o) {
  const a = s0e(o);
  return tt.useCallback(function(...c) {
    return a.current && a.current(...c);
  }, [a]);
}
var r0e = function() {
}, a0e = r0e;
const i0e = /* @__PURE__ */ eO(a0e);
function Dse(o) {
  return o && o.ownerDocument || document;
}
function xV(o) {
  return o && "setState" in o ? Mk.findDOMNode(o) : o ?? null;
}
const l0e = function(o) {
  return Dse(xV(o));
};
var c0e = 27, $le = function() {
};
function u0e(o) {
  return o.button === 0;
}
function d0e(o) {
  return !!(o.metaKey || o.altKey || o.ctrlKey || o.shiftKey);
}
var Hle = function(a) {
  return a && ("current" in a ? a.current : a);
};
function f0e(o, a, c) {
  var f = c === void 0 ? {} : c, g = f.disabled, x = f.clickTrigger, k = x === void 0 ? "click" : x, A = tt.useRef(!1), N = a || $le, H = tt.useCallback(function(J) {
    var pe, Se = Hle(o);
    i0e(!!Se, "RootClose captured a close event but does not have a ref to compare it to. useRootClose(), should be passed a ref that resolves to a DOM node"), A.current = !Se || d0e(J) || !u0e(J) || !!Hfe(Se, (pe = J.composedPath == null ? void 0 : J.composedPath()[0]) != null ? pe : J.target);
  }, [o]), Z = Lle(function(J) {
    A.current || N(J);
  }), K = Lle(function(J) {
    J.keyCode === c0e && N(J);
  });
  tt.useEffect(function() {
    if (!(g || o == null)) {
      var J = window.event, pe = l0e(Hle(o)), Se = E4(pe, k, H, !0), be = E4(pe, k, function(oe) {
        if (oe === J) {
          J = void 0;
          return;
        }
        Z(oe);
      }), ye = E4(pe, "keyup", function(oe) {
        if (oe === J) {
          J = void 0;
          return;
        }
        K(oe);
      }), re = [];
      return "ontouchstart" in pe.documentElement && (re = [].slice.call(pe.body.children).map(function(oe) {
        return E4(oe, "mousemove", $le);
      })), function() {
        Se(), be(), ye(), re.forEach(function(oe) {
          return oe();
        });
      };
    }
  }, [o, g, k, H, Z, K]);
}
var gte = function(a) {
  var c;
  return typeof document > "u" ? null : a == null ? Dse().body : (typeof a == "function" && (a = a()), a && "current" in a && (a = a.current), (c = a) != null && c.nodeType && a || null);
};
function zle(o, a) {
  var c = tt.useState(function() {
    return gte(o);
  }), f = c[0], g = c[1];
  if (!f) {
    var x = gte(o);
    x && g(x);
  }
  return tt.useEffect(function() {
  }, [a, f]), tt.useEffect(function() {
    var k = gte(o);
    k !== f && g(k);
  }, [o, f]), f;
}
function m0e(o) {
  var a = {};
  return Array.isArray(o) ? (o == null || o.forEach(function(c) {
    a[c.name] = c;
  }), a) : o || a;
}
function p0e(o) {
  return o === void 0 && (o = {}), Array.isArray(o) ? o : Object.keys(o).map(function(a) {
    return o[a].name = a, o[a];
  });
}
function h0e(o) {
  var a, c, f, g, x = o.enabled, k = o.enableEvents, A = o.placement, N = o.flip, H = o.offset, Z = o.fixed, K = o.containerPadding, J = o.arrowElement, pe = o.popperConfig, Se = pe === void 0 ? {} : pe, be = m0e(Se.modifiers);
  return Zs({}, Se, {
    placement: A,
    enabled: x,
    strategy: Z ? "fixed" : Se.strategy,
    modifiers: p0e(Zs({}, be, {
      eventListeners: {
        enabled: k
      },
      preventOverflow: Zs({}, be.preventOverflow, {
        options: K ? Zs({
          padding: K
        }, (a = be.preventOverflow) == null ? void 0 : a.options) : (c = be.preventOverflow) == null ? void 0 : c.options
      }),
      offset: {
        options: Zs({
          offset: H
        }, (f = be.offset) == null ? void 0 : f.options)
      },
      arrow: Zs({}, be.arrow, {
        enabled: !!J,
        options: Zs({}, (g = be.arrow) == null ? void 0 : g.options, {
          element: J
        })
      }),
      flip: Zs({
        enabled: !!N
      }, be.flip)
    }))
  });
}
var Rse = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  var c = o.flip, f = o.offset, g = o.placement, x = o.containerPadding, k = x === void 0 ? 5 : x, A = o.popperConfig, N = A === void 0 ? {} : A, H = o.transition, Z = Ele(), K = Z[0], J = Z[1], pe = Ele(), Se = pe[0], be = pe[1], ye = n1e(J, a), re = zle(o.container), oe = zle(o.target), U = tt.useState(!o.show), ve = U[0], Ze = U[1], rt = e0e(oe, K, h0e({
    placement: g,
    enableEvents: !!o.show,
    containerPadding: k || 5,
    flip: c,
    offset: f,
    arrowElement: Se,
    popperConfig: N
  })), ee = rt.styles, lt = rt.attributes, wt = Ei(rt, ["styles", "attributes"]);
  o.show ? ve && Ze(!1) : !o.transition && !ve && Ze(!0);
  var Vt = function() {
    Ze(!0), o.onExited && o.onExited.apply(o, arguments);
  }, Ue = o.show || H && !ve;
  if (f0e(K, o.onHide, {
    disabled: !o.rootClose || o.rootCloseDisabled,
    clickTrigger: o.rootCloseEvent
  }), !Ue)
    return null;
  var Ce = o.children(Zs({}, wt, {
    show: !!o.show,
    props: Zs({}, lt.popper, {
      style: ee.popper,
      ref: ye
    }),
    arrowProps: Zs({}, lt.arrow, {
      style: ee.arrow,
      ref: be
    })
  }));
  if (H) {
    var Rn = o.onExit, _t = o.onExiting, ot = o.onEnter, B = o.onEntering, fn = o.onEntered;
    Ce = /* @__PURE__ */ Ve.createElement(H, {
      in: o.show,
      appear: !0,
      onExit: Rn,
      onExiting: _t,
      onExited: Vt,
      onEnter: ot,
      onEntering: B,
      onEntered: fn
    }, Ce);
  }
  return re ? /* @__PURE__ */ Mk.createPortal(Ce, re) : null;
});
Rse.displayName = "Overlay";
Rse.propTypes = {
  /**
   * Set the visibility of the Overlay
   */
  show: ce.bool,
  /** Specify where the overlay element is positioned in relation to the target element */
  placement: ce.oneOf(Sse),
  /**
   * A DOM Element, Ref to an element, or function that returns either. The `target` element is where
   * the overlay is positioned relative to.
   */
  target: ce.any,
  /**
   * A DOM Element, Ref to an element, or function that returns either. The `container` will have the Portal children
   * appended to it.
   */
  container: ce.any,
  /**
   * Enables the Popper.js `flip` modifier, allowing the Overlay to
   * automatically adjust it's placement in case of overlap with the viewport or toggle.
   * Refer to the [flip docs](https://popper.js.org/popper-documentation.html#modifiers..flip.enabled) for more info
   */
  flip: ce.bool,
  /**
   * A render prop that returns an element to overlay and position. See
   * the [react-popper documentation](https://github.com/FezVrasta/react-popper#children) for more info.
   *
   * @type {Function ({
   *   show: boolean,
   *   placement: Placement,
   *   update: () => void,
   *   forceUpdate: () => void,
   *   props: {
   *     ref: (?HTMLElement) => void,
   *     style: { [string]: string | number },
   *     aria-labelledby: ?string
   *     [string]: string | number,
   *   },
   *   arrowProps: {
   *     ref: (?HTMLElement) => void,
   *     style: { [string]: string | number },
   *     [string]: string | number,
   *   },
   * }) => React.Element}
   */
  children: ce.func.isRequired,
  /**
   * Control how much space there is between the edge of the boundary element and overlay.
   * A convenience shortcut to setting `popperConfig.modfiers.preventOverflow.padding`
   */
  containerPadding: ce.number,
  /**
   * A set of popper options and props passed directly to react-popper's Popper component.
   */
  popperConfig: ce.object,
  /**
   * Specify whether the overlay should trigger `onHide` when the user clicks outside the overlay
   */
  rootClose: ce.bool,
  /**
   * Specify event for toggling overlay
   */
  rootCloseEvent: ce.oneOf(["click", "mousedown"]),
  /**
   * Specify disabled for disable RootCloseWrapper
   */
  rootCloseDisabled: ce.bool,
  /**
   * A Callback fired by the Overlay when it wishes to be hidden.
   *
   * __required__ when `rootClose` is `true`.
   *
   * @type func
   */
  onHide: function(a) {
    for (var c = arguments.length, f = new Array(c > 1 ? c - 1 : 0), g = 1; g < c; g++)
      f[g - 1] = arguments[g];
    if (a.rootClose) {
      var x;
      return (x = ce.func).isRequired.apply(x, [a].concat(f));
    }
    return ce.func.apply(ce, [a].concat(f));
  },
  /**
   * A `react-transition-group@2.0.0` `<Transition/>` component
   * used to animate the overlay as it changes visibility.
   */
  // @ts-ignore
  transition: ce.elementType,
  /**
   * Callback fired before the Overlay transitions in
   */
  onEnter: ce.func,
  /**
   * Callback fired as the Overlay begins to transition in
   */
  onEntering: ce.func,
  /**
   * Callback fired after the Overlay finishes transitioning in
   */
  onEntered: ce.func,
  /**
   * Callback fired right before the Overlay transitions out
   */
  onExit: ce.func,
  /**
   * Callback fired as the Overlay begins to transition out
   */
  onExiting: ce.func,
  /**
   * Callback fired after the Overlay finishes transitioning out
   */
  onExited: ce.func
};
function vte(o, a) {
  return o.classList ? !!a && o.classList.contains(a) : (" " + (o.className.baseVal || o.className) + " ").indexOf(" " + a + " ") !== -1;
}
function bte(o) {
  var a = window.getComputedStyle(o), c = parseFloat(a.marginTop) || 0, f = parseFloat(a.marginRight) || 0, g = parseFloat(a.marginBottom) || 0, x = parseFloat(a.marginLeft) || 0;
  return {
    top: c,
    right: f,
    bottom: g,
    left: x
  };
}
function g0e() {
  var o = tt.useRef(null), a = tt.useRef(null), c = tt.useRef(null), f = Fc(void 0, "popover"), g = Fc(void 0, "dropdown-menu"), x = tt.useCallback(function(H) {
    !H || !(vte(H, f) || vte(H, g)) || (a.current = bte(H), H.style.margin = "0", o.current = H);
  }, [f, g]), k = tt.useMemo(function() {
    return {
      name: "offset",
      options: {
        offset: function(Z) {
          var K = Z.placement;
          if (!a.current) return [0, 0];
          var J = a.current, pe = J.top, Se = J.left, be = J.bottom, ye = J.right;
          switch (K.split("-")[0]) {
            case "top":
              return [0, be];
            case "left":
              return [0, ye];
            case "bottom":
              return [0, pe];
            case "right":
              return [0, Se];
            default:
              return [0, 0];
          }
        }
      }
    };
  }, [a]), A = tt.useMemo(function() {
    return {
      name: "arrow",
      options: {
        padding: function() {
          if (!c.current)
            return 0;
          var Z = c.current, K = Z.top, J = Z.right, pe = K || J;
          return {
            top: pe,
            left: pe,
            right: pe,
            bottom: pe
          };
        }
      }
    };
  }, [c]), N = tt.useMemo(function() {
    return {
      name: "popoverArrowMargins",
      enabled: !0,
      phase: "main",
      fn: function() {
      },
      requiresIfExists: ["arrow"],
      effect: function(Z) {
        var K = Z.state;
        if (!(!o.current || !K.elements.arrow || !vte(o.current, f))) {
          if (K.modifiersData["arrow#persistent"]) {
            var J = bte(K.elements.arrow), pe = J.top, Se = J.right, be = pe || Se;
            K.modifiersData["arrow#persistent"].padding = {
              top: be,
              left: be,
              right: be,
              bottom: be
            };
          } else
            c.current = bte(K.elements.arrow);
          return K.elements.arrow.style.margin = "0", function() {
            K.elements.arrow && (K.elements.arrow.style.margin = "");
          };
        }
      }
    };
  }, [f]);
  return [x, [k, A, N]];
}
function Une(o, a) {
  return Une = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(c, f) {
    return c.__proto__ = f, c;
  }, Une(o, a);
}
function Nse(o, a) {
  o.prototype = Object.create(a.prototype), o.prototype.constructor = o, Une(o, a);
}
const Vle = {
  disabled: !1
}, zfe = Ve.createContext(null);
var v0e = function(a) {
  return a.scrollTop;
}, L5 = "unmounted", Ok = "exited", k2 = "entering", Dk = "entered", jne = "exiting", G0 = /* @__PURE__ */ function(o) {
  Nse(a, o);
  function a(f, g) {
    var x;
    x = o.call(this, f, g) || this;
    var k = g, A = k && !k.isMounting ? f.enter : f.appear, N;
    return x.appearStatus = null, f.in ? A ? (N = Ok, x.appearStatus = k2) : N = Dk : f.unmountOnExit || f.mountOnEnter ? N = L5 : N = Ok, x.state = {
      status: N
    }, x.nextCallback = null, x;
  }
  a.getDerivedStateFromProps = function(g, x) {
    var k = g.in;
    return k && x.status === L5 ? {
      status: Ok
    } : null;
  };
  var c = a.prototype;
  return c.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, c.componentDidUpdate = function(g) {
    var x = null;
    if (g !== this.props) {
      var k = this.state.status;
      this.props.in ? k !== k2 && k !== Dk && (x = k2) : (k === k2 || k === Dk) && (x = jne);
    }
    this.updateStatus(!1, x);
  }, c.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, c.getTimeouts = function() {
    var g = this.props.timeout, x, k, A;
    return x = k = A = g, g != null && typeof g != "number" && (x = g.exit, k = g.enter, A = g.appear !== void 0 ? g.appear : k), {
      exit: x,
      enter: k,
      appear: A
    };
  }, c.updateStatus = function(g, x) {
    if (g === void 0 && (g = !1), x !== null)
      if (this.cancelNextCallback(), x === k2) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var k = this.props.nodeRef ? this.props.nodeRef.current : Mk.findDOMNode(this);
          k && v0e(k);
        }
        this.performEnter(g);
      } else
        this.performExit();
    else this.props.unmountOnExit && this.state.status === Ok && this.setState({
      status: L5
    });
  }, c.performEnter = function(g) {
    var x = this, k = this.props.enter, A = this.context ? this.context.isMounting : g, N = this.props.nodeRef ? [A] : [Mk.findDOMNode(this), A], H = N[0], Z = N[1], K = this.getTimeouts(), J = A ? K.appear : K.enter;
    if (!g && !k || Vle.disabled) {
      this.safeSetState({
        status: Dk
      }, function() {
        x.props.onEntered(H);
      });
      return;
    }
    this.props.onEnter(H, Z), this.safeSetState({
      status: k2
    }, function() {
      x.props.onEntering(H, Z), x.onTransitionEnd(J, function() {
        x.safeSetState({
          status: Dk
        }, function() {
          x.props.onEntered(H, Z);
        });
      });
    });
  }, c.performExit = function() {
    var g = this, x = this.props.exit, k = this.getTimeouts(), A = this.props.nodeRef ? void 0 : Mk.findDOMNode(this);
    if (!x || Vle.disabled) {
      this.safeSetState({
        status: Ok
      }, function() {
        g.props.onExited(A);
      });
      return;
    }
    this.props.onExit(A), this.safeSetState({
      status: jne
    }, function() {
      g.props.onExiting(A), g.onTransitionEnd(k.exit, function() {
        g.safeSetState({
          status: Ok
        }, function() {
          g.props.onExited(A);
        });
      });
    });
  }, c.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, c.safeSetState = function(g, x) {
    x = this.setNextCallback(x), this.setState(g, x);
  }, c.setNextCallback = function(g) {
    var x = this, k = !0;
    return this.nextCallback = function(A) {
      k && (k = !1, x.nextCallback = null, g(A));
    }, this.nextCallback.cancel = function() {
      k = !1;
    }, this.nextCallback;
  }, c.onTransitionEnd = function(g, x) {
    this.setNextCallback(x);
    var k = this.props.nodeRef ? this.props.nodeRef.current : Mk.findDOMNode(this), A = g == null && !this.props.addEndListener;
    if (!k || A) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var N = this.props.nodeRef ? [this.nextCallback] : [k, this.nextCallback], H = N[0], Z = N[1];
      this.props.addEndListener(H, Z);
    }
    g != null && setTimeout(this.nextCallback, g);
  }, c.render = function() {
    var g = this.state.status;
    if (g === L5)
      return null;
    var x = this.props, k = x.children;
    x.in, x.mountOnEnter, x.unmountOnExit, x.appear, x.enter, x.exit, x.timeout, x.addEndListener, x.onEnter, x.onEntering, x.onEntered, x.onExit, x.onExiting, x.onExited, x.nodeRef;
    var A = Ei(x, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ Ve.createElement(zfe.Provider, {
        value: null
      }, typeof k == "function" ? k(g, A) : Ve.cloneElement(Ve.Children.only(k), A))
    );
  }, a;
}(Ve.Component);
G0.contextType = zfe;
G0.propTypes = {};
function i4() {
}
G0.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: i4,
  onEntering: i4,
  onEntered: i4,
  onExit: i4,
  onExiting: i4,
  onExited: i4
};
G0.UNMOUNTED = L5;
G0.EXITED = Ok;
G0.ENTERING = k2;
G0.ENTERED = Dk;
G0.EXITING = jne;
const b0e = G0;
function y0e(o) {
  var a = Dse(o);
  return a && a.defaultView || window;
}
function x0e(o, a) {
  return y0e(o).getComputedStyle(o, a);
}
var w0e = /([A-Z])/g;
function C0e(o) {
  return o.replace(w0e, "-$1").toLowerCase();
}
var S0e = /^ms-/;
function b9(o) {
  return C0e(o).replace(S0e, "-ms-");
}
var k0e = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i;
function _0e(o) {
  return !!(o && k0e.test(o));
}
function Vfe(o, a) {
  var c = "", f = "";
  if (typeof a == "string")
    return o.style.getPropertyValue(b9(a)) || x0e(o).getPropertyValue(b9(a));
  Object.keys(a).forEach(function(g) {
    var x = a[g];
    !x && x !== 0 ? o.style.removeProperty(b9(g)) : _0e(g) ? f += g + "(" + x + ") " : c += b9(g) + ": " + x + ";";
  }), f && (c += "transform: " + f + ";"), o.style.cssText += ";" + c;
}
function E0e(o, a, c, f) {
  if (f === void 0 && (f = !0), o) {
    var g = document.createEvent("HTMLEvents");
    g.initEvent(a, c, f), o.dispatchEvent(g);
  }
}
function T0e(o) {
  var a = Vfe(o, "transitionDuration") || "", c = a.indexOf("ms") === -1 ? 1e3 : 1;
  return parseFloat(a) * c;
}
function A0e(o, a, c) {
  c === void 0 && (c = 5);
  var f = !1, g = setTimeout(function() {
    f || E0e(o, "transitionend", !0);
  }, a + c), x = E4(o, "transitionend", function() {
    f = !0;
  }, {
    once: !0
  });
  return function() {
    clearTimeout(g), x();
  };
}
function O0e(o, a, c, f) {
  c == null && (c = T0e(o) || 0);
  var g = A0e(o, c, f), x = E4(o, "transitionend", a);
  return function() {
    g(), x();
  };
}
function Ule(o, a) {
  var c = Vfe(o, a) || "", f = c.indexOf("ms") === -1 ? 1e3 : 1;
  return parseFloat(c) * f;
}
function D0e(o, a) {
  var c = Ule(o, "transitionDuration"), f = Ule(o, "transitionDelay"), g = O0e(o, function(x) {
    x.target === o && (g(), a(x));
  }, c + f);
}
function R0e(o) {
  o.offsetHeight;
}
var N0e = ["className", "children"], y9, P0e = {
  in: !1,
  timeout: 300,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1
}, M0e = (y9 = {}, y9[k2] = "show", y9[Dk] = "show", y9), GV = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  var c = o.className, f = o.children, g = Ei(o, N0e), x = tt.useCallback(function(k) {
    R0e(k), g.onEnter && g.onEnter(k);
  }, [g]);
  return /* @__PURE__ */ Ve.createElement(b0e, Zs({
    ref: a,
    addEndListener: D0e
  }, g, {
    onEnter: x
  }), function(k, A) {
    return /* @__PURE__ */ Ve.cloneElement(f, Zs({}, A, {
      className: er("fade", c, f.props.className, M0e[k])
    }));
  });
});
GV.defaultProps = P0e;
GV.displayName = "Fade";
var I0e = ["children", "transition", "popperConfig"], F0e = ["props", "arrowProps", "show", "update", "forceUpdate", "placement", "state"], B0e = {
  transition: GV,
  rootClose: !1,
  show: !1,
  placement: "top"
};
function L0e(o, a) {
  var c = o.ref, f = a.ref;
  o.ref = c.__wrapped || (c.__wrapped = function(g) {
    return c(xV(g));
  }), a.ref = f.__wrapped || (f.__wrapped = function(g) {
    return f(xV(g));
  });
}
function Ufe(o) {
  var a = o.children, c = o.transition, f = o.popperConfig, g = f === void 0 ? {} : f, x = Ei(o, I0e), k = tt.useRef({}), A = g0e(), N = A[0], H = A[1], Z = c === !0 ? GV : c || null;
  return /* @__PURE__ */ Ve.createElement(Rse, Zs({}, x, {
    ref: N,
    popperConfig: Zs({}, g, {
      modifiers: H.concat(g.modifiers || [])
    }),
    transition: Z
  }), function(K) {
    var J, pe = K.props, Se = K.arrowProps, be = K.show, ye = K.update;
    K.forceUpdate;
    var re = K.placement, oe = K.state, U = Ei(K, F0e);
    L0e(pe, Se);
    var ve = Object.assign(k.current, {
      state: oe,
      scheduleUpdate: ye,
      placement: re,
      outOfBoundaries: (oe == null || (J = oe.modifiersData.hide) == null ? void 0 : J.isReferenceHidden) || !1
    });
    return typeof a == "function" ? a(Zs({}, U, pe, {
      placement: re,
      show: be
    }, !c && be && {
      className: "show"
    }, {
      popper: ve,
      arrowProps: Se
    })) : /* @__PURE__ */ Ve.cloneElement(a, Zs({}, U, pe, {
      placement: re,
      arrowProps: Se,
      popper: ve,
      className: er(a.props.className, !c && be && "show"),
      style: Zs({}, a.props.style, pe.style)
    }));
  });
}
Ufe.defaultProps = B0e;
function $0e(o) {
  const a = tt.useRef(o);
  return a.current = o, a;
}
function H0e(o) {
  const a = $0e(o);
  tt.useEffect(() => () => a.current(), []);
}
const Wne = 2 ** 31 - 1;
function jfe(o, a, c) {
  const f = c - Date.now();
  o.current = f <= Wne ? setTimeout(a, f) : setTimeout(() => jfe(o, a, c), Wne);
}
function z0e() {
  const o = $fe(), a = tt.useRef();
  return H0e(() => clearTimeout(a.current)), tt.useMemo(() => {
    const c = () => clearTimeout(a.current);
    function f(g, x = 0) {
      o() && (c(), x <= Wne ? a.current = setTimeout(g, x) : jfe(a, g, Date.now() + x));
    }
    return {
      set: f,
      clear: c,
      handleRef: a
    };
  }, []);
}
function V0e(o, a, c) {
  var f = tt.useRef(o !== void 0), g = tt.useState(a), x = g[0], k = g[1], A = o !== void 0, N = f.current;
  return f.current = A, !A && N && x !== a && k(a), [A ? o : x, tt.useCallback(function(H) {
    for (var Z = arguments.length, K = new Array(Z > 1 ? Z - 1 : 0), J = 1; J < Z; J++)
      K[J - 1] = arguments[J];
    c && c.apply(void 0, [H].concat(K)), k(H);
  }, [c])];
}
var U0e = ["trigger", "overlay", "children", "popperConfig", "show", "defaultShow", "onToggle", "delay", "placement", "flip"], j0e = /* @__PURE__ */ function(o) {
  Nse(a, o);
  function a() {
    return o.apply(this, arguments) || this;
  }
  var c = a.prototype;
  return c.render = function() {
    return this.props.children;
  }, a;
}(Ve.Component);
function W0e(o) {
  return o && typeof o == "object" ? o : {
    show: o,
    hide: o
  };
}
function jle(o, a, c) {
  var f = a[0], g = f.currentTarget, x = f.relatedTarget || f.nativeEvent[c];
  (!x || x !== g) && !Hfe(g, x) && o.apply(void 0, a);
}
var Z0e = {
  defaultShow: !1,
  trigger: ["hover", "focus"]
};
function Wfe(o) {
  var a = o.trigger, c = o.overlay, f = o.children, g = o.popperConfig, x = g === void 0 ? {} : g, k = o.show, A = o.defaultShow, N = A === void 0 ? !1 : A, H = o.onToggle, Z = o.delay, K = o.placement, J = o.flip, pe = J === void 0 ? K && K.indexOf("auto") !== -1 : J, Se = Ei(o, U0e), be = tt.useRef(null), ye = z0e(), re = tt.useRef(""), oe = V0e(k, N, H), U = oe[0], ve = oe[1], Ze = W0e(Z), rt = typeof f != "function" ? Ve.Children.only(f).props : {}, ee = rt.onFocus, lt = rt.onBlur, wt = rt.onClick, Vt = tt.useCallback(function() {
    return xV(be.current);
  }, []), Ue = tt.useCallback(function() {
    if (ye.clear(), re.current = "show", !Ze.show) {
      ve(!0);
      return;
    }
    ye.set(function() {
      re.current === "show" && ve(!0);
    }, Ze.show);
  }, [Ze.show, ve, ye]), Ce = tt.useCallback(function() {
    if (ye.clear(), re.current = "hide", !Ze.hide) {
      ve(!1);
      return;
    }
    ye.set(function() {
      re.current === "hide" && ve(!1);
    }, Ze.hide);
  }, [Ze.hide, ve, ye]), Rn = tt.useCallback(function() {
    Ue();
    for (var Tt = arguments.length, Je = new Array(Tt), pn = 0; pn < Tt; pn++)
      Je[pn] = arguments[pn];
    ee == null || ee.apply(void 0, Je);
  }, [Ue, ee]), _t = tt.useCallback(function() {
    Ce();
    for (var Tt = arguments.length, Je = new Array(Tt), pn = 0; pn < Tt; pn++)
      Je[pn] = arguments[pn];
    lt == null || lt.apply(void 0, Je);
  }, [Ce, lt]), ot = tt.useCallback(function() {
    ve(!U), wt && wt.apply(void 0, arguments);
  }, [wt, ve, U]), B = tt.useCallback(function() {
    for (var Tt = arguments.length, Je = new Array(Tt), pn = 0; pn < Tt; pn++)
      Je[pn] = arguments[pn];
    jle(Ue, Je, "fromElement");
  }, [Ue]), fn = tt.useCallback(function() {
    for (var Tt = arguments.length, Je = new Array(Tt), pn = 0; pn < Tt; pn++)
      Je[pn] = arguments[pn];
    jle(Ce, Je, "toElement");
  }, [Ce]), ze = a == null ? [] : [].concat(a), jt = {};
  return ze.indexOf("click") !== -1 && (jt.onClick = ot), ze.indexOf("focus") !== -1 && (jt.onFocus = Rn, jt.onBlur = _t), ze.indexOf("hover") !== -1 && (jt.onMouseOver = B, jt.onMouseOut = fn), /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, typeof f == "function" ? f(Zs({}, jt, {
    ref: be
  })) : /* @__PURE__ */ Ve.createElement(j0e, {
    ref: be
  }, /* @__PURE__ */ tt.cloneElement(f, jt)), /* @__PURE__ */ Ve.createElement(Ufe, Zs({}, Se, {
    show: U,
    onHide: Ce,
    flip: pe,
    placement: K,
    popperConfig: x,
    target: Vt
  }), c));
}
Wfe.defaultProps = Z0e;
const Zfe = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"], G0e = ["hover", "click", "focus"];
function qV(o) {
  return /* @__PURE__ */ Ve.createElement(Wfe, {
    ...o
  }, o.children);
}
const Wle = ce.oneOf(G0e);
ce.node.isRequired, ce.oneOfType([ce.elementType, ce.func]), ce.func, ce.func, ce.func, ce.func, ce.func, ce.func, ce.func, ce.oneOf(Zfe), ce.shape({}), ce.bool, ce.oneOf(["click", "mousedown"]), ce.bool, ce.oneOfType([ce.elementType, ce.func]), ce.oneOfType([ce.object, ce.bool]);
qV.propTypes = {
  /** Specifies the content of the `OverlayTrigger`. */
  children: ce.oneOfType([ce.element, ce.func]).isRequired,
  /** An element or text to overlay next to the target. */
  overlay: ce.oneOfType([ce.element, ce.func]).isRequired,
  /** The initial visibility state of the `Overlay`. */
  defaultShow: ce.bool,
  /** A millisecond delay amount to show and hide the `Overlay` once triggered. */
  delay: ce.oneOfType([ce.number, ce.shape({})]),
  /** The initial flip state of the `Overlay`. */
  flip: ce.bool,
  onHide: ce.func,
  /**
   * A callback that fires when the user triggers a change in tooltip visibility.
   * `onToggle` is called with the desired next show, and generally should be
   * passed back to the `show` prop. `onToggle` fires after the configured `delay`.
   *
   * Controls `show`.
   */
  onToggle: ce.func,
  /** The placement of the `Overlay` in relation to it's target. */
  placement: ce.oneOf(Zfe),
  /** A `Popper.js` config object passed to the the underlying popper instance. */
  popperConfig: ce.shape({}),
  /**
   * The visibility of the `Overlay`. `show` is a controlled prop so should
   * be paired with `onToggle` to avoid breaking user interactions.
   *
   * Manually toggling show does not wait for delay to change the visibility.
   *
   * Controls `onToggle`.
   */
  show: ce.bool,
  target: ce.instanceOf(EventTarget),
  /** Specify which action or actions trigger `Overlay` visibility. */
  trigger: ce.oneOfType([Wle, ce.arrayOf(Wle)])
};
qV.defaultProps = {
  defaultShow: !1,
  delay: void 0,
  flip: void 0,
  onHide: void 0,
  onToggle: void 0,
  placement: void 0,
  popperConfig: {},
  show: void 0,
  target: void 0,
  trigger: ["hover", "focus"]
};
var Zle = { exports: {} };
(function(o, a) {
  Object.defineProperty(a, "__esModule", {
    value: !0
  }), a.default = c;
  function c(f) {
    return function(x, k, A, N, H) {
      var Z = A || "<<anonymous>>", K = H || k;
      if (x[k] == null)
        return new Error("The " + N + " `" + K + "` is required to make " + ("`" + Z + "` accessible for users of assistive ") + "technologies such as screen readers.");
      for (var J = arguments.length, pe = Array(J > 5 ? J - 5 : 0), Se = 5; Se < J; Se++)
        pe[Se - 5] = arguments[Se];
      return f.apply(void 0, [x, k, A, N, H].concat(pe));
    };
  }
  o.exports = a.default;
})(Zle, Zle.exports);
var q0e = ["bsPrefix", "placement", "className", "style", "children", "arrowProps", "popper", "show"], K0e = {
  placement: "right"
}, KV = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  var c = o.bsPrefix, f = o.placement, g = o.className, x = o.style, k = o.children, A = o.arrowProps;
  o.popper, o.show;
  var N = Ei(o, q0e);
  c = Fc(c, "tooltip");
  var H = (f == null ? void 0 : f.split("-")) || [], Z = H[0];
  return /* @__PURE__ */ Ve.createElement("div", Zs({
    ref: a,
    style: x,
    role: "tooltip",
    "x-placement": Z,
    className: er(g, c, "bs-tooltip-" + Z)
  }, N), /* @__PURE__ */ Ve.createElement("div", Zs({
    className: "arrow"
  }, A)), /* @__PURE__ */ Ve.createElement("div", {
    className: c + "-inner"
  }, k));
});
KV.defaultProps = K0e;
KV.displayName = "Tooltip";
const Y0e = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"], SI = /* @__PURE__ */ Ve.forwardRef((o, a) => {
  let {
    children: c,
    variant: f,
    ...g
  } = o;
  return /* @__PURE__ */ Ve.createElement(KV, {
    ...g,
    className: er({
      "tooltip-light": f === "light"
    }, g.className),
    ref: a
  }, c);
});
SI.propTypes = {
  ...KV.propTypes,
  /** An html id attribute, necessary for accessibility. */
  id: ce.string.isRequired,
  /**
   * Sets the direction the `Tooltip` is positioned towards.
   *
   * This is generally provided by the `Overlay` component positioning the tooltip.
   */
  placement: ce.oneOf(Y0e),
  /**
   * An `Overlay` injected set of props for positioning the `Tooltip` arrow.
   *
   * This is generally provided by the `Overlay` component positioning the tooltip.
   */
  arrowProps: ce.shape({
    ref: ce.oneOfType([ce.func, ce.shape({
      current: ce.element
    })]),
    style: ce.shape({})
  }),
  /** Whether the `Overlay` is shown. */
  show: ce.bool,
  /** A `Popper.js` config object passed to the the underlying popper instance. */
  popper: ce.shape({}),
  /** Overrides underlying component base CSS class name */
  bsPrefix: ce.string,
  /** Specifies the content of the `Tooltip` */
  children: ce.node,
  /** Specifies class name to append to the base element */
  className: ce.string,
  /** The visual style of the `Tooltip` */
  variant: ce.string
};
SI.defaultProps = {
  ...SI.defaultProps,
  id: void 0,
  placement: "right",
  arrowProps: void 0,
  show: void 0,
  popper: void 0,
  children: void 0,
  className: void 0,
  variant: void 0,
  bsPrefix: "tooltip"
};
const rO = /* @__PURE__ */ Ve.forwardRef((o, a) => {
  let {
    className: c,
    alt: f,
    invertColors: g,
    icon: x,
    src: k,
    iconClassNames: A,
    onClick: N,
    size: H,
    variant: Z,
    iconAs: K,
    isActive: J,
    children: pe,
    // unused, just here because we don't want it to be part of 'attrs'
    ...Se
  } = o;
  const be = g ? "inverse-" : "", ye = J ? `${Z}-` : "", re = K || LI;
  return /* @__PURE__ */ Ve.createElement("button", {
    "aria-label": f,
    className: er("btn-icon", `btn-icon-${be}${Z}`, `btn-icon-${H}`, {
      [`btn-icon-${be}${ye}active`]: J
    }, c),
    onClick: N,
    type: "button",
    ref: a,
    ...Se
  }, /* @__PURE__ */ Ve.createElement("span", {
    className: "btn-icon__icon-container"
  }, /* @__PURE__ */ Ve.createElement(re, {
    className: er("btn-icon__icon", A),
    icon: x,
    src: k
  })));
});
rO.defaultProps = {
  iconAs: void 0,
  src: void 0,
  icon: void 0,
  iconClassNames: void 0,
  className: void 0,
  invertColors: !1,
  variant: "primary",
  size: "md",
  onClick: () => {
  },
  isActive: !1,
  value: void 0,
  children: void 0
};
rO.propTypes = {
  /** A custom class name. */
  className: ce.string,
  /** Component that renders the icon, currently defaults to `FontAwesomeIcon`,
   *  but is going to be deprecated soon, please use Paragon's icons instead. */
  iconAs: ce.elementType,
  /** An icon component to render. Example import of a Paragon icon component:
   * `import { Check } from '@openedx/paragon/icons';`
   * */
  src: ce.elementType,
  /** Alt text for your icon. For best practice, avoid using alt text to describe
   * the image in the `IconButton`. Instead, we recommend describing the function
   * of the button. */
  alt: ce.string.isRequired,
  /** Changes icon styles for dark background */
  invertColors: ce.bool,
  /** Accepts a React fontawesome icon. */
  icon: ce.shape({
    prefix: ce.string,
    iconName: ce.string,
    // eslint-disable-next-line react/forbid-prop-types
    icon: ce.array
  }),
  /** Extra class names that will be added to the icon */
  iconClassNames: ce.string,
  /** Click handler for the button */
  onClick: ce.func,
  /** Type of button (uses Bootstrap options) */
  variant: ce.oneOf(["primary", "secondary", "success", "warning", "danger", "light", "dark", "black", "brand"]),
  /** size of button to render */
  size: ce.oneOf(["sm", "md", "inline"]),
  /** whether to show the `IconButton` in an active state, whose styling is distinct from default state */
  isActive: ce.bool,
  /** Used with `IconButtonToggle` */
  value: ce.string
};
function Pse(o) {
  let {
    tooltipPlacement: a,
    tooltipContent: c,
    ...f
  } = o;
  const g = f.invertColors ? "inverse-" : "";
  return /* @__PURE__ */ Ve.createElement(qV, {
    placement: a,
    overlay: /* @__PURE__ */ Ve.createElement(SI, {
      id: `iconbutton-tooltip-${a}`,
      variant: g ? "light" : void 0
    }, c)
  }, /* @__PURE__ */ Ve.createElement(rO, {
    ...f
  }));
}
Pse.defaultProps = {
  ...rO.defaultProps,
  tooltipPlacement: "top"
};
Pse.propTypes = {
  /** tooltip placement can be top, left, right etc, per https://popper.js.org/docs/v2/constructors/#options  */
  tooltipPlacement: ce.string,
  /** any valid JSX or text to be rendered as tooltip contents */
  tooltipContent: ce.node.isRequired,
  /** Type of button (uses Bootstrap options) */
  variant: ce.oneOf(["primary", "secondary", "success", "warning", "danger", "light", "dark", "black", "brand"]),
  /** Changes icon styles for dark background */
  invertColors: ce.bool
};
rO.IconButtonWithTooltip = Pse;
var Wd = function() {
  return Wd = Object.assign || function(a) {
    for (var c, f = 1, g = arguments.length; f < g; f++) {
      c = arguments[f];
      for (var x in c) Object.prototype.hasOwnProperty.call(c, x) && (a[x] = c[x]);
    }
    return a;
  }, Wd.apply(this, arguments);
};
function X4(o, a) {
  var c = {};
  for (var f in o) Object.prototype.hasOwnProperty.call(o, f) && a.indexOf(f) < 0 && (c[f] = o[f]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var g = 0, f = Object.getOwnPropertySymbols(o); g < f.length; g++)
      a.indexOf(f[g]) < 0 && Object.prototype.propertyIsEnumerable.call(o, f[g]) && (c[f[g]] = o[f[g]]);
  return c;
}
function X0e() {
  for (var o = 0, a = 0, c = arguments.length; a < c; a++) o += arguments[a].length;
  for (var f = Array(o), g = 0, a = 0; a < c; a++)
    for (var x = arguments[a], k = 0, A = x.length; k < A; k++, g++)
      f[g] = x[k];
  return f;
}
function Q0e(o, a, c) {
  if (c || arguments.length === 2) for (var f = 0, g = a.length, x; f < g; f++)
    (x || !(f in a)) && (x || (x = Array.prototype.slice.call(a, 0, f)), x[f] = a[f]);
  return o.concat(x || Array.prototype.slice.call(a));
}
var Gfe = { exports: {} }, ai = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Iu = typeof Symbol == "function" && Symbol.for, Mse = Iu ? Symbol.for("react.element") : 60103, Ise = Iu ? Symbol.for("react.portal") : 60106, YV = Iu ? Symbol.for("react.fragment") : 60107, XV = Iu ? Symbol.for("react.strict_mode") : 60108, QV = Iu ? Symbol.for("react.profiler") : 60114, JV = Iu ? Symbol.for("react.provider") : 60109, eU = Iu ? Symbol.for("react.context") : 60110, Fse = Iu ? Symbol.for("react.async_mode") : 60111, tU = Iu ? Symbol.for("react.concurrent_mode") : 60111, nU = Iu ? Symbol.for("react.forward_ref") : 60112, oU = Iu ? Symbol.for("react.suspense") : 60113, J0e = Iu ? Symbol.for("react.suspense_list") : 60120, sU = Iu ? Symbol.for("react.memo") : 60115, rU = Iu ? Symbol.for("react.lazy") : 60116, eye = Iu ? Symbol.for("react.block") : 60121, tye = Iu ? Symbol.for("react.fundamental") : 60117, nye = Iu ? Symbol.for("react.responder") : 60118, oye = Iu ? Symbol.for("react.scope") : 60119;
function yp(o) {
  if (typeof o == "object" && o !== null) {
    var a = o.$$typeof;
    switch (a) {
      case Mse:
        switch (o = o.type, o) {
          case Fse:
          case tU:
          case YV:
          case QV:
          case XV:
          case oU:
            return o;
          default:
            switch (o = o && o.$$typeof, o) {
              case eU:
              case nU:
              case rU:
              case sU:
              case JV:
                return o;
              default:
                return a;
            }
        }
      case Ise:
        return a;
    }
  }
}
function qfe(o) {
  return yp(o) === tU;
}
ai.AsyncMode = Fse;
ai.ConcurrentMode = tU;
ai.ContextConsumer = eU;
ai.ContextProvider = JV;
ai.Element = Mse;
ai.ForwardRef = nU;
ai.Fragment = YV;
ai.Lazy = rU;
ai.Memo = sU;
ai.Portal = Ise;
ai.Profiler = QV;
ai.StrictMode = XV;
ai.Suspense = oU;
ai.isAsyncMode = function(o) {
  return qfe(o) || yp(o) === Fse;
};
ai.isConcurrentMode = qfe;
ai.isContextConsumer = function(o) {
  return yp(o) === eU;
};
ai.isContextProvider = function(o) {
  return yp(o) === JV;
};
ai.isElement = function(o) {
  return typeof o == "object" && o !== null && o.$$typeof === Mse;
};
ai.isForwardRef = function(o) {
  return yp(o) === nU;
};
ai.isFragment = function(o) {
  return yp(o) === YV;
};
ai.isLazy = function(o) {
  return yp(o) === rU;
};
ai.isMemo = function(o) {
  return yp(o) === sU;
};
ai.isPortal = function(o) {
  return yp(o) === Ise;
};
ai.isProfiler = function(o) {
  return yp(o) === QV;
};
ai.isStrictMode = function(o) {
  return yp(o) === XV;
};
ai.isSuspense = function(o) {
  return yp(o) === oU;
};
ai.isValidElementType = function(o) {
  return typeof o == "string" || typeof o == "function" || o === YV || o === tU || o === QV || o === XV || o === oU || o === J0e || typeof o == "object" && o !== null && (o.$$typeof === rU || o.$$typeof === sU || o.$$typeof === JV || o.$$typeof === eU || o.$$typeof === nU || o.$$typeof === tye || o.$$typeof === nye || o.$$typeof === oye || o.$$typeof === eye);
};
ai.typeOf = yp;
Gfe.exports = ai;
var sye = Gfe.exports, Kfe = sye, rye = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, aye = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, Yfe = {};
Yfe[Kfe.ForwardRef] = rye;
Yfe[Kfe.Memo] = aye;
function iye(o, a, c) {
  if (c === void 0 && (c = Error), !o)
    throw new c(a);
}
var lye = function(o) {
}, cye = function(o) {
}, uye = {
  formats: {},
  messages: {},
  timeZone: void 0,
  defaultLocale: "en",
  defaultFormats: {},
  fallbackOnEmptyString: !0,
  onError: lye,
  onWarn: cye
};
function dye(o) {
  iye(o, "[React Intl] Could not find required `intl` object. <IntlProvider> needs to exist in the component ancestry.");
}
Wd(Wd({}, uye), { textComponent: tt.Fragment });
var Bse = typeof window < "u" && !window.__REACT_INTL_BYPASS_GLOBAL_CONTEXT__ ? window.__REACT_INTL_CONTEXT__ || (window.__REACT_INTL_CONTEXT__ = tt.createContext(null)) : tt.createContext(null);
Bse.Consumer;
Bse.Provider;
var fye = Bse;
function Lse() {
  var o = tt.useContext(fye);
  return dye(o), o;
}
var Zne;
(function(o) {
  o.formatDate = "FormattedDate", o.formatTime = "FormattedTime", o.formatNumber = "FormattedNumber", o.formatList = "FormattedList", o.formatDisplayName = "FormattedDisplayName";
})(Zne || (Zne = {}));
var Gne;
(function(o) {
  o.formatDate = "FormattedDateParts", o.formatTime = "FormattedTimeParts", o.formatNumber = "FormattedNumberParts", o.formatList = "FormattedListParts";
})(Gne || (Gne = {}));
function Xfe(o) {
  var a = function(c) {
    var f = Lse(), g = c.value, x = c.children, k = X4(c, ["value", "children"]), A = typeof g == "string" ? new Date(g || 0) : g, N = o === "formatDate" ? f.formatDateToParts(A, k) : f.formatTimeToParts(A, k);
    return x(N);
  };
  return a.displayName = Gne[o], a;
}
function zI(o) {
  var a = function(c) {
    var f = Lse(), g = c.value, x = c.children, k = X4(
      c,
      ["value", "children"]
    ), A = f[o](g, k);
    if (typeof x == "function")
      return x(A);
    var N = f.textComponent || tt.Fragment;
    return tt.createElement(N, null, A);
  };
  return a.displayName = Zne[o], a;
}
zI("formatDate");
zI("formatTime");
zI("formatNumber");
zI("formatList");
zI("formatDisplayName");
Xfe("formatDate");
Xfe("formatTime");
const mye = (o) => /* @__PURE__ */ tt.createElement("svg", {
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  ...o
}, /* @__PURE__ */ tt.createElement("path", {
  d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2Zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59Z",
  fill: "currentColor"
})), pye = (o) => /* @__PURE__ */ tt.createElement("svg", {
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  ...o
}, /* @__PURE__ */ tt.createElement("path", {
  d: "M9 16.2 4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2Z",
  fill: "currentColor"
})), hye = (o) => /* @__PURE__ */ tt.createElement("svg", {
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  ...o
}, /* @__PURE__ */ tt.createElement("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2Zm-2 15-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9Z",
  fill: "currentColor"
})), gye = (o) => /* @__PURE__ */ tt.createElement("svg", {
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  ...o
}, /* @__PURE__ */ tt.createElement("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z",
  fill: "currentColor"
})), vye = (o) => /* @__PURE__ */ tt.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  ...o
}, /* @__PURE__ */ tt.createElement("path", {
  d: "M6 21h12V7H6v14zM8 9h8v10H8V9zm7.5-5-1-1h-5l-1 1H5v2h14V4h-3.5z",
  fill: "currentColor"
})), bye = (o) => /* @__PURE__ */ tt.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  ...o
}, /* @__PURE__ */ tt.createElement("path", {
  d: "M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z",
  fill: "currentColor"
})), yye = (o) => /* @__PURE__ */ tt.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  ...o
}, /* @__PURE__ */ tt.createElement("path", {
  d: "M7.41 15.41 12 10.83l4.59 4.58L18 14l-6-6-6 6 1.41 1.41z",
  fill: "currentColor"
})), xye = (o) => /* @__PURE__ */ tt.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  ...o
}, /* @__PURE__ */ tt.createElement("path", {
  d: "M19 12.998h-6v6h-2v-6H5v-2h6v-6h2v6h6z",
  fill: "currentColor"
})), wye = (o) => /* @__PURE__ */ tt.createElement("svg", {
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  ...o
}, /* @__PURE__ */ tt.createElement("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2Zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8Z",
  fill: "currentColor"
})), Cye = (o) => /* @__PURE__ */ tt.createElement("svg", {
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  ...o
}, /* @__PURE__ */ tt.createElement("path", {
  xmlns: "http://www.w3.org/2000/svg",
  d: "M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z",
  fill: "currentColor"
}));
var Gle = { exports: {} }, qne = { exports: {} };
(function(o, a) {
  Object.defineProperty(a, "__esModule", {
    value: !0
  }), a.default = c;
  function c(f) {
    function g(k, A, N, H, Z, K) {
      var J = H || "<<anonymous>>", pe = K || N;
      if (A[N] == null)
        return k ? new Error("Required " + Z + " `" + pe + "` was not specified " + ("in `" + J + "`.")) : null;
      for (var Se = arguments.length, be = Array(Se > 6 ? Se - 6 : 0), ye = 6; ye < Se; ye++)
        be[ye - 6] = arguments[ye];
      return f.apply(void 0, [A, N, J, Z, pe].concat(be));
    }
    var x = g.bind(null, !1);
    return x.isRequired = g.bind(null, !0), x;
  }
  o.exports = a.default;
})(qne, qne.exports);
var Sye = qne.exports;
(function(o, a) {
  Object.defineProperty(a, "__esModule", {
    value: !0
  }), a.default = x;
  var c = Sye, f = g(c);
  function g(k) {
    return k && k.__esModule ? k : { default: k };
  }
  function x() {
    for (var k = arguments.length, A = Array(k), N = 0; N < k; N++)
      A[N] = arguments[N];
    function H() {
      for (var Z = arguments.length, K = Array(Z), J = 0; J < Z; J++)
        K[J] = arguments[J];
      var pe = null;
      return A.forEach(function(Se) {
        if (pe == null) {
          var be = Se.apply(void 0, K);
          be != null && (pe = be);
        }
      }), pe;
    }
    return (0, f.default)(H);
  }
  o.exports = a.default;
})(Gle, Gle.exports);
var kye = ["as", "className", "type", "tooltip"], _ye = {
  /**
   * Specify whether the feedback is for valid or invalid fields
   *
   * @type {('valid'|'invalid')}
   */
  type: ce.string,
  /** Display feedback as a tooltip. */
  tooltip: ce.bool,
  as: ce.elementType
}, VI = /* @__PURE__ */ Ve.forwardRef(
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  function(o, a) {
    var c = o.as, f = c === void 0 ? "div" : c, g = o.className, x = o.type, k = x === void 0 ? "valid" : x, A = o.tooltip, N = A === void 0 ? !1 : A, H = Ei(o, kye);
    return /* @__PURE__ */ Ve.createElement(f, Zs({}, H, {
      ref: a,
      className: er(g, k + "-" + (N ? "tooltip" : "feedback"))
    }));
  }
);
VI.displayName = "Feedback";
VI.propTypes = _ye;
var iv = /* @__PURE__ */ Ve.createContext({
  controlId: void 0
}), Eye = ["id", "bsPrefix", "bsCustomPrefix", "className", "type", "isValid", "isInvalid", "isStatic", "as"], $se = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  var c = o.id, f = o.bsPrefix, g = o.bsCustomPrefix, x = o.className, k = o.type, A = k === void 0 ? "checkbox" : k, N = o.isValid, H = N === void 0 ? !1 : N, Z = o.isInvalid, K = Z === void 0 ? !1 : Z, J = o.isStatic, pe = o.as, Se = pe === void 0 ? "input" : pe, be = Ei(o, Eye), ye = tt.useContext(iv), re = ye.controlId, oe = ye.custom, U = oe ? [g, "custom-control-input"] : [f, "form-check-input"], ve = U[0], Ze = U[1];
  return f = Fc(ve, Ze), /* @__PURE__ */ Ve.createElement(Se, Zs({}, be, {
    ref: a,
    type: A,
    id: c || re,
    className: er(x, f, H && "is-valid", K && "is-invalid", J && "position-static")
  }));
});
$se.displayName = "FormCheckInput";
var Tye = ["bsPrefix", "bsCustomPrefix", "className", "htmlFor"], Hse = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  var c = o.bsPrefix, f = o.bsCustomPrefix, g = o.className, x = o.htmlFor, k = Ei(o, Tye), A = tt.useContext(iv), N = A.controlId, H = A.custom, Z = H ? [f, "custom-control-label"] : [c, "form-check-label"], K = Z[0], J = Z[1];
  return c = Fc(K, J), /* @__PURE__ */ Ve.createElement("label", Zs({}, k, {
    ref: a,
    htmlFor: x || N,
    className: er(g, c)
  }));
});
Hse.displayName = "FormCheckLabel";
var Aye = ["id", "bsPrefix", "bsCustomPrefix", "inline", "disabled", "isValid", "isInvalid", "feedbackTooltip", "feedback", "className", "style", "title", "type", "label", "children", "custom", "as"], t_ = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  var c = o.id, f = o.bsPrefix, g = o.bsCustomPrefix, x = o.inline, k = x === void 0 ? !1 : x, A = o.disabled, N = A === void 0 ? !1 : A, H = o.isValid, Z = H === void 0 ? !1 : H, K = o.isInvalid, J = K === void 0 ? !1 : K, pe = o.feedbackTooltip, Se = pe === void 0 ? !1 : pe, be = o.feedback, ye = o.className, re = o.style, oe = o.title, U = oe === void 0 ? "" : oe, ve = o.type, Ze = ve === void 0 ? "checkbox" : ve, rt = o.label, ee = o.children, lt = o.custom, wt = o.as, Vt = wt === void 0 ? "input" : wt, Ue = Ei(o, Aye), Ce = Ze === "switch" ? !0 : lt, Rn = Ce ? [g, "custom-control"] : [f, "form-check"], _t = Rn[0], ot = Rn[1];
  f = Fc(_t, ot);
  var B = tt.useContext(iv), fn = B.controlId, ze = tt.useMemo(function() {
    return {
      controlId: c || fn,
      custom: Ce
    };
  }, [fn, Ce, c]), jt = Ce || rt != null && rt !== !1 && !ee, Tt = /* @__PURE__ */ Ve.createElement($se, Zs({}, Ue, {
    type: Ze === "switch" ? "checkbox" : Ze,
    ref: a,
    isValid: Z,
    isInvalid: J,
    isStatic: !jt,
    disabled: N,
    as: Vt
  }));
  return /* @__PURE__ */ Ve.createElement(iv.Provider, {
    value: ze
  }, /* @__PURE__ */ Ve.createElement("div", {
    style: re,
    className: er(ye, f, Ce && "custom-" + Ze, k && f + "-inline")
  }, ee || /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, Tt, jt && /* @__PURE__ */ Ve.createElement(Hse, {
    title: U
  }, rt), (Z || J) && /* @__PURE__ */ Ve.createElement(VI, {
    type: Z ? "valid" : "invalid",
    tooltip: Se
  }, be))));
});
t_.displayName = "FormCheck";
t_.Input = $se;
t_.Label = Hse;
var Oye = ["id", "bsPrefix", "bsCustomPrefix", "className", "isValid", "isInvalid", "lang", "as"], zse = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  var c = o.id, f = o.bsPrefix, g = o.bsCustomPrefix, x = o.className, k = o.isValid, A = o.isInvalid, N = o.lang, H = o.as, Z = H === void 0 ? "input" : H, K = Ei(o, Oye), J = tt.useContext(iv), pe = J.controlId, Se = J.custom, be = "file", ye = Se ? [g, "custom-file-input"] : [f, "form-control-file"], re = ye[0], oe = ye[1];
  return f = Fc(re, oe), /* @__PURE__ */ Ve.createElement(Z, Zs({}, K, {
    ref: a,
    id: c || pe,
    type: be,
    lang: N,
    className: er(x, f, k && "is-valid", A && "is-invalid")
  }));
});
zse.displayName = "FormFileInput";
var Dye = ["bsPrefix", "bsCustomPrefix", "className", "htmlFor"], wV = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  var c = o.bsPrefix, f = o.bsCustomPrefix, g = o.className, x = o.htmlFor, k = Ei(o, Dye), A = tt.useContext(iv), N = A.controlId, H = A.custom, Z = H ? [f, "custom-file-label"] : [c, "form-file-label"], K = Z[0], J = Z[1];
  return c = Fc(K, J), /* @__PURE__ */ Ve.createElement("label", Zs({}, k, {
    ref: a,
    htmlFor: x || N,
    className: er(g, c),
    "data-browse": k["data-browse"]
  }));
});
wV.displayName = "FormFileLabel";
var Rye = ["id", "bsPrefix", "bsCustomPrefix", "disabled", "isValid", "isInvalid", "feedbackTooltip", "feedback", "className", "style", "label", "children", "custom", "lang", "data-browse", "as", "inputAs"], aU = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  var c = o.id, f = o.bsPrefix, g = o.bsCustomPrefix, x = o.disabled, k = x === void 0 ? !1 : x, A = o.isValid, N = A === void 0 ? !1 : A, H = o.isInvalid, Z = H === void 0 ? !1 : H, K = o.feedbackTooltip, J = K === void 0 ? !1 : K, pe = o.feedback, Se = o.className, be = o.style, ye = o.label, re = o.children, oe = o.custom, U = o.lang, ve = o["data-browse"], Ze = o.as, rt = Ze === void 0 ? "div" : Ze, ee = o.inputAs, lt = ee === void 0 ? "input" : ee, wt = Ei(o, Rye), Vt = oe ? [g, "custom"] : [f, "form-file"], Ue = Vt[0], Ce = Vt[1];
  f = Fc(Ue, Ce);
  var Rn = "file", _t = tt.useContext(iv), ot = _t.controlId, B = tt.useMemo(function() {
    return {
      controlId: c || ot,
      custom: oe
    };
  }, [ot, oe, c]), fn = ye != null && ye !== !1 && !re, ze = /* @__PURE__ */ Ve.createElement(zse, Zs({}, wt, {
    ref: a,
    isValid: N,
    isInvalid: Z,
    disabled: k,
    as: lt,
    lang: U
  }));
  return /* @__PURE__ */ Ve.createElement(iv.Provider, {
    value: B
  }, /* @__PURE__ */ Ve.createElement(rt, {
    style: be,
    className: er(Se, f, oe && "custom-" + Rn)
  }, re || /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, oe ? /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, ze, fn && /* @__PURE__ */ Ve.createElement(wV, {
    "data-browse": ve
  }, ye)) : /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, fn && /* @__PURE__ */ Ve.createElement(wV, null, ye), ze), (N || Z) && /* @__PURE__ */ Ve.createElement(VI, {
    type: N ? "valid" : "invalid",
    tooltip: J
  }, pe))));
});
aU.displayName = "FormFile";
aU.Input = zse;
aU.Label = wV;
var Nye = ["bsPrefix", "bsCustomPrefix", "type", "size", "htmlSize", "id", "className", "isValid", "isInvalid", "plaintext", "readOnly", "custom", "as"], Qfe = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  var c = o.bsPrefix, f = o.bsCustomPrefix, g = o.type, x = o.size, k = o.htmlSize, A = o.id, N = o.className, H = o.isValid, Z = H === void 0 ? !1 : H, K = o.isInvalid, J = K === void 0 ? !1 : K, pe = o.plaintext, Se = o.readOnly, be = o.custom, ye = o.as, re = ye === void 0 ? "input" : ye, oe = Ei(o, Nye), U = tt.useContext(iv), ve = U.controlId, Ze = be ? [f, "custom"] : [c, "form-control"], rt = Ze[0], ee = Ze[1];
  c = Fc(rt, ee);
  var lt;
  if (pe) {
    var wt;
    lt = (wt = {}, wt[c + "-plaintext"] = !0, wt);
  } else if (g === "file") {
    var Vt;
    lt = (Vt = {}, Vt[c + "-file"] = !0, Vt);
  } else if (g === "range") {
    var Ue;
    lt = (Ue = {}, Ue[c + "-range"] = !0, Ue);
  } else if (re === "select" && be) {
    var Ce;
    lt = (Ce = {}, Ce[c + "-select"] = !0, Ce[c + "-select-" + x] = x, Ce);
  } else {
    var Rn;
    lt = (Rn = {}, Rn[c] = !0, Rn[c + "-" + x] = x, Rn);
  }
  return /* @__PURE__ */ Ve.createElement(re, Zs({}, oe, {
    type: g,
    size: k,
    ref: a,
    readOnly: Se,
    id: A || ve,
    className: er(N, lt, Z && "is-valid", J && "is-invalid")
  }));
});
Qfe.displayName = "FormControl";
const Jfe = Object.assign(Qfe, {
  Feedback: VI
});
var Pye = ["bsPrefix", "className", "children", "controlId", "as"], eme = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  var c = o.bsPrefix, f = o.className, g = o.children, x = o.controlId, k = o.as, A = k === void 0 ? "div" : k, N = Ei(o, Pye);
  c = Fc(c, "form-group");
  var H = tt.useMemo(function() {
    return {
      controlId: x
    };
  }, [x]);
  return /* @__PURE__ */ Ve.createElement(iv.Provider, {
    value: H
  }, /* @__PURE__ */ Ve.createElement(A, Zs({}, N, {
    ref: a,
    className: er(f, c)
  }), g));
});
eme.displayName = "FormGroup";
var Mye = ["bsPrefix", "className", "as"], Iye = ["xl", "lg", "md", "sm", "xs"], tme = /* @__PURE__ */ Ve.forwardRef(
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  function(o, a) {
    var c = o.bsPrefix, f = o.className, g = o.as, x = g === void 0 ? "div" : g, k = Ei(o, Mye), A = Fc(c, "col"), N = [], H = [];
    return Iye.forEach(function(Z) {
      var K = k[Z];
      delete k[Z];
      var J, pe, Se;
      if (typeof K == "object" && K != null) {
        var be = K.span;
        J = be === void 0 ? !0 : be, pe = K.offset, Se = K.order;
      } else
        J = K;
      var ye = Z !== "xs" ? "-" + Z : "";
      J && N.push(J === !0 ? "" + A + ye : "" + A + ye + "-" + J), Se != null && H.push("order" + ye + "-" + Se), pe != null && H.push("offset" + ye + "-" + pe);
    }), N.length || N.push(A), /* @__PURE__ */ Ve.createElement(x, Zs({}, k, {
      ref: a,
      className: er.apply(void 0, [f].concat(N, H))
    }));
  }
);
tme.displayName = "Col";
var Fye = ["as", "bsPrefix", "column", "srOnly", "className", "htmlFor"], Bye = {
  column: !1,
  srOnly: !1
}, Vse = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  var c = o.as, f = c === void 0 ? "label" : c, g = o.bsPrefix, x = o.column, k = o.srOnly, A = o.className, N = o.htmlFor, H = Ei(o, Fye), Z = tt.useContext(iv), K = Z.controlId;
  g = Fc(g, "form-label");
  var J = "col-form-label";
  typeof x == "string" && (J = J + " " + J + "-" + x);
  var pe = er(A, g, k && "sr-only", x && J);
  return N = N || K, x ? /* @__PURE__ */ Ve.createElement(tme, Zs({
    ref: a,
    as: "label",
    className: pe,
    htmlFor: N
  }, H)) : (
    // eslint-disable-next-line jsx-a11y/label-has-for, jsx-a11y/label-has-associated-control
    /* @__PURE__ */ Ve.createElement(f, Zs({
      ref: a,
      className: pe,
      htmlFor: N
    }, H))
  );
});
Vse.displayName = "FormLabel";
Vse.defaultProps = Bye;
var Lye = ["bsPrefix", "className", "as", "muted"], nme = /* @__PURE__ */ Ve.forwardRef(
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  function(o, a) {
    var c = o.bsPrefix, f = o.className, g = o.as, x = g === void 0 ? "small" : g, k = o.muted, A = Ei(o, Lye);
    return c = Fc(c, "form-text"), /* @__PURE__ */ Ve.createElement(x, Zs({}, A, {
      ref: a,
      className: er(f, c, k && "text-muted")
    }));
  }
);
nme.displayName = "FormText";
var iU = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  return /* @__PURE__ */ Ve.createElement(t_, Zs({}, o, {
    ref: a,
    type: "switch"
  }));
});
iU.displayName = "Switch";
iU.Input = t_.Input;
iU.Label = t_.Label;
var $ye = /-(.)/g;
function Hye(o) {
  return o.replace($ye, function(a, c) {
    return c.toUpperCase();
  });
}
var zye = ["className", "bsPrefix", "as"], Vye = function(a) {
  return a[0].toUpperCase() + Hye(a).slice(1);
};
function Uye(o, a) {
  var c = {}, f = c.displayName, g = f === void 0 ? Vye(o) : f, x = c.Component, k = c.defaultProps, A = /* @__PURE__ */ Ve.forwardRef(function(N, H) {
    var Z = N.className, K = N.bsPrefix, J = N.as, pe = J === void 0 ? x || "div" : J, Se = Ei(N, zye), be = Fc(K, o);
    return /* @__PURE__ */ Ve.createElement(pe, Zs({
      ref: H,
      className: er(Z, be)
    }, Se));
  });
  return A.defaultProps = k, A.displayName = g, A;
}
var jye = ["bsPrefix", "inline", "className", "validated", "as"], Wye = Uye("form-row"), Zye = {
  inline: !1
}, lv = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  var c = o.bsPrefix, f = o.inline, g = o.className, x = o.validated, k = o.as, A = k === void 0 ? "form" : k, N = Ei(o, jye);
  return c = Fc(c, "form"), /* @__PURE__ */ Ve.createElement(A, Zs({}, N, {
    ref: a,
    className: er(g, x && "was-validated", f && c + "-inline")
  }));
});
lv.displayName = "Form";
lv.defaultProps = Zye;
lv.Row = Wye;
lv.Group = eme;
lv.Control = Jfe;
lv.Check = t_;
lv.File = aU;
lv.Switch = iU;
lv.Label = Vse;
lv.Text = nme;
function $2(o) {
  return typeof o == "string" || o instanceof String;
}
function qle(o) {
  var a;
  return typeof o == "object" && o != null && (o == null || (a = o.constructor) == null ? void 0 : a.name) === "Object";
}
function ome(o, a) {
  return Array.isArray(a) ? ome(o, (c, f) => a.includes(f)) : Object.entries(o).reduce((c, f) => {
    let [g, x] = f;
    return a(x, g) && (c[g] = x), c;
  }, {});
}
const As = {
  NONE: "NONE",
  LEFT: "LEFT",
  FORCE_LEFT: "FORCE_LEFT",
  RIGHT: "RIGHT",
  FORCE_RIGHT: "FORCE_RIGHT"
};
function Gye(o) {
  switch (o) {
    case As.LEFT:
      return As.FORCE_LEFT;
    case As.RIGHT:
      return As.FORCE_RIGHT;
    default:
      return o;
  }
}
function yte(o) {
  return o.replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1");
}
function CV(o, a) {
  if (a === o) return !0;
  const c = Array.isArray(a), f = Array.isArray(o);
  let g;
  if (c && f) {
    if (a.length != o.length) return !1;
    for (g = 0; g < a.length; g++) if (!CV(a[g], o[g])) return !1;
    return !0;
  }
  if (c != f) return !1;
  if (a && o && typeof a == "object" && typeof o == "object") {
    const x = a instanceof Date, k = o instanceof Date;
    if (x && k) return a.getTime() == o.getTime();
    if (x != k) return !1;
    const A = a instanceof RegExp, N = o instanceof RegExp;
    if (A && N) return a.toString() == o.toString();
    if (A != N) return !1;
    const H = Object.keys(a);
    for (g = 0; g < H.length; g++) if (!Object.prototype.hasOwnProperty.call(o, H[g])) return !1;
    for (g = 0; g < H.length; g++) if (!CV(o[H[g]], a[H[g]])) return !1;
    return !0;
  } else if (a && o && typeof a == "function" && typeof o == "function")
    return a.toString() === o.toString();
  return !1;
}
class qye {
  /** Current input value */
  /** Current cursor position */
  /** Old input value */
  /** Old selection */
  constructor(a) {
    for (Object.assign(this, a); this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos); )
      --this.oldSelection.start;
    if (this.insertedCount)
      for (; this.value.slice(this.cursorPos) !== this.oldValue.slice(this.oldSelection.end); )
        this.value.length - this.cursorPos < this.oldValue.length - this.oldSelection.end ? ++this.oldSelection.end : ++this.cursorPos;
  }
  /** Start changing position */
  get startChangePos() {
    return Math.min(this.cursorPos, this.oldSelection.start);
  }
  /** Inserted symbols count */
  get insertedCount() {
    return this.cursorPos - this.startChangePos;
  }
  /** Inserted symbols */
  get inserted() {
    return this.value.substr(this.startChangePos, this.insertedCount);
  }
  /** Removed symbols count */
  get removedCount() {
    return Math.max(this.oldSelection.end - this.startChangePos || // for Delete
    this.oldValue.length - this.value.length, 0);
  }
  /** Removed symbols */
  get removed() {
    return this.oldValue.substr(this.startChangePos, this.removedCount);
  }
  /** Unchanged head symbols */
  get head() {
    return this.value.substring(0, this.startChangePos);
  }
  /** Unchanged tail symbols */
  get tail() {
    return this.value.substring(this.startChangePos + this.insertedCount);
  }
  /** Remove direction */
  get removeDirection() {
    return !this.removedCount || this.insertedCount ? As.NONE : (this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos) && // if not range removed (event with backspace)
    this.oldSelection.end === this.oldSelection.start ? As.RIGHT : As.LEFT;
  }
}
function ir(o, a) {
  return new ir.InputMask(o, a);
}
function sme(o) {
  if (o == null) throw new Error("mask property should be defined");
  return o instanceof RegExp ? ir.MaskedRegExp : $2(o) ? ir.MaskedPattern : o === Date ? ir.MaskedDate : o === Number ? ir.MaskedNumber : Array.isArray(o) || o === Array ? ir.MaskedDynamic : ir.Masked && o.prototype instanceof ir.Masked ? o : ir.Masked && o instanceof ir.Masked ? o.constructor : o instanceof Function ? ir.MaskedFunction : (console.warn("Mask not found for mask", o), ir.Masked);
}
function kI(o) {
  if (!o) throw new Error("Options in not defined");
  if (ir.Masked) {
    if (o.prototype instanceof ir.Masked) return {
      mask: o
    };
    const {
      mask: a = void 0,
      ...c
    } = o instanceof ir.Masked ? {
      mask: o
    } : qle(o) && o.mask instanceof ir.Masked ? o : {};
    if (a) {
      const f = a.mask;
      return {
        ...ome(a, (g, x) => !x.startsWith("_")),
        mask: a.constructor,
        _mask: f,
        ...c
      };
    }
  }
  return qle(o) ? {
    ...o
  } : {
    mask: o
  };
}
function j0(o) {
  if (ir.Masked && o instanceof ir.Masked) return o;
  const a = kI(o), c = sme(a.mask);
  if (!c) throw new Error("Masked class is not found for provided mask " + a.mask + ", appropriate module needs to be imported manually before creating mask.");
  return a.mask === c && delete a.mask, a._mask && (a.mask = a._mask, delete a._mask), new c(a);
}
ir.createMask = j0;
class Use {
  /** */
  /** */
  /** */
  /** Safely returns selection start */
  get selectionStart() {
    let a;
    try {
      a = this._unsafeSelectionStart;
    } catch {
    }
    return a ?? this.value.length;
  }
  /** Safely returns selection end */
  get selectionEnd() {
    let a;
    try {
      a = this._unsafeSelectionEnd;
    } catch {
    }
    return a ?? this.value.length;
  }
  /** Safely sets element selection */
  select(a, c) {
    if (!(a == null || c == null || a === this.selectionStart && c === this.selectionEnd))
      try {
        this._unsafeSelect(a, c);
      } catch {
      }
  }
  /** */
  get isActive() {
    return !1;
  }
  /** */
  /** */
  /** */
}
ir.MaskElement = Use;
const Kle = 90, Kye = 89;
class lU extends Use {
  /** HTMLElement to use mask on */
  constructor(a) {
    super(), this.input = a, this._onKeydown = this._onKeydown.bind(this), this._onInput = this._onInput.bind(this), this._onBeforeinput = this._onBeforeinput.bind(this), this._onCompositionEnd = this._onCompositionEnd.bind(this);
  }
  get rootElement() {
    var a, c, f;
    return (a = (c = (f = this.input).getRootNode) == null ? void 0 : c.call(f)) != null ? a : document;
  }
  /** Is element in focus */
  get isActive() {
    return this.input === this.rootElement.activeElement;
  }
  /** Binds HTMLElement events to mask internal events */
  bindEvents(a) {
    this.input.addEventListener("keydown", this._onKeydown), this.input.addEventListener("input", this._onInput), this.input.addEventListener("beforeinput", this._onBeforeinput), this.input.addEventListener("compositionend", this._onCompositionEnd), this.input.addEventListener("drop", a.drop), this.input.addEventListener("click", a.click), this.input.addEventListener("focus", a.focus), this.input.addEventListener("blur", a.commit), this._handlers = a;
  }
  _onKeydown(a) {
    if (this._handlers.redo && (a.keyCode === Kle && a.shiftKey && (a.metaKey || a.ctrlKey) || a.keyCode === Kye && a.ctrlKey))
      return a.preventDefault(), this._handlers.redo(a);
    if (this._handlers.undo && a.keyCode === Kle && (a.metaKey || a.ctrlKey))
      return a.preventDefault(), this._handlers.undo(a);
    a.isComposing || this._handlers.selectionChange(a);
  }
  _onBeforeinput(a) {
    if (a.inputType === "historyUndo" && this._handlers.undo)
      return a.preventDefault(), this._handlers.undo(a);
    if (a.inputType === "historyRedo" && this._handlers.redo)
      return a.preventDefault(), this._handlers.redo(a);
  }
  _onCompositionEnd(a) {
    this._handlers.input(a);
  }
  _onInput(a) {
    a.isComposing || this._handlers.input(a);
  }
  /** Unbinds HTMLElement events to mask internal events */
  unbindEvents() {
    this.input.removeEventListener("keydown", this._onKeydown), this.input.removeEventListener("input", this._onInput), this.input.removeEventListener("beforeinput", this._onBeforeinput), this.input.removeEventListener("compositionend", this._onCompositionEnd), this.input.removeEventListener("drop", this._handlers.drop), this.input.removeEventListener("click", this._handlers.click), this.input.removeEventListener("focus", this._handlers.focus), this.input.removeEventListener("blur", this._handlers.commit), this._handlers = {};
  }
}
ir.HTMLMaskElement = lU;
class Yye extends lU {
  /** InputElement to use mask on */
  constructor(a) {
    super(a), this.input = a;
  }
  /** Returns InputElement selection start */
  get _unsafeSelectionStart() {
    return this.input.selectionStart != null ? this.input.selectionStart : this.value.length;
  }
  /** Returns InputElement selection end */
  get _unsafeSelectionEnd() {
    return this.input.selectionEnd;
  }
  /** Sets InputElement selection */
  _unsafeSelect(a, c) {
    this.input.setSelectionRange(a, c);
  }
  get value() {
    return this.input.value;
  }
  set value(a) {
    this.input.value = a;
  }
}
ir.HTMLMaskElement = lU;
class rme extends lU {
  /** Returns HTMLElement selection start */
  get _unsafeSelectionStart() {
    const a = this.rootElement, c = a.getSelection && a.getSelection(), f = c && c.anchorOffset, g = c && c.focusOffset;
    return g == null || f == null || f < g ? f : g;
  }
  /** Returns HTMLElement selection end */
  get _unsafeSelectionEnd() {
    const a = this.rootElement, c = a.getSelection && a.getSelection(), f = c && c.anchorOffset, g = c && c.focusOffset;
    return g == null || f == null || f > g ? f : g;
  }
  /** Sets HTMLElement selection */
  _unsafeSelect(a, c) {
    if (!this.rootElement.createRange) return;
    const f = this.rootElement.createRange();
    f.setStart(this.input.firstChild || this.input, a), f.setEnd(this.input.lastChild || this.input, c);
    const g = this.rootElement, x = g.getSelection && g.getSelection();
    x && (x.removeAllRanges(), x.addRange(f));
  }
  /** HTMLElement value */
  get value() {
    return this.input.textContent || "";
  }
  set value(a) {
    this.input.textContent = a;
  }
}
ir.HTMLContenteditableMaskElement = rme;
class cU {
  constructor() {
    this.states = [], this.currentIndex = 0;
  }
  get currentState() {
    return this.states[this.currentIndex];
  }
  get isEmpty() {
    return this.states.length === 0;
  }
  push(a) {
    this.currentIndex < this.states.length - 1 && (this.states.length = this.currentIndex + 1), this.states.push(a), this.states.length > cU.MAX_LENGTH && this.states.shift(), this.currentIndex = this.states.length - 1;
  }
  go(a) {
    return this.currentIndex = Math.min(Math.max(this.currentIndex + a, 0), this.states.length - 1), this.currentState;
  }
  undo() {
    return this.go(-1);
  }
  redo() {
    return this.go(1);
  }
  clear() {
    this.states.length = 0, this.currentIndex = 0;
  }
}
cU.MAX_LENGTH = 100;
class Xye {
  /**
    View element
  */
  /** Internal {@link Masked} model */
  constructor(a, c) {
    this.el = a instanceof Use ? a : a.isContentEditable && a.tagName !== "INPUT" && a.tagName !== "TEXTAREA" ? new rme(a) : new Yye(a), this.masked = j0(c), this._listeners = {}, this._value = "", this._unmaskedValue = "", this._rawInputValue = "", this.history = new cU(), this._saveSelection = this._saveSelection.bind(this), this._onInput = this._onInput.bind(this), this._onChange = this._onChange.bind(this), this._onDrop = this._onDrop.bind(this), this._onFocus = this._onFocus.bind(this), this._onClick = this._onClick.bind(this), this._onUndo = this._onUndo.bind(this), this._onRedo = this._onRedo.bind(this), this.alignCursor = this.alignCursor.bind(this), this.alignCursorFriendly = this.alignCursorFriendly.bind(this), this._bindEvents(), this.updateValue(), this._onChange();
  }
  maskEquals(a) {
    var c;
    return a == null || ((c = this.masked) == null ? void 0 : c.maskEquals(a));
  }
  /** Masked */
  get mask() {
    return this.masked.mask;
  }
  set mask(a) {
    if (this.maskEquals(a)) return;
    if (!(a instanceof ir.Masked) && this.masked.constructor === sme(a)) {
      this.masked.updateOptions({
        mask: a
      });
      return;
    }
    const c = a instanceof ir.Masked ? a : j0({
      mask: a
    });
    c.unmaskedValue = this.masked.unmaskedValue, this.masked = c;
  }
  /** Raw value */
  get value() {
    return this._value;
  }
  set value(a) {
    this.value !== a && (this.masked.value = a, this.updateControl("auto"));
  }
  /** Unmasked value */
  get unmaskedValue() {
    return this._unmaskedValue;
  }
  set unmaskedValue(a) {
    this.unmaskedValue !== a && (this.masked.unmaskedValue = a, this.updateControl("auto"));
  }
  /** Raw input value */
  get rawInputValue() {
    return this._rawInputValue;
  }
  set rawInputValue(a) {
    this.rawInputValue !== a && (this.masked.rawInputValue = a, this.updateControl(), this.alignCursor());
  }
  /** Typed unmasked value */
  get typedValue() {
    return this.masked.typedValue;
  }
  set typedValue(a) {
    this.masked.typedValueEquals(a) || (this.masked.typedValue = a, this.updateControl("auto"));
  }
  /** Display value */
  get displayValue() {
    return this.masked.displayValue;
  }
  /** Starts listening to element events */
  _bindEvents() {
    this.el.bindEvents({
      selectionChange: this._saveSelection,
      input: this._onInput,
      drop: this._onDrop,
      click: this._onClick,
      focus: this._onFocus,
      commit: this._onChange,
      undo: this._onUndo,
      redo: this._onRedo
    });
  }
  /** Stops listening to element events */
  _unbindEvents() {
    this.el && this.el.unbindEvents();
  }
  /** Fires custom event */
  _fireEvent(a, c) {
    const f = this._listeners[a];
    f && f.forEach((g) => g(c));
  }
  /** Current selection start */
  get selectionStart() {
    return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;
  }
  /** Current cursor position */
  get cursorPos() {
    return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;
  }
  set cursorPos(a) {
    !this.el || !this.el.isActive || (this.el.select(a, a), this._saveSelection());
  }
  /** Stores current selection */
  _saveSelection() {
    this.displayValue !== this.el.value && console.warn("Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly."), this._selection = {
      start: this.selectionStart,
      end: this.cursorPos
    };
  }
  /** Syncronizes model value from view */
  updateValue() {
    this.masked.value = this.el.value, this._value = this.masked.value, this._unmaskedValue = this.masked.unmaskedValue, this._rawInputValue = this.masked.rawInputValue;
  }
  /** Syncronizes view from model value, fires change events */
  updateControl(a) {
    const c = this.masked.unmaskedValue, f = this.masked.value, g = this.masked.rawInputValue, x = this.displayValue, k = this.unmaskedValue !== c || this.value !== f || this._rawInputValue !== g;
    this._unmaskedValue = c, this._value = f, this._rawInputValue = g, this.el.value !== x && (this.el.value = x), a === "auto" ? this.alignCursor() : a != null && (this.cursorPos = a), k && this._fireChangeEvents(), !this._historyChanging && (k || this.history.isEmpty) && this.history.push({
      unmaskedValue: c,
      selection: {
        start: this.selectionStart,
        end: this.cursorPos
      }
    });
  }
  /** Updates options with deep equal check, recreates {@link Masked} model if mask type changes */
  updateOptions(a) {
    const {
      mask: c,
      ...f
    } = a, g = !this.maskEquals(c), x = this.masked.optionsIsChanged(f);
    g && (this.mask = c), x && this.masked.updateOptions(f), (g || x) && this.updateControl();
  }
  /** Updates cursor */
  updateCursor(a) {
    a != null && (this.cursorPos = a, this._delayUpdateCursor(a));
  }
  /** Delays cursor update to support mobile browsers */
  _delayUpdateCursor(a) {
    this._abortUpdateCursor(), this._changingCursorPos = a, this._cursorChanging = setTimeout(() => {
      this.el && (this.cursorPos = this._changingCursorPos, this._abortUpdateCursor());
    }, 10);
  }
  /** Fires custom events */
  _fireChangeEvents() {
    this._fireEvent("accept", this._inputEvent), this.masked.isComplete && this._fireEvent("complete", this._inputEvent);
  }
  /** Aborts delayed cursor update */
  _abortUpdateCursor() {
    this._cursorChanging && (clearTimeout(this._cursorChanging), delete this._cursorChanging);
  }
  /** Aligns cursor to nearest available position */
  alignCursor() {
    this.cursorPos = this.masked.nearestInputPos(this.masked.nearestInputPos(this.cursorPos, As.LEFT));
  }
  /** Aligns cursor only if selection is empty */
  alignCursorFriendly() {
    this.selectionStart === this.cursorPos && this.alignCursor();
  }
  /** Adds listener on custom event */
  on(a, c) {
    return this._listeners[a] || (this._listeners[a] = []), this._listeners[a].push(c), this;
  }
  /** Removes custom event listener */
  off(a, c) {
    if (!this._listeners[a]) return this;
    if (!c)
      return delete this._listeners[a], this;
    const f = this._listeners[a].indexOf(c);
    return f >= 0 && this._listeners[a].splice(f, 1), this;
  }
  /** Handles view input event */
  _onInput(a) {
    this._inputEvent = a, this._abortUpdateCursor();
    const c = new qye({
      // new state
      value: this.el.value,
      cursorPos: this.cursorPos,
      // old state
      oldValue: this.displayValue,
      oldSelection: this._selection
    }), f = this.masked.rawInputValue, g = this.masked.splice(c.startChangePos, c.removed.length, c.inserted, c.removeDirection, {
      input: !0,
      raw: !0
    }).offset, x = f === this.masked.rawInputValue ? c.removeDirection : As.NONE;
    let k = this.masked.nearestInputPos(c.startChangePos + g, x);
    x !== As.NONE && (k = this.masked.nearestInputPos(k, As.NONE)), this.updateControl(k), delete this._inputEvent;
  }
  /** Handles view change event and commits model value */
  _onChange() {
    this.displayValue !== this.el.value && this.updateValue(), this.masked.doCommit(), this.updateControl(), this._saveSelection();
  }
  /** Handles view drop event, prevents by default */
  _onDrop(a) {
    a.preventDefault(), a.stopPropagation();
  }
  /** Restore last selection on focus */
  _onFocus(a) {
    this.alignCursorFriendly();
  }
  /** Restore last selection on focus */
  _onClick(a) {
    this.alignCursorFriendly();
  }
  _onUndo() {
    this._applyHistoryState(this.history.undo());
  }
  _onRedo() {
    this._applyHistoryState(this.history.redo());
  }
  _applyHistoryState(a) {
    a && (this._historyChanging = !0, this.unmaskedValue = a.unmaskedValue, this.el.select(a.selection.start, a.selection.end), this._saveSelection(), this._historyChanging = !1);
  }
  /** Unbind view events and removes element reference */
  destroy() {
    this._unbindEvents(), this._listeners.length = 0, delete this.el;
  }
}
ir.InputMask = Xye;
class Br {
  /** Inserted symbols */
  /** Additional offset if any changes occurred before tail */
  /** Raw inserted is used by dynamic mask */
  /** Can skip chars */
  static normalize(a) {
    return Array.isArray(a) ? a : [a, new Br()];
  }
  constructor(a) {
    Object.assign(this, {
      inserted: "",
      rawInserted: "",
      tailShift: 0,
      skip: !1
    }, a);
  }
  /** Aggregate changes */
  aggregate(a) {
    return this.inserted += a.inserted, this.rawInserted += a.rawInserted, this.tailShift += a.tailShift, this.skip = this.skip || a.skip, this;
  }
  /** Total offset considering all changes */
  get offset() {
    return this.tailShift + this.inserted.length;
  }
  get consumed() {
    return !!this.rawInserted || this.skip;
  }
  equals(a) {
    return this.inserted === a.inserted && this.tailShift === a.tailShift && this.rawInserted === a.rawInserted && this.skip === a.skip;
  }
}
ir.ChangeDetails = Br;
class Mb {
  /** Tail value as string */
  /** Tail start position */
  /** Start position */
  constructor(a, c, f) {
    a === void 0 && (a = ""), c === void 0 && (c = 0), this.value = a, this.from = c, this.stop = f;
  }
  toString() {
    return this.value;
  }
  extend(a) {
    this.value += String(a);
  }
  appendTo(a) {
    return a.append(this.toString(), {
      tail: !0
    }).aggregate(a._appendPlaceholder());
  }
  get state() {
    return {
      value: this.value,
      from: this.from,
      stop: this.stop
    };
  }
  set state(a) {
    Object.assign(this, a);
  }
  unshift(a) {
    if (!this.value.length || a != null && this.from >= a) return "";
    const c = this.value[0];
    return this.value = this.value.slice(1), c;
  }
  shift() {
    if (!this.value.length) return "";
    const a = this.value[this.value.length - 1];
    return this.value = this.value.slice(0, -1), a;
  }
}
class Gd {
  /** */
  /** */
  /** Transforms value before mask processing */
  /** Transforms each char before mask processing */
  /** Validates if value is acceptable */
  /** Does additional processing at the end of editing */
  /** Format typed value to string */
  /** Parse string to get typed value */
  /** Enable characters overwriting */
  /** */
  /** */
  /** */
  /** */
  constructor(a) {
    this._value = "", this._update({
      ...Gd.DEFAULTS,
      ...a
    }), this._initialized = !0;
  }
  /** Sets and applies new options */
  updateOptions(a) {
    this.optionsIsChanged(a) && this.withValueRefresh(this._update.bind(this, a));
  }
  /** Sets new options */
  _update(a) {
    Object.assign(this, a);
  }
  /** Mask state */
  get state() {
    return {
      _value: this.value,
      _rawInputValue: this.rawInputValue
    };
  }
  set state(a) {
    this._value = a._value;
  }
  /** Resets value */
  reset() {
    this._value = "";
  }
  get value() {
    return this._value;
  }
  set value(a) {
    this.resolve(a, {
      input: !0
    });
  }
  /** Resolve new value */
  resolve(a, c) {
    c === void 0 && (c = {
      input: !0
    }), this.reset(), this.append(a, c, ""), this.doCommit();
  }
  get unmaskedValue() {
    return this.value;
  }
  set unmaskedValue(a) {
    this.resolve(a, {});
  }
  get typedValue() {
    return this.parse ? this.parse(this.value, this) : this.unmaskedValue;
  }
  set typedValue(a) {
    this.format ? this.value = this.format(a, this) : this.unmaskedValue = String(a);
  }
  /** Value that includes raw user input */
  get rawInputValue() {
    return this.extractInput(0, this.displayValue.length, {
      raw: !0
    });
  }
  set rawInputValue(a) {
    this.resolve(a, {
      raw: !0
    });
  }
  get displayValue() {
    return this.value;
  }
  get isComplete() {
    return !0;
  }
  get isFilled() {
    return this.isComplete;
  }
  /** Finds nearest input position in direction */
  nearestInputPos(a, c) {
    return a;
  }
  totalInputPositions(a, c) {
    return a === void 0 && (a = 0), c === void 0 && (c = this.displayValue.length), Math.min(this.displayValue.length, c - a);
  }
  /** Extracts value in range considering flags */
  extractInput(a, c, f) {
    return a === void 0 && (a = 0), c === void 0 && (c = this.displayValue.length), this.displayValue.slice(a, c);
  }
  /** Extracts tail in range */
  extractTail(a, c) {
    return a === void 0 && (a = 0), c === void 0 && (c = this.displayValue.length), new Mb(this.extractInput(a, c), a);
  }
  /** Appends tail */
  appendTail(a) {
    return $2(a) && (a = new Mb(String(a))), a.appendTo(this);
  }
  /** Appends char */
  _appendCharRaw(a, c) {
    return a ? (this._value += a, new Br({
      inserted: a,
      rawInserted: a
    })) : new Br();
  }
  /** Appends char */
  _appendChar(a, c, f) {
    c === void 0 && (c = {});
    const g = this.state;
    let x;
    if ([a, x] = this.doPrepareChar(a, c), a && (x = x.aggregate(this._appendCharRaw(a, c)), !x.rawInserted && this.autofix === "pad")) {
      const k = this.state;
      this.state = g;
      let A = this.pad(c);
      const N = this._appendCharRaw(a, c);
      A = A.aggregate(N), N.rawInserted || A.equals(x) ? x = A : this.state = k;
    }
    if (x.inserted) {
      let k, A = this.doValidate(c) !== !1;
      if (A && f != null) {
        const N = this.state;
        if (this.overwrite === !0) {
          k = f.state;
          for (let Z = 0; Z < x.rawInserted.length; ++Z)
            f.unshift(this.displayValue.length - x.tailShift);
        }
        let H = this.appendTail(f);
        if (A = H.rawInserted.length === f.toString().length, !(A && H.inserted) && this.overwrite === "shift") {
          this.state = N, k = f.state;
          for (let Z = 0; Z < x.rawInserted.length; ++Z)
            f.shift();
          H = this.appendTail(f), A = H.rawInserted.length === f.toString().length;
        }
        A && H.inserted && (this.state = N);
      }
      A || (x = new Br(), this.state = g, f && k && (f.state = k));
    }
    return x;
  }
  /** Appends optional placeholder at the end */
  _appendPlaceholder() {
    return new Br();
  }
  /** Appends optional eager placeholder at the end */
  _appendEager() {
    return new Br();
  }
  /** Appends symbols considering flags */
  append(a, c, f) {
    if (!$2(a)) throw new Error("value should be string");
    const g = $2(f) ? new Mb(String(f)) : f;
    c != null && c.tail && (c._beforeTailState = this.state);
    let x;
    [a, x] = this.doPrepare(a, c);
    for (let k = 0; k < a.length; ++k) {
      const A = this._appendChar(a[k], c, g);
      if (!A.rawInserted && !this.doSkipInvalid(a[k], c, g)) break;
      x.aggregate(A);
    }
    return (this.eager === !0 || this.eager === "append") && c != null && c.input && a && x.aggregate(this._appendEager()), g != null && (x.tailShift += this.appendTail(g).tailShift), x;
  }
  remove(a, c) {
    return a === void 0 && (a = 0), c === void 0 && (c = this.displayValue.length), this._value = this.displayValue.slice(0, a) + this.displayValue.slice(c), new Br();
  }
  /** Calls function and reapplies current value */
  withValueRefresh(a) {
    if (this._refreshing || !this._initialized) return a();
    this._refreshing = !0;
    const c = this.rawInputValue, f = this.value, g = a();
    return this.rawInputValue = c, this.value && this.value !== f && f.indexOf(this.value) === 0 && (this.append(f.slice(this.displayValue.length), {}, ""), this.doCommit()), delete this._refreshing, g;
  }
  runIsolated(a) {
    if (this._isolated || !this._initialized) return a(this);
    this._isolated = !0;
    const c = this.state, f = a(this);
    return this.state = c, delete this._isolated, f;
  }
  doSkipInvalid(a, c, f) {
    return !!this.skipInvalid;
  }
  /** Prepares string before mask processing */
  doPrepare(a, c) {
    return c === void 0 && (c = {}), Br.normalize(this.prepare ? this.prepare(a, this, c) : a);
  }
  /** Prepares each char before mask processing */
  doPrepareChar(a, c) {
    return c === void 0 && (c = {}), Br.normalize(this.prepareChar ? this.prepareChar(a, this, c) : a);
  }
  /** Validates if value is acceptable */
  doValidate(a) {
    return (!this.validate || this.validate(this.value, this, a)) && (!this.parent || this.parent.doValidate(a));
  }
  /** Does additional processing at the end of editing */
  doCommit() {
    this.commit && this.commit(this.value, this);
  }
  splice(a, c, f, g, x) {
    f === void 0 && (f = ""), g === void 0 && (g = As.NONE), x === void 0 && (x = {
      input: !0
    });
    const k = a + c, A = this.extractTail(k), N = this.eager === !0 || this.eager === "remove";
    let H;
    N && (g = Gye(g), H = this.extractInput(0, k, {
      raw: !0
    }));
    let Z = a;
    const K = new Br();
    if (g !== As.NONE && (Z = this.nearestInputPos(a, c > 1 && a !== 0 && !N ? As.NONE : g), K.tailShift = Z - a), K.aggregate(this.remove(Z)), N && g !== As.NONE && H === this.rawInputValue)
      if (g === As.FORCE_LEFT) {
        let J;
        for (; H === this.rawInputValue && (J = this.displayValue.length); )
          K.aggregate(new Br({
            tailShift: -1
          })).aggregate(this.remove(J - 1));
      } else g === As.FORCE_RIGHT && A.unshift();
    return K.aggregate(this.append(f, x, A));
  }
  maskEquals(a) {
    return this.mask === a;
  }
  optionsIsChanged(a) {
    return !CV(this, a);
  }
  typedValueEquals(a) {
    const c = this.typedValue;
    return a === c || Gd.EMPTY_VALUES.includes(a) && Gd.EMPTY_VALUES.includes(c) || (this.format ? this.format(a, this) === this.format(this.typedValue, this) : !1);
  }
  pad(a) {
    return new Br();
  }
}
Gd.DEFAULTS = {
  skipInvalid: !0
};
Gd.EMPTY_VALUES = [void 0, null, ""];
ir.Masked = Gd;
class Lk {
  /** */
  constructor(a, c) {
    a === void 0 && (a = []), c === void 0 && (c = 0), this.chunks = a, this.from = c;
  }
  toString() {
    return this.chunks.map(String).join("");
  }
  extend(a) {
    if (!String(a)) return;
    a = $2(a) ? new Mb(String(a)) : a;
    const c = this.chunks[this.chunks.length - 1], f = c && // if stops are same or tail has no stop
    (c.stop === a.stop || a.stop == null) && // if tail chunk goes just after last chunk
    a.from === c.from + c.toString().length;
    if (a instanceof Mb)
      f ? c.extend(a.toString()) : this.chunks.push(a);
    else if (a instanceof Lk) {
      if (a.stop == null) {
        let g;
        for (; a.chunks.length && a.chunks[0].stop == null; )
          g = a.chunks.shift(), g.from += a.from, this.extend(g);
      }
      a.toString() && (a.stop = a.blockIndex, this.chunks.push(a));
    }
  }
  appendTo(a) {
    if (!(a instanceof ir.MaskedPattern))
      return new Mb(this.toString()).appendTo(a);
    const c = new Br();
    for (let f = 0; f < this.chunks.length; ++f) {
      const g = this.chunks[f], x = a._mapPosToBlock(a.displayValue.length), k = g.stop;
      let A;
      if (k != null && // if block not found or stop is behind lastBlock
      (!x || x.index <= k) && ((g instanceof Lk || // for continuous block also check if stop is exist
      a._stops.indexOf(k) >= 0) && c.aggregate(a._appendPlaceholder(k)), A = g instanceof Lk && a._blocks[k]), A) {
        const N = A.appendTail(g);
        c.aggregate(N);
        const H = g.toString().slice(N.rawInserted.length);
        H && c.aggregate(a.append(H, {
          tail: !0
        }));
      } else
        c.aggregate(a.append(g.toString(), {
          tail: !0
        }));
    }
    return c;
  }
  get state() {
    return {
      chunks: this.chunks.map((a) => a.state),
      from: this.from,
      stop: this.stop,
      blockIndex: this.blockIndex
    };
  }
  set state(a) {
    const {
      chunks: c,
      ...f
    } = a;
    Object.assign(this, f), this.chunks = c.map((g) => {
      const x = "chunks" in g ? new Lk() : new Mb();
      return x.state = g, x;
    });
  }
  unshift(a) {
    if (!this.chunks.length || a != null && this.from >= a) return "";
    const c = a != null ? a - this.from : a;
    let f = 0;
    for (; f < this.chunks.length; ) {
      const g = this.chunks[f], x = g.unshift(c);
      if (g.toString()) {
        if (!x) break;
        ++f;
      } else
        this.chunks.splice(f, 1);
      if (x) return x;
    }
    return "";
  }
  shift() {
    if (!this.chunks.length) return "";
    let a = this.chunks.length - 1;
    for (; 0 <= a; ) {
      const c = this.chunks[a], f = c.shift();
      if (c.toString()) {
        if (!f) break;
        --a;
      } else
        this.chunks.splice(a, 1);
      if (f) return f;
    }
    return "";
  }
}
class Qye {
  constructor(a, c) {
    this.masked = a, this._log = [];
    const {
      offset: f,
      index: g
    } = a._mapPosToBlock(c) || (c < 0 ? (
      // first
      {
        index: 0,
        offset: 0
      }
    ) : (
      // last
      {
        index: this.masked._blocks.length,
        offset: 0
      }
    ));
    this.offset = f, this.index = g, this.ok = !1;
  }
  get block() {
    return this.masked._blocks[this.index];
  }
  get pos() {
    return this.masked._blockStartPos(this.index) + this.offset;
  }
  get state() {
    return {
      index: this.index,
      offset: this.offset,
      ok: this.ok
    };
  }
  set state(a) {
    Object.assign(this, a);
  }
  pushState() {
    this._log.push(this.state);
  }
  popState() {
    const a = this._log.pop();
    return a && (this.state = a), a;
  }
  bindBlock() {
    this.block || (this.index < 0 && (this.index = 0, this.offset = 0), this.index >= this.masked._blocks.length && (this.index = this.masked._blocks.length - 1, this.offset = this.block.displayValue.length));
  }
  _pushLeft(a) {
    for (this.pushState(), this.bindBlock(); 0 <= this.index; --this.index, this.offset = ((c = this.block) == null ? void 0 : c.displayValue.length) || 0) {
      var c;
      if (a()) return this.ok = !0;
    }
    return this.ok = !1;
  }
  _pushRight(a) {
    for (this.pushState(), this.bindBlock(); this.index < this.masked._blocks.length; ++this.index, this.offset = 0)
      if (a()) return this.ok = !0;
    return this.ok = !1;
  }
  pushLeftBeforeFilled() {
    return this._pushLeft(() => {
      if (!(this.block.isFixed || !this.block.value) && (this.offset = this.block.nearestInputPos(this.offset, As.FORCE_LEFT), this.offset !== 0))
        return !0;
    });
  }
  pushLeftBeforeInput() {
    return this._pushLeft(() => {
      if (!this.block.isFixed)
        return this.offset = this.block.nearestInputPos(this.offset, As.LEFT), !0;
    });
  }
  pushLeftBeforeRequired() {
    return this._pushLeft(() => {
      if (!(this.block.isFixed || this.block.isOptional && !this.block.value))
        return this.offset = this.block.nearestInputPos(this.offset, As.LEFT), !0;
    });
  }
  pushRightBeforeFilled() {
    return this._pushRight(() => {
      if (!(this.block.isFixed || !this.block.value) && (this.offset = this.block.nearestInputPos(this.offset, As.FORCE_RIGHT), this.offset !== this.block.value.length))
        return !0;
    });
  }
  pushRightBeforeInput() {
    return this._pushRight(() => {
      if (!this.block.isFixed)
        return this.offset = this.block.nearestInputPos(this.offset, As.NONE), !0;
    });
  }
  pushRightBeforeRequired() {
    return this._pushRight(() => {
      if (!(this.block.isFixed || this.block.isOptional && !this.block.value))
        return this.offset = this.block.nearestInputPos(this.offset, As.NONE), !0;
    });
  }
}
class ame {
  /** */
  /** */
  /** */
  /** */
  /** */
  /** */
  constructor(a) {
    Object.assign(this, a), this._value = "", this.isFixed = !0;
  }
  get value() {
    return this._value;
  }
  get unmaskedValue() {
    return this.isUnmasking ? this.value : "";
  }
  get rawInputValue() {
    return this._isRawInput ? this.value : "";
  }
  get displayValue() {
    return this.value;
  }
  reset() {
    this._isRawInput = !1, this._value = "";
  }
  remove(a, c) {
    return a === void 0 && (a = 0), c === void 0 && (c = this._value.length), this._value = this._value.slice(0, a) + this._value.slice(c), this._value || (this._isRawInput = !1), new Br();
  }
  nearestInputPos(a, c) {
    c === void 0 && (c = As.NONE);
    const f = 0, g = this._value.length;
    switch (c) {
      case As.LEFT:
      case As.FORCE_LEFT:
        return f;
      case As.NONE:
      case As.RIGHT:
      case As.FORCE_RIGHT:
      default:
        return g;
    }
  }
  totalInputPositions(a, c) {
    return a === void 0 && (a = 0), c === void 0 && (c = this._value.length), this._isRawInput ? c - a : 0;
  }
  extractInput(a, c, f) {
    return a === void 0 && (a = 0), c === void 0 && (c = this._value.length), f === void 0 && (f = {}), f.raw && this._isRawInput && this._value.slice(a, c) || "";
  }
  get isComplete() {
    return !0;
  }
  get isFilled() {
    return !!this._value;
  }
  _appendChar(a, c) {
    if (c === void 0 && (c = {}), this.isFilled) return new Br();
    const f = this.eager === !0 || this.eager === "append", x = this.char === a && (this.isUnmasking || c.input || c.raw) && (!c.raw || !f) && !c.tail, k = new Br({
      inserted: this.char,
      rawInserted: x ? this.char : ""
    });
    return this._value = this.char, this._isRawInput = x && (c.raw || c.input), k;
  }
  _appendEager() {
    return this._appendChar(this.char, {
      tail: !0
    });
  }
  _appendPlaceholder() {
    const a = new Br();
    return this.isFilled || (this._value = a.inserted = this.char), a;
  }
  extractTail() {
    return new Mb("");
  }
  appendTail(a) {
    return $2(a) && (a = new Mb(String(a))), a.appendTo(this);
  }
  append(a, c, f) {
    const g = this._appendChar(a[0], c);
    return f != null && (g.tailShift += this.appendTail(f).tailShift), g;
  }
  doCommit() {
  }
  get state() {
    return {
      _value: this._value,
      _rawInputValue: this.rawInputValue
    };
  }
  set state(a) {
    this._value = a._value, this._isRawInput = !!a._rawInputValue;
  }
  pad(a) {
    return this._appendPlaceholder();
  }
}
class SV {
  /** */
  /** */
  /** */
  /** */
  /** */
  /** */
  /** */
  /** */
  constructor(a) {
    const {
      parent: c,
      isOptional: f,
      placeholderChar: g,
      displayChar: x,
      lazy: k,
      eager: A,
      ...N
    } = a;
    this.masked = j0(N), Object.assign(this, {
      parent: c,
      isOptional: f,
      placeholderChar: g,
      displayChar: x,
      lazy: k,
      eager: A
    });
  }
  reset() {
    this.isFilled = !1, this.masked.reset();
  }
  remove(a, c) {
    return a === void 0 && (a = 0), c === void 0 && (c = this.value.length), a === 0 && c >= 1 ? (this.isFilled = !1, this.masked.remove(a, c)) : new Br();
  }
  get value() {
    return this.masked.value || (this.isFilled && !this.isOptional ? this.placeholderChar : "");
  }
  get unmaskedValue() {
    return this.masked.unmaskedValue;
  }
  get rawInputValue() {
    return this.masked.rawInputValue;
  }
  get displayValue() {
    return this.masked.value && this.displayChar || this.value;
  }
  get isComplete() {
    return !!this.masked.value || this.isOptional;
  }
  _appendChar(a, c) {
    if (c === void 0 && (c = {}), this.isFilled) return new Br();
    const f = this.masked.state;
    let g = this.masked._appendChar(a, this.currentMaskFlags(c));
    return g.inserted && this.doValidate(c) === !1 && (g = new Br(), this.masked.state = f), !g.inserted && !this.isOptional && !this.lazy && !c.input && (g.inserted = this.placeholderChar), g.skip = !g.inserted && !this.isOptional, this.isFilled = !!g.inserted, g;
  }
  append(a, c, f) {
    return this.masked.append(a, this.currentMaskFlags(c), f);
  }
  _appendPlaceholder() {
    return this.isFilled || this.isOptional ? new Br() : (this.isFilled = !0, new Br({
      inserted: this.placeholderChar
    }));
  }
  _appendEager() {
    return new Br();
  }
  extractTail(a, c) {
    return this.masked.extractTail(a, c);
  }
  appendTail(a) {
    return this.masked.appendTail(a);
  }
  extractInput(a, c, f) {
    return a === void 0 && (a = 0), c === void 0 && (c = this.value.length), this.masked.extractInput(a, c, f);
  }
  nearestInputPos(a, c) {
    c === void 0 && (c = As.NONE);
    const f = 0, g = this.value.length, x = Math.min(Math.max(a, f), g);
    switch (c) {
      case As.LEFT:
      case As.FORCE_LEFT:
        return this.isComplete ? x : f;
      case As.RIGHT:
      case As.FORCE_RIGHT:
        return this.isComplete ? x : g;
      case As.NONE:
      default:
        return x;
    }
  }
  totalInputPositions(a, c) {
    return a === void 0 && (a = 0), c === void 0 && (c = this.value.length), this.value.slice(a, c).length;
  }
  doValidate(a) {
    return this.masked.doValidate(this.currentMaskFlags(a)) && (!this.parent || this.parent.doValidate(this.currentMaskFlags(a)));
  }
  doCommit() {
    this.masked.doCommit();
  }
  get state() {
    return {
      _value: this.value,
      _rawInputValue: this.rawInputValue,
      masked: this.masked.state,
      isFilled: this.isFilled
    };
  }
  set state(a) {
    this.masked.state = a.masked, this.isFilled = a.isFilled;
  }
  currentMaskFlags(a) {
    var c;
    return {
      ...a,
      _beforeTailState: (a == null || (c = a._beforeTailState) == null ? void 0 : c.masked) || (a == null ? void 0 : a._beforeTailState)
    };
  }
  pad(a) {
    return new Br();
  }
}
SV.DEFAULT_DEFINITIONS = {
  0: /\d/,
  a: /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
  // http://stackoverflow.com/a/22075070
  "*": /./
};
class Jye extends Gd {
  /** */
  /** Enable characters overwriting */
  /** */
  /** */
  /** */
  updateOptions(a) {
    super.updateOptions(a);
  }
  _update(a) {
    const c = a.mask;
    c && (a.validate = (f) => f.search(c) >= 0), super._update(a);
  }
}
ir.MaskedRegExp = Jye;
class qd extends Gd {
  /** */
  /** */
  /** Single char for empty input */
  /** Single char for filled input */
  /** Show placeholder only when needed */
  /** Enable characters overwriting */
  /** */
  /** */
  /** */
  constructor(a) {
    super({
      ...qd.DEFAULTS,
      ...a,
      definitions: Object.assign({}, SV.DEFAULT_DEFINITIONS, a == null ? void 0 : a.definitions)
    });
  }
  updateOptions(a) {
    super.updateOptions(a);
  }
  _update(a) {
    a.definitions = Object.assign({}, this.definitions, a.definitions), super._update(a), this._rebuildMask();
  }
  _rebuildMask() {
    const a = this.definitions;
    this._blocks = [], this.exposeBlock = void 0, this._stops = [], this._maskedBlocks = {};
    const c = this.mask;
    if (!c || !a) return;
    let f = !1, g = !1;
    for (let x = 0; x < c.length; ++x) {
      if (this.blocks) {
        const H = c.slice(x), Z = Object.keys(this.blocks).filter((J) => H.indexOf(J) === 0);
        Z.sort((J, pe) => pe.length - J.length);
        const K = Z[0];
        if (K) {
          const {
            expose: J,
            repeat: pe,
            ...Se
          } = kI(this.blocks[K]), be = {
            lazy: this.lazy,
            eager: this.eager,
            placeholderChar: this.placeholderChar,
            displayChar: this.displayChar,
            overwrite: this.overwrite,
            autofix: this.autofix,
            ...Se,
            repeat: pe,
            parent: this
          }, ye = pe != null ? new ir.RepeatBlock(
            be
            /* TODO */
          ) : j0(be);
          ye && (this._blocks.push(ye), J && (this.exposeBlock = ye), this._maskedBlocks[K] || (this._maskedBlocks[K] = []), this._maskedBlocks[K].push(this._blocks.length - 1)), x += K.length - 1;
          continue;
        }
      }
      let k = c[x], A = k in a;
      if (k === qd.STOP_CHAR) {
        this._stops.push(this._blocks.length);
        continue;
      }
      if (k === "{" || k === "}") {
        f = !f;
        continue;
      }
      if (k === "[" || k === "]") {
        g = !g;
        continue;
      }
      if (k === qd.ESCAPE_CHAR) {
        if (++x, k = c[x], !k) break;
        A = !1;
      }
      const N = A ? new SV({
        isOptional: g,
        lazy: this.lazy,
        eager: this.eager,
        placeholderChar: this.placeholderChar,
        displayChar: this.displayChar,
        ...kI(a[k]),
        parent: this
      }) : new ame({
        char: k,
        eager: this.eager,
        isUnmasking: f
      });
      this._blocks.push(N);
    }
  }
  get state() {
    return {
      ...super.state,
      _blocks: this._blocks.map((a) => a.state)
    };
  }
  set state(a) {
    if (!a) {
      this.reset();
      return;
    }
    const {
      _blocks: c,
      ...f
    } = a;
    this._blocks.forEach((g, x) => g.state = c[x]), super.state = f;
  }
  reset() {
    super.reset(), this._blocks.forEach((a) => a.reset());
  }
  get isComplete() {
    return this.exposeBlock ? this.exposeBlock.isComplete : this._blocks.every((a) => a.isComplete);
  }
  get isFilled() {
    return this._blocks.every((a) => a.isFilled);
  }
  get isFixed() {
    return this._blocks.every((a) => a.isFixed);
  }
  get isOptional() {
    return this._blocks.every((a) => a.isOptional);
  }
  doCommit() {
    this._blocks.forEach((a) => a.doCommit()), super.doCommit();
  }
  get unmaskedValue() {
    return this.exposeBlock ? this.exposeBlock.unmaskedValue : this._blocks.reduce((a, c) => a += c.unmaskedValue, "");
  }
  set unmaskedValue(a) {
    if (this.exposeBlock) {
      const c = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);
      this.exposeBlock.unmaskedValue = a, this.appendTail(c), this.doCommit();
    } else super.unmaskedValue = a;
  }
  get value() {
    return this.exposeBlock ? this.exposeBlock.value : (
      // TODO return _value when not in change?
      this._blocks.reduce((a, c) => a += c.value, "")
    );
  }
  set value(a) {
    if (this.exposeBlock) {
      const c = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);
      this.exposeBlock.value = a, this.appendTail(c), this.doCommit();
    } else super.value = a;
  }
  get typedValue() {
    return this.exposeBlock ? this.exposeBlock.typedValue : super.typedValue;
  }
  set typedValue(a) {
    if (this.exposeBlock) {
      const c = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);
      this.exposeBlock.typedValue = a, this.appendTail(c), this.doCommit();
    } else super.typedValue = a;
  }
  get displayValue() {
    return this._blocks.reduce((a, c) => a += c.displayValue, "");
  }
  appendTail(a) {
    return super.appendTail(a).aggregate(this._appendPlaceholder());
  }
  _appendEager() {
    var a;
    const c = new Br();
    let f = (a = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : a.index;
    if (f == null) return c;
    this._blocks[f].isFilled && ++f;
    for (let g = f; g < this._blocks.length; ++g) {
      const x = this._blocks[g]._appendEager();
      if (!x.inserted) break;
      c.aggregate(x);
    }
    return c;
  }
  _appendCharRaw(a, c) {
    c === void 0 && (c = {});
    const f = this._mapPosToBlock(this.displayValue.length), g = new Br();
    if (!f) return g;
    for (let k = f.index, A; A = this._blocks[k]; ++k) {
      var x;
      const N = A._appendChar(a, {
        ...c,
        _beforeTailState: (x = c._beforeTailState) == null || (x = x._blocks) == null ? void 0 : x[k]
      });
      if (g.aggregate(N), N.consumed) break;
    }
    return g;
  }
  extractTail(a, c) {
    a === void 0 && (a = 0), c === void 0 && (c = this.displayValue.length);
    const f = new Lk();
    return a === c || this._forEachBlocksInRange(a, c, (g, x, k, A) => {
      const N = g.extractTail(k, A);
      N.stop = this._findStopBefore(x), N.from = this._blockStartPos(x), N instanceof Lk && (N.blockIndex = x), f.extend(N);
    }), f;
  }
  extractInput(a, c, f) {
    if (a === void 0 && (a = 0), c === void 0 && (c = this.displayValue.length), f === void 0 && (f = {}), a === c) return "";
    let g = "";
    return this._forEachBlocksInRange(a, c, (x, k, A, N) => {
      g += x.extractInput(A, N, f);
    }), g;
  }
  _findStopBefore(a) {
    let c;
    for (let f = 0; f < this._stops.length; ++f) {
      const g = this._stops[f];
      if (g <= a) c = g;
      else break;
    }
    return c;
  }
  /** Appends placeholder depending on laziness */
  _appendPlaceholder(a) {
    const c = new Br();
    if (this.lazy && a == null) return c;
    const f = this._mapPosToBlock(this.displayValue.length);
    if (!f) return c;
    const g = f.index, x = a ?? this._blocks.length;
    return this._blocks.slice(g, x).forEach((k) => {
      if (!k.lazy || a != null) {
        var A;
        c.aggregate(k._appendPlaceholder((A = k._blocks) == null ? void 0 : A.length));
      }
    }), c;
  }
  /** Finds block in pos */
  _mapPosToBlock(a) {
    let c = "";
    for (let f = 0; f < this._blocks.length; ++f) {
      const g = this._blocks[f], x = c.length;
      if (c += g.displayValue, a <= c.length)
        return {
          index: f,
          offset: a - x
        };
    }
  }
  _blockStartPos(a) {
    return this._blocks.slice(0, a).reduce((c, f) => c += f.displayValue.length, 0);
  }
  _forEachBlocksInRange(a, c, f) {
    c === void 0 && (c = this.displayValue.length);
    const g = this._mapPosToBlock(a);
    if (g) {
      const x = this._mapPosToBlock(c), k = x && g.index === x.index, A = g.offset, N = x && k ? x.offset : this._blocks[g.index].displayValue.length;
      if (f(this._blocks[g.index], g.index, A, N), x && !k) {
        for (let H = g.index + 1; H < x.index; ++H)
          f(this._blocks[H], H, 0, this._blocks[H].displayValue.length);
        f(this._blocks[x.index], x.index, 0, x.offset);
      }
    }
  }
  remove(a, c) {
    a === void 0 && (a = 0), c === void 0 && (c = this.displayValue.length);
    const f = super.remove(a, c);
    return this._forEachBlocksInRange(a, c, (g, x, k, A) => {
      f.aggregate(g.remove(k, A));
    }), f;
  }
  nearestInputPos(a, c) {
    if (c === void 0 && (c = As.NONE), !this._blocks.length) return 0;
    const f = new Qye(this, a);
    if (c === As.NONE)
      return f.pushRightBeforeInput() || (f.popState(), f.pushLeftBeforeInput()) ? f.pos : this.displayValue.length;
    if (c === As.LEFT || c === As.FORCE_LEFT) {
      if (c === As.LEFT) {
        if (f.pushRightBeforeFilled(), f.ok && f.pos === a) return a;
        f.popState();
      }
      if (f.pushLeftBeforeInput(), f.pushLeftBeforeRequired(), f.pushLeftBeforeFilled(), c === As.LEFT) {
        if (f.pushRightBeforeInput(), f.pushRightBeforeRequired(), f.ok && f.pos <= a || (f.popState(), f.ok && f.pos <= a)) return f.pos;
        f.popState();
      }
      return f.ok ? f.pos : c === As.FORCE_LEFT ? 0 : (f.popState(), f.ok || (f.popState(), f.ok) ? f.pos : 0);
    }
    return c === As.RIGHT || c === As.FORCE_RIGHT ? (f.pushRightBeforeInput(), f.pushRightBeforeRequired(), f.pushRightBeforeFilled() ? f.pos : c === As.FORCE_RIGHT ? this.displayValue.length : (f.popState(), f.ok || (f.popState(), f.ok) ? f.pos : this.nearestInputPos(a, As.LEFT))) : a;
  }
  totalInputPositions(a, c) {
    a === void 0 && (a = 0), c === void 0 && (c = this.displayValue.length);
    let f = 0;
    return this._forEachBlocksInRange(a, c, (g, x, k, A) => {
      f += g.totalInputPositions(k, A);
    }), f;
  }
  /** Get block by name */
  maskedBlock(a) {
    return this.maskedBlocks(a)[0];
  }
  /** Get all blocks by name */
  maskedBlocks(a) {
    const c = this._maskedBlocks[a];
    return c ? c.map((f) => this._blocks[f]) : [];
  }
  pad(a) {
    const c = new Br();
    return this._forEachBlocksInRange(0, this.displayValue.length, (f) => c.aggregate(f.pad(a))), c;
  }
}
qd.DEFAULTS = {
  ...Gd.DEFAULTS,
  lazy: !0,
  placeholderChar: "_"
};
qd.STOP_CHAR = "`";
qd.ESCAPE_CHAR = "\\";
qd.InputDefinition = SV;
qd.FixedDefinition = ame;
ir.MaskedPattern = qd;
class z9 extends qd {
  /**
    Optionally sets max length of pattern.
    Used when pattern length is longer then `to` param length. Pads zeros at start in this case.
  */
  /** Min bound */
  /** Max bound */
  get _matchFrom() {
    return this.maxLength - String(this.from).length;
  }
  constructor(a) {
    super(a);
  }
  updateOptions(a) {
    super.updateOptions(a);
  }
  _update(a) {
    const {
      to: c = this.to || 0,
      from: f = this.from || 0,
      maxLength: g = this.maxLength || 0,
      autofix: x = this.autofix,
      ...k
    } = a;
    this.to = c, this.from = f, this.maxLength = Math.max(String(c).length, g), this.autofix = x;
    const A = String(this.from).padStart(this.maxLength, "0"), N = String(this.to).padStart(this.maxLength, "0");
    let H = 0;
    for (; H < N.length && N[H] === A[H]; ) ++H;
    k.mask = N.slice(0, H).replace(/0/g, "\\0") + "0".repeat(this.maxLength - H), super._update(k);
  }
  get isComplete() {
    return super.isComplete && !!this.value;
  }
  boundaries(a) {
    let c = "", f = "";
    const [, g, x] = a.match(/^(\D*)(\d*)(\D*)/) || [];
    return x && (c = "0".repeat(g.length) + x, f = "9".repeat(g.length) + x), c = c.padEnd(this.maxLength, "0"), f = f.padEnd(this.maxLength, "9"), [c, f];
  }
  doPrepareChar(a, c) {
    c === void 0 && (c = {});
    let f;
    return [a, f] = super.doPrepareChar(a.replace(/\D/g, ""), c), a || (f.skip = !this.isComplete), [a, f];
  }
  _appendCharRaw(a, c) {
    if (c === void 0 && (c = {}), !this.autofix || this.value.length + 1 > this.maxLength) return super._appendCharRaw(a, c);
    const f = String(this.from).padStart(this.maxLength, "0"), g = String(this.to).padStart(this.maxLength, "0"), [x, k] = this.boundaries(this.value + a);
    return Number(k) < this.from ? super._appendCharRaw(f[this.value.length], c) : Number(x) > this.to ? !c.tail && this.autofix === "pad" && this.value.length + 1 < this.maxLength ? super._appendCharRaw(f[this.value.length], c).aggregate(this._appendCharRaw(a, c)) : super._appendCharRaw(g[this.value.length], c) : super._appendCharRaw(a, c);
  }
  doValidate(a) {
    const c = this.value;
    if (c.search(/[^0]/) === -1 && c.length <= this._matchFrom) return !0;
    const [g, x] = this.boundaries(c);
    return this.from <= Number(x) && Number(g) <= this.to && super.doValidate(a);
  }
  pad(a) {
    const c = new Br();
    if (this.value.length === this.maxLength) return c;
    const f = this.value, g = this.maxLength - this.value.length;
    if (g) {
      this.reset();
      for (let x = 0; x < g; ++x)
        c.aggregate(super._appendCharRaw("0", a));
      f.split("").forEach((x) => this._appendCharRaw(x));
    }
    return c;
  }
}
ir.MaskedRange = z9;
const exe = "d{.}`m{.}`Y";
class N0 extends qd {
  static extractPatternOptions(a) {
    const {
      mask: c,
      pattern: f,
      ...g
    } = a;
    return {
      ...g,
      mask: $2(c) ? c : f
    };
  }
  /** Pattern mask for date according to {@link MaskedDate#format} */
  /** Start date */
  /** End date */
  /** Format typed value to string */
  /** Parse string to get typed value */
  constructor(a) {
    super(N0.extractPatternOptions({
      ...N0.DEFAULTS,
      ...a
    }));
  }
  updateOptions(a) {
    super.updateOptions(a);
  }
  _update(a) {
    const {
      mask: c,
      pattern: f,
      blocks: g,
      ...x
    } = {
      ...N0.DEFAULTS,
      ...a
    }, k = Object.assign({}, N0.GET_DEFAULT_BLOCKS());
    a.min && (k.Y.from = a.min.getFullYear()), a.max && (k.Y.to = a.max.getFullYear()), a.min && a.max && k.Y.from === k.Y.to && (k.m.from = a.min.getMonth() + 1, k.m.to = a.max.getMonth() + 1, k.m.from === k.m.to && (k.d.from = a.min.getDate(), k.d.to = a.max.getDate())), Object.assign(k, this.blocks, g), super._update({
      ...x,
      mask: $2(c) ? c : f,
      blocks: k
    });
  }
  doValidate(a) {
    const c = this.date;
    return super.doValidate(a) && (!this.isComplete || this.isDateExist(this.value) && c != null && (this.min == null || this.min <= c) && (this.max == null || c <= this.max));
  }
  /** Checks if date is exists */
  isDateExist(a) {
    return this.format(this.parse(a, this), this).indexOf(a) >= 0;
  }
  /** Parsed Date */
  get date() {
    return this.typedValue;
  }
  set date(a) {
    this.typedValue = a;
  }
  get typedValue() {
    return this.isComplete ? super.typedValue : null;
  }
  set typedValue(a) {
    super.typedValue = a;
  }
  maskEquals(a) {
    return a === Date || super.maskEquals(a);
  }
  optionsIsChanged(a) {
    return super.optionsIsChanged(N0.extractPatternOptions(a));
  }
}
N0.GET_DEFAULT_BLOCKS = () => ({
  d: {
    mask: z9,
    from: 1,
    to: 31,
    maxLength: 2
  },
  m: {
    mask: z9,
    from: 1,
    to: 12,
    maxLength: 2
  },
  Y: {
    mask: z9,
    from: 1900,
    to: 9999
  }
});
N0.DEFAULTS = {
  ...qd.DEFAULTS,
  mask: Date,
  pattern: exe,
  format: (o, a) => {
    if (!o) return "";
    const c = String(o.getDate()).padStart(2, "0"), f = String(o.getMonth() + 1).padStart(2, "0"), g = o.getFullYear();
    return [c, f, g].join(".");
  },
  parse: (o, a) => {
    const [c, f, g] = o.split(".").map(Number);
    return new Date(g, f - 1, c);
  }
};
ir.MaskedDate = N0;
class uU extends Gd {
  constructor(a) {
    super({
      ...uU.DEFAULTS,
      ...a
    }), this.currentMask = void 0;
  }
  updateOptions(a) {
    super.updateOptions(a);
  }
  _update(a) {
    super._update(a), "mask" in a && (this.exposeMask = void 0, this.compiledMasks = Array.isArray(a.mask) ? a.mask.map((c) => {
      const {
        expose: f,
        ...g
      } = kI(c), x = j0({
        overwrite: this._overwrite,
        eager: this._eager,
        skipInvalid: this._skipInvalid,
        ...g
      });
      return f && (this.exposeMask = x), x;
    }) : []);
  }
  _appendCharRaw(a, c) {
    c === void 0 && (c = {});
    const f = this._applyDispatch(a, c);
    return this.currentMask && f.aggregate(this.currentMask._appendChar(a, this.currentMaskFlags(c))), f;
  }
  _applyDispatch(a, c, f) {
    a === void 0 && (a = ""), c === void 0 && (c = {}), f === void 0 && (f = "");
    const g = c.tail && c._beforeTailState != null ? c._beforeTailState._value : this.value, x = this.rawInputValue, k = c.tail && c._beforeTailState != null ? c._beforeTailState._rawInputValue : x, A = x.slice(k.length), N = this.currentMask, H = new Br(), Z = N == null ? void 0 : N.state;
    return this.currentMask = this.doDispatch(a, {
      ...c
    }, f), this.currentMask && (this.currentMask !== N ? (this.currentMask.reset(), k && (this.currentMask.append(k, {
      raw: !0
    }), H.tailShift = this.currentMask.value.length - g.length), A && (H.tailShift += this.currentMask.append(A, {
      raw: !0,
      tail: !0
    }).tailShift)) : Z && (this.currentMask.state = Z)), H;
  }
  _appendPlaceholder() {
    const a = this._applyDispatch();
    return this.currentMask && a.aggregate(this.currentMask._appendPlaceholder()), a;
  }
  _appendEager() {
    const a = this._applyDispatch();
    return this.currentMask && a.aggregate(this.currentMask._appendEager()), a;
  }
  appendTail(a) {
    const c = new Br();
    return a && c.aggregate(this._applyDispatch("", {}, a)), c.aggregate(this.currentMask ? this.currentMask.appendTail(a) : super.appendTail(a));
  }
  currentMaskFlags(a) {
    var c, f;
    return {
      ...a,
      _beforeTailState: ((c = a._beforeTailState) == null ? void 0 : c.currentMaskRef) === this.currentMask && ((f = a._beforeTailState) == null ? void 0 : f.currentMask) || a._beforeTailState
    };
  }
  doDispatch(a, c, f) {
    return c === void 0 && (c = {}), f === void 0 && (f = ""), this.dispatch(a, this, c, f);
  }
  doValidate(a) {
    return super.doValidate(a) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(a)));
  }
  doPrepare(a, c) {
    c === void 0 && (c = {});
    let [f, g] = super.doPrepare(a, c);
    if (this.currentMask) {
      let x;
      [f, x] = super.doPrepare(f, this.currentMaskFlags(c)), g = g.aggregate(x);
    }
    return [f, g];
  }
  doPrepareChar(a, c) {
    c === void 0 && (c = {});
    let [f, g] = super.doPrepareChar(a, c);
    if (this.currentMask) {
      let x;
      [f, x] = super.doPrepareChar(f, this.currentMaskFlags(c)), g = g.aggregate(x);
    }
    return [f, g];
  }
  reset() {
    var a;
    (a = this.currentMask) == null || a.reset(), this.compiledMasks.forEach((c) => c.reset());
  }
  get value() {
    return this.exposeMask ? this.exposeMask.value : this.currentMask ? this.currentMask.value : "";
  }
  set value(a) {
    this.exposeMask ? (this.exposeMask.value = a, this.currentMask = this.exposeMask, this._applyDispatch()) : super.value = a;
  }
  get unmaskedValue() {
    return this.exposeMask ? this.exposeMask.unmaskedValue : this.currentMask ? this.currentMask.unmaskedValue : "";
  }
  set unmaskedValue(a) {
    this.exposeMask ? (this.exposeMask.unmaskedValue = a, this.currentMask = this.exposeMask, this._applyDispatch()) : super.unmaskedValue = a;
  }
  get typedValue() {
    return this.exposeMask ? this.exposeMask.typedValue : this.currentMask ? this.currentMask.typedValue : "";
  }
  set typedValue(a) {
    if (this.exposeMask) {
      this.exposeMask.typedValue = a, this.currentMask = this.exposeMask, this._applyDispatch();
      return;
    }
    let c = String(a);
    this.currentMask && (this.currentMask.typedValue = a, c = this.currentMask.unmaskedValue), this.unmaskedValue = c;
  }
  get displayValue() {
    return this.currentMask ? this.currentMask.displayValue : "";
  }
  get isComplete() {
    var a;
    return !!((a = this.currentMask) != null && a.isComplete);
  }
  get isFilled() {
    var a;
    return !!((a = this.currentMask) != null && a.isFilled);
  }
  remove(a, c) {
    const f = new Br();
    return this.currentMask && f.aggregate(this.currentMask.remove(a, c)).aggregate(this._applyDispatch()), f;
  }
  get state() {
    var a;
    return {
      ...super.state,
      _rawInputValue: this.rawInputValue,
      compiledMasks: this.compiledMasks.map((c) => c.state),
      currentMaskRef: this.currentMask,
      currentMask: (a = this.currentMask) == null ? void 0 : a.state
    };
  }
  set state(a) {
    const {
      compiledMasks: c,
      currentMaskRef: f,
      currentMask: g,
      ...x
    } = a;
    c && this.compiledMasks.forEach((k, A) => k.state = c[A]), f != null && (this.currentMask = f, this.currentMask.state = g), super.state = x;
  }
  extractInput(a, c, f) {
    return this.currentMask ? this.currentMask.extractInput(a, c, f) : "";
  }
  extractTail(a, c) {
    return this.currentMask ? this.currentMask.extractTail(a, c) : super.extractTail(a, c);
  }
  doCommit() {
    this.currentMask && this.currentMask.doCommit(), super.doCommit();
  }
  nearestInputPos(a, c) {
    return this.currentMask ? this.currentMask.nearestInputPos(a, c) : super.nearestInputPos(a, c);
  }
  get overwrite() {
    return this.currentMask ? this.currentMask.overwrite : this._overwrite;
  }
  set overwrite(a) {
    this._overwrite = a;
  }
  get eager() {
    return this.currentMask ? this.currentMask.eager : this._eager;
  }
  set eager(a) {
    this._eager = a;
  }
  get skipInvalid() {
    return this.currentMask ? this.currentMask.skipInvalid : this._skipInvalid;
  }
  set skipInvalid(a) {
    this._skipInvalid = a;
  }
  get autofix() {
    return this.currentMask ? this.currentMask.autofix : this._autofix;
  }
  set autofix(a) {
    this._autofix = a;
  }
  maskEquals(a) {
    return Array.isArray(a) ? this.compiledMasks.every((c, f) => {
      if (!a[f]) return;
      const {
        mask: g,
        ...x
      } = a[f];
      return CV(c, x) && c.maskEquals(g);
    }) : super.maskEquals(a);
  }
  typedValueEquals(a) {
    var c;
    return !!((c = this.currentMask) != null && c.typedValueEquals(a));
  }
}
uU.DEFAULTS = {
  ...Gd.DEFAULTS,
  dispatch: (o, a, c, f) => {
    if (!a.compiledMasks.length) return;
    const g = a.rawInputValue, x = a.compiledMasks.map((k, A) => {
      const N = a.currentMask === k, H = N ? k.displayValue.length : k.nearestInputPos(k.displayValue.length, As.FORCE_LEFT);
      return k.rawInputValue !== g ? (k.reset(), k.append(g, {
        raw: !0
      })) : N || k.remove(H), k.append(o, a.currentMaskFlags(c)), k.appendTail(f), {
        index: A,
        weight: k.rawInputValue.length,
        totalInputPositions: k.totalInputPositions(0, Math.max(H, k.nearestInputPos(k.displayValue.length, As.FORCE_LEFT)))
      };
    });
    return x.sort((k, A) => A.weight - k.weight || A.totalInputPositions - k.totalInputPositions), a.compiledMasks[x[0].index];
  }
};
ir.MaskedDynamic = uU;
class dU extends qd {
  constructor(a) {
    super({
      ...dU.DEFAULTS,
      ...a
    });
  }
  updateOptions(a) {
    super.updateOptions(a);
  }
  _update(a) {
    const {
      enum: c,
      ...f
    } = a;
    if (c) {
      const g = c.map((A) => A.length), x = Math.min(...g), k = Math.max(...g) - x;
      f.mask = "*".repeat(x), k && (f.mask += "[" + "*".repeat(k) + "]"), this.enum = c;
    }
    super._update(f);
  }
  _appendCharRaw(a, c) {
    c === void 0 && (c = {});
    const f = Math.min(this.nearestInputPos(0, As.FORCE_RIGHT), this.value.length), g = this.enum.filter((x) => this.matchValue(x, this.unmaskedValue + a, f));
    if (g.length) {
      g.length === 1 && this._forEachBlocksInRange(0, this.value.length, (k, A) => {
        const N = g[0][A];
        A >= this.value.length || N === k.value || (k.reset(), k._appendChar(N, c));
      });
      const x = super._appendCharRaw(g[0][this.value.length], c);
      return g.length === 1 && g[0].slice(this.unmaskedValue.length).split("").forEach((k) => x.aggregate(super._appendCharRaw(k))), x;
    }
    return new Br({
      skip: !this.isComplete
    });
  }
  extractTail(a, c) {
    return a === void 0 && (a = 0), c === void 0 && (c = this.displayValue.length), new Mb("", a);
  }
  remove(a, c) {
    if (a === void 0 && (a = 0), c === void 0 && (c = this.displayValue.length), a === c) return new Br();
    const f = Math.min(super.nearestInputPos(0, As.FORCE_RIGHT), this.value.length);
    let g;
    for (g = a; g >= 0 && !(this.enum.filter((A) => this.matchValue(A, this.value.slice(f, g), f)).length > 1); --g)
      ;
    const x = super.remove(g, c);
    return x.tailShift += g - a, x;
  }
  get isComplete() {
    return this.enum.indexOf(this.value) >= 0;
  }
}
dU.DEFAULTS = {
  ...qd.DEFAULTS,
  matchValue: (o, a, c) => o.indexOf(a, c) === c
};
ir.MaskedEnum = dU;
class txe extends Gd {
  /** */
  /** Enable characters overwriting */
  /** */
  /** */
  /** */
  updateOptions(a) {
    super.updateOptions(a);
  }
  _update(a) {
    super._update({
      ...a,
      validate: a.mask
    });
  }
}
ir.MaskedFunction = txe;
var ime;
class dp extends Gd {
  /** Single char */
  /** Single char */
  /** Array of single chars */
  /** */
  /** */
  /** Digits after point */
  /** Flag to remove leading and trailing zeros in the end of editing */
  /** Flag to pad trailing zeros after point in the end of editing */
  /** Enable characters overwriting */
  /** */
  /** */
  /** */
  /** Format typed value to string */
  /** Parse string to get typed value */
  constructor(a) {
    super({
      ...dp.DEFAULTS,
      ...a
    });
  }
  updateOptions(a) {
    super.updateOptions(a);
  }
  _update(a) {
    super._update(a), this._updateRegExps();
  }
  _updateRegExps() {
    const a = "^" + (this.allowNegative ? "[+|\\-]?" : ""), c = "\\d*", f = (this.scale ? "(" + yte(this.radix) + "\\d{0," + this.scale + "})?" : "") + "$";
    this._numberRegExp = new RegExp(a + c + f), this._mapToRadixRegExp = new RegExp("[" + this.mapToRadix.map(yte).join("") + "]", "g"), this._thousandsSeparatorRegExp = new RegExp(yte(this.thousandsSeparator), "g");
  }
  _removeThousandsSeparators(a) {
    return a.replace(this._thousandsSeparatorRegExp, "");
  }
  _insertThousandsSeparators(a) {
    const c = a.split(this.radix);
    return c[0] = c[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator), c.join(this.radix);
  }
  doPrepareChar(a, c) {
    c === void 0 && (c = {});
    const [f, g] = super.doPrepareChar(this._removeThousandsSeparators(this.scale && this.mapToRadix.length && /*
      radix should be mapped when
      1) input is done from keyboard = flags.input && flags.raw
      2) unmasked value is set = !flags.input && !flags.raw
      and should not be mapped when
      1) value is set = flags.input && !flags.raw
      2) raw value is set = !flags.input && flags.raw
    */
    (c.input && c.raw || !c.input && !c.raw) ? a.replace(this._mapToRadixRegExp, this.radix) : a), c);
    return a && !f && (g.skip = !0), f && !this.allowPositive && !this.value && f !== "-" && g.aggregate(this._appendChar("-")), [f, g];
  }
  _separatorsCount(a, c) {
    c === void 0 && (c = !1);
    let f = 0;
    for (let g = 0; g < a; ++g)
      this._value.indexOf(this.thousandsSeparator, g) === g && (++f, c && (a += this.thousandsSeparator.length));
    return f;
  }
  _separatorsCountFromSlice(a) {
    return a === void 0 && (a = this._value), this._separatorsCount(this._removeThousandsSeparators(a).length, !0);
  }
  extractInput(a, c, f) {
    return a === void 0 && (a = 0), c === void 0 && (c = this.displayValue.length), [a, c] = this._adjustRangeWithSeparators(a, c), this._removeThousandsSeparators(super.extractInput(a, c, f));
  }
  _appendCharRaw(a, c) {
    c === void 0 && (c = {});
    const f = c.tail && c._beforeTailState ? c._beforeTailState._value : this._value, g = this._separatorsCountFromSlice(f);
    this._value = this._removeThousandsSeparators(this.value);
    const x = this._value;
    this._value += a;
    const k = this.number;
    let A = !isNaN(k), N = !1;
    if (A) {
      let J;
      this.min != null && this.min < 0 && this.number < this.min && (J = this.min), this.max != null && this.max > 0 && this.number > this.max && (J = this.max), J != null && (this.autofix ? (this._value = this.format(J, this).replace(dp.UNMASKED_RADIX, this.radix), N || (N = x === this._value && !c.tail)) : A = !1), A && (A = !!this._value.match(this._numberRegExp));
    }
    let H;
    A ? H = new Br({
      inserted: this._value.slice(x.length),
      rawInserted: N ? "" : a,
      skip: N
    }) : (this._value = x, H = new Br()), this._value = this._insertThousandsSeparators(this._value);
    const Z = c.tail && c._beforeTailState ? c._beforeTailState._value : this._value, K = this._separatorsCountFromSlice(Z);
    return H.tailShift += (K - g) * this.thousandsSeparator.length, H;
  }
  _findSeparatorAround(a) {
    if (this.thousandsSeparator) {
      const c = a - this.thousandsSeparator.length + 1, f = this.value.indexOf(this.thousandsSeparator, c);
      if (f <= a) return f;
    }
    return -1;
  }
  _adjustRangeWithSeparators(a, c) {
    const f = this._findSeparatorAround(a);
    f >= 0 && (a = f);
    const g = this._findSeparatorAround(c);
    return g >= 0 && (c = g + this.thousandsSeparator.length), [a, c];
  }
  remove(a, c) {
    a === void 0 && (a = 0), c === void 0 && (c = this.displayValue.length), [a, c] = this._adjustRangeWithSeparators(a, c);
    const f = this.value.slice(0, a), g = this.value.slice(c), x = this._separatorsCount(f.length);
    this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(f + g));
    const k = this._separatorsCountFromSlice(f);
    return new Br({
      tailShift: (k - x) * this.thousandsSeparator.length
    });
  }
  nearestInputPos(a, c) {
    if (!this.thousandsSeparator) return a;
    switch (c) {
      case As.NONE:
      case As.LEFT:
      case As.FORCE_LEFT: {
        const f = this._findSeparatorAround(a - 1);
        if (f >= 0) {
          const g = f + this.thousandsSeparator.length;
          if (a < g || this.value.length <= g || c === As.FORCE_LEFT)
            return f;
        }
        break;
      }
      case As.RIGHT:
      case As.FORCE_RIGHT: {
        const f = this._findSeparatorAround(a);
        if (f >= 0)
          return f + this.thousandsSeparator.length;
      }
    }
    return a;
  }
  doCommit() {
    if (this.value) {
      const a = this.number;
      let c = a;
      this.min != null && (c = Math.max(c, this.min)), this.max != null && (c = Math.min(c, this.max)), c !== a && (this.unmaskedValue = this.format(c, this));
      let f = this.value;
      this.normalizeZeros && (f = this._normalizeZeros(f)), this.padFractionalZeros && this.scale > 0 && (f = this._padFractionalZeros(f)), this._value = f;
    }
    super.doCommit();
  }
  _normalizeZeros(a) {
    const c = this._removeThousandsSeparators(a).split(this.radix);
    return c[0] = c[0].replace(/^(\D*)(0*)(\d*)/, (f, g, x, k) => g + k), a.length && !/\d$/.test(c[0]) && (c[0] = c[0] + "0"), c.length > 1 && (c[1] = c[1].replace(/0*$/, ""), c[1].length || (c.length = 1)), this._insertThousandsSeparators(c.join(this.radix));
  }
  _padFractionalZeros(a) {
    if (!a) return a;
    const c = a.split(this.radix);
    return c.length < 2 && c.push(""), c[1] = c[1].padEnd(this.scale, "0"), c.join(this.radix);
  }
  doSkipInvalid(a, c, f) {
    c === void 0 && (c = {});
    const g = this.scale === 0 && a !== this.thousandsSeparator && (a === this.radix || a === dp.UNMASKED_RADIX || this.mapToRadix.includes(a));
    return super.doSkipInvalid(a, c, f) && !g;
  }
  get unmaskedValue() {
    return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, dp.UNMASKED_RADIX);
  }
  set unmaskedValue(a) {
    super.unmaskedValue = a;
  }
  get typedValue() {
    return this.parse(this.unmaskedValue, this);
  }
  set typedValue(a) {
    this.rawInputValue = this.format(a, this).replace(dp.UNMASKED_RADIX, this.radix);
  }
  /** Parsed Number */
  get number() {
    return this.typedValue;
  }
  set number(a) {
    this.typedValue = a;
  }
  get allowNegative() {
    return this.min != null && this.min < 0 || this.max != null && this.max < 0;
  }
  get allowPositive() {
    return this.min != null && this.min > 0 || this.max != null && this.max > 0;
  }
  typedValueEquals(a) {
    return (super.typedValueEquals(a) || dp.EMPTY_VALUES.includes(a) && dp.EMPTY_VALUES.includes(this.typedValue)) && !(a === 0 && this.value === "");
  }
}
ime = dp;
dp.UNMASKED_RADIX = ".";
dp.EMPTY_VALUES = [...Gd.EMPTY_VALUES, 0];
dp.DEFAULTS = {
  ...Gd.DEFAULTS,
  mask: Number,
  radix: ",",
  thousandsSeparator: "",
  mapToRadix: [ime.UNMASKED_RADIX],
  min: Number.MIN_SAFE_INTEGER,
  max: Number.MAX_SAFE_INTEGER,
  scale: 2,
  normalizeZeros: !0,
  padFractionalZeros: !1,
  parse: Number,
  format: (o) => o.toLocaleString("en-US", {
    useGrouping: !1,
    maximumFractionDigits: 20
  })
};
ir.MaskedNumber = dp;
const Kne = {
  MASKED: "value",
  UNMASKED: "unmaskedValue",
  TYPED: "typedValue"
};
function lme(o, a, c) {
  a === void 0 && (a = Kne.MASKED), c === void 0 && (c = Kne.MASKED);
  const f = j0(o);
  return (g) => f.runIsolated((x) => (x[a] = g, x[c]));
}
function nxe(o, a, c, f) {
  return lme(a, c, f)(o);
}
ir.PIPE_TYPE = Kne;
ir.createPipe = lme;
ir.pipe = nxe;
class oxe extends qd {
  get repeatFrom() {
    var a;
    return (a = Array.isArray(this.repeat) ? this.repeat[0] : this.repeat === 1 / 0 ? 0 : this.repeat) != null ? a : 0;
  }
  get repeatTo() {
    var a;
    return (a = Array.isArray(this.repeat) ? this.repeat[1] : this.repeat) != null ? a : 1 / 0;
  }
  constructor(a) {
    super(a);
  }
  updateOptions(a) {
    super.updateOptions(a);
  }
  _update(a) {
    var c, f, g;
    const {
      repeat: x,
      ...k
    } = kI(a);
    this._blockOpts = Object.assign({}, this._blockOpts, k);
    const A = j0(this._blockOpts);
    this.repeat = (c = (f = x ?? A.repeat) != null ? f : this.repeat) != null ? c : 1 / 0, super._update({
      mask: "m".repeat(Math.max(this.repeatTo === 1 / 0 && ((g = this._blocks) == null ? void 0 : g.length) || 0, this.repeatFrom)),
      blocks: {
        m: A
      },
      eager: A.eager,
      overwrite: A.overwrite,
      skipInvalid: A.skipInvalid,
      lazy: A.lazy,
      placeholderChar: A.placeholderChar,
      displayChar: A.displayChar
    });
  }
  _allocateBlock(a) {
    if (a < this._blocks.length) return this._blocks[a];
    if (this.repeatTo === 1 / 0 || this._blocks.length < this.repeatTo)
      return this._blocks.push(j0(this._blockOpts)), this.mask += "m", this._blocks[this._blocks.length - 1];
  }
  _appendCharRaw(a, c) {
    c === void 0 && (c = {});
    const f = new Br();
    for (
      let N = (g = (x = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : x.index) != null ? g : Math.max(this._blocks.length - 1, 0), H, Z;
      // try to get a block or
      // try to allocate a new block if not allocated already
      H = (k = this._blocks[N]) != null ? k : Z = !Z && this._allocateBlock(N);
      ++N
    ) {
      var g, x, k, A;
      const K = H._appendChar(a, {
        ...c,
        _beforeTailState: (A = c._beforeTailState) == null || (A = A._blocks) == null ? void 0 : A[N]
      });
      if (K.skip && Z) {
        this._blocks.pop(), this.mask = this.mask.slice(1);
        break;
      }
      if (f.aggregate(K), K.consumed) break;
    }
    return f;
  }
  _trimEmptyTail(a, c) {
    var f, g;
    a === void 0 && (a = 0);
    const x = Math.max(((f = this._mapPosToBlock(a)) == null ? void 0 : f.index) || 0, this.repeatFrom, 0);
    let k;
    c != null && (k = (g = this._mapPosToBlock(c)) == null ? void 0 : g.index), k == null && (k = this._blocks.length - 1);
    let A = 0;
    for (let N = k; x <= N && !this._blocks[N].unmaskedValue; --N, ++A)
      ;
    A && (this._blocks.splice(k - A + 1, A), this.mask = this.mask.slice(A));
  }
  reset() {
    super.reset(), this._trimEmptyTail();
  }
  remove(a, c) {
    a === void 0 && (a = 0), c === void 0 && (c = this.displayValue.length);
    const f = super.remove(a, c);
    return this._trimEmptyTail(a, c), f;
  }
  totalInputPositions(a, c) {
    return a === void 0 && (a = 0), c == null && this.repeatTo === 1 / 0 ? 1 / 0 : super.totalInputPositions(a, c);
  }
  get state() {
    return super.state;
  }
  set state(a) {
    this._blocks.length = a._blocks.length, this.mask = this.mask.slice(0, this._blocks.length), super.state = a;
  }
}
ir.RepeatBlock = oxe;
try {
  globalThis.IMask = ir;
} catch {
}
const cme = {
  // common
  mask: ce.oneOfType([ce.array, ce.func, ce.string, ce.instanceOf(RegExp), ce.oneOf([Date, Number, ir.Masked]), ce.instanceOf(ir.Masked)]),
  value: ce.any,
  unmask: ce.oneOfType([ce.bool, ce.oneOf(["typed"])]),
  prepare: ce.func,
  prepareChar: ce.func,
  validate: ce.func,
  commit: ce.func,
  overwrite: ce.oneOfType([ce.bool, ce.oneOf(["shift"])]),
  eager: ce.oneOfType([ce.bool, ce.oneOf(["append", "remove"])]),
  skipInvalid: ce.bool,
  // events
  onAccept: ce.func,
  onComplete: ce.func,
  // pattern
  placeholderChar: ce.string,
  displayChar: ce.string,
  lazy: ce.bool,
  definitions: ce.object,
  blocks: ce.object,
  // enum
  enum: ce.arrayOf(ce.string),
  // range
  maxLength: ce.number,
  from: ce.number,
  to: ce.number,
  // date
  pattern: ce.string,
  format: ce.func,
  parse: ce.func,
  autofix: ce.oneOfType([ce.bool, ce.oneOf(["pad"])]),
  // number
  radix: ce.string,
  thousandsSeparator: ce.string,
  mapToRadix: ce.arrayOf(ce.string),
  scale: ce.number,
  normalizeZeros: ce.bool,
  padFractionalZeros: ce.bool,
  min: ce.oneOfType([ce.number, ce.instanceOf(Date)]),
  max: ce.oneOfType([ce.number, ce.instanceOf(Date)]),
  // dynamic
  dispatch: ce.func,
  // ref
  inputRef: ce.oneOfType([ce.func, ce.shape({
    current: ce.object
  })])
}, ume = Object.keys(cme).filter((o) => o !== "value"), sxe = ["value", "unmask", "onAccept", "onComplete", "inputRef"], rxe = ume.filter((o) => sxe.indexOf(o) < 0);
function axe(o) {
  var a;
  const c = (a = class extends Ve.Component {
    constructor(x) {
      super(x), this._inputRef = this._inputRef.bind(this);
    }
    componentDidMount() {
      this.props.mask && this.initMask();
    }
    componentDidUpdate() {
      const x = this.props, k = this._extractMaskOptionsFromProps(x);
      if (k.mask)
        this.maskRef ? (this.maskRef.updateOptions(k), "value" in x && x.value !== void 0 && (this.maskValue = x.value)) : this.initMask(k);
      else if (this.destroyMask(), "value" in x && x.value !== void 0) {
        var A;
        (A = this.element) != null && A.isContentEditable && this.element.tagName !== "INPUT" && this.element.tagName !== "TEXTAREA" ? this.element.textContent = x.value : this.element.value = x.value;
      }
    }
    componentWillUnmount() {
      this.destroyMask();
    }
    _inputRef(x) {
      this.element = x, this.props.inputRef && (Object.prototype.hasOwnProperty.call(this.props.inputRef, "current") ? this.props.inputRef.current = x : this.props.inputRef(x));
    }
    initMask(x) {
      x === void 0 && (x = this._extractMaskOptionsFromProps(this.props)), this.maskRef = ir(this.element, x).on("accept", this._onAccept.bind(this)).on("complete", this._onComplete.bind(this)), "value" in this.props && this.props.value !== void 0 && (this.maskValue = this.props.value);
    }
    destroyMask() {
      this.maskRef && (this.maskRef.destroy(), delete this.maskRef);
    }
    _extractMaskOptionsFromProps(x) {
      const {
        ...k
      } = x;
      return Object.keys(k).filter((A) => rxe.indexOf(A) < 0).forEach((A) => {
        delete k[A];
      }), k;
    }
    _extractNonMaskProps(x) {
      const {
        ...k
      } = x;
      return ume.forEach((A) => {
        A !== "maxLength" && delete k[A];
      }), "defaultValue" in k || (k.defaultValue = x.mask ? "" : k.value), delete k.value, k;
    }
    get maskValue() {
      return this.maskRef ? this.props.unmask === "typed" ? this.maskRef.typedValue : this.props.unmask ? this.maskRef.unmaskedValue : this.maskRef.value : "";
    }
    set maskValue(x) {
      this.maskRef && (x = x == null && this.props.unmask !== "typed" ? "" : x, this.props.unmask === "typed" ? this.maskRef.typedValue = x : this.props.unmask ? this.maskRef.unmaskedValue = x : this.maskRef.value = x);
    }
    _onAccept(x) {
      this.props.onAccept && this.maskRef && this.props.onAccept(this.maskValue, this.maskRef, x);
    }
    _onComplete(x) {
      this.props.onComplete && this.maskRef && this.props.onComplete(this.maskValue, this.maskRef, x);
    }
    render() {
      return Ve.createElement(o, {
        ...this._extractNonMaskProps(this.props),
        inputRef: this._inputRef
      });
    }
  }, a.displayName = void 0, a.propTypes = void 0, a), f = o.displayName || o.name || "Component";
  return c.displayName = "IMask(" + f + ")", c.propTypes = cme, Ve.forwardRef((g, x) => Ve.createElement(c, {
    ...g,
    ref: x
  }));
}
const ixe = axe((o) => {
  let {
    inputRef: a,
    ...c
  } = o;
  return Ve.createElement("input", {
    ...c,
    ref: a
  });
}), lxe = (o, a) => Ve.createElement(ixe, {
  ...o,
  ref: a
}), cxe = Ve.forwardRef(lxe), uxe = function() {
  let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.entries(o).reduce((a, c) => {
    let [f, g] = c;
    return g !== void 0 && (a[f] = g), a;
  }, {});
}, Vk = function() {
  for (var o = arguments.length, a = new Array(o), c = 0; c < o; c++)
    a[c] = arguments[c];
  return (g) => {
    a.filter((x) => typeof x == "function").forEach((x) => x(g));
  };
}, dxe = (o) => {
  let {
    defaultValue: a,
    value: c
  } = o;
  const [f, g] = tt.useState(!!a || a === 0);
  return [!!c || c === 0 || f, (A) => g(!!A.target.value)];
}, Yle = (o, a) => {
  const [c, f] = tt.useState([]), g = (N) => (f((H) => [...H, N]), N), x = () => {
    const N = ise(`${o}-`);
    return g(N);
  }, k = (N) => {
    f((H) => H.filter((Z) => Z !== N));
  };
  return [c, (N) => {
    const [H, Z] = tt.useState(N);
    return tt.useEffect(() => (N ? g(N) : H || Z(x()), () => k(H)), [H, N]), H;
  }];
}, xte = (o) => o, fxe = () => {
}, dme = /* @__PURE__ */ Ve.createContext({
  getControlProps: xte,
  useSetIsControlGroupEffect: fxe,
  getLabelProps: xte,
  getDescriptorProps: xte,
  hasFormGroupProvider: !1
}), Hh = () => Ve.useContext(dme);
function mxe(o) {
  const [a, c] = tt.useState(o);
  return [a, (g) => {
    tt.useEffect(() => c(g), [g]);
  }];
}
function fU(o) {
  let {
    children: a,
    controlId: c,
    isInvalid: f,
    isValid: g,
    size: x
  } = o;
  const k = tt.useMemo(() => c || ise("form-field"), [c]), [A, N] = Yle(k), [H, Z] = Yle(k), [K, J] = mxe(!1), ye = {
    getControlProps: tt.useCallback((re) => {
      const oe = K ? H : void 0;
      return uxe({
        ...re,
        "aria-describedby": er(re["aria-describedby"], A) || void 0,
        "aria-labelledby": er(re["aria-labelledby"], oe) || void 0,
        id: k
      });
    }, [K, A, H, k]),
    getLabelProps: (re) => {
      const oe = Z(re == null ? void 0 : re.id);
      return K ? {
        ...re,
        id: oe
      } : {
        ...re,
        htmlFor: k
      };
    },
    getDescriptorProps: (re) => {
      const oe = N(re == null ? void 0 : re.id);
      return {
        ...re,
        id: oe
      };
    },
    useSetIsControlGroupEffect: J,
    isControlGroup: K,
    controlId: k,
    isInvalid: f,
    isValid: g,
    size: x,
    hasFormGroupProvider: !0
  };
  return /* @__PURE__ */ Ve.createElement(dme.Provider, {
    value: ye
  }, a);
}
const Q4 = {
  SMALL: "sm",
  LARGE: "lg"
}, tv = {
  DEFAULT: "default",
  VALID: "valid",
  INVALID: "invalid",
  WARNING: "warning",
  CRITERIA_EMPTY: "criteria-empty",
  CRITERIA_VALID: "criteria-valid",
  CRITERIA_INVALID: "criteria-invalid"
}, pxe = {
  [tv.DEFAULT]: null,
  [tv.VALID]: pye,
  [tv.INVALID]: gye,
  [tv.WARNING]: Cye,
  [tv.CRITERIA_EMPTY]: wye,
  [tv.CRITERIA_VALID]: hye,
  [tv.CRITERIA_INVALID]: mye
}, hxe = (o) => {
  let {
    isInvalid: a,
    isValid: c
  } = o;
  return c ? tv.VALID : a ? tv.INVALID : tv.DEFAULT;
};
function jse(o) {
  let {
    type: a,
    customIcon: c
  } = o;
  if (c)
    return c;
  const f = pxe[a];
  return f ? /* @__PURE__ */ Ve.createElement(W4, {
    src: f
  }) : null;
}
jse.propTypes = {
  type: ce.oneOf(Object.values(tv)),
  customIcon: ce.node
};
jse.defaultProps = {
  type: void 0,
  customIcon: void 0
};
function mU(o) {
  let {
    children: a,
    type: c,
    icon: f,
    muted: g,
    hasIcon: x,
    ...k
  } = o;
  const A = er(k.className, "pgn__form-text", `pgn__form-text-${c}`, {
    "text-muted": g
  });
  return /* @__PURE__ */ Ve.createElement("div", {
    ...k,
    className: A
  }, x && /* @__PURE__ */ Ve.createElement(jse, {
    customIcon: f,
    type: c
  }), /* @__PURE__ */ Ve.createElement("div", null, a));
}
const gxe = ["default", "valid", "invalid", "warning", "criteria-empty", "criteria-valid", "criteria-invalid"];
mU.propTypes = {
  /** Specifies contents of the component. */
  children: ce.node.isRequired,
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies whether to show an icon next to the text. */
  hasIcon: ce.bool,
  /** Specifies text type, this affects styling. */
  type: ce.oneOf(gxe),
  /** Specifies icon to show, will only be shown if `hasIcon` prop is set to `true`. */
  icon: ce.node,
  /** Specifies whether to show text with muted styling. */
  muted: ce.bool
};
mU.defaultProps = {
  hasIcon: !0,
  type: "default",
  icon: void 0,
  className: void 0,
  muted: !1
};
function W2(o) {
  let {
    children: a,
    ...c
  } = o;
  const {
    getDescriptorProps: f,
    isInvalid: g,
    isValid: x
  } = Hh(), k = f(c), A = er("pgn__form-control-description", c.className), N = c.type || hxe({
    isInvalid: g,
    isValid: x
  });
  return /* @__PURE__ */ Ve.createElement(mU, {
    ...k,
    className: A,
    type: N
  }, a);
}
const vxe = ["default", "valid", "invalid", "warning", "criteria-empty", "criteria-valid", "criteria-invalid"];
W2.propTypes = {
  /** Specifies contents of the component. */
  children: ce.node.isRequired,
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies whether to show an icon next to the text. */
  hasIcon: ce.bool,
  /** Specifies feedback type, this affects styling. */
  type: ce.oneOf(vxe),
  /** Specifies icon to show, will only be shown if `hasIcon` prop is set to `true`. */
  icon: ce.node,
  /** Specifies whether to show feedback with muted styling. */
  muted: ce.bool
};
W2.defaultProps = {
  hasIcon: !0,
  type: void 0,
  icon: void 0,
  className: void 0,
  muted: !1
};
function fme(o) {
  let {
    children: a
  } = o;
  const {
    controlId: c
  } = Hh();
  return /* @__PURE__ */ Ve.createElement("div", {
    className: "pgn__form-control-floating-label"
  }, /* @__PURE__ */ Ve.createElement("div", {
    className: "pgn__form-control-floating-label-content"
  }, /* @__PURE__ */ Ve.createElement("label", {
    className: "pgn__form-control-floating-label-text",
    htmlFor: c
  }, a)));
}
fme.propTypes = {
  children: ce.node.isRequired
};
function kV(o) {
  let {
    children: a,
    location: c
  } = o;
  return /* @__PURE__ */ Ve.createElement("div", {
    className: `pgn__form-control-decorator pgn__form-control-decorator-${c}`
  }, a);
}
kV.propTypes = {
  children: ce.node.isRequired,
  location: ce.oneOf(["leading", "trailing"])
};
kV.defaultProps = {
  location: "leading"
};
function Wse(o) {
  let {
    children: a,
    leadingElement: c,
    trailingElement: f,
    floatingLabel: g,
    className: x,
    ...k
  } = o;
  const A = Hh(), N = k.size || A.size;
  return /* @__PURE__ */ Ve.createElement("div", {
    className: er("pgn__form-control-decorator-group", {
      "has-prepended-node": !!c,
      "has-appended-node": !!f,
      "has-leading-element": !!c,
      "has-trailing-element": !!f,
      "has-floating-label": !!g,
      "pgn__form-control-decorator-group-lg": N === Q4.LARGE,
      "pgn__form-control-decorator-group-sm": N === Q4.SMALL
    }, x),
    ...k
  }, a, c && /* @__PURE__ */ Ve.createElement(kV, {
    location: "leading"
  }, c), f && /* @__PURE__ */ Ve.createElement(kV, {
    location: "trailing"
  }, f), g && /* @__PURE__ */ Ve.createElement(fme, null, g));
}
Wse.propTypes = {
  children: ce.node.isRequired,
  leadingElement: ce.node,
  trailingElement: ce.node,
  floatingLabel: ce.node,
  className: ce.string,
  size: ce.oneOf([Q4.SMALL, Q4.LARGE])
};
Wse.defaultProps = {
  leadingElement: void 0,
  trailingElement: void 0,
  floatingLabel: void 0,
  className: void 0,
  size: void 0
};
const aO = /* @__PURE__ */ Ve.forwardRef((o, a) => {
  let {
    as: c,
    className: f,
    controlClassName: g,
    leadingElement: x,
    trailingElement: k,
    floatingLabel: A,
    autoResize: N,
    onChange: H,
    inputMask: Z,
    ...K
  } = o;
  const {
    isInvalid: J,
    isValid: pe,
    getControlProps: Se,
    ...be
  } = Hh(), ye = Ve.useRef(), re = a || ye, oe = K.size || be.size, [U, ve] = dxe({
    defaultValue: K.defaultValue,
    value: K.value
  }), Ze = tt.useCallback(() => {
    c === "textarea" && N && (!re.current.initialHeight && !re.current.offsets && (re.current.initialHeight = re.current.offsetHeight, re.current.offsets = re.current.offsetHeight - re.current.clientHeight), re.current.style.height = `${re.current.initialHeight}px`, re.current.style.height = `${re.current.scrollHeight + re.current.offsets}px`);
  }, [c, N, re]);
  tt.useEffect(() => {
    Ze();
  }, [Ze]);
  const rt = Se({
    ...K,
    // eslint-disable-next-line react/prop-types
    onBlur: Vk(ve, K.onBlur)
  }), ee = (lt) => {
    Ze(), H && H(lt);
  };
  return /* @__PURE__ */ Ve.createElement(Wse, {
    size: oe,
    leadingElement: x,
    trailingElement: k,
    floatingLabel: A,
    className: f
  }, /* @__PURE__ */ Ve.createElement(Jfe, {
    as: Z ? cxe : c,
    ref: re,
    size: oe,
    isInvalid: J,
    isValid: pe,
    className: er(g, {
      "has-value": U
    }),
    onChange: ee,
    mask: Z,
    ...rt
  }));
}), bxe = ["sm", "lg"];
aO.Feedback = W2;
aO.Description = W2;
aO.propTypes = {
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies base element for the control component. */
  as: ce.elementType,
  /** Specifies function that is triggered on input value change. */
  onChange: ce.func,
  /** Specifies default value of the input component. */
  defaultValue: ce.oneOfType([ce.string, ce.number]),
  /** Specifies current value of the input component. */
  value: ce.oneOfType([ce.string, ce.number]),
  /** Specifies id of the control component. */
  id: ce.string,
  /** Specifies class name for the control component. */
  controlClassName: ce.string,
  /** Specifies size for the control component. */
  size: ce.oneOf(bxe),
  /** Specifies leading element to display for the input component. */
  leadingElement: ce.node,
  /** Specifies trailing element to display for the input component. */
  trailingElement: ce.node,
  /** Specifies floating label to display for the input component. */
  floatingLabel: ce.node,
  /** Specifies whether to render input as plain text. */
  plaintext: ce.bool,
  /** Specifies whether to display control in valid state, this affects styling. */
  isValid: ce.bool,
  /** Specifies whether to display control in invalid state, this affects styling. */
  isInvalid: ce.bool,
  /** Only for `as="textarea"`. Specifies whether the input can be resized according to the height of content. */
  autoResize: ce.bool,
  /** Specifies what format to use for the input mask. */
  inputMask: ce.string
};
aO.defaultProps = {
  as: "input",
  className: void 0,
  id: void 0,
  controlClassName: void 0,
  onChange: void 0,
  defaultValue: void 0,
  value: void 0,
  size: void 0,
  leadingElement: void 0,
  trailingElement: void 0,
  floatingLabel: void 0,
  plaintext: !1,
  isValid: void 0,
  isInvalid: void 0,
  autoResize: !1,
  inputMask: void 0
};
function pU(o) {
  let {
    children: a,
    isInline: c = !1,
    ...f
  } = o;
  const {
    size: g,
    isControlGroup: x,
    getLabelProps: k
  } = Hh(), A = er("pgn__form-label", {
    "pgn__form-label-inline": c,
    "pgn__form-label-lg": g === Q4.LARGE,
    "pgn__form-label-sm": g === Q4.SMALL
  }, f.className), N = k({
    ...f,
    className: A
  }), H = x ? "p" : "label";
  return /* @__PURE__ */ Ve.createElement(H, N, a);
}
pU.propTypes = {
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies contents of the component. */
  children: ce.node.isRequired,
  /** Specifies whether the component should be displayed with inline styling. */
  isInline: ce.bool
};
function mme(o) {
  let {
    children: a,
    controlId: c,
    isInvalid: f = !1,
    isValid: g = !1,
    size: x,
    as: k,
    ...A
  } = o;
  return /* @__PURE__ */ Ve.createElement(k ?? "div", {
    ...A,
    className: er("pgn__form-group", A.className)
  }, /* @__PURE__ */ Ve.createElement(fU, {
    controlId: c,
    isInvalid: f,
    isValid: g,
    size: x
  }, a));
}
const yxe = ["sm", "lg"];
mme.propTypes = {
  /** Specifies contents of the component. */
  children: ce.node.isRequired,
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies base element for the component. */
  as: ce.elementType,
  /** Specifies id to use in the group, it will be used as `htmlFor` in `FormLabel` and as `id` in input components.
   *  Will be autogenerated if none is supplied. */
  controlId: ce.string,
  /** Specifies whether to display components in invalid state, this affects styling. */
  isInvalid: ce.bool,
  /** Specifies whether to display components in valid state, this affects styling. */
  isValid: ce.bool,
  /** Specifies size for the component. */
  size: ce.oneOf(yxe)
};
const xxe = (o) => o, pme = /* @__PURE__ */ Ve.createContext({
  getRadioControlProps: xxe,
  hasRadioSetProvider: !1
}), wxe = () => tt.useContext(pme);
function Zse(o) {
  let {
    children: a,
    name: c,
    onBlur: f,
    onFocus: g,
    onChange: x,
    value: k,
    defaultValue: A
  } = o;
  const N = !A && k !== void 0, Z = {
    name: c,
    value: k,
    defaultValue: A,
    getRadioControlProps: (K) => ({
      ...K,
      name: c,
      /* istanbul ignore next */
      onBlur: K.onBlur ? Vk(f, K.onBlur) : f,
      /* istanbul ignore next */
      onFocus: K.onFocus ? Vk(g, K.onFocus) : g,
      /* istanbul ignore next */
      onChange: K.onChange ? Vk(x, K.onChange) : x,
      checked: N ? k === K.value : void 0,
      defaultChecked: N ? void 0 : A === K.value
    }),
    onBlur: f,
    onFocus: g,
    onChange: x,
    hasRadioSetProvider: !0
  };
  return /* @__PURE__ */ Ve.createElement(pme.Provider, {
    value: Z
  }, a);
}
Zse.propTypes = {
  children: ce.node.isRequired,
  name: ce.string.isRequired,
  onBlur: ce.func,
  onFocus: ce.func,
  onChange: ce.func,
  value: ce.string,
  defaultValue: ce.string
};
Zse.defaultProps = {
  onBlur: void 0,
  onFocus: void 0,
  onChange: void 0,
  value: void 0,
  defaultValue: void 0
};
const Gse = /* @__PURE__ */ Ve.forwardRef((o, a) => {
  const {
    getControlProps: c
  } = Hh(), {
    getRadioControlProps: f,
    hasRadioSetProvider: g
  } = wxe();
  let x = c({
    ...o,
    className: er("pgn__form-radio-input", o.className)
  });
  return g && (x = f(x)), /* @__PURE__ */ Ve.createElement("input", {
    ...x,
    type: "radio",
    ref: a
  });
});
Gse.propTypes = {
  className: ce.string
};
Gse.defaultProps = {
  className: void 0
};
const qse = /* @__PURE__ */ Ve.forwardRef((o, a) => {
  let {
    children: c,
    className: f,
    controlClassName: g,
    labelClassName: x,
    description: k,
    isInvalid: A,
    isValid: N,
    ...H
  } = o;
  return /* @__PURE__ */ Ve.createElement(fU, {
    controlId: H.id,
    isInvalid: A,
    isValid: N
  }, /* @__PURE__ */ Ve.createElement("div", {
    className: er("pgn__form-radio", f, {
      "pgn__form-control-valid": N,
      "pgn__form-control-invalid": A,
      "pgn__form-control-disabled": H.disabled
    })
  }, /* @__PURE__ */ Ve.createElement(Gse, {
    ref: a,
    className: g,
    ...H
  }), /* @__PURE__ */ Ve.createElement("div", null, /* @__PURE__ */ Ve.createElement(pU, {
    className: x
  }, c), k && /* @__PURE__ */ Ve.createElement(W2, {
    hasIcon: !1
  }, k))));
});
qse.propTypes = {
  /** Specifies id of the FormRadio component. */
  id: ce.string,
  /** Specifies contents of the component. */
  children: ce.node.isRequired,
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies class name for control component. */
  controlClassName: ce.string,
  /** Specifies class name for label component. */
  labelClassName: ce.string,
  /** Specifies description to show under the radio's value. */
  description: ce.node,
  /** Specifies whether to display component in invalid state, this affects styling. */
  isInvalid: ce.bool,
  /** Specifies whether to display component in valid state, this affects styling. */
  isValid: ce.bool,
  /** Specifies whether the `FormRadio` is disabled. */
  disabled: ce.bool
};
qse.defaultProps = {
  id: void 0,
  className: void 0,
  controlClassName: void 0,
  labelClassName: void 0,
  description: void 0,
  isInvalid: !1,
  isValid: !1,
  disabled: !1
};
function hU(o) {
  let {
    as: a,
    className: c,
    isInline: f,
    children: g,
    ...x
  } = o;
  return /* @__PURE__ */ Ve.createElement(a, {
    className: er(c, {
      "pgn__form-control-set": !f,
      "pgn__form-control-set-inline": f
    }),
    ...x
  }, g);
}
hU.propTypes = {
  /** Specifies the base element */
  as: ce.elementType,
  /** A class name to append to the base element. */
  className: ce.string,
  /** Specifies whether the component should be displayed with inline styling. */
  isInline: ce.bool,
  /** Specifies contents of the component. */
  children: ce.node
};
hU.defaultProps = {
  as: "div",
  className: void 0,
  isInline: !1,
  children: null
};
function Kse(o) {
  let {
    children: a,
    name: c,
    value: f,
    defaultValue: g,
    isInline: x,
    onChange: k,
    onFocus: A,
    onBlur: N,
    ...H
  } = o;
  const {
    getControlProps: Z,
    useSetIsControlGroupEffect: K
  } = Hh();
  K(!0);
  const J = Z(H);
  return /* @__PURE__ */ Ve.createElement(Zse, {
    name: c,
    value: f,
    defaultValue: g,
    onFocus: A,
    onBlur: N,
    onChange: k
  }, /* @__PURE__ */ Ve.createElement(hU, {
    role: "radiogroup",
    isInline: x,
    ...J
  }, a));
}
Kse.propTypes = {
  /** Specifies contents of the component. */
  children: ce.node.isRequired,
  /** A class name to append to the base element. */
  className: ce.string,
  /** Specifies name for the component. */
  name: ce.string.isRequired,
  /** Specifies values for the FormRadioSet. */
  value: ce.string,
  /** Specifies default values. */
  defaultValue: ce.string,
  /** Specifies whether the component should be displayed with inline styling. */
  isInline: ce.bool,
  /** Specifies onChange event handler. */
  onChange: ce.func,
  /** Specifies onFocus event handler. */
  onFocus: ce.func,
  /** Specifies onBlur event handler. */
  onBlur: ce.func
};
Kse.defaultProps = {
  className: void 0,
  value: void 0,
  defaultValue: void 0,
  isInline: !1,
  onChange: void 0,
  onFocus: void 0,
  onBlur: void 0
};
let x9;
const Cxe = new Uint8Array(16);
function Sxe() {
  if (!x9 && (x9 = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !x9))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return x9(Cxe);
}
const id = [];
for (let o = 0; o < 256; ++o)
  id.push((o + 256).toString(16).slice(1));
function kxe(o, a = 0) {
  return id[o[a + 0]] + id[o[a + 1]] + id[o[a + 2]] + id[o[a + 3]] + "-" + id[o[a + 4]] + id[o[a + 5]] + "-" + id[o[a + 6]] + id[o[a + 7]] + "-" + id[o[a + 8]] + id[o[a + 9]] + "-" + id[o[a + 10]] + id[o[a + 11]] + id[o[a + 12]] + id[o[a + 13]] + id[o[a + 14]] + id[o[a + 15]];
}
const _xe = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Xle = {
  randomUUID: _xe
};
function Exe(o, a, c) {
  if (Xle.randomUUID && !a && !o)
    return Xle.randomUUID();
  o = o || {};
  const f = o.random || (o.rng || Sxe)();
  return f[6] = f[6] & 15 | 64, f[8] = f[8] & 63 | 128, kxe(f);
}
var Txe = ["bsPrefix", "variant", "animation", "size", "children", "as", "className"], hme = /* @__PURE__ */ Ve.forwardRef(function(o, a) {
  var c = o.bsPrefix, f = o.variant, g = o.animation, x = o.size, k = o.children, A = o.as, N = A === void 0 ? "div" : A, H = o.className, Z = Ei(o, Txe);
  c = Fc(c, "spinner");
  var K = c + "-" + g;
  return /* @__PURE__ */ Ve.createElement(N, Zs({
    ref: a
  }, Z, {
    className: er(H, K, x && K + "-" + x, f && "text-" + f)
  }), k);
});
hme.displayName = "Spinner";
const Yse = /* @__PURE__ */ Ve.forwardRef((o, a) => {
  let {
    className: c,
    screenReaderText: f,
    ...g
  } = o;
  const x = {
    ...g,
    className: er("pgn__spinner", c),
    role: f ? "status" : void 0
  };
  return /* @__PURE__ */ Ve.createElement(hme, {
    ...x,
    ref: a
  }, f && /* @__PURE__ */ Ve.createElement("span", {
    className: "sr-only"
  }, f));
});
Yse.propTypes = {
  /** Specifies the class name for the component. */
  className: ce.string,
  /** Specifies the screen reader content for a11y. */
  screenReaderText: ce.node
};
Yse.defaultProps = {
  className: void 0,
  screenReaderText: void 0
};
function Axe(o) {
  let {
    event: a,
    currentIndex: c,
    activeElement: f
  } = o;
  c !== -1 && (f.click(), a.preventDefault());
}
function Oxe(o) {
  let {
    event: a,
    currentIndex: c,
    availableElements: f
  } = o;
  c === -1 && f[0].focus();
  let g;
  (a.key === "ArrowDown" || a.key === "ArrowRight") && (g = f[(c + 1) % f.length]), (a.key === "ArrowUp" || a.key === "ArrowLeft") && (g = c - 1 < 0 ? f[c - 1 + f.length] : f[c - 1]), a.key === "End" && (g = f[f.length - 1]), a.key === "Home" && ([g] = f), g == null || g.focus(), a.preventDefault();
}
function Dxe(o) {
  let {
    event: a,
    ignoredKeys: c = [],
    parentNode: f,
    selectors: g = "a,button,input"
  } = o;
  if (!f)
    return;
  const {
    key: x
  } = a;
  if (!["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft", "Enter", "Home", "End"].includes(x) || c.includes(x))
    return;
  const {
    activeElement: k
  } = document;
  if (!f.contains(k))
    return;
  const A = f.querySelectorAll(g);
  if (!A.length)
    return;
  const N = Array.from(A).findIndex((H) => H === k);
  x === "Enter" && k && Axe({
    event: a,
    currentIndex: N,
    activeElement: k
  }), Oxe({
    event: a,
    currentIndex: N,
    availableElements: A
  });
}
function Rxe() {
  let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    selectors: a,
    ignoredKeys: c
  } = o, f = tt.useRef();
  return tt.useEffect(() => {
    const g = (x) => {
      Dxe({
        event: x,
        ignoredKeys: c,
        parentNode: f.current,
        selectors: a
      });
    };
    return document.addEventListener("keydown", g), () => document.removeEventListener("keydown", g);
  }, [c, a]), f;
}
const Qle = {
  iconButtonOpened: {
    id: "pgn.FormAutosuggest.iconButtonOpened",
    defaultMessage: "Open the options menu",
    description: "A message shown in case when the autosuggest menu is closed."
  },
  iconButtonClosed: {
    id: "pgn.FormAutosuggest.iconButtonClosed",
    defaultMessage: "Close the options menu",
    description: "A message shown in case when the autosuggest menu is opened."
  }
}, Xse = /* @__PURE__ */ tt.forwardRef((o, a) => {
  let {
    children: c,
    arrowKeyNavigationSelector: f,
    ignoredArrowKeysNames: g,
    screenReaderText: x,
    value: k,
    isLoading: A,
    isValueRequired: N,
    valueRequiredErrorMessageText: H,
    isSelectionRequired: Z,
    selectionRequiredErrorMessageText: K,
    hasCustomError: J,
    customErrorMessageText: pe,
    onChange: Se,
    helpMessage: be,
    ...ye
  } = o;
  const re = Lse(), oe = tt.useRef(), U = Rxe({
    selectors: f,
    ignoredKeys: g
  }), [ve, Ze] = tt.useState(!1), [rt, ee] = tt.useState(!1), [lt, wt] = tt.useState(!1), [Vt, Ue] = tt.useState(!1), [Ce, Rn] = tt.useState((k == null ? void 0 : k.userProvidedText) || ""), [_t, ot] = tt.useState([]), [B, fn] = tt.useState(null), [ze, jt] = tt.useState(!0), [Tt, Je] = tt.useState(""), pn = (An) => {
    fn(An);
  }, Ro = () => {
    ot([]), Ze(!1), fn(null);
  }, Rt = (An, qn) => {
    const on = An.currentTarget.getAttribute("data-value"), zt = An.currentTarget.id;
    wt(!0), Ue(!0), Rn(on), Se && (!k || k && on !== k.selectionValue) && Se({
      userProvidedText: on,
      selectionValue: on,
      selectionId: zt
    }), Ro(), qn && qn(An);
  };
  function Cn() {
    let An = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", qn = Ve.Children.map(c, (on) => {
      const {
        children: zt,
        onClick: vt,
        ...oo
      } = on.props, Dn = on.props.id ?? Exe();
      return /* @__PURE__ */ Ve.cloneElement(on, {
        ...oo,
        children: zt,
        "data-value": zt,
        onClick: (ao) => Rt(ao, vt),
        id: Dn,
        onFocus: () => pn(Dn)
      });
    });
    return An.length > 0 && (qn = qn.filter((on) => on.props.children.toLowerCase().includes(An.toLowerCase()))), qn;
  }
  const et = () => {
    ot(Cn(Ce)), jt(!0), Je(""), Ze(!0);
  }, xt = () => {
    ve ? Ro() : et();
  }, X = /* @__PURE__ */ Ve.createElement(rO, {
    className: "pgn__form-autosuggest__icon-button",
    "data-testid": "autosuggest-iconbutton",
    tabIndex: "-1",
    src: ve ? yye : bye,
    iconAs: W4,
    size: "sm",
    variant: "secondary",
    alt: ve ? re.formatMessage(Qle.iconButtonClosed) : re.formatMessage(Qle.iconButtonOpened),
    onClick: xt
  }), ds = () => {
    ee(!0);
  }, So = () => {
    if (J) {
      jt(!1), Je(pe);
      return;
    }
    if (N && !lt) {
      jt(!1), Je(H);
      return;
    }
    if (lt && Z && !Vt) {
      jt(!1), Je(K);
      return;
    }
    jt(!0), Je("");
  };
  tt.useImperativeHandle(a, () => ({
    // expose updateErrorStateAndErrorMessage so consumers can trigger validation
    // when changing the value of the control externally
    updateErrorStateAndErrorMessage: So
  }));
  const At = () => {
    ee(!1), Ro(), So();
  }, Pt = (An) => {
    if (rt) {
      if (An.key === "Escape") {
        An.preventDefault(), oe && oe.current.focus(), Ro();
        return;
      }
      An.key === "Tab" && At();
    }
  }, Hn = (An) => {
    U.current && !U.current.contains(An.target) && rt && At();
  };
  tt.useEffect(() => (document.addEventListener("keydown", Pt), document.addEventListener("click", Hn, !0), () => {
    document.removeEventListener("click", Hn, !0), document.removeEventListener("keydown", Pt);
  })), tt.useEffect(() => {
    Rn(k ? k.userProvidedText ?? "" : ""), wt(!!k && !!k.userProvidedText), Ue(!!k && !!k.selectionValue);
  }, [k]);
  const Nt = () => {
    et();
  }, Vn = (An) => {
    const qn = An.target.value;
    if (!qn.length) {
      Rn(""), wt(!1), Ue(!1), ot([]), Ro(), Se && Se({
        userProvidedText: "",
        selectionValue: "",
        selectionId: ""
      });
      return;
    }
    wt(!0);
    const on = Cn(qn);
    ot(on);
    const zt = on.find((vt) => vt.props.children.toLowerCase() === qn.toLowerCase());
    if (!zt) {
      Ue(!1), Rn(qn), Se && Se({
        userProvidedText: qn,
        selectionValue: "",
        selectionId: ""
      });
      return;
    }
    Ue(!0), Rn(zt.props.children), Se && Se({
      userProvidedText: zt.props.children,
      selectionValue: zt.props.children,
      selectionId: zt.props.id
    });
  }, {
    getControlProps: tn
  } = Hh(), je = tn(ye);
  return /* @__PURE__ */ Ve.createElement("div", {
    className: "pgn__form-autosuggest__wrapper",
    ref: U,
    onFocus: ds
  }, /* @__PURE__ */ Ve.createElement("div", {
    "aria-live": "assertive",
    className: "sr-only",
    "data-testid": "autosuggest-screen-reader-options-count"
  }, `${_t.length} options found`), /* @__PURE__ */ Ve.createElement(fU, {
    controlId: je.id,
    isInvalid: !ze
  }, /* @__PURE__ */ Ve.createElement(aO, {
    ref: oe,
    "aria-expanded": (_t.length > 0).toString(),
    "aria-owns": "pgn__form-autosuggest__dropdown-box",
    role: "combobox",
    "aria-autocomplete": "list",
    autoComplete: "off",
    value: Ce,
    "aria-invalid": Tt,
    "aria-activedescendant": B,
    onChange: Vn,
    onClick: Nt,
    trailingElement: X,
    "data-testid": "autosuggest-textbox-input",
    ...je
  }), be && ze && /* @__PURE__ */ Ve.createElement(W2, {
    type: "default"
  }, be), !ze && /* @__PURE__ */ Ve.createElement(W2, {
    type: "invalid",
    "feedback-for": je.name
  }, Tt)), /* @__PURE__ */ Ve.createElement("ul", {
    id: "pgn__form-autosuggest__dropdown-box",
    className: "pgn__form-autosuggest__dropdown",
    role: "listbox"
  }, A ? /* @__PURE__ */ Ve.createElement("div", {
    className: "pgn__form-autosuggest__dropdown-loading"
  }, /* @__PURE__ */ Ve.createElement(Yse, {
    animation: "border",
    variant: "dark",
    screenReaderText: x,
    "data-testid": "autosuggest-loading-spinner"
  })) : _t.length > 0 && _t));
});
Xse.defaultProps = {
  arrowKeyNavigationSelector: "a:not(:disabled),li:not(:disabled, .btn-icon),input:not(:disabled)",
  ignoredArrowKeysNames: ["ArrowRight", "ArrowLeft"],
  isLoading: !1,
  className: null,
  floatingLabel: null,
  onChange: null,
  helpMessage: "",
  placeholder: "",
  value: null,
  isValueRequired: !1,
  valueRequiredErrorMessageText: null,
  isSelectionRequired: !1,
  selectionRequiredErrorMessageText: null,
  hasCustomError: !1,
  customErrorMessageText: null,
  readOnly: !1,
  children: null,
  name: "form-autosuggest",
  screenReaderText: "loading"
};
Xse.propTypes = {
  /**
   * Specifies the CSS selector string that indicates to which elements
   * the user can navigate using the arrow keys
  */
  arrowKeyNavigationSelector: ce.string,
  /** Specifies ignored hook keys. */
  ignoredArrowKeysNames: ce.arrayOf(ce.string),
  /** Specifies loading state. */
  isLoading: ce.bool,
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies floating label to display for the input component. */
  floatingLabel: ce.string,
  /** Specifies onChange event handler. */
  onChange: ce.func,
  /** Specifies help information for the user. */
  helpMessage: ce.string,
  /** Specifies the placeholder text for the input. */
  placeholder: ce.string,
  /** Specifies values for the input. */
  value: ce.shape({
    userProvidedText: ce.string,
    selectionValue: ce.string,
    selectionId: ce.string
  }),
  /** Specifies if empty values trigger an error state */
  isValueRequired: ce.bool,
  /** Informs user they must input a value. */
  valueRequiredErrorMessageText: cte(ce.string, "isValueRequired"),
  /** Specifies if freeform values trigger an error state */
  isSelectionRequired: ce.bool,
  /** Informs user they must make a selection. */
  selectionRequiredErrorMessageText: cte(ce.string, "isSelectionRequired"),
  /** Specifies the control is in a consumer provided error state */
  hasCustomError: ce.bool,
  /** Informs user of other errors. */
  customErrorMessageText: cte(ce.string, "hasCustomError"),
  /** Specifies the name of the base input element. */
  name: ce.string,
  /** Selected list item is read-only. */
  readOnly: ce.bool,
  /** Specifies the content of the `FormAutosuggest`. */
  children: ce.node,
  /** Specifies the screen reader text */
  screenReaderText: ce.string
};
function Qse(o) {
  let {
    as: a,
    children: c,
    defaultSelected: f,
    iconAfter: g,
    iconBefore: x,
    ...k
  } = o;
  const A = er(k.className, "pgn__menu-item");
  return /* @__PURE__ */ Ve.createElement(a, {
    ...k,
    className: A
  }, /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, x && /* @__PURE__ */ Ve.createElement(W4, {
    className: "btn-icon-before",
    src: x
  }), /* @__PURE__ */ Ve.createElement("span", {
    className: "pgn__menu-item-text"
  }, c), /* @__PURE__ */ Ve.createElement("span", {
    className: "pgn__menu-item-content-spacer"
  }), g && /* @__PURE__ */ Ve.createElement(W4, {
    className: "btn-icon-after",
    src: g
  })));
}
Qse.propTypes = {
  /** Specifies that this ``MenuItem`` is selected inside the ``SelectMenu`` */
  defaultSelected: ce.bool,
  /** Specifies class name to append to the base element */
  className: ce.string,
  /** Specifies the content of the ``MenuItem`` */
  children: ce.node,
  /** Specifies the base element */
  as: ce.elementType,
  /** Specifies the jsx before the content of the ``MenuItem`` */
  iconBefore: ce.oneOfType([ce.element, ce.elementType]),
  /** Specifies the jsx after the content of the ``MenuItem`` */
  iconAfter: ce.oneOfType([ce.element, ce.elementType])
};
Qse.defaultProps = {
  defaultSelected: !1,
  as: "button",
  className: void 0,
  children: null,
  iconBefore: void 0,
  iconAfter: void 0
};
function Jse(o) {
  let {
    children: a,
    className: c,
    onClick: f,
    ...g
  } = o;
  return /* @__PURE__ */ Ve.createElement(Qse, {
    as: "li",
    "data-testid": "autosuggest-optionitem",
    role: "option",
    tabIndex: "-1",
    onClick: f,
    className: er(c, "dropdown-item"),
    ...g
  }, a);
}
Jse.defaultProps = {
  className: null,
  children: null,
  onClick: null
};
Jse.propTypes = {
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies the text-content of the `FormAutosuggestOption`. */
  children: ce.string,
  /** A click handler for the `FormAutosuggestOption` */
  onClick: ce.func
};
const Nxe = (o) => o, gme = /* @__PURE__ */ Ve.createContext({
  getCheckboxControlProps: Nxe,
  hasCheckboxSetProvider: !1
}), vme = () => tt.useContext(gme);
function ere(o) {
  let {
    children: a,
    name: c,
    onBlur: f,
    onFocus: g,
    onChange: x,
    value: k,
    defaultValue: A
  } = o;
  const N = !A && Array.isArray(k), Z = {
    name: c,
    value: k,
    defaultValue: A,
    getCheckboxControlProps: (K) => ({
      ...K,
      name: c,
      /* istanbul ignore next */
      onBlur: K.onBlur ? Vk(f, K.onBlur) : f,
      /* istanbul ignore next */
      onFocus: K.onFocus ? Vk(g, K.onFocus) : g,
      /* istanbul ignore next */
      onChange: K.onChange ? Vk(x, K.onChange) : x,
      checked: N ? k.includes(K.value) : void 0,
      defaultChecked: N ? void 0 : A && A.includes(K.value)
    }),
    onBlur: f,
    onFocus: g,
    onChange: x,
    hasCheckboxSetProvider: !0
  };
  return /* @__PURE__ */ Ve.createElement(gme.Provider, {
    value: Z
  }, a);
}
ere.propTypes = {
  children: ce.node.isRequired,
  name: ce.string,
  onBlur: ce.func,
  onFocus: ce.func,
  onChange: ce.func,
  value: ce.arrayOf(ce.string),
  defaultValue: ce.arrayOf(ce.string)
};
ere.defaultProps = {
  onBlur: void 0,
  name: void 0,
  onFocus: void 0,
  onChange: void 0,
  value: void 0,
  defaultValue: void 0
};
const tre = /* @__PURE__ */ Ve.forwardRef((o, a) => {
  let {
    isIndeterminate: c,
    ...f
  } = o;
  const {
    getCheckboxControlProps: g,
    hasCheckboxSetProvider: x
  } = vme(), k = Ve.useRef(), A = a || k, {
    getControlProps: N
  } = Hh();
  let H = N({
    ...f,
    className: er("pgn__form-checkbox-input", f.className)
  });
  return x && (H = g(H)), Ve.useEffect(() => {
    A.current && (A.current.indeterminate = c);
  }, [A, c]), /* @__PURE__ */ Ve.createElement("input", {
    type: "checkbox",
    ...H,
    ref: A
  });
});
tre.propTypes = {
  /** Specifies whether the checkbox should be rendered in indeterminate state. */
  isIndeterminate: ce.bool,
  /** Specifies class name to append to the base element. */
  className: ce.string
};
tre.defaultProps = {
  isIndeterminate: !1,
  className: void 0
};
const gU = /* @__PURE__ */ Ve.forwardRef((o, a) => {
  let {
    children: c,
    className: f,
    controlClassName: g,
    labelClassName: x,
    description: k,
    isInvalid: A,
    isValid: N,
    controlAs: H,
    floatLabelLeft: Z,
    ...K
  } = o;
  const {
    hasCheckboxSetProvider: J
  } = vme(), {
    hasFormGroupProvider: pe,
    useSetIsControlGroupEffect: Se,
    getControlProps: be
  } = Hh();
  Se(!0);
  const re = pe && !J ? {
    ...be({}),
    role: "group"
  } : {}, oe = /* @__PURE__ */ Ve.createElement(H, {
    ...K,
    className: g,
    ref: a
  });
  return /* @__PURE__ */ Ve.createElement(fU, {
    controlId: K.id,
    isInvalid: A,
    isValid: N
  }, /* @__PURE__ */ Ve.createElement("div", {
    className: er("pgn__form-checkbox", f, {
      "pgn__form-control-valid": N,
      "pgn__form-control-invalid": A,
      "pgn__form-control-disabled": K.disabled,
      "pgn__form-control-label-left": !!Z
    }),
    ...re
  }, oe, /* @__PURE__ */ Ve.createElement("div", null, /* @__PURE__ */ Ve.createElement(pU, {
    className: x
  }, c), k && /* @__PURE__ */ Ve.createElement(W2, {
    hasIcon: !1
  }, k))));
});
gU.propTypes = {
  /** Specifies id of the FormCheckbox component. */
  id: ce.string,
  /** Specifies contents of the component. */
  children: ce.node.isRequired,
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies class name for control component. */
  controlClassName: ce.string,
  /** Specifies class name for label component. */
  labelClassName: ce.string,
  /** Specifies description to show under the checkbox. */
  description: ce.node,
  /** Specifies whether to display checkbox in invalid state, this affects styling. */
  isInvalid: ce.bool,
  /** Specifies whether to display checkbox in valid state, this affects styling. */
  isValid: ce.bool,
  /** Specifies control element. */
  controlAs: ce.elementType,
  /** Specifies whether the floating label should be aligned to the left. */
  floatLabelLeft: ce.bool,
  /** Specifies whether the `FormCheckbox` is disabled. */
  disabled: ce.bool
};
gU.defaultProps = {
  id: void 0,
  className: void 0,
  controlClassName: void 0,
  labelClassName: void 0,
  description: void 0,
  isInvalid: !1,
  isValid: !1,
  controlAs: tre,
  floatLabelLeft: !1,
  disabled: !1
};
const nre = /* @__PURE__ */ Ve.forwardRef((o, a) => {
  let {
    isIndeterminate: c,
    ...f
  } = o;
  const g = Ve.useRef(), x = a || g, {
    getControlProps: k
  } = Hh(), A = k({
    ...f,
    className: er("pgn__form-switch-input", f.className)
  });
  return Ve.useEffect(() => {
    x.current && (x.current.indeterminate = c);
  }, [x, c]), /* @__PURE__ */ Ve.createElement("input", {
    type: "checkbox",
    ...A,
    ref: x
  });
});
nre.propTypes = {
  /** Specifies whether input should be rendered in indeterminate state. */
  isIndeterminate: ce.bool,
  /** Specifies class name to append to the base element. */
  className: ce.string
};
nre.defaultProps = {
  isIndeterminate: !1,
  className: void 0
};
const ore = /* @__PURE__ */ Ve.forwardRef((o, a) => {
  let {
    children: c,
    className: f,
    helperText: g,
    ...x
  } = o;
  return /* @__PURE__ */ Ve.createElement("div", {
    className: "d-inline-flex flex-column"
  }, /* @__PURE__ */ Ve.createElement(gU, {
    className: er("pgn__form-switch", f),
    ...x,
    role: "switch",
    ref: a,
    controlAs: nre,
    isValid: null,
    isInvalid: null,
    description: null
  }, c), g && /* @__PURE__ */ Ve.createElement("div", {
    className: "pgn__form-switch-helper-text"
  }, g));
});
ore.propTypes = {
  /** Specifies contents of the component. */
  children: ce.node.isRequired,
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies class name to append to the label element. */
  labelClassName: ce.string,
  /** Specifies helper text to display below the switch. */
  helperText: ce.node,
  /** Determines whether the label should float to the left when the switch is active. */
  floatLabelLeft: ce.bool
};
ore.defaultProps = {
  className: void 0,
  labelClassName: void 0,
  helperText: void 0,
  floatLabelLeft: !1
};
function vU(o) {
  let {
    children: a,
    name: c,
    value: f,
    defaultValue: g,
    isInline: x,
    onChange: k,
    onFocus: A,
    onBlur: N,
    ...H
  } = o;
  const {
    getControlProps: Z,
    useSetIsControlGroupEffect: K
  } = Hh();
  K(!0);
  const J = Z(H);
  return /* @__PURE__ */ Ve.createElement(ere, {
    name: c,
    value: f,
    defaultValue: g,
    onFocus: A,
    onBlur: N,
    onChange: k
  }, /* @__PURE__ */ Ve.createElement(hU, {
    role: "group",
    isInline: x,
    ...J
  }, a));
}
vU.propTypes = {
  /** Specifies contents of the component. */
  children: ce.node.isRequired,
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies name for the component. */
  name: ce.string.isRequired,
  /** Specifies values for the checkboxes. */
  value: ce.arrayOf(ce.string),
  /** Specifies default values for the checkboxes. */
  defaultValue: ce.arrayOf(ce.string),
  /** Specifies whether to display components with inline styling. */
  isInline: ce.bool,
  /** Specifies onChange event handler. */
  onChange: ce.func,
  /** Specifies onFocus event handler. */
  onFocus: ce.func,
  /** Specifies onBlur event handler. */
  onBlur: ce.func
};
vU.defaultProps = {
  className: void 0,
  value: void 0,
  defaultValue: void 0,
  isInline: !1,
  onChange: void 0,
  onFocus: void 0,
  onBlur: void 0
};
const Zd = lv;
Zd.Control = aO;
Zd.Radio = qse;
Zd.RadioSet = Kse;
Zd.Autosuggest = Xse;
Zd.AutosuggestOption = Jse;
Zd.Checkbox = gU;
Zd.CheckboxSet = vU;
Zd.Switch = ore;
Zd.SwitchSet = vU;
Zd.Label = pU;
Zd.Group = mme;
Zd.Text = mU;
const Pxe = /* @__PURE__ */ Ve.createContext({
  onClose: () => {
  },
  isOpen: !1,
  isBlocking: !1
});
function Mxe(o) {
  let {
    onClose: a,
    isOpen: c,
    isBlocking: f = !1,
    children: g = null
  } = o;
  const x = tt.useMemo(() => ({
    onClose: a,
    isOpen: c,
    isBlocking: f
  }), [a, c, f]);
  return /* @__PURE__ */ Ve.createElement(Pxe.Provider, {
    value: x
  }, g);
}
var V9 = "right-scroll-bar-position", U9 = "width-before-scroll-bar", Ixe = "with-scroll-bars-hidden", Fxe = "--removed-body-scroll-bar-size";
function wte(o, a) {
  return typeof o == "function" ? o(a) : o && (o.current = a), o;
}
function Bxe(o, a) {
  var c = tt.useState(function() {
    return {
      // value
      value: o,
      // last callback
      callback: a,
      // "memoized" public interface
      facade: {
        get current() {
          return c.value;
        },
        set current(f) {
          var g = c.value;
          g !== f && (c.value = f, c.callback(f, g));
        }
      }
    };
  })[0];
  return c.callback = a, c.facade;
}
var Lxe = typeof window < "u" ? tt.useLayoutEffect : tt.useEffect, Jle = /* @__PURE__ */ new WeakMap();
function bme(o, a) {
  var c = Bxe(null, function(f) {
    return o.forEach(function(g) {
      return wte(g, f);
    });
  });
  return Lxe(function() {
    var f = Jle.get(c);
    if (f) {
      var g = new Set(f), x = new Set(o), k = c.current;
      g.forEach(function(A) {
        x.has(A) || wte(A, null);
      }), x.forEach(function(A) {
        g.has(A) || wte(A, k);
      });
    }
    Jle.set(c, o);
  }, [o]), c;
}
function yme(o) {
  return o;
}
function xme(o, a) {
  a === void 0 && (a = yme);
  var c = [], f = !1, g = {
    read: function() {
      if (f)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return c.length ? c[c.length - 1] : o;
    },
    useMedium: function(x) {
      var k = a(x, f);
      return c.push(k), function() {
        c = c.filter(function(A) {
          return A !== k;
        });
      };
    },
    assignSyncMedium: function(x) {
      for (f = !0; c.length; ) {
        var k = c;
        c = [], k.forEach(x);
      }
      c = {
        push: function(A) {
          return x(A);
        },
        filter: function() {
          return c;
        }
      };
    },
    assignMedium: function(x) {
      f = !0;
      var k = [];
      if (c.length) {
        var A = c;
        c = [], A.forEach(x), k = c;
      }
      var N = function() {
        var Z = k;
        k = [], Z.forEach(x);
      }, H = function() {
        return Promise.resolve().then(N);
      };
      H(), c = {
        push: function(Z) {
          k.push(Z), H();
        },
        filter: function(Z) {
          return k = k.filter(Z), c;
        }
      };
    }
  };
  return g;
}
function sre(o, a) {
  return a === void 0 && (a = yme), xme(o, a);
}
function rre(o) {
  o === void 0 && (o = {});
  var a = xme(null);
  return a.options = Wd({ async: !0, ssr: !1 }, o), a;
}
var wme = function(o) {
  var a = o.sideCar, c = X4(o, ["sideCar"]);
  if (!a)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var f = a.read();
  if (!f)
    throw new Error("Sidecar medium not found");
  return tt.createElement(f, Wd({}, c));
};
wme.isSideCarExport = !0;
function are(o, a) {
  return o.useMedium(a), wme;
}
var Cme = rre(), Cte = function() {
}, ire = tt.forwardRef(function(o, a) {
  var c = tt.useRef(null), f = tt.useState({
    onScrollCapture: Cte,
    onWheelCapture: Cte,
    onTouchMoveCapture: Cte
  }), g = f[0], x = f[1], k = o.forwardProps, A = o.children, N = o.className, H = o.removeScrollBar, Z = o.enabled, K = o.shards, J = o.sideCar, pe = o.noRelative, Se = o.noIsolation, be = o.inert, ye = o.allowPinchZoom, re = o.as, oe = re === void 0 ? "div" : re, U = o.gapMode, ve = X4(o, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), Ze = J, rt = bme([c, a]), ee = Wd(Wd({}, ve), g);
  return tt.createElement(
    tt.Fragment,
    null,
    Z && tt.createElement(Ze, { sideCar: Cme, removeScrollBar: H, shards: K, noRelative: pe, noIsolation: Se, inert: be, setCallbacks: x, allowPinchZoom: !!ye, lockRef: c, gapMode: U }),
    k ? tt.cloneElement(tt.Children.only(A), Wd(Wd({}, ee), { ref: rt })) : tt.createElement(oe, Wd({}, ee, { className: N, ref: rt }), A)
  );
});
ire.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
ire.classNames = {
  fullWidth: U9,
  zeroRight: V9
};
var Yne = "data-focus-lock", Sme = "data-focus-lock-disabled", $xe = "data-no-focus-lock", Hxe = "data-autofocus-inside", zxe = "data-no-autofocus", Ste = {
  width: "1px",
  height: "0px",
  padding: 0,
  overflow: "hidden",
  position: "fixed",
  top: "1px",
  left: "1px"
}, kme = sre({}, function(o) {
  var a = o.target, c = o.currentTarget;
  return {
    target: a,
    currentTarget: c
  };
}), _me = sre(), Vxe = sre(), Eme = rre({
  async: !0,
  ssr: typeof document < "u"
}), Uxe = /* @__PURE__ */ tt.createContext(void 0), jxe = [], Tme = /* @__PURE__ */ tt.forwardRef(function(a, c) {
  var f, g = tt.useState(), x = g[0], k = g[1], A = tt.useRef(), N = tt.useRef(!1), H = tt.useRef(null), Z = tt.useState({}), K = Z[1], J = a.children, pe = a.disabled, Se = pe === void 0 ? !1 : pe, be = a.noFocusGuards, ye = be === void 0 ? !1 : be, re = a.persistentFocus, oe = re === void 0 ? !1 : re, U = a.crossFrame, ve = U === void 0 ? !0 : U, Ze = a.autoFocus, rt = Ze === void 0 ? !0 : Ze;
  a.allowTextSelection;
  var ee = a.group, lt = a.className, wt = a.whiteList, Vt = a.hasPositiveIndices, Ue = a.shards, Ce = Ue === void 0 ? jxe : Ue, Rn = a.as, _t = Rn === void 0 ? "div" : Rn, ot = a.lockProps, B = ot === void 0 ? {} : ot, fn = a.sideCar, ze = a.returnFocus, jt = ze === void 0 ? !1 : ze, Tt = a.focusOptions, Je = a.onActivation, pn = a.onDeactivation, Ro = tt.useState({}), Rt = Ro[0], Cn = tt.useCallback(function(tn) {
    var je = tn.captureFocusRestore;
    if (!H.current) {
      var An, qn = (An = document) == null ? void 0 : An.activeElement;
      H.current = qn, qn !== document.body && (H.current = je(qn));
    }
    A.current && Je && Je(A.current), N.current = !0, K();
  }, [Je]), et = tt.useCallback(function() {
    N.current = !1, pn && pn(A.current), K();
  }, [pn]), xt = tt.useCallback(function(tn) {
    var je = H.current;
    if (je) {
      var An = (typeof je == "function" ? je() : je) || document.body, qn = typeof jt == "function" ? jt(An) : jt;
      if (qn) {
        var on = typeof qn == "object" ? qn : void 0;
        H.current = null, tn ? Promise.resolve().then(function() {
          return An.focus(on);
        }) : An.focus(on);
      }
    }
  }, [jt]), X = tt.useCallback(function(tn) {
    N.current && kme.useMedium(tn);
  }, []), ds = _me.useMedium, So = tt.useCallback(function(tn) {
    A.current !== tn && (A.current = tn, k(tn));
  }, []), At = Zs((f = {}, f[Sme] = Se && "disabled", f[Yne] = ee, f), B), Pt = ye !== !0, Hn = Pt && ye !== "tail", Nt = bme([c, So]), Vn = tt.useMemo(function() {
    return {
      observed: A,
      shards: Ce,
      enabled: !Se,
      active: N.current
    };
  }, [Se, N.current, Ce, x]);
  return /* @__PURE__ */ Ve.createElement(tt.Fragment, null, Pt && [
    /* @__PURE__ */ Ve.createElement("div", {
      key: "guard-first",
      "data-focus-guard": !0,
      tabIndex: Se ? -1 : 0,
      style: Ste
    }),
    Vt ? /* @__PURE__ */ Ve.createElement("div", {
      key: "guard-nearest",
      "data-focus-guard": !0,
      tabIndex: Se ? -1 : 1,
      style: Ste
    }) : null
  ], !Se && /* @__PURE__ */ Ve.createElement(fn, {
    id: Rt,
    sideCar: Eme,
    observed: x,
    disabled: Se,
    persistentFocus: oe,
    crossFrame: ve,
    autoFocus: rt,
    whiteList: wt,
    shards: Ce,
    onActivation: Cn,
    onDeactivation: et,
    returnFocus: xt,
    focusOptions: Tt,
    noFocusGuards: ye
  }), /* @__PURE__ */ Ve.createElement(_t, Zs({
    ref: Nt
  }, At, {
    className: lt,
    onBlur: ds,
    onFocus: X
  }), /* @__PURE__ */ Ve.createElement(Uxe.Provider, {
    value: Vn
  }, J)), Hn && /* @__PURE__ */ Ve.createElement("div", {
    "data-focus-guard": !0,
    tabIndex: Se ? -1 : 0,
    style: Ste
  }));
});
Tme.propTypes = {};
function lre(o) {
  setTimeout(o, 1);
}
var Wxe = function(a) {
  return a && "current" in a ? a.current : a;
}, Ame = rre(), Ome = "data-focus-on-hidden", Zxe = { preventScroll: !0 }, Gxe = tt.forwardRef(function(o, a) {
  var c = tt.useState(!1), f = c[0], g = c[1], x = o.children, k = o.autoFocus, A = o.shards, N = o.crossFrame, H = o.enabled, Z = H === void 0 ? !0 : H, K = o.scrollLock, J = K === void 0 ? !0 : K, pe = o.focusLock, Se = pe === void 0 ? !0 : pe, be = o.returnFocus, ye = be === void 0 ? !0 : be, re = o.inert, oe = o.allowPinchZoom, U = o.sideCar, ve = o.className, Ze = o.shouldIgnore, rt = o.preventScrollOnFocus, ee = o.style, lt = o.as, wt = o.gapMode, Vt = X4(o, ["children", "autoFocus", "shards", "crossFrame", "enabled", "scrollLock", "focusLock", "returnFocus", "inert", "allowPinchZoom", "sideCar", "className", "shouldIgnore", "preventScrollOnFocus", "style", "as", "gapMode"]), Ue = U, Ce = f.onActivation, Rn = f.onDeactivation, _t = X4(f, ["onActivation", "onDeactivation"]), ot = Wd(Wd({}, _t), {
    as: lt,
    style: ee,
    sideCar: U,
    shards: A,
    allowPinchZoom: oe,
    gapMode: wt,
    inert: re,
    enabled: Z && J
  });
  return tt.createElement(
    tt.Fragment,
    null,
    tt.createElement(Tme, { ref: a, sideCar: U, disabled: !(f && Z && Se), returnFocus: ye, autoFocus: k, shards: A, crossFrame: N, onActivation: Ce, onDeactivation: Rn, className: ve, whiteList: Ze, lockProps: ot, focusOptions: rt ? Zxe : void 0, as: ire }, x),
    Z && tt.createElement(Ue, Wd({}, Vt, { sideCar: Ame, setLockProps: g, shards: A }))
  );
});
function _I(o) {
  "@babel/helpers - typeof";
  return _I = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(a) {
    return typeof a;
  } : function(a) {
    return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
  }, _I(o);
}
function qxe(o, a) {
  if (_I(o) != "object" || !o) return o;
  var c = o[Symbol.toPrimitive];
  if (c !== void 0) {
    var f = c.call(o, a || "default");
    if (_I(f) != "object") return f;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (a === "string" ? String : Number)(o);
}
function Kxe(o) {
  var a = qxe(o, "string");
  return _I(a) == "symbol" ? a : a + "";
}
function Yxe(o, a, c) {
  return (a = Kxe(a)) in o ? Object.defineProperty(o, a, {
    value: c,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : o[a] = c, o;
}
function Xxe(o, a) {
  function c(f) {
    return f.displayName || f.name || "Component";
  }
  return function(g) {
    var x = [], k;
    function A() {
      k = o(x.map(function(H) {
        return H.props;
      })), a(k);
    }
    var N = /* @__PURE__ */ function(H) {
      Nse(Z, H);
      function Z() {
        return H.apply(this, arguments) || this;
      }
      Z.peek = function() {
        return k;
      };
      var K = Z.prototype;
      return K.componentDidMount = function() {
        x.push(this), A();
      }, K.componentDidUpdate = function() {
        A();
      }, K.componentWillUnmount = function() {
        var pe = x.indexOf(this);
        x.splice(pe, 1), A();
      }, K.render = function() {
        return /* @__PURE__ */ Ve.createElement(g, this.props);
      }, Z;
    }(tt.PureComponent);
    return Yxe(N, "displayName", "SideEffect(" + c(g) + ")"), N;
  };
}
var $b = function(o) {
  for (var a = Array(o.length), c = 0; c < o.length; ++c)
    a[c] = o[c];
  return a;
}, Qk = function(o) {
  return Array.isArray(o) ? o : [o];
}, Dme = function(o) {
  return Array.isArray(o) ? o[0] : o;
}, Qxe = function(o) {
  if (o.nodeType !== Node.ELEMENT_NODE)
    return !1;
  var a = window.getComputedStyle(o, null);
  return !a || !a.getPropertyValue ? !1 : a.getPropertyValue("display") === "none" || a.getPropertyValue("visibility") === "hidden";
}, Rme = function(o) {
  return o.parentNode && o.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    o.parentNode.host
  ) : o.parentNode;
}, Nme = function(o) {
  return o === document || o && o.nodeType === Node.DOCUMENT_NODE;
}, Jxe = function(o) {
  return o.hasAttribute("inert");
}, e2e = function(o, a) {
  return !o || Nme(o) || !Qxe(o) && !Jxe(o) && a(Rme(o));
}, Pme = function(o, a) {
  var c = o.get(a);
  if (c !== void 0)
    return c;
  var f = e2e(a, Pme.bind(void 0, o));
  return o.set(a, f), f;
}, t2e = function(o, a) {
  return o && !Nme(o) ? s2e(o) ? a(Rme(o)) : !1 : !0;
}, Mme = function(o, a) {
  var c = o.get(a);
  if (c !== void 0)
    return c;
  var f = t2e(a, Mme.bind(void 0, o));
  return o.set(a, f), f;
}, Ime = function(o) {
  return o.dataset;
}, n2e = function(o) {
  return o.tagName === "BUTTON";
}, Fme = function(o) {
  return o.tagName === "INPUT";
}, Bme = function(o) {
  return Fme(o) && o.type === "radio";
}, o2e = function(o) {
  return !((Fme(o) || n2e(o)) && (o.type === "hidden" || o.disabled));
}, s2e = function(o) {
  var a = o.getAttribute(zxe);
  return ![!0, "true", ""].includes(a);
}, cre = function(o) {
  var a;
  return !!(o && (!((a = Ime(o)) === null || a === void 0) && a.focusGuard));
}, Xne = function(o) {
  return !cre(o);
}, r2e = function(o) {
  return !!o;
}, a2e = function(o, a) {
  var c = Math.max(0, o.tabIndex), f = Math.max(0, a.tabIndex), g = c - f, x = o.index - a.index;
  if (g) {
    if (!c)
      return 1;
    if (!f)
      return -1;
  }
  return g || x;
}, i2e = function(o) {
  return o.tabIndex < 0 && !o.hasAttribute("tabindex") ? 0 : o.tabIndex;
}, ure = function(o, a, c) {
  return $b(o).map(function(f, g) {
    var x = i2e(f);
    return {
      node: f,
      index: g,
      tabIndex: c && x === -1 ? (f.dataset || {}).focusGuard ? 0 : -1 : x
    };
  }).filter(function(f) {
    return !a || f.tabIndex >= 0;
  }).sort(a2e);
}, l2e = [
  "button:enabled",
  "select:enabled",
  "textarea:enabled",
  "input:enabled",
  // elements with explicit roles will also use explicit tabindex
  // '[role="button"]',
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[tabindex]",
  "[contenteditable]",
  "[autofocus]"
], dre = l2e.join(","), c2e = "".concat(dre, ", [data-focus-guard]"), Lme = function(o, a) {
  return $b((o.shadowRoot || o).children).reduce(function(c, f) {
    return c.concat(f.matches(a ? c2e : dre) ? [f] : [], Lme(f));
  }, []);
}, u2e = function(o, a) {
  var c;
  return o instanceof HTMLIFrameElement && (!((c = o.contentDocument) === null || c === void 0) && c.body) ? J4([o.contentDocument.body], a) : [o];
}, J4 = function(o, a) {
  return o.reduce(function(c, f) {
    var g, x = Lme(f, a), k = (g = []).concat.apply(g, x.map(function(A) {
      return u2e(A, a);
    }));
    return c.concat(
      // add all tabbables inside and within shadow DOMs in DOM order
      k,
      // add if node is tabbable itself
      f.parentNode ? $b(f.parentNode.querySelectorAll(dre)).filter(function(A) {
        return A === f;
      }) : []
    );
  }, []);
}, d2e = function(o) {
  var a = o.querySelectorAll("[".concat(Hxe, "]"));
  return $b(a).map(function(c) {
    return J4([c]);
  }).reduce(function(c, f) {
    return c.concat(f);
  }, []);
}, fre = function(o, a) {
  return $b(o).filter(function(c) {
    return Pme(a, c);
  }).filter(function(c) {
    return o2e(c);
  });
}, ece = function(o, a) {
  return a === void 0 && (a = /* @__PURE__ */ new Map()), $b(o).filter(function(c) {
    return Mme(a, c);
  });
}, mre = function(o, a, c) {
  return ure(fre(J4(o, c), a), !0, c);
}, EI = function(o, a) {
  return ure(fre(J4(o), a), !1);
}, f2e = function(o, a) {
  return fre(d2e(o), a);
}, Uk = function(o, a) {
  return o.shadowRoot ? Uk(o.shadowRoot, a) : Object.getPrototypeOf(o).contains !== void 0 && Object.getPrototypeOf(o).contains.call(o, a) ? !0 : $b(o.children).some(function(c) {
    var f;
    if (c instanceof HTMLIFrameElement) {
      var g = (f = c.contentDocument) === null || f === void 0 ? void 0 : f.body;
      return g ? Uk(g, a) : !1;
    }
    return Uk(c, a);
  });
}, m2e = function(o) {
  for (var a = /* @__PURE__ */ new Set(), c = o.length, f = 0; f < c; f += 1)
    for (var g = f + 1; g < c; g += 1) {
      var x = o[f].compareDocumentPosition(o[g]);
      (x & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0 && a.add(g), (x & Node.DOCUMENT_POSITION_CONTAINS) > 0 && a.add(f);
    }
  return o.filter(function(k, A) {
    return !a.has(A);
  });
}, $me = function(o) {
  return o.parentNode ? $me(o.parentNode) : o;
}, pre = function(o) {
  var a = Qk(o);
  return a.filter(Boolean).reduce(function(c, f) {
    var g = f.getAttribute(Yne);
    return c.push.apply(c, g ? m2e($b($me(f).querySelectorAll("[".concat(Yne, '="').concat(g, '"]:not([').concat(Sme, '="disabled"])')))) : [f]), c;
  }, []);
}, p2e = function(o) {
  try {
    return o();
  } catch {
    return;
  }
}, TI = function(o) {
  if (o === void 0 && (o = document), !(!o || !o.activeElement)) {
    var a = o.activeElement;
    return a.shadowRoot ? TI(a.shadowRoot) : a instanceof HTMLIFrameElement && p2e(function() {
      return a.contentWindow.document;
    }) ? TI(a.contentWindow.document) : a;
  }
}, h2e = function(o, a) {
  return o === a;
}, g2e = function(o, a) {
  return !!$b(o.querySelectorAll("iframe")).some(function(c) {
    return h2e(c, a);
  });
}, Hme = function(o, a) {
  return a === void 0 && (a = TI(Dme(o).ownerDocument)), !a || a.dataset && a.dataset.focusGuard ? !1 : pre(o).some(function(c) {
    return Uk(c, a) || g2e(c, a);
  });
}, v2e = function(o) {
  o === void 0 && (o = document);
  var a = TI(o);
  return a ? $b(o.querySelectorAll("[".concat($xe, "]"))).some(function(c) {
    return Uk(c, a);
  }) : !1;
}, b2e = function(o, a) {
  return a.filter(Bme).filter(function(c) {
    return c.name === o.name;
  }).filter(function(c) {
    return c.checked;
  })[0] || o;
}, hre = function(o, a) {
  return Bme(o) && o.name ? b2e(o, a) : o;
}, y2e = function(o) {
  var a = /* @__PURE__ */ new Set();
  return o.forEach(function(c) {
    return a.add(hre(c, o));
  }), o.filter(function(c) {
    return a.has(c);
  });
}, tce = function(o) {
  return o[0] && o.length > 1 ? hre(o[0], o) : o[0];
}, nce = function(o, a) {
  return o.indexOf(hre(a, o));
}, Qne = "NEW_FOCUS", x2e = function(o, a, c, f, g) {
  var x = o.length, k = o[0], A = o[x - 1], N = cre(f);
  if (!(f && o.indexOf(f) >= 0)) {
    var H = f !== void 0 ? c.indexOf(f) : -1, Z = g ? c.indexOf(g) : H, K = g ? o.indexOf(g) : -1;
    if (H === -1)
      return K !== -1 ? K : Qne;
    if (K === -1)
      return Qne;
    var J = H - Z, pe = c.indexOf(k), Se = c.indexOf(A), be = y2e(c), ye = f !== void 0 ? be.indexOf(f) : -1, re = g ? be.indexOf(g) : ye, oe = be.filter(function(lt) {
      return lt.tabIndex >= 0;
    }), U = f !== void 0 ? oe.indexOf(f) : -1, ve = g ? oe.indexOf(g) : U, Ze = U >= 0 && ve >= 0 ? (
      // old/new are tabbables, measure distance in tabbable space
      ve - U
    ) : (
      // or else measure in focusable space
      re - ye
    );
    if (!J && K >= 0 || a.length === 0)
      return K;
    var rt = nce(o, a[0]), ee = nce(o, a[a.length - 1]);
    if (H <= pe && N && Math.abs(J) > 1)
      return ee;
    if (H >= Se && N && Math.abs(J) > 1)
      return rt;
    if (J && Math.abs(Ze) > 1)
      return K;
    if (H <= pe)
      return ee;
    if (H > Se)
      return rt;
    if (J)
      return Math.abs(J) > 1 ? K : (x + K + J) % x;
  }
}, w2e = function(o) {
  return function(a) {
    var c, f = (c = Ime(a)) === null || c === void 0 ? void 0 : c.autofocus;
    return (
      // @ts-expect-error
      a.autofocus || //
      f !== void 0 && f !== "false" || //
      o.indexOf(a) >= 0
    );
  };
}, oce = function(o, a, c) {
  var f = o.map(function(x) {
    var k = x.node;
    return k;
  }), g = ece(f.filter(w2e(c)));
  return g && g.length ? tce(g) : tce(ece(a));
}, Jne = function(o, a) {
  return a === void 0 && (a = []), a.push(o), o.parentNode && Jne(o.parentNode.host || o.parentNode, a), a;
}, kte = function(o, a) {
  for (var c = Jne(o), f = Jne(a), g = 0; g < c.length; g += 1) {
    var x = c[g];
    if (f.indexOf(x) >= 0)
      return x;
  }
  return !1;
}, zme = function(o, a, c) {
  var f = Qk(o), g = Qk(a), x = f[0], k = !1;
  return g.filter(Boolean).forEach(function(A) {
    k = kte(k || A, A) || k, c.filter(Boolean).forEach(function(N) {
      var H = kte(x, N);
      H && (!k || Uk(H, k) ? k = H : k = kte(H, k));
    });
  }), k;
}, sce = function(o, a) {
  return o.reduce(function(c, f) {
    return c.concat(f2e(f, a));
  }, []);
}, C2e = function(o, a) {
  var c = /* @__PURE__ */ new Map();
  return a.forEach(function(f) {
    return c.set(f.node, f);
  }), o.map(function(f) {
    return c.get(f);
  }).filter(r2e);
}, S2e = function(o, a) {
  var c = TI(Qk(o).length > 0 ? document : Dme(o).ownerDocument), f = pre(o).filter(Xne), g = zme(c || o, o, f), x = /* @__PURE__ */ new Map(), k = EI(f, x), A = k.filter(function(Se) {
    var be = Se.node;
    return Xne(be);
  });
  if (A[0]) {
    var N = EI([g], x).map(function(Se) {
      var be = Se.node;
      return be;
    }), H = C2e(N, A), Z = H.map(function(Se) {
      var be = Se.node;
      return be;
    }), K = H.filter(function(Se) {
      var be = Se.tabIndex;
      return be >= 0;
    }).map(function(Se) {
      var be = Se.node;
      return be;
    }), J = x2e(Z, K, N, c, a);
    if (J === Qne) {
      var pe = (
        // first try only tabbable, and the fallback to all focusable, as long as at least one element should be picked for focus
        oce(k, K, sce(f, x)) || oce(k, Z, sce(f, x))
      );
      if (pe)
        return { node: pe };
      console.warn("focus-lock: cannot find any node to move focus into");
      return;
    }
    return J === void 0 ? J : H[J];
  }
}, k2e = function(o) {
  var a = pre(o).filter(Xne), c = zme(o, o, a), f = ure(J4([c], !0), !0, !0), g = J4(a, !1);
  return f.map(function(x) {
    var k = x.node, A = x.index;
    return {
      node: k,
      index: A,
      lockItem: g.indexOf(k) >= 0,
      guard: cre(k)
    };
  });
}, gre = function(o, a) {
  o && ("focus" in o && o.focus(a), "contentWindow" in o && o.contentWindow && o.contentWindow.focus());
}, _te = 0, Ete = !1, Vme = function(o, a, c) {
  c === void 0 && (c = {});
  var f = S2e(o, a);
  if (!Ete && f) {
    if (_te > 2) {
      console.error("FocusLock: focus-fighting detected. Only one focus management system could be active. See https://github.com/theKashey/focus-lock/#focus-fighting"), Ete = !0, setTimeout(function() {
        Ete = !1;
      }, 1);
      return;
    }
    _te++, gre(f.node, c.focusOptions), _te--;
  }
};
function N5(o) {
  if (!o)
    return null;
  if (typeof WeakRef > "u")
    return function() {
      return o || null;
    };
  var a = o ? new WeakRef(o) : null;
  return function() {
    return (a == null ? void 0 : a.deref()) || null;
  };
}
var _2e = function(o) {
  if (!o)
    return null;
  for (var a = [], c = o; c && c !== document.body; )
    a.push({
      current: N5(c),
      parent: N5(c.parentElement),
      left: N5(c.previousElementSibling),
      right: N5(c.nextElementSibling)
    }), c = c.parentElement;
  return {
    element: N5(o),
    stack: a,
    ownerDocument: o.ownerDocument
  };
}, E2e = function(o) {
  var a, c, f, g, x;
  if (o)
    for (var k = o.stack, A = o.ownerDocument, N = /* @__PURE__ */ new Map(), H = 0, Z = k; H < Z.length; H++) {
      var K = Z[H], J = (a = K.parent) === null || a === void 0 ? void 0 : a.call(K);
      if (J && A.contains(J)) {
        for (var pe = (c = K.left) === null || c === void 0 ? void 0 : c.call(K), Se = K.current(), be = J.contains(Se) ? Se : void 0, ye = (f = K.right) === null || f === void 0 ? void 0 : f.call(K), re = mre([J], N), oe = (
          // that is element itself
          (x = (g = be ?? // or something in it's place
          (pe == null ? void 0 : pe.nextElementSibling)) !== null && g !== void 0 ? g : (
            // or somebody to the right, still close enough
            ye
          )) !== null && x !== void 0 ? x : (
            // or somebody to the left, something?
            pe
          )
        ); oe; ) {
          for (var U = 0, ve = re; U < ve.length; U++) {
            var Ze = ve[U];
            if (oe != null && oe.contains(Ze.node))
              return Ze.node;
          }
          oe = oe.nextElementSibling;
        }
        if (re.length)
          return re[0].node;
      }
    }
}, Ume = function(o) {
  var a = _2e(o);
  return function() {
    return E2e(a);
  };
}, T2e = function(o, a, c) {
  if (!o || !a)
    return console.error("no element or scope given"), {};
  var f = Qk(a);
  if (f.every(function(k) {
    return !Uk(k, o);
  }))
    return console.error("Active element is not contained in the scope"), {};
  var g = c ? mre(f, /* @__PURE__ */ new Map()) : EI(f, /* @__PURE__ */ new Map()), x = g.findIndex(function(k) {
    var A = k.node;
    return A === o;
  });
  if (x !== -1)
    return {
      prev: g[x - 1],
      next: g[x + 1],
      first: g[0],
      last: g[g.length - 1]
    };
}, A2e = function(o, a) {
  var c = a ? mre(Qk(o), /* @__PURE__ */ new Map()) : EI(Qk(o), /* @__PURE__ */ new Map());
  return {
    first: c[0],
    last: c[c.length - 1]
  };
}, O2e = function(o) {
  return Object.assign({
    scope: document.body,
    cycle: !0,
    onlyTabbable: !0
  }, o);
}, jme = function(o, a, c) {
  a === void 0 && (a = {});
  var f = O2e(a), g = T2e(o, f.scope, f.onlyTabbable);
  if (g) {
    var x = c(g, f.cycle);
    x && gre(x.node, f.focusOptions);
  }
}, D2e = function(o, a) {
  a === void 0 && (a = {}), jme(o, a, function(c, f) {
    var g = c.next, x = c.first;
    return g || f && x;
  });
}, R2e = function(o, a) {
  a === void 0 && (a = {}), jme(o, a, function(c, f) {
    var g = c.prev, x = c.last;
    return g || f && x;
  });
}, Wme = function(o, a, c) {
  var f, g = A2e(o, (f = a.onlyTabbable) !== null && f !== void 0 ? f : !0), x = g[c];
  x && gre(x.node, a.focusOptions);
}, N2e = function(o, a) {
  a === void 0 && (a = {}), Wme(o, a, "first");
}, P2e = function(o, a) {
  a === void 0 && (a = {}), Wme(o, a, "last");
}, Zme = function() {
  return document && document.activeElement === document.body;
}, M2e = function() {
  return Zme() || v2e();
}, I4 = null, ym = null, rce = function() {
  return null;
}, F4 = null, AI = !1, vre = !1, I2e = function() {
  return !0;
}, F2e = function(a) {
  return (I4.whiteList || I2e)(a);
}, B2e = function(a, c) {
  F4 = {
    observerNode: a,
    portaledElement: c
  };
}, L2e = function(a) {
  return F4 && F4.portaledElement === a;
};
function ace(o, a, c, f) {
  var g = null, x = o;
  do {
    var k = f[x];
    if (k.guard)
      k.node.dataset.focusAutoGuard && (g = k);
    else if (k.lockItem) {
      if (x !== o)
        return;
      g = null;
    } else
      break;
  } while ((x += c) !== a);
  g && (g.node.tabIndex = 0);
}
var $2e = function(a) {
  return a ? !!AI : AI === "meanwhile";
}, H2e = function o(a, c, f) {
  return c && (c.host === a && (!c.activeElement || f.contains(c.activeElement)) || c.parentNode && o(a, c.parentNode, f));
}, z2e = function(a, c) {
  return c.some(function(f) {
    return H2e(a, f, f);
  });
}, Gme = function(a) {
  return EI(a, /* @__PURE__ */ new Map());
}, V2e = function(a) {
  return !Gme([a.parentNode]).some(function(c) {
    return c.node === a;
  });
}, _V = function() {
  var a = !1;
  if (I4) {
    var c = I4, f = c.observed, g = c.persistentFocus, x = c.autoFocus, k = c.shards, A = c.crossFrame, N = c.focusOptions, H = c.noFocusGuards, Z = f || F4 && F4.portaledElement;
    if (Zme() && ym && ym !== document.body && (!document.body.contains(ym) || V2e(ym))) {
      var K = rce();
      K && K.focus();
    }
    var J = document && document.activeElement;
    if (Z) {
      var pe = [Z].concat(k.map(Wxe).filter(Boolean)), Se = function() {
        if (!$2e(A) || !H || !ym || vre)
          return !1;
        var U = Gme(pe), ve = U.findIndex(function(Ze) {
          var rt = Ze.node;
          return rt === ym;
        });
        return ve === 0 || ve === U.length - 1;
      };
      if ((!J || F2e(J)) && (g || Se() || !M2e() || !ym && x) && (Z && !(Hme(pe) || J && z2e(J, pe) || L2e(J)) && (document && !ym && J && !x ? (J.blur && J.blur(), document.body.focus()) : (a = Vme(pe, ym, {
        focusOptions: N
      }), F4 = {})), ym = document && document.activeElement, ym !== document.body && (rce = Ume(ym)), AI = !1), document && J !== document.activeElement && document.querySelector("[data-focus-auto-guard]")) {
        var be = document && document.activeElement, ye = k2e(pe), re = ye.map(function(oe) {
          var U = oe.node;
          return U;
        }).indexOf(be);
        re > -1 && (ye.filter(function(oe) {
          var U = oe.guard, ve = oe.node;
          return U && ve.dataset.focusAutoGuard;
        }).forEach(function(oe) {
          var U = oe.node;
          return U.removeAttribute("tabIndex");
        }), ace(re, ye.length, 1, ye), ace(re, -1, -1, ye));
      }
    }
  }
  return a;
}, qme = function(a) {
  _V() && a && (a.stopPropagation(), a.preventDefault());
}, bre = function() {
  return lre(_V);
}, U2e = function(a) {
  var c = a.target, f = a.currentTarget;
  f.contains(c) || B2e(f, c);
}, j2e = function() {
  return null;
}, Kme = function() {
  vre = !0;
}, Yme = function() {
  vre = !1, AI = "just", lre(function() {
    AI = "meanwhile";
  });
}, W2e = function() {
  document.addEventListener("focusin", qme), document.addEventListener("focusout", bre), window.addEventListener("focus", Kme), window.addEventListener("blur", Yme);
}, Z2e = function() {
  document.removeEventListener("focusin", qme), document.removeEventListener("focusout", bre), window.removeEventListener("focus", Kme), window.removeEventListener("blur", Yme);
};
function G2e(o) {
  return o.filter(function(a) {
    var c = a.disabled;
    return !c;
  });
}
var Xme = {
  moveFocusInside: Vme,
  focusInside: Hme,
  focusNextElement: D2e,
  focusPrevElement: R2e,
  focusFirstElement: N2e,
  focusLastElement: P2e,
  captureFocusRestore: Ume
};
function q2e(o) {
  var a = o.slice(-1)[0];
  a && !I4 && W2e();
  var c = I4, f = c && a && a.id === c.id;
  I4 = a, c && !f && (c.onDeactivation(), o.filter(function(g) {
    var x = g.id;
    return x === c.id;
  }).length || c.returnFocus(!a)), a ? (ym = null, (!f || c.observed !== a.observed) && a.onActivation(Xme), _V(), lre(_V)) : (Z2e(), ym = null);
}
kme.assignSyncMedium(U2e);
_me.assignMedium(bre);
Vxe.assignMedium(function(o) {
  return o(Xme);
});
const K2e = Xxe(G2e, q2e)(j2e);
are(Eme, K2e);
var Y2e = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function X2e() {
  if (!document)
    return null;
  var o = document.createElement("style");
  o.type = "text/css";
  var a = Y2e();
  return a && o.setAttribute("nonce", a), o;
}
function Q2e(o, a) {
  o.styleSheet ? o.styleSheet.cssText = a : o.appendChild(document.createTextNode(a));
}
function J2e(o) {
  var a = document.head || document.getElementsByTagName("head")[0];
  a.appendChild(o);
}
var ewe = function() {
  var o = 0, a = null;
  return {
    add: function(c) {
      o == 0 && (a = X2e()) && (Q2e(a, c), J2e(a)), o++;
    },
    remove: function() {
      o--, !o && a && (a.parentNode && a.parentNode.removeChild(a), a = null);
    }
  };
}, twe = function() {
  var o = ewe();
  return function(a, c) {
    tt.useEffect(function() {
      return o.add(a), function() {
        o.remove();
      };
    }, [a && c]);
  };
}, yre = function() {
  var o = twe(), a = function(c) {
    var f = c.styles, g = c.dynamic;
    return o(f, g), null;
  };
  return a;
}, nwe = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, Tte = function(o) {
  return parseInt(o || "", 10) || 0;
}, owe = function(o) {
  var a = window.getComputedStyle(document.body), c = a[o === "padding" ? "paddingLeft" : "marginLeft"], f = a[o === "padding" ? "paddingTop" : "marginTop"], g = a[o === "padding" ? "paddingRight" : "marginRight"];
  return [Tte(c), Tte(f), Tte(g)];
}, swe = function(o) {
  if (o === void 0 && (o = "margin"), typeof window > "u")
    return nwe;
  var a = owe(o), c = document.documentElement.clientWidth, f = window.innerWidth;
  return {
    left: a[0],
    top: a[1],
    right: a[2],
    gap: Math.max(0, f - c + a[2] - a[0])
  };
}, rwe = yre(), B4 = "data-scroll-locked", awe = function(o, a, c, f) {
  var g = o.left, x = o.top, k = o.right, A = o.gap;
  return c === void 0 && (c = "margin"), `
  .`.concat(Ixe, ` {
   overflow: hidden `).concat(f, `;
   padding-right: `).concat(A, "px ").concat(f, `;
  }
  body[`).concat(B4, `] {
    overflow: hidden `).concat(f, `;
    overscroll-behavior: contain;
    `).concat([
    a && "position: relative ".concat(f, ";"),
    c === "margin" && `
    padding-left: `.concat(g, `px;
    padding-top: `).concat(x, `px;
    padding-right: `).concat(k, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(A, "px ").concat(f, `;
    `),
    c === "padding" && "padding-right: ".concat(A, "px ").concat(f, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(V9, ` {
    right: `).concat(A, "px ").concat(f, `;
  }
  
  .`).concat(U9, ` {
    margin-right: `).concat(A, "px ").concat(f, `;
  }
  
  .`).concat(V9, " .").concat(V9, ` {
    right: 0 `).concat(f, `;
  }
  
  .`).concat(U9, " .").concat(U9, ` {
    margin-right: 0 `).concat(f, `;
  }
  
  body[`).concat(B4, `] {
    `).concat(Fxe, ": ").concat(A, `px;
  }
`);
}, ice = function() {
  var o = parseInt(document.body.getAttribute(B4) || "0", 10);
  return isFinite(o) ? o : 0;
}, iwe = function() {
  tt.useEffect(function() {
    return document.body.setAttribute(B4, (ice() + 1).toString()), function() {
      var o = ice() - 1;
      o <= 0 ? document.body.removeAttribute(B4) : document.body.setAttribute(B4, o.toString());
    };
  }, []);
}, lwe = function(o) {
  var a = o.noRelative, c = o.noImportant, f = o.gapMode, g = f === void 0 ? "margin" : f;
  iwe();
  var x = tt.useMemo(function() {
    return swe(g);
  }, [g]);
  return tt.createElement(rwe, { styles: awe(x, !a, g, c ? "" : "!important") });
}, eoe = !1;
if (typeof window < "u")
  try {
    var w9 = Object.defineProperty({}, "passive", {
      get: function() {
        return eoe = !0, !0;
      }
    });
    window.addEventListener("test", w9, w9), window.removeEventListener("test", w9, w9);
  } catch {
    eoe = !1;
  }
var l4 = eoe ? { passive: !1 } : !1, cwe = function(o) {
  return o.tagName === "TEXTAREA";
}, Qme = function(o, a) {
  if (!(o instanceof Element))
    return !1;
  var c = window.getComputedStyle(o);
  return (
    // not-not-scrollable
    c[a] !== "hidden" && // contains scroll inside self
    !(c.overflowY === c.overflowX && !cwe(o) && c[a] === "visible")
  );
}, uwe = function(o) {
  return Qme(o, "overflowY");
}, dwe = function(o) {
  return Qme(o, "overflowX");
}, lce = function(o, a) {
  var c = a.ownerDocument, f = a;
  do {
    typeof ShadowRoot < "u" && f instanceof ShadowRoot && (f = f.host);
    var g = Jme(o, f);
    if (g) {
      var x = epe(o, f), k = x[1], A = x[2];
      if (k > A)
        return !0;
    }
    f = f.parentNode;
  } while (f && f !== c.body);
  return !1;
}, fwe = function(o) {
  var a = o.scrollTop, c = o.scrollHeight, f = o.clientHeight;
  return [
    a,
    c,
    f
  ];
}, mwe = function(o) {
  var a = o.scrollLeft, c = o.scrollWidth, f = o.clientWidth;
  return [
    a,
    c,
    f
  ];
}, Jme = function(o, a) {
  return o === "v" ? uwe(a) : dwe(a);
}, epe = function(o, a) {
  return o === "v" ? fwe(a) : mwe(a);
}, pwe = function(o, a) {
  return o === "h" && a === "rtl" ? -1 : 1;
}, hwe = function(o, a, c, f, g) {
  var x = pwe(o, window.getComputedStyle(a).direction), k = x * f, A = c.target, N = a.contains(A), H = !1, Z = k > 0, K = 0, J = 0;
  do {
    if (!A)
      break;
    var pe = epe(o, A), Se = pe[0], be = pe[1], ye = pe[2], re = be - ye - x * Se;
    (Se || re) && Jme(o, A) && (K += re, J += Se);
    var oe = A.parentNode;
    A = oe && oe.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? oe.host : oe;
  } while (
    // portaled content
    !N && A !== document.body || // self content
    N && (a.contains(A) || a === A)
  );
  return (Z && (Math.abs(K) < 1 || !g) || !Z && (Math.abs(J) < 1 || !g)) && (H = !0), H;
}, C9 = function(o) {
  return "changedTouches" in o ? [o.changedTouches[0].clientX, o.changedTouches[0].clientY] : [0, 0];
}, cce = function(o) {
  return [o.deltaX, o.deltaY];
}, uce = function(o) {
  return o && "current" in o ? o.current : o;
}, gwe = function(o, a) {
  return o[0] === a[0] && o[1] === a[1];
}, vwe = function(o) {
  return `
  .block-interactivity-`.concat(o, ` {pointer-events: none;}
  .allow-interactivity-`).concat(o, ` {pointer-events: all;}
`);
}, bwe = 0, c4 = [];
function ywe(o) {
  var a = tt.useRef([]), c = tt.useRef([0, 0]), f = tt.useRef(), g = tt.useState(bwe++)[0], x = tt.useState(yre)[0], k = tt.useRef(o);
  tt.useEffect(function() {
    k.current = o;
  }, [o]), tt.useEffect(function() {
    if (o.inert) {
      document.body.classList.add("block-interactivity-".concat(g));
      var be = Q0e([o.lockRef.current], (o.shards || []).map(uce), !0).filter(Boolean);
      return be.forEach(function(ye) {
        return ye.classList.add("allow-interactivity-".concat(g));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(g)), be.forEach(function(ye) {
          return ye.classList.remove("allow-interactivity-".concat(g));
        });
      };
    }
  }, [o.inert, o.lockRef.current, o.shards]);
  var A = tt.useCallback(function(be, ye) {
    if ("touches" in be && be.touches.length === 2 || be.type === "wheel" && be.ctrlKey)
      return !k.current.allowPinchZoom;
    var re = C9(be), oe = c.current, U = "deltaX" in be ? be.deltaX : oe[0] - re[0], ve = "deltaY" in be ? be.deltaY : oe[1] - re[1], Ze, rt = be.target, ee = Math.abs(U) > Math.abs(ve) ? "h" : "v";
    if ("touches" in be && ee === "h" && rt.type === "range")
      return !1;
    var lt = lce(ee, rt);
    if (!lt)
      return !0;
    if (lt ? Ze = ee : (Ze = ee === "v" ? "h" : "v", lt = lce(ee, rt)), !lt)
      return !1;
    if (!f.current && "changedTouches" in be && (U || ve) && (f.current = Ze), !Ze)
      return !0;
    var wt = f.current || Ze;
    return hwe(wt, ye, be, wt === "h" ? U : ve, !0);
  }, []), N = tt.useCallback(function(be) {
    var ye = be;
    if (!(!c4.length || c4[c4.length - 1] !== x)) {
      var re = "deltaY" in ye ? cce(ye) : C9(ye), oe = a.current.filter(function(Ze) {
        return Ze.name === ye.type && (Ze.target === ye.target || ye.target === Ze.shadowParent) && gwe(Ze.delta, re);
      })[0];
      if (oe && oe.should) {
        ye.cancelable && ye.preventDefault();
        return;
      }
      if (!oe) {
        var U = (k.current.shards || []).map(uce).filter(Boolean).filter(function(Ze) {
          return Ze.contains(ye.target);
        }), ve = U.length > 0 ? A(ye, U[0]) : !k.current.noIsolation;
        ve && ye.cancelable && ye.preventDefault();
      }
    }
  }, []), H = tt.useCallback(function(be, ye, re, oe) {
    var U = { name: be, delta: ye, target: re, should: oe, shadowParent: xwe(re) };
    a.current.push(U), setTimeout(function() {
      a.current = a.current.filter(function(ve) {
        return ve !== U;
      });
    }, 1);
  }, []), Z = tt.useCallback(function(be) {
    c.current = C9(be), f.current = void 0;
  }, []), K = tt.useCallback(function(be) {
    H(be.type, cce(be), be.target, A(be, o.lockRef.current));
  }, []), J = tt.useCallback(function(be) {
    H(be.type, C9(be), be.target, A(be, o.lockRef.current));
  }, []);
  tt.useEffect(function() {
    return c4.push(x), o.setCallbacks({
      onScrollCapture: K,
      onWheelCapture: K,
      onTouchMoveCapture: J
    }), document.addEventListener("wheel", N, l4), document.addEventListener("touchmove", N, l4), document.addEventListener("touchstart", Z, l4), function() {
      c4 = c4.filter(function(be) {
        return be !== x;
      }), document.removeEventListener("wheel", N, l4), document.removeEventListener("touchmove", N, l4), document.removeEventListener("touchstart", Z, l4);
    };
  }, []);
  var pe = o.removeScrollBar, Se = o.inert;
  return tt.createElement(
    tt.Fragment,
    null,
    Se ? tt.createElement(x, { styles: vwe(g) }) : null,
    pe ? tt.createElement(lwe, { noRelative: o.noRelative, gapMode: o.gapMode }) : null
  );
}
function xwe(o) {
  for (var a = null; o !== null; )
    o instanceof ShadowRoot && (a = o.host, o = o.host), o = o.parentNode;
  return a;
}
are(Cme, ywe);
var wwe = function(o) {
  if (typeof document > "u")
    return null;
  var a = Array.isArray(o) ? o[0] : o;
  return a.ownerDocument.body;
}, u4 = /* @__PURE__ */ new WeakMap(), S9 = /* @__PURE__ */ new WeakMap(), k9 = {}, Ate = 0, tpe = function(o) {
  return o && (o.host || tpe(o.parentNode));
}, Cwe = function(o, a) {
  return a.map(function(c) {
    if (o.contains(c))
      return c;
    var f = tpe(c);
    return f && o.contains(f) ? f : (console.error("aria-hidden", c, "in not contained inside", o, ". Doing nothing"), null);
  }).filter(function(c) {
    return !!c;
  });
}, Swe = function(o, a, c, f) {
  var g = Cwe(a, Array.isArray(o) ? o : [o]);
  k9[c] || (k9[c] = /* @__PURE__ */ new WeakMap());
  var x = k9[c], k = [], A = /* @__PURE__ */ new Set(), N = new Set(g), H = function(K) {
    !K || A.has(K) || (A.add(K), H(K.parentNode));
  };
  g.forEach(H);
  var Z = function(K) {
    !K || N.has(K) || Array.prototype.forEach.call(K.children, function(J) {
      if (A.has(J))
        Z(J);
      else
        try {
          var pe = J.getAttribute(f), Se = pe !== null && pe !== "false", be = (u4.get(J) || 0) + 1, ye = (x.get(J) || 0) + 1;
          u4.set(J, be), x.set(J, ye), k.push(J), be === 1 && Se && S9.set(J, !0), ye === 1 && J.setAttribute(c, "true"), Se || J.setAttribute(f, "true");
        } catch (re) {
          console.error("aria-hidden: cannot operate on ", J, re);
        }
    });
  };
  return Z(a), A.clear(), Ate++, function() {
    k.forEach(function(K) {
      var J = u4.get(K) - 1, pe = x.get(K) - 1;
      u4.set(K, J), x.set(K, pe), J || (S9.has(K) || K.removeAttribute(f), S9.delete(K)), pe || K.removeAttribute(c);
    }), Ate--, Ate || (u4 = /* @__PURE__ */ new WeakMap(), u4 = /* @__PURE__ */ new WeakMap(), S9 = /* @__PURE__ */ new WeakMap(), k9 = {});
  };
}, kwe = function(o, a, c) {
  var f = Array.from(Array.isArray(o) ? o : [o]), g = a || wwe(o);
  return g ? (f.push.apply(f, Array.from(g.querySelectorAll("[aria-live], script"))), Swe(f, g, c, "aria-hidden")) : function() {
    return null;
  };
}, _we = yre(), Ewe = `
 [` + Ome + `] {
   pointer-events: none !important;
 }
`, Twe = function() {
  return tt.createElement(_we, { styles: Ewe });
}, dce = function(o) {
  return "current" in o ? o.current : o;
};
function Awe(o) {
  var a = o.setLockProps, c = o.onEscapeKey, f = o.onClickOutside, g = o.shards, x = o.onActivation, k = o.onDeactivation, A = o.noIsolation, N = tt.useState(void 0), H = N[0], Z = N[1], K = tt.useRef(null), J = tt.useRef(0);
  return tt.useEffect(function() {
    var pe = function(re) {
      re.defaultPrevented || (re.code === "Escape" || re.key === "Escape" || re.keyCode === 27) && c && c(re);
    }, Se = function(re) {
      re.defaultPrevented || re.target === K.current || re instanceof MouseEvent && re.button !== 0 || g && g.map(dce).some(function(oe) {
        return oe && oe.contains(re.target) || oe === re.target;
      }) || f && f(re);
    }, be = function(re) {
      Se(re), J.current = re.touches.length;
    }, ye = function(re) {
      J.current = re.touches.length;
    };
    if (H)
      return H.ownerDocument.addEventListener("keydown", pe), H.ownerDocument.addEventListener("mousedown", Se), H.ownerDocument.addEventListener("touchstart", be), H.ownerDocument.addEventListener("touchend", ye), function() {
        H.ownerDocument.removeEventListener("keydown", pe), H.ownerDocument.removeEventListener("mousedown", Se), H.ownerDocument.removeEventListener("touchstart", be), H.ownerDocument.removeEventListener("touchend", ye);
      };
  }, [H, f, c]), tt.useEffect(function() {
    if (H)
      return x && x(H), function() {
        k && k();
      };
  }, [!!H]), tt.useEffect(function() {
    var pe = function() {
      return null;
    }, Se = !1, be = function(re) {
      A || (pe = kwe(X0e([re], (g || []).map(dce)), re.ownerDocument.body, Ome)), Z(function() {
        return re;
      });
    }, ye = function() {
      pe(), Se || Z(null);
    };
    return a({
      onMouseDown: function(re) {
        K.current = re.target;
      },
      onTouchStart: function(re) {
        K.current = re.target;
      },
      onActivation: be,
      onDeactivation: ye
    }), function() {
      Se = !0, a(!1);
    };
  }, []), tt.createElement(Twe, null);
}
const Owe = are(Ame, Awe);
var Dwe = function(o) {
  return tt.createElement(Owe, Wd({}, o));
}, Rwe = tt.forwardRef(function(o, a) {
  return tt.createElement(Gxe, Wd({}, o, { ref: a, sideCar: Dwe }));
});
class Nwe extends Ve.Component {
  constructor(a) {
    if (super(a), this.rootName = "paragon-portal-root", typeof document > "u")
      this.rootElement = null;
    else if (document.getElementById(this.rootName))
      this.rootElement = document.getElementById(this.rootName);
    else {
      const c = document.createElement("div");
      c.setAttribute("id", this.rootName), this.rootElement = document.body.appendChild(c);
    }
  }
  render() {
    return this.rootElement ? /* @__PURE__ */ Mk.createPortal(this.props.children, this.rootElement) : null;
  }
}
function Pwe() {
  let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    handleToggleOn: c,
    handleToggleOff: f,
    handleToggle: g
  } = a, [x, k] = tt.useState(o), A = tt.useCallback(() => {
    k(!0), c == null || c(), g == null || g(!0);
  }, [c, g]), N = tt.useCallback(() => {
    k(!1), f == null || f(), g == null || g(!1);
  }, [f, g]), H = tt.useCallback(() => {
    (x ? N : A)();
  }, [x, A, N]);
  return [x, A, N, H];
}
var fce = function(a) {
  return a.reduce(function(c, f) {
    var g = f[0], x = f[1];
    return c[g] = x, c;
  }, {});
}, mce = typeof window < "u" && window.document && window.document.createElement ? tt.useLayoutEffect : tt.useEffect;
function Mwe(o) {
  var a = o.state;
  Object.keys(a.elements).forEach(function(c) {
    var f = a.styles[c] || {}, g = a.attributes[c] || {}, x = a.elements[c];
    !Ih(x) || !Lb(x) || (Object.assign(x.style, f), Object.keys(g).forEach(function(k) {
      var A = g[k];
      A === !1 ? x.removeAttribute(k) : x.setAttribute(k, A === !0 ? "" : A);
    }));
  });
}
function Iwe(o) {
  var a = o.state, c = {
    popper: {
      position: a.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(a.elements.popper.style, c.popper), a.styles = c, a.elements.arrow && Object.assign(a.elements.arrow.style, c.arrow), function() {
    Object.keys(a.elements).forEach(function(f) {
      var g = a.elements[f], x = a.attributes[f] || {}, k = Object.keys(a.styles.hasOwnProperty(f) ? a.styles[f] : c[f]), A = k.reduce(function(N, H) {
        return N[H] = "", N;
      }, {});
      !Ih(g) || !Lb(g) || (Object.assign(g.style, A), Object.keys(x).forEach(function(N) {
        g.removeAttribute(N);
      }));
    });
  };
}
const Fwe = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: Mwe,
  effect: Iwe,
  requires: ["computeStyles"]
};
var Bwe = [Dfe, Ffe, Ofe, Fwe, Ife, Pfe, Bfe, Afe, Mfe], Lwe = /* @__PURE__ */ Lfe({
  defaultModifiers: Bwe
}), $we = typeof Element < "u", Hwe = typeof Map == "function", zwe = typeof Set == "function", Vwe = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
function j9(o, a) {
  if (o === a) return !0;
  if (o && a && typeof o == "object" && typeof a == "object") {
    if (o.constructor !== a.constructor) return !1;
    var c, f, g;
    if (Array.isArray(o)) {
      if (c = o.length, c != a.length) return !1;
      for (f = c; f-- !== 0; )
        if (!j9(o[f], a[f])) return !1;
      return !0;
    }
    var x;
    if (Hwe && o instanceof Map && a instanceof Map) {
      if (o.size !== a.size) return !1;
      for (x = o.entries(); !(f = x.next()).done; )
        if (!a.has(f.value[0])) return !1;
      for (x = o.entries(); !(f = x.next()).done; )
        if (!j9(f.value[1], a.get(f.value[0]))) return !1;
      return !0;
    }
    if (zwe && o instanceof Set && a instanceof Set) {
      if (o.size !== a.size) return !1;
      for (x = o.entries(); !(f = x.next()).done; )
        if (!a.has(f.value[0])) return !1;
      return !0;
    }
    if (Vwe && ArrayBuffer.isView(o) && ArrayBuffer.isView(a)) {
      if (c = o.length, c != a.length) return !1;
      for (f = c; f-- !== 0; )
        if (o[f] !== a[f]) return !1;
      return !0;
    }
    if (o.constructor === RegExp) return o.source === a.source && o.flags === a.flags;
    if (o.valueOf !== Object.prototype.valueOf && typeof o.valueOf == "function" && typeof a.valueOf == "function") return o.valueOf() === a.valueOf();
    if (o.toString !== Object.prototype.toString && typeof o.toString == "function" && typeof a.toString == "function") return o.toString() === a.toString();
    if (g = Object.keys(o), c = g.length, c !== Object.keys(a).length) return !1;
    for (f = c; f-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(a, g[f])) return !1;
    if ($we && o instanceof Element) return !1;
    for (f = c; f-- !== 0; )
      if (!((g[f] === "_owner" || g[f] === "__v" || g[f] === "__o") && o.$$typeof) && !j9(o[g[f]], a[g[f]]))
        return !1;
    return !0;
  }
  return o !== o && a !== a;
}
var Uwe = function(a, c) {
  try {
    return j9(a, c);
  } catch (f) {
    if ((f.message || "").match(/stack|recursion/i))
      return console.warn("react-fast-compare cannot handle circular refs"), !1;
    throw f;
  }
};
const jwe = /* @__PURE__ */ eO(Uwe);
var Wwe = [], Zwe = function(a, c, f) {
  f === void 0 && (f = {});
  var g = tt.useRef(null), x = {
    onFirstUpdate: f.onFirstUpdate,
    placement: f.placement || "bottom",
    strategy: f.strategy || "absolute",
    modifiers: f.modifiers || Wwe
  }, k = tt.useState({
    styles: {
      popper: {
        position: x.strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), A = k[0], N = k[1], H = tt.useMemo(function() {
    return {
      name: "updateState",
      enabled: !0,
      phase: "write",
      fn: function(pe) {
        var Se = pe.state, be = Object.keys(Se.elements);
        tse.flushSync(function() {
          N({
            styles: fce(be.map(function(ye) {
              return [ye, Se.styles[ye] || {}];
            })),
            attributes: fce(be.map(function(ye) {
              return [ye, Se.attributes[ye]];
            }))
          });
        });
      },
      requires: ["computeStyles"]
    };
  }, []), Z = tt.useMemo(function() {
    var J = {
      onFirstUpdate: x.onFirstUpdate,
      placement: x.placement,
      strategy: x.strategy,
      modifiers: [].concat(x.modifiers, [H, {
        name: "applyStyles",
        enabled: !1
      }])
    };
    return jwe(g.current, J) ? g.current || J : (g.current = J, J);
  }, [x.onFirstUpdate, x.placement, x.strategy, x.modifiers, H]), K = tt.useRef();
  return mce(function() {
    K.current && K.current.setOptions(Z);
  }, [Z]), mce(function() {
    if (!(a == null || c == null)) {
      var J = f.createPopper || Lwe, pe = J(a, c, Z);
      return K.current = pe, function() {
        pe.destroy(), K.current = null;
      };
    }
  }, [a, c, f.createPopper]), {
    state: K.current ? K.current.state : null,
    styles: A.styles,
    attributes: A.attributes,
    update: K.current ? K.current.update : null,
    forceUpdate: K.current ? K.current.forceUpdate : null
  };
};
function UI(o) {
  let {
    children: a,
    target: c,
    strategy: f,
    placement: g,
    modifiers: x
  } = o;
  const [k, A] = tt.useState(null), N = {
    modifiers: x,
    strategy: f,
    placement: g
  }, {
    styles: H,
    attributes: Z
  } = Zwe(c, k, N);
  return c ? /* @__PURE__ */ Ve.createElement("div", {
    ref: A,
    style: {
      ...H.popper,
      zIndex: 2e3
    },
    ...Z.popper
  }, a) : null;
}
UI.defaultProps = {
  target: void 0
};
UI.propTypes = {
  children: ce.node,
  target: ce.shape({
    current: ce.shape({})
  }),
  strategy: ce.oneOf(["absolute", "fixed"]),
  placement: ce.oneOf(["auto", "auto-start", "auto-end", "top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "right", "right-start", "right-end", "left", "left-start", "left-end"]),
  modifiers: ce.arrayOf(ce.shape({}))
};
UI.defaultProps = {
  children: void 0,
  strategy: "absolute",
  placement: "bottom-start",
  modifiers: [{
    name: "flip",
    enabled: !0
  }, {
    name: "preventOverflow",
    options: {
      tether: !1
    }
  }]
};
const Gwe = {
  right: [-2, 10],
  left: [-2, 10]
};
function xre(o) {
  let {
    children: a,
    onClose: c,
    isOpen: f,
    positionRef: g,
    isBlocking: x,
    withPortal: k,
    placement: A,
    hasArrow: N,
    ...H
  } = o;
  const Z = k ? Nwe : Ve.Fragment, K = Gwe[A] || [0, 10], J = [{
    name: "eventListeners",
    options: {
      scroll: !1
    }
  }, {
    name: "offset",
    options: {
      offset: () => K
    }
  }], pe = (Se) => {
    Se.type !== "touchstart" && c();
  };
  return /* @__PURE__ */ Ve.createElement(Mxe, {
    onClose: c,
    isOpen: f,
    isBlocking: x
  }, /* @__PURE__ */ Ve.createElement(Z, null, /* @__PURE__ */ Ve.createElement(UI, {
    modifiers: N ? J : null,
    target: g,
    placement: A,
    ...H
  }, /* @__PURE__ */ Ve.createElement(Rwe, {
    scrollLock: !1,
    enabled: f,
    onEscapeKey: c,
    onClickOutside: pe
  }, f && /* @__PURE__ */ Ve.createElement("div", {
    className: "pgn__modal-popup__tooltip"
  }, a, N && /* @__PURE__ */ Ve.createElement("div", {
    id: "arrow",
    "data-testid": "modal-popup-arrow",
    className: `pgn__modal-popup__arrow pgn__modal-popup__arrow-${A}`,
    "data-popper-arrow": ""
  }))))));
}
xre.propTypes = {
  /** Specifies the contents of the modal */
  children: ce.node.isRequired,
  /** A callback function for when the modal is dismissed */
  onClose: ce.func.isRequired,
  /** Is the modal dialog open or closed */
  isOpen: ce.bool.isRequired,
  /** Prevent clicking on the backdrop or pressing Esc to close the modal */
  isBlocking: ce.bool,
  /** Insert modal into a different location in the DOM */
  withPortal: ce.bool,
  // This type: https://stackoverflow.com/questions/48007326/what-is-the-correct-proptype-for-a-ref-in-react
  /** Specifies an element near which the modal should be displayed */
  positionRef: ce.oneOfType([ce.func, ce.shape({
    current: ce.shape({})
  })]),
  /** Specifies position according to the element that the ``positionRef`` prop points to */
  placement: UI.propTypes.placement,
  /** Caret to the modal popup pointing to the target */
  hasArrow: ce.bool
};
xre.defaultProps = {
  isBlocking: !1,
  withPortal: !1,
  placement: "bottom-start",
  positionRef: null,
  hasArrow: !1
};
function bU() {
  return (bU = Object.assign || function(o) {
    for (var a = 1; a < arguments.length; a++) {
      var c = arguments[a];
      for (var f in c) Object.prototype.hasOwnProperty.call(c, f) && (o[f] = c[f]);
    }
    return o;
  }).apply(this, arguments);
}
function npe(o, a) {
  if (o == null) return {};
  var c, f, g = {}, x = Object.keys(o);
  for (f = 0; f < x.length; f++) a.indexOf(c = x[f]) >= 0 || (g[c] = o[c]);
  return g;
}
function toe(o) {
  var a = tt.useRef(o), c = tt.useRef(function(f) {
    a.current && a.current(f);
  });
  return a.current = o, c.current;
}
var OI = function(o, a, c) {
  return a === void 0 && (a = 0), c === void 0 && (c = 1), o > c ? c : o < a ? a : o;
}, Q5 = function(o) {
  return "touches" in o;
}, noe = function(o) {
  return o && o.ownerDocument.defaultView || self;
}, pce = function(o, a, c) {
  var f = o.getBoundingClientRect(), g = Q5(a) ? function(x, k) {
    for (var A = 0; A < x.length; A++) if (x[A].identifier === k) return x[A];
    return x[0];
  }(a.touches, c) : a;
  return { left: OI((g.pageX - (f.left + noe(o).pageXOffset)) / f.width), top: OI((g.pageY - (f.top + noe(o).pageYOffset)) / f.height) };
}, hce = function(o) {
  !Q5(o) && o.preventDefault();
}, ope = Ve.memo(function(o) {
  var a = o.onMove, c = o.onKey, f = npe(o, ["onMove", "onKey"]), g = tt.useRef(null), x = toe(a), k = toe(c), A = tt.useRef(null), N = tt.useRef(!1), H = tt.useMemo(function() {
    var pe = function(ye) {
      hce(ye), (Q5(ye) ? ye.touches.length > 0 : ye.buttons > 0) && g.current ? x(pce(g.current, ye, A.current)) : be(!1);
    }, Se = function() {
      return be(!1);
    };
    function be(ye) {
      var re = N.current, oe = noe(g.current), U = ye ? oe.addEventListener : oe.removeEventListener;
      U(re ? "touchmove" : "mousemove", pe), U(re ? "touchend" : "mouseup", Se);
    }
    return [function(ye) {
      var re = ye.nativeEvent, oe = g.current;
      if (oe && (hce(re), !function(ve, Ze) {
        return Ze && !Q5(ve);
      }(re, N.current) && oe)) {
        if (Q5(re)) {
          N.current = !0;
          var U = re.changedTouches || [];
          U.length && (A.current = U[0].identifier);
        }
        oe.focus(), x(pce(oe, re, A.current)), be(!0);
      }
    }, function(ye) {
      var re = ye.which || ye.keyCode;
      re < 37 || re > 40 || (ye.preventDefault(), k({ left: re === 39 ? 0.05 : re === 37 ? -0.05 : 0, top: re === 40 ? 0.05 : re === 38 ? -0.05 : 0 }));
    }, be];
  }, [k, x]), Z = H[0], K = H[1], J = H[2];
  return tt.useEffect(function() {
    return J;
  }, [J]), Ve.createElement("div", bU({}, f, { onTouchStart: Z, onMouseDown: Z, className: "react-colorful__interactive", ref: g, onKeyDown: K, tabIndex: 0, role: "slider" }));
}), wre = function(o) {
  return o.filter(Boolean).join(" ");
}, spe = function(o) {
  var a = o.color, c = o.left, f = o.top, g = f === void 0 ? 0.5 : f, x = wre(["react-colorful__pointer", o.className]);
  return Ve.createElement("div", { className: x, style: { top: 100 * g + "%", left: 100 * c + "%" } }, Ve.createElement("div", { className: "react-colorful__pointer-fill", style: { backgroundColor: a } }));
}, cd = function(o, a, c) {
  return a === void 0 && (a = 0), c === void 0 && (c = Math.pow(10, a)), Math.round(c * o) / c;
}, qwe = function(o) {
  return Jwe(ooe(o));
}, ooe = function(o) {
  return o[0] === "#" && (o = o.substring(1)), o.length < 6 ? { r: parseInt(o[0] + o[0], 16), g: parseInt(o[1] + o[1], 16), b: parseInt(o[2] + o[2], 16), a: o.length === 4 ? cd(parseInt(o[3] + o[3], 16) / 255, 2) : 1 } : { r: parseInt(o.substring(0, 2), 16), g: parseInt(o.substring(2, 4), 16), b: parseInt(o.substring(4, 6), 16), a: o.length === 8 ? cd(parseInt(o.substring(6, 8), 16) / 255, 2) : 1 };
}, Kwe = function(o) {
  return Qwe(Xwe(o));
}, Ywe = function(o) {
  var a = o.s, c = o.v, f = o.a, g = (200 - a) * c / 100;
  return { h: cd(o.h), s: cd(g > 0 && g < 200 ? a * c / 100 / (g <= 100 ? g : 200 - g) * 100 : 0), l: cd(g / 2), a: cd(f, 2) };
}, soe = function(o) {
  var a = Ywe(o);
  return "hsl(" + a.h + ", " + a.s + "%, " + a.l + "%)";
}, Xwe = function(o) {
  var a = o.h, c = o.s, f = o.v, g = o.a;
  a = a / 360 * 6, c /= 100, f /= 100;
  var x = Math.floor(a), k = f * (1 - c), A = f * (1 - (a - x) * c), N = f * (1 - (1 - a + x) * c), H = x % 6;
  return { r: cd(255 * [f, A, k, k, N, f][H]), g: cd(255 * [N, f, f, A, k, k][H]), b: cd(255 * [k, k, N, f, f, A][H]), a: cd(g, 2) };
}, _9 = function(o) {
  var a = o.toString(16);
  return a.length < 2 ? "0" + a : a;
}, Qwe = function(o) {
  var a = o.r, c = o.g, f = o.b, g = o.a, x = g < 1 ? _9(cd(255 * g)) : "";
  return "#" + _9(a) + _9(c) + _9(f) + x;
}, Jwe = function(o) {
  var a = o.r, c = o.g, f = o.b, g = o.a, x = Math.max(a, c, f), k = x - Math.min(a, c, f), A = k ? x === a ? (c - f) / k : x === c ? 2 + (f - a) / k : 4 + (a - c) / k : 0;
  return { h: cd(60 * (A < 0 ? A + 6 : A)), s: cd(x ? k / x * 100 : 0), v: cd(x / 255 * 100), a: g };
}, eCe = Ve.memo(function(o) {
  var a = o.hue, c = o.onChange, f = wre(["react-colorful__hue", o.className]);
  return Ve.createElement("div", { className: f }, Ve.createElement(ope, { onMove: function(g) {
    c({ h: 360 * g.left });
  }, onKey: function(g) {
    c({ h: OI(a + 360 * g.left, 0, 360) });
  }, "aria-label": "Hue", "aria-valuenow": cd(a), "aria-valuemax": "360", "aria-valuemin": "0" }, Ve.createElement(spe, { className: "react-colorful__hue-pointer", left: a / 360, color: soe({ h: a, s: 100, v: 100, a: 1 }) })));
}), tCe = Ve.memo(function(o) {
  var a = o.hsva, c = o.onChange, f = { backgroundColor: soe({ h: a.h, s: 100, v: 100, a: 1 }) };
  return Ve.createElement("div", { className: "react-colorful__saturation", style: f }, Ve.createElement(ope, { onMove: function(g) {
    c({ s: 100 * g.left, v: 100 - 100 * g.top });
  }, onKey: function(g) {
    c({ s: OI(a.s + 100 * g.left, 0, 100), v: OI(a.v - 100 * g.top, 0, 100) });
  }, "aria-label": "Color", "aria-valuetext": "Saturation " + cd(a.s) + "%, Brightness " + cd(a.v) + "%" }, Ve.createElement(spe, { className: "react-colorful__saturation-pointer", top: 1 - a.v / 100, left: a.s / 100, color: soe(a) })));
}), rpe = function(o, a) {
  if (o === a) return !0;
  for (var c in o) if (o[c] !== a[c]) return !1;
  return !0;
}, nCe = function(o, a) {
  return o.toLowerCase() === a.toLowerCase() || rpe(ooe(o), ooe(a));
};
function oCe(o, a, c) {
  var f = toe(c), g = tt.useState(function() {
    return o.toHsva(a);
  }), x = g[0], k = g[1], A = tt.useRef({ color: a, hsva: x });
  tt.useEffect(function() {
    if (!o.equal(a, A.current.color)) {
      var H = o.toHsva(a);
      A.current = { hsva: H, color: a }, k(H);
    }
  }, [a, o]), tt.useEffect(function() {
    var H;
    rpe(x, A.current.hsva) || o.equal(H = o.fromHsva(x), A.current.color) || (A.current = { hsva: x, color: H }, f(H));
  }, [x, o, f]);
  var N = tt.useCallback(function(H) {
    k(function(Z) {
      return Object.assign({}, Z, H);
    });
  }, []);
  return [x, N];
}
var sCe = typeof window < "u" ? tt.useLayoutEffect : tt.useEffect, rCe = function() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : void 0;
}, gce = /* @__PURE__ */ new Map(), aCe = function(o) {
  sCe(function() {
    var a = o.current ? o.current.ownerDocument : document;
    if (a !== void 0 && !gce.has(a)) {
      var c = a.createElement("style");
      c.innerHTML = `.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}`, gce.set(a, c);
      var f = rCe();
      f && c.setAttribute("nonce", f), a.head.appendChild(c);
    }
  }, []);
}, iCe = function(o) {
  var a = o.className, c = o.colorModel, f = o.color, g = f === void 0 ? c.defaultColor : f, x = o.onChange, k = npe(o, ["className", "colorModel", "color", "onChange"]), A = tt.useRef(null);
  aCe(A);
  var N = oCe(c, g, x), H = N[0], Z = N[1], K = wre(["react-colorful", a]);
  return Ve.createElement("div", bU({}, k, { ref: A, className: K }), Ve.createElement(tCe, { hsva: H, onChange: Z }), Ve.createElement(eCe, { hue: H.h, onChange: Z, className: "react-colorful__last-control" }));
}, lCe = { defaultColor: "000", toHsva: qwe, fromHsva: function(o) {
  return Kwe({ h: o.h, s: o.s, v: o.v, a: 1 });
}, equal: nCe }, cCe = function(o) {
  return Ve.createElement(iCe, bU({}, o, { colorModel: lCe }));
};
function Cre(o) {
  let {
    color: a,
    setColor: c,
    className: f,
    size: g
  } = o;
  const [x, k, A] = Pwe(!1), [N, H] = Ve.useState(null), Z = (U) => /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(U), K = (U) => U.startsWith("#") ? U.slice(0, 7) : `#${U}`.slice(0, 7), [J, pe] = Ve.useState(() => a === "" || Z(K(a))), [Se, be] = Ve.useState(() => a === "" ? "" : K(a)), [ye, re] = Ve.useState(() => {
    const U = K(a);
    return Z(U) ? U : "#fff";
  }), oe = (U) => {
    if (U === "") {
      pe(!0), c(""), be(""), re("#fff");
      return;
    }
    const ve = K(U);
    if (Z(ve)) {
      pe(!0), c(ve), be(ve), re(ve);
      return;
    }
    pe(!1), be(ve), c(ve);
  };
  return /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, /* @__PURE__ */ Ve.createElement("span", {
    className: "d-flex"
  }, /* @__PURE__ */ Ve.createElement(qV, {
    placement: "top",
    overlay: /* @__PURE__ */ Ve.createElement(SI, {
      id: "color-picker-tooltip"
    }, "Color picker")
  }, /* @__PURE__ */ Ve.createElement(L2, {
    ref: H,
    className: er(f, "pgn__color-picker", `pgn__color-picker-${g}`),
    style: {
      ...a && J ? {
        background: `${a}`
      } : {}
    },
    onClick: k
  }))), /* @__PURE__ */ Ve.createElement(xre, {
    positionRef: N,
    isOpen: x,
    style: {
      background: "black"
    },
    onClose: A
  }, /* @__PURE__ */ Ve.createElement("div", {
    className: "pgn__color-modal rounded shadow",
    style: {
      textAlign: "start"
    }
  }, /* @__PURE__ */ Ve.createElement(cCe, {
    color: ye,
    onChange: oe
  }), /* @__PURE__ */ Ve.createElement(Zd.Group, {
    className: "pgn__hex-form",
    size: "sm"
  }, /* @__PURE__ */ Ve.createElement("div", null, /* @__PURE__ */ Ve.createElement(Zd.Label, {
    className: "pgn__hex-label"
  }, "Hex"), /* @__PURE__ */ Ve.createElement(Zd.Control, {
    className: "pgn__hex-field",
    isInvalid: !J,
    value: Se,
    onChange: (U) => oe(U.target.value),
    "data-testid": "hex-input",
    spellCheck: "false"
  })), !J && /* @__PURE__ */ Ve.createElement(Zd.Control.Feedback, {
    className: "pgn__color-error",
    type: "invalid"
  }, "Colors must be in hexadecimal format.")))));
}
Cre.defaultProps = {
  color: "",
  className: void 0,
  size: "md"
};
Cre.propTypes = {
  /** A default hex code to preset the picker to display. */
  color: ce.string,
  /** Passing setState function allows parent to alter the color. */
  setColor: ce.func.isRequired,
  /** A class name to append to the base element. */
  className: ce.string,
  /** Size of the color picker */
  size: ce.oneOf(["sm", "md"])
};
function Ote({
  label: o,
  color: a,
  setColor: c,
  help: f
}) {
  return /* @__PURE__ */ Ws.jsxs("div", { className: "d-flex flex-column pb-3", children: [
    /* @__PURE__ */ Ws.jsxs("div", { className: "d-flex align-items-center", "data-testid": o, children: [
      /* @__PURE__ */ Ws.jsx("span", { className: "mr-2", children: o }),
      /* @__PURE__ */ Ws.jsx(
        Cre,
        {
          size: "sm",
          color: a,
          setColor: c
        }
      )
    ] }),
    /* @__PURE__ */ Ws.jsx("span", { className: "text-light-800 small mt-2", children: f })
  ] });
}
function uCe({
  styling: o,
  setStyling: a
}) {
  const c = (f) => a({ ...o, ...f });
  return /* @__PURE__ */ Ws.jsxs("div", { style: { maxWidth: "800px" }, children: [
    /* @__PURE__ */ Ws.jsx("h3", { className: "mb-2 h3", children: "Styling of Flashcards" }),
    /* @__PURE__ */ Ws.jsxs("div", { className: "d-flex align-items-center mb-2", children: [
      /* @__PURE__ */ Ws.jsx("label", { className: "mr-2", htmlFor: "font-size-input", children: "Font size" }),
      /* @__PURE__ */ Ws.jsx(
        "input",
        {
          id: "font-size-input",
          value: o.fontSize,
          onChange: (f) => c({ fontSize: f.target.value }),
          placeholder: "e.g., 16px, 1.2em"
        }
      )
    ] }),
    /* @__PURE__ */ Ws.jsx(
      Ote,
      {
        label: "Background color",
        help: "Background color of flashcard cards",
        color: o.backgroundColor,
        setColor: (f) => c({ backgroundColor: f })
      }
    ),
    /* @__PURE__ */ Ws.jsx(
      Ote,
      {
        label: "Border color",
        help: "Border color of flashcard cards",
        color: o.borderColor,
        setColor: (f) => c({ borderColor: f })
      }
    ),
    /* @__PURE__ */ Ws.jsx(
      Ote,
      {
        label: "Text color",
        help: "Text color of flashcard content",
        color: o.textColor,
        setColor: (f) => c({ textColor: f })
      }
    )
  ] });
}
var roe = function() {
  return roe = Object.assign || function(o) {
    for (var a, c = 1, f = arguments.length; c < f; c++) {
      a = arguments[c];
      for (var g in a) Object.prototype.hasOwnProperty.call(a, g) && (o[g] = a[g]);
    }
    return o;
  }, roe.apply(this, arguments);
}, ape = {
  onActivate: Pn.func,
  onAddUndo: Pn.func,
  onBeforeAddUndo: Pn.func,
  onBeforeExecCommand: Pn.func,
  onBeforeGetContent: Pn.func,
  onBeforeRenderUI: Pn.func,
  onBeforeSetContent: Pn.func,
  onBeforePaste: Pn.func,
  onBlur: Pn.func,
  onChange: Pn.func,
  onClearUndos: Pn.func,
  onClick: Pn.func,
  onContextMenu: Pn.func,
  onCommentChange: Pn.func,
  onCompositionEnd: Pn.func,
  onCompositionStart: Pn.func,
  onCompositionUpdate: Pn.func,
  onCopy: Pn.func,
  onCut: Pn.func,
  onDblclick: Pn.func,
  onDeactivate: Pn.func,
  onDirty: Pn.func,
  onDrag: Pn.func,
  onDragDrop: Pn.func,
  onDragEnd: Pn.func,
  onDragGesture: Pn.func,
  onDragOver: Pn.func,
  onDrop: Pn.func,
  onExecCommand: Pn.func,
  onFocus: Pn.func,
  onFocusIn: Pn.func,
  onFocusOut: Pn.func,
  onGetContent: Pn.func,
  onHide: Pn.func,
  onInit: Pn.func,
  onInput: Pn.func,
  onKeyDown: Pn.func,
  onKeyPress: Pn.func,
  onKeyUp: Pn.func,
  onLoadContent: Pn.func,
  onMouseDown: Pn.func,
  onMouseEnter: Pn.func,
  onMouseLeave: Pn.func,
  onMouseMove: Pn.func,
  onMouseOut: Pn.func,
  onMouseOver: Pn.func,
  onMouseUp: Pn.func,
  onNodeChange: Pn.func,
  onObjectResizeStart: Pn.func,
  onObjectResized: Pn.func,
  onObjectSelected: Pn.func,
  onPaste: Pn.func,
  onPostProcess: Pn.func,
  onPostRender: Pn.func,
  onPreProcess: Pn.func,
  onProgressState: Pn.func,
  onRedo: Pn.func,
  onRemove: Pn.func,
  onReset: Pn.func,
  onSaveContent: Pn.func,
  onSelectionChange: Pn.func,
  onSetAttrib: Pn.func,
  onSetContent: Pn.func,
  onShow: Pn.func,
  onSubmit: Pn.func,
  onUndo: Pn.func,
  onVisualAid: Pn.func,
  onSkinLoadError: Pn.func,
  onThemeLoadError: Pn.func,
  onModelLoadError: Pn.func,
  onPluginLoadError: Pn.func,
  onIconsLoadError: Pn.func,
  onLanguageLoadError: Pn.func,
  onScriptsLoad: Pn.func,
  onScriptsLoadError: Pn.func
}, dCe = roe({ apiKey: Pn.string, licenseKey: Pn.string, id: Pn.string, inline: Pn.bool, init: Pn.object, initialValue: Pn.string, onEditorChange: Pn.func, value: Pn.string, tagName: Pn.string, tabIndex: Pn.number, cloudChannel: Pn.string, plugins: Pn.oneOfType([Pn.string, Pn.array]), toolbar: Pn.oneOfType([Pn.string, Pn.array]), disabled: Pn.bool, textareaName: Pn.string, tinymceScriptSrc: Pn.oneOfType([
  Pn.string,
  Pn.arrayOf(Pn.string),
  Pn.arrayOf(Pn.shape({
    src: Pn.string,
    async: Pn.bool,
    defer: Pn.bool
  }))
]), rollback: Pn.oneOfType([Pn.number, Pn.oneOf([!1])]), scriptLoading: Pn.shape({
  async: Pn.bool,
  defer: Pn.bool,
  delay: Pn.number
}) }, ape), Dte = function(o) {
  return typeof o == "function";
}, vce = function(o) {
  return o in ape;
}, bce = function(o) {
  return o.substr(2);
}, fCe = function(o, a, c, f, g, x, k) {
  var A = Object.keys(g).filter(vce), N = Object.keys(x).filter(vce), H = A.filter(function(K) {
    return x[K] === void 0;
  }), Z = N.filter(function(K) {
    return g[K] === void 0;
  });
  H.forEach(function(K) {
    var J = bce(K), pe = k[J];
    c(J, pe), delete k[J];
  }), Z.forEach(function(K) {
    var J = f(o, K), pe = bce(K);
    k[pe] = J, a(pe, J);
  });
}, mCe = function(o, a, c, f, g) {
  return fCe(
    g,
    o.on.bind(o),
    o.off.bind(o),
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    function(x, k) {
      return function(A) {
        var N;
        return (N = x(k)) === null || N === void 0 ? void 0 : N(A, o);
      };
    },
    a,
    c,
    f
  );
}, yce = 0, ipe = function(o) {
  var a = Date.now(), c = Math.floor(Math.random() * 1e9);
  return yce++, o + "_" + c + yce + String(a);
}, xce = function(o) {
  return o !== null && (o.tagName.toLowerCase() === "textarea" || o.tagName.toLowerCase() === "input");
}, wce = function(o) {
  return typeof o > "u" || o === "" ? [] : Array.isArray(o) ? o : o.split(" ");
}, pCe = function(o, a) {
  return wce(o).concat(wce(a));
}, hCe = function() {
  return window.InputEvent && typeof InputEvent.prototype.getTargetRanges == "function";
}, gCe = function(o) {
  if (!("isConnected" in Node.prototype)) {
    for (var a = o, c = o.parentNode; c != null; )
      a = c, c = a.parentNode;
    return a === o.ownerDocument;
  }
  return o.isConnected;
}, Cce = function(o, a) {
  o !== void 0 && (o.mode != null && typeof o.mode == "object" && typeof o.mode.set == "function" ? o.mode.set(a) : o.setMode(a));
}, aoe = function() {
  return aoe = Object.assign || function(o) {
    for (var a, c = 1, f = arguments.length; c < f; c++) {
      a = arguments[c];
      for (var g in a) Object.prototype.hasOwnProperty.call(a, g) && (o[g] = a[g]);
    }
    return o;
  }, aoe.apply(this, arguments);
}, vCe = function(o, a, c) {
  var f, g, x = o.createElement("script");
  x.referrerPolicy = "origin", x.type = "application/javascript", x.id = a.id, x.src = a.src, x.async = (f = a.async) !== null && f !== void 0 ? f : !1, x.defer = (g = a.defer) !== null && g !== void 0 ? g : !1;
  var k = function() {
    x.removeEventListener("load", k), x.removeEventListener("error", A), c(a.src);
  }, A = function(N) {
    x.removeEventListener("load", k), x.removeEventListener("error", A), c(a.src, N);
  };
  x.addEventListener("load", k), x.addEventListener("error", A), o.head && o.head.appendChild(x);
}, bCe = function(o) {
  var a = {}, c = function(k, A) {
    var N = a[k];
    N.done = !0, N.error = A;
    for (var H = 0, Z = N.handlers; H < Z.length; H++) {
      var K = Z[H];
      K(k, A);
    }
    N.handlers = [];
  }, f = function(k, A, N) {
    var H = function(oe) {
      return N !== void 0 ? N(oe) : console.error(oe);
    };
    if (k.length === 0) {
      H(new Error("At least one script must be provided"));
      return;
    }
    for (var Z = 0, K = !1, J = function(oe, U) {
      K || (U ? (K = !0, H(U)) : ++Z === k.length && A());
    }, pe = 0, Se = k; pe < Se.length; pe++) {
      var be = Se[pe], ye = a[be.src];
      if (ye)
        ye.done ? J(be.src, ye.error) : ye.handlers.push(J);
      else {
        var re = ipe("tiny-");
        a[be.src] = {
          id: re,
          src: be.src,
          done: !1,
          error: null,
          handlers: [J]
        }, vCe(o, aoe({ id: re }, be), c);
      }
    }
  }, g = function() {
    for (var k, A = 0, N = Object.values(a); A < N.length; A++) {
      var H = N[A], Z = o.getElementById(H.id);
      Z != null && Z.tagName === "SCRIPT" && ((k = Z.parentNode) === null || k === void 0 || k.removeChild(Z));
    }
    a = {};
  }, x = function() {
    return o;
  };
  return {
    loadScripts: f,
    deleteScripts: g,
    getDocument: x
  };
}, yCe = function() {
  var o = [], a = function(g) {
    var x = o.find(function(k) {
      return k.getDocument() === g;
    });
    return x === void 0 && (x = bCe(g), o.push(x)), x;
  }, c = function(g, x, k, A, N) {
    var H = function() {
      return a(g).loadScripts(x, A, N);
    };
    k > 0 ? setTimeout(H, k) : H();
  }, f = function() {
    for (var g = o.pop(); g != null; g = o.pop())
      g.deleteScripts();
  };
  return {
    loadList: c,
    reinitialize: f
  };
}, xCe = yCe(), Rte = function(o) {
  var a = o;
  return a && a.tinymce ? a.tinymce : null;
}, wCe = /* @__PURE__ */ function() {
  var o = function(a, c) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(f, g) {
      f.__proto__ = g;
    } || function(f, g) {
      for (var x in g) Object.prototype.hasOwnProperty.call(g, x) && (f[x] = g[x]);
    }, o(a, c);
  };
  return function(a, c) {
    if (typeof c != "function" && c !== null)
      throw new TypeError("Class extends value " + String(c) + " is not a constructor or null");
    o(a, c);
    function f() {
      this.constructor = a;
    }
    a.prototype = c === null ? Object.create(c) : (f.prototype = c.prototype, new f());
  };
}(), T4 = function() {
  return T4 = Object.assign || function(o) {
    for (var a, c = 1, f = arguments.length; c < f; c++) {
      a = arguments[c];
      for (var g in a) Object.prototype.hasOwnProperty.call(a, g) && (o[g] = a[g]);
    }
    return o;
  }, T4.apply(this, arguments);
}, CCe = (
  /** @class */
  function(o) {
    wCe(a, o);
    function a(c) {
      var f, g, x, k = o.call(this, c) || this;
      return k.rollbackTimer = void 0, k.valueCursor = void 0, k.rollbackChange = function() {
        var A = k.editor, N = k.props.value;
        A && N && N !== k.currentContent && A.undoManager.ignore(function() {
          if (A.setContent(N), k.valueCursor && (!k.inline || A.hasFocus()))
            try {
              A.selection.moveToBookmark(k.valueCursor);
            } catch {
            }
        }), k.rollbackTimer = void 0;
      }, k.handleBeforeInput = function(A) {
        if (k.props.value !== void 0 && k.props.value === k.currentContent && k.editor && (!k.inline || k.editor.hasFocus()))
          try {
            k.valueCursor = k.editor.selection.getBookmark(3);
          } catch {
          }
      }, k.handleBeforeInputSpecial = function(A) {
        (A.key === "Enter" || A.key === "Backspace" || A.key === "Delete") && k.handleBeforeInput(A);
      }, k.handleEditorChange = function(A) {
        var N = k.editor;
        if (N && N.initialized) {
          var H = N.getContent();
          k.props.value !== void 0 && k.props.value !== H && k.props.rollback !== !1 && (k.rollbackTimer || (k.rollbackTimer = window.setTimeout(k.rollbackChange, typeof k.props.rollback == "number" ? k.props.rollback : 200))), H !== k.currentContent && (k.currentContent = H, Dte(k.props.onEditorChange) && k.props.onEditorChange(H, N));
        }
      }, k.handleEditorChangeSpecial = function(A) {
        (A.key === "Backspace" || A.key === "Delete") && k.handleEditorChange(A);
      }, k.initialise = function(A) {
        var N, H, Z;
        A === void 0 && (A = 0);
        var K = k.elementRef.current;
        if (K) {
          if (!gCe(K)) {
            if (A === 0)
              setTimeout(function() {
                return k.initialise(1);
              }, 1);
            else if (A < 100)
              setTimeout(function() {
                return k.initialise(A + 1);
              }, 100);
            else
              throw new Error("tinymce can only be initialised when in a document");
            return;
          }
          var J = Rte(k.view);
          if (!J)
            throw new Error("tinymce should have been loaded into global scope");
          var pe = T4(T4(T4(T4({}, k.props.init), { selector: void 0, target: K, readonly: k.props.disabled, inline: k.inline, plugins: pCe((N = k.props.init) === null || N === void 0 ? void 0 : N.plugins, k.props.plugins), toolbar: (H = k.props.toolbar) !== null && H !== void 0 ? H : (Z = k.props.init) === null || Z === void 0 ? void 0 : Z.toolbar }), k.props.licenseKey ? { license_key: k.props.licenseKey } : {}), { setup: function(Se) {
            k.editor = Se, k.bindHandlers({}), k.inline && !xce(K) && Se.once("PostRender", function(be) {
              Se.setContent(k.getInitialValue(), { no_events: !0 });
            }), k.props.init && Dte(k.props.init.setup) && k.props.init.setup(Se);
          }, init_instance_callback: function(Se) {
            var be, ye, re = k.getInitialValue();
            k.currentContent = (be = k.currentContent) !== null && be !== void 0 ? be : Se.getContent(), k.currentContent !== re && (k.currentContent = re, Se.setContent(re), Se.undoManager.clear(), Se.undoManager.add(), Se.setDirty(!1));
            var oe = (ye = k.props.disabled) !== null && ye !== void 0 ? ye : !1;
            Cce(k.editor, oe ? "readonly" : "design"), k.props.init && Dte(k.props.init.init_instance_callback) && k.props.init.init_instance_callback(Se);
          } });
          k.inline || (K.style.visibility = ""), xce(K) && (K.value = k.getInitialValue()), J.init(pe);
        }
      }, k.id = k.props.id || ipe("tiny-react"), k.elementRef = tt.createRef(), k.inline = (x = (f = k.props.inline) !== null && f !== void 0 ? f : (g = k.props.init) === null || g === void 0 ? void 0 : g.inline) !== null && x !== void 0 ? x : !1, k.boundHandlers = {}, k;
    }
    return Object.defineProperty(a.prototype, "view", {
      get: function() {
        var c, f;
        return (f = (c = this.elementRef.current) === null || c === void 0 ? void 0 : c.ownerDocument.defaultView) !== null && f !== void 0 ? f : window;
      },
      enumerable: !1,
      configurable: !0
    }), a.prototype.componentDidUpdate = function(c) {
      var f = this, g, x;
      if (this.rollbackTimer && (clearTimeout(this.rollbackTimer), this.rollbackTimer = void 0), this.editor && (this.bindHandlers(c), this.editor.initialized)) {
        if (this.currentContent = (g = this.currentContent) !== null && g !== void 0 ? g : this.editor.getContent(), typeof this.props.initialValue == "string" && this.props.initialValue !== c.initialValue)
          this.editor.setContent(this.props.initialValue), this.editor.undoManager.clear(), this.editor.undoManager.add(), this.editor.setDirty(!1);
        else if (typeof this.props.value == "string" && this.props.value !== this.currentContent) {
          var k = this.editor;
          k.undoManager.transact(function() {
            var N;
            if (!f.inline || k.hasFocus())
              try {
                N = k.selection.getBookmark(3);
              } catch {
              }
            var H = f.valueCursor;
            if (k.setContent(f.props.value), !f.inline || k.hasFocus())
              for (var Z = 0, K = [N, H]; Z < K.length; Z++) {
                var J = K[Z];
                if (J)
                  try {
                    k.selection.moveToBookmark(J), f.valueCursor = J;
                    break;
                  } catch {
                  }
              }
          });
        }
        if (this.props.disabled !== c.disabled) {
          var A = (x = this.props.disabled) !== null && x !== void 0 ? x : !1;
          Cce(this.editor, A ? "readonly" : "design");
        }
      }
    }, a.prototype.componentDidMount = function() {
      var c = this, f, g, x, k, A;
      if (Rte(this.view) !== null)
        this.initialise();
      else if (Array.isArray(this.props.tinymceScriptSrc) && this.props.tinymceScriptSrc.length === 0)
        (g = (f = this.props).onScriptsLoadError) === null || g === void 0 || g.call(f, new Error("No `tinymce` global is present but the `tinymceScriptSrc` prop was an empty array."));
      else if (!((x = this.elementRef.current) === null || x === void 0) && x.ownerDocument) {
        var N = function() {
          var Z, K;
          (K = (Z = c.props).onScriptsLoad) === null || K === void 0 || K.call(Z), c.initialise();
        }, H = function(Z) {
          var K, J;
          (J = (K = c.props).onScriptsLoadError) === null || J === void 0 || J.call(K, Z);
        };
        xCe.loadList(this.elementRef.current.ownerDocument, this.getScriptSources(), (A = (k = this.props.scriptLoading) === null || k === void 0 ? void 0 : k.delay) !== null && A !== void 0 ? A : 0, N, H);
      }
    }, a.prototype.componentWillUnmount = function() {
      var c = this, f = this.editor;
      f && (f.off(this.changeEvents(), this.handleEditorChange), f.off(this.beforeInputEvent(), this.handleBeforeInput), f.off("keypress", this.handleEditorChangeSpecial), f.off("keydown", this.handleBeforeInputSpecial), f.off("NewBlock", this.handleEditorChange), Object.keys(this.boundHandlers).forEach(function(g) {
        f.off(g, c.boundHandlers[g]);
      }), this.boundHandlers = {}, f.remove(), this.editor = void 0);
    }, a.prototype.render = function() {
      return this.inline ? this.renderInline() : this.renderIframe();
    }, a.prototype.changeEvents = function() {
      var c, f, g, x = (g = (f = (c = Rte(this.view)) === null || c === void 0 ? void 0 : c.Env) === null || f === void 0 ? void 0 : f.browser) === null || g === void 0 ? void 0 : g.isIE();
      return x ? "change keyup compositionend setcontent CommentChange" : "change input compositionend setcontent CommentChange";
    }, a.prototype.beforeInputEvent = function() {
      return hCe() ? "beforeinput SelectionChange" : "SelectionChange";
    }, a.prototype.renderInline = function() {
      var c = this.props.tagName, f = c === void 0 ? "div" : c;
      return tt.createElement(f, {
        ref: this.elementRef,
        id: this.id,
        tabIndex: this.props.tabIndex
      });
    }, a.prototype.renderIframe = function() {
      return tt.createElement("textarea", {
        ref: this.elementRef,
        style: { visibility: "hidden" },
        name: this.props.textareaName,
        id: this.id,
        tabIndex: this.props.tabIndex
      });
    }, a.prototype.getScriptSources = function() {
      var c, f, g = (c = this.props.scriptLoading) === null || c === void 0 ? void 0 : c.async, x = (f = this.props.scriptLoading) === null || f === void 0 ? void 0 : f.defer;
      if (this.props.tinymceScriptSrc !== void 0)
        return typeof this.props.tinymceScriptSrc == "string" ? [{ src: this.props.tinymceScriptSrc, async: g, defer: x }] : this.props.tinymceScriptSrc.map(function(H) {
          return typeof H == "string" ? { src: H, async: g, defer: x } : H;
        });
      var k = this.props.cloudChannel, A = this.props.apiKey ? this.props.apiKey : "no-api-key", N = "https://cdn.tiny.cloud/1/".concat(A, "/tinymce/").concat(k, "/tinymce.min.js");
      return [{ src: N, async: g, defer: x }];
    }, a.prototype.getInitialValue = function() {
      return typeof this.props.initialValue == "string" ? this.props.initialValue : typeof this.props.value == "string" ? this.props.value : "";
    }, a.prototype.bindHandlers = function(c) {
      var f = this;
      if (this.editor !== void 0) {
        mCe(this.editor, c, this.props, this.boundHandlers, function(A) {
          return f.props[A];
        });
        var g = function(A) {
          return A.onEditorChange !== void 0 || A.value !== void 0;
        }, x = g(c), k = g(this.props);
        !x && k ? (this.editor.on(this.changeEvents(), this.handleEditorChange), this.editor.on(this.beforeInputEvent(), this.handleBeforeInput), this.editor.on("keydown", this.handleBeforeInputSpecial), this.editor.on("keyup", this.handleEditorChangeSpecial), this.editor.on("NewBlock", this.handleEditorChange)) : x && !k && (this.editor.off(this.changeEvents(), this.handleEditorChange), this.editor.off(this.beforeInputEvent(), this.handleBeforeInput), this.editor.off("keydown", this.handleBeforeInputSpecial), this.editor.off("keyup", this.handleEditorChangeSpecial), this.editor.off("NewBlock", this.handleEditorChange));
      }
    }, a.propTypes = dCe, a.defaultProps = {
      cloudChannel: "7"
    }, a;
  }(tt.Component)
), SCe = { exports: {} };
(function(o) {
  (function() {
    var a = function(e) {
      if (e === null)
        return "null";
      if (e === void 0)
        return "undefined";
      var n = typeof e;
      return n === "object" && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === "Array") ? "array" : n === "object" && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === "String") ? "string" : n;
    }, c = function(e) {
      return [
        "undefined",
        "boolean",
        "number",
        "string",
        "function",
        "xml",
        "null"
      ].indexOf(e) !== -1;
    }, f = function(e, n) {
      var s = Array.prototype.slice.call(e);
      return s.sort(n);
    }, g = function(e, n) {
      return x(function(s, i) {
        return e.eq(n(s), n(i));
      });
    }, x = function(e) {
      return { eq: e };
    }, k = x(function(e, n) {
      return e === n;
    }), A = k, N = function(e) {
      return x(function(n, s) {
        if (n.length !== s.length)
          return !1;
        for (var i = n.length, u = 0; u < i; u++)
          if (!e.eq(n[u], s[u]))
            return !1;
        return !0;
      });
    }, H = function(e, n) {
      return g(N(e), function(s) {
        return f(s, n);
      });
    }, Z = function(e) {
      return x(function(n, s) {
        var i = Object.keys(n), u = Object.keys(s);
        if (!H(A).eq(i, u))
          return !1;
        for (var p = i.length, b = 0; b < p; b++) {
          var S = i[b];
          if (!e.eq(n[S], s[S]))
            return !1;
        }
        return !0;
      });
    }, K = x(function(e, n) {
      if (e === n)
        return !0;
      var s = a(e), i = a(n);
      return s !== i ? !1 : c(s) ? e === n : s === "array" ? N(K).eq(e, n) : s === "object" ? Z(K).eq(e, n) : !1;
    });
    const J = Object.getPrototypeOf, pe = (e, n, s) => {
      var i;
      return s(e, n.prototype) ? !0 : ((i = e.constructor) === null || i === void 0 ? void 0 : i.name) === n.name;
    }, Se = (e) => {
      const n = typeof e;
      return e === null ? "null" : n === "object" && Array.isArray(e) ? "array" : n === "object" && pe(e, String, (s, i) => i.isPrototypeOf(s)) ? "string" : n;
    }, be = (e) => (n) => Se(n) === e, ye = (e) => (n) => typeof n === e, re = (e) => (n) => e === n, oe = (e, n) => ve(e) && pe(e, n, (s, i) => J(s) === i), U = be("string"), ve = be("object"), Ze = (e) => oe(e, Object), rt = be("array"), ee = re(null), lt = ye("boolean"), wt = re(void 0), Vt = (e) => e == null, Ue = (e) => !Vt(e), Ce = ye("function"), Rn = ye("number"), _t = (e, n) => {
      if (rt(e)) {
        for (let s = 0, i = e.length; s < i; ++s)
          if (!n(e[s]))
            return !1;
        return !0;
      }
      return !1;
    }, ot = () => {
    }, B = (e, n) => (...s) => e(n.apply(null, s)), fn = (e, n) => (s) => e(n(s)), ze = (e) => () => e, jt = (e) => e, Tt = (e, n) => e === n;
    function Je(e, ...n) {
      return (...s) => {
        const i = n.concat(s);
        return e.apply(null, i);
      };
    }
    const pn = (e) => (n) => !e(n), Ro = (e) => () => {
      throw new Error(e);
    }, Rt = (e) => e(), Cn = (e) => {
      e();
    }, et = ze(!1), xt = ze(!0);
    class X {
      constructor(n, s) {
        this.tag = n, this.value = s;
      }
      static some(n) {
        return new X(!0, n);
      }
      static none() {
        return X.singletonNone;
      }
      fold(n, s) {
        return this.tag ? s(this.value) : n();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(n) {
        return this.tag ? X.some(n(this.value)) : X.none();
      }
      bind(n) {
        return this.tag ? n(this.value) : X.none();
      }
      exists(n) {
        return this.tag && n(this.value);
      }
      forall(n) {
        return !this.tag || n(this.value);
      }
      filter(n) {
        return !this.tag || n(this.value) ? this : X.none();
      }
      getOr(n) {
        return this.tag ? this.value : n;
      }
      or(n) {
        return this.tag ? this : n;
      }
      getOrThunk(n) {
        return this.tag ? this.value : n();
      }
      orThunk(n) {
        return this.tag ? this : n();
      }
      getOrDie(n) {
        if (this.tag)
          return this.value;
        throw new Error(n ?? "Called getOrDie on None");
      }
      static from(n) {
        return Ue(n) ? X.some(n) : X.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(n) {
        this.tag && n(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    X.singletonNone = new X(!1);
    const ds = Array.prototype.slice, So = Array.prototype.indexOf, At = Array.prototype.push, Pt = (e, n) => So.call(e, n), Hn = (e, n) => {
      const s = Pt(e, n);
      return s === -1 ? X.none() : X.some(s);
    }, Nt = (e, n) => Pt(e, n) > -1, Vn = (e, n) => {
      for (let s = 0, i = e.length; s < i; s++) {
        const u = e[s];
        if (n(u, s))
          return !0;
      }
      return !1;
    }, tn = (e, n) => {
      const s = e.length, i = new Array(s);
      for (let u = 0; u < s; u++) {
        const p = e[u];
        i[u] = n(p, u);
      }
      return i;
    }, je = (e, n) => {
      for (let s = 0, i = e.length; s < i; s++) {
        const u = e[s];
        n(u, s);
      }
    }, An = (e, n) => {
      for (let s = e.length - 1; s >= 0; s--) {
        const i = e[s];
        n(i, s);
      }
    }, qn = (e, n) => {
      const s = [], i = [];
      for (let u = 0, p = e.length; u < p; u++) {
        const b = e[u];
        (n(b, u) ? s : i).push(b);
      }
      return {
        pass: s,
        fail: i
      };
    }, on = (e, n) => {
      const s = [];
      for (let i = 0, u = e.length; i < u; i++) {
        const p = e[i];
        n(p, i) && s.push(p);
      }
      return s;
    }, zt = (e, n, s) => (An(e, (i, u) => {
      s = n(s, i, u);
    }), s), vt = (e, n, s) => (je(e, (i, u) => {
      s = n(s, i, u);
    }), s), oo = (e, n, s) => {
      for (let i = 0, u = e.length; i < u; i++) {
        const p = e[i];
        if (n(p, i))
          return X.some(p);
        if (s(p, i))
          break;
      }
      return X.none();
    }, Dn = (e, n) => oo(e, n, et), ao = (e, n) => {
      for (let s = 0, i = e.length; s < i; s++) {
        const u = e[s];
        if (n(u, s))
          return X.some(s);
      }
      return X.none();
    }, xs = (e) => {
      const n = [];
      for (let s = 0, i = e.length; s < i; ++s) {
        if (!rt(e[s]))
          throw new Error("Arr.flatten item " + s + " was not an array, input: " + e);
        At.apply(n, e[s]);
      }
      return n;
    }, rs = (e, n) => xs(tn(e, n)), Qo = (e, n) => {
      for (let s = 0, i = e.length; s < i; ++s) {
        const u = e[s];
        if (n(u, s) !== !0)
          return !1;
      }
      return !0;
    }, os = (e) => {
      const n = ds.call(e, 0);
      return n.reverse(), n;
    }, zs = (e, n) => on(e, (s) => !Nt(n, s)), it = (e, n) => {
      const s = {};
      for (let i = 0, u = e.length; i < u; i++) {
        const p = e[i];
        s[String(p)] = n(p, i);
      }
      return s;
    }, kt = (e, n) => {
      const s = ds.call(e, 0);
      return s.sort(n), s;
    }, xn = (e, n) => n >= 0 && n < e.length ? X.some(e[n]) : X.none(), hn = (e) => xn(e, 0), Do = (e) => xn(e, e.length - 1), Ss = Ce(Array.from) ? Array.from : (e) => ds.call(e), pr = (e, n) => {
      for (let s = 0; s < e.length; s++) {
        const i = n(e[s], s);
        if (i.isSome())
          return i;
      }
      return X.none();
    }, ta = (e, n) => {
      const s = [], i = Ce(n) ? (u) => Vn(s, (p) => n(p, u)) : (u) => Nt(s, u);
      for (let u = 0, p = e.length; u < p; u++) {
        const b = e[u];
        i(b) || s.push(b);
      }
      return s;
    }, Ms = Object.keys, hr = Object.hasOwnProperty, qt = (e, n) => {
      const s = Ms(e);
      for (let i = 0, u = s.length; i < u; i++) {
        const p = s[i], b = e[p];
        n(b, p);
      }
    }, Ko = (e, n) => Lr(e, (s, i) => ({
      k: i,
      v: n(s, i)
    })), Lr = (e, n) => {
      const s = {};
      return qt(e, (i, u) => {
        const p = n(i, u);
        s[p.k] = p.v;
      }), s;
    }, ha = (e) => (n, s) => {
      e[s] = n;
    }, ia = (e, n, s, i) => {
      qt(e, (u, p) => {
        (n(u, p) ? s : i)(u, p);
      });
    }, na = (e, n) => {
      const s = {}, i = {};
      return ia(e, n, ha(s), ha(i)), {
        t: s,
        f: i
      };
    }, ks = (e, n) => {
      const s = {};
      return ia(e, n, ha(s), ot), s;
    }, xa = (e, n) => {
      const s = [];
      return qt(e, (i, u) => {
        s.push(n(i, u));
      }), s;
    }, la = (e) => xa(e, jt), _s = (e, n) => Xn(e, n) ? X.from(e[n]) : X.none(), Xn = (e, n) => hr.call(e, n), wr = (e, n) => Xn(e, n) && e[n] !== void 0 && e[n] !== null, Ke = (e, n, s = K) => Z(s).eq(e, n), ht = (e) => {
      const n = {};
      return je(e, (s) => {
        n[s] = {};
      }), Ms(n);
    }, gn = (e) => e.length !== void 0, En = Array.isArray, Ao = (e) => {
      if (En(e))
        return e;
      {
        const n = [];
        for (let s = 0, i = e.length; s < i; s++)
          n[s] = e[s];
        return n;
      }
    }, as = (e, n, s) => {
      if (!e)
        return !1;
      if (s = s || e, gn(e)) {
        for (let i = 0, u = e.length; i < u; i++)
          if (n.call(s, e[i], i, e) === !1)
            return !1;
      } else
        for (const i in e)
          if (Xn(e, i) && n.call(s, e[i], i, e) === !1)
            return !1;
      return !0;
    }, Yr = (e, n) => {
      const s = [];
      return as(e, (i, u) => {
        s.push(n(i, u, e));
      }), s;
    }, Xr = (e, n) => {
      const s = [];
      return as(e, (i, u) => {
        (!n || n(i, u, e)) && s.push(i);
      }), s;
    }, Tr = (e, n) => {
      if (e) {
        for (let s = 0, i = e.length; s < i; s++)
          if (e[s] === n)
            return s;
      }
      return -1;
    }, Ne = (e, n, s, i) => {
      let u = wt(s) ? e[0] : s;
      for (let p = 0; p < e.length; p++)
        u = n.call(i, u, e[p], p);
      return u;
    }, Ae = (e, n, s) => {
      for (let i = 0, u = e.length; i < u; i++)
        if (n.call(s, e[i], i, e))
          return i;
      return -1;
    }, ct = (e) => e[e.length - 1], Ct = (e) => {
      let n = !1, s;
      return (...i) => (n || (n = !0, s = e.apply(null, i)), s);
    }, Kn = (e, n, s, i) => {
      const u = e.isiOS() && /ipad/i.test(s) === !0, p = e.isiOS() && !u, b = e.isiOS() || e.isAndroid(), S = b || i("(pointer:coarse)"), T = u || !p && b && i("(min-device-width:768px)"), M = p || b && !T, j = n.isSafari() && e.isiOS() && /safari/i.test(s) === !1, W = !M && !T && !j;
      return {
        isiPad: ze(u),
        isiPhone: ze(p),
        isTablet: ze(T),
        isPhone: ze(M),
        isTouch: ze(S),
        isAndroid: e.isAndroid,
        isiOS: e.isiOS,
        isWebView: ze(j),
        isDesktop: ze(W)
      };
    }, lo = (e, n) => {
      for (let s = 0; s < e.length; s++) {
        const i = e[s];
        if (i.test(n))
          return i;
      }
    }, Bo = (e, n) => {
      const s = lo(e, n);
      if (!s)
        return {
          major: 0,
          minor: 0
        };
      const i = (u) => Number(n.replace(s, "$" + u));
      return Oo(i(1), i(2));
    }, Xs = (e, n) => {
      const s = String(n).toLowerCase();
      return e.length === 0 ? $e() : Bo(e, s);
    }, $e = () => Oo(0, 0), Oo = (e, n) => ({
      major: e,
      minor: n
    }), Pe = {
      nu: Oo,
      detect: Xs,
      unknown: $e
    }, Ie = (e, n) => pr(n.brands, (s) => {
      const i = s.brand.toLowerCase();
      return Dn(e, (u) => {
        var p;
        return i === ((p = u.brand) === null || p === void 0 ? void 0 : p.toLowerCase());
      }).map((u) => ({
        current: u.name,
        version: Pe.nu(parseInt(s.version, 10), 0)
      }));
    }), Lt = (e, n) => {
      const s = String(n).toLowerCase();
      return Dn(e, (i) => i.search(s));
    }, Zt = (e, n) => Lt(e, n).map((s) => {
      const i = Pe.detect(s.versionRegexes, n);
      return {
        current: s.name,
        version: i
      };
    }), kn = (e, n) => Lt(e, n).map((s) => {
      const i = Pe.detect(s.versionRegexes, n);
      return {
        current: s.name,
        version: i
      };
    }), Jn = (e, n) => e.substring(n), Zn = (e, n, s) => n === "" || e.length >= n.length && e.substr(s, s + n.length) === n, Gn = (e, n) => co(e, n) ? Jn(e, n.length) : e, Qn = (e, n, s = 0, i) => {
      const u = e.indexOf(n, s);
      return u !== -1 ? wt(i) ? !0 : u + n.length <= i : !1;
    }, co = (e, n) => Zn(e, n, 0), Jo = (e, n) => Zn(e, n, e.length - n.length), Gs = (e) => (n) => n.replace(e, ""), Wa = Gs(/^\s+|\s+$/g), Ti = Gs(/^\s+/g), Ai = Gs(/\s+$/g), ko = (e) => e.length > 0, Zo = (e) => !ko(e), Rs = (e, n) => n <= 0 ? "" : new Array(n + 1).join(e), Ba = (e, n = 10) => {
      const s = parseInt(e, n);
      return isNaN(s) ? X.none() : X.some(s);
    }, ca = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, gr = (e) => (n) => Qn(n, e), Qs = [
      {
        name: "Edge",
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: (e) => Qn(e, "edge/") && Qn(e, "chrome") && Qn(e, "safari") && Qn(e, "applewebkit")
      },
      {
        name: "Chromium",
        brand: "Chromium",
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          ca
        ],
        search: (e) => Qn(e, "chrome") && !Qn(e, "chromeframe")
      },
      {
        name: "IE",
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: (e) => Qn(e, "msie") || Qn(e, "trident")
      },
      {
        name: "Opera",
        versionRegexes: [
          ca,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: gr("opera")
      },
      {
        name: "Firefox",
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: gr("firefox")
      },
      {
        name: "Safari",
        versionRegexes: [
          ca,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: (e) => (Qn(e, "safari") || Qn(e, "mobile/")) && Qn(e, "applewebkit")
      }
    ], ii = [
      {
        name: "Windows",
        search: gr("win"),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "iOS",
        search: (e) => Qn(e, "iphone") || Qn(e, "ipad"),
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: "Android",
        search: gr("android"),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "macOS",
        search: gr("mac os x"),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: "Linux",
        search: gr("linux"),
        versionRegexes: []
      },
      {
        name: "Solaris",
        search: gr("sunos"),
        versionRegexes: []
      },
      {
        name: "FreeBSD",
        search: gr("freebsd"),
        versionRegexes: []
      },
      {
        name: "ChromeOS",
        search: gr("cros"),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ], xc = {
      browsers: ze(Qs),
      oses: ze(ii)
    }, Is = "Edge", ka = "Chromium", li = "IE", Qr = "Opera", Oi = "Firefox", cl = "Safari", Za = () => Di({
      current: void 0,
      version: Pe.unknown()
    }), Di = (e) => {
      const n = e.current, s = e.version, i = (u) => () => n === u;
      return {
        current: n,
        version: s,
        isEdge: i(Is),
        isChromium: i(ka),
        isIE: i(li),
        isOpera: i(Qr),
        isFirefox: i(Oi),
        isSafari: i(cl)
      };
    }, ji = {
      unknown: Za,
      nu: Di,
      edge: ze(Is),
      chromium: ze(ka),
      ie: ze(li),
      opera: ze(Qr),
      firefox: ze(Oi),
      safari: ze(cl)
    }, uu = "Windows", vi = "iOS", Bl = "Android", La = "Linux", Wi = "macOS", Xl = "Solaris", wc = "FreeBSD", fd = "ChromeOS", du = () => bi({
      current: void 0,
      version: Pe.unknown()
    }), bi = (e) => {
      const n = e.current, s = e.version, i = (u) => () => n === u;
      return {
        current: n,
        version: s,
        isWindows: i(uu),
        isiOS: i(vi),
        isAndroid: i(Bl),
        isMacOS: i(Wi),
        isLinux: i(La),
        isSolaris: i(Xl),
        isFreeBSD: i(wc),
        isChromeOS: i(fd)
      };
    }, Fu = {
      unknown: du,
      nu: bi,
      windows: ze(uu),
      ios: ze(vi),
      android: ze(Bl),
      linux: ze(La),
      macos: ze(Wi),
      solaris: ze(Xl),
      freebsd: ze(wc),
      chromeos: ze(fd)
    }, Oe = { detect: (e, n, s) => {
      const i = xc.browsers(), u = xc.oses(), p = n.bind((T) => Ie(i, T)).orThunk(() => Zt(i, e)).fold(ji.unknown, ji.nu), b = kn(u, e).fold(Fu.unknown, Fu.nu), S = Kn(b, p, e, s);
      return {
        browser: p,
        os: b,
        deviceType: S
      };
    } }, Ge = (e) => window.matchMedia(e).matches;
    let Dt = Ct(() => Oe.detect(navigator.userAgent, X.from(navigator.userAgentData), Ge));
    const Xt = () => Dt(), jn = navigator.userAgent, ss = Xt(), hs = ss.browser, Uo = ss.os, qs = ss.deviceType, Ar = jn.indexOf("Windows Phone") !== -1, sn = {
      transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
      documentMode: hs.isIE() ? document.documentMode || 7 : 10,
      cacheSuffix: null,
      container: null,
      canHaveCSP: !hs.isIE(),
      windowsPhone: Ar,
      browser: {
        current: hs.current,
        version: hs.version,
        isChromium: hs.isChromium,
        isEdge: hs.isEdge,
        isFirefox: hs.isFirefox,
        isIE: hs.isIE,
        isOpera: hs.isOpera,
        isSafari: hs.isSafari
      },
      os: {
        current: Uo.current,
        version: Uo.version,
        isAndroid: Uo.isAndroid,
        isChromeOS: Uo.isChromeOS,
        isFreeBSD: Uo.isFreeBSD,
        isiOS: Uo.isiOS,
        isLinux: Uo.isLinux,
        isMacOS: Uo.isMacOS,
        isSolaris: Uo.isSolaris,
        isWindows: Uo.isWindows
      },
      deviceType: {
        isDesktop: qs.isDesktop,
        isiPad: qs.isiPad,
        isiPhone: qs.isiPhone,
        isPhone: qs.isPhone,
        isTablet: qs.isTablet,
        isTouch: qs.isTouch,
        isWebView: qs.isWebView
      }
    }, md = /^\s*|\s*$/g, tr = (e) => Vt(e) ? "" : ("" + e).replace(md, ""), Y = (e, n) => n ? n === "array" && En(e) ? !0 : typeof e === n : e !== void 0, ge = (e, n, s = {}) => {
      const i = U(e) ? e.split(n || ",") : e || [];
      let u = i.length;
      for (; u--; )
        s[i[u]] = {};
      return s;
    }, Ee = Xn, dt = (e, ...n) => {
      for (let s = 0; s < n.length; s++) {
        const i = n[s];
        for (const u in i)
          if (Xn(i, u)) {
            const p = i[u];
            p !== void 0 && (e[u] = p);
          }
      }
      return e;
    }, wn = function(e, n, s, i) {
      i = i || this, e && (s && (e = e[s]), as(e, (u, p) => n.call(i, u, p, s) === !1 ? !1 : (wn(u, n, s, i), !0)));
    }, Kt = {
      trim: tr,
      isArray: En,
      is: Y,
      toArray: Ao,
      makeMap: ge,
      each: as,
      map: Yr,
      grep: Xr,
      inArray: Tr,
      hasOwn: Ee,
      extend: dt,
      walk: wn,
      resolve: (e, n = window) => {
        const s = e.split(".");
        for (let i = 0, u = s.length; i < u && (n = n[s[i]], !!n); i++)
          ;
        return n;
      },
      explode: (e, n) => rt(e) ? e : e === "" ? [] : Yr(e.split(n || ","), tr),
      _addCacheSuffix: (e) => {
        const n = sn.cacheSuffix;
        return n && (e += (e.indexOf("?") === -1 ? "?" : "&") + n), e;
      }
    }, lr = (e, n, s = Tt) => e.exists((i) => s(i, n)), yi = (e, n, s = Tt) => ga(e, n, s).getOr(e.isNone() && n.isNone()), Cr = (e) => {
      const n = [], s = (i) => {
        n.push(i);
      };
      for (let i = 0; i < e.length; i++)
        e[i].each(s);
      return n;
    }, ga = (e, n, s) => e.isSome() && n.isSome() ? X.some(s(e.getOrDie(), n.getOrDie())) : X.none(), Ll = (e, n, s, i) => e.isSome() && n.isSome() && s.isSome() ? X.some(i(e.getOrDie(), n.getOrDie(), s.getOrDie())) : X.none(), gs = (e, n) => e ? X.some(n) : X.none(), xi = typeof window < "u" ? window : Function("return this;")(), Dr = (e, n) => {
      let s = n ?? xi;
      for (let i = 0; i < e.length && s !== void 0 && s !== null; ++i)
        s = s[e[i]];
      return s;
    }, Cc = (e, n) => {
      const s = e.split(".");
      return Dr(s, n);
    }, Mr = (e, n) => Cc(e, n), pd = (e, n) => {
      const s = Mr(e, n);
      if (s == null)
        throw new Error(e + " not available on this browser");
      return s;
    }, Tm = Object.getPrototypeOf, zh = (e) => pd("HTMLElement", e), $r = (e) => {
      const n = Cc("ownerDocument.defaultView", e);
      return ve(e) && (zh(n).prototype.isPrototypeOf(e) || /^HTML\w*Element$/.test(Tm(e).constructor.name));
    }, Ql = 8, $a = 9, Ga = 11, wi = 1, If = 3, fs = (e) => e.dom.nodeName.toLowerCase(), Ri = (e) => e.dom.nodeType, ci = (e) => (n) => Ri(n) === e, me = (e) => Ri(e) === Ql || fs(e) === "#comment", Te = (e) => nt(e) && $r(e.dom), nt = ci(wi), ft = ci(If), eo = ci($a), es = ci(Ga), Sr = (e) => (n) => nt(n) && fs(n) === e, Ha = (e, n, s) => {
      if (U(s) || lt(s) || Rn(s))
        e.setAttribute(n, s + "");
      else
        throw console.error("Invalid call to Attribute.set. Key ", n, ":: Value ", s, ":: Element ", e), new Error("Attribute value was not simple");
    }, is = (e, n, s) => {
      Ha(e.dom, n, s);
    }, _a = (e, n) => {
      const s = e.dom;
      qt(n, (i, u) => {
        Ha(s, u, i);
      });
    }, Rr = (e, n) => {
      const s = e.dom.getAttribute(n);
      return s === null ? void 0 : s;
    }, ua = (e, n) => X.from(Rr(e, n)), oa = (e, n) => {
      const s = e.dom;
      return s && s.hasAttribute ? s.hasAttribute(n) : !1;
    }, Jr = (e, n) => {
      e.dom.removeAttribute(n);
    }, ul = (e) => {
      const n = e.dom.attributes;
      return n == null || n.length === 0;
    }, Sc = (e) => vt(e.dom.attributes, (n, s) => (n[s.name] = s.value, n), {}), qa = (e, n) => {
      const s = Rr(e, n);
      return s === void 0 || s === "" ? [] : s.split(" ");
    }, dl = (e, n, s) => {
      const u = qa(e, n).concat([s]);
      return is(e, n, u.join(" ")), !0;
    }, Bc = (e, n, s) => {
      const i = on(qa(e, n), (u) => u !== s);
      return i.length > 0 ? is(e, n, i.join(" ")) : Jr(e, n), !1;
    }, Lc = (e) => e.dom.classList !== void 0, xp = (e) => qa(e, "class"), hd = (e, n) => dl(e, "class", n), kc = (e, n) => Bc(e, "class", n), Zi = (e, n) => Nt(xp(e), n) ? kc(e, n) : hd(e, n), gd = (e, n) => {
      Lc(e) ? e.dom.classList.add(n) : hd(e, n);
    }, Ff = (e) => {
      (Lc(e) ? e.dom.classList : xp(e)).length === 0 && Jr(e, "class");
    }, fu = (e, n) => {
      Lc(e) ? e.dom.classList.remove(n) : kc(e, n), Ff(e);
    }, Vh = (e, n) => {
      const s = Lc(e) ? e.dom.classList.toggle(n) : Zi(e, n);
      return Ff(e), s;
    }, Bf = (e, n) => Lc(e) && e.dom.classList.contains(n), Uh = (e, n) => {
      const i = (n || document).createElement("div");
      if (i.innerHTML = e, !i.hasChildNodes() || i.childNodes.length > 1) {
        const u = "HTML does not have a single root node";
        throw console.error(u, e), new Error(u);
      }
      return Xd(i.childNodes[0]);
    }, Yd = (e, n) => {
      const i = (n || document).createElement(e);
      return Xd(i);
    }, jh = (e, n) => {
      const i = (n || document).createTextNode(e);
      return Xd(i);
    }, Xd = (e) => {
      if (e == null)
        throw new Error("Node cannot be null or undefined");
      return { dom: e };
    }, Me = {
      fromHtml: Uh,
      fromTag: Yd,
      fromText: jh,
      fromDom: Xd,
      fromPoint: (e, n, s) => X.from(e.dom.elementFromPoint(n, s)).map(Xd)
    }, Am = (e, n) => {
      const s = [], i = (p) => (s.push(p), n(p));
      let u = n(e);
      do
        u = u.bind(i);
      while (u.isSome());
      return s;
    }, wl = (e, n) => {
      const s = e.dom;
      if (s.nodeType !== wi)
        return !1;
      {
        const i = s;
        if (i.matches !== void 0)
          return i.matches(n);
        if (i.msMatchesSelector !== void 0)
          return i.msMatchesSelector(n);
        if (i.webkitMatchesSelector !== void 0)
          return i.webkitMatchesSelector(n);
        if (i.mozMatchesSelector !== void 0)
          return i.mozMatchesSelector(n);
        throw new Error("Browser lacks native selectors");
      }
    }, Bu = (e) => e.nodeType !== wi && e.nodeType !== $a && e.nodeType !== Ga || e.childElementCount === 0, Wh = (e, n) => {
      const s = n === void 0 ? document : n.dom;
      return Bu(s) ? [] : tn(s.querySelectorAll(e), Me.fromDom);
    }, cv = (e, n) => {
      const s = n === void 0 ? document : n.dom;
      return Bu(s) ? X.none() : X.from(s.querySelector(e)).map(Me.fromDom);
    }, Bs = (e, n) => e.dom === n.dom, Gi = (e, n) => {
      const s = e.dom, i = n.dom;
      return s === i ? !1 : s.contains(i);
    }, $l = (e) => Me.fromDom(e.dom.ownerDocument), Ka = (e) => eo(e) ? e : $l(e), Qd = (e) => Me.fromDom(Ka(e).dom.documentElement), $c = (e) => Me.fromDom(Ka(e).dom.defaultView), Ni = (e) => X.from(e.dom.parentNode).map(Me.fromDom), Hc = (e) => X.from(e.dom.parentElement).map(Me.fromDom), Zh = (e, n) => {
      const s = Ce(n) ? n : et;
      let i = e.dom;
      const u = [];
      for (; i.parentNode !== null && i.parentNode !== void 0; ) {
        const p = i.parentNode, b = Me.fromDom(p);
        if (u.push(b), s(b) === !0)
          break;
        i = p;
      }
      return u;
    }, uv = (e) => {
      const n = (s) => on(s, (i) => !Bs(e, i));
      return Ni(e).map(Ya).map(n).getOr([]);
    }, Jl = (e) => X.from(e.dom.previousSibling).map(Me.fromDom), zc = (e) => X.from(e.dom.nextSibling).map(Me.fromDom), wp = (e) => os(Am(e, Jl)), qi = (e) => Am(e, zc), Ya = (e) => tn(e.dom.childNodes, Me.fromDom), vd = (e, n) => {
      const s = e.dom.childNodes;
      return X.from(s[n]).map(Me.fromDom);
    }, Lf = (e) => vd(e, 0), _c = (e) => vd(e, e.dom.childNodes.length - 1), Ci = (e) => e.dom.childNodes.length, Cp = (e) => {
      const n = e.dom.head;
      if (n == null)
        throw new Error("Head is not available yet");
      return Me.fromDom(n);
    }, Sp = (e) => es(e) && Ue(e.dom.host), kp = Ce(Element.prototype.attachShadow) && Ce(Node.prototype.getRootNode), Om = ze(kp), ec = kp ? (e) => Me.fromDom(e.dom.getRootNode()) : Ka, _p = (e) => Sp(e) ? e : Cp(Ka(e)), dv = (e) => Sp(e) ? e : Me.fromDom(Ka(e).dom.body), zb = (e) => {
      const n = ec(e);
      return Sp(n) ? X.some(n) : X.none();
    }, fv = (e) => Me.fromDom(e.dom.host), Ep = (e) => {
      if (Om() && Ue(e.target)) {
        const n = Me.fromDom(e.target);
        if (nt(n) && Dm(n) && e.composed && e.composedPath) {
          const s = e.composedPath();
          if (s)
            return hn(s);
        }
      }
      return X.from(e.target);
    }, Dm = (e) => Ue(e.dom.shadowRoot), Lu = (e) => {
      const n = ft(e) ? e.dom.parentNode : e.dom;
      if (n == null || n.ownerDocument === null)
        return !1;
      const s = n.ownerDocument;
      return zb(Me.fromDom(n)).fold(() => s.body.contains(n), fn(Lu, fv));
    };
    var Gh = (e, n, s, i, u) => e(s, i) ? X.some(s) : Ce(u) && u(s) ? X.none() : n(s, i, u);
    const Nr = (e, n, s) => {
      let i = e.dom;
      const u = Ce(s) ? s : et;
      for (; i.parentNode; ) {
        i = i.parentNode;
        const p = Me.fromDom(i);
        if (n(p))
          return X.some(p);
        if (u(p))
          break;
      }
      return X.none();
    }, sa = (e, n, s) => Gh((u, p) => p(u), Nr, e, n, s), Cl = (e, n) => {
      const s = e.dom;
      return s.parentNode ? qh(Me.fromDom(s.parentNode), (i) => !Bs(e, i) && n(i)) : X.none();
    }, qh = (e, n) => {
      const s = (u) => n(Me.fromDom(u));
      return Dn(e.dom.childNodes, s).map(Me.fromDom);
    }, Kh = (e, n) => {
      const s = (i) => {
        for (let u = 0; u < i.childNodes.length; u++) {
          const p = Me.fromDom(i.childNodes[u]);
          if (n(p))
            return X.some(p);
          const b = s(i.childNodes[u]);
          if (b.isSome())
            return b;
        }
        return X.none();
      };
      return s(e.dom);
    }, Na = (e, n, s) => Nr(e, (i) => wl(i, n), s), to = (e, n) => cv(n, e), mu = (e, n, s) => Gh((u, p) => wl(u, p), Na, e, n, s), mv = (e) => mu(e, "[contenteditable]"), za = (e, n = !1) => Lu(e) ? e.dom.isContentEditable : mv(e).fold(ze(n), (s) => cr(s) === "true"), cr = (e) => e.dom.contentEditable, Jd = (e) => e.style !== void 0 && Ce(e.style.getPropertyValue), Yh = (e, n, s) => {
      if (!U(s))
        throw console.error("Invalid call to CSS.set. Property ", n, ":: Value ", s, ":: Element ", e), new Error("CSS value must be a string: " + s);
      Jd(e) && e.style.setProperty(n, s);
    }, Tp = (e, n) => {
      Jd(e) && e.style.removeProperty(n);
    }, Ap = (e, n, s) => {
      const i = e.dom;
      Yh(i, n, s);
    }, Ho = (e, n) => {
      const s = e.dom;
      qt(n, (i, u) => {
        Yh(s, u, i);
      });
    }, da = (e, n) => {
      const s = e.dom, u = window.getComputedStyle(s).getPropertyValue(n);
      return u === "" && !Lu(e) ? $f(s, n) : u;
    }, $f = (e, n) => Jd(e) ? e.style.getPropertyValue(n) : "", Sl = (e, n) => {
      const s = e.dom, i = $f(s, n);
      return X.from(i).filter((u) => u.length > 0);
    }, fl = (e) => {
      const n = {}, s = e.dom;
      if (Jd(s))
        for (let i = 0; i < s.style.length; i++) {
          const u = s.style.item(i);
          n[u] = s.style[u];
        }
      return n;
    }, kl = (e, n) => {
      const s = e.dom;
      Tp(s, n), lr(ua(e, "style").map(Wa), "") && Jr(e, "style");
    }, Pa = (e) => e.dom.offsetWidth, Ki = (e, n) => {
      Ni(e).each((i) => {
        i.dom.insertBefore(n.dom, e.dom);
      });
    }, tc = (e, n) => {
      zc(e).fold(() => {
        Ni(e).each((u) => {
          Zr(u, n);
        });
      }, (i) => {
        Ki(i, n);
      });
    }, Rm = (e, n) => {
      Lf(e).fold(() => {
        Zr(e, n);
      }, (i) => {
        e.dom.insertBefore(n.dom, i.dom);
      });
    }, Zr = (e, n) => {
      e.dom.appendChild(n.dom);
    }, Xh = (e, n) => {
      Ki(e, n), Zr(n, e);
    }, wa = (e, n) => {
      je(n, (s, i) => {
        const u = i === 0 ? e : n[i - 1];
        tc(u, s);
      });
    }, bd = (e, n) => {
      je(n, (s) => {
        Zr(e, s);
      });
    }, Vc = (e) => {
      e.dom.textContent = "", je(Ya(e), (n) => {
        vr(n);
      });
    }, vr = (e) => {
      const n = e.dom;
      n.parentNode !== null && n.parentNode.removeChild(n);
    }, Uc = (e) => {
      const n = Ya(e);
      n.length > 0 && wa(e, n), vr(e);
    }, Hf = (e, n) => {
      const i = (n || document).createElement("div");
      return i.innerHTML = e, Ya(Me.fromDom(i));
    }, $u = (e) => tn(e, Me.fromDom), Pr = (e) => e.dom.innerHTML, yd = (e, n) => {
      const i = $l(e).dom, u = Me.fromDom(i.createDocumentFragment()), p = Hf(n, i);
      bd(u, p), Vc(e), Zr(e, u);
    }, nc = (e) => {
      const n = Me.fromTag("div"), s = Me.fromDom(e.dom.cloneNode(!0));
      return Zr(n, s), Pr(n);
    }, ls = (e, n, s, i, u, p, b) => ({
      target: e,
      x: n,
      y: s,
      stop: i,
      prevent: u,
      kill: p,
      raw: b
    }), ef = (e) => {
      const n = Me.fromDom(Ep(e).getOr(e.target)), s = () => e.stopPropagation(), i = () => e.preventDefault(), u = B(i, s);
      return ls(n, e.clientX, e.clientY, s, i, u, e);
    }, Nm = (e, n) => (s) => {
      e(s) && n(ef(s));
    }, Op = (e, n, s, i, u) => {
      const p = Nm(s, i);
      return e.dom.addEventListener(n, p, u), { unbind: Je(Dp, e, n, p, u) };
    }, pv = (e, n, s, i) => Op(e, n, s, i, !1), Dp = (e, n, s, i) => {
      e.dom.removeEventListener(n, s, i);
    }, hv = (e, n) => ({
      left: e,
      top: n,
      translate: (i, u) => hv(e + i, n + u)
    }), R = hv, V = (e) => {
      const n = e.getBoundingClientRect();
      return R(n.left, n.top);
    }, se = (e, n) => e !== void 0 ? e : n !== void 0 ? n : 0, De = (e) => {
      const n = e.dom.ownerDocument, s = n.body, i = n.defaultView, u = n.documentElement;
      if (s === e.dom)
        return R(s.offsetLeft, s.offsetTop);
      const p = se(i == null ? void 0 : i.pageYOffset, u.scrollTop), b = se(i == null ? void 0 : i.pageXOffset, u.scrollLeft), S = se(u.clientTop, s.clientTop), T = se(u.clientLeft, s.clientLeft);
      return Le(e).translate(b - T, p - S);
    }, Le = (e) => {
      const n = e.dom, i = n.ownerDocument.body;
      return i === n ? R(i.offsetLeft, i.offsetTop) : Lu(e) ? V(n) : R(0, 0);
    }, $t = (e) => {
      const n = e !== void 0 ? e.dom : document, s = n.body.scrollLeft || n.documentElement.scrollLeft, i = n.body.scrollTop || n.documentElement.scrollTop;
      return R(s, i);
    }, vo = (e, n, s) => {
      const u = (s !== void 0 ? s.dom : document).defaultView;
      u && u.scrollTo(e, n);
    }, Lo = (e, n) => {
      Xt().browser.isSafari() && Ce(e.dom.scrollIntoViewIfNeeded) ? e.dom.scrollIntoViewIfNeeded(!1) : e.dom.scrollIntoView(n);
    }, Mo = (e) => {
      const n = e === void 0 ? window : e;
      return Xt().browser.isFirefox() ? X.none() : X.from(n.visualViewport);
    }, go = (e, n, s, i) => ({
      x: e,
      y: n,
      width: s,
      height: i,
      right: e + s,
      bottom: n + i
    }), Hr = (e) => {
      const n = e === void 0 ? window : e, s = n.document, i = $t(Me.fromDom(s));
      return Mo(n).fold(() => {
        const u = n.document.documentElement, p = u.clientWidth, b = u.clientHeight;
        return go(i.left, i.top, p, b);
      }, (u) => go(Math.max(u.pageLeft, i.left), Math.max(u.pageTop, i.top), u.width, u.height));
    }, fa = (e, n) => on(Ya(e), n), _l = (e, n) => {
      let s = [];
      return je(Ya(e), (i) => {
        n(i) && (s = s.concat([i])), s = s.concat(_l(i, n));
      }), s;
    }, va = (e, n) => Wh(n, e), gv = (e, n, s) => Nr(e, n, s).isSome(), q0 = (e, n) => Cl(e, n).isSome(), Vb = (e, n) => Kh(e, n).isSome();
    class Pi {
      constructor(n, s) {
        this.node = n, this.rootNode = s, this.current = this.current.bind(this), this.next = this.next.bind(this), this.prev = this.prev.bind(this), this.prev2 = this.prev2.bind(this);
      }
      current() {
        return this.node;
      }
      next(n) {
        return this.node = this.findSibling(this.node, "firstChild", "nextSibling", n), this.node;
      }
      prev(n) {
        return this.node = this.findSibling(this.node, "lastChild", "previousSibling", n), this.node;
      }
      prev2(n) {
        return this.node = this.findPreviousNode(this.node, n), this.node;
      }
      findSibling(n, s, i, u) {
        if (n) {
          if (!u && n[s])
            return n[s];
          if (n !== this.rootNode) {
            let p = n[i];
            if (p)
              return p;
            for (let b = n.parentNode; b && b !== this.rootNode; b = b.parentNode)
              if (p = b[i], p)
                return p;
          }
        }
      }
      findPreviousNode(n, s) {
        if (n) {
          const i = n.previousSibling;
          if (this.rootNode && i === this.rootNode)
            return;
          if (i) {
            if (!s) {
              for (let p = i.lastChild; p; p = p.lastChild)
                if (!p.lastChild)
                  return p;
            }
            return i;
          }
          const u = n.parentNode;
          if (u && u !== this.rootNode)
            return u;
        }
      }
    }
    const vv = "\uFEFF", Xa = " ", Ub = (e) => e === vv, Mi = (e) => e.replace(/\uFEFF/g, ""), xo = /^[ \t\r\n]*$/, jc = (e) => xo.test(e), Rp = (e) => {
      for (const n of e)
        if (!Ub(n))
          return !1;
      return !0;
    }, Np = (e) => " \f	\v".indexOf(e) !== -1, K0 = (e) => e === `
` || e === "\r", jb = (e, n) => n < e.length && n >= 0 ? K0(e[n]) : !1, pu = (e, n = 4, s = !0, i = !0) => {
      const u = Rs(" ", n), p = e.replace(/\t/g, u);
      return vt(p, (S, T) => Np(T) || T === Xa ? S.pcIsSpace || S.str === "" && s || S.str.length === p.length - 1 && i || jb(p, S.str.length + 1) ? {
        pcIsSpace: !1,
        str: S.str + Xa
      } : {
        pcIsSpace: !0,
        str: S.str + " "
      } : {
        pcIsSpace: K0(T),
        str: S.str + T
      }, {
        pcIsSpace: !1,
        str: ""
      }).str;
    }, xd = (e) => (n) => !!n && n.nodeType === e, zf = (e) => !!e && !Object.getPrototypeOf(e), Tn = xd(1), Ec = (e) => Tn(e) && Te(Me.fromDom(e)), Wb = (e) => Tn(e) && e.namespaceURI === "http://www.w3.org/2000/svg", Pm = (e) => {
      const n = e.toLowerCase();
      return (s) => Ue(s) && s.nodeName.toLowerCase() === n;
    }, hu = (e) => {
      const n = e.map((s) => s.toLowerCase());
      return (s) => {
        if (s && s.nodeName) {
          const i = s.nodeName.toLowerCase();
          return Nt(n, i);
        }
        return !1;
      };
    }, Qh = (e, n) => {
      const s = n.toLowerCase().split(" ");
      return (i) => {
        if (Tn(i)) {
          const u = i.ownerDocument.defaultView;
          if (u)
            for (let p = 0; p < s.length; p++) {
              const b = u.getComputedStyle(i, null);
              if ((b ? b.getPropertyValue(e) : null) === s[p])
                return !0;
            }
        }
        return !1;
      };
    }, Vf = (e) => (n) => Tn(n) && n.hasAttribute(e), Mm = (e) => Tn(e) && e.hasAttribute("data-mce-bogus"), Jh = (e) => Tn(e) && e.getAttribute("data-mce-bogus") === "all", Hu = (e) => Tn(e) && e.tagName === "TABLE", Y0 = (e) => (n) => !!(Ec(n) && (n.contentEditable === e || n.getAttribute("data-mce-contenteditable") === e)), ra = hu([
      "textarea",
      "input"
    ]), Gt = xd(3), El = xd(4), zu = xd(7), ui = xd(8), Pp = xd(9), Qa = xd(11), Vs = Pm("br"), bv = Pm("img"), Mt = Y0("true"), Ls = Y0("false"), yv = hu([
      "td",
      "th"
    ]), Va = hu([
      "td",
      "th",
      "caption"
    ]), Yi = hu([
      "video",
      "audio",
      "object",
      "embed"
    ]), Y2 = Pm("li"), Tc = Pm("details"), X2 = Pm("summary"), tf = {
      skipBogus: !0,
      includeZwsp: !1,
      checkRootAsContent: !1
    }, X0 = (e, n, s) => {
      const i = Me.fromDom(n), u = Me.fromDom(e), p = s.getWhitespaceElements();
      return gv(u, (S) => Xn(p, fs(S)), Je(Bs, i));
    }, Ac = (e) => Tn(e) && e.nodeName === "A" && !e.hasAttribute("href") && (e.hasAttribute("name") || e.hasAttribute("id")), $s = (e, n) => Tn(e) && Xn(n.getNonEmptyElements(), e.nodeName), wd = Vf("data-mce-bookmark"), Im = (e) => Hc(Me.fromDom(e)).exists((n) => !za(n)), Ua = (e, n, s) => jc(e.data) && !X0(e, n, s), Zb = (e, n, s, i) => Gt(e) && !Ua(e, n, s) && (!i.includeZwsp || !Rp(e.data)), Cd = (e, n, s, i) => Ce(i.isContent) && i.isContent(n) || $s(n, e) || wd(n) || Ac(n) || Zb(n, s, e, i) || Ls(n) || Mt(n) && Im(n), Vu = (e, n, s) => {
      const i = {
        ...tf,
        ...s
      };
      if (i.checkRootAsContent && Cd(e, n, n, i))
        return !1;
      let u = n.firstChild, p = 0;
      if (!u)
        return !0;
      const b = new Pi(u, n);
      do {
        if (i.skipBogus && Tn(u)) {
          const S = u.getAttribute("data-mce-bogus");
          if (S) {
            u = b.next(S === "all");
            continue;
          }
        }
        if (ui(u)) {
          u = b.next(!0);
          continue;
        }
        if (Vs(u)) {
          p++, u = b.next();
          continue;
        }
        if (Cd(e, u, n, i))
          return !1;
        u = b.next();
      } while (u);
      return p <= 1;
    }, kr = (e, n, s) => Vu(e, n.dom, {
      checkRootAsContent: !0,
      ...s
    }), Mp = (e, n, s) => Cd(e, n, n, {
      includeZwsp: tf.includeZwsp,
      ...s
    }), Xe = (e) => {
      let n = e;
      return {
        get: () => n,
        set: (u) => {
          n = u;
        }
      };
    }, Wc = (e) => {
      const n = Xe(X.none()), s = () => n.get().each(e);
      return {
        clear: () => {
          s(), n.set(X.none());
        },
        isSet: () => n.get().isSome(),
        get: () => n.get(),
        set: (S) => {
          s(), n.set(X.some(S));
        }
      };
    }, Ip = (e) => {
      const n = Xe(X.none()), s = () => n.get().each((S) => clearInterval(S));
      return {
        clear: () => {
          s(), n.set(X.none());
        },
        isSet: () => n.get().isSome(),
        get: () => n.get(),
        set: (S) => {
          s(), n.set(X.some(setInterval(S, e)));
        }
      };
    }, Ii = () => {
      const e = Wc(ot);
      return {
        ...e,
        on: (s) => e.get().each(s)
      };
    }, gu = (e) => {
      const n = e.toLowerCase();
      return n === "svg" ? "svg" : n === "math" ? "math" : "html";
    }, Ea = (e) => gu(e) !== "html", Ca = (e) => Ea(e.nodeName), D = (e) => gu(e.nodeName), I = [
      "svg",
      "math"
    ], te = () => {
      const e = Ii(), n = () => e.get().map(D).getOr("html");
      return {
        track: (u) => (Ca(u) ? e.set(u) : e.get().exists((p) => !p.contains(u)) && e.clear(), n()),
        current: n,
        reset: () => {
          e.clear();
        }
      };
    }, he = "data-mce-block", Be = (e) => on(Ms(e), (n) => !/[A-Z]/.test(n)), Ot = (e) => tn(Be(e), (n) => {
      const s = CSS.escape(n);
      return `${s}:` + tn(I, (i) => `not(${i} ${s})`).join(":");
    }).join(","), rn = (e, n) => Ue(n.querySelector(e)) ? (n.setAttribute(he, "true"), n.getAttribute("data-mce-selected") === "inline-boundary" && n.removeAttribute("data-mce-selected"), !0) : (n.removeAttribute(he), !1), $n = (e, n) => {
      const s = Ot(e.getTransparentElements()), i = Ot(e.getBlockElements());
      return on(n.querySelectorAll(s), (u) => rn(i, u));
    }, No = (e, n, s) => {
      var i;
      const u = s ? "lastChild" : "firstChild";
      for (let p = n[u]; p; p = p[u])
        if (Vu(e, p, { checkRootAsContent: !0 })) {
          (i = p.parentNode) === null || i === void 0 || i.removeChild(p);
          return;
        }
    }, ts = (e, n, s) => {
      const i = document.createRange(), u = n.parentNode;
      if (u) {
        i.setStartBefore(n), i.setEndBefore(s);
        const p = i.extractContents();
        No(e, p, !0), i.setStartAfter(s), i.setEndAfter(n);
        const b = i.extractContents();
        No(e, b, !1), Vu(e, p, { checkRootAsContent: !0 }) || u.insertBefore(p, n), Vu(e, s, { checkRootAsContent: !0 }) || u.insertBefore(s, n), Vu(e, b, { checkRootAsContent: !0 }) || u.insertBefore(b, n), u.removeChild(n);
      }
    }, nr = (e, n, s) => {
      const i = e.getBlockElements(), u = Me.fromDom(n), p = (S) => fs(S) in i, b = (S) => Bs(S, u);
      je($u(s), (S) => {
        Nr(S, p, b).each((T) => {
          const M = fa(S, (j) => p(j) && !e.isValidChild(fs(T), fs(j)));
          if (M.length > 0) {
            const j = Hc(T);
            je(M, (W) => {
              Nr(W, p, b).each((G) => {
                ts(e, G.dom, W.dom);
              });
            }), j.each((W) => $n(e, W.dom));
          }
        });
      });
    }, Us = (e, n, s) => {
      je([
        ...s,
        ...Uu(e, n) ? [n] : []
      ], (i) => je(va(Me.fromDom(i), i.nodeName.toLowerCase()), (u) => {
        Fp(e, u.dom) && Uc(u);
      }));
    }, Ir = (e, n) => {
      const s = $n(e, n);
      nr(e, n, s), Us(e, n, s);
    }, oc = (e, n) => {
      if (Uf(e, n)) {
        const s = Ot(e.getBlockElements());
        rn(s, n);
      }
    }, Sd = (e, n, s) => {
      const i = (p) => Bs(p, Me.fromDom(n)), u = Zh(Me.fromDom(s), i);
      xn(u, u.length - 2).filter(nt).fold(() => Ir(e, n), (p) => Ir(e, p.dom));
    }, ml = (e) => e.hasAttribute(he), kd = (e, n) => Xn(e.getTransparentElements(), n), Uf = (e, n) => Tn(n) && kd(e, n.nodeName), Uu = (e, n) => Uf(e, n) && ml(n), Fp = (e, n) => Uf(e, n) && !ml(n), Zc = (e, n) => n.type === 1 && kd(e, n.name) && U(n.attr(he)), xv = Xt().browser, eg = (e) => Dn(e, nt), wv = (e) => xv.isFirefox() && fs(e) === "table" ? eg(Ya(e)).filter((n) => fs(n) === "caption").bind((n) => eg(qi(n)).map((s) => {
      const i = s.dom.offsetTop, u = n.dom.offsetTop, p = n.dom.offsetHeight;
      return i <= u ? -p : 0;
    })).getOr(0) : 0, Cv = (e, n) => e.children && Nt(e.children, n), di = (e, n, s) => {
      let i = 0, u = 0;
      const p = e.ownerDocument;
      if (s = s || e, n) {
        if (s === e && n.getBoundingClientRect && da(Me.fromDom(e), "position") === "static") {
          const S = n.getBoundingClientRect();
          return i = S.left + (p.documentElement.scrollLeft || e.scrollLeft) - p.documentElement.clientLeft, u = S.top + (p.documentElement.scrollTop || e.scrollTop) - p.documentElement.clientTop, {
            x: i,
            y: u
          };
        }
        let b = n;
        for (; b && b !== s && b.nodeType && !Cv(b, s); ) {
          const S = b;
          i += S.offsetLeft || 0, u += S.offsetTop || 0, b = S.offsetParent;
        }
        for (b = n.parentNode; b && b !== s && b.nodeType && !Cv(b, s); )
          i -= b.scrollLeft || 0, u -= b.scrollTop || 0, b = b.parentNode;
        u += wv(Me.fromDom(n));
      }
      return {
        x: i,
        y: u
      };
    }, vs = (e, n = {}) => {
      let s = 0;
      const i = {}, u = Me.fromDom(e), p = Ka(u), b = (He) => {
        n.referrerPolicy = He;
      }, S = (He) => {
        n.contentCssCors = He;
      }, T = (He) => {
        Zr(_p(u), He);
      }, M = (He) => {
        const Ye = _p(u);
        to(Ye, "#" + He).each(vr);
      }, j = (He) => _s(i, He).getOrThunk(() => ({
        id: "mce-u" + s++,
        passed: [],
        failed: [],
        count: 0
      })), W = (He) => new Promise((Ye, We) => {
        let ut;
        const Ut = Kt._addCacheSuffix(He), an = j(Ut);
        i[Ut] = an, an.count++;
        const Nn = (zn, uo) => {
          je(zn, Cn), an.status = uo, an.passed = [], an.failed = [], ut && (ut.onload = null, ut.onerror = null, ut = null);
        }, Et = () => Nn(an.passed, 2), bt = () => Nn(an.failed, 3);
        if (Ye && an.passed.push(Ye), We && an.failed.push(We), an.status === 1)
          return;
        if (an.status === 2) {
          Et();
          return;
        }
        if (an.status === 3) {
          bt();
          return;
        }
        an.status = 1;
        const Ht = Me.fromTag("link", p.dom);
        _a(Ht, {
          rel: "stylesheet",
          type: "text/css",
          id: an.id
        }), n.contentCssCors && is(Ht, "crossOrigin", "anonymous"), n.referrerPolicy && is(Ht, "referrerpolicy", n.referrerPolicy), ut = Ht.dom, ut.onload = Et, ut.onerror = bt, T(Ht), is(Ht, "href", Ut);
      }), G = (He, Ye) => {
        const We = j(He);
        i[He] = We, We.count++;
        const ut = Me.fromTag("style", p.dom);
        _a(ut, {
          rel: "stylesheet",
          type: "text/css",
          id: We.id
        }), ut.dom.innerHTML = Ye, T(ut);
      }, ue = (He) => Promise.allSettled(tn(He, (We) => W(We).then(ze(We)))).then((We) => {
        const ut = qn(We, (Ut) => Ut.status === "fulfilled");
        return ut.fail.length > 0 ? Promise.reject(tn(ut.fail, (Ut) => Ut.reason)) : tn(ut.pass, (Ut) => Ut.value);
      }), we = (He) => {
        const Ye = Kt._addCacheSuffix(He);
        _s(i, Ye).each((We) => {
          --We.count === 0 && (delete i[Ye], M(We.id));
        });
      };
      return {
        load: W,
        loadRawCss: G,
        loadAll: ue,
        unload: we,
        unloadRawCss: (He) => {
          _s(i, He).each((Ye) => {
            --Ye.count === 0 && (delete i[He], M(Ye.id));
          });
        },
        unloadAll: (He) => {
          je(He, (Ye) => {
            we(Ye);
          });
        },
        _setReferrerPolicy: b,
        _setContentCssCors: S
      };
    }, Ja = (() => {
      const e = /* @__PURE__ */ new WeakMap();
      return { forElement: (s, i) => {
        const p = ec(s).dom;
        return X.from(e.get(p)).getOrThunk(() => {
          const b = vs(p, i);
          return e.set(p, b), b;
        });
      } };
    })(), Oc = (e) => e.nodeName.toLowerCase() === "span", sc = (e, n) => Ue(e) && (Mp(n, e) || n.isInline(e.nodeName.toLowerCase())), Sv = (e, n, s) => {
      const i = new Pi(e, n).prev(!1), u = new Pi(e, n).next(!1), p = wt(i) || sc(i, s), b = wt(u) || sc(u, s);
      return p && b;
    }, _d = (e) => Oc(e) && e.getAttribute("data-mce-type") === "bookmark", Fm = (e, n, s) => Gt(e) && e.data.length > 0 && Sv(e, n, s), jf = (e) => Tn(e) ? e.childNodes.length > 0 : !1, nf = (e) => Qa(e) || Pp(e), Wf = (e, n, s, i) => {
      var u;
      const p = i || n;
      if (Tn(n) && _d(n))
        return n;
      const b = n.childNodes;
      for (let S = b.length - 1; S >= 0; S--)
        Wf(e, b[S], s, p);
      if (Tn(n)) {
        const S = n.childNodes;
        S.length === 1 && _d(S[0]) && ((u = n.parentNode) === null || u === void 0 || u.insertBefore(S[0], n));
      }
      return !nf(n) && !Mp(s, n) && !jf(n) && !Fm(n, p, s) && e.remove(n), n;
    }, Ed = Kt.makeMap, Gb = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Zf = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, kv = /[<>&\"\']/g, tg = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi, n_ = {
      128: "€",
      130: "‚",
      131: "ƒ",
      132: "„",
      133: "…",
      134: "†",
      135: "‡",
      136: "ˆ",
      137: "‰",
      138: "Š",
      139: "‹",
      140: "Œ",
      142: "Ž",
      145: "‘",
      146: "’",
      147: "“",
      148: "”",
      149: "•",
      150: "–",
      151: "—",
      152: "˜",
      153: "™",
      154: "š",
      155: "›",
      156: "œ",
      158: "ž",
      159: "Ÿ"
    }, of = {
      '"': "&quot;",
      "'": "&#39;",
      "<": "&lt;",
      ">": "&gt;",
      "&": "&amp;",
      "`": "&#96;"
    }, o_ = {
      "&lt;": "<",
      "&gt;": ">",
      "&amp;": "&",
      "&quot;": '"',
      "&apos;": "'"
    }, Q2 = (e) => {
      const n = Me.fromTag("div").dom;
      return n.innerHTML = e, n.textContent || n.innerText || e;
    }, Ta = (e, n) => {
      const s = {};
      if (e) {
        const i = e.split(",");
        n = n || 10;
        for (let u = 0; u < i.length; u += 2) {
          const p = String.fromCharCode(parseInt(i[u], n));
          if (!of[p]) {
            const b = "&" + i[u + 1] + ";";
            s[p] = b, s[b] = p;
          }
        }
        return s;
      } else
        return;
    }, Q0 = Ta("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32), sf = (e, n) => e.replace(n ? Gb : Zf, (s) => of[s] || s), Bp = (e) => ("" + e).replace(kv, (n) => of[n] || n), Bm = (e, n) => e.replace(n ? Gb : Zf, (s) => s.length > 1 ? "&#" + ((s.charCodeAt(0) - 55296) * 1024 + (s.charCodeAt(1) - 56320) + 65536) + ";" : of[s] || "&#" + s.charCodeAt(0) + ";"), ju = (e, n, s) => {
      const i = s || Q0;
      return e.replace(n ? Gb : Zf, (u) => of[u] || i[u] || u);
    }, rf = {
      encodeRaw: sf,
      encodeAllRaw: Bp,
      encodeNumeric: Bm,
      encodeNamed: ju,
      getEncodeFunc: (e, n) => {
        const s = Ta(n) || Q0, i = (b, S) => b.replace(S ? Gb : Zf, (T) => of[T] !== void 0 ? of[T] : s[T] !== void 0 ? s[T] : T.length > 1 ? "&#" + ((T.charCodeAt(0) - 55296) * 1024 + (T.charCodeAt(1) - 56320) + 65536) + ";" : "&#" + T.charCodeAt(0) + ";"), u = (b, S) => ju(b, S, s), p = Ed(e.replace(/\+/g, ","));
        return p.named && p.numeric ? i : p.named ? n ? u : ju : p.numeric ? Bm : sf;
      },
      decode: (e) => e.replace(tg, (n, s) => s ? (s.charAt(0).toLowerCase() === "x" ? s = parseInt(s.substr(1), 16) : s = parseInt(s, 10), s > 65535 ? (s -= 65536, String.fromCharCode(55296 + (s >> 10), 56320 + (s & 1023))) : n_[s] || String.fromCharCode(s)) : o_[n] || Q0[n] || Q2(n))
    }, Tl = (e, n) => (e = Kt.trim(e), e ? e.split(n || " ") : []), Kb = (e) => new RegExp("^" + e.replace(/([?+*])/g, ".$1") + "$"), J2 = (e) => ve(e) && e.source && Object.prototype.toString.call(e) === "[object RegExp]", Yb = (e) => {
      const n = (s) => rt(s) ? tn(s, n) : J2(s) ? new RegExp(s.source, s.flags) : ve(s) ? Ko(s, n) : s;
      return n(e);
    }, Xb = (e) => {
      const n = /^(~)?(.+)$/;
      return rs(Tl(e, ","), (s) => {
        const i = n.exec(s);
        if (i) {
          const p = i[1] === "~" ? "span" : "div", b = i[2];
          return [{
            cloneName: p,
            name: b
          }];
        } else
          return [];
      });
    }, ew = (e) => Object.freeze([
      "id",
      "accesskey",
      "class",
      "dir",
      "lang",
      "style",
      "tabindex",
      "title",
      "role",
      ...e !== "html4" ? [
        "contenteditable",
        "contextmenu",
        "draggable",
        "dropzone",
        "hidden",
        "spellcheck",
        "translate",
        "itemprop",
        "itemscope",
        "itemtype"
      ] : [],
      ...e !== "html5-strict" ? ["xml:lang"] : []
    ]), ng = (e) => {
      let n, s;
      n = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul", s = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment", e !== "html4" && (n += " article aside details dialog figure main header footer hgroup section nav " + "a ins del canvas map", s += " audio canvas command data datalist mark meter output picture progress time wbr video ruby bdi keygen svg"), e !== "html5-strict" && (s = [
        s,
        "acronym applet basefont big font strike tt"
      ].join(" "), n = [
        n,
        "center dir isindex noframes"
      ].join(" "));
      const i = [
        n,
        s
      ].join(" ");
      return {
        blockContent: n,
        phrasingContent: s,
        flowContent: i
      };
    }, af = (e) => {
      const { blockContent: n, phrasingContent: s, flowContent: i } = ng(e), u = (p) => Object.freeze(p.split(" "));
      return Object.freeze({
        blockContent: u(n),
        phrasingContent: u(s),
        flowContent: u(i)
      });
    }, rc = {
      html4: Ct(() => af("html4")),
      html5: Ct(() => af("html5")),
      "html5-strict": Ct(() => af("html5-strict"))
    }, Zu = (e, n) => {
      const { blockContent: s, phrasingContent: i, flowContent: u } = rc[e]();
      return n === "blocks" ? X.some(s) : n === "phrasing" ? X.some(i) : n === "flow" ? X.some(u) : X.none();
    }, Lp = (e) => {
      const n = ew(e), { phrasingContent: s, flowContent: i } = ng(e), u = {}, p = (T, M, j) => {
        u[T] = {
          attributes: it(M, ze({})),
          attributesOrder: M,
          children: it(j, ze({}))
        };
      }, b = (T, M = "", j = "") => {
        const W = Tl(j), G = Tl(T);
        let ue = G.length;
        const we = [
          ...n,
          ...Tl(M)
        ];
        for (; ue--; )
          p(G[ue], we.slice(), W);
      }, S = (T, M) => {
        const j = Tl(T), W = Tl(M);
        let G = j.length;
        for (; G--; ) {
          const ue = u[j[G]];
          for (let we = 0, fe = W.length; we < fe; we++)
            ue.attributes[W[we]] = {}, ue.attributesOrder.push(W[we]);
        }
      };
      return e !== "html5-strict" && (je(Tl("acronym applet basefont big font strike tt"), (j) => {
        b(j, "", s);
      }), je(Tl("center dir isindex noframes"), (j) => {
        b(j, "", i);
      })), b("html", "manifest", "head body"), b("head", "", "base command link meta noscript script style title"), b("title hr noscript br"), b("base", "href target"), b("link", "href rel media hreflang type sizes hreflang"), b("meta", "name http-equiv content charset"), b("style", "media type scoped"), b("script", "src async defer type charset"), b("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", i), b("dd div", "", i), b("address dt caption", "", e === "html4" ? s : i), b("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", s), b("blockquote", "cite", i), b("ol", "reversed start type", "li"), b("ul", "", "li"), b("li", "value", i), b("dl", "", "dt dd"), b("a", "href target rel media hreflang type", e === "html4" ? s : i), b("q", "cite", s), b("ins del", "cite datetime", i), b("img", "src sizes srcset alt usemap ismap width height"), b("iframe", "src name width height", i), b("embed", "src type width height"), b("object", "data type typemustmatch name usemap form width height", [
        i,
        "param"
      ].join(" ")), b("param", "name value"), b("map", "name", [
        i,
        "area"
      ].join(" ")), b("area", "alt coords shape href target rel media hreflang type"), b("table", "border", "caption colgroup thead tfoot tbody tr" + (e === "html4" ? " col" : "")), b("colgroup", "span", "col"), b("col", "span"), b("tbody thead tfoot", "", "tr"), b("tr", "", "td th"), b("td", "colspan rowspan headers", i), b("th", "colspan rowspan headers scope abbr", i), b("form", "accept-charset action autocomplete enctype method name novalidate target", i), b("fieldset", "disabled form name", [
        i,
        "legend"
      ].join(" ")), b("label", "form for", s), b("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"), b("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", e === "html4" ? i : s), b("select", "disabled form multiple name required size", "option optgroup"), b("optgroup", "disabled label", "option"), b("option", "disabled label selected value"), b("textarea", "cols dirname disabled form maxlength name readonly required rows wrap"), b("menu", "type label", [
        i,
        "li"
      ].join(" ")), b("noscript", "", i), e !== "html4" && (b("wbr"), b("ruby", "", [
        s,
        "rt rp"
      ].join(" ")), b("figcaption", "", i), b("mark rt rp bdi", "", s), b("summary", "", [
        s,
        "h1 h2 h3 h4 h5 h6"
      ].join(" ")), b("canvas", "width height", i), b("data", "value", s), b("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", [
        i,
        "track source"
      ].join(" ")), b("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [
        i,
        "track source"
      ].join(" ")), b("picture", "", "img source"), b("source", "src srcset type media sizes"), b("track", "kind src srclang label default"), b("datalist", "", [
        s,
        "option"
      ].join(" ")), b("article section nav aside main header footer", "", i), b("hgroup", "", "h1 h2 h3 h4 h5 h6"), b("figure", "", [
        i,
        "figcaption"
      ].join(" ")), b("time", "datetime", s), b("dialog", "open", i), b("command", "type label icon disabled checked radiogroup command"), b("output", "for form name", s), b("progress", "value max", s), b("meter", "value min max low high optimum", s), b("details", "open", [
        i,
        "summary"
      ].join(" ")), b("keygen", "autofocus challenge disabled form keytype name"), p("svg", "id tabindex lang xml:space class style x y width height viewBox preserveAspectRatio zoomAndPan transform".split(" "), [])), e !== "html5-strict" && (S("script", "language xml:space"), S("style", "xml:space"), S("object", "declare classid code codebase codetype archive standby align border hspace vspace"), S("embed", "align name hspace vspace"), S("param", "valuetype type"), S("a", "charset name rev shape coords"), S("br", "clear"), S("applet", "codebase archive code object alt name width height align hspace vspace"), S("img", "name longdesc align border hspace vspace"), S("iframe", "longdesc frameborder marginwidth marginheight scrolling align"), S("font basefont", "size color face"), S("input", "usemap align"), S("select"), S("textarea"), S("h1 h2 h3 h4 h5 h6 div p legend caption", "align"), S("ul", "type compact"), S("li", "type"), S("ol dl menu dir", "compact"), S("pre", "width xml:space"), S("hr", "align noshade size width"), S("isindex", "prompt"), S("table", "summary width frame rules cellspacing cellpadding align bgcolor"), S("col", "width align char charoff valign"), S("colgroup", "width align char charoff valign"), S("thead", "align char charoff valign"), S("tr", "align char charoff valign bgcolor"), S("th", "axis align char charoff valign nowrap bgcolor width height"), S("form", "accept"), S("td", "abbr axis scope align char charoff valign nowrap bgcolor width height"), S("tfoot", "align char charoff valign"), S("tbody", "align char charoff valign"), S("area", "nohref"), S("body", "background bgcolor text link vlink alink")), e !== "html4" && (S("input button select textarea", "autofocus"), S("input textarea", "placeholder"), S("a", "download"), S("link script img", "crossorigin"), S("img", "loading"), S("iframe", "sandbox seamless allow allowfullscreen loading referrerpolicy")), e !== "html4" && je([
        u.video,
        u.audio
      ], (T) => {
        delete T.children.audio, delete T.children.video;
      }), je(Tl("a form meter progress dfn"), (T) => {
        u[T] && delete u[T].children[T];
      }), delete u.caption.children.table, delete u.script, u;
    }, tw = (e) => e === "-" ? "remove" : "add", og = (e) => {
      const n = /^(@?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)$/;
      return X.from(n.exec(e)).map((s) => ({
        preset: s[1] === "@",
        name: s[2]
      }));
    }, nw = (e) => {
      const n = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
      return rs(Tl(e, ","), (s) => {
        const i = n.exec(s);
        if (i) {
          const u = i[1], p = u ? tw(u) : "replace", b = i[2], S = rs(Tl(i[3], "|"), (T) => og(T).toArray());
          return [{
            operation: p,
            name: b,
            validChildren: S
          }];
        } else
          return [];
      });
    }, s_ = (e, n) => {
      const s = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/, i = /[*?+]/, { attributes: u, attributesOrder: p } = n;
      return je(Tl(e, "|"), (b) => {
        const S = s.exec(b);
        if (S) {
          const T = {}, M = S[1], j = S[2].replace(/[\\:]:/g, ":"), W = S[3], G = S[4];
          if (M === "!" && (n.attributesRequired = n.attributesRequired || [], n.attributesRequired.push(j), T.required = !0), M === "-") {
            delete u[j], p.splice(Kt.inArray(p, j), 1);
            return;
          }
          if (W && (W === "=" ? (n.attributesDefault = n.attributesDefault || [], n.attributesDefault.push({
            name: j,
            value: G
          }), T.defaultValue = G) : W === "~" ? (n.attributesForced = n.attributesForced || [], n.attributesForced.push({
            name: j,
            value: G
          }), T.forcedValue = G) : W === "<" && (T.validValues = Kt.makeMap(G, "?"))), i.test(j)) {
            const ue = T;
            n.attributePatterns = n.attributePatterns || [], ue.pattern = Kb(j), n.attributePatterns.push(ue);
          } else
            u[j] || p.push(j), u[j] = T;
        }
      });
    }, r_ = (e, n) => {
      qt(e.attributes, (s, i) => {
        n.attributes[i] = s;
      }), n.attributesOrder.push(...e.attributesOrder);
    }, a_ = (e, n) => {
      const s = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/;
      return rs(Tl(n, ","), (i) => {
        const u = s.exec(i);
        if (u) {
          const p = u[1], b = u[2], S = u[3], T = u[4], M = u[5], j = {
            attributes: {},
            attributesOrder: []
          };
          if (e.each((W) => r_(W, j)), p === "#" ? j.paddEmpty = !0 : p === "-" && (j.removeEmpty = !0), T === "!" && (j.removeEmptyAttrs = !0), M && s_(M, j), S && (j.outputName = b), b === "@")
            if (e.isNone())
              e = X.some(j);
            else
              return [];
          return [S ? {
            name: b,
            element: j,
            aliasName: S
          } : {
            name: b,
            element: j
          }];
        } else
          return [];
      });
    }, $p = {}, sg = Kt.makeMap, Xo = Kt.each, po = Kt.extend, Hp = Kt.explode, Qb = (e, n = {}) => {
      const s = sg(e, " ", sg(e.toUpperCase(), " "));
      return po(s, n);
    }, J0 = (e) => Qb("td th li dt dd figcaption caption details summary", e.getTextBlockElements()), ow = (e, n) => {
      if (e) {
        const s = {};
        return U(e) && (e = { "*": e }), Xo(e, (i, u) => {
          s[u] = s[u.toUpperCase()] = n === "map" ? sg(i, /[, ]/) : Hp(i, /[, ]/);
        }), s;
      } else
        return;
    }, Gf = (e = {}) => {
      var n;
      const s = {}, i = {};
      let u = [];
      const p = {}, b = {}, S = (fo, Ps, ya) => {
        const Ra = e[fo];
        if (Ra)
          return sg(Ra, /[, ]/, sg(Ra.toUpperCase(), /[, ]/));
        {
          let si = $p[fo];
          return si || (si = Qb(Ps, ya), $p[fo] = si), si;
        }
      }, T = (n = e.schema) !== null && n !== void 0 ? n : "html5", M = Lp(T);
      e.verify_html === !1 && (e.valid_elements = "*[*]");
      const j = ow(e.valid_styles), W = ow(e.invalid_styles, "map"), G = ow(e.valid_classes, "map"), ue = S("whitespace_elements", "pre script noscript style textarea video audio iframe object code"), we = S("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr"), fe = S("void_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track"), ke = S("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls allowfullscreen"), He = "td th iframe video audio object script code", Ye = S("non_empty_elements", He + " pre svg textarea summary", fe), We = S("move_caret_before_on_enter_elements", He + " table", fe), ut = "h1 h2 h3 h4 h5 h6", Ut = S("text_block_elements", ut + " p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure"), an = S("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary html body multicol listing", Ut), Nn = S("text_inline_elements", "span strong b em i font s strike u var cite dfn code mark q sup sub samp"), Et = S("transparent_elements", "a ins del canvas map"), bt = S("wrap_block_elements", "pre " + ut);
      Xo("script noscript iframe noframes noembed title style textarea xmp plaintext".split(" "), (fo) => {
        b[fo] = new RegExp("</" + fo + "[^>]*>", "gi");
      });
      const Ht = (fo) => {
        const Ps = X.from(s["@"]), ya = /[*?+]/;
        je(a_(Ps, fo ?? ""), ({ name: Ra, element: si, aliasName: sl }) => {
          if (sl && (s[sl] = si), ya.test(Ra)) {
            const ja = si;
            ja.pattern = Kb(Ra), u.push(ja);
          } else
            s[Ra] = si;
        });
      }, zn = (fo) => {
        u = [], je(Ms(s), (Ps) => {
          delete s[Ps];
        }), Ht(fo);
      }, uo = (fo, Ps) => {
        var ya, Ra;
        delete $p.text_block_elements, delete $p.block_elements;
        const si = Ps.extends ? !Au(Ps.extends) : !1, sl = Ps.extends;
        if (i[fo] = sl ? i[sl] : {}, p[fo] = sl ?? fo, Ye[fo.toUpperCase()] = {}, Ye[fo] = {}, si || (an[fo.toUpperCase()] = {}, an[fo] = {}), sl && !s[fo] && s[sl]) {
          const ja = Yb(s[sl]);
          delete ja.removeEmptyAttrs, delete ja.removeEmpty, s[fo] = ja;
        } else
          s[fo] = {
            attributesOrder: [],
            attributes: {}
          };
        if (rt(Ps.attributes)) {
          const ja = (Gl) => {
            Fa.attributesOrder.push(Gl), Fa.attributes[Gl] = {};
          }, Fa = (ya = s[fo]) !== null && ya !== void 0 ? ya : {};
          delete Fa.attributesDefault, delete Fa.attributesForced, delete Fa.attributePatterns, delete Fa.attributesRequired, Fa.attributesOrder = [], Fa.attributes = {}, je(Ps.attributes, (Gl) => {
            const ad = ew(T);
            og(Gl).each(({ preset: Tf, name: Af }) => {
              Tf ? Af === "global" && je(ad, ja) : ja(Af);
            });
          }), s[fo] = Fa;
        }
        if (lt(Ps.padEmpty)) {
          const ja = (Ra = s[fo]) !== null && Ra !== void 0 ? Ra : {};
          ja.paddEmpty = Ps.padEmpty, s[fo] = ja;
        }
        if (rt(Ps.children)) {
          const ja = {}, Fa = (ad) => {
            ja[ad] = {};
          }, Gl = (ad) => {
            Zu(T, ad).each((Tf) => {
              je(Tf, Fa);
            });
          };
          je(Ps.children, (ad) => {
            og(ad).each(({ preset: Tf, name: Af }) => {
              Tf ? Gl(Af) : Fa(Af);
            });
          }), i[fo] = ja;
        }
        sl && qt(i, (ja, Fa) => {
          ja[sl] && (i[Fa] = ja = po({}, i[Fa]), ja[fo] = ja[sl]);
        });
      }, Go = (fo) => {
        je(Xb(fo ?? ""), ({ name: Ps, cloneName: ya }) => {
          uo(Ps, { extends: ya });
        });
      }, ys = (fo) => {
        ve(fo) ? qt(fo, (Ps, ya) => uo(ya, Ps)) : U(fo) && Go(fo);
      }, Js = (fo) => {
        je(nw(fo ?? ""), ({ operation: Ps, name: ya, validChildren: Ra }) => {
          const si = Ps === "replace" ? { "#comment": {} } : i[ya], sl = (Fa) => {
            Ps === "remove" ? delete si[Fa] : si[Fa] = {};
          }, ja = (Fa) => {
            Zu(T, Fa).each((Gl) => {
              je(Gl, sl);
            });
          };
          je(Ra, ({ preset: Fa, name: Gl }) => {
            Fa ? ja(Gl) : sl(Gl);
          }), i[ya] = si;
        });
      }, xr = (fo) => {
        const Ps = s[fo];
        if (Ps)
          return Ps;
        let ya = u.length;
        for (; ya--; ) {
          const Ra = u[ya];
          if (Ra.pattern.test(fo))
            return Ra;
        }
      }, Da = () => {
        e.valid_elements ? (zn(e.valid_elements), Xo(M, (fo, Ps) => {
          i[Ps] = fo.children;
        })) : (Xo(M, (fo, Ps) => {
          s[Ps] = {
            attributes: fo.attributes,
            attributesOrder: fo.attributesOrder
          }, i[Ps] = fo.children;
        }), Xo(Tl("strong/b em/i"), (fo) => {
          const Ps = Tl(fo, "/");
          s[Ps[1]].outputName = Ps[0];
        }), Xo(Nn, (fo, Ps) => {
          s[Ps] && (e.padd_empty_block_inline_children && (s[Ps].paddInEmptyBlock = !0), s[Ps].removeEmpty = !0);
        }), Xo(Tl("ol ul blockquote a table tbody"), (fo) => {
          s[fo] && (s[fo].removeEmpty = !0);
        }), Xo(Tl("p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary"), (fo) => {
          s[fo] && (s[fo].paddEmpty = !0);
        }), Xo(Tl("span"), (fo) => {
          s[fo].removeEmptyAttrs = !0;
        })), delete s.svg, ys(e.custom_elements), Js(e.valid_children), Ht(e.extended_valid_elements), Js("+ol[ul|ol],+ul[ul|ol]"), Xo({
          dd: "dl",
          dt: "dl",
          li: "ul ol",
          td: "tr",
          th: "tr",
          tr: "tbody thead tfoot",
          tbody: "table",
          thead: "table",
          tfoot: "table",
          legend: "fieldset",
          area: "map",
          param: "video audio object"
        }, (fo, Ps) => {
          s[Ps] && (s[Ps].parentsRequired = Tl(fo));
        }), e.invalid_elements && Xo(Hp(e.invalid_elements), (fo) => {
          s[fo] && delete s[fo];
        }), xr("span") || Ht("span[!data-mce-type|*]");
      }, yl = ze(j), mr = ze(W), mn = ze(G), ro = ze(ke), Hs = ze(an), Sn = ze(Ut), bo = ze(Nn), cs = ze(Object.seal(fe)), On = ze(we), us = ze(Ye), ws = ze(We), Vi = ze(ue), ar = ze(Et), hi = ze(bt), Bd = ze(Object.seal(b)), vm = (fo, Ps) => {
        const ya = i[fo.toLowerCase()];
        return !!(ya && ya[Ps.toLowerCase()]);
      }, gc = (fo, Ps) => {
        const ya = xr(fo);
        if (ya)
          if (Ps) {
            if (ya.attributes[Ps])
              return !0;
            const Ra = ya.attributePatterns;
            if (Ra) {
              let si = Ra.length;
              for (; si--; )
                if (Ra[si].pattern.test(Ps))
                  return !0;
            }
          } else
            return !0;
        return !1;
      }, Au = (fo) => Xn(Hs(), fo), rd = (fo) => !co(fo, "#") && gc(fo) && !Au(fo), Ou = (fo) => Xn(hi(), fo) || rd(fo), Ld = ze(p);
      return Da(), {
        type: T,
        children: i,
        elements: s,
        getValidStyles: yl,
        getValidClasses: mn,
        getBlockElements: Hs,
        getInvalidStyles: mr,
        getVoidElements: cs,
        getTextBlockElements: Sn,
        getTextInlineElements: bo,
        getBoolAttrs: ro,
        getElementRule: xr,
        getSelfClosingElements: On,
        getNonEmptyElements: us,
        getMoveCaretBeforeOnEnterElements: ws,
        getWhitespaceElements: Vi,
        getTransparentElements: ar,
        getSpecialElements: Bd,
        isValidChild: vm,
        isValid: gc,
        isBlock: Au,
        isInline: rd,
        isWrapper: Ou,
        getCustomElements: Ld,
        addValidElements: Ht,
        setValidElements: zn,
        addCustomElements: ys,
        addValidChildren: Js
      };
    }, zr = (e) => ({ value: i_(e) }), i_ = (e) => Gn(e, "#").toUpperCase(), sw = (e) => {
      const n = e.toString(16);
      return (n.length === 1 ? "0" + n : n).toUpperCase();
    }, ey = (e) => {
      const n = sw(e.red) + sw(e.green) + sw(e.blue);
      return zr(n);
    }, Ft = /^\s*rgb\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*\)\s*$/i, rg = /^\s*rgba\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*((?:\d?\.\d+|\d+)%?)\s*\)\s*$/i, iO = (e, n, s, i) => ({
      red: e,
      green: n,
      blue: s,
      alpha: i
    }), zp = (e, n, s, i) => {
      const u = parseInt(e, 10), p = parseInt(n, 10), b = parseInt(s, 10), S = parseFloat(i);
      return iO(u, p, b, S);
    }, lO = (e) => Ft.test(e) ? "rgb" : rg.test(e) ? "rgba" : "other", ag = (e) => {
      const n = Ft.exec(e);
      if (n !== null)
        return X.some(zp(n[1], n[2], n[3], "1"));
      const s = rg.exec(e);
      return s !== null ? X.some(zp(s[1], s[2], s[3], s[4])) : X.none();
    }, rw = (e) => `rgba(${e.red},${e.green},${e.blue},${e.alpha})`, lf = (e) => ag(e).map(ey).map((n) => "#" + n.value).getOr(e), aw = (e = {}, n) => {
      const s = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi, i = /\s*([^:]+):\s*([^;]+);?/g, u = /\s+$/, p = {};
      let b, S;
      const T = vv;
      n && (b = n.getValidStyles(), S = n.getInvalidStyles());
      const M = (`\\" \\' \\; \\: ; : ` + T).split(" ");
      for (let W = 0; W < M.length; W++)
        p[M[W]] = T + W, p[T + W] = M[W];
      const j = {
        parse: (W) => {
          const G = {};
          let ue = !1;
          const we = e.url_converter, fe = e.url_converter_scope || j, ke = (Et, bt, Ht) => {
            const zn = G[Et + "-top" + bt];
            if (!zn)
              return;
            const uo = G[Et + "-right" + bt];
            if (!uo)
              return;
            const Go = G[Et + "-bottom" + bt];
            if (!Go)
              return;
            const ys = G[Et + "-left" + bt];
            if (!ys)
              return;
            const Js = [
              zn,
              uo,
              Go,
              ys
            ];
            let xr = Js.length - 1;
            for (; xr-- && Js[xr] === Js[xr + 1]; )
              ;
            xr > -1 && Ht || (G[Et + bt] = xr === -1 ? Js[0] : Js.join(" "), delete G[Et + "-top" + bt], delete G[Et + "-right" + bt], delete G[Et + "-bottom" + bt], delete G[Et + "-left" + bt]);
          }, He = (Et) => {
            const bt = G[Et];
            if (!bt)
              return;
            const Ht = bt.indexOf(",") > -1 ? [bt] : bt.split(" ");
            let zn = Ht.length;
            for (; zn--; )
              if (Ht[zn] !== Ht[0])
                return !1;
            return G[Et] = Ht[0], !0;
          }, Ye = (Et, bt, Ht, zn) => {
            He(bt) && He(Ht) && He(zn) && (G[Et] = G[bt] + " " + G[Ht] + " " + G[zn], delete G[bt], delete G[Ht], delete G[zn]);
          }, We = (Et) => (ue = !0, p[Et]), ut = (Et, bt) => (ue && (Et = Et.replace(/\uFEFF[0-9]/g, (Ht) => p[Ht])), bt || (Et = Et.replace(/\\([\'\";:])/g, "$1")), Et), Ut = (Et) => String.fromCharCode(parseInt(Et.slice(1), 16)), an = (Et) => Et.replace(/\\[0-9a-f]+/gi, Ut), Nn = (Et, bt, Ht, zn, uo, Go) => {
            if (uo = uo || Go, uo)
              return uo = ut(uo), "'" + uo.replace(/\'/g, "\\'") + "'";
            if (bt = ut(bt || Ht || zn || ""), !e.allow_script_urls) {
              const ys = bt.replace(/[\s\r\n]+/g, "");
              if (/(java|vb)script:/i.test(ys) || !e.allow_svg_data_urls && /^data:image\/svg/i.test(ys))
                return "";
            }
            return we && (bt = we.call(fe, bt, "style")), "url('" + bt.replace(/\'/g, "\\'") + "')";
          };
          if (W) {
            W = W.replace(/[\u0000-\u001F]/g, ""), W = W.replace(/\\[\"\';:\uFEFF]/g, We).replace(/\"[^\"]+\"|\'[^\']+\'/g, (bt) => bt.replace(/[;:]/g, We));
            let Et;
            for (; Et = i.exec(W); ) {
              i.lastIndex = Et.index + Et[0].length;
              let bt = Et[1].replace(u, "").toLowerCase(), Ht = Et[2].replace(u, "");
              if (bt && Ht) {
                if (bt = an(bt), Ht = an(Ht), bt.indexOf(T) !== -1 || bt.indexOf('"') !== -1 || !e.allow_script_urls && (bt === "behavior" || /expression\s*\(|\/\*|\*\//.test(Ht)))
                  continue;
                bt === "font-weight" && Ht === "700" ? Ht = "bold" : (bt === "color" || bt === "background-color") && (Ht = Ht.toLowerCase()), lO(Ht) === "rgb" && ag(Ht).each((zn) => {
                  Ht = lf(rw(zn)).toLowerCase();
                }), Ht = Ht.replace(s, Nn), G[bt] = ue ? ut(Ht, !0) : Ht;
              }
            }
            ke("border", "", !0), ke("border", "-width"), ke("border", "-color"), ke("border", "-style"), ke("padding", ""), ke("margin", ""), Ye("border", "border-width", "border-style", "border-color"), G.border === "medium none" && delete G.border, G["border-image"] === "none" && delete G["border-image"];
          }
          return G;
        },
        serialize: (W, G) => {
          let ue = "";
          const we = (ke, He) => {
            const Ye = He[ke];
            if (Ye)
              for (let We = 0, ut = Ye.length; We < ut; We++) {
                const Ut = Ye[We], an = W[Ut];
                an && (ue += (ue.length > 0 ? " " : "") + Ut + ": " + an + ";");
              }
          }, fe = (ke, He) => {
            if (!S || !He)
              return !0;
            let Ye = S["*"];
            return Ye && Ye[ke] ? !1 : (Ye = S[He], !(Ye && Ye[ke]));
          };
          return G && b ? (we("*", b), we(G, b)) : qt(W, (ke, He) => {
            ke && fe(He, G) && (ue += (ue.length > 0 ? " " : "") + He + ": " + ke + ";");
          }), ue;
        }
      };
      return j;
    }, _v = {
      keyLocation: !0,
      layerX: !0,
      layerY: !0,
      returnValue: !0,
      webkitMovementX: !0,
      webkitMovementY: !0,
      keyIdentifier: !0,
      mozPressure: !0
    }, qr = (e) => e instanceof Event || Ce(e.initEvent), qf = (e) => e.isDefaultPrevented === xt || e.isDefaultPrevented === et, l_ = (e) => Vt(e.preventDefault) || qr(e), Td = (e, n) => {
      const s = n ?? {};
      for (const i in e)
        Xn(_v, i) || (s[i] = e[i]);
      return Ue(e.composedPath) && (s.composedPath = () => e.composedPath()), Ue(e.getModifierState) && (s.getModifierState = (i) => e.getModifierState(i)), Ue(e.getTargetRanges) && (s.getTargetRanges = () => e.getTargetRanges()), s;
    }, iw = (e, n, s, i) => {
      var u;
      const p = Td(n, i);
      return p.type = e, Vt(p.target) && (p.target = (u = p.srcElement) !== null && u !== void 0 ? u : s), l_(n) && (p.preventDefault = () => {
        p.defaultPrevented = !0, p.isDefaultPrevented = xt, Ce(n.preventDefault) && n.preventDefault();
      }, p.stopPropagation = () => {
        p.cancelBubble = !0, p.isPropagationStopped = xt, Ce(n.stopPropagation) && n.stopPropagation();
      }, p.stopImmediatePropagation = () => {
        p.isImmediatePropagationStopped = xt, p.stopPropagation();
      }, qf(p) || (p.isDefaultPrevented = p.defaultPrevented === !0 ? xt : et, p.isPropagationStopped = p.cancelBubble === !0 ? xt : et, p.isImmediatePropagationStopped = et)), p;
    }, Jb = "mce-data-", Ev = /^(?:mouse|contextmenu)|click/, e1 = (e, n, s, i) => {
      e.addEventListener(n, s, i || !1);
    }, Gc = (e, n, s, i) => {
      e.removeEventListener(n, s, i || !1);
    }, c_ = (e) => Ue(e) && Ev.test(e.type), t1 = (e, n) => {
      const s = iw(e.type, e, document, n);
      if (c_(e) && wt(e.pageX) && !wt(e.clientX)) {
        const i = s.target.ownerDocument || document, u = i.documentElement, p = i.body, b = s;
        b.pageX = e.clientX + (u && u.scrollLeft || p && p.scrollLeft || 0) - (u && u.clientLeft || p && p.clientLeft || 0), b.pageY = e.clientY + (u && u.scrollTop || p && p.scrollTop || 0) - (u && u.clientTop || p && p.clientTop || 0);
      }
      return s;
    }, lw = (e, n, s) => {
      const i = e.document, u = { type: "ready" };
      if (s.domLoaded) {
        n(u);
        return;
      }
      const p = () => i.readyState === "complete" || i.readyState === "interactive" && i.body, b = () => {
        Gc(e, "DOMContentLoaded", b), Gc(e, "load", b), s.domLoaded || (s.domLoaded = !0, n(u)), e = null;
      };
      p() ? b() : e1(e, "DOMContentLoaded", b), s.domLoaded || e1(e, "load", b);
    };
    class Vp {
      constructor() {
        this.domLoaded = !1, this.events = {}, this.count = 1, this.expando = Jb + (+/* @__PURE__ */ new Date()).toString(32), this.hasFocusIn = "onfocusin" in document.documentElement, this.count = 1;
      }
      bind(n, s, i, u) {
        const p = this;
        let b;
        const S = window, T = (G) => {
          p.executeHandlers(t1(G || S.event), M);
        };
        if (!n || Gt(n) || ui(n))
          return i;
        let M;
        n[p.expando] ? M = n[p.expando] : (M = p.count++, n[p.expando] = M, p.events[M] = {}), u = u || n;
        const j = s.split(" ");
        let W = j.length;
        for (; W--; ) {
          let G = j[W], ue = T, we = !1, fe = !1;
          if (G === "DOMContentLoaded" && (G = "ready"), p.domLoaded && G === "ready" && n.readyState === "complete") {
            i.call(u, t1({ type: G }));
            continue;
          }
          !p.hasFocusIn && (G === "focusin" || G === "focusout") && (we = !0, fe = G === "focusin" ? "focus" : "blur", ue = (ke) => {
            const He = t1(ke || S.event);
            He.type = He.type === "focus" ? "focusin" : "focusout", p.executeHandlers(He, M);
          }), b = p.events[M][G], b ? G === "ready" && p.domLoaded ? i(t1({ type: G })) : b.push({
            func: i,
            scope: u
          }) : (p.events[M][G] = b = [{
            func: i,
            scope: u
          }], b.fakeName = fe, b.capture = we, b.nativeHandler = ue, G === "ready" ? lw(n, ue, p) : e1(n, fe || G, ue, we));
        }
        return n = b = null, i;
      }
      unbind(n, s, i) {
        if (!n || Gt(n) || ui(n))
          return this;
        const u = n[this.expando];
        if (u) {
          let p = this.events[u];
          if (s) {
            const b = s.split(" ");
            let S = b.length;
            for (; S--; ) {
              const T = b[S], M = p[T];
              if (M) {
                if (i) {
                  let j = M.length;
                  for (; j--; )
                    if (M[j].func === i) {
                      const W = M.nativeHandler, G = M.fakeName, ue = M.capture, we = M.slice(0, j).concat(M.slice(j + 1));
                      we.nativeHandler = W, we.fakeName = G, we.capture = ue, p[T] = we;
                    }
                }
                (!i || M.length === 0) && (delete p[T], Gc(n, M.fakeName || T, M.nativeHandler, M.capture));
              }
            }
          } else
            qt(p, (b, S) => {
              Gc(n, b.fakeName || S, b.nativeHandler, b.capture);
            }), p = {};
          for (const b in p)
            if (Xn(p, b))
              return this;
          delete this.events[u];
          try {
            delete n[this.expando];
          } catch {
            n[this.expando] = null;
          }
        }
        return this;
      }
      fire(n, s, i) {
        return this.dispatch(n, s, i);
      }
      dispatch(n, s, i) {
        if (!n || Gt(n) || ui(n))
          return this;
        const u = t1({
          type: s,
          target: n
        }, i);
        do {
          const p = n[this.expando];
          p && this.executeHandlers(u, p), n = n.parentNode || n.ownerDocument || n.defaultView || n.parentWindow;
        } while (n && !u.isPropagationStopped());
        return this;
      }
      clean(n) {
        if (!n || Gt(n) || ui(n))
          return this;
        if (n[this.expando] && this.unbind(n), n.getElementsByTagName || (n = n.document), n && n.getElementsByTagName) {
          this.unbind(n);
          const s = n.getElementsByTagName("*");
          let i = s.length;
          for (; i--; )
            n = s[i], n[this.expando] && this.unbind(n);
        }
        return this;
      }
      destroy() {
        this.events = {};
      }
      cancel(n) {
        return n && (n.preventDefault(), n.stopImmediatePropagation()), !1;
      }
      executeHandlers(n, s) {
        const i = this.events[s], u = i && i[n.type];
        if (u)
          for (let p = 0, b = u.length; p < b; p++) {
            const S = u[p];
            if (S && S.func.call(S.scope, n) === !1 && n.preventDefault(), n.isImmediatePropagationStopped())
              return;
          }
      }
    }
    Vp.Event = new Vp();
    const cw = Kt.each, u_ = Kt.grep, uw = "data-mce-style", d_ = Kt.makeMap("fill-opacity font-weight line-height opacity orphans widows z-index zoom", " "), Hl = (e, n, s) => {
      Vt(s) || s === "" ? Jr(e, n) : is(e, n, s);
    }, qc = (e) => e.replace(/[A-Z]/g, (n) => "-" + n.toLowerCase()), Jt = (e, n) => {
      let s = 0;
      if (e)
        for (let i = e.nodeType, u = e.previousSibling; u; u = u.previousSibling) {
          const p = u.nodeType;
          n && Gt(u) && (p === i || !u.data.length) || (s++, i = p);
        }
      return s;
    }, ty = (e, n) => {
      const s = Rr(n, "style"), i = e.serialize(e.parse(s), fs(n));
      Hl(n, uw, i);
    }, Xi = (e, n) => Rn(e) ? Xn(d_, n) ? e + "" : e + "px" : e, ny = (e, n, s) => {
      const i = qc(n);
      Vt(s) || s === "" ? kl(e, i) : Ap(e, i, Xi(s, i));
    }, f_ = (e, n, s) => {
      const i = n.keep_values, u = {
        set: (b, S, T) => {
          const M = Me.fromDom(b);
          Ce(n.url_converter) && Ue(S) && (S = n.url_converter.call(n.url_converter_scope || s(), String(S), T, b));
          const j = "data-mce-" + T;
          Hl(M, j, S), Hl(M, T, S);
        },
        get: (b, S) => {
          const T = Me.fromDom(b);
          return Rr(T, "data-mce-" + S) || Rr(T, S);
        }
      }, p = {
        style: {
          set: (b, S) => {
            const T = Me.fromDom(b);
            i && Hl(T, uw, S), Jr(T, "style"), U(S) && Ho(T, e.parse(S));
          },
          get: (b) => {
            const S = Me.fromDom(b), T = Rr(S, uw) || Rr(S, "style");
            return e.serialize(e.parse(T), fs(S));
          }
        }
      };
      return i && (p.href = p.src = u), p;
    }, Kr = (e, n = {}) => {
      const s = {}, i = window, u = {};
      let p = 0;
      const b = !0, S = !0, T = Ja.forElement(Me.fromDom(e), {
        contentCssCors: n.contentCssCors,
        referrerPolicy: n.referrerPolicy
      }), M = [], j = n.schema ? n.schema : Gf({}), W = aw({
        url_converter: n.url_converter,
        url_converter_scope: n.url_converter_scope
      }, n.schema), G = n.ownEvents ? new Vp() : Vp.Event, ue = j.getBlockElements(), we = (mt) => U(mt) ? Xn(ue, mt) : Tn(mt) && (Xn(ue, mt.nodeName) || Uu(j, mt)), fe = (mt) => mt && e && U(mt) ? e.getElementById(mt) : mt, ke = (mt) => {
        const yt = fe(mt);
        return Ue(yt) ? Me.fromDom(yt) : null;
      }, He = (mt, yt, dn = "") => {
        let nn;
        const Eo = ke(mt);
        if (Ue(Eo) && nt(Eo)) {
          const Es = kk[yt];
          Es && Es.get ? nn = Es.get(Eo.dom, yt) : nn = Rr(Eo, yt);
        }
        return Ue(nn) ? nn : dn;
      }, Ye = (mt) => {
        const yt = fe(mt);
        return Vt(yt) ? [] : yt.attributes;
      }, We = (mt, yt, dn) => {
        ro(mt, (nn) => {
          if (Tn(nn)) {
            const Eo = Me.fromDom(nn), Es = dn === "" ? null : dn, pa = Rr(Eo, yt), bm = kk[yt];
            bm && bm.set ? bm.set(Eo.dom, Es, yt) : Hl(Eo, yt, Es), pa !== Es && n.onSetAttrib && n.onSetAttrib({
              attrElm: Eo.dom,
              attrName: yt,
              attrValue: Es
            });
          }
        });
      }, ut = (mt, yt) => mt.cloneNode(yt), Ut = () => n.root_element || e.body, an = (mt) => {
        const yt = Hr(mt);
        return {
          x: yt.x,
          y: yt.y,
          w: yt.width,
          h: yt.height
        };
      }, Nn = (mt, yt) => di(e.body, fe(mt), yt), Et = (mt, yt, dn) => {
        ro(mt, (nn) => {
          const Eo = Me.fromDom(nn);
          ny(Eo, yt, dn), n.update_styles && ty(W, Eo);
        });
      }, bt = (mt, yt) => {
        ro(mt, (dn) => {
          const nn = Me.fromDom(dn);
          qt(yt, (Eo, Es) => {
            ny(nn, Es, Eo);
          }), n.update_styles && ty(W, nn);
        });
      }, Ht = (mt, yt, dn) => {
        const nn = fe(mt);
        if (!(Vt(nn) || !Ec(nn) && !Wb(nn)))
          return dn ? da(Me.fromDom(nn), qc(yt)) : (yt = yt.replace(/-(\D)/g, (Eo, Es) => Es.toUpperCase()), yt === "float" && (yt = "cssFloat"), nn.style ? nn.style[yt] : void 0);
      }, zn = (mt) => {
        const yt = fe(mt);
        if (!yt)
          return {
            w: 0,
            h: 0
          };
        let dn = Ht(yt, "width"), nn = Ht(yt, "height");
        return (!dn || dn.indexOf("px") === -1) && (dn = "0"), (!nn || nn.indexOf("px") === -1) && (nn = "0"), {
          w: parseInt(dn, 10) || yt.offsetWidth || yt.clientWidth,
          h: parseInt(nn, 10) || yt.offsetHeight || yt.clientHeight
        };
      }, uo = (mt) => {
        const yt = fe(mt), dn = Nn(yt), nn = zn(yt);
        return {
          x: dn.x,
          y: dn.y,
          w: nn.w,
          h: nn.h
        };
      }, Go = (mt, yt) => {
        if (!mt)
          return !1;
        const dn = rt(mt) ? mt : [mt];
        return Vn(dn, (nn) => wl(Me.fromDom(nn), yt));
      }, ys = (mt, yt, dn, nn) => {
        const Eo = [];
        let Es = fe(mt);
        nn = nn === void 0;
        const pa = dn || (Ut().nodeName !== "BODY" ? Ut().parentNode : null);
        if (U(yt))
          if (yt === "*")
            yt = Tn;
          else {
            const bm = yt;
            yt = (J3) => Go(J3, bm);
          }
        for (; Es && !(Es === pa || Vt(Es.nodeType) || Pp(Es) || Qa(Es)); ) {
          if (!yt || yt(Es))
            if (nn)
              Eo.push(Es);
            else
              return [Es];
          Es = Es.parentNode;
        }
        return nn ? Eo : null;
      }, Js = (mt, yt, dn) => {
        const nn = ys(mt, yt, dn, !1);
        return nn && nn.length > 0 ? nn[0] : null;
      }, xr = (mt, yt, dn) => {
        let nn = yt;
        if (mt) {
          U(yt) && (nn = (Eo) => Go(Eo, yt));
          for (let Eo = mt[dn]; Eo; Eo = Eo[dn])
            if (Ce(nn) && nn(Eo))
              return Eo;
        }
        return null;
      }, Da = (mt, yt) => xr(mt, yt, "nextSibling"), yl = (mt, yt) => xr(mt, yt, "previousSibling"), mr = (mt) => Ce(mt.querySelectorAll), mn = (mt, yt) => {
        var dn, nn;
        const Eo = (nn = (dn = fe(yt)) !== null && dn !== void 0 ? dn : n.root_element) !== null && nn !== void 0 ? nn : e;
        return mr(Eo) ? Ss(Eo.querySelectorAll(mt)) : [];
      }, ro = function(mt, yt, dn) {
        const nn = dn ?? this;
        if (rt(mt)) {
          const Eo = [];
          return cw(mt, (Es, pa) => {
            const bm = fe(Es);
            bm && Eo.push(yt.call(nn, bm, pa));
          }), Eo;
        } else {
          const Eo = fe(mt);
          return Eo ? yt.call(nn, Eo) : !1;
        }
      }, Hs = (mt, yt) => {
        ro(mt, (dn) => {
          qt(yt, (nn, Eo) => {
            We(dn, Eo, nn);
          });
        });
      }, Sn = (mt, yt) => {
        ro(mt, (dn) => {
          const nn = Me.fromDom(dn);
          yd(nn, yt);
        });
      }, bo = (mt, yt, dn, nn, Eo) => ro(mt, (Es) => {
        const pa = U(yt) ? e.createElement(yt) : yt;
        return Ue(dn) && Hs(pa, dn), nn && (!U(nn) && nn.nodeType ? pa.appendChild(nn) : U(nn) && Sn(pa, nn)), Eo ? pa : Es.appendChild(pa);
      }), cs = (mt, yt, dn) => bo(e.createElement(mt), mt, yt, dn, !0), On = rf.decode, us = rf.encodeAllRaw, ws = (mt, yt, dn = "") => {
        let nn = "<" + mt;
        for (const Eo in yt)
          wr(yt, Eo) && (nn += " " + Eo + '="' + us(yt[Eo]) + '"');
        return Zo(dn) && Xn(j.getVoidElements(), mt) ? nn + " />" : nn + ">" + dn + "</" + mt + ">";
      }, Vi = (mt) => {
        const yt = e.createElement("div"), dn = e.createDocumentFragment();
        dn.appendChild(yt), mt && (yt.innerHTML = mt);
        let nn;
        for (; nn = yt.firstChild; )
          dn.appendChild(nn);
        return dn.removeChild(yt), dn;
      }, ar = (mt, yt) => ro(mt, (dn) => {
        const nn = Me.fromDom(dn);
        return yt && je(Ya(nn), (Eo) => {
          ft(Eo) && Eo.dom.length === 0 ? vr(Eo) : Ki(nn, Eo);
        }), vr(nn), nn.dom;
      }), hi = (mt) => ro(mt, (yt) => {
        const dn = yt.attributes;
        for (let nn = dn.length - 1; nn >= 0; nn--)
          yt.removeAttributeNode(dn.item(nn));
      }), Bd = (mt) => W.parse(mt), vm = (mt, yt) => W.serialize(mt, yt), gc = (mt) => {
        if (Of !== Kr.DOM && e === document) {
          if (s[mt])
            return;
          s[mt] = !0;
        }
        let yt = e.getElementById("mceDefaultStyles");
        if (!yt) {
          yt = e.createElement("style"), yt.id = "mceDefaultStyles", yt.type = "text/css";
          const dn = e.head;
          dn.firstChild ? dn.insertBefore(yt, dn.firstChild) : dn.appendChild(yt);
        }
        yt.styleSheet ? yt.styleSheet.cssText += mt : yt.appendChild(e.createTextNode(mt));
      }, Au = (mt) => {
        mt || (mt = ""), je(mt.split(","), (yt) => {
          u[yt] = !0, T.load(yt).catch(ot);
        });
      }, rd = (mt, yt, dn) => {
        ro(mt, (nn) => {
          if (Tn(nn)) {
            const Eo = Me.fromDom(nn), Es = yt.split(" ");
            je(Es, (pa) => {
              Ue(dn) ? (dn ? gd : fu)(Eo, pa) : Vh(Eo, pa);
            });
          }
        });
      }, Ou = (mt, yt) => {
        rd(mt, yt, !0);
      }, Ld = (mt, yt) => {
        rd(mt, yt, !1);
      }, fo = (mt, yt) => {
        const dn = ke(mt), nn = yt.split(" ");
        return Ue(dn) && Qo(nn, (Eo) => Bf(dn, Eo));
      }, Ps = (mt) => {
        ro(mt, (yt) => kl(Me.fromDom(yt), "display"));
      }, ya = (mt) => {
        ro(mt, (yt) => Ap(Me.fromDom(yt), "display", "none"));
      }, Ra = (mt) => {
        const yt = ke(mt);
        return Ue(yt) && lr(Sl(yt, "display"), "none");
      }, si = (mt) => (mt || "mce_") + p++, sl = (mt) => {
        const yt = ke(mt);
        return Ue(yt) ? Tn(yt.dom) ? yt.dom.outerHTML : nc(yt) : "";
      }, ja = (mt, yt) => {
        ro(mt, (dn) => {
          Tn(dn) && (dn.outerHTML = yt);
        });
      }, Fa = (mt, yt) => {
        const dn = fe(yt);
        return ro(mt, (nn) => {
          const Eo = dn == null ? void 0 : dn.parentNode, Es = dn == null ? void 0 : dn.nextSibling;
          return Eo && (Es ? Eo.insertBefore(nn, Es) : Eo.appendChild(nn)), nn;
        });
      }, Gl = (mt, yt, dn) => ro(yt, (nn) => {
        var Eo;
        const Es = rt(yt) ? mt.cloneNode(!0) : mt;
        return dn && cw(u_(nn.childNodes), (pa) => {
          Es.appendChild(pa);
        }), (Eo = nn.parentNode) === null || Eo === void 0 || Eo.replaceChild(Es, nn), nn;
      }), ad = (mt, yt) => {
        if (mt.nodeName !== yt.toUpperCase()) {
          const dn = cs(yt);
          return cw(Ye(mt), (nn) => {
            We(dn, nn.nodeName, He(mt, nn.nodeName));
          }), Gl(dn, mt, !0), dn;
        } else
          return mt;
      }, Tf = (mt, yt) => {
        let dn = mt;
        for (; dn; ) {
          let nn = yt;
          for (; nn && dn !== nn; )
            nn = nn.parentNode;
          if (dn === nn)
            break;
          dn = dn.parentNode;
        }
        return !dn && mt.ownerDocument ? mt.ownerDocument.documentElement : dn;
      }, Af = (mt, yt, dn) => Ze(yt) ? Vu(j, mt, {
        ...dn,
        isContent: (Eo) => {
          const Es = Eo.nodeName.toLowerCase();
          return !!yt[Es];
        }
      }) : Vu(j, mt, dn), $d = () => e.createRange(), Eh = (mt, yt, dn) => {
        let nn = $d(), Eo, Es;
        if (mt && yt && mt.parentNode && yt.parentNode) {
          const pa = mt.parentNode;
          return nn.setStart(pa, Jt(mt)), nn.setEnd(yt.parentNode, Jt(yt)), Eo = nn.extractContents(), nn = $d(), nn.setStart(yt.parentNode, Jt(yt) + 1), nn.setEnd(pa, Jt(mt) + 1), Es = nn.extractContents(), pa.insertBefore(Wf(Of, Eo, j), mt), dn ? pa.insertBefore(dn, mt) : pa.insertBefore(yt, mt), pa.insertBefore(Wf(Of, Es, j), mt), ar(mt), dn || yt;
        } else
          return;
      }, _0 = (mt, yt, dn, nn) => {
        if (rt(mt)) {
          let Eo = mt.length;
          const Es = [];
          for (; Eo--; )
            Es[Eo] = _0(mt[Eo], yt, dn, nn);
          return Es;
        } else
          return n.collect && (mt === e || mt === i) && M.push([
            mt,
            yt,
            dn,
            nn
          ]), G.bind(mt, yt, dn, nn || Of);
      }, E0 = (mt, yt, dn) => {
        if (rt(mt)) {
          let nn = mt.length;
          const Eo = [];
          for (; nn--; )
            Eo[nn] = E0(mt[nn], yt, dn);
          return Eo;
        } else {
          if (M.length > 0 && (mt === e || mt === i)) {
            let nn = M.length;
            for (; nn--; ) {
              const [Eo, Es, pa] = M[nn];
              mt === Eo && (!yt || yt === Es) && (!dn || dn === pa) && G.unbind(Eo, Es, pa);
            }
          }
          return G.unbind(mt, yt, dn);
        }
      }, v5 = (mt, yt, dn) => G.dispatch(mt, yt, dn), Th = (mt, yt, dn) => G.dispatch(mt, yt, dn), X3 = (mt) => {
        if (mt && Ec(mt)) {
          const yt = mt.getAttribute("data-mce-contenteditable");
          return yt && yt !== "inherit" ? yt : mt.contentEditable !== "inherit" ? mt.contentEditable : null;
        } else
          return null;
      }, Of = {
        doc: e,
        settings: n,
        win: i,
        files: u,
        stdMode: b,
        boxModel: S,
        styleSheetLoader: T,
        boundEvents: M,
        styles: W,
        schema: j,
        events: G,
        isBlock: we,
        root: null,
        clone: ut,
        getRoot: Ut,
        getViewPort: an,
        getRect: uo,
        getSize: zn,
        getParent: Js,
        getParents: ys,
        get: fe,
        getNext: Da,
        getPrev: yl,
        select: mn,
        is: Go,
        add: bo,
        create: cs,
        createHTML: ws,
        createFragment: Vi,
        remove: ar,
        setStyle: Et,
        getStyle: Ht,
        setStyles: bt,
        removeAllAttribs: hi,
        setAttrib: We,
        setAttribs: Hs,
        getAttrib: He,
        getPos: Nn,
        parseStyle: Bd,
        serializeStyle: vm,
        addStyle: gc,
        loadCSS: Au,
        addClass: Ou,
        removeClass: Ld,
        hasClass: fo,
        toggleClass: rd,
        show: Ps,
        hide: ya,
        isHidden: Ra,
        uniqueId: si,
        setHTML: Sn,
        getOuterHTML: sl,
        setOuterHTML: ja,
        decode: On,
        encode: us,
        insertAfter: Fa,
        replace: Gl,
        rename: ad,
        findCommonAncestor: Tf,
        run: ro,
        getAttribs: Ye,
        isEmpty: Af,
        createRng: $d,
        nodeIndex: Jt,
        split: Eh,
        bind: _0,
        unbind: E0,
        fire: Th,
        dispatch: v5,
        getContentEditable: X3,
        getContentEditableParent: (mt) => {
          const yt = Ut();
          let dn = null;
          for (let nn = mt; nn && nn !== yt && (dn = X3(nn), dn === null); nn = nn.parentNode)
            ;
          return dn;
        },
        isEditable: (mt) => {
          if (Ue(mt)) {
            const yt = Tn(mt) ? mt : mt.parentElement;
            return Ue(yt) && Ec(yt) && za(Me.fromDom(yt));
          } else
            return !1;
        },
        destroy: () => {
          if (M.length > 0) {
            let mt = M.length;
            for (; mt--; ) {
              const [yt, dn, nn] = M[mt];
              G.unbind(yt, dn, nn);
            }
          }
          qt(u, (mt, yt) => {
            T.unload(yt), delete u[yt];
          });
        },
        isChildOf: (mt, yt) => mt === yt || yt.contains(mt),
        dumpRng: (mt) => "startContainer: " + mt.startContainer.nodeName + ", startOffset: " + mt.startOffset + ", endContainer: " + mt.endContainer.nodeName + ", endOffset: " + mt.endOffset
      }, kk = f_(W, n, ze(Of));
      return Of;
    };
    Kr.DOM = Kr(document), Kr.nodeIndex = Jt;
    const Lm = Kr.DOM, oy = 0, cO = 1, $m = 2, sy = 3;
    class cf {
      constructor(n = {}) {
        this.states = {}, this.queue = [], this.scriptLoadedCallbacks = {}, this.queueLoadedCallbacks = [], this.loading = !1, this.settings = n;
      }
      _setReferrerPolicy(n) {
        this.settings.referrerPolicy = n;
      }
      loadScript(n) {
        return new Promise((s, i) => {
          const u = Lm;
          let p;
          const b = () => {
            u.remove(M), p && (p.onerror = p.onload = p = null);
          }, S = () => {
            b(), s();
          }, T = () => {
            b(), i("Failed to load script: " + n);
          }, M = u.uniqueId();
          p = document.createElement("script"), p.id = M, p.type = "text/javascript", p.src = Kt._addCacheSuffix(n), this.settings.referrerPolicy && u.setAttrib(p, "referrerpolicy", this.settings.referrerPolicy), p.onload = S, p.onerror = T, (document.getElementsByTagName("head")[0] || document.body).appendChild(p);
        });
      }
      isDone(n) {
        return this.states[n] === $m;
      }
      markDone(n) {
        this.states[n] = $m;
      }
      add(n) {
        const s = this;
        return s.queue.push(n), s.states[n] === void 0 && (s.states[n] = oy), new Promise((u, p) => {
          s.scriptLoadedCallbacks[n] || (s.scriptLoadedCallbacks[n] = []), s.scriptLoadedCallbacks[n].push({
            resolve: u,
            reject: p
          });
        });
      }
      load(n) {
        return this.add(n);
      }
      remove(n) {
        delete this.states[n], delete this.scriptLoadedCallbacks[n];
      }
      loadQueue() {
        const n = this.queue;
        return this.queue = [], this.loadScripts(n);
      }
      loadScripts(n) {
        const s = this, i = (T, M) => {
          _s(s.scriptLoadedCallbacks, M).each((j) => {
            je(j, (W) => W[T](M));
          }), delete s.scriptLoadedCallbacks[M];
        }, u = (T) => {
          const M = on(T, (j) => j.status === "rejected");
          return M.length > 0 ? Promise.reject(rs(M, ({ reason: j }) => rt(j) ? j : [j])) : Promise.resolve();
        }, p = (T) => Promise.allSettled(tn(T, (M) => s.states[M] === $m ? (i("resolve", M), Promise.resolve()) : s.states[M] === sy ? (i("reject", M), Promise.reject(M)) : (s.states[M] = cO, s.loadScript(M).then(() => {
          s.states[M] = $m, i("resolve", M);
          const j = s.queue;
          return j.length > 0 ? (s.queue = [], p(j).then(u)) : Promise.resolve();
        }, () => (s.states[M] = sy, i("reject", M), Promise.reject(M)))))), b = (T) => (s.loading = !0, p(T).then((M) => {
          s.loading = !1;
          const j = s.queueLoadedCallbacks.shift();
          return X.from(j).each(Cn), u(M);
        })), S = ht(n);
        return s.loading ? new Promise((T, M) => {
          s.queueLoadedCallbacks.push(() => {
            b(S).then(T, M);
          });
        }) : b(S);
      }
    }
    cf.ScriptLoader = new cf();
    const m_ = (e, n) => {
      const s = e.indexOf(n);
      return s !== -1 && e.indexOf(n, s + 1) > s;
    }, dw = (e) => ve(e) && Xn(e, "raw"), Vr = (e) => rt(e) && e.length > 1, Tv = {}, ba = Xe("en"), p_ = () => _s(Tv, ba.get()), Fi = {
      getData: () => Ko(Tv, (e) => ({ ...e })),
      setCode: (e) => {
        e && ba.set(e);
      },
      getCode: () => ba.get(),
      add: (e, n) => {
        let s = Tv[e];
        s || (Tv[e] = s = {});
        const i = tn(Ms(n), (u) => u.toLowerCase());
        qt(n, (u, p) => {
          const b = p.toLowerCase();
          b !== p && m_(i, b) ? (Xn(n, b) || (s[b] = u), s[p] = u) : s[b] = u;
        });
      },
      translate: (e) => {
        const n = p_().getOr({}), s = (b) => Ce(b) ? Object.prototype.toString.call(b) : i(b) ? "" : "" + b, i = (b) => b === "" || b === null || b === void 0, u = (b) => {
          const S = s(b);
          return Xn(n, S) ? s(n[S]) : _s(n, S.toLowerCase()).map(s).getOr(S);
        }, p = (b) => b.replace(/{context:\w+}$/, "");
        if (i(e))
          return "";
        if (dw(e))
          return s(e.raw);
        if (Vr(e)) {
          const b = e.slice(1), S = u(e[0]).replace(/\{([0-9]+)\}/g, (T, M) => Xn(b, M) ? s(b[M]) : T);
          return p(S);
        }
        return p(u(e));
      },
      isRtl: () => p_().bind((e) => _s(e, "_dir")).exists((e) => e === "rtl"),
      hasCode: (e) => Xn(Tv, e)
    }, ac = () => {
      const e = [], n = {}, s = {}, i = [], u = (fe, ke) => {
        const He = on(i, (Ye) => Ye.name === fe && Ye.state === ke);
        je(He, (Ye) => Ye.resolve());
      }, p = (fe) => Xn(n, fe), b = (fe) => Xn(s, fe), S = (fe) => {
        if (s[fe])
          return s[fe].instance;
      }, T = (fe, ke) => {
        const He = Fi.getCode(), Ye = "," + (ke || "") + ",";
        !He || ke && Ye.indexOf("," + He + ",") === -1 || cf.ScriptLoader.add(n[fe] + "/langs/" + He + ".js");
      }, M = (fe, ke) => {
        ac.languageLoad !== !1 && (p(fe) ? T(fe, ke) : we(fe, "loaded").then(() => T(fe, ke)));
      }, j = (fe, ke) => (e.push(ke), s[fe] = { instance: ke }, u(fe, "added"), ke), W = (fe) => {
        delete n[fe], delete s[fe];
      }, G = (fe, ke) => U(ke) ? U(fe) ? {
        prefix: "",
        resource: ke,
        suffix: ""
      } : {
        prefix: fe.prefix,
        resource: ke,
        suffix: fe.suffix
      } : ke, ue = (fe, ke) => {
        if (n[fe])
          return Promise.resolve();
        let He = U(ke) ? ke : ke.prefix + ke.resource + ke.suffix;
        He.indexOf("/") !== 0 && He.indexOf("://") === -1 && (He = ac.baseURL + "/" + He), n[fe] = He.substring(0, He.lastIndexOf("/"));
        const Ye = () => (u(fe, "loaded"), Promise.resolve());
        return s[fe] ? Ye() : cf.ScriptLoader.add(He).then(Ye);
      }, we = (fe, ke = "added") => ke === "added" && b(fe) || ke === "loaded" && p(fe) ? Promise.resolve() : new Promise((He) => {
        i.push({
          name: fe,
          state: ke,
          resolve: He
        });
      });
      return {
        items: e,
        urls: n,
        lookup: s,
        get: S,
        requireLangPack: M,
        add: j,
        remove: W,
        createUrl: G,
        load: ue,
        waitFor: we
      };
    };
    ac.languageLoad = !0, ac.baseURL = "", ac.PluginManager = ac(), ac.ThemeManager = ac(), ac.ModelManager = ac();
    const n1 = (e, n) => {
      let s = null;
      return {
        cancel: () => {
          ee(s) || (clearTimeout(s), s = null);
        },
        throttle: (...p) => {
          ee(s) && (s = setTimeout(() => {
            s = null, e.apply(null, p);
          }, n));
        }
      };
    }, Up = (e, n) => {
      let s = null;
      const i = () => {
        ee(s) || (clearTimeout(s), s = null);
      };
      return {
        cancel: i,
        throttle: (...p) => {
          i(), s = setTimeout(() => {
            s = null, e.apply(null, p);
          }, n);
        }
      };
    }, fw = (e, n, s) => Na(e, n, s).isSome(), Ov = ze("mce-annotation"), Kf = ze("data-mce-annotation"), Dv = ze("data-mce-annotation-uid"), ig = ze("data-mce-annotation-active"), jp = ze("data-mce-annotation-classes"), Yf = ze("data-mce-annotation-attrs"), lg = (e) => (n) => Bs(n, e), cg = (e, n) => {
      const s = e.selection.getRng(), i = Me.fromDom(s.startContainer), u = Me.fromDom(e.getBody()), p = n.fold(() => "." + Ov(), (T) => `[${Kf()}="${T}"]`), b = vd(i, s.startOffset).getOr(i);
      return mu(b, p, lg(u)).bind((T) => ua(T, `${Dv()}`).bind((M) => ua(T, `${Kf()}`).map((j) => {
        const W = ry(e, M);
        return {
          uid: M,
          name: j,
          elements: W
        };
      })));
    }, pO = (e) => nt(e) && Bf(e, Ov()), mw = (e, n) => oa(e, "data-mce-bogus") || fw(e, '[data-mce-bogus="all"]', lg(n)), ry = (e, n) => {
      const s = Me.fromDom(e.getBody()), i = va(s, `[${Dv()}="${n}"]`);
      return on(i, (u) => !mw(u, s));
    }, h_ = (e, n) => {
      const s = Me.fromDom(e.getBody()), i = va(s, `[${Kf()}="${n}"]`), u = {};
      return je(i, (p) => {
        if (!mw(p, s)) {
          const b = Rr(p, Dv()), S = _s(u, b).getOr([]);
          u[b] = S.concat([p]);
        }
      }), u;
    }, pw = (e, n) => {
      const s = Xe({}), i = () => ({
        listeners: [],
        previous: Ii()
      }), u = (W, G) => {
        p(W, (ue) => (G(ue), ue));
      }, p = (W, G) => {
        const ue = s.get(), we = _s(ue, W).getOrThunk(i), fe = G(we);
        ue[W] = fe, s.set(ue);
      }, b = (W, G, ue) => {
        u(W, (we) => {
          je(we.listeners, (fe) => fe(!0, W, {
            uid: G,
            nodes: tn(ue, (ke) => ke.dom)
          }));
        });
      }, S = (W) => {
        u(W, (G) => {
          je(G.listeners, (ue) => ue(!1, W));
        });
      }, T = (W, G) => {
        je(ry(e, W), (ue) => {
          G ? is(ue, ig(), "true") : Jr(ue, ig());
        });
      }, M = Up(() => {
        const W = kt(n.getNames());
        je(W, (G) => {
          p(G, (ue) => {
            const we = ue.previous.get();
            return cg(e, X.some(G)).fold(() => {
              we.each((fe) => {
                S(G), ue.previous.clear(), T(fe, !1);
              });
            }, ({ uid: fe, name: ke, elements: He }) => {
              lr(we, fe) || (we.each((Ye) => T(Ye, !1)), b(ke, fe, He), ue.previous.set(fe), T(fe, !0));
            }), {
              previous: ue.previous,
              listeners: ue.listeners
            };
          });
        });
      }, 30);
      return e.on("remove", () => {
        M.cancel();
      }), e.on("NodeChange", () => {
        M.throttle();
      }), { addListener: (W, G) => {
        p(W, (ue) => ({
          previous: ue.previous,
          listeners: ue.listeners.concat([G])
        }));
      } };
    }, ay = (e, n) => {
      const s = Kf(), i = (p) => X.from(p.attr(s)).bind(n.lookup), u = (p) => {
        var b, S;
        p.attr(Dv(), null), p.attr(Kf(), null), p.attr(ig(), null);
        const T = X.from(p.attr(Yf())).map((G) => G.split(",")).getOr([]), M = X.from(p.attr(jp())).map((G) => G.split(",")).getOr([]);
        je(T, (G) => p.attr(G, null));
        const j = (S = (b = p.attr("class")) === null || b === void 0 ? void 0 : b.split(" ")) !== null && S !== void 0 ? S : [], W = zs(j, [Ov()].concat(M));
        p.attr("class", W.length > 0 ? W.join(" ") : null), p.attr(jp(), null), p.attr(Yf(), null);
      };
      e.serializer.addTempAttr(ig()), e.serializer.addAttributeFilter(s, (p) => {
        for (const b of p)
          i(b).each((S) => {
            S.persistent === !1 && (b.name === "span" ? b.unwrap() : u(b));
          });
      });
    }, hw = () => {
      const e = {};
      return {
        register: (u, p) => {
          e[u] = {
            name: u,
            settings: p
          };
        },
        lookup: (u) => _s(e, u).map((p) => p.settings),
        getNames: () => Ms(e)
      };
    };
    let iy = 0;
    const Rv = (e) => {
      const s = (/* @__PURE__ */ new Date()).getTime(), i = Math.floor(Math.random() * 1e9);
      return iy++, e + "_" + i + iy + String(s);
    }, ly = (e, n) => {
      je(n, (s) => {
        gd(e, s);
      });
    }, jI = (e, n) => {
      je(n, (s) => {
        fu(e, s);
      });
    }, hO = (e, n) => Me.fromDom(e.dom.cloneNode(n)), uf = (e) => hO(e, !1), Nv = (e) => hO(e, !0), g_ = (e, n) => {
      const s = Me.fromTag(n), i = Sc(e);
      return _a(s, i), s;
    }, v_ = (e, n) => {
      const s = g_(e, n);
      tc(e, s);
      const i = Ya(e);
      return bd(s, i), vr(e), s;
    }, cy = (e, n, s = et) => {
      const i = new Pi(e, n), u = (p) => {
        let b;
        do
          b = i[p]();
        while (b && !Gt(b) && !s(b));
        return X.from(b).filter(Gt);
      };
      return {
        current: () => X.from(i.current()).filter(Gt),
        next: () => u("next"),
        prev: () => u("prev"),
        prev2: () => u("prev2")
      };
    }, Wp = (e, n) => {
      const s = n || ((b) => e.isBlock(b) || Vs(b) || Ls(b)), i = (b, S, T, M) => {
        if (Gt(b)) {
          const j = M(b, S, b.data);
          if (j !== -1)
            return X.some({
              container: b,
              offset: j
            });
        }
        return T().bind((j) => i(j.container, j.offset, T, M));
      };
      return {
        backwards: (b, S, T, M) => {
          const j = cy(b, M ?? e.getRoot(), s);
          return i(b, S, () => j.prev().map((W) => ({
            container: W,
            offset: W.length
          })), T).getOrNull();
        },
        forwards: (b, S, T, M) => {
          const j = cy(b, M ?? e.getRoot(), s);
          return i(b, S, () => j.next().map((W) => ({
            container: W,
            offset: 0
          })), T).getOrNull();
        }
      };
    }, gw = ((e, n) => {
      const s = (p) => {
        if (!e(p))
          throw new Error("Can only get " + n + " value of a " + n + " node");
        return i(p).getOr("");
      }, i = (p) => e(p) ? X.from(p.dom.nodeValue) : X.none();
      return {
        get: s,
        getOption: i,
        set: (p, b) => {
          if (!e(p))
            throw new Error("Can only set raw " + n + " value of a " + n + " node");
          p.dom.nodeValue = b;
        }
      };
    })(ft, "text"), o1 = (e) => gw.get(e), vO = (e) => gw.getOption(e), uy = (e, n) => gw.set(e, n), Pv = [
      "td",
      "th"
    ], b_ = [
      "thead",
      "tbody",
      "tfoot"
    ], dy = [
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "p",
      "div",
      "address",
      "pre",
      "form",
      "blockquote",
      "center",
      "dir",
      "fieldset",
      "header",
      "footer",
      "article",
      "section",
      "hgroup",
      "aside",
      "nav",
      "figure"
    ], vw = [
      "li",
      "dd",
      "dt"
    ], y_ = [
      "ul",
      "ol",
      "dl"
    ], Al = [
      "pre",
      "script",
      "textarea",
      "style"
    ], s1 = (e) => {
      let n;
      return (s) => (n = n || it(e, xt), Xn(n, fs(s)));
    }, bw = (e) => fs(e) === "table", Mv = (e) => nt(e) && fs(e) === "br", x_ = s1(dy), df = s1(y_), Dc = s1(vw), Iv = s1(b_), Fv = s1(Pv), r1 = s1(Al), bO = (e) => {
      const n = [];
      let s = e.dom;
      for (; s; )
        n.push(Me.fromDom(s)), s = s.lastChild;
      return n;
    }, yO = (e) => {
      const n = va(e, "br"), s = on(bO(e).slice(-1), Mv);
      n.length === s.length && je(s, vr);
    }, ug = () => {
      const e = Me.fromTag("br");
      return is(e, "data-mce-bogus", "1"), e;
    }, Xc = (e) => {
      Vc(e), Zr(e, ug());
    }, w_ = (e, n) => {
      _c(e).each((s) => {
        Jl(s).each((i) => {
          n.isBlock(fs(e)) && Mv(s) && n.isBlock(fs(i)) && vr(s);
        });
      });
    }, Ma = vv, dg = Ub, Qc = Mi, WI = (e) => e.insertContent(Ma, { preserve_zwsp: !0 }), fy = Tn, Bv = Gt, fg = (e) => (Bv(e) && (e = e.parentNode), fy(e) && e.hasAttribute("data-mce-caret")), ff = (e) => Bv(e) && dg(e.data), Jc = (e) => fg(e) || ff(e), yw = (e) => e.firstChild !== e.lastChild || !Vs(e.firstChild), xw = (e, n) => {
      var s;
      const u = ((s = e.ownerDocument) !== null && s !== void 0 ? s : document).createTextNode(Ma), p = e.parentNode;
      if (n) {
        const b = e.previousSibling;
        if (Bv(b)) {
          if (Jc(b))
            return b;
          if (Xf(b))
            return b.splitText(b.data.length - 1);
        }
        p == null || p.insertBefore(u, e);
      } else {
        const b = e.nextSibling;
        if (Bv(b)) {
          if (Jc(b))
            return b;
          if (pg(b))
            return b.splitText(1), b;
        }
        e.nextSibling ? p == null || p.insertBefore(u, e.nextSibling) : p == null || p.appendChild(u);
      }
      return u;
    }, ww = (e) => {
      const n = e.container();
      return Gt(n) ? n.data.charAt(e.offset()) === Ma || e.isAtStart() && ff(n.previousSibling) : !1;
    }, mg = (e) => {
      const n = e.container();
      return Gt(n) ? n.data.charAt(e.offset() - 1) === Ma || e.isAtEnd() && ff(n.nextSibling) : !1;
    }, xO = (e, n, s) => {
      var i;
      const p = ((i = n.ownerDocument) !== null && i !== void 0 ? i : document).createElement(e);
      p.setAttribute("data-mce-caret", s ? "before" : "after"), p.setAttribute("data-mce-bogus", "all"), p.appendChild(ug().dom);
      const b = n.parentNode;
      return s ? b == null || b.insertBefore(p, n) : n.nextSibling ? b == null || b.insertBefore(p, n.nextSibling) : b == null || b.appendChild(p), p;
    }, pg = (e) => Bv(e) && e.data[0] === Ma, Xf = (e) => Bv(e) && e.data[e.data.length - 1] === Ma, a1 = (e) => {
      var n;
      const s = e.getElementsByTagName("br"), i = s[s.length - 1];
      Mm(i) && ((n = i.parentNode) === null || n === void 0 || n.removeChild(i));
    }, Os = (e) => e && e.hasAttribute("data-mce-caret") ? (a1(e), e.removeAttribute("data-mce-caret"), e.removeAttribute("data-mce-bogus"), e.removeAttribute("style"), e.removeAttribute("data-mce-style"), e.removeAttribute("_moz_abspos"), e) : null, ic = (e) => fg(e.startContainer), Gu = Math.round, Hm = (e) => e ? {
      left: Gu(e.left),
      top: Gu(e.top),
      bottom: Gu(e.bottom),
      right: Gu(e.right),
      width: Gu(e.width),
      height: Gu(e.height)
    } : {
      left: 0,
      top: 0,
      bottom: 0,
      right: 0,
      width: 0,
      height: 0
    }, Ur = (e, n) => (e = Hm(e), n || (e.left = e.left + e.width), e.right = e.left, e.width = 0, e), C_ = (e, n) => e.left === n.left && e.top === n.top && e.bottom === n.bottom && e.right === n.right, my = (e, n, s) => e >= 0 && e <= Math.min(n.height, s.height) / 2, i1 = (e, n) => {
      const s = Math.min(n.height / 2, e.height / 2);
      return e.bottom - s < n.top ? !0 : e.top > n.bottom ? !1 : my(n.top - e.bottom, e, n);
    }, py = (e, n) => e.top > n.bottom ? !0 : e.bottom < n.top ? !1 : my(n.bottom - e.top, e, n), wO = (e, n, s) => n >= e.left && n <= e.right && s >= e.top && s <= e.bottom, ma = (e) => vt(e, (n, s) => n.fold(() => X.some(s), (i) => {
      const u = Math.min(s.left, i.left), p = Math.min(s.top, i.top), b = Math.max(s.right, i.right), S = Math.max(s.bottom, i.bottom);
      return X.some({
        top: p,
        right: b,
        bottom: S,
        left: u,
        width: b - u,
        height: S - p
      });
    }), X.none()), Cw = (e, n, s) => {
      const i = Math.max(Math.min(n, e.left + e.width), e.left), u = Math.max(Math.min(s, e.top + e.height), e.top);
      return Math.sqrt((n - i) * (n - i) + (s - u) * (s - u));
    }, CO = (e, n) => Math.max(0, Math.min(e.bottom, n.bottom) - Math.max(e.top, n.top)), SO = (e, n, s) => Math.min(Math.max(e, n), s), Lv = (e) => {
      const n = e.startContainer, s = e.startOffset;
      return n === e.endContainer && n.hasChildNodes() && e.endOffset === s + 1 ? n.childNodes[s] : null;
    }, Mn = (e, n) => {
      if (Tn(e) && e.hasChildNodes()) {
        const s = e.childNodes, i = SO(n, 0, s.length - 1);
        return s[i];
      } else
        return e;
    }, kO = (e, n) => {
      if (!(n < 0 && Tn(e) && e.hasChildNodes()))
        return Mn(e, n);
    }, S_ = new RegExp("[̀-ͯ҃-҇҈-҉֑-ֽֿׁ-ׂׄ-ׇׅؐ-ًؚ-ٰٟۖ-ۜ۟-ۤۧ-۪ۨ-ܑۭܰ-݊ަ-ް߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣣ-ंऺ़ु-ै्॑-ॗॢ-ॣঁ়াু-ৄ্ৗৢ-ৣਁ-ਂ਼ੁ-ੂੇ-ੈੋ-੍ੑੰ-ੱੵઁ-ં઼ુ-ૅે-ૈ્ૢ-ૣଁ଼ାିୁ-ୄ୍ୖୗୢ-ୣஂாீ்ௗఀా-ీె-ైొ-్ౕ-ౖౢ-ౣಁ಼ಿೂೆೌ-್ೕ-ೖೢ-ೣഁാു-ൄ്ൗൢ-ൣ්ාි-ුූෟัิ-ฺ็-๎ັິ-ູົ-ຼ່-ໍ༘-ཱ༹༙༵༷-ཾྀ-྄྆-྇ྍ-ྗྙ-ྼ࿆ိ-ူဲ-့္-်ွ-ှၘ-ၙၞ-ၠၱ-ၴႂႅ-ႆႍႝ፝-፟ᜒ-᜔ᜲ-᜴ᝒ-ᝓᝲ-ᝳ឴-឵ិ-ួំ៉-៓៝᠋-᠍ᢩᤠ-ᤢᤧ-ᤨᤲ᤹-᤻ᨗ-ᨘᨛᩖᩘ-ᩞ᩠ᩢᩥ-ᩬᩳ-᩿᩼᪰-᪽᪾ᬀ-ᬃ᬴ᬶ-ᬺᬼᭂ᭫-᭳ᮀ-ᮁᮢ-ᮥᮨ-ᮩ᮫-ᮭ᯦ᯨ-ᯩᯭᯯ-ᯱᰬ-ᰳᰶ-᰷᳐-᳔᳒-᳢᳠-᳨᳭᳴᳸-᳹᷀-᷵᷼-᷿‌-‍⃐-⃜⃝-⃠⃡⃢-⃤⃥-⃰⳯-⵿⳱ⷠ-〪ⷿ-〭〮-゙〯-゚꙯꙰-꙲ꙴ-꙽ꚞ-ꚟ꛰-꛱ꠂ꠆ꠋꠥ-ꠦ꣄꣠-꣱ꤦ-꤭ꥇ-ꥑꦀ-ꦂ꦳ꦶ-ꦹꦼꧥꨩ-ꨮꨱ-ꨲꨵ-ꨶꩃꩌꩼꪰꪲ-ꪴꪷ-ꪸꪾ-꪿꫁ꫬ-ꫭ꫶ꯥꯨ꯭ﬞ︀-️︠-︯ﾞ-ﾟ]"), hy = (e) => U(e) && e.charCodeAt(0) >= 768 && S_.test(e), Sw = (...e) => (n) => {
      for (let s = 0; s < e.length; s++)
        if (e[s](n))
          return !0;
      return !1;
    }, _O = (...e) => (n) => {
      for (let s = 0; s < e.length; s++)
        if (!e[s](n))
          return !1;
      return !0;
    }, l1 = Mt, c1 = Ls, hg = Vs, ZI = Gt, Qf = hu([
      "script",
      "style",
      "textarea"
    ]), EO = hu([
      "img",
      "input",
      "textarea",
      "hr",
      "iframe",
      "video",
      "audio",
      "object",
      "embed"
    ]), zm = hu(["table"]), k_ = Jc, mf = (e) => k_(e) ? !1 : ZI(e) ? !Qf(e.parentNode) : EO(e) || hg(e) || zm(e) || $v(e), __ = (e) => Tn(e) && e.getAttribute("unselectable") === "true", $v = (e) => !__(e) && c1(e), TO = (e, n) => {
      for (let s = e.parentNode; s && s !== n; s = s.parentNode) {
        if ($v(s))
          return !1;
        if (l1(s))
          return !0;
      }
      return !0;
    }, AO = (e) => $v(e) ? !vt(Ss(e.getElementsByTagName("*")), (n, s) => n || l1(s), !1) : !1, OO = (e) => EO(e) || AO(e), kw = (e, n) => mf(e) && TO(e, n), gy = Tn, E_ = mf, _w = Qh("display", "block table"), DO = Qh("float", "left right"), u1 = _O(gy, E_, pn(DO)), Zp = pn(Qh("white-space", "pre pre-line pre-wrap")), Hv = Gt, vy = Vs, Ew = Kr.nodeIndex, by = kO, Tw = (e) => e ? e.createRange() : Kr.DOM.createRng(), Aw = (e) => U(e) && /[\r\n\t ]/.test(e), Ow = (e) => !!e.setStart && !!e.setEnd, T_ = (e) => {
      const n = e.startContainer, s = e.startOffset;
      if (Aw(e.toString()) && Zp(n.parentNode) && Gt(n)) {
        const i = n.data;
        if (Aw(i[s - 1]) || Aw(i[s + 1]))
          return !0;
      }
      return !1;
    }, Qi = (e) => {
      const n = e.ownerDocument, s = Tw(n), i = n.createTextNode(Xa), u = e.parentNode;
      u.insertBefore(i, e), s.setStart(i, 0), s.setEnd(i, 1);
      const p = Hm(s.getBoundingClientRect());
      return u.removeChild(i), p;
    }, RO = (e) => {
      const n = e.startContainer, s = e.endContainer, i = e.startOffset, u = e.endOffset;
      if (n === s && Gt(s) && i === 0 && u === 1) {
        const p = e.cloneRange();
        return p.setEndAfter(s), Gp(p);
      } else
        return null;
    }, A_ = (e) => e.left === 0 && e.right === 0 && e.top === 0 && e.bottom === 0, Gp = (e) => {
      var n;
      let s;
      const i = e.getClientRects();
      return i.length > 0 ? s = Hm(i[0]) : s = Hm(e.getBoundingClientRect()), !Ow(e) && vy(e) && A_(s) ? Qi(e) : A_(s) && Ow(e) && (n = RO(e)) !== null && n !== void 0 ? n : s;
    }, gg = (e, n) => {
      const s = Ur(e, n);
      return s.width = 1, s.right = s.left + 1, s;
    }, Dw = (e) => {
      const n = [], s = (b) => {
        b.height !== 0 && (n.length > 0 && C_(b, n[n.length - 1]) || n.push(b));
      }, i = (b, S) => {
        const T = Tw(b.ownerDocument);
        if (S < b.data.length) {
          if (hy(b.data[S]))
            return;
          if (hy(b.data[S - 1]) && (T.setStart(b, S), T.setEnd(b, S + 1), !T_(T))) {
            s(gg(Gp(T), !1));
            return;
          }
        }
        S > 0 && (T.setStart(b, S - 1), T.setEnd(b, S), T_(T) || s(gg(Gp(T), !1))), S < b.data.length && (T.setStart(b, S), T.setEnd(b, S + 1), T_(T) || s(gg(Gp(T), !0)));
      }, u = e.container(), p = e.offset();
      if (Hv(u))
        return i(u, p), n;
      if (gy(u))
        if (e.isAtEnd()) {
          const b = by(u, p);
          Hv(b) && i(b, b.data.length), u1(b) && !vy(b) && s(gg(Gp(b), !1));
        } else {
          const b = by(u, p);
          if (Hv(b) && i(b, 0), u1(b) && e.isAtEnd())
            return s(gg(Gp(b), !1)), n;
          const S = by(e.container(), e.offset() - 1);
          u1(S) && !vy(S) && (_w(S) || _w(b) || !u1(b)) && s(gg(Gp(S), !1)), u1(b) && s(gg(Gp(b), !0));
        }
      return n;
    }, gt = (e, n, s) => {
      const i = () => (Hv(e), n === 0), u = () => Hv(e) ? n >= e.data.length : n >= e.childNodes.length, p = () => {
        const j = Tw(e.ownerDocument);
        return j.setStart(e, n), j.setEnd(e, n), j;
      }, b = () => (s || (s = Dw(gt(e, n))), s), S = () => b().length > 0, T = (j) => j && e === j.container() && n === j.offset(), M = (j) => by(e, j ? n - 1 : n);
      return {
        container: ze(e),
        offset: ze(n),
        toRange: p,
        getClientRects: b,
        isVisible: S,
        isAtStart: i,
        isAtEnd: u,
        isEqual: T,
        getNode: M
      };
    };
    gt.fromRangeStart = (e) => gt(e.startContainer, e.startOffset), gt.fromRangeEnd = (e) => gt(e.endContainer, e.endOffset), gt.after = (e) => gt(e.parentNode, Ew(e) + 1), gt.before = (e) => gt(e.parentNode, Ew(e)), gt.isAbove = (e, n) => ga(hn(n.getClientRects()), Do(e.getClientRects()), i1).getOr(!1), gt.isBelow = (e, n) => ga(Do(n.getClientRects()), hn(e.getClientRects()), py).getOr(!1), gt.isAtStart = (e) => e ? e.isAtStart() : !1, gt.isAtEnd = (e) => e ? e.isAtEnd() : !1, gt.isTextPosition = (e) => e ? Gt(e.container()) : !1, gt.isElementPosition = (e) => !gt.isTextPosition(e);
    const Jf = (e, n) => {
      Gt(n) && n.data.length === 0 && e.remove(n);
    }, NO = (e, n, s) => {
      n.insertNode(s), Jf(e, s.previousSibling), Jf(e, s.nextSibling);
    }, O_ = (e, n, s) => {
      const i = X.from(s.firstChild), u = X.from(s.lastChild);
      n.insertNode(s), i.each((p) => Jf(e, p.previousSibling)), u.each((p) => Jf(e, p.nextSibling));
    }, d1 = (e, n, s) => {
      Qa(s) ? O_(e, n, s) : NO(e, n, s);
    }, qu = Gt, f1 = Mm, D_ = Kr.nodeIndex, Rw = (e) => {
      const n = e.parentNode;
      return f1(n) ? Rw(n) : n;
    }, zl = (e) => e ? Ne(e.childNodes, (n, s) => (f1(s) && s.nodeName !== "BR" ? n = n.concat(zl(s)) : n.push(s), n), []) : [], yy = (e, n) => {
      let s = e;
      for (; (s = s.previousSibling) && qu(s); )
        n += s.data.length;
      return n;
    }, R_ = (e) => (n) => e === n, PO = (e) => {
      let n, s;
      n = zl(Rw(e)), s = Ae(n, R_(e), e), n = n.slice(0, s + 1);
      const i = Ne(n, (u, p, b) => (qu(p) && qu(n[b - 1]) && u++, u), 0);
      return n = Xr(n, hu([e.nodeName])), s = Ae(n, R_(e), e), s - i;
    }, N_ = (e) => (qu(e) ? "text()" : e.nodeName.toLowerCase()) + "[" + PO(e) + "]", MO = (e, n, s) => {
      const i = [];
      for (let u = n.parentNode; u && u !== e; u = u.parentNode)
        i.push(u);
      return i;
    }, P_ = (e, n) => {
      let s = [], i = n.container(), u = n.offset(), p;
      if (qu(i))
        p = yy(i, u);
      else {
        const S = i.childNodes;
        u >= S.length ? (p = "after", u = S.length - 1) : p = "before", i = S[u];
      }
      s.push(N_(i));
      let b = MO(e, i);
      return b = Xr(b, pn(Mm)), s = s.concat(Yr(b, (S) => N_(S))), s.reverse().join("/") + "," + p;
    }, IO = (e, n, s) => {
      let i = zl(e);
      return i = Xr(i, (u, p) => !qu(u) || !qu(i[p - 1])), i = Xr(i, hu([n])), i[s];
    }, FO = (e, n) => {
      let s = e, i = 0;
      for (; qu(s); ) {
        const u = s.data.length;
        if (n >= i && n <= i + u) {
          e = s, n = n - i;
          break;
        }
        if (!qu(s.nextSibling)) {
          e = s, n = u;
          break;
        }
        i += u, s = s.nextSibling;
      }
      return qu(e) && n > e.data.length && (n = e.data.length), gt(e, n);
    }, M_ = (e, n) => {
      if (!n)
        return null;
      const s = n.split(","), i = s[0].split("/"), u = s.length > 1 ? s[1] : "before", p = Ne(i, (b, S) => {
        const T = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(S);
        return T ? (T[1] === "text()" && (T[1] = "#text"), IO(b, T[1], parseInt(T[2], 10))) : null;
      }, e);
      if (!p)
        return null;
      if (!qu(p) && p.parentNode) {
        let b;
        return u === "after" ? b = D_(p) + 1 : b = D_(p), gt(p.parentNode, b);
      }
      return FO(p, parseInt(u, 10));
    }, zv = Ls, BO = (e, n, s) => {
      let i = e(n.data.slice(0, s)).length;
      for (let u = n.previousSibling; u && Gt(u); u = u.previousSibling)
        i += e(u.data).length;
      return i;
    }, I_ = (e, n, s, i, u) => {
      const p = u ? i.startContainer : i.endContainer;
      let b = u ? i.startOffset : i.endOffset;
      const S = [], T = e.getRoot();
      if (Gt(p))
        S.push(s ? BO(n, p, b) : b);
      else {
        let M = 0;
        const j = p.childNodes;
        b >= j.length && j.length && (M = 1, b = Math.max(0, j.length - 1)), S.push(e.nodeIndex(j[b], s) + M);
      }
      for (let M = p; M && M !== T; M = M.parentNode)
        S.push(e.nodeIndex(M, s));
      return S;
    }, Aa = (e, n, s, i) => {
      const u = n.dom, p = I_(u, e, s, i, !0), b = n.isForward(), S = ic(i) ? { isFakeCaret: !0 } : {};
      if (n.isCollapsed())
        return {
          start: p,
          forward: b,
          ...S
        };
      {
        const T = I_(u, e, s, i, !1);
        return {
          start: p,
          end: T,
          forward: b,
          ...S
        };
      }
    }, xy = (e, n, s) => {
      let i = 0;
      return Kt.each(e.select(n), (u) => {
        if (u.getAttribute("data-mce-bogus") !== "all") {
          if (u === s)
            return !1;
          i++;
          return;
        }
      }), i;
    }, F_ = (e, n) => {
      let s = n ? e.startContainer : e.endContainer, i = n ? e.startOffset : e.endOffset;
      if (Tn(s) && s.nodeName === "TR") {
        const u = s.childNodes;
        s = u[Math.min(n ? i : i - 1, u.length - 1)], s && (i = n ? 0 : s.childNodes.length, n ? e.setStart(s, i) : e.setEnd(s, i));
      }
    }, B_ = (e) => (F_(e, !0), F_(e, !1), e), wy = (e, n) => {
      if (Tn(e) && (e = Mn(e, n), zv(e)))
        return e;
      if (Jc(e)) {
        Gt(e) && fg(e) && (e = e.parentNode);
        let s = e.previousSibling;
        if (zv(s) || (s = e.nextSibling, zv(s)))
          return s;
      }
    }, Ol = (e) => wy(e.startContainer, e.startOffset) || wy(e.endContainer, e.endOffset), Vl = (e, n, s) => {
      const i = s.getNode(), u = s.getRng();
      if (i.nodeName === "IMG" || zv(i)) {
        const b = i.nodeName;
        return {
          name: b,
          index: xy(s.dom, b, i)
        };
      }
      const p = Ol(u);
      if (p) {
        const b = p.tagName;
        return {
          name: b,
          index: xy(s.dom, b, p)
        };
      }
      return Aa(e, s, n, u);
    }, L_ = (e) => {
      const n = e.getRng();
      return {
        start: P_(e.dom.getRoot(), gt.fromRangeStart(n)),
        end: P_(e.dom.getRoot(), gt.fromRangeEnd(n)),
        forward: e.isForward()
      };
    }, $_ = (e) => ({
      rng: e.getRng(),
      forward: e.isForward()
    }), Nw = (e, n, s) => {
      const i = {
        "data-mce-type": "bookmark",
        id: n,
        style: "overflow:hidden;line-height:0px"
      };
      return s ? e.create("span", i, "&#xFEFF;") : e.create("span", i);
    }, H_ = (e, n) => {
      const s = e.dom;
      let i = e.getRng();
      const u = s.uniqueId(), p = e.isCollapsed(), b = e.getNode(), S = b.nodeName, T = e.isForward();
      if (S === "IMG")
        return {
          name: S,
          index: xy(s, S, b)
        };
      const M = B_(i.cloneRange());
      if (!p) {
        M.collapse(!1);
        const W = Nw(s, u + "_end", n);
        d1(s, M, W);
      }
      i = B_(i), i.collapse(!0);
      const j = Nw(s, u + "_start", n);
      return d1(s, i, j), e.moveToBookmark({
        id: u,
        keep: !0,
        forward: T
      }), {
        id: u,
        forward: T
      };
    }, z_ = (e, n, s = !1) => n === 2 ? Vl(Qc, s, e) : n === 3 ? L_(e) : n ? $_(e) : H_(e, !1), Pw = Je(Vl, jt, !0), Mw = (e) => {
      const n = (p) => p(e), s = ze(e), i = () => u, u = {
        tag: !0,
        inner: e,
        fold: (p, b) => b(e),
        isValue: xt,
        isError: et,
        map: (p) => lc.value(p(e)),
        mapError: i,
        bind: n,
        exists: n,
        forall: n,
        getOr: s,
        or: i,
        getOrThunk: s,
        orThunk: i,
        getOrDie: s,
        each: (p) => {
          p(e);
        },
        toOptional: () => X.some(e)
      };
      return u;
    }, Cy = (e) => {
      const n = () => s, s = {
        tag: !1,
        inner: e,
        fold: (i, u) => i(e),
        isValue: et,
        isError: xt,
        map: n,
        mapError: (i) => lc.error(i(e)),
        bind: n,
        exists: et,
        forall: xt,
        getOr: jt,
        or: jt,
        getOrThunk: Rt,
        orThunk: Rt,
        getOrDie: Ro(String(e)),
        each: ot,
        toOptional: X.none
      };
      return s;
    }, lc = {
      value: Mw,
      error: Cy,
      fromOption: (e, n) => e.fold(() => Cy(n), Mw)
    }, or = { generate: (e) => {
      if (!rt(e))
        throw new Error("cases must be an array");
      if (e.length === 0)
        throw new Error("there must be at least one case");
      const n = [], s = {};
      return je(e, (i, u) => {
        const p = Ms(i);
        if (p.length !== 1)
          throw new Error("one and only one name per case");
        const b = p[0], S = i[b];
        if (s[b] !== void 0)
          throw new Error("duplicate key detected:" + b);
        if (b === "cata")
          throw new Error("cannot have a case named cata (sorry)");
        if (!rt(S))
          throw new Error("case arguments must be an array");
        n.push(b), s[b] = (...T) => {
          const M = T.length;
          if (M !== S.length)
            throw new Error("Wrong number of arguments to case " + b + ". Expected " + S.length + " (" + S + "), got " + M);
          return {
            fold: (...W) => {
              if (W.length !== e.length)
                throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + W.length);
              return W[u].apply(null, T);
            },
            match: (W) => {
              const G = Ms(W);
              if (n.length !== G.length)
                throw new Error("Wrong number of arguments to match. Expected: " + n.join(",") + `
Actual: ` + G.join(","));
              if (!Qo(n, (we) => Nt(G, we)))
                throw new Error("Not all branches were specified when using match. Specified: " + G.join(", ") + `
Required: ` + n.join(", "));
              return W[b].apply(null, T);
            },
            log: (W) => {
              console.log(W, {
                constructors: n,
                constructor: b,
                params: T
              });
            }
          };
        };
      }), s;
    } };
    or.generate([
      {
        bothErrors: [
          "error1",
          "error2"
        ]
      },
      {
        firstError: [
          "error1",
          "value2"
        ]
      },
      {
        secondError: [
          "value1",
          "error2"
        ]
      },
      {
        bothValues: [
          "value1",
          "value2"
        ]
      }
    ]);
    const pf = (e) => {
      const n = [], s = [];
      return je(e, (i) => {
        i.fold((u) => {
          n.push(u);
        }, (u) => {
          s.push(u);
        });
      }), {
        errors: n,
        values: s
      };
    }, m1 = (e) => e.type === "inline-command" || e.type === "inline-format", V_ = (e) => e.type === "block-command" || e.type === "block-format", Sy = (e, n) => (e.type === "block-command" || e.type === "block-format") && e.trigger === n, ky = (e) => {
      var n;
      const s = (u) => lc.error({
        message: u,
        pattern: e
      }), i = (u, p, b) => {
        if (e.format !== void 0) {
          let S;
          if (rt(e.format)) {
            if (!Qo(e.format, U))
              return s(u + " pattern has non-string items in the `format` array");
            S = e.format;
          } else if (U(e.format))
            S = [e.format];
          else
            return s(u + " pattern has non-string `format` parameter");
          return lc.value(p(S));
        } else return e.cmd !== void 0 ? U(e.cmd) ? lc.value(b(e.cmd, e.value)) : s(u + " pattern has non-string `cmd` parameter") : s(u + " pattern is missing both `format` and `cmd` parameters");
      };
      if (!ve(e))
        return s("Raw pattern is not an object");
      if (!U(e.start))
        return s("Raw pattern is missing `start` parameter");
      if (e.end !== void 0) {
        if (!U(e.end))
          return s("Inline pattern has non-string `end` parameter");
        if (e.start.length === 0 && e.end.length === 0)
          return s("Inline pattern has empty `start` and `end` parameters");
        let u = e.start, p = e.end;
        return p.length === 0 && (p = u, u = ""), i("Inline", (b) => ({
          type: "inline-format",
          start: u,
          end: p,
          format: b
        }), (b, S) => ({
          type: "inline-command",
          start: u,
          end: p,
          cmd: b,
          value: S
        }));
      } else {
        if (e.replacement !== void 0)
          return U(e.replacement) ? e.start.length === 0 ? s("Replacement pattern has empty `start` parameter") : lc.value({
            type: "inline-command",
            start: "",
            end: e.start,
            cmd: "mceInsertContent",
            value: e.replacement
          }) : s("Replacement pattern has non-string `replacement` parameter");
        {
          const u = (n = e.trigger) !== null && n !== void 0 ? n : "space";
          return e.start.length === 0 ? s("Block pattern has empty `start` parameter") : i("Block", (p) => ({
            type: "block-format",
            start: e.start,
            format: p[0],
            trigger: u
          }), (p, b) => ({
            type: "block-command",
            start: e.start,
            cmd: p,
            value: b,
            trigger: u
          }));
        }
      }
    }, qp = (e) => on(e, V_), Ji = (e) => on(e, m1), Kp = (e, n) => ({
      inlinePatterns: Ji(e),
      blockPatterns: qp(e),
      dynamicPatternsLookup: n
    }), Fw = (e, n) => ({
      ...e,
      blockPatterns: on(e.blockPatterns, (s) => Sy(s, n))
    }), U_ = (e) => {
      const n = pf(tn(e, ky));
      return je(n.errors, (s) => console.error(s.message, s.pattern)), n.values;
    }, LO = (e) => (n) => {
      const s = e(n);
      return U_(s);
    }, Vv = Xt().deviceType, Bw = Vv.isTouch(), Lw = Kr.DOM, $w = (e) => {
      const n = e.indexOf("=") > 0 ? e.split(/[;,](?![^=;,]*(?:[;,]|$))/) : e.split(",");
      return vt(n, (s, i) => {
        const u = i.split("="), p = u[0], b = u.length > 1 ? u[1] : p;
        return s[Wa(p)] = Wa(b), s;
      }, {});
    }, Hw = (e) => oe(e, RegExp), Bn = (e) => (n) => n.options.get(e), p1 = (e) => U(e) || ve(e), zw = (e, n = "") => (s) => {
      const i = U(s);
      if (i)
        if (s.indexOf("=") !== -1) {
          const u = $w(s);
          return {
            value: _s(u, e.id).getOr(n),
            valid: i
          };
        } else
          return {
            value: s,
            valid: i
          };
      else
        return {
          valid: !1,
          message: "Must be a string."
        };
    }, Uv = (e) => {
      const n = e.options.register;
      n("id", {
        processor: "string",
        default: e.id
      }), n("selector", { processor: "string" }), n("target", { processor: "object" }), n("suffix", { processor: "string" }), n("cache_suffix", { processor: "string" }), n("base_url", { processor: "string" }), n("referrer_policy", {
        processor: "string",
        default: ""
      }), n("language_load", {
        processor: "boolean",
        default: !0
      }), n("inline", {
        processor: "boolean",
        default: !1
      }), n("iframe_attrs", {
        processor: "object",
        default: {}
      }), n("doctype", {
        processor: "string",
        default: "<!DOCTYPE html>"
      }), n("document_base_url", {
        processor: "string",
        default: e.documentBaseUrl
      }), n("body_id", {
        processor: zw(e, "tinymce"),
        default: "tinymce"
      }), n("body_class", {
        processor: zw(e),
        default: ""
      }), n("content_security_policy", {
        processor: "string",
        default: ""
      }), n("br_in_pre", {
        processor: "boolean",
        default: !0
      }), n("forced_root_block", {
        processor: (s) => {
          const i = U(s) && ko(s);
          return i ? {
            value: s,
            valid: i
          } : {
            valid: !1,
            message: "Must be a non-empty string."
          };
        },
        default: "p"
      }), n("forced_root_block_attrs", {
        processor: "object",
        default: {}
      }), n("newline_behavior", {
        processor: (s) => {
          const i = Nt([
            "block",
            "linebreak",
            "invert",
            "default"
          ], s);
          return i ? {
            value: s,
            valid: i
          } : {
            valid: !1,
            message: "Must be one of: block, linebreak, invert or default."
          };
        },
        default: "default"
      }), n("br_newline_selector", {
        processor: "string",
        default: ".mce-toc h2,figcaption,caption"
      }), n("no_newline_selector", {
        processor: "string",
        default: ""
      }), n("keep_styles", {
        processor: "boolean",
        default: !0
      }), n("end_container_on_empty_block", {
        processor: (s) => lt(s) ? {
          valid: !0,
          value: s
        } : U(s) ? {
          valid: !0,
          value: s
        } : {
          valid: !1,
          message: "Must be boolean or a string"
        },
        default: "blockquote"
      }), n("font_size_style_values", {
        processor: "string",
        default: "xx-small,x-small,small,medium,large,x-large,xx-large"
      }), n("font_size_legacy_values", {
        processor: "string",
        default: "xx-small,small,medium,large,x-large,xx-large,300%"
      }), n("font_size_classes", {
        processor: "string",
        default: ""
      }), n("automatic_uploads", {
        processor: "boolean",
        default: !0
      }), n("images_reuse_filename", {
        processor: "boolean",
        default: !1
      }), n("images_replace_blob_uris", {
        processor: "boolean",
        default: !0
      }), n("icons", {
        processor: "string",
        default: ""
      }), n("icons_url", {
        processor: "string",
        default: ""
      }), n("images_upload_url", {
        processor: "string",
        default: ""
      }), n("images_upload_base_path", {
        processor: "string",
        default: ""
      }), n("images_upload_credentials", {
        processor: "boolean",
        default: !1
      }), n("images_upload_handler", { processor: "function" }), n("language", {
        processor: "string",
        default: "en"
      }), n("language_url", {
        processor: "string",
        default: ""
      }), n("entity_encoding", {
        processor: "string",
        default: "named"
      }), n("indent", {
        processor: "boolean",
        default: !0
      }), n("indent_before", {
        processor: "string",
        default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
      }), n("indent_after", {
        processor: "string",
        default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
      }), n("indent_use_margin", {
        processor: "boolean",
        default: !1
      }), n("indentation", {
        processor: "string",
        default: "40px"
      }), n("content_css", {
        processor: (s) => {
          const i = s === !1 || U(s) || _t(s, U);
          return i ? U(s) ? {
            value: tn(s.split(","), Wa),
            valid: i
          } : rt(s) ? {
            value: s,
            valid: i
          } : s === !1 ? {
            value: [],
            valid: i
          } : {
            value: s,
            valid: i
          } : {
            valid: !1,
            message: "Must be false, a string or an array of strings."
          };
        },
        default: xg(e) ? [] : ["default"]
      }), n("content_style", { processor: "string" }), n("content_css_cors", {
        processor: "boolean",
        default: !1
      }), n("font_css", {
        processor: (s) => {
          const i = U(s) || _t(s, U);
          return i ? {
            value: rt(s) ? s : tn(s.split(","), Wa),
            valid: i
          } : {
            valid: !1,
            message: "Must be a string or an array of strings."
          };
        },
        default: []
      }), n("inline_boundaries", {
        processor: "boolean",
        default: !0
      }), n("inline_boundaries_selector", {
        processor: "string",
        default: "a[href],code,span.mce-annotation"
      }), n("object_resizing", {
        processor: (s) => {
          const i = lt(s) || U(s);
          return i ? s === !1 || Vv.isiPhone() || Vv.isiPad() ? {
            value: "",
            valid: i
          } : {
            value: s === !0 ? "table,img,figure.image,div,video,iframe" : s,
            valid: i
          } : {
            valid: !1,
            message: "Must be boolean or a string"
          };
        },
        default: !Bw
      }), n("resize_img_proportional", {
        processor: "boolean",
        default: !0
      }), n("event_root", { processor: "string" }), n("service_message", { processor: "string" }), n("theme", {
        processor: (s) => s === !1 || U(s) || Ce(s),
        default: "silver"
      }), n("theme_url", { processor: "string" }), n("formats", { processor: "object" }), n("format_empty_lines", {
        processor: "boolean",
        default: !1
      }), n("format_noneditable_selector", {
        processor: "string",
        default: ""
      }), n("preview_styles", {
        processor: (s) => {
          const i = s === !1 || U(s);
          return i ? {
            value: s === !1 ? "" : s,
            valid: i
          } : {
            valid: !1,
            message: "Must be false or a string"
          };
        },
        default: "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow"
      }), n("custom_ui_selector", {
        processor: "string",
        default: ""
      }), n("hidden_input", {
        processor: "boolean",
        default: !0
      }), n("submit_patch", {
        processor: "boolean",
        default: !0
      }), n("encoding", { processor: "string" }), n("add_form_submit_trigger", {
        processor: "boolean",
        default: !0
      }), n("add_unload_trigger", {
        processor: "boolean",
        default: !0
      }), n("custom_undo_redo_levels", {
        processor: "number",
        default: 0
      }), n("disable_nodechange", {
        processor: "boolean",
        default: !1
      }), n("readonly", {
        processor: "boolean",
        default: !1
      }), n("editable_root", {
        processor: "boolean",
        default: !0
      }), n("plugins", {
        processor: "string[]",
        default: []
      }), n("external_plugins", { processor: "object" }), n("forced_plugins", { processor: "string[]" }), n("model", {
        processor: "string",
        default: e.hasPlugin("rtc") ? "plugin" : "dom"
      }), n("model_url", { processor: "string" }), n("block_unsupported_drop", {
        processor: "boolean",
        default: !0
      }), n("visual", {
        processor: "boolean",
        default: !0
      }), n("visual_table_class", {
        processor: "string",
        default: "mce-item-table"
      }), n("visual_anchor_class", {
        processor: "string",
        default: "mce-item-anchor"
      }), n("iframe_aria_text", {
        processor: "string",
        default: "Rich Text Area. Press ALT-0 for help."
      }), n("setup", { processor: "function" }), n("init_instance_callback", { processor: "function" }), n("url_converter", {
        processor: "function",
        default: e.convertURL
      }), n("url_converter_scope", {
        processor: "object",
        default: e
      }), n("urlconverter_callback", { processor: "function" }), n("allow_conditional_comments", {
        processor: "boolean",
        default: !1
      }), n("allow_html_data_urls", {
        processor: "boolean",
        default: !1
      }), n("allow_svg_data_urls", { processor: "boolean" }), n("allow_html_in_named_anchor", {
        processor: "boolean",
        default: !1
      }), n("allow_script_urls", {
        processor: "boolean",
        default: !1
      }), n("allow_unsafe_link_target", {
        processor: "boolean",
        default: !1
      }), n("convert_fonts_to_spans", {
        processor: "boolean",
        default: !0,
        deprecated: !0
      }), n("fix_list_elements", {
        processor: "boolean",
        default: !1
      }), n("preserve_cdata", {
        processor: "boolean",
        default: !1
      }), n("remove_trailing_brs", {
        processor: "boolean",
        default: !0
      }), n("pad_empty_with_br", {
        processor: "boolean",
        default: !1
      }), n("inline_styles", {
        processor: "boolean",
        default: !0,
        deprecated: !0
      }), n("element_format", {
        processor: "string",
        default: "html"
      }), n("entities", { processor: "string" }), n("schema", {
        processor: "string",
        default: "html5"
      }), n("convert_urls", {
        processor: "boolean",
        default: !0
      }), n("relative_urls", {
        processor: "boolean",
        default: !0
      }), n("remove_script_host", {
        processor: "boolean",
        default: !0
      }), n("custom_elements", { processor: p1 }), n("extended_valid_elements", { processor: "string" }), n("invalid_elements", { processor: "string" }), n("invalid_styles", { processor: p1 }), n("valid_children", { processor: "string" }), n("valid_classes", { processor: p1 }), n("valid_elements", { processor: "string" }), n("valid_styles", { processor: p1 }), n("verify_html", {
        processor: "boolean",
        default: !0
      }), n("auto_focus", { processor: (s) => U(s) || s === !0 }), n("browser_spellcheck", {
        processor: "boolean",
        default: !1
      }), n("protect", { processor: "array" }), n("images_file_types", {
        processor: "string",
        default: "jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp"
      }), n("deprecation_warnings", {
        processor: "boolean",
        default: !0
      }), n("a11y_advanced_options", {
        processor: "boolean",
        default: !1
      }), n("api_key", { processor: "string" }), n("license_key", { processor: "string" }), n("paste_block_drop", {
        processor: "boolean",
        default: !1
      }), n("paste_data_images", {
        processor: "boolean",
        default: !0
      }), n("paste_preprocess", { processor: "function" }), n("paste_postprocess", { processor: "function" }), n("paste_webkit_styles", {
        processor: "string",
        default: "none"
      }), n("paste_remove_styles_if_webkit", {
        processor: "boolean",
        default: !0
      }), n("paste_merge_formats", {
        processor: "boolean",
        default: !0
      }), n("smart_paste", {
        processor: "boolean",
        default: !0
      }), n("paste_as_text", {
        processor: "boolean",
        default: !1
      }), n("paste_tab_spaces", {
        processor: "number",
        default: 4
      }), n("text_patterns", {
        processor: (s) => _t(s, ve) || s === !1 ? {
          value: U_(s === !1 ? [] : s),
          valid: !0
        } : {
          valid: !1,
          message: "Must be an array of objects or false."
        },
        default: [
          {
            start: "*",
            end: "*",
            format: "italic"
          },
          {
            start: "**",
            end: "**",
            format: "bold"
          },
          {
            start: "#",
            format: "h1",
            trigger: "space"
          },
          {
            start: "##",
            format: "h2",
            trigger: "space"
          },
          {
            start: "###",
            format: "h3",
            trigger: "space"
          },
          {
            start: "####",
            format: "h4",
            trigger: "space"
          },
          {
            start: "#####",
            format: "h5",
            trigger: "space"
          },
          {
            start: "######",
            format: "h6",
            trigger: "space"
          },
          {
            start: "1.",
            cmd: "InsertOrderedList",
            trigger: "space"
          },
          {
            start: "*",
            cmd: "InsertUnorderedList",
            trigger: "space"
          },
          {
            start: "-",
            cmd: "InsertUnorderedList",
            trigger: "space"
          },
          {
            start: ">",
            cmd: "mceBlockQuote",
            trigger: "space"
          },
          {
            start: "---",
            cmd: "InsertHorizontalRule",
            trigger: "space"
          }
        ]
      }), n("text_patterns_lookup", {
        processor: (s) => Ce(s) ? {
          value: LO(s),
          valid: !0
        } : {
          valid: !1,
          message: "Must be a single function"
        },
        default: (s) => []
      }), n("noneditable_class", {
        processor: "string",
        default: "mceNonEditable"
      }), n("editable_class", {
        processor: "string",
        default: "mceEditable"
      }), n("noneditable_regexp", {
        processor: (s) => _t(s, Hw) ? {
          value: s,
          valid: !0
        } : Hw(s) ? {
          value: [s],
          valid: !0
        } : {
          valid: !1,
          message: "Must be a RegExp or an array of RegExp."
        },
        default: []
      }), n("table_tab_navigation", {
        processor: "boolean",
        default: !0
      }), n("highlight_on_focus", {
        processor: "boolean",
        default: !0
      }), n("xss_sanitization", {
        processor: "boolean",
        default: !0
      }), n("details_initial_state", {
        processor: (s) => {
          const i = Nt([
            "inherited",
            "collapsed",
            "expanded"
          ], s);
          return i ? {
            value: s,
            valid: i
          } : {
            valid: !1,
            message: "Must be one of: inherited, collapsed, or expanded."
          };
        },
        default: "inherited"
      }), n("details_serialized_state", {
        processor: (s) => {
          const i = Nt([
            "inherited",
            "collapsed",
            "expanded"
          ], s);
          return i ? {
            value: s,
            valid: i
          } : {
            valid: !1,
            message: "Must be one of: inherited, collapsed, or expanded."
          };
        },
        default: "inherited"
      }), n("init_content_sync", {
        processor: "boolean",
        default: !1
      }), n("newdocument_content", {
        processor: "string",
        default: ""
      }), n("sandbox_iframes", {
        processor: "boolean",
        default: !0
      }), n("sandbox_iframes_exclusions", {
        processor: "string[]",
        default: [
          "youtube.com",
          "youtu.be",
          "vimeo.com",
          "player.vimeo.com",
          "dailymotion.com",
          "embed.music.apple.com",
          "open.spotify.com",
          "giphy.com",
          "dai.ly",
          "codepen.io"
        ]
      }), n("convert_unsafe_embeds", {
        processor: "boolean",
        default: !0
      }), e.on("ScriptsLoaded", () => {
        n("directionality", {
          processor: "string",
          default: Fi.isRtl() ? "rtl" : void 0
        }), n("placeholder", {
          processor: "string",
          default: Lw.getAttrib(e.getElement(), "placeholder")
        });
      });
    }, Ad = Bn("iframe_attrs"), $O = Bn("doctype"), el = Bn("document_base_url"), HO = Bn("body_id"), Yp = Bn("body_class"), Vw = Bn("content_security_policy"), j_ = Bn("br_in_pre"), Dl = Bn("forced_root_block"), Xp = Bn("forced_root_block_attrs"), _y = Bn("newline_behavior"), Qp = Bn("br_newline_selector"), zO = Bn("no_newline_selector"), VO = Bn("keep_styles"), fi = Bn("end_container_on_empty_block"), ei = Bn("automatic_uploads"), mi = Bn("images_reuse_filename"), br = Bn("images_replace_blob_uris"), Si = Bn("icons"), ti = Bn("icons_url"), Uw = Bn("images_upload_url"), Ey = Bn("images_upload_base_path"), jw = Bn("images_upload_credentials"), W_ = Bn("images_upload_handler"), Z_ = Bn("content_css_cors"), Ty = Bn("referrer_policy"), Ay = Bn("language"), vg = Bn("language_url"), Ww = Bn("indent_use_margin"), yU = Bn("indentation"), bg = Bn("content_css"), UO = Bn("content_style"), Rc = Bn("font_css"), GI = Bn("directionality"), jO = Bn("inline_boundaries_selector"), vu = Bn("object_resizing"), h1 = Bn("resize_img_proportional"), g1 = Bn("placeholder"), hf = Bn("event_root"), cc = Bn("service_message"), Jp = Bn("theme"), Zw = Bn("theme_url"), Oy = Bn("model"), G_ = Bn("model_url"), yg = Bn("inline_boundaries"), Gw = Bn("formats"), qw = Bn("preview_styles"), q_ = Bn("format_empty_lines"), K_ = Bn("format_noneditable_selector"), v1 = Bn("custom_ui_selector"), xg = Bn("inline"), Kw = Bn("hidden_input"), Yw = Bn("submit_patch"), Y_ = Bn("add_form_submit_trigger"), X_ = Bn("add_unload_trigger"), WO = Bn("custom_undo_redo_levels"), Dy = Bn("disable_nodechange"), Q_ = Bn("readonly"), ZO = Bn("editable_root"), J_ = Bn("content_css_cors"), b1 = Bn("plugins"), GO = Bn("external_plugins"), eE = Bn("block_unsupported_drop"), uc = Bn("visual"), Xw = Bn("visual_table_class"), Qw = Bn("visual_anchor_class"), Jw = Bn("iframe_aria_text"), Ry = Bn("setup"), qO = Bn("init_instance_callback"), KO = Bn("urlconverter_callback"), Ny = Bn("auto_focus"), tE = Bn("browser_spellcheck"), eC = Bn("protect"), tC = Bn("paste_block_drop"), y1 = Bn("paste_data_images"), nC = Bn("paste_preprocess"), nE = Bn("paste_postprocess"), oE = Bn("newdocument_content"), sE = Bn("paste_webkit_styles"), YO = Bn("paste_remove_styles_if_webkit"), rE = Bn("paste_merge_formats"), aE = Bn("smart_paste"), iE = Bn("paste_as_text"), Py = Bn("paste_tab_spaces"), jv = Bn("allow_html_data_urls"), lE = Bn("text_patterns"), XO = Bn("text_patterns_lookup"), My = Bn("noneditable_class"), QO = Bn("editable_class"), Od = Bn("noneditable_regexp"), Iy = Bn("preserve_cdata"), Fy = Bn("highlight_on_focus"), By = Bn("xss_sanitization"), dc = Bn("init_content_sync"), eh = (e) => e.options.isSet("text_patterns_lookup"), th = (e) => Kt.explode(e.options.get("font_size_style_values")), JO = (e) => Kt.explode(e.options.get("font_size_classes")), nh = (e) => e.options.get("encoding") === "xml", x1 = (e) => Kt.explode(e.options.get("images_file_types")), eD = Bn("table_tab_navigation"), tD = Bn("details_initial_state"), cE = Bn("details_serialized_state"), Ly = Bn("sandbox_iframes"), $y = (e) => e.options.get("sandbox_iframes_exclusions"), nD = Bn("convert_unsafe_embeds"), w1 = Bn("license_key"), oC = Bn("api_key"), oD = Tn, sC = Gt, rC = (e) => {
      const n = e.parentNode;
      n && n.removeChild(e);
    }, Hy = (e) => {
      const n = Qc(e);
      return {
        count: e.length - n.length,
        text: n
      };
    }, sD = (e) => {
      let n;
      for (; (n = e.data.lastIndexOf(Ma)) !== -1; )
        e.deleteData(n, 1);
    }, wg = (e, n) => (oh(e), n), uE = (e, n) => {
      const s = Hy(e.data.substr(0, n.offset())), i = Hy(e.data.substr(n.offset()));
      return (s.text + i.text).length > 0 ? (sD(e), gt(e, n.offset() - s.count)) : n;
    }, aC = (e, n) => {
      const s = n.container(), i = Hn(Ss(s.childNodes), e).map((u) => u < n.offset() ? gt(s, n.offset() - 1) : n).getOr(n);
      return oh(e), i;
    }, dE = (e, n) => sC(e) && n.container() === e ? uE(e, n) : wg(e, n), zy = (e, n) => n.container() === e.parentNode ? aC(e, n) : wg(e, n), rD = (e, n) => gt.isTextPosition(n) ? dE(e, n) : zy(e, n), oh = (e) => {
      oD(e) && Jc(e) && (yw(e) ? e.removeAttribute("data-mce-caret") : rC(e)), sC(e) && (sD(e), e.data.length === 0 && rC(e));
    }, qI = Ls, Wv = Yi, Vy = yv, Zv = "*[contentEditable=false],video,audio,embed,object", Gv = (e, n, s) => {
      const i = Ur(n.getBoundingClientRect(), s);
      let u, p;
      if (e.tagName === "BODY") {
        const S = e.ownerDocument.documentElement;
        u = e.scrollLeft || S.scrollLeft, p = e.scrollTop || S.scrollTop;
      } else {
        const S = e.getBoundingClientRect();
        u = e.scrollLeft - S.left, p = e.scrollTop - S.top;
      }
      i.left += u, i.right += u, i.top += p, i.bottom += p, i.width = 1;
      let b = n.offsetWidth - n.clientWidth;
      return b > 0 && (s && (b *= -1), i.left += b, i.right += b), i;
    }, aD = (e) => {
      var n, s;
      const i = va(Me.fromDom(e), Zv);
      for (let u = 0; u < i.length; u++) {
        const p = i[u].dom;
        let b = p.previousSibling;
        if (Xf(b)) {
          const S = b.data;
          S.length === 1 ? (n = b.parentNode) === null || n === void 0 || n.removeChild(b) : b.deleteData(S.length - 1, 1);
        }
        b = p.nextSibling, pg(b) && (b.data.length === 1 ? (s = b.parentNode) === null || s === void 0 || s.removeChild(b) : b.deleteData(0, 1));
      }
    }, fE = (e, n, s, i) => {
      const u = Ii();
      let p, b;
      const S = Dl(e), T = e.dom, M = (fe, ke) => {
        let He;
        if (j(), Vy(ke))
          return null;
        if (s(ke)) {
          const Ye = xO(S, ke, fe), We = Gv(n, ke, fe);
          T.setStyle(Ye, "top", We.top), T.setStyle(Ye, "caret-color", "transparent"), b = Ye;
          const ut = T.create("div", {
            class: "mce-visual-caret",
            "data-mce-bogus": "all"
          });
          T.setStyles(ut, { ...We }), T.add(n, ut), u.set({
            caret: ut,
            element: ke,
            before: fe
          }), fe && T.addClass(ut, "mce-visual-caret-before"), W(), He = ke.ownerDocument.createRange(), He.setStart(Ye, 0), He.setEnd(Ye, 0);
        } else
          return b = xw(ke, fe), He = ke.ownerDocument.createRange(), Uy(b.nextSibling) ? (He.setStart(b, 0), He.setEnd(b, 0)) : (He.setStart(b, 1), He.setEnd(b, 1)), He;
        return He;
      }, j = () => {
        aD(n), b && (oh(b), b = null), u.on((fe) => {
          T.remove(fe.caret), u.clear();
        }), p && (clearInterval(p), p = void 0);
      }, W = () => {
        p = setInterval(() => {
          u.on((fe) => {
            i() ? T.toggleClass(fe.caret, "mce-visual-caret-hidden") : T.addClass(fe.caret, "mce-visual-caret-hidden");
          });
        }, 500);
      };
      return {
        show: M,
        hide: j,
        getCss: () => ".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}",
        reposition: () => {
          u.on((fe) => {
            const ke = Gv(n, fe.element, fe.before);
            T.setStyles(fe.caret, { ...ke });
          });
        },
        destroy: () => clearInterval(p)
      };
    }, iD = () => sn.browser.isFirefox(), Uy = (e) => qI(e) || Wv(e), Um = (e) => (Uy(e) || Hu(e) && iD()) && Hc(Me.fromDom(e)).exists(za), iC = Mt, lC = Ls, lD = Yi, cC = Qh("display", "block table table-cell table-caption list-item"), mE = Jc, pE = fg, hE = Tn, qv = Gt, jy = mf, Cg = (e) => e > 0, jm = (e) => e < 0, C1 = (e, n) => {
      let s;
      for (; s = e(n); )
        if (!pE(s))
          return s;
      return null;
    }, Kv = (e, n, s, i, u) => {
      const p = new Pi(e, i), b = lC(e) || pE(e);
      let S;
      if (jm(n)) {
        if (b && (S = C1(p.prev.bind(p), !0), s(S)))
          return S;
        for (; S = C1(p.prev.bind(p), u); )
          if (s(S))
            return S;
      }
      if (Cg(n)) {
        if (b && (S = C1(p.next.bind(p), !0), s(S)))
          return S;
        for (; S = C1(p.next.bind(p), u); )
          if (s(S))
            return S;
      }
      return null;
    }, cD = (e, n) => {
      const s = (u) => iC(u.dom), i = (u) => u.dom === n;
      return Nr(Me.fromDom(e), s, i).map((u) => u.dom).getOr(n);
    }, gf = (e, n) => {
      for (; e && e !== n; ) {
        if (cC(e))
          return e;
        e = e.parentNode;
      }
      return null;
    }, bu = (e, n, s) => gf(e.container(), s) === gf(n.container(), s), Wy = (e, n) => {
      if (!n)
        return X.none();
      const s = n.container(), i = n.offset();
      return hE(s) ? X.from(s.childNodes[i + e]) : X.none();
    }, uD = (e, n) => {
      var s;
      const u = ((s = n.ownerDocument) !== null && s !== void 0 ? s : document).createRange();
      return e ? (u.setStartBefore(n), u.setEndBefore(n)) : (u.setStartAfter(n), u.setEndAfter(n)), u;
    }, KI = (e, n, s) => gf(n, e) === gf(s, e), Sg = (e, n, s) => {
      const i = e ? "previousSibling" : "nextSibling";
      let u = s;
      for (; u && u !== n; ) {
        let p = u[i];
        if (p && mE(p) && (p = p[i]), lC(p) || lD(p)) {
          if (KI(n, p, u))
            return p;
          break;
        }
        if (jy(p))
          break;
        u = u.parentNode;
      }
      return null;
    }, Yv = Je(uD, !0), Xv = Je(uD, !1), Rl = (e, n, s) => {
      let i;
      const u = Je(Sg, !0, n), p = Je(Sg, !1, n), b = s.startContainer, S = s.startOffset;
      if (fg(b)) {
        const T = qv(b) ? b.parentNode : b, M = T.getAttribute("data-mce-caret");
        if (M === "before" && (i = T.nextSibling, Um(i)))
          return Yv(i);
        if (M === "after" && (i = T.previousSibling, Um(i)))
          return Xv(i);
      }
      if (!s.collapsed)
        return s;
      if (Gt(b)) {
        if (mE(b)) {
          if (e === 1) {
            if (i = p(b), i)
              return Yv(i);
            if (i = u(b), i)
              return Xv(i);
          }
          if (e === -1) {
            if (i = u(b), i)
              return Xv(i);
            if (i = p(b), i)
              return Yv(i);
          }
          return s;
        }
        if (Xf(b) && S >= b.data.length - 1)
          return e === 1 && (i = p(b), i) ? Yv(i) : s;
        if (pg(b) && S <= 1)
          return e === -1 && (i = u(b), i) ? Xv(i) : s;
        if (S === b.data.length)
          return i = p(b), i ? Yv(i) : s;
        if (S === 0)
          return i = u(b), i ? Xv(i) : s;
      }
      return s;
    }, Zy = (e, n) => Wy(e ? 0 : -1, n).filter(lC), kg = (e, n, s) => {
      const i = Rl(e, n, s);
      return e === -1 ? gt.fromRangeStart(i) : gt.fromRangeEnd(i);
    }, Gy = (e) => X.from(e.getNode()).map(Me.fromDom), gE = (e) => X.from(e.getNode(!0)).map(Me.fromDom), uC = (e, n) => {
      let s = n;
      for (; s = e(s); )
        if (s.isVisible())
          return s;
      return s;
    }, qy = (e, n) => {
      const s = bu(e, n);
      return !s && Vs(e.getNode()) ? !0 : s;
    };
    var Bi;
    (function(e) {
      e[e.Backwards = -1] = "Backwards", e[e.Forwards = 1] = "Forwards";
    })(Bi || (Bi = {}));
    const Ky = Ls, Dd = Gt, dC = Tn, fC = Vs, Wm = mf, vE = OO, sh = kw, Yy = (e, n) => {
      const s = [];
      let i = e;
      for (; i && i !== n; )
        s.push(i), i = i.parentNode;
      return s;
    }, Xy = (e, n) => e.hasChildNodes() && n < e.childNodes.length ? e.childNodes[n] : null, mC = (e, n) => {
      if (Cg(e)) {
        if (Wm(n.previousSibling) && !Dd(n.previousSibling))
          return gt.before(n);
        if (Dd(n))
          return gt(n, 0);
      }
      if (jm(e)) {
        if (Wm(n.nextSibling) && !Dd(n.nextSibling))
          return gt.after(n);
        if (Dd(n))
          return gt(n, n.data.length);
      }
      return jm(e) ? fC(n) ? gt.before(n) : gt.after(n) : gt.before(n);
    }, _g = (e, n) => {
      const s = n.nextSibling;
      return s && Wm(s) ? Dd(s) ? gt(s, 0) : gt.before(s) : Qv(Bi.Forwards, gt.after(n), e);
    }, Qv = (e, n, s) => {
      let i, u, p, b;
      if (!dC(s) || !n)
        return null;
      if (n.isEqual(gt.after(s)) && s.lastChild) {
        if (b = gt.after(s.lastChild), jm(e) && Wm(s.lastChild) && dC(s.lastChild))
          return fC(s.lastChild) ? gt.before(s.lastChild) : b;
      } else
        b = n;
      const S = b.container();
      let T = b.offset();
      if (Dd(S)) {
        if (jm(e) && T > 0)
          return gt(S, --T);
        if (Cg(e) && T < S.length)
          return gt(S, ++T);
        i = S;
      } else {
        if (jm(e) && T > 0 && (u = Xy(S, T - 1), Wm(u)))
          return !vE(u) && (p = Kv(u, e, sh, u), p) ? Dd(p) ? gt(p, p.data.length) : gt.after(p) : Dd(u) ? gt(u, u.data.length) : gt.before(u);
        if (Cg(e) && T < S.childNodes.length && (u = Xy(S, T), Wm(u)))
          return fC(u) ? _g(s, u) : !vE(u) && (p = Kv(u, e, sh, u), p) ? Dd(p) ? gt(p, 0) : gt.before(p) : Dd(u) ? gt(u, 0) : gt.after(u);
        i = u || b.getNode();
      }
      if (i && (Cg(e) && b.isAtEnd() || jm(e) && b.isAtStart()) && (i = Kv(i, e, xt, s, !0), sh(i, s)))
        return mC(e, i);
      u = i && Kv(i, e, sh, s);
      const M = ct(on(Yy(S, s), Ky));
      return M && (!u || !M.contains(u)) ? (Cg(e) ? b = gt.after(M) : b = gt.before(M), b) : u ? mC(e, u) : null;
    }, pl = (e) => ({
      next: (n) => Qv(Bi.Forwards, n, e),
      prev: (n) => Qv(Bi.Backwards, n, e)
    }), bE = (e, n, s) => {
      const i = e ? gt.before(s) : gt.after(s);
      return yu(e, n, i);
    }, pC = (e) => Vs(e) ? gt.before(e) : gt.after(e), hC = (e) => gt.isTextPosition(e) ? e.offset() === 0 : mf(e.getNode()), yE = (e) => {
      if (gt.isTextPosition(e)) {
        const n = e.container();
        return e.offset() === n.data.length;
      } else
        return mf(e.getNode(!0));
    }, gC = (e, n) => !gt.isTextPosition(e) && !gt.isTextPosition(n) && e.getNode() === n.getNode(!0), xE = (e) => !gt.isTextPosition(e) && Vs(e.getNode()), wE = (e, n, s) => e ? !gC(n, s) && !xE(n) && yE(n) && hC(s) : !gC(s, n) && hC(n) && yE(s), yu = (e, n, s) => {
      const i = pl(n);
      return X.from(e ? i.next(s) : i.prev(s));
    }, Zm = (e, n, s) => yu(e, n, s).bind((i) => bu(s, i, n) && wE(e, s, i) ? yu(e, n, i) : X.some(i)), CE = (e, n, s, i) => Zm(e, n, s).bind((u) => i(u) ? CE(e, n, u, i) : X.some(u)), Eg = (e, n) => {
      const s = e ? n.firstChild : n.lastChild;
      return Gt(s) ? X.some(gt(s, e ? 0 : s.data.length)) : s ? mf(s) ? X.some(e ? gt.before(s) : pC(s)) : bE(e, n, s) : X.none();
    }, Ul = Je(yu, !0), eu = Je(yu, !1), jl = Je(Eg, !0), xu = Je(Eg, !1), Qy = "_mce_caret", wu = (e) => Tn(e) && e.id === Qy, Tg = (e, n) => {
      let s = n;
      for (; s && s !== e; ) {
        if (wu(s))
          return s;
        s = s.parentNode;
      }
      return null;
    }, dD = (e) => U(e.start), SE = (e) => Xn(e, "rng"), fD = (e) => Xn(e, "id"), kE = (e) => Xn(e, "name"), _E = (e) => Kt.isArray(e.start), vC = (e) => !kE(e) && lt(e.forward) ? e.forward : !0, bC = (e, n) => (Tn(n) && e.isBlock(n) && !n.innerHTML && (n.innerHTML = '<br data-mce-bogus="1" />'), n), tl = (e, n) => {
      const s = X.from(M_(e.getRoot(), n.start)), i = X.from(M_(e.getRoot(), n.end));
      return ga(s, i, (u, p) => {
        const b = e.createRng();
        return b.setStart(u.container(), u.offset()), b.setEnd(p.container(), p.offset()), {
          range: b,
          forward: vC(n)
        };
      });
    }, yC = (e, n) => {
      var s;
      const u = ((s = e.ownerDocument) !== null && s !== void 0 ? s : document).createTextNode(Ma);
      e.appendChild(u), n.setStart(u, 0), n.setEnd(u, 0);
    }, rh = (e) => !e.hasChildNodes(), Jv = (e, n) => xu(e).fold(et, (s) => (n.setStart(s.container(), s.offset()), n.setEnd(s.container(), s.offset()), !0)), xC = (e, n, s) => rh(n) && Tg(e, n) ? (yC(n, s), !0) : !1, Jy = (e, n, s, i) => {
      const u = s[n ? "start" : "end"], p = e.getRoot();
      if (u) {
        let b = p, S = u[0];
        for (let T = u.length - 1; b && T >= 1; T--) {
          const M = b.childNodes;
          if (xC(p, b, i))
            return !0;
          if (u[T] > M.length - 1)
            return xC(p, b, i) ? !0 : Jv(b, i);
          b = M[u[T]];
        }
        Gt(b) && (S = Math.min(u[0], b.data.length)), Tn(b) && (S = Math.min(u[0], b.childNodes.length)), n ? i.setStart(b, S) : i.setEnd(b, S);
      }
      return !0;
    }, S1 = (e) => Gt(e) && e.data.length > 0, wC = (e, n, s) => {
      const i = e.get(s.id + "_" + n), u = i == null ? void 0 : i.parentNode, p = s.keep;
      if (i && u) {
        let b, S;
        if (n === "start" ? p ? i.hasChildNodes() ? (b = i.firstChild, S = 1) : S1(i.nextSibling) ? (b = i.nextSibling, S = 0) : S1(i.previousSibling) ? (b = i.previousSibling, S = i.previousSibling.data.length) : (b = u, S = e.nodeIndex(i) + 1) : (b = u, S = e.nodeIndex(i)) : p ? i.hasChildNodes() ? (b = i.firstChild, S = 1) : S1(i.previousSibling) ? (b = i.previousSibling, S = i.previousSibling.data.length) : (b = u, S = e.nodeIndex(i)) : (b = u, S = e.nodeIndex(i)), !p) {
          const T = i.previousSibling, M = i.nextSibling;
          Kt.each(Kt.grep(i.childNodes), (W) => {
            Gt(W) && (W.data = W.data.replace(/\uFEFF/g, ""));
          });
          let j;
          for (; j = e.get(s.id + "_" + n); )
            e.remove(j, !0);
          if (Gt(M) && Gt(T) && !sn.browser.isOpera()) {
            const W = T.data.length;
            T.appendData(M.data), e.remove(M), b = T, S = W;
          }
        }
        return X.some(gt(b, S));
      } else
        return X.none();
    }, eb = (e, n) => {
      const s = e.createRng();
      return Jy(e, !0, n, s) && Jy(e, !1, n, s) ? X.some({
        range: s,
        forward: vC(n)
      }) : X.none();
    }, CC = (e, n) => {
      const s = wC(e, "start", n), i = wC(e, "end", n);
      return ga(s, i.or(s), (u, p) => {
        const b = e.createRng();
        return b.setStart(bC(e, u.container()), u.offset()), b.setEnd(bC(e, p.container()), p.offset()), {
          range: b,
          forward: vC(n)
        };
      });
    }, em = (e, n) => X.from(e.select(n.name)[n.index]).map((s) => {
      const i = e.createRng();
      return i.selectNode(s), {
        range: i,
        forward: !0
      };
    }), Ag = (e, n) => {
      const s = e.dom;
      if (n) {
        if (_E(n))
          return eb(s, n);
        if (dD(n))
          return tl(s, n);
        if (fD(n))
          return CC(s, n);
        if (kE(n))
          return em(s, n);
        if (SE(n))
          return X.some({
            range: n.rng,
            forward: vC(n)
          });
      }
      return X.none();
    }, EE = (e, n, s) => z_(e, n, s), Gm = (e, n) => {
      Ag(e, n).each(({ range: s, forward: i }) => {
        e.setRng(s, i);
      });
    }, Cu = (e) => Tn(e) && e.tagName === "SPAN" && e.getAttribute("data-mce-type") === "bookmark", tm = ((e) => (n) => e === n)(Xa), Og = (e) => e !== "" && ` \f
\r	\v`.indexOf(e) !== -1, SC = (e) => !Og(e) && !tm(e) && !Ub(e), ex = (e) => {
      const n = [];
      if (e)
        for (let s = 0; s < e.rangeCount; s++)
          n.push(e.getRangeAt(s));
      return n;
    }, AE = (e) => rs(e, (n) => {
      const s = Lv(n);
      return s ? [Me.fromDom(s)] : [];
    }), mD = (e) => ex(e).length > 1, pD = (e) => on(AE(e), Fv), OE = (e) => va(e, "td[data-mce-selected],th[data-mce-selected]"), ah = (e, n) => {
      const s = OE(n);
      return s.length > 0 ? s : pD(e);
    }, tb = (e) => ah(ex(e.selection.getSel()), Me.fromDom(e.getBody())), k1 = (e, n) => Na(e, "table", n), hD = (e) => {
      const n = e.startContainer, s = e.startOffset;
      return Gt(n) ? s === 0 ? X.some(Me.fromDom(n)) : X.none() : X.from(n.childNodes[s]).map(Me.fromDom);
    }, gD = (e) => {
      const n = e.endContainer, s = e.endOffset;
      return Gt(n) ? s === n.data.length ? X.some(Me.fromDom(n)) : X.none() : X.from(n.childNodes[s - 1]).map(Me.fromDom);
    }, nb = (e) => Lf(e).fold(ze([e]), (n) => [e].concat(nb(n))), kC = (e) => _c(e).fold(ze([e]), (n) => fs(n) === "br" ? Jl(n).map((s) => [e].concat(kC(s))).getOr([]) : [e].concat(kC(n))), tx = (e, n) => ga(hD(n), gD(n), (s, i) => {
      const u = Dn(nb(e), Je(Bs, s)), p = Dn(kC(e), Je(Bs, i));
      return u.isSome() && p.isSome();
    }).getOr(!1), _C = (e, n, s, i) => {
      const u = s, p = new Pi(s, u), b = ks(e.schema.getMoveCaretBeforeOnEnterElements(), (T, M) => !Nt([
        "td",
        "th",
        "table"
      ], M.toLowerCase()));
      let S = s;
      do {
        if (Gt(S) && Kt.trim(S.data).length !== 0) {
          i ? n.setStart(S, 0) : n.setEnd(S, S.data.length);
          return;
        }
        if (b[S.nodeName]) {
          i ? n.setStartBefore(S) : S.nodeName === "BR" ? n.setEndBefore(S) : n.setEndAfter(S);
          return;
        }
      } while (S = i ? p.next() : p.prev());
      u.nodeName === "BODY" && (i ? n.setStart(u, 0) : n.setEnd(u, u.childNodes.length));
    }, EC = (e) => {
      const n = e.selection.getSel();
      return Ue(n) && n.rangeCount > 0;
    }, ob = (e, n) => {
      const s = tb(e);
      s.length > 0 ? je(s, (i) => {
        const u = i.dom, p = e.dom.createRng();
        p.setStartBefore(u), p.setEndAfter(u), n(p, !0);
      }) : n(e.selection.getRng(), !1);
    }, TC = (e, n, s) => {
      const i = H_(e, n);
      s(i), e.moveToBookmark(i);
    }, sb = (e) => Rn(e == null ? void 0 : e.nodeType), AC = (e) => Tn(e) && !Cu(e) && !wu(e) && !Mm(e), Ns = (e, n) => {
      if (AC(n) && !/^(TD|TH)$/.test(n.nodeName)) {
        const s = e.getAttrib(n, "data-mce-selected"), i = parseInt(s, 10);
        return !isNaN(i) && i > 0;
      } else
        return !1;
    }, nm = (e, n, s) => {
      const { selection: i, dom: u } = e, p = i.getNode(), b = Ls(p);
      TC(i, !0, () => {
        n();
      }), b && Ls(p) && u.isChildOf(p, e.getBody()) ? e.selection.select(p) : s(i.getStart()) && Dg(u, i);
    }, Dg = (e, n) => {
      var s, i;
      const u = n.getRng(), { startContainer: p, startOffset: b } = u, S = n.getNode();
      if (!Ns(e, S) && Tn(p)) {
        const T = p.childNodes, M = e.getRoot();
        let j;
        if (b < T.length) {
          const W = T[b];
          j = new Pi(W, (s = e.getParent(W, e.isBlock)) !== null && s !== void 0 ? s : M);
        } else {
          const W = T[T.length - 1];
          j = new Pi(W, (i = e.getParent(W, e.isBlock)) !== null && i !== void 0 ? i : M), j.next(!0);
        }
        for (let W = j.current(); W; W = j.next()) {
          if (e.getContentEditable(W) === "false")
            return;
          if (Gt(W) && !DC(W)) {
            u.setStart(W, 0), n.setRng(u);
            return;
          }
        }
      }
    }, _1 = (e, n, s) => {
      if (e) {
        const i = n ? "nextSibling" : "previousSibling";
        for (e = e[i]; e; e = e[i])
          if (Tn(e) || !DC(e))
            return e;
      }
    }, OC = (e, n) => !!e.getTextBlockElements()[n.nodeName.toLowerCase()] || Uu(e, n), qm = (e, n, s) => e.schema.isValidChild(n, s), DC = (e, n = !1) => {
      if (Ue(e) && Gt(e)) {
        const s = n ? e.data.replace(/ /g, " ") : e.data;
        return jc(s);
      } else
        return !1;
    }, nx = (e) => Ue(e) && Gt(e) && e.length === 0, RC = (e, n) => {
      const s = "[data-mce-cef-wrappable]", i = K_(e), u = Zo(i) ? s : `${s},${i}`;
      return wl(Me.fromDom(n), u);
    }, NC = (e, n) => {
      const s = e.dom;
      return AC(n) && s.getContentEditable(n) === "false" && RC(e, n) && s.select('[contenteditable="true"]', n).length === 0;
    }, Rg = (e, n) => Ce(e) ? e(n) : (Ue(n) && (e = e.replace(/%(\w+)/g, (s, i) => n[i] || s)), e), ox = (e, n) => (e = e || "", n = n || "", e = "" + (e.nodeName || e), n = "" + (n.nodeName || n), e.toLowerCase() === n.toLowerCase()), Ng = (e, n) => {
      if (Vt(e))
        return null;
      {
        let s = String(e);
        return (n === "color" || n === "backgroundColor") && (s = lf(s)), n === "fontWeight" && e === 700 && (s = "bold"), n === "fontFamily" && (s = s.replace(/[\'\"]/g, "").replace(/,\s+/g, ",")), s;
      }
    }, sx = (e, n, s) => {
      const i = e.getStyle(n, s);
      return Ng(i, s);
    }, DE = (e, n) => {
      let s;
      return e.getParent(n, (i) => Tn(i) ? (s = e.getStyle(i, "text-decoration"), !!s && s !== "none") : !1), s;
    }, rb = (e, n, s) => e.getParents(n, s, e.getRoot()), rx = (e, n, s) => {
      const i = e.formatter.get(n);
      return Ue(i) && Vn(i, s);
    }, vD = (e, n) => rx(e, n, (i) => {
      const u = (p) => Ce(p) || p.length > 1 && p.charAt(0) === "%";
      return Vn([
        "styles",
        "attributes"
      ], (p) => _s(i, p).exists((b) => {
        const S = rt(b) ? b : la(b);
        return Vn(S, u);
      }));
    }), ax = (e, n, s) => {
      const i = [
        "inline",
        "block",
        "selector",
        "attributes",
        "styles",
        "classes"
      ], u = (p) => ks(p, (b, S) => Vn(i, (T) => T === S));
      return rx(e, n, (p) => {
        const b = u(p);
        return rx(e, s, (S) => {
          const T = u(S);
          return Ke(b, T);
        });
      });
    }, Km = (e) => wr(e, "block"), bD = (e) => Km(e) && e.wrapper === !0, E1 = (e) => Km(e) && e.wrapper !== !0, Ku = (e) => wr(e, "selector"), Li = (e) => wr(e, "inline"), yD = (e) => Ku(e) && Li(e) && lr(_s(e, "mixed"), !0), vf = (e) => Ku(e) && e.expand !== !1 && !Li(e), xD = (e) => {
      const n = [];
      let s = e;
      for (; s; ) {
        if (Gt(s) && s.data !== Ma || s.childNodes.length > 1)
          return [];
        Tn(s) && n.push(s), s = s.firstChild;
      }
      return n;
    }, RE = (e) => xD(e).length > 0, T1 = (e) => wu(e.dom) && RE(e.dom), ab = Cu, NE = rb, PE = DC, YI = OC, XI = (e) => Vs(e) && e.getAttribute("data-mce-bogus") && !e.nextSibling, ME = (e, n) => {
      let s = n;
      for (; s; ) {
        if (Tn(s) && e.getContentEditable(s))
          return e.getContentEditable(s) === "false" ? s : n;
        s = s.parentNode;
      }
      return n;
    }, IE = (e, n, s, i) => {
      const u = n.data;
      if (e) {
        for (let p = s; p > 0; p--)
          if (i(u.charAt(p - 1)))
            return p;
      } else
        for (let p = s; p < u.length; p++)
          if (i(u.charAt(p)))
            return p;
      return -1;
    }, In = (e, n, s) => IE(e, n, s, (i) => tm(i) || Og(i)), $i = (e, n, s) => IE(e, n, s, SC), A1 = (e, n, s, i, u, p) => {
      let b;
      const S = e.getParent(s, e.isBlock) || n, T = (j, W, G) => {
        const ue = Wp(e), we = u ? ue.backwards : ue.forwards;
        return X.from(we(j, W, (fe, ke) => ab(fe.parentNode) ? -1 : (b = fe, G(u, fe, ke)), S));
      };
      return T(s, i, In).bind((j) => p ? T(j.container, j.offset + (u ? -1 : 0), $i) : X.some(j)).orThunk(() => b ? X.some({
        container: b,
        offset: u ? 0 : b.length
      }) : X.none());
    }, Hi = (e, n, s, i, u) => {
      const p = i[u];
      Gt(i) && Zo(i.data) && p && (i = p);
      const b = NE(e, i);
      for (let S = 0; S < b.length; S++)
        for (let T = 0; T < n.length; T++) {
          const M = n[T];
          if (!(Ue(M.collapsed) && M.collapsed !== s.collapsed) && Ku(M) && e.is(b[S], M.selector))
            return b[S];
        }
      return i;
    }, Yu = (e, n, s, i) => {
      var u;
      let p = s;
      const b = e.getRoot(), S = n[0];
      if (Km(S) && (p = S.wrapper ? null : e.getParent(s, S.block, b)), !p) {
        const T = (u = e.getParent(s, "LI,TD,TH,SUMMARY")) !== null && u !== void 0 ? u : b;
        p = e.getParent(Gt(s) ? s.parentNode : s, (M) => M !== b && YI(e.schema, M), T);
      }
      if (p && Km(S) && S.wrapper && (p = NE(e, p, "ul,ol").reverse()[0] || p), !p)
        for (p = s; p && p[i] && !e.isBlock(p[i]) && (p = p[i], !ox(p, "br")); )
          ;
      return p || s;
    }, PC = (e, n, s, i) => {
      const u = s.parentNode;
      return Ue(s[i]) ? !1 : u === n || Vt(u) || e.isBlock(u) ? !0 : PC(e, n, u, i);
    }, Pg = (e, n, s, i, u) => {
      let p = s;
      const b = u ? "previousSibling" : "nextSibling", S = e.getRoot();
      if (Gt(s) && !PE(s) && (u ? i > 0 : i < s.data.length))
        return s;
      for (; p; ) {
        if (!n[0].block_expand && e.isBlock(p))
          return p;
        for (let T = p[b]; T; T = T[b]) {
          const M = Gt(T) && !PC(e, S, T, b);
          if (!ab(T) && !XI(T) && !PE(T, M))
            return p;
        }
        if (p === S || p.parentNode === S) {
          s = p;
          break;
        }
        p = p.parentNode;
      }
      return s;
    }, ix = (e) => ab(e.parentNode) || ab(e), ih = (e, n, s, i = !1) => {
      let { startContainer: u, startOffset: p, endContainer: b, endOffset: S } = n;
      const T = s[0];
      return Tn(u) && u.hasChildNodes() && (u = Mn(u, p), Gt(u) && (p = 0)), Tn(b) && b.hasChildNodes() && (b = Mn(b, n.collapsed ? S : S - 1), Gt(b) && (S = b.data.length)), u = ME(e, u), b = ME(e, b), ix(u) && (u = ab(u) ? u : u.parentNode, n.collapsed ? u = u.previousSibling || u : u = u.nextSibling || u, Gt(u) && (p = n.collapsed ? u.length : 0)), ix(b) && (b = ab(b) ? b : b.parentNode, n.collapsed ? b = b.nextSibling || b : b = b.previousSibling || b, Gt(b) && (S = n.collapsed ? 0 : b.length)), n.collapsed && (A1(e, e.getRoot(), u, p, !0, i).each(({ container: W, offset: G }) => {
        u = W, p = G;
      }), A1(e, e.getRoot(), b, S, !1, i).each(({ container: W, offset: G }) => {
        b = W, S = G;
      })), (Li(T) || T.block_expand) && ((!Li(T) || !Gt(u) || p === 0) && (u = Pg(e, s, u, p, !0)), (!Li(T) || !Gt(b) || S === b.data.length) && (b = Pg(e, s, b, S, !1))), vf(T) && (u = Hi(e, s, n, u, "previousSibling"), b = Hi(e, s, n, b, "nextSibling")), (Km(T) || Ku(T)) && (u = Yu(e, s, u, "previousSibling"), b = Yu(e, s, b, "nextSibling"), Km(T) && (e.isBlock(u) || (u = Pg(e, s, u, p, !0), Gt(u) && (p = 0)), e.isBlock(b) || (b = Pg(e, s, b, S, !1), Gt(b) && (S = b.data.length)))), Tn(u) && u.parentNode && (p = e.nodeIndex(u), u = u.parentNode), Tn(b) && b.parentNode && (S = e.nodeIndex(b) + 1, b = b.parentNode), {
        startContainer: u,
        startOffset: p,
        endContainer: b,
        endOffset: S
      };
    }, O1 = (e, n, s) => {
      var i;
      const u = n.startOffset, p = Mn(n.startContainer, u), b = n.endOffset, S = Mn(n.endContainer, b - 1), T = (ke) => {
        const He = ke[0];
        Gt(He) && He === p && u >= He.data.length && ke.splice(0, 1);
        const Ye = ke[ke.length - 1];
        return b === 0 && ke.length > 0 && Ye === S && Gt(Ye) && ke.splice(ke.length - 1, 1), ke;
      }, M = (ke, He, Ye) => {
        const We = [];
        for (; ke && ke !== Ye; ke = ke[He])
          We.push(ke);
        return We;
      }, j = (ke, He) => e.getParent(ke, (Ye) => Ye.parentNode === He, He), W = (ke, He, Ye) => {
        const We = Ye ? "nextSibling" : "previousSibling";
        for (let ut = ke, Ut = ut.parentNode; ut && ut !== He; ut = Ut) {
          Ut = ut.parentNode;
          const an = M(ut === ke ? ut : ut[We], We);
          an.length && (Ye || an.reverse(), s(T(an)));
        }
      };
      if (p === S)
        return s(T([p]));
      const G = (i = e.findCommonAncestor(p, S)) !== null && i !== void 0 ? i : e.getRoot();
      if (e.isChildOf(p, S))
        return W(p, G, !0);
      if (e.isChildOf(S, p))
        return W(S, G);
      const ue = j(p, G) || p, we = j(S, G) || S;
      W(p, ue, !0);
      const fe = M(ue === p ? ue : ue.nextSibling, "nextSibling", we === S ? we.nextSibling : we);
      fe.length && s(T(fe)), W(S, we);
    }, FE = [
      'pre[class*=language-][contenteditable="false"]',
      "figure.image",
      "div[data-ephox-embed-iri]",
      "div.tiny-pageembed",
      "div.mce-toc",
      "div[data-mce-toc]"
    ], wD = (e) => ft(e) && o1(e) === Ma, CD = (e, n, s, i) => Ni(n).fold(() => "skipping", (u) => i === "br" || wD(n) ? "valid" : pO(n) ? "existing" : wu(n.dom) ? "caret" : Vn(FE, (p) => wl(n, p)) ? "valid-block" : !qm(e, s, i) || !qm(e, fs(u), s) ? "invalid-child" : "valid"), SD = (e, n) => {
      const s = ih(e.dom, n, [{ inline: "span" }]);
      n.setStart(s.startContainer, s.startOffset), n.setEnd(s.endContainer, s.endOffset), e.selection.setRng(n);
    }, lh = (e, n, s, i, u, p) => {
      const { uid: b = n, ...S } = s;
      gd(e, Ov()), is(e, `${Dv()}`, b), is(e, `${Kf()}`, i);
      const { attributes: T = {}, classes: M = [] } = u(b, S);
      if (_a(e, T), ly(e, M), p) {
        M.length > 0 && is(e, `${jp()}`, M.join(","));
        const j = Ms(T);
        j.length > 0 && is(e, `${Yf()}`, j.join(","));
      }
    }, D1 = (e) => {
      fu(e, Ov()), Jr(e, `${Dv()}`), Jr(e, `${Kf()}`), Jr(e, `${ig()}`);
      const n = ua(e, `${Yf()}`).map((i) => i.split(",")).getOr([]), s = ua(e, `${jp()}`).map((i) => i.split(",")).getOr([]);
      je(n, (i) => Jr(e, i)), jI(e, s), Jr(e, `${jp()}`), Jr(e, `${Yf()}`);
    }, R1 = (e, n, s, i, u) => {
      const p = Me.fromTag("span", e);
      return lh(p, n, s, i, u, !1), p;
    }, lx = (e, n, s, i, u, p) => {
      const b = [], S = R1(e.getDoc(), s, p, i, u), T = Ii(), M = () => {
        T.clear();
      }, j = () => T.get().getOrThunk(() => {
        const we = uf(S);
        return b.push(we), T.set(we), we;
      }), W = (we) => {
        je(we, G);
      }, G = (we) => {
        switch (CD(e, we, "span", fs(we))) {
          case "invalid-child": {
            M();
            const ke = Ya(we);
            W(ke), M();
            break;
          }
          case "valid-block": {
            M(), lh(we, s, p, i, u, !0);
            break;
          }
          case "valid": {
            const ke = j();
            Xh(we, ke);
            break;
          }
        }
      }, ue = (we) => {
        const fe = tn(we, Me.fromDom);
        W(fe);
      };
      return O1(e.dom, n, (we) => {
        M(), ue(we);
      }), b;
    }, tu = (e, n, s, i) => {
      e.undoManager.transact(() => {
        const u = e.selection, p = u.getRng(), b = tb(e).length > 0, S = Rv("mce-annotation");
        if (p.collapsed && !b && SD(e, p), u.getRng().collapsed && !b) {
          const T = R1(e.getDoc(), S, i, n, s.decorate);
          yd(T, Xa), u.getRng().insertNode(T.dom), u.select(T.dom);
        } else
          TC(u, !1, () => {
            ob(e, (T) => {
              lx(e, T, S, n, s.decorate, i);
            });
          });
      });
    }, om = (e) => {
      const n = hw();
      ay(e, n);
      const s = pw(e, n), i = Sr("span"), u = (p) => {
        je(p, (b) => {
          i(b) ? Uc(b) : D1(b);
        });
      };
      return {
        register: (p, b) => {
          n.register(p, b);
        },
        annotate: (p, b) => {
          n.lookup(p).each((S) => {
            tu(e, p, S, b);
          });
        },
        annotationChanged: (p, b) => {
          s.addListener(p, b);
        },
        remove: (p) => {
          cg(e, X.some(p)).each(({ elements: b }) => {
            const S = e.selection.getBookmark();
            u(b), e.selection.moveToBookmark(S);
          });
        },
        removeAll: (p) => {
          const b = e.selection.getBookmark();
          qt(h_(e, p), (S, T) => {
            u(S);
          }), e.selection.moveToBookmark(b);
        },
        getAll: (p) => {
          const b = h_(e, p);
          return Ko(b, (S) => tn(S, (T) => T.dom));
        }
      };
    }, ch = (e) => ({
      getBookmark: Je(EE, e),
      moveToBookmark: Je(Gm, e)
    });
    ch.isBookmarkNode = Cu;
    const uh = (e, n, s) => s.collapsed ? !1 : Vn(s.getClientRects(), (i) => wO(i, e, n)), kD = (e, n) => e.dispatch("PreProcess", n), cx = (e, n) => e.dispatch("PostProcess", n), ux = (e) => {
      e.dispatch("remove");
    }, _D = (e) => {
      e.dispatch("detach");
    }, ED = (e, n) => {
      e.dispatch("SwitchMode", { mode: n });
    }, TD = (e, n, s, i, u) => {
      e.dispatch("ObjectResizeStart", {
        target: n,
        width: s,
        height: i,
        origin: u
      });
    }, AD = (e, n, s, i, u) => {
      e.dispatch("ObjectResized", {
        target: n,
        width: s,
        height: i,
        origin: u
      });
    }, BE = (e) => {
      e.dispatch("PreInit");
    }, dx = (e) => {
      e.dispatch("PostRender");
    }, OD = (e) => {
      e.dispatch("Init");
    }, fx = (e, n) => {
      e.dispatch("PlaceholderToggle", { state: n });
    }, hl = (e, n, s) => {
      e.dispatch(n, s);
    }, Xu = (e, n, s, i) => {
      e.dispatch("FormatApply", {
        format: n,
        node: s,
        vars: i
      });
    }, Su = (e, n, s, i) => {
      e.dispatch("FormatRemove", {
        format: n,
        node: s,
        vars: i
      });
    }, mx = (e, n) => e.dispatch("BeforeSetContent", n), px = (e, n) => e.dispatch("SetContent", n), LE = (e, n) => e.dispatch("BeforeGetContent", n), MC = (e, n) => e.dispatch("GetContent", n), $E = (e, n) => {
      e.dispatch("AutocompleterStart", n);
    }, IC = (e, n) => {
      e.dispatch("AutocompleterUpdate", n);
    }, HE = (e, n) => {
      e.dispatch("AutocompleterUpdateActiveRange", n);
    }, zE = (e) => {
      e.dispatch("AutocompleterEnd");
    }, DD = (e, n, s) => e.dispatch("PastePreProcess", {
      content: n,
      internal: s
    }), RD = (e, n, s) => e.dispatch("PastePostProcess", {
      node: n,
      internal: s
    }), hx = (e, n) => e.dispatch("PastePlainTextToggle", { state: n }), FC = (e, n) => e.dispatch("EditableRootStateChange", { state: n }), Qt = {
      BACKSPACE: 8,
      DELETE: 46,
      DOWN: 40,
      ENTER: 13,
      ESC: 27,
      LEFT: 37,
      RIGHT: 39,
      SPACEBAR: 32,
      TAB: 9,
      UP: 38,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      modifierPressed: (e) => e.shiftKey || e.ctrlKey || e.altKey || Qt.metaKeyPressed(e),
      metaKeyPressed: (e) => sn.os.isMacOS() || sn.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey
    }, fc = "data-mce-selected", VE = "table,img,figure.image,hr,video,span.mce-preview-object,details", BC = Math.abs, N1 = Math.round, P1 = {
      nw: [
        0,
        0,
        -1,
        -1
      ],
      ne: [
        1,
        0,
        1,
        -1
      ],
      se: [
        1,
        1,
        1,
        1
      ],
      sw: [
        0,
        1,
        -1,
        1
      ]
    }, gx = (e) => e.type === "longpress" || e.type.indexOf("touch") === 0, M1 = (e, n) => {
      const s = n.dom, i = n.getDoc(), u = document, p = n.getBody();
      let b, S, T, M, j, W, G, ue, we, fe, ke, He, Ye, We, ut, Ut, an;
      const Nn = (On) => Ue(On) && (bv(On) || s.is(On, "figure.image")), Et = (On) => Yi(On) || s.hasClass(On, "mce-preview-object"), bt = (On, us) => {
        if (gx(On)) {
          const ws = On.touches[0];
          return Nn(On.target) && !uh(ws.clientX, ws.clientY, us);
        } else
          return Nn(On.target) && !uh(On.clientX, On.clientY, us);
      }, Ht = (On) => {
        const us = On.target;
        bt(On, n.selection.getRng()) && !On.isDefaultPrevented() && n.selection.select(us);
      }, zn = (On) => s.hasClass(On, "mce-preview-object") && Ue(On.firstElementChild) ? [
        On,
        On.firstElementChild
      ] : s.is(On, "figure.image") ? [On.querySelector("img")] : [On], uo = (On) => {
        const us = vu(n);
        return !us || On.getAttribute("data-mce-resize") === "false" || On === n.getBody() ? !1 : s.hasClass(On, "mce-preview-object") && Ue(On.firstElementChild) ? wl(Me.fromDom(On.firstElementChild), us) : wl(Me.fromDom(On), us);
      }, Go = (On, us) => {
        if (Et(us))
          return On.create("img", { src: sn.transparentSrc });
        if (Hu(us)) {
          const Vi = co(M.name, "n") ? hn : Do, ar = us.cloneNode(!0);
          return Vi(On.select("tr", ar)).each((hi) => {
            const Bd = On.select("td,th", hi);
            On.setStyle(hi, "height", null), je(Bd, (vm) => On.setStyle(vm, "height", null));
          }), ar;
        } else
          return us.cloneNode(!0);
      }, ys = (On, us, ws) => {
        if (Ue(ws)) {
          const Vi = zn(On);
          je(Vi, (ar) => {
            ar.style[us] || !n.schema.isValid(ar.nodeName.toLowerCase(), us) ? s.setStyle(ar, us, ws) : s.setAttrib(ar, us, "" + ws);
          });
        }
      }, Js = (On, us, ws) => {
        ys(On, "width", us), ys(On, "height", ws);
      }, xr = (On) => {
        let us, ws, Vi, ar, hi;
        us = On.screenX - W, ws = On.screenY - G, We = us * M[2] + fe, ut = ws * M[3] + ke, We = We < 5 ? 5 : We, ut = ut < 5 ? 5 : ut, (Nn(b) || Et(b)) && h1(n) !== !1 ? Vi = !Qt.modifierPressed(On) : Vi = Qt.modifierPressed(On), Vi && (BC(us) > BC(ws) ? (ut = N1(We * He), We = N1(ut / He)) : (We = N1(ut / He), ut = N1(We * He))), Js(S, We, ut), ar = M.startPos.x + us, hi = M.startPos.y + ws, ar = ar > 0 ? ar : 0, hi = hi > 0 ? hi : 0, s.setStyles(T, {
          left: ar,
          top: hi,
          display: "block"
        }), T.innerHTML = We + " &times; " + ut, M[2] < 0 && S.clientWidth <= We && s.setStyle(S, "left", ue + (fe - We)), M[3] < 0 && S.clientHeight <= ut && s.setStyle(S, "top", we + (ke - ut)), us = p.scrollWidth - Ut, ws = p.scrollHeight - an, us + ws !== 0 && s.setStyles(T, {
          left: ar - us,
          top: hi - ws
        }), Ye || (TD(n, b, fe, ke, "corner-" + M.name), Ye = !0);
      }, Da = () => {
        const On = Ye;
        Ye = !1, On && (ys(b, "width", We), ys(b, "height", ut)), s.unbind(i, "mousemove", xr), s.unbind(i, "mouseup", Da), u !== i && (s.unbind(u, "mousemove", xr), s.unbind(u, "mouseup", Da)), s.remove(S), s.remove(T), s.remove(j), yl(b), On && (AD(n, b, We, ut, "corner-" + M.name), s.setAttrib(b, "style", s.getAttrib(b, "style"))), n.nodeChanged();
      }, yl = (On) => {
        Sn();
        const us = s.getPos(On, p), ws = us.x, Vi = us.y, ar = On.getBoundingClientRect(), hi = ar.width || ar.right - ar.left, Bd = ar.height || ar.bottom - ar.top;
        b !== On && (mn(), b = On, We = ut = 0);
        const vm = n.dispatch("ObjectSelected", { target: On });
        uo(On) && !vm.isDefaultPrevented() ? qt(P1, (gc, Au) => {
          const rd = (Ld) => {
            const fo = zn(b)[0];
            W = Ld.screenX, G = Ld.screenY, fe = fo.clientWidth, ke = fo.clientHeight, He = ke / fe, M = gc, M.name = Au, M.startPos = {
              x: hi * gc[0] + ws,
              y: Bd * gc[1] + Vi
            }, Ut = p.scrollWidth, an = p.scrollHeight, j = s.add(p, "div", {
              class: "mce-resize-backdrop",
              "data-mce-bogus": "all"
            }), s.setStyles(j, {
              position: "fixed",
              left: "0",
              top: "0",
              width: "100%",
              height: "100%"
            }), S = Go(s, b), s.addClass(S, "mce-clonedresizable"), s.setAttrib(S, "data-mce-bogus", "all"), S.contentEditable = "false", s.setStyles(S, {
              left: ws,
              top: Vi,
              margin: 0
            }), Js(S, hi, Bd), S.removeAttribute(fc), p.appendChild(S), s.bind(i, "mousemove", xr), s.bind(i, "mouseup", Da), u !== i && (s.bind(u, "mousemove", xr), s.bind(u, "mouseup", Da)), T = s.add(p, "div", {
              class: "mce-resize-helper",
              "data-mce-bogus": "all"
            }, fe + " &times; " + ke);
          };
          let Ou = s.get("mceResizeHandle" + Au);
          Ou && s.remove(Ou), Ou = s.add(p, "div", {
            id: "mceResizeHandle" + Au,
            "data-mce-bogus": "all",
            class: "mce-resizehandle",
            unselectable: !0,
            style: "cursor:" + Au + "-resize; margin:0; padding:0"
          }), s.bind(Ou, "mousedown", (Ld) => {
            Ld.stopImmediatePropagation(), Ld.preventDefault(), rd(Ld);
          }), gc.elm = Ou, s.setStyles(Ou, {
            left: hi * gc[0] + ws - Ou.offsetWidth / 2,
            top: Bd * gc[1] + Vi - Ou.offsetHeight / 2
          });
        }) : mn(!1);
      }, mr = n1(yl, 0), mn = (On = !0) => {
        mr.cancel(), Sn(), b && On && b.removeAttribute(fc), qt(P1, (us, ws) => {
          const Vi = s.get("mceResizeHandle" + ws);
          Vi && (s.unbind(Vi), s.remove(Vi));
        });
      }, ro = (On, us) => s.isChildOf(On, us), Hs = (On) => {
        if (Ye || n.removed || n.composing)
          return;
        const us = On.type === "mousedown" ? On.target : e.getNode(), ws = mu(Me.fromDom(us), VE).map((ar) => ar.dom).filter((ar) => s.isEditable(ar.parentElement) || ar.nodeName === "IMG" && s.isEditable(ar)).getOrUndefined(), Vi = Ue(ws) ? s.getAttrib(ws, fc, "1") : "1";
        if (je(s.select(`img[${fc}],hr[${fc}]`), (ar) => {
          ar.removeAttribute(fc);
        }), Ue(ws) && ro(ws, p) && n.hasFocus()) {
          bo();
          const ar = e.getStart(!0);
          if (ro(ar, ws) && ro(e.getEnd(!0), ws)) {
            s.setAttrib(ws, fc, Vi), mr.throttle(ws);
            return;
          }
        }
        mn();
      }, Sn = () => {
        qt(P1, (On) => {
          On.elm && (s.unbind(On.elm), delete On.elm);
        });
      }, bo = () => {
        try {
          n.getDoc().execCommand("enableObjectResizing", !1, "false");
        } catch {
        }
      };
      return n.on("init", () => {
        bo(), n.on("NodeChange ResizeEditor ResizeWindow ResizeContent drop", Hs), n.on("keyup compositionend", (On) => {
          b && b.nodeName === "TABLE" && Hs(On);
        }), n.on("hide blur", mn), n.on("contextmenu longpress", Ht, !0);
      }), n.on("remove", Sn), {
        isResizable: uo,
        showResizeRect: yl,
        hideResizeRect: mn,
        updateResizeRect: Hs,
        destroy: () => {
          mr.cancel(), b = S = j = null;
        }
      };
    }, UE = (e, n) => {
      n.fold((s) => {
        e.setStartBefore(s.dom);
      }, (s, i) => {
        e.setStart(s.dom, i);
      }, (s) => {
        e.setStartAfter(s.dom);
      });
    }, jE = (e, n) => {
      n.fold((s) => {
        e.setEndBefore(s.dom);
      }, (s, i) => {
        e.setEnd(s.dom, i);
      }, (s) => {
        e.setEndAfter(s.dom);
      });
    }, LC = (e, n, s) => {
      const i = e.document.createRange();
      return UE(i, n), jE(i, s), i;
    }, $C = (e, n, s, i, u) => {
      const p = e.document.createRange();
      return p.setStart(n.dom, s), p.setEnd(i.dom, u), p;
    }, Ym = or.generate([
      {
        ltr: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      },
      {
        rtl: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]), HC = (e, n, s) => n(Me.fromDom(s.startContainer), s.startOffset, Me.fromDom(s.endContainer), s.endOffset), WE = (e, n) => n.match({
      domRange: (s) => ({
        ltr: ze(s),
        rtl: X.none
      }),
      relative: (s, i) => ({
        ltr: Ct(() => LC(e, s, i)),
        rtl: Ct(() => X.some(LC(e, i, s)))
      }),
      exact: (s, i, u, p) => ({
        ltr: Ct(() => $C(e, s, i, u, p)),
        rtl: Ct(() => X.some($C(e, u, p, s, i)))
      })
    }), ND = (e, n) => {
      const s = n.ltr();
      return s.collapsed ? n.rtl().filter((u) => u.collapsed === !1).map((u) => Ym.rtl(Me.fromDom(u.endContainer), u.endOffset, Me.fromDom(u.startContainer), u.startOffset)).getOrThunk(() => HC(e, Ym.ltr, s)) : HC(e, Ym.ltr, s);
    }, PD = (e, n) => {
      const s = WE(e, n);
      return ND(e, s);
    };
    Ym.ltr, Ym.rtl;
    const Nc = { create: (e, n, s, i) => ({
      start: e,
      soffset: n,
      finish: s,
      foffset: i
    }) }, Wl = (e, n, s) => {
      var i, u;
      return X.from((u = (i = e.dom).caretPositionFromPoint) === null || u === void 0 ? void 0 : u.call(i, n, s)).bind((p) => {
        if (p.offsetNode === null)
          return X.none();
        const b = e.dom.createRange();
        return b.setStart(p.offsetNode, p.offset), b.collapse(), X.some(b);
      });
    }, ib = (e, n, s) => {
      var i, u;
      return X.from((u = (i = e.dom).caretRangeFromPoint) === null || u === void 0 ? void 0 : u.call(i, n, s));
    }, QI = document.caretPositionFromPoint ? Wl : document.caretRangeFromPoint ? ib : X.none, MD = (e, n, s) => {
      const i = Me.fromDom(e.document);
      return QI(i, n, s).map((u) => Nc.create(Me.fromDom(u.startContainer), u.startOffset, Me.fromDom(u.endContainer), u.endOffset));
    }, zC = or.generate([
      { before: ["element"] },
      {
        on: [
          "element",
          "offset"
        ]
      },
      { after: ["element"] }
    ]), Ds = (e, n, s, i) => e.fold(n, s, i), JI = (e) => e.fold(jt, jt, jt), GE = zC.before, qE = zC.on, eF = zC.after, dh = {
      before: GE,
      on: qE,
      after: eF,
      cata: Ds,
      getStart: JI
    }, I1 = or.generate([
      { domRange: ["rng"] },
      {
        relative: [
          "startSitu",
          "finishSitu"
        ]
      },
      {
        exact: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]), ID = (e) => I1.exact(e.start, e.soffset, e.finish, e.foffset), FD = (e) => e.match({
      domRange: (n) => Me.fromDom(n.startContainer),
      relative: (n, s) => dh.getStart(n),
      exact: (n, s, i, u) => n
    }), BD = I1.domRange, vx = I1.relative, F1 = I1.exact, KE = (e) => {
      const n = FD(e);
      return $c(n);
    }, tF = Nc.create, lb = {
      domRange: BD,
      relative: vx,
      exact: F1,
      exactFromRange: ID,
      getWin: KE,
      range: tF
    }, VC = (e, n) => {
      const s = fs(e);
      return s === "input" ? dh.after(e) : Nt([
        "br",
        "img"
      ], s) ? n === 0 ? dh.before(e) : dh.after(e) : dh.on(e, n);
    }, nF = (e, n) => {
      const s = e.fold(dh.before, VC, dh.after), i = n.fold(dh.before, VC, dh.after);
      return lb.relative(s, i);
    }, YE = (e, n, s, i) => {
      const u = VC(e, n), p = VC(s, i);
      return lb.relative(u, p);
    }, LD = (e) => e.match({
      domRange: (n) => {
        const s = Me.fromDom(n.startContainer), i = Me.fromDom(n.endContainer);
        return YE(s, n.startOffset, i, n.endOffset);
      },
      relative: nF,
      exact: YE
    }), _o = (e, n) => {
      const i = document.createDocumentFragment();
      return je(e, (u) => {
        i.appendChild(u.dom);
      }), Me.fromDom(i);
    }, m = (e) => {
      const n = lb.getWin(e).dom, s = (u, p, b, S) => $C(n, u, p, b, S), i = LD(e);
      return PD(n, i).match({
        ltr: s,
        rtl: s
      });
    }, v = (e, n, s) => MD(e, n, s), C = (e, n, s) => {
      const i = $c(Me.fromDom(s));
      return v(i.dom, e, n).map((u) => {
        const p = s.createRange();
        return p.setStart(u.start.dom, u.soffset), p.setEnd(u.finish.dom, u.foffset), p;
      }).getOrUndefined();
    }, _ = (e, n) => Ue(e) && Ue(n) && e.startContainer === n.startContainer && e.startOffset === n.startOffset && e.endContainer === n.endContainer && e.endOffset === n.endOffset, P = (e, n, s) => {
      let i = e;
      for (; i && i !== n; ) {
        if (s(i))
          return i;
        i = i.parentNode;
      }
      return null;
    }, z = (e, n, s) => P(e, n, s) !== null, Q = (e, n, s) => z(e, n, (i) => i.nodeName === s), le = (e, n) => Jc(e) && !z(e, n, wu), xe = (e, n, s) => {
      const i = n.parentNode;
      if (i) {
        const u = new Pi(n, e.getParent(i, e.isBlock) || e.getRoot());
        let p;
        for (; p = u[s ? "prev" : "next"](); )
          if (Vs(p))
            return !0;
      }
      return !1;
    }, Fe = (e, n) => {
      var s;
      return ((s = e.previousSibling) === null || s === void 0 ? void 0 : s.nodeName) === n;
    }, at = (e, n) => {
      let s = n;
      for (; s && s !== e; ) {
        if (Ls(s))
          return !0;
        s = s.parentNode;
      }
      return !1;
    }, Yt = (e, n, s, i, u) => {
      const p = e.getRoot(), b = e.schema.getNonEmptyElements(), S = u.parentNode;
      let T, M;
      if (!S)
        return X.none();
      const j = e.getParent(S, e.isBlock) || p;
      if (i && Vs(u) && n && e.isEmpty(j))
        return X.some(gt(S, e.nodeIndex(u)));
      const W = new Pi(u, j);
      for (; M = W[i ? "prev" : "next"](); ) {
        if (e.getContentEditableParent(M) === "false" || le(M, p))
          return X.none();
        if (Gt(M) && M.data.length > 0)
          return Q(M, p, "A") ? X.none() : X.some(gt(M, i ? M.data.length : 0));
        if (e.isBlock(M) || b[M.nodeName.toLowerCase()])
          return X.none();
        T = M;
      }
      return ui(T) ? X.none() : s && T ? X.some(gt(T, 0)) : X.none();
    }, _n = (e, n, s, i) => {
      const u = e.getRoot();
      let p, b = !1, S = s ? i.startContainer : i.endContainer, T = s ? i.startOffset : i.endOffset;
      const M = Tn(S) && T === S.childNodes.length, j = e.schema.getNonEmptyElements();
      let W = s;
      if (Jc(S))
        return X.none();
      if (Tn(S) && T > S.childNodes.length - 1 && (W = !1), Pp(S) && (S = u, T = 0), S === u) {
        if (W && (p = S.childNodes[T > 0 ? T - 1 : 0], p && (Jc(p) || j[p.nodeName] || Hu(p))))
          return X.none();
        if (S.hasChildNodes()) {
          if (T = Math.min(!W && T > 0 ? T - 1 : T, S.childNodes.length - 1), S = S.childNodes[T], T = Gt(S) && M ? S.data.length : 0, !n && S === u.lastChild && Hu(S) || at(u, S) || Jc(S) || Tc(S))
            return X.none();
          if (S.hasChildNodes() && !Hu(S)) {
            p = S;
            const G = new Pi(S, u);
            do {
              if (Ls(p) || Jc(p)) {
                b = !1;
                break;
              }
              if (Gt(p) && p.data.length > 0) {
                T = W ? 0 : p.data.length, S = p, b = !0;
                break;
              }
              if (j[p.nodeName.toLowerCase()] && !Va(p)) {
                T = e.nodeIndex(p), S = p.parentNode, W || T++, b = !0;
                break;
              }
            } while (p = W ? G.next() : G.prev());
          }
        }
      }
      return n && (Gt(S) && T === 0 && Yt(e, M, n, !0, S).each((G) => {
        S = G.container(), T = G.offset(), b = !0;
      }), Tn(S) && (p = S.childNodes[T], p || (p = S.childNodes[T - 1]), p && Vs(p) && !Fe(p, "A") && !xe(e, p, !1) && !xe(e, p, !0) && Yt(e, M, n, !0, p).each((G) => {
        S = G.container(), T = G.offset(), b = !0;
      }))), W && !n && Gt(S) && T === S.data.length && Yt(e, M, n, !1, S).each((G) => {
        S = G.container(), T = G.offset(), b = !0;
      }), b && S ? X.some(gt(S, T)) : X.none();
    }, vn = (e, n) => {
      const s = n.collapsed, i = n.cloneRange(), u = gt.fromRangeStart(n);
      return _n(e, s, !0, i).each((p) => {
        (!s || !gt.isAbove(u, p)) && i.setStart(p.container(), p.offset());
      }), s || _n(e, s, !1, i).each((p) => {
        i.setEnd(p.container(), p.offset());
      }), s && i.collapse(!0), _(n, i) ? X.none() : X.some(i);
    }, ln = (e, n) => e.splitText(n), Wn = (e) => {
      let n = e.startContainer, s = e.startOffset, i = e.endContainer, u = e.endOffset;
      if (n === i && Gt(n)) {
        if (s > 0 && s < n.data.length)
          if (i = ln(n, s), n = i.previousSibling, u > s) {
            u = u - s;
            const p = ln(i, u).previousSibling;
            n = i = p, u = p.data.length, s = 0;
          } else
            u = 0;
      } else if (Gt(n) && s > 0 && s < n.data.length && (n = ln(n, s), s = 0), Gt(i) && u > 0 && u < i.data.length) {
        const p = ln(i, u).previousSibling;
        i = p, u = p.data.length;
      }
      return {
        startContainer: n,
        startOffset: s,
        endContainer: i,
        endOffset: u
      };
    }, Wt = (e) => ({
      walk: (p, b) => O1(e, p, b),
      split: Wn,
      expand: (p, b = { type: "word" }) => {
        if (b.type === "word") {
          const S = ih(e, p, [{ inline: "span" }]), T = e.createRng();
          return T.setStart(S.startContainer, S.startOffset), T.setEnd(S.endContainer, S.endOffset), T;
        }
        return p;
      },
      normalize: (p) => vn(e, p).fold(et, (b) => (p.setStart(b.startContainer, b.startOffset), p.setEnd(b.endContainer, b.endOffset), !0))
    });
    Wt.compareRanges = _, Wt.getCaretRangeFromPoint = C, Wt.getSelectedNode = Lv, Wt.getNode = Mn;
    const wo = ((e, n) => {
      const s = (S, T) => {
        if (!Rn(T) && !T.match(/^[0-9]+$/))
          throw new Error(e + ".set accepts only positive integer values. Value was " + T);
        const M = S.dom;
        Jd(M) && (M.style[e] = T + "px");
      }, i = (S) => {
        const T = n(S);
        if (T <= 0 || T === null) {
          const M = da(S, e);
          return parseFloat(M) || 0;
        }
        return T;
      }, u = i, p = (S, T) => vt(T, (M, j) => {
        const W = da(S, j), G = W === void 0 ? 0 : parseInt(W, 10);
        return isNaN(G) ? M : M + G;
      }, 0);
      return {
        set: s,
        get: i,
        getOuter: u,
        aggregate: p,
        max: (S, T, M) => {
          const j = p(S, M);
          return T > j ? T - j : 0;
        }
      };
    })("height", (e) => {
      const n = e.dom;
      return Lu(e) ? n.getBoundingClientRect().height : n.offsetHeight;
    }), yn = (e) => wo.get(e), Ks = () => Me.fromDom(document), yr = (e, n) => e.view(n).fold(ze([]), (i) => {
      const u = e.owner(i), p = yr(e, u);
      return [i].concat(p);
    }), ur = (e, n) => {
      const s = n.owner(e);
      return yr(n, s);
    };
    var sm = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      view: (e) => {
        var n;
        return (e.dom === document ? X.none() : X.from((n = e.dom.defaultView) === null || n === void 0 ? void 0 : n.frameElement)).map(Me.fromDom);
      },
      owner: (e) => Ka(e)
    });
    const fh = (e) => {
      const n = Ks(), s = $t(n), i = ur(e, sm), u = Le(e), p = zt(i, (b, S) => {
        const T = Le(S);
        return {
          left: b.left + T.left,
          top: b.top + T.top
        };
      }, {
        left: 0,
        top: 0
      });
      return R(p.left + u.left + s.left, p.top + u.top + s.top);
    }, mh = (e) => fs(e) === "textarea", sr = (e, n) => e.dispatch("ScrollIntoView", n).isDefaultPrevented(), mc = (e, n) => {
      e.dispatch("AfterScrollIntoView", n);
    }, pc = (e, n) => {
      const s = Ya(e);
      if (s.length === 0 || mh(e))
        return {
          element: e,
          offset: n
        };
      if (n < s.length && !mh(s[n]))
        return {
          element: s[n],
          offset: 0
        };
      {
        const i = s[s.length - 1];
        return mh(i) ? {
          element: e,
          offset: n
        } : fs(i) === "img" ? {
          element: i,
          offset: 1
        } : ft(i) ? {
          element: i,
          offset: o1(i).length
        } : {
          element: i,
          offset: Ya(i).length
        };
      }
    }, Qu = (e, n) => {
      const s = De(e), i = yn(e);
      return {
        element: e,
        bottom: s.top + i,
        height: i,
        pos: s,
        cleanup: n
      };
    }, Ju = (e, n) => {
      const s = pc(e, n), i = Me.fromHtml('<span data-mce-bogus="all" style="display: inline-block;">' + Ma + "</span>");
      return Ki(s.element, i), Qu(i, () => vr(i));
    }, bs = (e) => Qu(Me.fromDom(e), ot), Oa = (e, n, s, i) => {
      zo(e, (u, p) => B1(e, n, s, i), s);
    }, rm = (e, n, s, i, u) => {
      const p = {
        elm: i.element.dom,
        alignToTop: u
      };
      if (sr(e, p))
        return;
      const b = $t(n).top;
      s(e, n, b, i, u), mc(e, p);
    }, B1 = (e, n, s, i) => {
      const u = Me.fromDom(e.getBody()), p = Me.fromDom(e.getDoc());
      Pa(u);
      const b = Ju(Me.fromDom(s.startContainer), s.startOffset);
      rm(e, p, n, b, i), b.cleanup();
    }, nu = (e, n, s, i) => {
      const u = Me.fromDom(e.getDoc());
      rm(e, u, s, bs(n), i);
    }, zo = (e, n, s) => {
      const i = s.startContainer, u = s.startOffset, p = s.endContainer, b = s.endOffset;
      n(Me.fromDom(i), Me.fromDom(p));
      const S = e.dom.createRng();
      S.setStart(i, u), S.setEnd(p, b), e.selection.setRng(s);
    }, UC = (e, n, s, i, u) => {
      const p = n.pos;
      if (i)
        vo(p.left, p.top, u);
      else {
        const b = p.top - s + n.height;
        vo(-e.getBody().getBoundingClientRect().left, b, u);
      }
    }, jC = (e, n, s, i, u, p) => {
      const b = i + s, S = u.pos.top, T = u.bottom, M = T - S >= i;
      S < s ? UC(e, u, i, p !== !1, n) : S > b ? UC(e, u, i, M ? p !== !1 : p === !0, n) : T > b && !M && UC(e, u, i, p === !0, n);
    }, bx = (e, n, s, i, u) => {
      const p = $c(n).dom.innerHeight;
      jC(e, n, s, p, i, u);
    }, XE = (e, n, s, i, u) => {
      const p = $c(n).dom.innerHeight;
      jC(e, n, s, p, i, u);
      const b = fh(i.element), S = Hr(window);
      b.top < S.y ? Lo(i.element, u !== !1) : b.top > S.bottom && Lo(i.element, u === !0);
    }, Mg = (e, n, s) => Oa(e, bx, n, s), Xm = (e, n, s) => nu(e, n, bx, s), QE = (e, n, s) => Oa(e, XE, n, s), L1 = (e, n, s) => nu(e, n, XE, s), xU = (e, n, s) => {
      (e.inline ? Xm : L1)(e, n, s);
    }, WC = (e, n, s) => {
      (e.inline ? Mg : QE)(e, n, s);
    }, yx = (e, n = !1) => e.dom.focus({ preventScroll: n }), $1 = (e) => {
      const n = ec(e).dom;
      return e.dom === n.activeElement;
    }, $D = (e = Ks()) => X.from(e.dom.activeElement).map(Me.fromDom), oF = (e) => $D(ec(e)).filter((n) => e.dom.contains(n.dom)), sF = (e, n) => {
      const s = ft(n) ? o1(n).length : Ya(n).length + 1;
      return e > s ? s : e < 0 ? 0 : e;
    }, wU = (e) => lb.range(e.start, sF(e.soffset, e.start), e.finish, sF(e.foffset, e.finish)), rF = (e, n) => !zf(n.dom) && (Gi(e, n) || Bs(e, n)), HD = (e) => (n) => rF(e, n.start) && rF(e, n.finish), Sre = (e) => e.inline || sn.browser.isFirefox(), CU = (e) => lb.range(Me.fromDom(e.startContainer), e.startOffset, Me.fromDom(e.endContainer), e.endOffset), aF = (e) => {
      const n = e.getSelection();
      return (!n || n.rangeCount === 0 ? X.none() : X.from(n.getRangeAt(0))).map(CU);
    }, zD = (e) => {
      const n = $c(e);
      return aF(n.dom).filter(HD(e));
    }, VD = (e, n) => X.from(n).filter(HD(e)).map(wU), UD = (e) => {
      const n = document.createRange();
      try {
        return n.setStart(e.start.dom, e.soffset), n.setEnd(e.finish.dom, e.foffset), X.some(n);
      } catch {
        return X.none();
      }
    }, ZC = (e) => {
      const n = Sre(e) ? zD(Me.fromDom(e.getBody())) : X.none();
      e.bookmark = n.isSome() ? n : e.bookmark;
    }, JE = (e) => (e.bookmark ? e.bookmark : X.none()).bind((s) => VD(Me.fromDom(e.getBody()), s)).bind(UD), iF = (e) => {
      JE(e).each((n) => e.selection.setRng(n));
    }, lF = { isEditorUIElement: (e) => {
      const n = e.className.toString();
      return n.indexOf("tox-") !== -1 || n.indexOf("mce-") !== -1;
    } }, cF = (e, n) => (Rn(n) || (n = 0), setTimeout(e, n)), SU = (e, n) => (Rn(n) || (n = 0), setInterval(e, n)), Rd = {
      setEditorTimeout: (e, n, s) => cF(() => {
        e.removed || n();
      }, s),
      setEditorInterval: (e, n, s) => {
        const i = SU(() => {
          e.removed ? clearInterval(i) : n();
        }, s);
        return i;
      }
    }, uF = (e) => e.type === "nodechange" && e.selectionChange, dF = (e, n) => {
      const s = () => {
        n.throttle();
      };
      Kr.DOM.bind(document, "mouseup", s), e.on("remove", () => {
        Kr.DOM.unbind(document, "mouseup", s);
      });
    }, fF = (e, n) => {
      e.on("mouseup touchend", (s) => {
        n.throttle();
      });
    }, mF = (e, n) => {
      fF(e, n), e.on("keyup NodeChange AfterSetSelectionRange", (s) => {
        uF(s) || ZC(e);
      });
    }, kU = (e) => {
      const n = n1(() => {
        ZC(e);
      }, 0);
      e.on("init", () => {
        e.inline && dF(e, n), mF(e, n);
      }), e.on("remove", () => {
        n.cancel();
      });
    };
    let xx;
    const WD = Kr.DOM, _U = (e) => Tn(e) && lF.isEditorUIElement(e), ZD = (e) => {
      const n = e.classList;
      return n !== void 0 ? n.contains("tox-edit-area") || n.contains("tox-edit-area__iframe") || n.contains("mce-content-body") : !1;
    }, eT = (e, n) => {
      const s = v1(e);
      return WD.getParent(n, (u) => _U(u) || (s ? e.dom.is(u, s) : !1)) !== null;
    }, GD = (e) => {
      try {
        const n = ec(Me.fromDom(e.getElement()));
        return $D(n).fold(() => document.body, (s) => s.dom);
      } catch {
        return document.body;
      }
    }, EU = (e, n) => {
      const s = n.editor;
      kU(s);
      const i = (u, p) => {
        if (Fy(u) && u.inline !== !0) {
          const b = Me.fromDom(u.getContainer());
          p(b, "tox-edit-focus");
        }
      };
      s.on("focusin", () => {
        const u = e.focusedEditor;
        ZD(GD(s)) && i(s, gd), u !== s && (u && u.dispatch("blur", { focusedEditor: s }), e.setActive(s), e.focusedEditor = s, s.dispatch("focus", { blurredEditor: u }), s.focus(!0));
      }), s.on("focusout", () => {
        Rd.setEditorTimeout(s, () => {
          const u = e.focusedEditor;
          (!ZD(GD(s)) || u !== s) && i(s, fu), !eT(s, GD(s)) && u === s && (s.dispatch("blur", { focusedEditor: null }), e.focusedEditor = null);
        });
      }), xx || (xx = (u) => {
        const p = e.activeEditor;
        p && Ep(u).each((b) => {
          const S = b;
          S.ownerDocument === document && S !== document.body && !eT(p, S) && e.focusedEditor === p && (p.dispatch("blur", { focusedEditor: null }), e.focusedEditor = null);
        });
      }, WD.bind(document, "focusin", xx));
    }, tT = (e, n) => {
      e.focusedEditor === n.editor && (e.focusedEditor = null), !e.activeEditor && xx && (WD.unbind(document, "focusin", xx), xx = null);
    }, pF = (e) => {
      e.on("AddEditor", Je(EU, e)), e.on("RemoveEditor", Je(tT, e));
    }, TU = (e, n) => e.dom.getParent(n, (s) => e.dom.getContentEditable(s) === "true"), hF = (e) => e.collapsed ? X.from(Mn(e.startContainer, e.startOffset)).map(Me.fromDom) : X.none(), gF = (e, n) => hF(n).bind((s) => Iv(s) ? X.some(s) : Gi(e, s) ? X.none() : X.some(e)), vF = (e, n) => {
      gF(Me.fromDom(e.getBody()), n).bind((s) => jl(s.dom)).fold(() => {
        e.selection.normalize();
      }, (s) => e.selection.setRng(s.toRange()));
    }, qD = (e) => {
      if (e.setActive)
        try {
          e.setActive();
        } catch {
          e.focus();
        }
      else
        e.focus();
    }, AU = (e) => $1(e) || oF(e).isSome(), OU = (e) => Ue(e.iframeElement) && $1(Me.fromDom(e.iframeElement)), DU = (e) => {
      const n = e.getBody();
      return n && AU(Me.fromDom(n));
    }, bF = (e) => {
      const n = ec(Me.fromDom(e.getElement()));
      return $D(n).filter((s) => !ZD(s.dom) && eT(e, s.dom)).isSome();
    }, H1 = (e) => e.inline ? DU(e) : OU(e), GC = (e) => H1(e) || bF(e), RU = (e) => {
      const n = e.selection, s = e.getBody();
      let i = n.getRng();
      e.quirks.refreshContentEditable();
      const u = (b) => {
        JE(b).each((S) => {
          b.selection.setRng(S), i = S;
        });
      };
      !H1(e) && e.hasEditableRoot() && u(e);
      const p = TU(e, n.getNode());
      if (p && e.dom.isChildOf(p, s)) {
        qD(p), e.hasEditableRoot() || u(e), vF(e, i), KD(e);
        return;
      }
      e.inline || (sn.browser.isOpera() || qD(s), e.getWin().focus()), (sn.browser.isFirefox() || e.inline) && (qD(s), vF(e, i)), KD(e);
    }, KD = (e) => e.editorManager.setActive(e), YD = (e, n) => {
      e.removed || (n ? KD(e) : RU(e));
    }, yF = (e, n) => n.collapsed ? e.isEditable(n.startContainer) : e.isEditable(n.startContainer) && e.isEditable(n.endContainer), XD = (e, n, s, i, u) => {
      const p = s ? n.startContainer : n.endContainer, b = s ? n.startOffset : n.endOffset;
      return X.from(p).map(Me.fromDom).map((S) => !i || !n.collapsed ? vd(S, u(S, b)).getOr(S) : S).bind((S) => nt(S) ? X.some(S) : Ni(S).filter(nt)).map((S) => S.dom).getOr(e);
    }, QD = (e, n, s = !1) => XD(e, n, !0, s, (i, u) => Math.min(Ci(i), u)), JD = (e, n, s = !1) => XD(e, n, !1, s, (i, u) => u > 0 ? u - 1 : u), xF = (e, n) => {
      const s = e;
      for (; e && Gt(e) && e.length === 0; )
        e = n ? e.nextSibling : e.previousSibling;
      return e || s;
    }, NU = (e, n) => {
      if (!n)
        return e;
      let s = n.startContainer, i = n.endContainer;
      const u = n.startOffset, p = n.endOffset;
      let b = n.commonAncestorContainer;
      n.collapsed || (s === i && p - u < 2 && s.hasChildNodes() && (b = s.childNodes[u]), Gt(s) && Gt(i) && (s.length === u ? s = xF(s.nextSibling, !0) : s = s.parentNode, p === 0 ? i = xF(i.previousSibling, !1) : i = i.parentNode, s && s === i && (b = s)));
      const S = Gt(b) ? b.parentNode : b;
      return Ec(S) ? S : e;
    }, PU = (e, n, s, i) => {
      const u = [], p = e.getRoot(), b = e.getParent(s || QD(p, n, n.collapsed), e.isBlock), S = e.getParent(i || JD(p, n, n.collapsed), e.isBlock);
      if (b && b !== p && u.push(b), b && S && b !== S) {
        let T;
        const M = new Pi(b, p);
        for (; (T = M.next()) && T !== S; )
          e.isBlock(T) && u.push(T);
      }
      return S && b !== S && S !== p && u.push(S), u;
    }, MU = (e, n, s) => X.from(n).bind((i) => X.from(i.parentNode).map((u) => {
      const p = e.nodeIndex(i), b = e.createRng();
      return b.setStart(u, p), b.setEnd(u, p + 1), s && (_C(e, b, i, !0), _C(e, b, i, !1)), b;
    })), wx = (e, n) => tn(n, (s) => {
      const i = e.dispatch("GetSelectionRange", { range: s });
      return i.range !== s ? i.range : s;
    }), wF = {
      "#text": 3,
      "#comment": 8,
      "#cdata": 4,
      "#pi": 7,
      "#doctype": 10,
      "#document-fragment": 11
    }, qC = (e, n, s) => {
      const i = s ? "lastChild" : "firstChild", u = s ? "prev" : "next";
      if (e[i])
        return e[i];
      if (e !== n) {
        let p = e[u];
        if (p)
          return p;
        for (let b = e.parent; b && b !== n; b = b.parent)
          if (p = b[u], p)
            return p;
      }
    }, CF = (e) => {
      var n;
      const s = (n = e.value) !== null && n !== void 0 ? n : "";
      if (!jc(s))
        return !1;
      const i = e.parent;
      return !(i && (i.name !== "span" || i.attr("style")) && /^[ ]+$/.test(s));
    }, eR = (e) => {
      const n = e.name === "a" && !e.attr("href") && e.attr("id");
      return e.attr("name") || e.attr("id") && !e.firstChild || e.attr("data-mce-bookmark") || n;
    };
    class ou {
      static create(n, s) {
        const i = new ou(n, wF[n] || 1);
        return s && qt(s, (u, p) => {
          i.attr(p, u);
        }), i;
      }
      constructor(n, s) {
        this.name = n, this.type = s, s === 1 && (this.attributes = [], this.attributes.map = {});
      }
      replace(n) {
        const s = this;
        return n.parent && n.remove(), s.insert(n, s), s.remove(), s;
      }
      attr(n, s) {
        const i = this;
        if (!U(n))
          return Ue(n) && qt(n, (p, b) => {
            i.attr(b, p);
          }), i;
        const u = i.attributes;
        if (u) {
          if (s !== void 0) {
            if (s === null) {
              if (n in u.map) {
                delete u.map[n];
                let p = u.length;
                for (; p--; )
                  if (u[p].name === n)
                    return u.splice(p, 1), i;
              }
              return i;
            }
            if (n in u.map) {
              let p = u.length;
              for (; p--; )
                if (u[p].name === n) {
                  u[p].value = s;
                  break;
                }
            } else
              u.push({
                name: n,
                value: s
              });
            return u.map[n] = s, i;
          }
          return u.map[n];
        }
      }
      clone() {
        const n = this, s = new ou(n.name, n.type), i = n.attributes;
        if (i) {
          const u = [];
          u.map = {};
          for (let p = 0, b = i.length; p < b; p++) {
            const S = i[p];
            S.name !== "id" && (u[u.length] = {
              name: S.name,
              value: S.value
            }, u.map[S.name] = S.value);
          }
          s.attributes = u;
        }
        return s.value = n.value, s;
      }
      wrap(n) {
        const s = this;
        return s.parent && (s.parent.insert(n, s), n.append(s)), s;
      }
      unwrap() {
        const n = this;
        for (let s = n.firstChild; s; ) {
          const i = s.next;
          n.insert(s, n, !0), s = i;
        }
        n.remove();
      }
      remove() {
        const n = this, s = n.parent, i = n.next, u = n.prev;
        return s && (s.firstChild === n ? (s.firstChild = i, i && (i.prev = null)) : u && (u.next = i), s.lastChild === n ? (s.lastChild = u, u && (u.next = null)) : i && (i.prev = u), n.parent = n.next = n.prev = null), n;
      }
      append(n) {
        const s = this;
        n.parent && n.remove();
        const i = s.lastChild;
        return i ? (i.next = n, n.prev = i, s.lastChild = n) : s.lastChild = s.firstChild = n, n.parent = s, n;
      }
      insert(n, s, i) {
        n.parent && n.remove();
        const u = s.parent || this;
        return i ? (s === u.firstChild ? u.firstChild = n : s.prev && (s.prev.next = n), n.prev = s.prev, n.next = s, s.prev = n) : (s === u.lastChild ? u.lastChild = n : s.next && (s.next.prev = n), n.next = s.next, n.prev = s, s.next = n), n.parent = u, n;
      }
      getAll(n) {
        const s = this, i = [];
        for (let u = s.firstChild; u; u = qC(u, s))
          u.name === n && i.push(u);
        return i;
      }
      children() {
        const n = this, s = [];
        for (let i = n.firstChild; i; i = i.next)
          s.push(i);
        return s;
      }
      empty() {
        const n = this;
        if (n.firstChild) {
          const s = [];
          for (let u = n.firstChild; u; u = qC(u, n))
            s.push(u);
          let i = s.length;
          for (; i--; ) {
            const u = s[i];
            u.parent = u.firstChild = u.lastChild = u.next = u.prev = null;
          }
        }
        return n.firstChild = n.lastChild = null, n;
      }
      isEmpty(n, s = {}, i) {
        var u;
        const p = this;
        let b = p.firstChild;
        if (eR(p))
          return !1;
        if (b)
          do {
            if (b.type === 1) {
              if (b.attr("data-mce-bogus"))
                continue;
              if (n[b.name] || eR(b))
                return !1;
            }
            if (b.type === 8 || b.type === 3 && !CF(b) || b.type === 3 && b.parent && s[b.parent.name] && jc((u = b.value) !== null && u !== void 0 ? u : "") || i && i(b))
              return !1;
          } while (b = qC(b, p));
        return !0;
      }
      walk(n) {
        return qC(this, null, n);
      }
    }
    const IU = Kt.makeMap("NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT", " "), SF = (e) => U(e.nodeValue) && e.nodeValue.includes(Ma), kF = (e) => `${e.length === 0 ? "" : `${tn(e, (n) => `[${n}]`).join(",")},`}[data-mce-bogus="all"]`, FU = (e, n) => n.querySelectorAll(kF(e)), _F = (e) => document.createTreeWalker(e, NodeFilter.SHOW_COMMENT, (n) => SF(n) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP), EF = (e) => document.createTreeWalker(e, NodeFilter.SHOW_TEXT, (n) => {
      if (SF(n)) {
        const s = n.parentNode;
        return s && Xn(IU, s.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      } else
        return NodeFilter.FILTER_SKIP;
    }), BU = (e) => _F(e).nextNode() !== null, LU = (e) => EF(e).nextNode() !== null, $U = (e, n) => n.querySelector(kF(e)) !== null, HU = (e, n) => {
      je(FU(e, n), (s) => {
        const i = Me.fromDom(s);
        Rr(i, "data-mce-bogus") === "all" ? vr(i) : je(e, (u) => {
          oa(i, u) && Jr(i, u);
        });
      });
    }, TF = (e) => {
      let n = e.nextNode();
      for (; n !== null; )
        n.nodeValue = null, n = e.nextNode();
    }, nT = B(TF, _F), AF = B(TF, EF), tR = (e, n) => {
      const s = [
        {
          condition: Je($U, n),
          action: Je(HU, n)
        },
        {
          condition: BU,
          action: nT
        },
        {
          condition: LU,
          action: AF
        }
      ];
      let i = e, u = !1;
      return je(s, ({ condition: p, action: b }) => {
        p(i) && (u || (i = e.cloneNode(!0), u = !0), b(i));
      }), i;
    }, OF = (e) => {
      const n = va(e, "[data-mce-bogus]");
      je(n, (s) => {
        Rr(s, "data-mce-bogus") === "all" ? vr(s) : Mv(s) ? (Ki(s, Me.fromText(vv)), vr(s)) : Uc(s);
      });
    }, DF = (e) => {
      const n = va(e, "input");
      je(n, (s) => {
        Jr(s, "name");
      });
    }, zU = (e, n) => {
      const s = Dl(e), i = new RegExp(`^(<${s}[^>]*>(&nbsp;|&#160;|\\s| |<br \\/>|)<\\/${s}>[\r
]*|<br \\/>[\r
]*)$`);
      return n.replace(i, "");
    }, VU = (e, n) => {
      const s = e.getDoc(), i = ec(Me.fromDom(e.getBody())), u = Me.fromTag("div", s);
      is(u, "data-mce-bogus", "all"), Ho(u, {
        position: "fixed",
        left: "-9999999px",
        top: "0"
      }), yd(u, n.innerHTML), OF(u), DF(u);
      const p = dv(i);
      Zr(p, u);
      const b = Qc(u.dom.innerText);
      return vr(u), b;
    }, UU = (e, n, s) => {
      let i;
      return n.format === "raw" ? i = Kt.trim(Qc(tR(s, e.serializer.getTempAttrs()).innerHTML)) : n.format === "text" ? i = VU(e, s) : n.format === "tree" ? i = e.serializer.serialize(s, n) : i = zU(e, e.serializer.serialize(s, n)), n.format !== "text" && !r1(Me.fromDom(s)) && U(i) ? Kt.trim(i) : i;
    }, jU = (e, n) => X.from(e.getBody()).fold(ze(n.format === "tree" ? new ou("body", 11) : ""), (s) => UU(e, n, s)), nR = Kt.makeMap, RF = (e) => {
      const n = [];
      e = e || {};
      const s = e.indent, i = nR(e.indent_before || ""), u = nR(e.indent_after || ""), p = rf.getEncodeFunc(e.entity_encoding || "raw", e.entities), b = e.element_format !== "xhtml";
      return {
        start: (S, T, M) => {
          if (s && i[S] && n.length > 0) {
            const j = n[n.length - 1];
            j.length > 0 && j !== `
` && n.push(`
`);
          }
          if (n.push("<", S), T)
            for (let j = 0, W = T.length; j < W; j++) {
              const G = T[j];
              n.push(" ", G.name, '="', p(G.value, !0), '"');
            }
          if (!M || b ? n[n.length] = ">" : n[n.length] = " />", M && s && u[S] && n.length > 0) {
            const j = n[n.length - 1];
            j.length > 0 && j !== `
` && n.push(`
`);
          }
        },
        end: (S) => {
          let T;
          n.push("</", S, ">"), s && u[S] && n.length > 0 && (T = n[n.length - 1], T.length > 0 && T !== `
` && n.push(`
`));
        },
        text: (S, T) => {
          S.length > 0 && (n[n.length] = T ? S : p(S));
        },
        cdata: (S) => {
          n.push("<![CDATA[", S, "]]>");
        },
        comment: (S) => {
          n.push("<!--", S, "-->");
        },
        pi: (S, T) => {
          T ? n.push("<?", S, " ", p(T), "?>") : n.push("<?", S, "?>"), s && n.push(`
`);
        },
        doctype: (S) => {
          n.push("<!DOCTYPE", S, ">", s ? `
` : "");
        },
        reset: () => {
          n.length = 0;
        },
        getContent: () => n.join("").replace(/\n$/, "")
      };
    }, Ig = (e = {}, n = Gf()) => {
      const s = RF(e);
      return e.validate = "validate" in e ? e.validate : !0, { serialize: (u) => {
        const p = e.validate, b = {
          3: (T) => {
            var M;
            s.text((M = T.value) !== null && M !== void 0 ? M : "", T.raw);
          },
          8: (T) => {
            var M;
            s.comment((M = T.value) !== null && M !== void 0 ? M : "");
          },
          7: (T) => {
            s.pi(T.name, T.value);
          },
          10: (T) => {
            var M;
            s.doctype((M = T.value) !== null && M !== void 0 ? M : "");
          },
          4: (T) => {
            var M;
            s.cdata((M = T.value) !== null && M !== void 0 ? M : "");
          },
          11: (T) => {
            let M = T;
            if (M = M.firstChild)
              do
                S(M);
              while (M = M.next);
          }
        };
        s.reset();
        const S = (T) => {
          var M;
          const j = b[T.type];
          if (j)
            j(T);
          else {
            const W = T.name, G = W in n.getVoidElements();
            let ue = T.attributes;
            if (p && ue && ue.length > 1) {
              const we = [];
              we.map = {};
              const fe = n.getElementRule(T.name);
              if (fe) {
                for (let ke = 0, He = fe.attributesOrder.length; ke < He; ke++) {
                  const Ye = fe.attributesOrder[ke];
                  if (Ye in ue.map) {
                    const We = ue.map[Ye];
                    we.map[Ye] = We, we.push({
                      name: Ye,
                      value: We
                    });
                  }
                }
                for (let ke = 0, He = ue.length; ke < He; ke++) {
                  const Ye = ue[ke].name;
                  if (!(Ye in we.map)) {
                    const We = ue.map[Ye];
                    we.map[Ye] = We, we.push({
                      name: Ye,
                      value: We
                    });
                  }
                }
                ue = we;
              }
            }
            if (s.start(W, ue, G), Ea(W))
              U(T.value) && s.text(T.value, !0), s.end(W);
            else if (!G) {
              let we = T.firstChild;
              if (we) {
                (W === "pre" || W === "textarea") && we.type === 3 && ((M = we.value) === null || M === void 0 ? void 0 : M[0]) === `
` && s.text(`
`, !0);
                do
                  S(we);
                while (we = we.next);
              }
              s.end(W);
            }
          }
        };
        return u.type === 1 && !e.inner ? S(u) : u.type === 3 ? b[3](u) : b[11](u), s.getContent();
      } };
    }, oR = /* @__PURE__ */ new Set();
    je([
      "margin",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-bottom",
      "padding",
      "padding-left",
      "padding-right",
      "padding-top",
      "padding-bottom",
      "border",
      "border-width",
      "border-style",
      "border-color",
      "background",
      "background-attachment",
      "background-clip",
      "background-image",
      "background-origin",
      "background-position",
      "background-repeat",
      "background-size",
      "float",
      "position",
      "left",
      "right",
      "top",
      "bottom",
      "z-index",
      "display",
      "transform",
      "width",
      "max-width",
      "min-width",
      "height",
      "max-height",
      "min-height",
      "overflow",
      "overflow-x",
      "overflow-y",
      "text-overflow",
      "vertical-align",
      "transition",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function"
    ], (n) => {
      oR.add(n);
    });
    const NF = /* @__PURE__ */ new Set();
    je(["background-color"], (n) => {
      NF.add(n);
    });
    const PF = [
      "font",
      "text-decoration",
      "text-emphasis"
    ], WU = (e, n) => e.parseStyle(e.getAttrib(n, "style")), Cx = (e, n) => Ms(WU(e, n)), ZU = (e) => oR.has(e), GU = (e) => NF.has(e), MF = (e, n) => Vn(Cx(e, n), (s) => ZU(s)), qU = (e, n) => MF(e, n) && Vn(Cx(e, n), (s) => GU(s)), KU = (e) => on(e, (n) => Vn(PF, (s) => co(n, s))), YU = (e, n, s) => {
      const i = Cx(e, n), u = Cx(e, s), p = (b) => {
        var S, T;
        const M = (S = e.getStyle(n, b)) !== null && S !== void 0 ? S : "", j = (T = e.getStyle(s, b)) !== null && T !== void 0 ? T : "";
        return ko(M) && ko(j) && M !== j;
      };
      return Vn(i, (b) => {
        const S = (T) => Vn(T, (M) => M === b);
        if (!S(u) && S(PF)) {
          const T = KU(u);
          return Vn(T, p);
        } else
          return p(b);
      });
    }, IF = (e, n, s) => X.from(s.container()).filter(Gt).exists((i) => {
      const u = e ? 0 : -1;
      return n(i.data.charAt(s.offset() + u));
    }), sR = Je(IF, !0, Og), rR = Je(IF, !1, Og), XU = (e) => {
      const n = e.container();
      return Gt(n) && (n.data.length === 0 || dg(n.data) && ch.isBookmarkNode(n.parentNode));
    }, cb = (e, n) => (s) => Wy(e ? 0 : -1, s).filter(n).isSome(), FF = (e) => bv(e) && da(Me.fromDom(e), "display") === "block", BF = (e) => Ls(e) && !Jh(e), QU = cb(!0, FF), JU = cb(!1, FF), so = cb(!0, Yi), Sx = cb(!1, Yi), aR = cb(!0, Hu), iR = cb(!1, Hu), ph = cb(!0, BF), ub = cb(!1, BF), ej = (e) => e.slice(0, -1), tj = (e, n, s) => Gi(n, e) ? ej(Zh(e, (i) => s(i) || Bs(i, n))) : [], LF = (e, n) => tj(e, n, et), Fg = (e, n) => [e].concat(LF(e, n)), kx = (e, n, s) => CE(e, n, s, XU), $F = (e) => (n) => e.isBlock(fs(n)), nj = (e, n, s) => Dn(Fg(Me.fromDom(n.container()), e), $F(s)), HF = (e, n, s, i) => kx(e, n.dom, s).forall((u) => nj(n, s, i).fold(() => !bu(u, s, n.dom), (p) => !bu(u, s, n.dom) && Gi(p, Me.fromDom(u.container())))), Po = (e, n, s, i) => nj(n, s, i).fold(() => kx(e, n.dom, s).forall((u) => !bu(u, s, n.dom)), (u) => kx(e, u.dom, s).isNone()), lR = Je(Po, !1), jo = Je(Po, !0), zF = Je(HF, !1), kre = Je(HF, !0), _re = (e) => Gy(e).exists(Mv), oT = (e, n, s, i) => {
      const u = on(Fg(Me.fromDom(s.container()), n), (b) => i.isBlock(fs(b))), p = hn(u).getOr(n);
      return yu(e, p.dom, s).filter(_re);
    }, VF = (e, n, s) => Gy(n).exists(Mv) || oT(!0, e, n, s).isSome(), cR = (e, n, s) => gE(n).exists(Mv) || oT(!1, e, n, s).isSome(), UF = Je(oT, !1), oj = Je(oT, !0), To = (e) => gt.isTextPosition(e) && !e.isAtStart() && !e.isAtEnd(), jF = (e, n, s) => {
      const i = on(Fg(Me.fromDom(n.container()), e), (u) => s.isBlock(fs(u)));
      return hn(i).getOr(e);
    }, WF = (e, n, s) => To(n) ? rR(n) : rR(n) || eu(jF(e, n, s).dom, n).exists(rR), ZF = (e, n, s) => To(n) ? sR(n) : sR(n) || Ul(jF(e, n, s).dom, n).exists(sR), KC = (e) => Nt([
      "pre",
      "pre-wrap"
    ], e), sT = (e) => Gy(e).bind((n) => sa(n, nt)).exists((n) => KC(da(n, "white-space"))), sj = (e, n) => eu(e.dom, n).isNone(), rj = (e, n) => Ul(e.dom, n).isNone(), aj = (e, n, s) => sj(e, n) || rj(e, n) || lR(e, n, s) || jo(e, n, s) || cR(e, n, s) || VF(e, n, s), GF = (e) => Ue(e) && Ls(e) && cC(e), qF = (e, n) => (s) => GF(new Pi(s, e)[n]()), Ere = (e, n) => {
      const s = Ul(e.dom, n).getOr(n), i = qF(e.dom, "next");
      return n.isAtEnd() && (i(n.container()) || i(s.container()));
    }, Tre = (e, n) => {
      const s = eu(e.dom, n).getOr(n), i = qF(e.dom, "prev");
      return n.isAtStart() && (i(n.container()) || i(s.container()));
    }, KF = (e, n, s) => sT(n) ? !1 : aj(e, n, s) || WF(e, n, s) || ZF(e, n, s), YC = (e, n, s) => sT(n) ? !1 : lR(e, n, s) || zF(e, n, s) || cR(e, n, s) || WF(e, n, s) || Tre(e, n), ij = (e) => {
      const n = e.container(), s = e.offset();
      return Gt(n) && s < n.data.length ? gt(n, s + 1) : e;
    }, XC = (e, n, s) => sT(n) ? !1 : jo(e, n, s) || kre(e, n, s) || VF(e, n, s) || ZF(e, n, s) || Ere(e, n), rT = (e, n, s) => YC(e, n, s) || XC(e, ij(n), s), YF = (e, n) => tm(e.charAt(n)), ns = (e, n) => Og(e.charAt(n)), XF = (e) => {
      const n = e.container();
      return Gt(n) && Qn(n.data, Xa);
    }, aT = (e) => {
      const n = e.split("");
      return tn(n, (s, i) => tm(s) && i > 0 && i < n.length - 1 && SC(n[i - 1]) && SC(n[i + 1]) ? " " : s).join("");
    }, uR = (e, n, s, i) => {
      const u = n.data, p = gt(n, 0);
      return !s && YF(u, 0) && !rT(e, p, i) ? (n.data = " " + u.slice(1), !0) : s && ns(u, 0) && YC(e, p, i) ? (n.data = Xa + u.slice(1), !0) : !1;
    }, QF = (e) => {
      const n = e.data, s = aT(n);
      return s !== n ? (e.data = s, !0) : !1;
    }, dR = (e, n, s, i) => {
      const u = n.data, p = gt(n, u.length - 1);
      return !s && YF(u, u.length - 1) && !rT(e, p, i) ? (n.data = u.slice(0, -1) + " ", !0) : s && ns(u, u.length - 1) && XC(e, p, i) ? (n.data = u.slice(0, -1) + Xa, !0) : !1;
    }, JF = (e, n, s) => {
      const i = n.container();
      if (!Gt(i))
        return X.none();
      if (XF(n)) {
        const u = uR(e, i, !1, s) || QF(i) || dR(e, i, !1, s);
        return gs(u, n);
      } else if (rT(e, n, s)) {
        const u = uR(e, i, !0, s) || dR(e, i, !0, s);
        return gs(u, n);
      } else
        return X.none();
    }, eB = (e) => {
      const n = Me.fromDom(e.getBody());
      e.selection.isCollapsed() && JF(n, gt.fromRangeStart(e.selection.getRng()), e.schema).each((s) => {
        e.selection.setRng(s.toRange());
      });
    }, tB = (e, n, s, i) => {
      if (s === 0)
        return;
      const u = Me.fromDom(e), p = Nr(u, (M) => i.isBlock(fs(M))).getOr(u), b = e.data.slice(n, n + s), S = n + s >= e.data.length && XC(p, gt(e, e.data.length), i), T = n === 0 && YC(p, gt(e, 0), i);
      e.replaceData(n, s, pu(b, 4, T, S));
    }, QC = (e, n, s) => {
      const i = e.data.slice(n), u = i.length - Ti(i).length;
      tB(e, n, u, s);
    }, fR = (e, n, s) => {
      const i = e.data.slice(0, n), u = i.length - Ai(i).length;
      tB(e, n - u, u, s);
    }, mR = (e, n, s, i, u = !0) => {
      const p = Ai(e.data).length, b = u ? e : n, S = u ? n : e;
      return u ? b.appendData(S.data) : b.insertData(0, S.data), vr(Me.fromDom(S)), i && QC(b, p, s), b;
    }, lj = (e, n) => {
      const s = e.container(), i = e.offset();
      return !gt.isTextPosition(e) && s === n.parentNode && i > gt.before(n).offset();
    }, cj = (e, n) => lj(n, e) ? gt(n.container(), n.offset() - 1) : n, uj = (e) => Gt(e) ? gt(e, 0) : gt.before(e), dj = (e) => Gt(e) ? gt(e, e.data.length) : gt.after(e), nB = (e) => mf(e.previousSibling) ? X.some(dj(e.previousSibling)) : e.previousSibling ? xu(e.previousSibling) : X.none(), oB = (e) => mf(e.nextSibling) ? X.some(uj(e.nextSibling)) : e.nextSibling ? jl(e.nextSibling) : X.none(), pR = (e, n) => X.from(n.previousSibling ? n.previousSibling : n.parentNode).bind((s) => eu(e, gt.before(s))).orThunk(() => Ul(e, gt.after(n))), hR = (e, n) => Ul(e, gt.after(n)).orThunk(() => eu(e, gt.before(n))), fj = (e, n) => nB(n).orThunk(() => oB(n)).orThunk(() => pR(e, n)), mj = (e, n) => oB(n).orThunk(() => nB(n)).orThunk(() => hR(e, n)), pj = (e, n, s) => e ? mj(n, s) : fj(n, s), hj = (e, n, s) => pj(e, n, s).map(Je(cj, s)), sB = (e, n, s) => {
      s.fold(() => {
        e.focus();
      }, (i) => {
        e.selection.setRng(i.toRange(), n);
      });
    }, gj = (e) => (n) => n.dom === e, vj = (e, n) => n && Xn(e.schema.getBlockElements(), fs(n)), bj = (e, n, s) => {
      if (kr(e, n)) {
        const i = Me.fromHtml('<br data-mce-bogus="1">');
        return s ? je(Ya(n), (u) => {
          T1(u) || vr(u);
        }) : Vc(n), Zr(n, i), X.some(gt.before(i.dom));
      } else
        return X.none();
    }, rB = (e, n, s, i) => {
      const u = Jl(e).filter(ft), p = zc(e).filter(ft);
      return vr(e), Ll(u, p, n, (b, S, T) => {
        const M = b.dom, j = S.dom, W = M.data.length;
        return mR(M, j, s, i), T.container() === j ? gt(M, W) : T;
      }).orThunk(() => (i && (u.each((b) => fR(b.dom, b.dom.length, s)), p.each((b) => QC(b.dom, 0, s))), n));
    }, yj = (e, n) => Xn(e.schema.getTextInlineElements(), fs(n)), z1 = (e, n, s, i = !0, u = !1) => {
      const p = hj(n, e.getBody(), s.dom), b = Nr(s, Je(vj, e), gj(e.getBody())), S = rB(s, p, e.schema, yj(e, s));
      e.dom.isEmpty(e.getBody()) ? (e.setContent(""), e.selection.setCursorLocation()) : b.bind((T) => bj(e.schema, T, u)).fold(() => {
        i && sB(e, n, S);
      }, (T) => {
        i && sB(e, n, X.some(T));
      });
    }, V1 = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/, xj = (e) => V1.test(e), db = (e, n) => wl(Me.fromDom(n), jO(e)) && !Uu(e.schema, n) && e.dom.isEditable(n), aB = (e) => {
      var n;
      return Kr.DOM.getStyle(e, "direction", !0) === "rtl" || xj((n = e.textContent) !== null && n !== void 0 ? n : "");
    }, wj = (e, n, s) => on(Kr.DOM.getParents(s.container(), "*", n), e), Bg = (e, n, s) => {
      const i = wj(e, n, s);
      return X.from(i[i.length - 1]);
    }, iB = (e, n, s) => {
      const i = gf(n, e), u = gf(s, e);
      return Ue(i) && i === u;
    }, lB = (e) => ww(e) || mg(e), Nd = (e, n) => {
      const s = n.container(), i = n.offset();
      return e ? ff(s) ? Gt(s.nextSibling) ? gt(s.nextSibling, 0) : gt.after(s) : ww(n) ? gt(s, i + 1) : n : ff(s) ? Gt(s.previousSibling) ? gt(s.previousSibling, s.previousSibling.data.length) : gt.before(s) : mg(n) ? gt(s, i - 1) : n;
    }, Pc = Je(Nd, !0), cB = Je(Nd, !1), uB = (e, n) => {
      const s = (i) => i.stopImmediatePropagation();
      e.on("beforeinput input", s, !0), e.getDoc().execCommand(n), e.off("beforeinput input", s);
    }, Cj = (e) => {
      e.execCommand("delete");
    }, iT = (e) => uB(e, "Delete"), dB = (e) => uB(e, "ForwardDelete"), U1 = (e) => (n) => lr(Ni(n), e, Bs), Sj = (e) => x_(e) || Dc(e), lT = (e, n) => Gi(e, n) ? sa(n, Sj, U1(e)) : X.none(), aa = (e, n = !0) => {
      e.dom.isEmpty(e.getBody()) && e.setContent("", { no_selection: !n });
    }, JC = (e, n, s) => ga(jl(s), xu(s), (i, u) => {
      const p = Nd(!0, i), b = Nd(!1, u), S = Nd(!1, n);
      return e ? Ul(s, S).exists((T) => T.isEqual(b) && n.isEqual(p)) : eu(s, S).exists((T) => T.isEqual(p) && n.isEqual(b));
    }).getOr(!0), j1 = (e) => (me(e) ? Jl(e) : _c(e)).bind(j1).orThunk(() => X.some(e)), fB = (e, n, s, i = !0) => {
      var u;
      n.deleteContents();
      const p = j1(s).getOr(s), b = Me.fromDom((u = e.dom.getParent(p.dom, e.dom.isBlock)) !== null && u !== void 0 ? u : s.dom);
      if (b.dom === e.getBody() ? aa(e, i) : kr(e.schema, b, { checkRootAsContent: !1 }) && (Xc(b), i && e.selection.setCursorLocation(b.dom, 0)), !Bs(s, b)) {
        const S = lr(Ni(b), s) ? [] : uv(b);
        je(S.concat(Ya(s)), (T) => {
          !Bs(T, b) && !Gi(T, b) && kr(e.schema, T) && vr(T);
        });
      }
    }, _x = (e) => (n) => Bs(e, n), ed = (e) => va(e, "td,th"), Ex = (e, n) => k1(Me.fromDom(e), n), Fr = (e) => ga(e.startTable, e.endTable, (n, s) => {
      const i = Vb(n, (p) => Bs(p, s)), u = Vb(s, (p) => Bs(p, n));
      return !i && !u ? e : {
        ...e,
        startTable: i ? X.none() : e.startTable,
        endTable: u ? X.none() : e.endTable,
        isSameTable: !1,
        isMultiTable: !1
      };
    }).getOr(e), eS = (e) => Fr(e), mB = (e, n) => {
      const s = Ex(e.startContainer, n), i = Ex(e.endContainer, n), u = s.isSome(), p = i.isSome(), b = ga(s, i, Bs).getOr(!1);
      return eS({
        startTable: s,
        endTable: i,
        isStartInTable: u,
        isEndInTable: p,
        isSameTable: b,
        isMultiTable: !b && u && p
      });
    }, cT = (e, n) => ({
      start: e,
      end: n
    }), gR = (e, n, s) => ({
      rng: e,
      table: n,
      cells: s
    }), W1 = or.generate([
      {
        singleCellTable: [
          "rng",
          "cell"
        ]
      },
      { fullTable: ["table"] },
      {
        partialTable: [
          "cells",
          "outsideDetails"
        ]
      },
      {
        multiTable: [
          "startTableCells",
          "endTableCells",
          "betweenRng"
        ]
      }
    ]), Tx = (e, n) => mu(Me.fromDom(e), "td,th", n), uT = (e) => !Bs(e.start, e.end), tS = (e, n) => k1(e.start, n).bind((s) => k1(e.end, n).bind((i) => gs(Bs(s, i), s))), vR = (e, n) => !uT(e) && tS(e, n).exists((s) => {
      const i = s.dom.rows;
      return i.length === 1 && i[0].cells.length === 1;
    }), pB = (e, n) => {
      const s = Tx(e.startContainer, n), i = Tx(e.endContainer, n);
      return ga(s, i, cT);
    }, hB = (e) => (n) => k1(n, e).bind((s) => Do(ed(s)).map((i) => cT(n, i))), gB = (e) => (n) => k1(n, e).bind((s) => hn(ed(s)).map((i) => cT(i, n))), dT = (e) => (n) => tS(n, e).map((s) => gR(n, s, ed(s))), bR = (e, n, s, i) => {
      if (s.collapsed || !e.forall(uT))
        return X.none();
      if (n.isSameTable) {
        const u = e.bind(dT(i));
        return X.some({
          start: u,
          end: u
        });
      } else {
        const u = Tx(s.startContainer, i), p = Tx(s.endContainer, i), b = u.bind(hB(i)).bind(dT(i)), S = p.bind(gB(i)).bind(dT(i));
        return X.some({
          start: b,
          end: S
        });
      }
    }, Z1 = (e, n) => ao(e, (s) => Bs(s, n)), fT = (e) => ga(Z1(e.cells, e.rng.start), Z1(e.cells, e.rng.end), (n, s) => e.cells.slice(n, s + 1)), yR = (e, n, s) => e.exists((i) => vR(i, s) && tx(i.start, n)), vB = (e, n) => {
      const { startTable: s, endTable: i } = n, u = e.cloneRange();
      return s.each((p) => u.setStartAfter(p.dom)), i.each((p) => u.setEndBefore(p.dom)), u;
    }, kj = (e, n, s, i) => bR(e, n, s, i).bind(({ start: u, end: p }) => u.or(p)).bind((u) => {
      const { isSameTable: p } = n, b = fT(u).getOr([]);
      if (p && u.cells.length === b.length)
        return X.some(W1.fullTable(u.table));
      if (b.length > 0) {
        if (p)
          return X.some(W1.partialTable(b, X.none()));
        {
          const S = vB(s, n);
          return X.some(W1.partialTable(b, X.some({
            ...n,
            rng: S
          })));
        }
      } else
        return X.none();
    }), bB = (e, n, s, i) => bR(e, n, s, i).bind(({ start: u, end: p }) => {
      const b = u.bind(fT).getOr([]), S = p.bind(fT).getOr([]);
      if (b.length > 0 && S.length > 0) {
        const T = vB(s, n);
        return X.some(W1.multiTable(b, S, T));
      } else
        return X.none();
    }), yB = (e, n) => {
      const s = _x(e), i = pB(n, s), u = mB(n, s);
      return yR(i, n, s) ? i.map((p) => W1.singleCellTable(n, p.start)) : u.isMultiTable ? bB(i, u, n, s) : kj(i, u, n, s);
    }, xR = (e) => je(e, (n) => {
      Jr(n, "contenteditable"), Xc(n);
    }), mT = (e, n) => X.from(e.dom.getParent(n, e.dom.isBlock)).map(Me.fromDom), xB = (e, n, s) => {
      s.each((i) => {
        n ? vr(i) : (Xc(i), e.selection.setCursorLocation(i.dom, 0));
      });
    }, pT = (e, n, s, i) => {
      const u = s.cloneRange();
      i ? (u.setStart(s.startContainer, s.startOffset), u.setEndAfter(n.dom.lastChild)) : (u.setStartBefore(n.dom.firstChild), u.setEnd(s.endContainer, s.endOffset)), hT(e, u, n, !1).each((p) => p());
    }, wR = (e) => {
      const n = tb(e), s = Me.fromDom(e.selection.getNode());
      yv(s.dom) && kr(e.schema, s) ? e.selection.setCursorLocation(s.dom, 0) : e.selection.collapse(!0), n.length > 1 && Vn(n, (i) => Bs(i, s)) && is(s, "data-mce-selected", "1");
    }, CR = (e, n, s) => X.some(() => {
      const i = e.selection.getRng(), u = s.bind(({ rng: p, isStartInTable: b }) => {
        const S = mT(e, b ? p.endContainer : p.startContainer);
        p.deleteContents(), xB(e, b, S.filter(Je(kr, e.schema)));
        const T = b ? n[0] : n[n.length - 1];
        return pT(e, T, i, b), kr(e.schema, T) ? X.none() : X.some(b ? n.slice(1) : n.slice(0, -1));
      }).getOr(n);
      xR(u), wR(e);
    }), wB = (e, n, s, i) => X.some(() => {
      const u = e.selection.getRng(), p = n[0], b = s[s.length - 1];
      pT(e, p, u, !0), pT(e, b, u, !1);
      const S = kr(e.schema, p) ? n : n.slice(1), T = kr(e.schema, b) ? s : s.slice(0, -1);
      xR(S.concat(T)), i.deleteContents(), wR(e);
    }), hT = (e, n, s, i = !0) => X.some(() => {
      fB(e, n, s, i);
    }), CB = (e, n) => X.some(() => z1(e, !1, n)), SB = (e, n, s) => yB(n, s).bind((i) => i.fold(Je(hT, e), Je(CB, e), Je(CR, e), Je(wB, e))), kB = (e, n) => nS(e, n), _B = (e, n, s, i) => gT(n, i).fold(() => SB(e, n, s), (u) => kB(e, u)), SR = (e, n, s) => {
      const i = Me.fromDom(e.getBody()), u = e.selection.getRng();
      return s.length !== 0 ? CR(e, s, X.none()) : _B(e, i, u, n);
    }, kR = (e, n) => Dn(Fg(n, e), Fv), gT = (e, n) => Dn(Fg(n, e), Sr("caption")), EB = (e, n, s, i, u) => Zm(s, e.getBody(), u).bind((p) => kR(n, Me.fromDom(p.getNode())).bind((b) => Bs(b, i) ? X.none() : X.some(ot))), nS = (e, n) => X.some(() => {
      Xc(n), e.selection.setCursorLocation(n.dom, 0);
    }), TB = (e, n, s, i) => jl(e.dom).bind((u) => xu(e.dom).map((p) => n ? s.isEqual(u) && i.isEqual(p) : s.isEqual(p) && i.isEqual(u))).getOr(!0), AB = (e, n) => nS(e, n), _R = (e, n, s) => gT(e, Me.fromDom(s.getNode())).fold(() => X.some(ot), (i) => gs(!Bs(i, n), ot)), vT = (e, n, s, i, u) => Zm(s, e.getBody(), u).fold(() => X.some(ot), (p) => TB(i, s, u, p) ? AB(e, i) : _R(n, i, p)), ER = (e, n, s, i) => {
      const u = gt.fromRangeStart(e.selection.getRng());
      return kR(s, i).bind((p) => kr(e.schema, p, { checkRootAsContent: !1 }) ? nS(e, p) : EB(e, s, n, p, u));
    }, bT = (e, n, s, i) => {
      const u = gt.fromRangeStart(e.selection.getRng());
      return kr(e.schema, i) ? nS(e, i) : vT(e, s, n, i, u);
    }, TR = (e, n) => e ? aR(n) : iR(n), yT = (e, n) => {
      const s = gt.fromRangeStart(e.selection.getRng());
      return TR(n, s) || yu(n, e.getBody(), s).exists((i) => TR(n, i));
    }, AR = (e, n, s) => {
      const i = Me.fromDom(e.getBody());
      return gT(i, s).fold(() => ER(e, n, i, s).orThunk(() => gs(yT(e, n), ot)), (u) => bT(e, n, i, u));
    }, G1 = (e, n) => {
      const s = Me.fromDom(e.selection.getStart(!0)), i = tb(e);
      return e.selection.isCollapsed() && i.length === 0 ? AR(e, n, s) : SR(e, s, i);
    }, Lg = (e, n) => {
      let s = n;
      for (; s && s !== e; ) {
        if (Mt(s) || Ls(s))
          return s;
        s = s.parentNode;
      }
      return null;
    }, OB = [
      "data-ephox-",
      "data-mce-",
      "data-alloy-",
      "data-snooker-",
      "_"
    ], Ax = Kt.each, oS = (e) => {
      const n = e.dom, s = new Set(e.serializer.getTempAttrs()), i = (p, b) => {
        if (p.nodeName !== b.nodeName || p.nodeType !== b.nodeType)
          return !1;
        const S = (M) => {
          const j = {};
          return Ax(n.getAttribs(M), (W) => {
            const G = W.nodeName.toLowerCase();
            G !== "style" && !u(G) && (j[G] = n.getAttrib(M, G));
          }), j;
        }, T = (M, j) => {
          for (const W in M)
            if (Xn(M, W)) {
              const G = j[W];
              if (wt(G) || M[W] !== G)
                return !1;
              delete j[W];
            }
          for (const W in j)
            if (Xn(j, W))
              return !1;
          return !0;
        };
        return Tn(p) && Tn(b) && (!T(S(p), S(b)) || !T(n.parseStyle(n.getAttrib(p, "style")), n.parseStyle(n.getAttrib(b, "style")))) ? !1 : !Cu(p) && !Cu(b);
      }, u = (p) => Vn(OB, (b) => co(p, b)) || s.has(p);
      return {
        compare: i,
        isAttributeInternal: u
      };
    }, xT = (e) => [
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6"
    ].includes(e.name), Ox = (e) => e.name === "summary", fb = (e, n) => {
      let s = e;
      for (; s = s.walk(); )
        n(s);
    }, OR = (e, n, s, i) => {
      const u = s.name;
      for (let p = 0, b = e.length; p < b; p++) {
        const S = e[p];
        if (S.name === u) {
          const T = i.nodes[u];
          T ? T.nodes.push(s) : i.nodes[u] = {
            filter: S,
            nodes: [s]
          };
        }
      }
      if (s.attributes)
        for (let p = 0, b = n.length; p < b; p++) {
          const S = n[p], T = S.name;
          if (T in s.attributes.map) {
            const M = i.attributes[T];
            M ? M.nodes.push(s) : i.attributes[T] = {
              filter: S,
              nodes: [s]
            };
          }
        }
    }, _j = (e, n, s) => {
      const i = {
        nodes: {},
        attributes: {}
      };
      return s.firstChild && fb(s, (u) => {
        OR(e, n, u, i);
      }), i;
    }, DB = (e, n) => {
      const s = (i, u) => {
        qt(i, (p) => {
          const b = Ss(p.nodes);
          je(p.filter.callbacks, (S) => {
            for (let T = b.length - 1; T >= 0; T--) {
              const M = b[T];
              (!(u ? M.attr(p.filter.name) !== void 0 : M.name === p.filter.name) || Vt(M.parent)) && b.splice(T, 1);
            }
            b.length > 0 && S(b, p.filter.name, n);
          });
        });
      };
      s(e.nodes, !1), s(e.attributes, !0);
    }, DR = (e, n, s, i = {}) => {
      const u = _j(e, n, s);
      DB(u, i);
    }, wT = (e, n, s, i) => {
      if ((e.pad_empty_with_br || n.insert) && s(i)) {
        const p = new ou("br", 1);
        n.insert && p.attr("data-mce-bogus", "1"), i.empty().append(p);
      } else
        i.empty().append(new ou("#text", 3)).value = Xa;
    }, Ej = (e) => {
      var n;
      return $g(e, "#text") && ((n = e == null ? void 0 : e.firstChild) === null || n === void 0 ? void 0 : n.value) === Xa;
    }, $g = (e, n) => {
      const s = e == null ? void 0 : e.firstChild;
      return Ue(s) && s === e.lastChild && s.name === n;
    }, q1 = (e, n) => {
      const s = e.getElementRule(n.name);
      return (s == null ? void 0 : s.paddEmpty) === !0;
    }, CT = (e, n, s, i) => i.isEmpty(n, s, (u) => q1(e, u)), Nl = (e, n) => Ue(e) && (n(e) || e.name === "br"), Tj = (e) => {
      let n;
      for (let s = e; s; s = s.parent) {
        const i = s.attr("contenteditable");
        if (i === "false")
          break;
        i === "true" && (n = s);
      }
      return X.from(n);
    }, RR = (e, n, s = e.parent) => {
      if (n.getSpecialElements()[e.name])
        e.empty().remove();
      else {
        const i = e.children();
        for (const u of i)
          s && !n.isValidChild(s.name, u.name) && RR(u, n, s);
        e.unwrap();
      }
    }, Qm = (e, n, s, i = ot) => {
      const u = n.getTextBlockElements(), p = n.getNonEmptyElements(), b = n.getWhitespaceElements(), S = Kt.makeMap("tr,td,th,tbody,thead,tfoot,table,summary"), T = /* @__PURE__ */ new Set(), M = (j) => j !== s && !S[j.name];
      for (let j = 0; j < e.length; j++) {
        const W = e[j];
        let G, ue, we;
        if (!W.parent || T.has(W))
          continue;
        if (u[W.name] && W.parent.name === "li") {
          let ke = W.next;
          for (; ke && u[ke.name]; ) {
            ke.name = "li", T.add(ke), W.parent.insert(ke, W.parent);
            ke = ke.next;
          }
          W.unwrap();
          continue;
        }
        const fe = [W];
        for (G = W.parent; G && !n.isValidChild(G.name, W.name) && M(G); G = G.parent)
          fe.push(G);
        if (G && fe.length > 1)
          if (RB(n, W, G))
            RR(W, n);
          else {
            fe.reverse(), ue = fe[0].clone(), i(ue);
            let ke = ue;
            for (let He = 0; He < fe.length - 1; He++) {
              n.isValidChild(ke.name, fe[He].name) && He > 0 ? (we = fe[He].clone(), i(we), ke.append(we)) : we = ke;
              for (let Ye = fe[He].firstChild; Ye && Ye !== fe[He + 1]; ) {
                const We = Ye.next;
                we.append(Ye), Ye = We;
              }
              ke = we;
            }
            CT(n, p, b, ue) ? G.insert(W, fe[0], !0) : (G.insert(ue, fe[0], !0), G.insert(W, ue)), G = fe[0], (CT(n, p, b, G) || $g(G, "br")) && G.empty().remove();
          }
        else if (W.parent) {
          if (W.name === "li") {
            let ke = W.prev;
            if (ke && (ke.name === "ul" || ke.name === "ol")) {
              ke.append(W);
              continue;
            }
            if (ke = W.next, ke && (ke.name === "ul" || ke.name === "ol") && ke.firstChild) {
              ke.insert(W, ke.firstChild, !0);
              continue;
            }
            const He = new ou("ul", 1);
            i(He), W.wrap(He);
            continue;
          }
          if (n.isValidChild(W.parent.name, "div") && n.isValidChild("div", W.name)) {
            const ke = new ou("div", 1);
            i(ke), W.wrap(ke);
          } else
            RR(W, n);
        }
      }
    }, rr = (e, n) => {
      let s = e;
      for (; s; ) {
        if (s.name === n)
          return !0;
        s = s.parent;
      }
      return !1;
    }, RB = (e, n, s = n.parent) => s ? e.children[n.name] && !e.isValidChild(s.name, n.name) || n.name === "a" && rr(s, "a") ? !0 : Ox(s) && xT(n) ? !((s == null ? void 0 : s.firstChild) === n && (s == null ? void 0 : s.lastChild) === n) : !1 : !1, Aj = (e, n, s, i) => {
      const u = document.createRange();
      return u.setStart(e, n), u.setEnd(s, i), u;
    }, Oj = (e) => {
      const n = gt.fromRangeStart(e), s = gt.fromRangeEnd(e), i = e.commonAncestorContainer;
      return yu(!1, i, s).map((u) => !bu(n, s, i) && bu(n, u, i) ? Aj(n.container(), n.offset(), u.container(), u.offset()) : e).getOr(e);
    }, jr = (e) => e.collapsed ? e : Oj(e), NB = (e) => Ue(e.firstChild) && e.firstChild === e.lastChild, sS = (e) => e.name === "br" || e.value === Xa, rS = (e, n) => e.getBlockElements()[n.name] && NB(n) && sS(n.firstChild), ST = (e, n) => {
      const s = e.getNonEmptyElements();
      return Ue(n) && (n.isEmpty(s) || rS(e, n));
    }, kT = (e, n) => {
      let s = n.firstChild, i = n.lastChild;
      return s && s.name === "meta" && (s = s.next), i && i.attr("id") === "mce_marker" && (i = i.prev), ST(e, i) && (i = i == null ? void 0 : i.prev), !s || s !== i ? !1 : s.name === "ul" || s.name === "ol";
    }, PB = (e) => {
      var n, s;
      const i = e.firstChild, u = e.lastChild;
      return i && i.nodeName === "META" && ((n = i.parentNode) === null || n === void 0 || n.removeChild(i)), u && u.id === "mce_marker" && ((s = u.parentNode) === null || s === void 0 || s.removeChild(u)), e;
    }, Are = (e, n, s) => {
      const i = n.serialize(s), u = e.createFragment(i);
      return PB(u);
    }, Dj = (e) => {
      var n;
      return on((n = e == null ? void 0 : e.childNodes) !== null && n !== void 0 ? n : [], (s) => s.nodeName === "LI");
    }, Ore = (e) => e.data === Xa || Vs(e), Rj = (e) => Ue(e == null ? void 0 : e.firstChild) && e.firstChild === e.lastChild && Ore(e.firstChild), Nj = (e) => !e.firstChild || Rj(e), Dre = (e) => e.length > 0 && Nj(e[e.length - 1]) ? e.slice(0, -1) : e, NR = (e, n) => {
      const s = e.getParent(n, e.isBlock);
      return s && s.nodeName === "LI" ? s : null;
    }, gl = (e, n) => !!NR(e, n), MB = (e, n) => {
      const s = n.cloneRange(), i = n.cloneRange();
      return s.setStartBefore(e), i.setEndAfter(e), [
        s.cloneContents(),
        i.cloneContents()
      ];
    }, IB = (e, n) => {
      const s = gt.before(e), u = pl(n).next(s);
      return u ? u.toRange() : null;
    }, FB = (e, n) => {
      const s = gt.after(e), u = pl(n).prev(s);
      return u ? u.toRange() : null;
    }, Pj = (e, n, s, i) => {
      const u = MB(e, i), p = e.parentNode;
      return p && (p.insertBefore(u[0], e), Kt.each(n, (b) => {
        p.insertBefore(b, e);
      }), p.insertBefore(u[1], e), p.removeChild(e)), FB(n[n.length - 1], s);
    }, Mj = (e, n, s) => {
      const i = e.parentNode;
      return i && Kt.each(n, (u) => {
        i.insertBefore(u, e);
      }), IB(e, s);
    }, td = (e, n, s, i) => (i.insertAfter(n.reverse(), e), FB(n[0], s)), Jm = (e, n, s, i) => {
      const u = Are(n, e, i), p = NR(n, s.startContainer), b = Dre(Dj(u.firstChild)), S = 1, T = 2, M = n.getRoot(), j = (W) => {
        const G = gt.fromRangeStart(s), ue = pl(n.getRoot()), we = W === S ? ue.prev(G) : ue.next(G), fe = we == null ? void 0 : we.getNode();
        return fe ? NR(n, fe) !== p : !0;
      };
      return p ? j(S) ? Mj(p, b, M) : j(T) ? td(p, b, M, n) : Pj(p, b, M, s) : null;
    }, Ij = ["pre"], PR = (e, n, s, i) => {
      var u;
      const p = n.firstChild, b = n.lastChild, S = b.attr("data-mce-type") === "bookmark" ? b.prev : b, T = p === S, M = Nt(Ij, p.name);
      if (T && M) {
        const j = p.attr("contenteditable") !== "false", W = ((u = e.getParent(s, e.isBlock)) === null || u === void 0 ? void 0 : u.nodeName.toLowerCase()) === p.name, G = X.from(Lg(i, s)).forall(Mt);
        return j && W && G;
      } else
        return !1;
    }, aS = yv, Fj = (e, n, s) => {
      if (Ue(s)) {
        const i = e.getParent(n.endContainer, aS);
        return s === i && tx(Me.fromDom(s), n);
      } else
        return !1;
    }, Bj = (e, n, s) => {
      var i;
      if (s.getAttribute("data-mce-bogus") === "all")
        (i = s.parentNode) === null || i === void 0 || i.insertBefore(e.dom.createFragment(n), s);
      else {
        const u = s.firstChild, p = s.lastChild;
        !u || u === p && u.nodeName === "BR" ? e.dom.setHTML(s, n) : e.selection.setContent(n, { no_events: !0 });
      }
    }, iS = (e, n, s) => {
      X.from(e.getParent(n, "td,th")).map(Me.fromDom).each((i) => w_(i, s));
    }, _T = (e, n) => {
      const s = e.schema.getTextInlineElements(), i = e.dom;
      if (n) {
        const u = e.getBody(), p = oS(e), b = "*[data-mce-fragment]", S = i.select(b);
        Kt.each(S, (T) => {
          const M = (G) => Ue(s[G.nodeName.toLowerCase()]), j = (G) => G.childNodes.length === 1;
          if (((G) => !(MF(i, G) || qU(i, G)))(T) && M(T) && j(T)) {
            const G = Cx(i, T), ue = (He, Ye) => Qo(He, (We) => Nt(Ye, We)), we = (He) => j(T) && i.is(He, b) && M(He) && (He.nodeName === T.nodeName && ue(G, Cx(i, He)) || we(He.children[0])), fe = (He) => Ue(He) && He !== u && (p.compare(T, He) || fe(He.parentElement)), ke = (He) => Ue(He) && He !== u && i.is(He, b) && (YU(i, T, He) || ke(He.parentElement));
            (we(T.children[0]) || fe(T.parentElement) && !ke(T.parentElement)) && i.remove(T, !0);
          }
        });
      }
    }, MR = (e) => {
      let n = e;
      for (; n = n.walk(); )
        n.type === 1 && n.attr("data-mce-fragment", "1");
    }, Lj = (e) => {
      Kt.each(e.getElementsByTagName("*"), (n) => {
        n.removeAttribute("data-mce-fragment");
      });
    }, ep = (e) => !!e.getAttribute("data-mce-fragment"), $j = (e, n) => Ue(n) && !e.schema.getVoidElements()[n.nodeName], Hj = (e, n) => {
      var s, i, u;
      let p;
      const b = e.dom, S = e.selection;
      if (!n)
        return;
      S.scrollIntoView(n);
      const T = Lg(e.getBody(), n);
      if (T && b.getContentEditable(T) === "false") {
        b.remove(n), S.select(T);
        return;
      }
      let M = b.createRng();
      const j = n.previousSibling;
      if (Gt(j)) {
        M.setStart(j, (i = (s = j.nodeValue) === null || s === void 0 ? void 0 : s.length) !== null && i !== void 0 ? i : 0);
        const ue = n.nextSibling;
        Gt(ue) && (j.appendData(ue.data), (u = ue.parentNode) === null || u === void 0 || u.removeChild(ue));
      } else
        M.setStartBefore(n), M.setEndBefore(n);
      const W = (ue) => {
        let we = gt.fromRangeStart(ue);
        return we = pl(e.getBody()).next(we), we == null ? void 0 : we.toRange();
      }, G = b.getParent(n, b.isBlock);
      if (b.remove(n), G && b.isEmpty(G)) {
        const ue = aS(G);
        Vc(Me.fromDom(G)), M.setStart(G, 0), M.setEnd(G, 0), !ue && !ep(G) && (p = W(M)) ? (M = p, b.remove(G)) : b.add(G, b.create("br", ue ? {} : { "data-mce-bogus": "1" }));
      }
      S.setRng(M);
    }, bf = (e) => {
      const n = e.dom, s = jr(e.selection.getRng());
      e.selection.setRng(s);
      const i = n.getParent(s.startContainer, aS);
      Fj(n, s, i) ? hT(e, s, Me.fromDom(i)) : s.startContainer === s.endContainer && s.endOffset - s.startOffset === 1 && Gt(s.startContainer.childNodes[s.startOffset]) ? s.deleteContents() : e.getDoc().execCommand("Delete", !1);
    }, lS = (e) => {
      for (let n = e; n; n = n.walk())
        if (n.attr("id") === "mce_marker")
          return X.some(n);
      return X.none();
    }, am = (e, n, s) => {
      var i;
      return Vn(s.children(), xT) && ((i = e.getParent(n, e.isBlock)) === null || i === void 0 ? void 0 : i.nodeName) === "SUMMARY";
    }, zj = (e, n, s) => {
      var i, u;
      const p = e.selection, b = e.dom, S = e.parser, T = s.merge, M = Ig({ validate: !0 }, e.schema), j = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
      s.preserve_zwsp || (n = Qc(n)), n.indexOf("{$caret}") === -1 && (n += "{$caret}"), n = n.replace(/\{\$caret\}/, j);
      let W = p.getRng();
      const G = W.startContainer, ue = e.getBody();
      G === ue && p.isCollapsed() && b.isBlock(ue.firstChild) && $j(e, ue.firstChild) && b.isEmpty(ue.firstChild) && (W = b.createRng(), W.setStart(ue.firstChild, 0), W.setEnd(ue.firstChild, 0), p.setRng(W)), p.isCollapsed() || bf(e);
      const we = p.getNode(), fe = {
        context: we.nodeName.toLowerCase(),
        data: s.data,
        insert: !0
      }, ke = S.parse(n, fe);
      if (s.paste === !0 && kT(e.schema, ke) && gl(b, we))
        return W = Jm(M, b, p.getRng(), ke), W && p.setRng(W), n;
      s.paste === !0 && PR(b, ke, we, e.getBody()) && ((i = ke.firstChild) === null || i === void 0 || i.unwrap()), MR(ke);
      let He = ke.lastChild;
      if (He && He.attr("id") === "mce_marker") {
        const Ye = He;
        for (He = He.prev; He; He = He.walk(!0))
          if (He.type === 3 || !b.isBlock(He.name)) {
            He.parent && e.schema.isValidChild(He.parent.name, "span") && He.parent.insert(Ye, He, He.name === "br");
            break;
          }
      }
      if (e._selectionOverrides.showBlockCaretContainer(we), !fe.invalid && !am(b, we, ke))
        n = M.serialize(ke), Bj(e, n, we);
      else {
        e.selection.setContent(j);
        let Ye = p.getNode(), We;
        const ut = e.getBody();
        for (Pp(Ye) ? Ye = We = ut : We = Ye; We && We !== ut; )
          Ye = We, We = We.parentNode;
        n = Ye === ut ? ut.innerHTML : b.getOuterHTML(Ye);
        const Ut = S.parse(n), an = lS(Ut), Nn = an.bind(Tj).getOr(Ut);
        an.each((zn) => zn.replace(ke));
        const Et = ke.children(), bt = (u = ke.parent) !== null && u !== void 0 ? u : Ut;
        ke.unwrap();
        const Ht = on(Et, (zn) => RB(e.schema, zn, bt));
        Qm(Ht, e.schema, Nn), DR(S.getNodeFilters(), S.getAttributeFilters(), Ut), n = M.serialize(Ut), Ye === ut ? b.setHTML(ut, n) : b.setOuterHTML(Ye, n);
      }
      return _T(e, T), Hj(e, b.get("mce_marker")), Lj(e.getBody()), iS(b, p.getStart(), e.schema), Sd(e.schema, e.getBody(), p.getStart()), n;
    }, dr = (e) => e instanceof ou, Dx = (e) => {
      H1(e) && jl(e.getBody()).each((n) => {
        const s = n.getNode(), i = Hu(s) ? jl(s).getOr(n) : n;
        e.selection.setRng(i.toRange());
      });
    }, Rx = (e, n, s) => {
      e.dom.setHTML(e.getBody(), n), s !== !0 && Dx(e);
    }, BB = (e, n, s, i) => {
      if (s = Qc(s), s.length === 0 || /^\s+$/.test(s)) {
        const u = '<br data-mce-bogus="1">';
        n.nodeName === "TABLE" ? s = "<tr><td>" + u + "</td></tr>" : /^(UL|OL)$/.test(n.nodeName) && (s = "<li>" + u + "</li>");
        const p = Dl(e);
        return e.schema.isValidChild(n.nodeName.toLowerCase(), p.toLowerCase()) ? (s = u, s = e.dom.createHTML(p, Xp(e), s)) : s || (s = u), Rx(e, s, i.no_selection), {
          content: s,
          html: s
        };
      } else {
        i.format !== "raw" && (s = Ig({ validate: !1 }, e.schema).serialize(e.parser.parse(s, {
          isRootContent: !0,
          insert: !0
        })));
        const u = r1(Me.fromDom(n)) ? s : Kt.trim(s);
        return Rx(e, u, i.no_selection), {
          content: u,
          html: u
        };
      }
    }, IR = (e, n, s, i) => {
      DR(e.parser.getNodeFilters(), e.parser.getAttributeFilters(), s);
      const u = Ig({ validate: !1 }, e.schema).serialize(s), p = Qc(r1(Me.fromDom(n)) ? u : Kt.trim(u));
      return Rx(e, p, i.no_selection), {
        content: s,
        html: p
      };
    }, FR = (e, n, s) => X.from(e.getBody()).map((i) => dr(n) ? IR(e, i, n, s) : BB(e, i, n, s)).getOr({
      content: n,
      html: dr(s.content) ? "" : s.content
    }), LB = (e) => Ce(e) ? e : et, BR = (e, n, s) => {
      let i = e.dom;
      const u = LB(s);
      for (; i.parentNode; ) {
        i = i.parentNode;
        const p = Me.fromDom(i), b = n(p);
        if (b.isSome())
          return b;
        if (u(p))
          break;
      }
      return X.none();
    }, LR = (e, n, s) => {
      const i = n(e), u = LB(s);
      return i.orThunk(() => u(e) ? X.none() : BR(e, n, u));
    }, ET = ox, $R = (e, n, s) => {
      const i = e.formatter.get(s);
      if (i)
        for (let u = 0; u < i.length; u++) {
          const p = i[u];
          if (Ku(p) && p.inherit === !1 && e.dom.is(n, p.selector))
            return !0;
        }
      return !1;
    }, cS = (e, n, s, i, u) => {
      const p = e.dom.getRoot();
      if (n === p)
        return !1;
      const b = e.dom.getParent(n, (S) => $R(e, S, s) ? !0 : S.parentNode === p || !!hh(e, S, s, i, !0));
      return !!hh(e, b, s, i, u);
    }, uS = (e, n, s) => Li(s) && ET(n, s.inline) || Km(s) && ET(n, s.block) ? !0 : Ku(s) ? Tn(n) && e.is(n, s.selector) : !1, dS = (e, n, s, i, u, p) => {
      const b = s[i], S = i === "attributes";
      if (Ce(s.onmatch))
        return s.onmatch(n, s, i);
      if (b) {
        if (gn(b)) {
          for (let T = 0; T < b.length; T++)
            if (S ? e.getAttrib(n, b[T]) : sx(e, n, b[T]))
              return !0;
        } else
          for (const T in b)
            if (Xn(b, T)) {
              const M = S ? e.getAttrib(n, T) : sx(e, n, T), j = Rg(b[T], p), W = Vt(M) || Zo(M);
              if (W && Vt(j))
                continue;
              if (u && W && !s.exact || (!u || s.exact) && !ET(M, Ng(j, T)))
                return !1;
            }
      }
      return !0;
    }, hh = (e, n, s, i, u) => {
      const p = e.formatter.get(s), b = e.dom;
      if (p && Tn(n))
        for (let S = 0; S < p.length; S++) {
          const T = p[S];
          if (uS(e.dom, n, T) && dS(b, n, T, "attributes", u, i) && dS(b, n, T, "styles", u, i)) {
            const M = T.classes;
            if (M) {
              for (let j = 0; j < M.length; j++)
                if (!e.dom.hasClass(n, Rg(M[j], i)))
                  return;
            }
            return T;
          }
        }
    }, HR = (e, n, s, i, u) => {
      if (i)
        return cS(e, i, n, s, u);
      if (i = e.selection.getNode(), cS(e, i, n, s, u))
        return !0;
      const p = e.selection.getStart();
      return !!(p !== i && cS(e, p, n, s, u));
    }, Vj = (e, n, s) => {
      const i = [], u = {}, p = e.selection.getStart();
      return e.dom.getParent(p, (b) => {
        for (let S = 0; S < n.length; S++) {
          const T = n[S];
          !u[T] && hh(e, b, T, s) && (u[T] = !0, i.push(T));
        }
      }, e.dom.getRoot()), i;
    }, Uj = (e, n) => {
      const s = (u) => Bs(u, Me.fromDom(e.getBody())), i = (u, p) => hh(e, u.dom, p) ? X.some(p) : X.none();
      return X.from(e.selection.getStart(!0)).bind((u) => LR(Me.fromDom(u), (p) => pr(n, (b) => i(p, b)), s)).getOrNull();
    }, jj = (e, n) => {
      const s = e.formatter.get(n), i = e.dom;
      if (s && e.selection.isEditable()) {
        const u = e.selection.getStart(), p = rb(i, u);
        for (let b = s.length - 1; b >= 0; b--) {
          const S = s[b];
          if (!Ku(S))
            return !0;
          for (let T = p.length - 1; T >= 0; T--)
            if (i.is(p[T], S.selector))
              return !0;
        }
      }
      return !1;
    }, $B = (e, n, s) => vt(s, (i, u) => {
      const p = vD(e, u);
      return e.formatter.matchNode(n, u, {}, p) ? i.concat([u]) : i;
    }, []), fS = Ma, Wj = (e, n) => e.importNode(n, !0), zR = (e) => {
      if (e) {
        const n = new Pi(e, e);
        for (let s = n.current(); s; s = n.next())
          if (Gt(s))
            return s;
      }
      return null;
    }, TT = (e) => {
      const n = Me.fromTag("span");
      return _a(n, {
        id: Qy,
        "data-mce-bogus": "1",
        "data-mce-type": "format-caret"
      }), e && Zr(n, Me.fromText(fS)), n;
    }, Zj = (e) => {
      const n = zR(e);
      return n && n.data.charAt(0) === fS && n.deleteData(0, 1), n;
    }, VR = (e, n, s) => {
      const i = e.dom, u = e.selection;
      if (RE(n))
        z1(e, !1, Me.fromDom(n), s, !0);
      else {
        const p = u.getRng(), b = i.getParent(n, i.isBlock), S = p.startContainer, T = p.startOffset, M = p.endContainer, j = p.endOffset, W = Zj(n);
        i.remove(n, !0), S === W && T > 0 && p.setStart(W, T - 1), M === W && j > 0 && p.setEnd(W, j - 1), b && i.isEmpty(b) && Xc(Me.fromDom(b)), u.setRng(p);
      }
    }, AT = (e, n, s) => {
      const i = e.dom, u = e.selection;
      if (n)
        VR(e, n, s);
      else if (n = Tg(e.getBody(), u.getStart()), !n)
        for (; n = i.get(Qy); )
          VR(e, n, s);
    }, Gj = (e, n, s) => {
      var i, u;
      const p = e.dom, b = p.getParent(s, Je(OC, e.schema));
      b && p.isEmpty(b) ? (i = s.parentNode) === null || i === void 0 || i.replaceChild(n, s) : (yO(Me.fromDom(s)), p.isEmpty(s) ? (u = s.parentNode) === null || u === void 0 || u.replaceChild(n, s) : p.insertAfter(n, s));
    }, UR = (e, n) => (e.appendChild(n), n), Pd = (e, n) => {
      var s;
      const i = zt(e, (p, b) => UR(p, b.cloneNode(!1)), n), u = (s = i.ownerDocument) !== null && s !== void 0 ? s : document;
      return UR(i, u.createTextNode(fS));
    }, qj = (e, n, s, i, u, p) => {
      const b = e.formatter, S = e.dom, T = on(Ms(b.get()), (W) => W !== i && !Qn(W, "removeformat")), M = $B(e, s, T);
      if (on(M, (W) => !ax(e, W, i)).length > 0) {
        const W = s.cloneNode(!1);
        return S.add(n, W), b.remove(i, u, W, p), S.remove(W), X.some(W);
      } else
        return X.none();
    }, HB = (e, n, s) => {
      let i;
      const u = e.selection, p = e.formatter.get(n);
      if (!p)
        return;
      const b = u.getRng();
      let S = b.startOffset;
      const M = b.startContainer.nodeValue;
      i = Tg(e.getBody(), u.getStart());
      const j = /[^\s\u00a0\u00ad\u200b\ufeff]/;
      if (M && S > 0 && S < M.length && j.test(M.charAt(S)) && j.test(M.charAt(S - 1))) {
        const W = u.getBookmark();
        b.collapse(!0);
        let G = ih(e.dom, b, p);
        G = Wn(G), e.formatter.apply(n, s, G), u.moveToBookmark(W);
      } else {
        let W = i ? zR(i) : null;
        (!i || (W == null ? void 0 : W.data) !== fS) && (i = Wj(e.getDoc(), TT(!0).dom), W = i.firstChild, b.insertNode(i), S = 1), e.formatter.apply(n, s, i), u.setCursorLocation(W, S);
      }
    }, jR = (e, n, s, i) => {
      const u = e.dom, p = e.selection;
      let b = !1;
      const S = e.formatter.get(n);
      if (!S)
        return;
      const T = p.getRng(), M = T.startContainer, j = T.startOffset;
      let W = M;
      Gt(M) && (j !== M.data.length && (b = !0), W = W.parentNode);
      const G = [];
      let ue;
      for (; W; ) {
        if (hh(e, W, n, s, i)) {
          ue = W;
          break;
        }
        W.nextSibling && (b = !0), G.push(W), W = W.parentNode;
      }
      if (ue)
        if (b) {
          const we = p.getBookmark();
          T.collapse(!0);
          let fe = ih(u, T, S, !0);
          fe = Wn(fe), e.formatter.remove(n, s, fe, i), p.moveToBookmark(we);
        } else {
          const we = Tg(e.getBody(), ue), fe = Ue(we) ? u.getParents(ue.parentNode, xt, we) : [], ke = TT(!1).dom;
          Gj(e, ke, we ?? ue);
          const He = qj(e, ke, ue, n, s, i), Ye = Pd([
            ...G,
            ...He.toArray(),
            ...fe
          ], ke);
          we && VR(e, we, Ue(we)), p.setCursorLocation(Ye, 1), u.isEmpty(ue) && u.remove(ue);
        }
    }, WR = (e, n, s) => {
      const i = e.selection, u = e.getBody();
      AT(e, null, s), (n === 8 || n === 46) && i.isCollapsed() && i.getStart().innerHTML === fS && AT(e, Tg(u, i.getStart()), !0), (n === 37 || n === 39) && AT(e, Tg(u, i.getStart()), !0);
    }, zB = (e) => Gt(e) && Jo(e.data, Xa), VB = (e) => {
      e.on("mouseup keydown", (n) => {
        WR(e, n.keyCode, zB(e.selection.getRng().endContainer));
      });
    }, UB = (e) => {
      const n = TT(!1), s = Pd(e, n.dom);
      return {
        caretContainer: n,
        caretPosition: gt(s, 0)
      };
    }, jB = (e, n) => {
      const { caretContainer: s, caretPosition: i } = UB(n);
      return Ki(Me.fromDom(e), s), vr(Me.fromDom(e)), i;
    }, ZR = (e, n) => {
      const { caretContainer: s, caretPosition: i } = UB(n);
      return e.insertNode(s.dom), i;
    }, GR = (e, n) => {
      if (wu(n.dom))
        return !1;
      const s = e.schema.getTextInlineElements();
      return Xn(s, fs(n)) && !wu(n.dom) && !Mm(n.dom);
    }, ku = {}, WB = hu(["pre"]), Kj = (e, n) => {
      ku[e] || (ku[e] = []), ku[e].push(n);
    }, Rre = (e, n) => {
      Xn(ku, e) && je(ku[e], (s) => {
        s(n);
      });
    };
    Kj("pre", (e) => {
      const n = e.selection.getRng(), s = (u) => (p) => {
        const b = p.previousSibling;
        return WB(b) && Nt(u, b);
      }, i = (u, p) => {
        const b = Me.fromDom(p), S = Ka(b).dom;
        vr(b), bd(Me.fromDom(u), [
          Me.fromTag("br", S),
          Me.fromTag("br", S),
          ...Ya(b)
        ]);
      };
      if (!n.collapsed) {
        const u = e.selection.getSelectedBlocks(), p = on(on(u, WB), s(u));
        je(p, (b) => {
          i(b.previousSibling, b);
        });
      }
    });
    const OT = [
      "fontWeight",
      "fontStyle",
      "color",
      "fontSize",
      "fontFamily"
    ], Yj = (e) => ve(e.styles) && Vn(Ms(e.styles), (n) => Nt(OT, n)), Nre = (e) => Dn(e, (n) => Li(n) && n.inline === "span" && Yj(n)), ZB = (e, n) => {
      const s = e.get(n);
      return rt(s) ? Nre(s) : X.none();
    }, DT = (e, n) => eu(n, gt.fromRangeStart(e)).isNone(), im = (e, n) => Ul(n, gt.fromRangeEnd(e)).exists((s) => !Vs(s.getNode()) || Ul(n, s).isSome()) === !1, RT = (e) => (n) => Y2(n) && e.isEditable(n), NT = (e) => {
      const n = e.getSelectedBlocks(), s = e.getRng();
      if (e.isCollapsed())
        return [];
      if (n.length === 1)
        return DT(s, n[0]) && im(s, n[0]) ? n : [];
      {
        const i = hn(n).filter((b) => DT(s, b)).toArray(), u = Do(n).filter((b) => im(s, b)).toArray(), p = n.slice(1, -1);
        return i.concat(p).concat(u);
      }
    }, qR = (e) => on(NT(e), RT(e.dom)), GB = (e) => on(e.getSelectedBlocks(), RT(e.dom)), PT = Kt.each, KR = (e) => Tn(e) && !Cu(e) && !wu(e) && !Mm(e), YR = (e, n) => {
      for (let s = e; s; s = s[n]) {
        if (Gt(s) && ko(s.data))
          return e;
        if (Tn(s) && !Cu(s))
          return s;
      }
      return e;
    }, MT = (e, n, s) => {
      const i = oS(e), u = Ec(n) && e.dom.isEditable(n), p = Ec(s) && e.dom.isEditable(s);
      if (u && p) {
        const b = YR(n, "previousSibling"), S = YR(s, "nextSibling");
        if (i.compare(b, S)) {
          for (let T = b.nextSibling; T && T !== S; ) {
            const M = T;
            T = T.nextSibling, b.appendChild(M);
          }
          return e.dom.remove(S), Kt.each(Kt.grep(S.childNodes), (T) => {
            b.appendChild(T);
          }), b;
        }
      }
      return s;
    }, qB = (e, n, s, i) => {
      var u;
      if (i && n.merge_siblings !== !1) {
        const p = (u = MT(e, _1(i), i)) !== null && u !== void 0 ? u : i;
        MT(e, p, _1(p, !0));
      }
    }, KB = (e, n, s) => {
      if (n.clear_child_styles) {
        const i = n.links ? "*:not(a)" : "*";
        PT(e.select(i, s), (u) => {
          KR(u) && e.isEditable(u) && PT(n.styles, (p, b) => {
            e.setStyle(u, b, "");
          });
        });
      }
    }, XR = (e, n, s) => {
      PT(e.childNodes, (i) => {
        KR(i) && (n(i) && s(i), i.hasChildNodes() && XR(i, n, s));
      });
    }, K1 = (e, n) => {
      n.nodeName === "SPAN" && e.getAttribs(n).length === 0 && e.remove(n, !0);
    }, QR = (e, n) => (s) => !!(s && sx(e, s, n)), YB = (e, n, s) => (i) => {
      e.setStyle(i, n, s), i.getAttribute("style") === "" && i.removeAttribute("style"), K1(e, i);
    }, mb = or.generate([
      { keep: [] },
      { rename: ["name"] },
      { removed: [] }
    ]), Xj = /^(src|href|style)$/, JR = Kt.each, IT = ox, Qj = (e) => /^(TR|TH|TD)$/.test(e.nodeName), XB = (e, n, s) => e.isChildOf(n, s) && n !== s && !e.isBlock(s), eN = (e, n, s) => {
      let i = n[s ? "startContainer" : "endContainer"], u = n[s ? "startOffset" : "endOffset"];
      if (Tn(i)) {
        const p = i.childNodes.length - 1;
        !s && u && u--, i = i.childNodes[u > p ? p : u];
      }
      return Gt(i) && s && u >= i.data.length && (i = new Pi(i, e.getBody()).next() || i), Gt(i) && !s && u === 0 && (i = new Pi(i, e.getBody()).prev() || i), i;
    }, QB = (e, n) => {
      const s = n ? "firstChild" : "lastChild", i = e[s];
      return Qj(e) && i ? e.nodeName === "TR" && i[s] || i : e;
    }, mS = (e, n, s, i) => {
      var u;
      const p = e.create(s, i);
      return (u = n.parentNode) === null || u === void 0 || u.insertBefore(p, n), p.appendChild(n), p;
    }, pb = (e, n, s, i, u) => {
      const p = Me.fromDom(n), b = Me.fromDom(e.create(i, u)), S = s ? qi(p) : wp(p);
      return bd(b, S), s ? (Ki(p, b), Rm(b, p)) : (tc(p, b), Zr(b, p)), b.dom;
    }, Jj = (e, n) => n.links && e.nodeName === "A", JB = (e, n, s) => {
      const i = n.parentNode;
      let u;
      const p = e.dom, b = Dl(e);
      Km(s) && i === p.getRoot() && (!s.list_block || !IT(n, s.list_block)) && je(Ss(n.childNodes), (S) => {
        qm(e, b, S.nodeName.toLowerCase()) ? u ? u.appendChild(S) : (u = mS(p, S, b), p.setAttribs(u, Xp(e))) : u = null;
      }), !(yD(s) && !IT(s.inline, n)) && p.remove(n, !0);
    }, pS = (e, n, s) => Rn(e) ? {
      name: n,
      value: null
    } : {
      name: e,
      value: Rg(n, s)
    }, tN = (e, n) => {
      e.getAttrib(n, "style") === "" && (n.removeAttribute("style"), n.removeAttribute("data-mce-style"));
    }, nN = (e, n, s, i, u) => {
      let p = !1;
      JR(s.styles, (b, S) => {
        const {
          name: T,
          value: M
        } = pS(S, b, i), j = Ng(M, T);
        (s.remove_similar || ee(M) || !Tn(u) || IT(sx(e, u, T), j)) && e.setStyle(n, T, ""), p = !0;
      }), p && tN(e, n);
    }, eW = (e, n, s) => {
      n === "removeformat" ? je(GB(e.selection), (i) => {
        je(OT, (u) => e.dom.setStyle(i, u, "")), tN(e.dom, i);
      }) : ZB(e.formatter, n).each((i) => {
        je(GB(e.selection), (u) => nN(e.dom, u, i, s, null));
      });
    }, oN = (e, n, s, i, u) => {
      const p = e.dom, b = oS(e), S = e.schema;
      if (Li(n) && kd(S, n.inline) && Uu(S, i) && i.parentElement === e.getBody())
        return JB(e, i, n), mb.removed();
      if (!n.ceFalseOverride && i && p.getContentEditableParent(i) === "false" || i && !uS(p, i, n) && !Jj(i, n))
        return mb.keep();
      const T = i, M = n.preserve_attributes;
      if (Li(n) && n.remove === "all" && rt(M)) {
        const j = on(p.getAttribs(T), (W) => Nt(M, W.name.toLowerCase()));
        if (p.removeAllAttribs(T), je(j, (W) => p.setAttrib(T, W.name, W.value)), j.length > 0)
          return mb.rename("span");
      }
      if (n.remove !== "all") {
        nN(p, T, n, s, u), JR(n.attributes, (W, G) => {
          const {
            name: ue,
            value: we
          } = pS(G, W, s);
          if (n.remove_similar || ee(we) || !Tn(u) || IT(p.getAttrib(u, ue), we)) {
            if (ue === "class") {
              const fe = p.getAttrib(T, ue);
              if (fe) {
                let ke = "";
                if (je(fe.split(/\s+/), (He) => {
                  /mce\-\w+/.test(He) && (ke += (ke ? " " : "") + He);
                }), ke) {
                  p.setAttrib(T, ue, ke);
                  return;
                }
              }
            }
            if (Xj.test(ue) && T.removeAttribute("data-mce-" + ue), ue === "style" && hu(["li"])(T) && p.getStyle(T, "list-style-type") === "none") {
              T.removeAttribute(ue), p.setStyle(T, "list-style-type", "none");
              return;
            }
            ue === "class" && T.removeAttribute("className"), T.removeAttribute(ue);
          }
        }), JR(n.classes, (W) => {
          W = Rg(W, s), (!Tn(u) || p.hasClass(u, W)) && p.removeClass(T, W);
        });
        const j = p.getAttribs(T);
        for (let W = 0; W < j.length; W++) {
          const G = j[W].nodeName;
          if (!b.isAttributeInternal(G))
            return mb.keep();
        }
      }
      return n.remove !== "none" ? (JB(e, T, n), mb.removed()) : mb.keep();
    }, tW = (e, n, s, i, u) => {
      let p;
      return n.parentNode && je(rb(e.dom, n.parentNode).reverse(), (b) => {
        if (!p && Tn(b) && b.id !== "_start" && b.id !== "_end") {
          const S = hh(e, b, s, i, u);
          S && S.split !== !1 && (p = b);
        }
      }), p;
    }, Y1 = (e, n, s, i) => oN(e, n, s, i, i).fold(ze(i), (u) => (e.dom.createFragment().appendChild(i), e.dom.rename(i, u)), ze(null)), eL = (e, n, s, i, u, p, b, S) => {
      var T, M;
      let j, W;
      const G = e.dom;
      if (s) {
        const ue = s.parentNode;
        for (let we = i.parentNode; we && we !== ue; we = we.parentNode) {
          let fe = G.clone(we, !1);
          for (let ke = 0; ke < n.length && (fe = Y1(e, n[ke], S, fe), fe !== null); ke++)
            ;
          fe && (j && fe.appendChild(j), W || (W = fe), j = fe);
        }
        (!b.mixed || !G.isBlock(s)) && (i = (T = G.split(s, i)) !== null && T !== void 0 ? T : i), j && W && ((M = u.parentNode) === null || M === void 0 || M.insertBefore(j, u), W.appendChild(u), Li(b) && qB(e, b, S, j));
      }
      return i;
    }, tL = (e, n, s, i, u) => {
      const p = e.formatter.get(n), b = p[0], S = e.dom, T = e.selection, M = (fe) => {
        const ke = tW(e, fe, n, s, u);
        return eL(e, p, ke, fe, fe, !0, b, s);
      }, j = (fe) => Cu(fe) && Tn(fe) && (fe.id === "_start" || fe.id === "_end"), W = (fe) => Vn(p, (ke) => hb(e, ke, s, fe, fe)), G = (fe) => {
        const ke = Ss(fe.childNodes), Ye = W(fe) || Vn(p, (Ut) => uS(S, fe, Ut)), We = fe.parentNode;
        if (!Ye && Ue(We) && vf(b) && W(We), b.deep && ke.length)
          for (let Ut = 0; Ut < ke.length; Ut++)
            G(ke[Ut]);
        je([
          "underline",
          "line-through",
          "overline"
        ], (Ut) => {
          Tn(fe) && e.dom.getStyle(fe, "text-decoration") === Ut && fe.parentNode && DE(S, fe.parentNode) === Ut && hb(e, {
            deep: !1,
            exact: !0,
            inline: "span",
            styles: { textDecoration: Ut }
          }, void 0, fe);
        });
      }, ue = (fe) => {
        const ke = S.get(fe ? "_start" : "_end");
        if (ke) {
          let He = ke[fe ? "firstChild" : "lastChild"];
          return j(He) && (He = He[fe ? "firstChild" : "lastChild"]), Gt(He) && He.data.length === 0 && (He = fe ? ke.previousSibling || ke.nextSibling : ke.nextSibling || ke.previousSibling), S.remove(ke, !0), He;
        } else
          return null;
      }, we = (fe) => {
        let ke, He, Ye = ih(S, fe, p, fe.collapsed);
        if (b.split) {
          if (Ye = Wn(Ye), ke = eN(e, Ye, !0), He = eN(e, Ye), ke !== He) {
            if (ke = QB(ke, !0), He = QB(He, !1), XB(S, ke, He)) {
              const ut = X.from(ke.firstChild).getOr(ke);
              M(pb(S, ut, !0, "span", {
                id: "_start",
                "data-mce-type": "bookmark"
              })), ue(!0);
              return;
            }
            if (XB(S, He, ke)) {
              const ut = X.from(He.lastChild).getOr(He);
              M(pb(S, ut, !1, "span", {
                id: "_end",
                "data-mce-type": "bookmark"
              })), ue(!1);
              return;
            }
            ke = mS(S, ke, "span", {
              id: "_start",
              "data-mce-type": "bookmark"
            }), He = mS(S, He, "span", {
              id: "_end",
              "data-mce-type": "bookmark"
            });
            const We = S.createRng();
            We.setStartAfter(ke), We.setEndBefore(He), O1(S, We, (ut) => {
              je(ut, (Ut) => {
                !Cu(Ut) && !Cu(Ut.parentNode) && M(Ut);
              });
            }), M(ke), M(He), ke = ue(!0), He = ue();
          } else
            ke = He = M(ke);
          Ye.startContainer = ke.parentNode ? ke.parentNode : ke, Ye.startOffset = S.nodeIndex(ke), Ye.endContainer = He.parentNode ? He.parentNode : He, Ye.endOffset = S.nodeIndex(He) + 1;
        }
        O1(S, Ye, (We) => {
          je(We, G);
        });
      };
      if (i) {
        if (sb(i)) {
          const fe = S.createRng();
          fe.setStartBefore(i), fe.setEndAfter(i), we(fe);
        } else
          we(i);
        Su(e, n, i, s);
        return;
      }
      !T.isCollapsed() || !Li(b) || tb(e).length ? (nm(e, () => ob(e, we), (fe) => Li(b) && HR(e, n, s, fe)), e.nodeChanged()) : jR(e, n, s, u), eW(e, n, s), Su(e, n, i, s);
    }, sN = (e, n, s, i, u) => {
      (i || e.selection.isEditable()) && tL(e, n, s, i, u);
    }, hb = (e, n, s, i, u) => oN(e, n, s, i, u).fold(et, (p) => (e.dom.rename(i, p), !0), xt), rN = Kt.each, nW = (e, n, s, i) => {
      const u = (p) => {
        if (Ec(p) && Tn(p.parentNode) && e.isEditable(p)) {
          const b = DE(e, p.parentNode);
          e.getStyle(p, "color") && b ? e.setStyle(p, "text-decoration", b) : e.getStyle(p, "text-decoration") === b && e.setStyle(p, "text-decoration", null);
        }
      };
      n.styles && (n.styles.color || n.styles.textDecoration) && (Kt.walk(i, u, "childNodes"), u(i));
    }, nL = (e, n, s, i) => {
      if (n.styles && n.styles.backgroundColor) {
        const u = QR(e, "fontSize");
        XR(i, (p) => u(p) && e.isEditable(p), YB(e, "backgroundColor", Rg(n.styles.backgroundColor, s)));
      }
    }, oW = (e, n, s, i) => {
      if (Li(n) && (n.inline === "sub" || n.inline === "sup")) {
        const u = QR(e, "fontSize");
        XR(i, (b) => u(b) && e.isEditable(b), YB(e, "fontSize", ""));
        const p = on(e.select(n.inline === "sup" ? "sub" : "sup", i), e.isEditable);
        e.remove(p, !0);
      }
    }, sW = (e, n, s, i) => {
      rN(n, (u) => {
        Li(u) && rN(e.dom.select(u.inline, i), (p) => {
          KR(p) && hb(e, u, s, p, u.exact ? p : null);
        }), KB(e.dom, u, i);
      });
    }, FT = (e, n, s, i, u) => {
      const p = u.parentNode;
      hh(e, p, s, i) && hb(e, n, i, u) || n.merge_with_parents && p && e.dom.getParent(p, (b) => hh(e, b, s, i) ? (hb(e, n, i, u), !0) : !1);
    }, hS = Kt.each, aN = (e, n, s, i) => {
      if (q_(e) && Li(n) && s.parentNode) {
        const u = J0(e.schema), p = q0(Me.fromDom(s), (b) => wu(b.dom));
        return wr(u, i) && Vu(e.schema, s.parentNode, {
          skipBogus: !1,
          includeZwsp: !0
        }) && !p;
      } else
        return !1;
    }, oL = (e, n, s, i) => {
      if (hS(s.styles, (u, p) => {
        e.setStyle(n, p, Rg(u, i));
      }), s.styles) {
        const u = e.getAttrib(n, "style");
        u && e.setAttrib(n, "data-mce-style", u);
      }
    }, rW = (e, n, s, i) => {
      const u = e.formatter.get(n), p = u[0], b = !i && e.selection.isCollapsed(), S = e.dom, T = e.selection, M = (we, fe = p) => {
        Ce(fe.onformat) && fe.onformat(we, fe, s, i), oL(S, we, fe, s), hS(fe.attributes, (ke, He) => {
          S.setAttrib(we, He, Rg(ke, s));
        }), hS(fe.classes, (ke) => {
          const He = Rg(ke, s);
          S.hasClass(we, He) || S.addClass(we, He);
        });
      }, j = (we, fe) => {
        let ke = !1;
        return hS(we, (He) => Ku(He) ? S.getContentEditable(fe) === "false" && !He.ceFalseOverride || Ue(He.collapsed) && He.collapsed !== b ? !0 : S.is(fe, He.selector) && !wu(fe) ? (M(fe, He), ke = !0, !1) : !0 : !1), ke;
      }, W = (we) => {
        if (U(we)) {
          const fe = S.create(we);
          return M(fe), fe;
        } else
          return null;
      }, G = (we, fe, ke) => {
        const He = [];
        let Ye = !0;
        const We = p.inline || p.block, ut = W(We), Ut = (Et) => bD(p) && hh(e, Et, n, s), an = (Et, bt, Ht) => {
          const zn = E1(p) && OC(e.schema, Et) && qm(e, bt, We);
          return Ht && zn;
        }, Nn = (Et, bt, Ht, zn) => {
          const uo = Et.nodeName.toLowerCase(), Go = qm(e, We, uo) && qm(e, bt, We), ys = !ke && Gt(Et) && dg(Et.data), Js = wu(Et), xr = !Li(p) || !we.isBlock(Et);
          return (Ht || zn) && Go && !ys && !Js && xr;
        };
        O1(we, fe, (Et) => {
          let bt;
          const Ht = (zn) => {
            let uo = !1, Go = Ye, ys = !1;
            const Js = zn.parentNode, xr = Js.nodeName.toLowerCase(), Da = we.getContentEditable(zn);
            Ue(Da) && (Go = Ye, Ye = Da === "true", uo = !0, ys = NC(e, zn));
            const yl = Ye && !uo;
            if (Vs(zn) && !aN(e, p, zn, xr)) {
              bt = null, Km(p) && we.remove(zn);
              return;
            }
            if (Ut(zn)) {
              bt = null;
              return;
            }
            if (an(zn, xr, yl)) {
              const mr = we.rename(zn, We);
              M(mr), He.push(mr), bt = null;
              return;
            }
            if (Ku(p)) {
              let mr = j(u, zn);
              if (!mr && Ue(Js) && vf(p) && (mr = j(u, Js)), !Li(p) || mr) {
                bt = null;
                return;
              }
            }
            Ue(ut) && Nn(zn, xr, yl, ys) ? (bt || (bt = we.clone(ut, !1), Js.insertBefore(bt, zn), He.push(bt)), ys && uo && (Ye = Go), bt.appendChild(zn)) : (bt = null, je(Ss(zn.childNodes), Ht), uo && (Ye = Go), bt = null);
          };
          je(Et, Ht);
        }), p.links === !0 && je(He, (Et) => {
          const bt = (Ht) => {
            Ht.nodeName === "A" && M(Ht, p), je(Ss(Ht.childNodes), bt);
          };
          bt(Et);
        }), je(He, (Et) => {
          const bt = (uo) => {
            let Go = 0;
            return je(uo.childNodes, (ys) => {
              !nx(ys) && !Cu(ys) && Go++;
            }), Go;
          }, Ht = (uo) => Dn(uo.childNodes, AC).filter((ys) => we.getContentEditable(ys) !== "false" && uS(we, ys, p)).map((ys) => {
            const Js = we.clone(ys, !1);
            return M(Js), we.replace(Js, uo, !0), we.remove(ys, !0), Js;
          }).getOr(uo), zn = bt(Et);
          if ((He.length > 1 || !we.isBlock(Et)) && zn === 0) {
            we.remove(Et, !0);
            return;
          }
          (Li(p) || Km(p) && p.wrapper) && (!p.exact && zn === 1 && (Et = Ht(Et)), sW(e, u, s, Et), FT(e, p, n, s, Et), nL(we, p, s, Et), nW(we, p, s, Et), oW(we, p, s, Et), qB(e, p, s, Et));
        });
      }, ue = sb(i) ? i : T.getNode();
      if (S.getContentEditable(ue) === "false" && !NC(e, ue)) {
        i = ue, j(u, i), Xu(e, n, i, s);
        return;
      }
      if (p) {
        if (i)
          if (sb(i)) {
            if (!j(u, i)) {
              const we = S.createRng();
              we.setStartBefore(i), we.setEndAfter(i), G(S, ih(S, we, u), !0);
            }
          } else
            G(S, i, !0);
        else
          !b || !Li(p) || tb(e).length ? (T.setRng(jr(T.getRng())), nm(e, () => {
            ob(e, (we, fe) => {
              const ke = fe ? we : ih(S, we, u);
              G(S, ke, !1);
            });
          }, xt), e.nodeChanged()) : HB(e, n, s), ZB(e.formatter, n).each((we) => {
            je(qR(e.selection), (fe) => oL(S, fe, we, s));
          });
        Rre(n, e);
      }
      Xu(e, n, i, s);
    }, iN = (e, n, s, i) => {
      (i || e.selection.isEditable()) && rW(e, n, s, i);
    }, BT = (e) => Xn(e, "vars"), sL = (e, n) => {
      e.set({}), n.on("NodeChange", (s) => {
        gS(n, s.element, e.get());
      }), n.on("FormatApply FormatRemove", (s) => {
        const i = X.from(s.node).map((u) => sb(u) ? u : u.startContainer).bind((u) => Tn(u) ? X.some(u) : X.from(u.parentElement)).getOrThunk(() => rL(n));
        gS(n, i, e.get());
      });
    }, rL = (e) => e.selection.getStart(), aL = (e, n, s, i, u) => oo(n, (S) => {
      const T = e.formatter.matchNode(S, s, u ?? {}, i);
      return !wt(T);
    }, (S) => $R(e, S, s) ? !0 : i ? !1 : Ue(e.formatter.matchNode(S, s, u, !0))), iL = (e, n) => {
      const s = n ?? rL(e);
      return on(rb(e.dom, s), (i) => Tn(i) && !Mm(i));
    }, gS = (e, n, s) => {
      const i = iL(e, n);
      qt(s, (u, p) => {
        const b = (S) => {
          const T = aL(e, i, p, S.similar, BT(S) ? S.vars : void 0), M = T.isSome();
          if (S.state.get() !== M) {
            S.state.set(M);
            const j = T.getOr(n);
            BT(S) ? S.callback(M, {
              node: j,
              format: p,
              parents: i
            }) : je(S.callbacks, (W) => W(M, {
              node: j,
              format: p,
              parents: i
            }));
          }
        };
        je([
          u.withSimilar,
          u.withoutSimilar
        ], b), je(u.withVars, b);
      });
    }, Hg = (e, n, s, i, u, p) => {
      const b = n.get();
      je(s.split(","), (S) => {
        const T = _s(b, S).getOrThunk(() => {
          const j = {
            withSimilar: {
              state: Xe(!1),
              similar: !0,
              callbacks: []
            },
            withoutSimilar: {
              state: Xe(!1),
              similar: !1,
              callbacks: []
            },
            withVars: []
          };
          return b[S] = j, j;
        }), M = () => {
          const j = iL(e);
          return aL(e, j, S, u, p).isSome();
        };
        if (wt(p)) {
          const j = u ? T.withSimilar : T.withoutSimilar;
          j.callbacks.push(i), j.callbacks.length === 1 && j.state.set(M());
        } else
          T.withVars.push({
            state: Xe(M()),
            similar: u,
            vars: p,
            callback: i
          });
      }), n.set(b);
    }, aW = (e, n, s) => {
      const i = e.get();
      je(n.split(","), (u) => _s(i, u).each((p) => {
        i[u] = {
          withSimilar: {
            ...p.withSimilar,
            callbacks: on(p.withSimilar.callbacks, (b) => b !== s)
          },
          withoutSimilar: {
            ...p.withoutSimilar,
            callbacks: on(p.withoutSimilar.callbacks, (b) => b !== s)
          },
          withVars: on(p.withVars, (b) => b.callback !== s)
        };
      })), e.set(i);
    }, lN = (e, n, s, i, u, p) => (Hg(e, n, s, i, u, p), { unbind: () => aW(n, s, i) }), oi = (e, n, s, i) => {
      const u = e.formatter.get(n);
      u && (HR(e, n, s, i) && (!("toggle" in u[0]) || u[0].toggle) ? sN(e, n, s, i) : iN(e, n, s, i));
    }, LT = Kt.explode, $T = () => {
      const e = {};
      return {
        addFilter: (u, p) => {
          je(LT(u), (b) => {
            Xn(e, b) || (e[b] = {
              name: b,
              callbacks: []
            }), e[b].callbacks.push(p);
          });
        },
        getFilters: () => la(e),
        removeFilter: (u, p) => {
          je(LT(u), (b) => {
            if (Xn(e, b))
              if (Ue(p)) {
                const S = e[b], T = on(S.callbacks, (M) => M !== p);
                T.length > 0 ? S.callbacks = T : delete e[b];
              } else
                delete e[b];
          });
        }
      };
    }, zg = (e, n) => {
      je(n, (s) => {
        e.attr(s, null);
      });
    }, lL = (e, n, s) => {
      e.addNodeFilter("font", (i) => {
        je(i, (u) => {
          const p = n.parse(u.attr("style")), b = u.attr("color"), S = u.attr("face"), T = u.attr("size");
          b && (p.color = b), S && (p["font-family"] = S), T && Ba(T).each((M) => {
            p["font-size"] = s[M - 1];
          }), u.name = "span", u.attr("style", n.serialize(p)), zg(u, [
            "color",
            "face",
            "size"
          ]);
        });
      });
    }, cL = (e, n, s) => {
      e.addNodeFilter("strike", (i) => {
        const u = n.type !== "html4";
        je(i, (p) => {
          if (u)
            p.name = "s";
          else {
            const b = s.parse(p.attr("style"));
            b["text-decoration"] = "line-through", p.name = "span", p.attr("style", s.serialize(b));
          }
        });
      });
    }, vS = (e, n, s) => {
      var i;
      const u = aw();
      n.convert_fonts_to_spans && lL(e, u, Kt.explode((i = n.font_size_legacy_values) !== null && i !== void 0 ? i : "")), cL(e, s, u);
    }, iW = (e, n, s) => {
      n.inline_styles && vS(e, n, s);
    }, lW = (e) => fetch(e).then((n) => n.ok ? n.blob() : Promise.reject()).catch(() => Promise.reject({
      message: `Cannot convert ${e} to Blob. Resource might not exist or is inaccessible.`,
      uriType: "blob"
    })), Nx = (e) => {
      const n = /([a-z0-9+\/=\s]+)/i.exec(e);
      return n ? n[1] : "";
    }, cN = (e) => {
      const [n, ...s] = e.split(","), i = s.join(","), u = /data:([^/]+\/[^;]+)(;.+)?/.exec(n);
      if (u) {
        const p = u[2] === ";base64", b = p ? Nx(i) : decodeURIComponent(i);
        return X.some({
          type: u[1],
          data: b,
          base64Encoded: p
        });
      } else
        return X.none();
    }, gb = (e, n, s = !0) => {
      let i = n;
      if (s)
        try {
          i = atob(n);
        } catch {
          return X.none();
        }
      const u = new Uint8Array(i.length);
      for (let p = 0; p < u.length; p++)
        u[p] = i.charCodeAt(p);
      return X.some(new Blob([u], { type: e }));
    }, cW = (e) => new Promise((n, s) => {
      cN(e).bind(({ type: i, data: u, base64Encoded: p }) => gb(i, u, p)).fold(() => s("Invalid data URI"), n);
    }), vb = (e) => co(e, "blob:") ? lW(e) : co(e, "data:") ? cW(e) : Promise.reject("Unknown URI format"), uL = (e) => new Promise((n, s) => {
      const i = new FileReader();
      i.onloadend = () => {
        n(i.result);
      }, i.onerror = () => {
        var u;
        s((u = i.error) === null || u === void 0 ? void 0 : u.message);
      }, i.readAsDataURL(e);
    });
    let yf = 0;
    const bS = (e) => "blobid" + yf++, HT = (e, n, s) => cN(e).bind(({ data: i, type: u, base64Encoded: p }) => {
      if (n && !p)
        return X.none();
      {
        const b = p ? i : btoa(i);
        return s(b, u);
      }
    }), zT = (e, n, s) => {
      const i = e.create(bS(), n, s);
      return e.add(i), i;
    }, dL = (e, n, s = !1) => HT(n, s, (i, u) => X.from(e.getByData(i, u)).orThunk(() => gb(u, i).map((p) => zT(e, p, i)))), VT = (e, n) => {
      const s = () => Promise.reject("Invalid data URI");
      if (co(n, "blob:")) {
        const i = e.getByUri(n);
        return Ue(i) ? Promise.resolve(i) : vb(n).then((u) => uL(u).then((p) => HT(p, !1, (b) => X.some(zT(e, u, b))).getOrThunk(s)));
      } else return co(n, "data:") ? dL(e, n).fold(s, (i) => Promise.resolve(i)) : Promise.reject("Unknown image data format");
    }, uW = /^(?:(?:(?:[A-Za-z][A-Za-z\d.+-]{0,14}:\/\/(?:[-.~*+=!&;:'%@?^${}(),\w]+@)?|www\.|[-;:&=+$,.\w]+@)([A-Za-z\d-]+(?:\.[A-Za-z\d-]+)*))(?::\d+)?(?:\/(?:[-.~*+=!;:'%@$(),\/\w]*[-~*+=%@$()\/\w])?)?(?:\?(?:[-.~*+=!&;:'%@?^${}(),\/\w]+)?)?(?:#(?:[-.~*+=!&;:'%@?^${}(),\/\w]+)?)?)$/, lm = (e) => X.from(e.match(uW)).bind((n) => xn(n, 1)).map((n) => co(n, "www.") ? n.substring(4) : n), yS = (e, n) => {
      X.from(e.attr("src")).bind(lm).forall((s) => !Nt(n, s)) && e.attr("sandbox", "");
    }, UT = (e, n) => co(e, `${n}/`), uN = (e) => wt(e) ? "iframe" : UT(e, "image") ? "img" : UT(e, "video") ? "video" : UT(e, "audio") ? "audio" : "iframe", dN = ({ type: e, src: n, width: s, height: i } = {}, u, p) => {
      const b = uN(e), S = new ou(b, 1);
      return S.attr(b === "audio" ? { src: n } : {
        src: n,
        width: s,
        height: i
      }), (b === "audio" || b === "video") && S.attr("controls", ""), b === "iframe" && u && yS(S, p), S;
    }, X1 = (e) => Ue(e.attr("data-mce-bogus")), fN = (e) => e.attr("src") === sn.transparentSrc || Ue(e.attr("data-mce-placeholder")), dW = (e, n) => {
      const { blob_cache: s } = n;
      if (s) {
        const i = (u) => {
          const p = u.attr("src");
          fN(u) || X1(u) || Vt(p) || dL(s, p, !0).each((b) => {
            u.attr("src", b.blobUri());
          });
        };
        e.addAttributeFilter("src", (u) => je(u, i));
      }
    }, fL = (e, n) => {
      var s, i;
      const u = e.schema;
      e.addAttributeFilter("href", (T) => {
        let M = T.length;
        const j = (G) => G.split(" ").filter((we) => we.length > 0).concat(["noopener"]).sort().join(" "), W = (G) => {
          const ue = G ? Kt.trim(G) : "";
          return /\b(noopener)\b/g.test(ue) ? ue : j(ue);
        };
        if (!n.allow_unsafe_link_target)
          for (; M--; ) {
            const G = T[M];
            G.name === "a" && G.attr("target") === "_blank" && G.attr("rel", W(G.attr("rel")));
          }
      }), n.allow_html_in_named_anchor || e.addAttributeFilter("id,name", (T) => {
        let M = T.length, j, W, G, ue;
        for (; M--; )
          if (ue = T[M], ue.name === "a" && ue.firstChild && !ue.attr("href"))
            for (G = ue.parent, j = ue.lastChild; j && G; )
              W = j.prev, G.insert(j, ue), j = W;
      }), n.fix_list_elements && e.addNodeFilter("ul,ol", (T) => {
        let M = T.length, j, W;
        for (; M--; )
          if (j = T[M], W = j.parent, W && (W.name === "ul" || W.name === "ol"))
            if (j.prev && j.prev.name === "li")
              j.prev.append(j);
            else {
              const G = new ou("li", 1);
              G.attr("style", "list-style-type: none"), j.wrap(G);
            }
      });
      const p = u.getValidClasses();
      n.validate && p && e.addAttributeFilter("class", (T) => {
        var M;
        let j = T.length;
        for (; j--; ) {
          const W = T[j], G = (M = W.attr("class")) !== null && M !== void 0 ? M : "", ue = Kt.explode(G, " ");
          let we = "";
          for (let fe = 0; fe < ue.length; fe++) {
            const ke = ue[fe];
            let He = !1, Ye = p["*"];
            Ye && Ye[ke] && (He = !0), Ye = p[W.name], !He && Ye && Ye[ke] && (He = !0), He && (we && (we += " "), we += ke);
          }
          we.length || (we = null), W.attr("class", we);
        }
      }), dW(e, n);
      const b = (s = n.sandbox_iframes) !== null && s !== void 0 ? s : !1, S = ta((i = n.sandbox_iframes_exclusions) !== null && i !== void 0 ? i : []);
      n.convert_unsafe_embeds && e.addNodeFilter("object,embed", (T) => je(T, (M) => {
        M.replace(dN({
          type: M.attr("type"),
          src: M.name === "object" ? M.attr("data") : M.attr("src"),
          width: M.attr("width"),
          height: M.attr("height")
        }, b, S));
      })), b && e.addNodeFilter("iframe", (T) => je(T, (M) => yS(M, S)));
    }, { entries: mL, setPrototypeOf: pL, isFrozen: fW, getPrototypeOf: mW, getOwnPropertyDescriptor: xS } = Object;
    let { freeze: nd, seal: cm, create: mN } = Object, { apply: pN, construct: jT } = typeof Reflect < "u" && Reflect;
    pN || (pN = function(n, s, i) {
      return n.apply(s, i);
    }), nd || (nd = function(n) {
      return n;
    }), cm || (cm = function(n) {
      return n;
    }), jT || (jT = function(n, s) {
      return new n(...s);
    });
    const hL = um(Array.prototype.forEach), pW = um(Array.prototype.pop), wS = um(Array.prototype.push), WT = um(String.prototype.toLowerCase), hN = um(String.prototype.toString), hW = um(String.prototype.match), tp = um(String.prototype.replace), gW = um(String.prototype.indexOf), vW = um(String.prototype.trim), xf = um(RegExp.prototype.test), CS = bW(TypeError);
    function um(e) {
      return function(n) {
        for (var s = arguments.length, i = new Array(s > 1 ? s - 1 : 0), u = 1; u < s; u++)
          i[u - 1] = arguments[u];
        return pN(e, n, i);
      };
    }
    function bW(e) {
      return function() {
        for (var n = arguments.length, s = new Array(n), i = 0; i < n; i++)
          s[i] = arguments[i];
        return jT(e, s);
      };
    }
    function _r(e, n, s) {
      var i;
      s = (i = s) !== null && i !== void 0 ? i : WT, pL && pL(e, null);
      let u = n.length;
      for (; u--; ) {
        let p = n[u];
        if (typeof p == "string") {
          const b = s(p);
          b !== p && (fW(n) || (n[u] = b), p = b);
        }
        e[p] = !0;
      }
      return e;
    }
    function Q1(e) {
      const n = mN(null);
      for (const [s, i] of mL(e))
        n[s] = i;
      return n;
    }
    function ZT(e, n) {
      for (; e !== null; ) {
        const i = xS(e, n);
        if (i) {
          if (i.get)
            return um(i.get);
          if (typeof i.value == "function")
            return um(i.value);
        }
        e = mW(e);
      }
      function s(i) {
        return console.warn("fallback value for", i), null;
      }
      return s;
    }
    const J1 = nd([
      "a",
      "abbr",
      "acronym",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "bdi",
      "bdo",
      "big",
      "blink",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "center",
      "cite",
      "code",
      "col",
      "colgroup",
      "content",
      "data",
      "datalist",
      "dd",
      "decorator",
      "del",
      "details",
      "dfn",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "element",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "font",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "map",
      "mark",
      "marquee",
      "menu",
      "menuitem",
      "meter",
      "nav",
      "nobr",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "section",
      "select",
      "shadow",
      "small",
      "source",
      "spacer",
      "span",
      "strike",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "template",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "track",
      "tt",
      "u",
      "ul",
      "var",
      "video",
      "wbr"
    ]), gN = nd([
      "svg",
      "a",
      "altglyph",
      "altglyphdef",
      "altglyphitem",
      "animatecolor",
      "animatemotion",
      "animatetransform",
      "circle",
      "clippath",
      "defs",
      "desc",
      "ellipse",
      "filter",
      "font",
      "g",
      "glyph",
      "glyphref",
      "hkern",
      "image",
      "line",
      "lineargradient",
      "marker",
      "mask",
      "metadata",
      "mpath",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialgradient",
      "rect",
      "stop",
      "style",
      "switch",
      "symbol",
      "text",
      "textpath",
      "title",
      "tref",
      "tspan",
      "view",
      "vkern"
    ]), vN = nd([
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence"
    ]), yW = nd([
      "animate",
      "color-profile",
      "cursor",
      "discard",
      "font-face",
      "font-face-format",
      "font-face-name",
      "font-face-src",
      "font-face-uri",
      "foreignobject",
      "hatch",
      "hatchpath",
      "mesh",
      "meshgradient",
      "meshpatch",
      "meshrow",
      "missing-glyph",
      "script",
      "set",
      "solidcolor",
      "unknown",
      "use"
    ]), bN = nd([
      "math",
      "menclose",
      "merror",
      "mfenced",
      "mfrac",
      "mglyph",
      "mi",
      "mlabeledtr",
      "mmultiscripts",
      "mn",
      "mo",
      "mover",
      "mpadded",
      "mphantom",
      "mroot",
      "mrow",
      "ms",
      "mspace",
      "msqrt",
      "mstyle",
      "msub",
      "msup",
      "msubsup",
      "mtable",
      "mtd",
      "mtext",
      "mtr",
      "munder",
      "munderover",
      "mprescripts"
    ]), gL = nd([
      "maction",
      "maligngroup",
      "malignmark",
      "mlongdiv",
      "mscarries",
      "mscarry",
      "msgroup",
      "mstack",
      "msline",
      "msrow",
      "semantics",
      "annotation",
      "annotation-xml",
      "mprescripts",
      "none"
    ]), vL = nd(["#text"]), bL = nd([
      "accept",
      "action",
      "align",
      "alt",
      "autocapitalize",
      "autocomplete",
      "autopictureinpicture",
      "autoplay",
      "background",
      "bgcolor",
      "border",
      "capture",
      "cellpadding",
      "cellspacing",
      "checked",
      "cite",
      "class",
      "clear",
      "color",
      "cols",
      "colspan",
      "controls",
      "controlslist",
      "coords",
      "crossorigin",
      "datetime",
      "decoding",
      "default",
      "dir",
      "disabled",
      "disablepictureinpicture",
      "disableremoteplayback",
      "download",
      "draggable",
      "enctype",
      "enterkeyhint",
      "face",
      "for",
      "headers",
      "height",
      "hidden",
      "high",
      "href",
      "hreflang",
      "id",
      "inputmode",
      "integrity",
      "ismap",
      "kind",
      "label",
      "lang",
      "list",
      "loading",
      "loop",
      "low",
      "max",
      "maxlength",
      "media",
      "method",
      "min",
      "minlength",
      "multiple",
      "muted",
      "name",
      "nonce",
      "noshade",
      "novalidate",
      "nowrap",
      "open",
      "optimum",
      "pattern",
      "placeholder",
      "playsinline",
      "poster",
      "preload",
      "pubdate",
      "radiogroup",
      "readonly",
      "rel",
      "required",
      "rev",
      "reversed",
      "role",
      "rows",
      "rowspan",
      "spellcheck",
      "scope",
      "selected",
      "shape",
      "size",
      "sizes",
      "span",
      "srclang",
      "start",
      "src",
      "srcset",
      "step",
      "style",
      "summary",
      "tabindex",
      "title",
      "translate",
      "type",
      "usemap",
      "valign",
      "value",
      "width",
      "xmlns",
      "slot"
    ]), yN = nd([
      "accent-height",
      "accumulate",
      "additive",
      "alignment-baseline",
      "ascent",
      "attributename",
      "attributetype",
      "azimuth",
      "basefrequency",
      "baseline-shift",
      "begin",
      "bias",
      "by",
      "class",
      "clip",
      "clippathunits",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "cx",
      "cy",
      "d",
      "dx",
      "dy",
      "diffuseconstant",
      "direction",
      "display",
      "divisor",
      "dur",
      "edgemode",
      "elevation",
      "end",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "filterunits",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "fx",
      "fy",
      "g1",
      "g2",
      "glyph-name",
      "glyphref",
      "gradientunits",
      "gradienttransform",
      "height",
      "href",
      "id",
      "image-rendering",
      "in",
      "in2",
      "k",
      "k1",
      "k2",
      "k3",
      "k4",
      "kerning",
      "keypoints",
      "keysplines",
      "keytimes",
      "lang",
      "lengthadjust",
      "letter-spacing",
      "kernelmatrix",
      "kernelunitlength",
      "lighting-color",
      "local",
      "marker-end",
      "marker-mid",
      "marker-start",
      "markerheight",
      "markerunits",
      "markerwidth",
      "maskcontentunits",
      "maskunits",
      "max",
      "mask",
      "media",
      "method",
      "mode",
      "min",
      "name",
      "numoctaves",
      "offset",
      "operator",
      "opacity",
      "order",
      "orient",
      "orientation",
      "origin",
      "overflow",
      "paint-order",
      "path",
      "pathlength",
      "patterncontentunits",
      "patterntransform",
      "patternunits",
      "points",
      "preservealpha",
      "preserveaspectratio",
      "primitiveunits",
      "r",
      "rx",
      "ry",
      "radius",
      "refx",
      "refy",
      "repeatcount",
      "repeatdur",
      "restart",
      "result",
      "rotate",
      "scale",
      "seed",
      "shape-rendering",
      "specularconstant",
      "specularexponent",
      "spreadmethod",
      "startoffset",
      "stddeviation",
      "stitchtiles",
      "stop-color",
      "stop-opacity",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke",
      "stroke-width",
      "style",
      "surfacescale",
      "systemlanguage",
      "tabindex",
      "targetx",
      "targety",
      "transform",
      "transform-origin",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "textlength",
      "type",
      "u1",
      "u2",
      "unicode",
      "values",
      "viewbox",
      "visibility",
      "version",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "width",
      "word-spacing",
      "wrap",
      "writing-mode",
      "xchannelselector",
      "ychannelselector",
      "x",
      "x1",
      "x2",
      "xmlns",
      "y",
      "y1",
      "y2",
      "z",
      "zoomandpan"
    ]), yL = nd([
      "accent",
      "accentunder",
      "align",
      "bevelled",
      "close",
      "columnsalign",
      "columnlines",
      "columnspan",
      "denomalign",
      "depth",
      "dir",
      "display",
      "displaystyle",
      "encoding",
      "fence",
      "frame",
      "height",
      "href",
      "id",
      "largeop",
      "length",
      "linethickness",
      "lspace",
      "lquote",
      "mathbackground",
      "mathcolor",
      "mathsize",
      "mathvariant",
      "maxsize",
      "minsize",
      "movablelimits",
      "notation",
      "numalign",
      "open",
      "rowalign",
      "rowlines",
      "rowspacing",
      "rowspan",
      "rspace",
      "rquote",
      "scriptlevel",
      "scriptminsize",
      "scriptsizemultiplier",
      "selection",
      "separator",
      "separators",
      "stretchy",
      "subscriptshift",
      "supscriptshift",
      "symmetric",
      "voffset",
      "width",
      "xmlns"
    ]), GT = nd([
      "xlink:href",
      "xml:id",
      "xlink:title",
      "xml:space",
      "xmlns:xlink"
    ]), xW = cm(/\{\{[\w\W]*|[\w\W]*\}\}/gm), wW = cm(/<%[\w\W]*|[\w\W]*%>/gm), CW = cm(/\${[\w\W]*}/gm), SW = cm(/^data-[\-\w.\u00B7-\uFFFF]/), kW = cm(/^aria-[\-\w]+$/), qT = cm(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), xL = cm(/^(?:\w+script|data):/i), Pre = cm(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), Px = cm(/^html$/i);
    var wL = Object.freeze({
      __proto__: null,
      MUSTACHE_EXPR: xW,
      ERB_EXPR: wW,
      TMPLIT_EXPR: CW,
      DATA_ATTR: SW,
      ARIA_ATTR: kW,
      IS_ALLOWED_URI: qT,
      IS_SCRIPT_OR_DATA: xL,
      ATTR_WHITESPACE: Pre,
      DOCTYPE_NAME: Px
    });
    const CL = () => typeof window > "u" ? null : window, _W = function(n, s) {
      if (typeof n != "object" || typeof n.createPolicy != "function")
        return null;
      let i = null;
      const u = "data-tt-policy-suffix";
      s && s.hasAttribute(u) && (i = s.getAttribute(u));
      const p = "dompurify" + (i ? "#" + i : "");
      try {
        return n.createPolicy(p, {
          createHTML(b) {
            return b;
          },
          createScriptURL(b) {
            return b;
          }
        });
      } catch {
        return console.warn("TrustedTypes policy " + p + " could not be created."), null;
      }
    };
    function SS() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : CL();
      const n = (Cs) => SS(Cs);
      if (n.version = "3.0.5", n.removed = [], !e || !e.document || e.document.nodeType !== 9)
        return n.isSupported = !1, n;
      const s = e.document, i = s.currentScript;
      let { document: u } = e;
      const { DocumentFragment: p, HTMLTemplateElement: b, Node: S, Element: T, NodeFilter: M, NamedNodeMap: j = e.NamedNodeMap || e.MozNamedAttrMap, HTMLFormElement: W, DOMParser: G, trustedTypes: ue } = e, we = T.prototype, fe = ZT(we, "cloneNode"), ke = ZT(we, "nextSibling"), He = ZT(we, "childNodes"), Ye = ZT(we, "parentNode");
      if (typeof b == "function") {
        const Cs = u.createElement("template");
        Cs.content && Cs.content.ownerDocument && (u = Cs.content.ownerDocument);
      }
      let We, ut = "";
      const { implementation: Ut, createNodeIterator: an, createDocumentFragment: Nn, getElementsByTagName: Et } = u, { importNode: bt } = s;
      let Ht = {};
      n.isSupported = typeof mL == "function" && typeof Ye == "function" && Ut && Ut.createHTMLDocument !== void 0;
      const { MUSTACHE_EXPR: zn, ERB_EXPR: uo, TMPLIT_EXPR: Go, DATA_ATTR: ys, ARIA_ATTR: Js, IS_SCRIPT_OR_DATA: xr, ATTR_WHITESPACE: Da } = wL;
      let { IS_ALLOWED_URI: yl } = wL, mr = null;
      const mn = _r({}, [
        ...J1,
        ...gN,
        ...vN,
        ...bN,
        ...vL
      ]);
      let ro = null;
      const Hs = _r({}, [
        ...bL,
        ...yN,
        ...yL,
        ...GT
      ]);
      let Sn = Object.seal(Object.create(null, {
        tagNameCheck: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: null
        },
        attributeNameCheck: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: null
        },
        allowCustomizedBuiltInElements: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: !1
        }
      })), bo = null, cs = null, On = !0, us = !0, ws = !1, Vi = !0, ar = !1, hi = !1, Bd = !1, vm = !1, gc = !1, Au = !1, rd = !1, Ou = !0, Ld = !1;
      const fo = "user-content-";
      let Ps = !0, ya = !1, Ra = {}, si = null;
      const sl = _r({}, [
        "annotation-xml",
        "audio",
        "colgroup",
        "desc",
        "foreignobject",
        "head",
        "iframe",
        "math",
        "mi",
        "mn",
        "mo",
        "ms",
        "mtext",
        "noembed",
        "noframes",
        "noscript",
        "plaintext",
        "script",
        "style",
        "svg",
        "template",
        "thead",
        "title",
        "video",
        "xmp"
      ]);
      let ja = null;
      const Fa = _r({}, [
        "audio",
        "video",
        "img",
        "source",
        "image",
        "track"
      ]);
      let Gl = null;
      const ad = _r({}, [
        "alt",
        "class",
        "for",
        "id",
        "label",
        "name",
        "pattern",
        "placeholder",
        "role",
        "summary",
        "title",
        "value",
        "style",
        "xmlns"
      ]), Tf = "http://www.w3.org/1998/Math/MathML", Af = "http://www.w3.org/2000/svg", $d = "http://www.w3.org/1999/xhtml";
      let Eh = $d, _0 = !1, E0 = null;
      const v5 = _r({}, [
        Tf,
        Af,
        $d
      ], hN);
      let Th;
      const X3 = [
        "application/xhtml+xml",
        "text/html"
      ], Fz = "text/html";
      let vc, Ob = null;
      const Bz = u.createElement("form"), Q3 = function(t) {
        return t instanceof RegExp || t instanceof Function;
      }, Of = function(t) {
        if (!(Ob && Ob === t)) {
          if ((!t || typeof t != "object") && (t = {}), t = Q1(t), Th = X3.indexOf(t.PARSER_MEDIA_TYPE) === -1 ? Th = Fz : Th = t.PARSER_MEDIA_TYPE, vc = Th === "application/xhtml+xml" ? hN : WT, mr = "ALLOWED_TAGS" in t ? _r({}, t.ALLOWED_TAGS, vc) : mn, ro = "ALLOWED_ATTR" in t ? _r({}, t.ALLOWED_ATTR, vc) : Hs, E0 = "ALLOWED_NAMESPACES" in t ? _r({}, t.ALLOWED_NAMESPACES, hN) : v5, Gl = "ADD_URI_SAFE_ATTR" in t ? _r(Q1(ad), t.ADD_URI_SAFE_ATTR, vc) : ad, ja = "ADD_DATA_URI_TAGS" in t ? _r(Q1(Fa), t.ADD_DATA_URI_TAGS, vc) : Fa, si = "FORBID_CONTENTS" in t ? _r({}, t.FORBID_CONTENTS, vc) : sl, bo = "FORBID_TAGS" in t ? _r({}, t.FORBID_TAGS, vc) : {}, cs = "FORBID_ATTR" in t ? _r({}, t.FORBID_ATTR, vc) : {}, Ra = "USE_PROFILES" in t ? t.USE_PROFILES : !1, On = t.ALLOW_ARIA_ATTR !== !1, us = t.ALLOW_DATA_ATTR !== !1, ws = t.ALLOW_UNKNOWN_PROTOCOLS || !1, Vi = t.ALLOW_SELF_CLOSE_IN_ATTR !== !1, ar = t.SAFE_FOR_TEMPLATES || !1, hi = t.WHOLE_DOCUMENT || !1, gc = t.RETURN_DOM || !1, Au = t.RETURN_DOM_FRAGMENT || !1, rd = t.RETURN_TRUSTED_TYPE || !1, vm = t.FORCE_BODY || !1, Ou = t.SANITIZE_DOM !== !1, Ld = t.SANITIZE_NAMED_PROPS || !1, Ps = t.KEEP_CONTENT !== !1, ya = t.IN_PLACE || !1, yl = t.ALLOWED_URI_REGEXP || qT, Eh = t.NAMESPACE || $d, Sn = t.CUSTOM_ELEMENT_HANDLING || {}, t.CUSTOM_ELEMENT_HANDLING && Q3(t.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Sn.tagNameCheck = t.CUSTOM_ELEMENT_HANDLING.tagNameCheck), t.CUSTOM_ELEMENT_HANDLING && Q3(t.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Sn.attributeNameCheck = t.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), t.CUSTOM_ELEMENT_HANDLING && typeof t.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Sn.allowCustomizedBuiltInElements = t.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), ar && (us = !1), Au && (gc = !0), Ra && (mr = _r({}, [...vL]), ro = [], Ra.html === !0 && (_r(mr, J1), _r(ro, bL)), Ra.svg === !0 && (_r(mr, gN), _r(ro, yN), _r(ro, GT)), Ra.svgFilters === !0 && (_r(mr, vN), _r(ro, yN), _r(ro, GT)), Ra.mathMl === !0 && (_r(mr, bN), _r(ro, yL), _r(ro, GT))), t.ADD_TAGS && (mr === mn && (mr = Q1(mr)), _r(mr, t.ADD_TAGS, vc)), t.ADD_ATTR && (ro === Hs && (ro = Q1(ro)), _r(ro, t.ADD_ATTR, vc)), t.ADD_URI_SAFE_ATTR && _r(Gl, t.ADD_URI_SAFE_ATTR, vc), t.FORBID_CONTENTS && (si === sl && (si = Q1(si)), _r(si, t.FORBID_CONTENTS, vc)), Ps && (mr["#text"] = !0), hi && _r(mr, [
            "html",
            "head",
            "body"
          ]), mr.table && (_r(mr, ["tbody"]), delete bo.tbody), t.TRUSTED_TYPES_POLICY) {
            if (typeof t.TRUSTED_TYPES_POLICY.createHTML != "function")
              throw CS('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
            if (typeof t.TRUSTED_TYPES_POLICY.createScriptURL != "function")
              throw CS('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
            We = t.TRUSTED_TYPES_POLICY, ut = We.createHTML("");
          } else
            We === void 0 && (We = _W(ue, i)), We !== null && typeof ut == "string" && (ut = We.createHTML(""));
          nd && nd(t), Ob = t;
        }
      }, kk = _r({}, [
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext"
      ]), mt = _r({}, [
        "foreignobject",
        "desc",
        "title",
        "annotation-xml"
      ]), yt = _r({}, [
        "title",
        "style",
        "font",
        "a",
        "script"
      ]), dn = _r({}, gN);
      _r(dn, vN), _r(dn, yW);
      const nn = _r({}, bN);
      _r(nn, gL);
      const Eo = function(t) {
        let r = Ye(t);
        (!r || !r.tagName) && (r = {
          namespaceURI: Eh,
          tagName: "template"
        });
        const l = WT(t.tagName), d = WT(r.tagName);
        return E0[t.namespaceURI] ? t.namespaceURI === Af ? r.namespaceURI === $d ? l === "svg" : r.namespaceURI === Tf ? l === "svg" && (d === "annotation-xml" || kk[d]) : !!dn[l] : t.namespaceURI === Tf ? r.namespaceURI === $d ? l === "math" : r.namespaceURI === Af ? l === "math" && mt[d] : !!nn[l] : t.namespaceURI === $d ? r.namespaceURI === Af && !mt[d] || r.namespaceURI === Tf && !kk[d] ? !1 : !nn[l] && (yt[l] || !dn[l]) : !!(Th === "application/xhtml+xml" && E0[t.namespaceURI]) : !1;
      }, Es = function(t) {
        wS(n.removed, { element: t });
        try {
          t.parentNode.removeChild(t);
        } catch {
          t.remove();
        }
      }, pa = function(t, r) {
        try {
          wS(n.removed, {
            attribute: r.getAttributeNode(t),
            from: r
          });
        } catch {
          wS(n.removed, {
            attribute: null,
            from: r
          });
        }
        if (r.removeAttribute(t), t === "is" && !ro[t])
          if (gc || Au)
            try {
              Es(r);
            } catch {
            }
          else
            try {
              r.setAttribute(t, "");
            } catch {
            }
      }, bm = function(t) {
        let r, l;
        if (vm)
          t = "<remove></remove>" + t;
        else {
          const y = hW(t, /^[\r\n\t ]+/);
          l = y && y[0];
        }
        Th === "application/xhtml+xml" && Eh === $d && (t = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + t + "</body></html>");
        const d = We ? We.createHTML(t) : t;
        if (Eh === $d)
          try {
            r = new G().parseFromString(d, Th);
          } catch {
          }
        if (!r || !r.documentElement) {
          r = Ut.createDocument(Eh, "template", null);
          try {
            r.documentElement.innerHTML = _0 ? ut : d;
          } catch {
          }
        }
        const h = r.body || r.documentElement;
        return t && l && h.insertBefore(u.createTextNode(l), h.childNodes[0] || null), Eh === $d ? Et.call(r, hi ? "html" : "body")[0] : hi ? r.documentElement : h;
      }, J3 = function(t) {
        return an.call(t.ownerDocument || t, t, M.SHOW_ELEMENT | M.SHOW_COMMENT | M.SHOW_TEXT, null, !1);
      }, Aee = function(t) {
        return t instanceof W && (typeof t.nodeName != "string" || typeof t.textContent != "string" || typeof t.removeChild != "function" || !(t.attributes instanceof j) || typeof t.removeAttribute != "function" || typeof t.setAttribute != "function" || typeof t.namespaceURI != "string" || typeof t.insertBefore != "function" || typeof t.hasChildNodes != "function");
      }, e4 = function(t) {
        return typeof S == "object" ? t instanceof S : t && typeof t == "object" && typeof t.nodeType == "number" && typeof t.nodeName == "string";
      }, Xg = function(t, r, l) {
        Ht[t] && hL(Ht[t], (d) => {
          d.call(n, r, l, Ob);
        });
      }, b5 = function(t) {
        let r;
        if (Xg("beforeSanitizeElements", t, null), Aee(t))
          return Es(t), !0;
        const l = vc(t.nodeName);
        if (Xg("uponSanitizeElement", t, {
          tagName: l,
          allowedTags: mr
        }), t.hasChildNodes() && !e4(t.firstElementChild) && (!e4(t.content) || !e4(t.content.firstElementChild)) && xf(/<[/\w]/g, t.innerHTML) && xf(/<[/\w]/g, t.textContent))
          return Es(t), !0;
        if (!mr[l] || bo[l]) {
          if (!bo[l] && Lz(l) && (Sn.tagNameCheck instanceof RegExp && xf(Sn.tagNameCheck, l) || Sn.tagNameCheck instanceof Function && Sn.tagNameCheck(l)))
            return !1;
          if (Ps && !si[l]) {
            const d = Ye(t) || t.parentNode, h = He(t) || t.childNodes;
            if (h && d) {
              const y = h.length;
              for (let w = y - 1; w >= 0; --w)
                d.insertBefore(fe(h[w], !0), ke(t));
            }
          }
          return Es(t), !0;
        }
        return t instanceof T && !Eo(t) || (l === "noscript" || l === "noembed" || l === "noframes") && xf(/<\/no(script|embed|frames)/i, t.innerHTML) ? (Es(t), !0) : (ar && t.nodeType === 3 && (r = t.textContent, r = tp(r, zn, " "), r = tp(r, uo, " "), r = tp(r, Go, " "), t.textContent !== r && (wS(n.removed, { element: t.cloneNode() }), t.textContent = r)), Xg("afterSanitizeElements", t, null), !1);
      }, y5 = function(t, r, l) {
        if (Ou && (r === "id" || r === "name") && (l in u || l in Bz))
          return !1;
        if (!(us && !cs[r] && xf(ys, r))) {
          if (!(On && xf(Js, r))) {
            if (!ro[r] || cs[r]) {
              if (!(Lz(t) && (Sn.tagNameCheck instanceof RegExp && xf(Sn.tagNameCheck, t) || Sn.tagNameCheck instanceof Function && Sn.tagNameCheck(t)) && (Sn.attributeNameCheck instanceof RegExp && xf(Sn.attributeNameCheck, r) || Sn.attributeNameCheck instanceof Function && Sn.attributeNameCheck(r)) || r === "is" && Sn.allowCustomizedBuiltInElements && (Sn.tagNameCheck instanceof RegExp && xf(Sn.tagNameCheck, l) || Sn.tagNameCheck instanceof Function && Sn.tagNameCheck(l)))) return !1;
            } else if (!Gl[r]) {
              if (!xf(yl, tp(l, Da, ""))) {
                if (!((r === "src" || r === "xlink:href" || r === "href") && t !== "script" && gW(l, "data:") === 0 && ja[t])) {
                  if (!(ws && !xf(xr, tp(l, Da, "")))) {
                    if (l)
                      return !1;
                  }
                }
              }
            }
          }
        }
        return !0;
      }, Lz = function(t) {
        return t.indexOf("-") > 0;
      }, $z = function(t) {
        let r, l, d, h;
        Xg("beforeSanitizeAttributes", t, null);
        const { attributes: y } = t;
        if (!y)
          return;
        const w = {
          attrName: "",
          attrValue: "",
          keepAttr: !0,
          allowedAttributes: ro
        };
        for (h = y.length; h--; ) {
          r = y[h];
          const { name: E, namespaceURI: O } = r;
          l = E === "value" ? r.value : vW(r.value);
          const F = l;
          if (d = vc(E), w.attrName = d, w.attrValue = l, w.keepAttr = !0, w.forceKeepAttr = void 0, Xg("uponSanitizeAttribute", t, w), l = w.attrValue, w.forceKeepAttr)
            continue;
          if (!w.keepAttr) {
            pa(E, t);
            continue;
          }
          if (!Vi && xf(/\/>/i, l)) {
            pa(E, t);
            continue;
          }
          ar && (l = tp(l, zn, " "), l = tp(l, uo, " "), l = tp(l, Go, " "));
          const L = vc(t.nodeName);
          if (!y5(L, d, l)) {
            pa(E, t);
            continue;
          }
          if (Ld && (d === "id" || d === "name") && (pa(E, t), l = fo + l), We && typeof ue == "object" && typeof ue.getAttributeType == "function" && !O)
            switch (ue.getAttributeType(L, d)) {
              case "TrustedHTML": {
                l = We.createHTML(l);
                break;
              }
              case "TrustedScriptURL": {
                l = We.createScriptURL(l);
                break;
              }
            }
          if (l !== F)
            try {
              O ? t.setAttributeNS(O, E, l) : t.setAttribute(E, l);
            } catch {
              pa(E, t);
            }
        }
        Xg("afterSanitizeAttributes", t, null);
      }, Oee = function Cs(t) {
        let r;
        const l = J3(t);
        for (Xg("beforeSanitizeShadowDOM", t, null); r = l.nextNode(); )
          Xg("uponSanitizeShadowNode", r, null), !b5(r) && (r.content instanceof p && Cs(r.content), $z(r));
        Xg("afterSanitizeShadowDOM", t, null);
      };
      return n.sanitize = function(Cs) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r, l, d, h;
        if (_0 = !Cs, _0 && (Cs = "<!-->"), typeof Cs != "string" && !e4(Cs))
          if (typeof Cs.toString == "function") {
            if (Cs = Cs.toString(), typeof Cs != "string")
              throw CS("dirty is not a string, aborting");
          } else
            throw CS("toString is not a function");
        if (!n.isSupported)
          return Cs;
        if (Bd || Of(t), n.removed = [], typeof Cs == "string" && (ya = !1), ya) {
          if (Cs.nodeName) {
            const E = vc(Cs.nodeName);
            if (!mr[E] || bo[E])
              throw CS("root node is forbidden and cannot be sanitized in-place");
          }
        } else if (Cs instanceof S)
          r = bm("<!---->"), l = r.ownerDocument.importNode(Cs, !0), l.nodeType === 1 && l.nodeName === "BODY" || l.nodeName === "HTML" ? r = l : r.appendChild(l);
        else {
          if (!gc && !ar && !hi && Cs.indexOf("<") === -1)
            return We && rd ? We.createHTML(Cs) : Cs;
          if (r = bm(Cs), !r)
            return gc ? null : rd ? ut : "";
        }
        r && vm && Es(r.firstChild);
        const y = J3(ya ? Cs : r);
        for (; d = y.nextNode(); )
          b5(d) || (d.content instanceof p && Oee(d.content), $z(d));
        if (ya)
          return Cs;
        if (gc) {
          if (Au)
            for (h = Nn.call(r.ownerDocument); r.firstChild; )
              h.appendChild(r.firstChild);
          else
            h = r;
          return (ro.shadowroot || ro.shadowrootmode) && (h = bt.call(s, h, !0)), h;
        }
        let w = hi ? r.outerHTML : r.innerHTML;
        return hi && mr["!doctype"] && r.ownerDocument && r.ownerDocument.doctype && r.ownerDocument.doctype.name && xf(Px, r.ownerDocument.doctype.name) && (w = "<!DOCTYPE " + r.ownerDocument.doctype.name + `>
` + w), ar && (w = tp(w, zn, " "), w = tp(w, uo, " "), w = tp(w, Go, " ")), We && rd ? We.createHTML(w) : w;
      }, n.setConfig = function(Cs) {
        Of(Cs), Bd = !0;
      }, n.clearConfig = function() {
        Ob = null, Bd = !1;
      }, n.isValidAttribute = function(Cs, t, r) {
        Ob || Of({});
        const l = vc(Cs), d = vc(t);
        return y5(l, d, r);
      }, n.addHook = function(Cs, t) {
        typeof t == "function" && (Ht[Cs] = Ht[Cs] || [], wS(Ht[Cs], t));
      }, n.removeHook = function(Cs) {
        if (Ht[Cs])
          return pW(Ht[Cs]);
      }, n.removeHooks = function(Cs) {
        Ht[Cs] && (Ht[Cs] = []);
      }, n.removeAllHooks = function() {
        Ht = {};
      }, n;
    }
    var KT = SS();
    const ki = Kt.each, Mre = Kt.trim, Ire = [
      "source",
      "protocol",
      "authority",
      "userInfo",
      "user",
      "password",
      "host",
      "port",
      "relative",
      "path",
      "directory",
      "file",
      "query",
      "anchor"
    ], Fre = {
      ftp: 21,
      http: 80,
      https: 443,
      mailto: 25
    }, Bre = [
      "img",
      "video"
    ], dm = (e, n) => Ue(e) ? !e : Ue(n) ? !Nt(Bre, n) : !0, YT = (e) => {
      try {
        return decodeURIComponent(e);
      } catch {
        return unescape(e);
      }
    }, Vg = (e, n, s) => {
      const i = YT(n).replace(/\s/g, "");
      return e.allow_script_urls ? !1 : /((java|vb)script|mhtml):/i.test(i) ? !0 : e.allow_html_data_urls ? !1 : /^data:image\//i.test(i) ? dm(e.allow_svg_data_urls, s) && /^data:image\/svg\+xml/i.test(i) : /^data:/i.test(i);
    };
    class hc {
      static parseDataUri(n) {
        let s;
        const i = decodeURIComponent(n).split(","), u = /data:([^;]+)/.exec(i[0]);
        return u && (s = u[1]), {
          type: s,
          data: i[1]
        };
      }
      static isDomSafe(n, s, i = {}) {
        if (i.allow_script_urls)
          return !0;
        {
          const u = rf.decode(n).replace(/[\s\u0000-\u001F]+/g, "");
          return !Vg(i, u, s);
        }
      }
      static getDocumentBaseUrl(n) {
        var s;
        let i;
        return n.protocol.indexOf("http") !== 0 && n.protocol !== "file:" ? i = (s = n.href) !== null && s !== void 0 ? s : "" : i = n.protocol + "//" + n.host + n.pathname, /^[^:]+:\/\/\/?[^\/]+\//.test(i) && (i = i.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(i) || (i += "/")), i;
      }
      constructor(n, s = {}) {
        this.path = "", this.directory = "", n = Mre(n), this.settings = s;
        const i = s.base_uri, u = this;
        if (/^([\w\-]+):([^\/]{2})/i.test(n) || /^\s*#/.test(n)) {
          u.source = n;
          return;
        }
        const p = n.indexOf("//") === 0;
        if (n.indexOf("/") === 0 && !p && (n = (i && i.protocol || "http") + "://mce_host" + n), !/^[\w\-]*:?\/\//.test(n)) {
          const S = i ? i.path : new hc(document.location.href).directory;
          if ((i == null ? void 0 : i.protocol) === "")
            n = "//mce_host" + u.toAbsPath(S, n);
          else {
            const T = /([^#?]*)([#?]?.*)/.exec(n);
            T && (n = (i && i.protocol || "http") + "://mce_host" + u.toAbsPath(S, T[1]) + T[2]);
          }
        }
        n = n.replace(/@@/g, "(mce_at)");
        const b = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(n);
        b && ki(Ire, (S, T) => {
          let M = b[T];
          M && (M = M.replace(/\(mce_at\)/g, "@@")), u[S] = M;
        }), i && (u.protocol || (u.protocol = i.protocol), u.userInfo || (u.userInfo = i.userInfo), !u.port && u.host === "mce_host" && (u.port = i.port), (!u.host || u.host === "mce_host") && (u.host = i.host), u.source = ""), p && (u.protocol = "");
      }
      setPath(n) {
        const s = /^(.*?)\/?(\w+)?$/.exec(n);
        s && (this.path = s[0], this.directory = s[1], this.file = s[2]), this.source = "", this.getURI();
      }
      toRelative(n) {
        if (n === "./")
          return n;
        const s = new hc(n, { base_uri: this });
        if (s.host !== "mce_host" && this.host !== s.host && s.host || this.port !== s.port || this.protocol !== s.protocol && s.protocol !== "")
          return s.getURI();
        const i = this.getURI(), u = s.getURI();
        if (i === u || i.charAt(i.length - 1) === "/" && i.substr(0, i.length - 1) === u)
          return i;
        let p = this.toRelPath(this.path, s.path);
        return s.query && (p += "?" + s.query), s.anchor && (p += "#" + s.anchor), p;
      }
      toAbsolute(n, s) {
        const i = new hc(n, { base_uri: this });
        return i.getURI(s && this.isSameOrigin(i));
      }
      isSameOrigin(n) {
        if (this.host == n.host && this.protocol == n.protocol) {
          if (this.port == n.port)
            return !0;
          const s = this.protocol ? Fre[this.protocol] : null;
          if (s && (this.port || s) == (n.port || s))
            return !0;
        }
        return !1;
      }
      toRelPath(n, s) {
        let i = 0, u = "", p, b;
        const S = n.substring(0, n.lastIndexOf("/")).split("/"), T = s.split("/");
        if (S.length >= T.length) {
          for (p = 0, b = S.length; p < b; p++)
            if (p >= T.length || S[p] !== T[p]) {
              i = p + 1;
              break;
            }
        }
        if (S.length < T.length) {
          for (p = 0, b = T.length; p < b; p++)
            if (p >= S.length || S[p] !== T[p]) {
              i = p + 1;
              break;
            }
        }
        if (i === 1)
          return s;
        for (p = 0, b = S.length - (i - 1); p < b; p++)
          u += "../";
        for (p = i - 1, b = T.length; p < b; p++)
          p !== i - 1 ? u += "/" + T[p] : u += T[p];
        return u;
      }
      toAbsPath(n, s) {
        let i = 0;
        const u = /\/$/.test(s) ? "/" : "", p = n.split("/"), b = s.split("/"), S = [];
        ki(p, (W) => {
          W && S.push(W);
        });
        const T = [];
        for (let W = b.length - 1; W >= 0; W--)
          if (!(b[W].length === 0 || b[W] === ".")) {
            if (b[W] === "..") {
              i++;
              continue;
            }
            if (i > 0) {
              i--;
              continue;
            }
            T.push(b[W]);
          }
        const M = S.length - i;
        let j;
        return M <= 0 ? j = os(T).join("/") : j = S.slice(0, M).join("/") + "/" + os(T).join("/"), j.indexOf("/") !== 0 && (j = "/" + j), u && j.lastIndexOf("/") !== j.length - 1 && (j += u), j;
      }
      getURI(n = !1) {
        let s;
        return (!this.source || n) && (s = "", n || (this.protocol ? s += this.protocol + "://" : s += "//", this.userInfo && (s += this.userInfo + "@"), this.host && (s += this.host), this.port && (s += ":" + this.port)), this.path && (s += this.path), this.query && (s += "?" + this.query), this.anchor && (s += "#" + this.anchor), this.source = s), this.source;
      }
    }
    const EW = Kt.makeMap("src,href,data,background,action,formaction,poster,xlink:href"), xN = "data-mce-type";
    let e0 = 0;
    const t0 = (e, n, s, i, u) => {
      var p, b, S, T;
      const M = n.validate, j = s.getSpecialElements();
      e.nodeType === Ql && !n.allow_conditional_comments && /^\[if/i.test((p = e.nodeValue) !== null && p !== void 0 ? p : "") && (e.nodeValue = " " + e.nodeValue);
      const W = (b = u == null ? void 0 : u.tagName) !== null && b !== void 0 ? b : e.nodeName.toLowerCase();
      if (i !== "html" && s.isValid(i)) {
        Ue(u) && (u.allowedTags[W] = !0);
        return;
      }
      if (e.nodeType !== wi || W === "body")
        return;
      const G = Me.fromDom(e), ue = oa(G, xN), we = Rr(G, "data-mce-bogus");
      if (!ue && U(we)) {
        we === "all" ? vr(G) : Uc(G);
        return;
      }
      const fe = s.getElementRule(W);
      if (M && !fe) {
        Xn(j, W) ? vr(G) : Uc(G);
        return;
      } else
        Ue(u) && (u.allowedTags[W] = !0);
      if (M && fe && !ue) {
        if (je((S = fe.attributesForced) !== null && S !== void 0 ? S : [], (ke) => {
          is(G, ke.name, ke.value === "{$uid}" ? `mce_${e0++}` : ke.value);
        }), je((T = fe.attributesDefault) !== null && T !== void 0 ? T : [], (ke) => {
          oa(G, ke.name) || is(G, ke.name, ke.value === "{$uid}" ? `mce_${e0++}` : ke.value);
        }), fe.attributesRequired && !Vn(fe.attributesRequired, (ke) => oa(G, ke))) {
          Uc(G);
          return;
        }
        if (fe.removeEmptyAttrs && ul(G)) {
          Uc(G);
          return;
        }
        fe.outputName && fe.outputName !== W && v_(G, fe.outputName);
      }
    }, Mx = (e, n, s, i, u) => {
      const p = e.tagName.toLowerCase(), { attrName: b, attrValue: S } = u;
      u.keepAttr = XT(n, s, i, p, b, S), u.keepAttr ? (u.allowedAttributes[b] = !0, wN(b, s) && (u.attrValue = b), n.allow_svg_data_urls && co(S, "data:image/svg+xml") && (u.forceKeepAttr = !0)) : QT(e, b) && (u.forceKeepAttr = !0);
    }, XT = (e, n, s, i, u, p) => s !== "html" && !Ea(i) ? !0 : !(u in EW && Vg(e, p, i)) && (!e.validate || n.isValid(i, u) || co(u, "data-") || co(u, "aria-")), QT = (e, n) => e.hasAttribute(xN) && (n === "id" || n === "class" || n === "style"), wN = (e, n) => e in n.getBoolAttrs(), SL = (e, n, s, i) => {
      const { attributes: u } = e;
      for (let p = u.length - 1; p >= 0; p--) {
        const b = u[p], S = b.name, T = b.value;
        !XT(n, s, i, e.tagName.toLowerCase(), S, T) && !QT(e, S) ? e.removeAttribute(S) : wN(S, s) && e.setAttribute(S, S);
      }
    }, TW = (e, n, s) => {
      const i = KT();
      return i.addHook("uponSanitizeElement", (u, p) => {
        t0(u, e, n, s.track(u), p);
      }), i.addHook("uponSanitizeAttribute", (u, p) => {
        Mx(u, e, n, s.current(), p);
      }), i;
    }, AW = (e, n) => {
      const i = { ...{
        IN_PLACE: !0,
        ALLOW_UNKNOWN_PROTOCOLS: !0,
        ALLOWED_TAGS: [
          "#comment",
          "#cdata-section",
          "body"
        ],
        ALLOWED_ATTR: []
      } };
      return i.PARSER_MEDIA_TYPE = n, e.allow_script_urls ? i.ALLOWED_URI_REGEXP = /.*/ : e.allow_html_data_urls && (i.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i), i;
    }, kL = (e) => {
      const n = D(e);
      if (n === "svg") {
        const s = [
          "type",
          "href",
          "role",
          "arcrole",
          "title",
          "show",
          "actuate",
          "label",
          "from",
          "to"
        ].map((u) => `xlink:${u}`), i = {
          IN_PLACE: !0,
          USE_PROFILES: {
            html: !0,
            svg: !0,
            svgFilters: !0
          },
          ALLOWED_ATTR: s
        };
        KT().sanitize(e, i);
      } else if (n === "math") {
        const s = {
          IN_PLACE: !0,
          USE_PROFILES: { mathMl: !0 }
        };
        KT().sanitize(e, s);
      } else
        throw new Error("Not a namespace element");
    }, OW = (e, n) => {
      const s = te();
      if (e.sanitize) {
        const i = TW(e, n, s);
        return {
          sanitizeHtmlElement: (p, b) => {
            i.sanitize(p, AW(e, b)), i.removed = [], s.reset();
          },
          sanitizeNamespaceElement: kL
        };
      } else
        return {
          sanitizeHtmlElement: (p, b) => {
            const S = document.createNodeIterator(p, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);
            let T;
            for (; T = S.nextNode(); ) {
              const M = s.track(T);
              t0(T, e, n, M), Tn(T) && SL(T, e, n, M);
            }
            s.reset();
          },
          sanitizeNamespaceElement: ot
        };
    }, _L = Kt.makeMap, EL = Kt.extend, TL = (e, n, s, i) => {
      const u = e.name, p = u in s && u !== "title" && u !== "textarea" && u !== "noscript", b = n.childNodes;
      for (let S = 0, T = b.length; S < T; S++) {
        const M = b[S], j = new ou(M.nodeName.toLowerCase(), M.nodeType);
        if (Tn(M)) {
          const W = M.attributes;
          for (let G = 0, ue = W.length; G < ue; G++) {
            const we = W[G];
            j.attr(we.name, we.value);
          }
          Ea(j.name) && (i(M), j.value = M.innerHTML);
        } else Gt(M) ? (j.value = M.data, p && (j.raw = !0)) : (ui(M) || El(M) || zu(M)) && (j.value = M.data);
        Ea(j.name) || TL(j, M, s, i), e.append(j);
      }
    }, DW = (e, n, s) => {
      const i = [];
      for (let u = e, p = u; u; p = u, u = u.walk()) {
        const b = u;
        je(n, (S) => S(b)), Vt(b.parent) && b !== e ? u = p : i.push(b);
      }
      for (let u = i.length - 1; u >= 0; u--) {
        const p = i[u];
        je(s, (b) => b(p));
      }
    }, AL = (e, n, s, i) => {
      const u = s.validate, p = n.getNonEmptyElements(), b = n.getWhitespaceElements(), S = EL(_L("script,style,head,html,body,title,meta,param"), n.getBlockElements()), T = J0(n), M = /[ \t\r\n]+/g, j = /^[ \t\r\n]+/, W = /[ \t\r\n]+$/, G = (Ye) => {
        let We = Ye.parent;
        for (; Ue(We); ) {
          if (We.name in b)
            return !0;
          We = We.parent;
        }
        return !1;
      }, ue = (Ye) => {
        let We = Ye;
        for (; Ue(We); ) {
          if (We.name in T)
            return CT(n, p, b, We);
          We = We.parent;
        }
        return !1;
      }, we = (Ye) => Ye.name in S || Zc(n, Ye) || Ea(Ye.name) && Ye.parent === e, fe = (Ye, We) => {
        const ut = We ? Ye.prev : Ye.next;
        return Ue(ut) || Vt(Ye.parent) ? !1 : we(Ye.parent) && (Ye.parent !== e || i.isRootContent === !0);
      };
      return [
        (Ye) => {
          var We;
          if (Ye.type === 3 && !G(Ye)) {
            let ut = (We = Ye.value) !== null && We !== void 0 ? We : "";
            ut = ut.replace(M, " "), (Nl(Ye.prev, we) || fe(Ye, !0)) && (ut = ut.replace(j, "")), ut.length === 0 ? Ye.remove() : Ye.value = ut;
          }
        },
        (Ye) => {
          var We;
          if (Ye.type === 1) {
            const ut = n.getElementRule(Ye.name);
            if (u && ut) {
              const Ut = CT(n, p, b, Ye);
              ut.paddInEmptyBlock && Ut && ue(Ye) ? wT(s, i, we, Ye) : ut.removeEmpty && Ut ? we(Ye) ? Ye.remove() : Ye.unwrap() : ut.paddEmpty && (Ut || Ej(Ye)) && wT(s, i, we, Ye);
            }
          } else if (Ye.type === 3 && !G(Ye)) {
            let ut = (We = Ye.value) !== null && We !== void 0 ? We : "";
            (Ye.next && we(Ye.next) || fe(Ye, !1)) && (ut = ut.replace(W, "")), ut.length === 0 ? Ye.remove() : Ye.value = ut;
          }
        }
      ];
    }, RW = (e, n) => {
      var s;
      const i = (s = n.forced_root_block) !== null && s !== void 0 ? s : e.forced_root_block;
      return i === !1 ? "" : i === !0 ? "p" : i;
    }, gh = (e = {}, n = Gf()) => {
      const s = $T(), i = $T(), u = {
        validate: !0,
        root_name: "body",
        sanitize: !0,
        ...e
      }, p = new DOMParser(), b = OW(u, n), S = (We, ut, Ut = "html") => {
        const an = Ut === "xhtml" ? "application/xhtml+xml" : "text/html", Nn = Xn(n.getSpecialElements(), ut.toLowerCase()), Et = Nn ? `<${ut}>${We}</${ut}>` : We, bt = Ut === "xhtml" ? `<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>${Et}</body></html>` : `<body>${Et}</body>`, Ht = p.parseFromString(bt, an).body;
        return b.sanitizeHtmlElement(Ht, an), Nn ? Ht.firstChild : Ht;
      }, T = s.addFilter, M = s.getFilters, j = s.removeFilter, W = i.addFilter, G = i.getFilters, ue = i.removeFilter, we = (We, ut) => {
        RB(n, We) && ut.push(We);
      }, fe = (We, ut) => {
        const Ut = U(ut.attr(xN)), an = ut.type === 1 && !Xn(We, ut.name) && !Zc(n, ut) && !Ea(ut.name);
        return ut.type === 3 || an && !Ut;
      }, ke = (We, ut) => {
        const Ut = EL(_L("script,style,head,html,body,title,meta,param"), n.getBlockElements()), an = /^[ \t\r\n]+/, Nn = /[ \t\r\n]+$/;
        let Et = We.firstChild, bt = null;
        const Ht = (zn) => {
          var uo, Go;
          zn && (Et = zn.firstChild, Et && Et.type === 3 && (Et.value = (uo = Et.value) === null || uo === void 0 ? void 0 : uo.replace(an, "")), Et = zn.lastChild, Et && Et.type === 3 && (Et.value = (Go = Et.value) === null || Go === void 0 ? void 0 : Go.replace(Nn, "")));
        };
        if (n.isValidChild(We.name, ut.toLowerCase())) {
          for (; Et; ) {
            const zn = Et.next;
            fe(Ut, Et) ? (bt || (bt = new ou(ut, 1), bt.attr(u.forced_root_block_attrs), We.insert(bt, Et)), bt.append(Et)) : (Ht(bt), bt = null), Et = zn;
          }
          Ht(bt);
        }
      }, Ye = {
        schema: n,
        addAttributeFilter: W,
        getAttributeFilters: G,
        removeAttributeFilter: ue,
        addNodeFilter: T,
        getNodeFilters: M,
        removeNodeFilter: j,
        parse: (We, ut = {}) => {
          var Ut;
          const an = u.validate, Nn = (Ut = ut.context) !== null && Ut !== void 0 ? Ut : u.root_name, Et = S(We, Nn, ut.format);
          Ir(n, Et);
          const bt = new ou(Nn, 11);
          TL(bt, Et, n.getSpecialElements(), b.sanitizeNamespaceElement), Et.innerHTML = "";
          const [Ht, zn] = AL(bt, n, u, ut), uo = [], Go = an ? (Da) => we(Da, uo) : ot, ys = {
            nodes: {},
            attributes: {}
          }, Js = (Da) => OR(M(), G(), Da, ys);
          if (DW(bt, [
            Ht,
            Js
          ], [
            zn,
            Go
          ]), uo.reverse(), an && uo.length > 0)
            if (ut.context) {
              const {
                pass: Da,
                fail: yl
              } = qn(uo, (mr) => mr.parent === bt);
              Qm(yl, n, bt, Js), ut.invalid = Da.length > 0;
            } else
              Qm(uo, n, bt, Js);
          const xr = RW(u, ut);
          return xr && (bt.name === "body" || ut.isRootContent) && ke(bt, xr), ut.invalid || DB(ys, ut), bt;
        }
      };
      return fL(Ye, u), iW(Ye, u, n), Ye;
    }, OL = (e) => dr(e) ? Ig({ validate: !1 }).serialize(e) : e, DL = (e, n, s) => {
      const i = OL(e), u = n(i);
      if (u.isDefaultPrevented())
        return u;
      if (dr(e))
        if (u.content !== i) {
          const p = gh({
            validate: !1,
            forced_root_block: !1,
            ...s
          }).parse(u.content, { context: e.name });
          return {
            ...u,
            content: p
          };
        } else
          return {
            ...u,
            content: e
          };
      else
        return u;
    }, CN = (e) => ({
      sanitize: By(e),
      sandbox_iframes: Ly(e),
      sandbox_iframes_exclusions: $y(e)
    }), RL = (e, n) => {
      if (n.no_events)
        return lc.value(n);
      {
        const s = LE(e, n);
        return s.isDefaultPrevented() ? lc.error(MC(e, {
          content: "",
          ...s
        }).content) : lc.value(s);
      }
    }, SN = (e, n, s) => s.no_events ? n : DL(n, (u) => MC(e, {
      ...s,
      content: u
    }), CN(e)).content, kN = (e, n) => {
      if (n.no_events)
        return lc.value(n);
      {
        const s = DL(n.content, (i) => mx(e, {
          ...n,
          content: i
        }), CN(e));
        return s.isDefaultPrevented() ? (px(e, s), lc.error(void 0)) : lc.value(s);
      }
    }, _N = (e, n, s) => {
      s.no_events || px(e, {
        ...s,
        content: n
      });
    }, JT = (e, n, s) => ({
      element: e,
      width: n,
      rows: s
    }), EN = (e, n) => ({
      element: e,
      cells: n
    }), NL = (e, n) => ({
      x: e,
      y: n
    }), TN = (e, n) => ua(e, n).bind(Ba).getOr(1), PL = (e, n, s, i, u) => {
      const p = TN(u, "rowspan"), b = TN(u, "colspan"), S = e.rows;
      for (let T = s; T < s + p; T++) {
        S[T] || (S[T] = EN(Nv(i), []));
        for (let M = n; M < n + b; M++) {
          const j = S[T].cells;
          j[M] = T === s && M === n ? u : uf(u);
        }
      }
    }, ML = (e, n, s) => {
      const i = e.rows;
      return !!(i[s] ? i[s].cells : [])[n];
    }, NW = (e, n, s) => {
      for (; ML(e, n, s); )
        n++;
      return n;
    }, IL = (e) => vt(e, (n, s) => s.cells.length > n ? s.cells.length : n, 0), FL = (e, n) => {
      const s = e.rows;
      for (let i = 0; i < s.length; i++) {
        const u = s[i].cells;
        for (let p = 0; p < u.length; p++)
          if (Bs(u[p], n))
            return X.some(NL(p, i));
      }
      return X.none();
    }, eA = (e, n, s, i, u) => {
      const p = [], b = e.rows;
      for (let S = s; S <= u; S++) {
        const T = b[S].cells, M = n < i ? T.slice(n, i + 1) : T.slice(i, n + 1);
        p.push(EN(b[S].element, M));
      }
      return p;
    }, kS = (e, n, s) => {
      const i = n.x, u = n.y, p = s.x, b = s.y, S = u < b ? eA(e, i, u, p, b) : eA(e, i, b, p, u);
      return JT(e.element, IL(S), S);
    }, BL = (e, n) => {
      const s = uf(e.element), i = Me.fromTag("tbody");
      return bd(i, n), Zr(s, i), s;
    }, LL = (e) => tn(e.rows, (n) => {
      const s = tn(n.cells, (u) => {
        const p = Nv(u);
        return Jr(p, "colspan"), Jr(p, "rowspan"), p;
      }), i = uf(n.element);
      return bd(i, s), i;
    }), tA = (e) => {
      const n = JT(uf(e), 0, []);
      return je(va(e, "tr"), (s, i) => {
        je(va(s, "td,th"), (u, p) => {
          PL(n, NW(n, p, i), i, s, u);
        });
      }), JT(n.element, IL(n.rows), n.rows);
    }, PW = (e) => BL(e, LL(e)), MW = (e, n, s) => FL(e, n).bind((i) => FL(e, s).map((u) => kS(e, i, u))), n0 = (e) => Dn(e, (n) => fs(n) === "ul" || fs(n) === "ol"), AN = (e, n) => Dn(e, (s) => fs(s) === "li" && tx(s, n)).fold(ze([]), (s) => n0(e).map((i) => {
      const u = Me.fromTag(fs(i)), p = ks(fl(i), (b, S) => co(S, "list-style"));
      return Ho(u, p), [
        Me.fromTag("li"),
        u
      ];
    }).getOr([])), $L = (e, n) => {
      const s = vt(n, (i, u) => (Zr(u, i), u), e);
      return n.length > 0 ? _o([s]) : s;
    }, _S = (e) => Dc(e) ? Ni(e).filter(df).fold(ze([]), (n) => [
      e,
      n
    ]) : df(e) ? [e] : [], HL = (e, n, s) => {
      const i = Me.fromDom(n.commonAncestorContainer), u = Fg(i, e), p = on(u, (T) => s.isWrapper(fs(T))), b = AN(u, n), S = p.concat(b.length ? b : _S(i));
      return tn(S, uf);
    }, nA = () => _o([]), zL = (e, n, s) => $L(Me.fromDom(n.cloneContents()), HL(e, n, s)), VL = (e, n) => Na(n, "table", Je(Bs, e)), IW = (e, n) => VL(e, n[0]).bind((s) => {
      const i = n[0], u = n[n.length - 1], p = tA(s);
      return MW(p, i, u).map((b) => _o([PW(b)]));
    }).getOrThunk(nA), FW = (e, n, s) => n.length > 0 && n[0].collapsed ? nA() : zL(e, n[0], s), BW = (e, n, s) => {
      const i = ah(n, e);
      return i.length > 0 ? IW(e, i) : FW(e, n, s);
    }, Ix = (e, n) => n >= 0 && n < e.length && Og(e.charAt(n)), UL = (e) => Qc(e.innerText), jL = (e) => e.map((n) => n.nodeName).getOr("div").toLowerCase(), LW = (e) => X.from(e.selection.getRng()).map((n) => {
      var s;
      const i = X.from(e.dom.getParent(n.commonAncestorContainer, e.dom.isBlock)), u = e.getBody(), p = jL(i), b = Me.fromDom(n.cloneContents());
      OF(b), DF(b);
      const S = e.dom.add(u, p, {
        "data-mce-bogus": "all",
        style: "overflow: hidden; opacity: 0;"
      }, b.dom), T = UL(S), M = Qc((s = S.textContent) !== null && s !== void 0 ? s : "");
      if (e.dom.remove(S), Ix(M, 0) || Ix(M, M.length - 1)) {
        const j = i.getOr(u), W = UL(j), G = W.indexOf(T);
        if (G === -1)
          return T;
        {
          const ue = Ix(W, G - 1), we = Ix(W, G + T.length);
          return (ue ? " " : "") + T + (we ? " " : "");
        }
      } else
        return T;
    }).getOr(""), $W = (e, n) => {
      const s = e.selection.getRng(), i = e.dom.create("body"), u = e.selection.getSel(), p = wx(e, ex(u)), b = n.contextual ? BW(Me.fromDom(e.getBody()), p, e.schema).dom : s.cloneContents();
      return b && i.appendChild(b), e.selection.serializer.serialize(i, n);
    }, HW = (e, n) => {
      if (n.format === "text")
        return LW(e);
      {
        const s = $W(e, n);
        return n.format === "tree" ? s : e.selection.isCollapsed() ? "" : s;
      }
    }, zW = (e, n) => ({
      ...e,
      format: n,
      get: !0,
      selection: !0,
      getInner: !0
    }), VW = (e, n, s = {}) => {
      const i = zW(s, n);
      return RL(e, i).fold(jt, (u) => {
        const p = HW(e, u);
        return SN(e, p, u);
      });
    }, ON = 0, WL = 1, ZL = 2, UW = (e, n) => {
      const s = e.length + n.length + 2, i = new Array(s), u = new Array(s), p = (j, W, G) => ({
        start: j,
        end: W,
        diag: G
      }), b = (j, W, G, ue, we) => {
        const fe = T(j, W, G, ue);
        if (fe === null || fe.start === W && fe.diag === W - ue || fe.end === j && fe.diag === j - G) {
          let ke = j, He = G;
          for (; ke < W || He < ue; )
            ke < W && He < ue && e[ke] === n[He] ? (we.push([
              ON,
              e[ke]
            ]), ++ke, ++He) : W - j > ue - G ? (we.push([
              ZL,
              e[ke]
            ]), ++ke) : (we.push([
              WL,
              n[He]
            ]), ++He);
        } else {
          b(j, fe.start, G, fe.start - fe.diag, we);
          for (let ke = fe.start; ke < fe.end; ++ke)
            we.push([
              ON,
              e[ke]
            ]);
          b(fe.end, W, fe.end - fe.diag, ue, we);
        }
      }, S = (j, W, G, ue) => {
        let we = j;
        for (; we - W < ue && we < G && e[we] === n[we - W]; )
          ++we;
        return p(j, we, W);
      }, T = (j, W, G, ue) => {
        const we = W - j, fe = ue - G;
        if (we === 0 || fe === 0)
          return null;
        const ke = we - fe, He = fe + we, Ye = (He % 2 === 0 ? He : He + 1) / 2;
        i[1 + Ye] = j, u[1 + Ye] = W + 1;
        let We, ut, Ut, an, Nn;
        for (We = 0; We <= Ye; ++We) {
          for (ut = -We; ut <= We; ut += 2) {
            for (Ut = ut + Ye, ut === -We || ut !== We && i[Ut - 1] < i[Ut + 1] ? i[Ut] = i[Ut + 1] : i[Ut] = i[Ut - 1] + 1, an = i[Ut], Nn = an - j + G - ut; an < W && Nn < ue && e[an] === n[Nn]; )
              i[Ut] = ++an, ++Nn;
            if (ke % 2 !== 0 && ke - We <= ut && ut <= ke + We && u[Ut - ke] <= i[Ut])
              return S(u[Ut - ke], ut + j - G, W, ue);
          }
          for (ut = ke - We; ut <= ke + We; ut += 2) {
            for (Ut = ut + Ye - ke, ut === ke - We || ut !== ke + We && u[Ut + 1] <= u[Ut - 1] ? u[Ut] = u[Ut + 1] - 1 : u[Ut] = u[Ut - 1], an = u[Ut] - 1, Nn = an - j + G - ut; an >= j && Nn >= G && e[an] === n[Nn]; )
              u[Ut] = an--, Nn--;
            if (ke % 2 === 0 && -We <= ut && ut <= We && u[Ut] <= i[Ut + ke])
              return S(u[Ut], ut + j - G, W, ue);
          }
        }
        return null;
      }, M = [];
      return b(0, e.length, 0, n.length, M), M;
    }, ES = (e) => Tn(e) ? e.outerHTML : Gt(e) ? rf.encodeRaw(e.data, !1) : ui(e) ? "<!--" + e.data + "-->" : "", Mc = (e) => {
      let n;
      const s = document.createElement("div"), i = document.createDocumentFragment();
      for (e && (s.innerHTML = e); n = s.firstChild; )
        i.appendChild(n);
      return i;
    }, jW = (e, n, s) => {
      const i = Mc(n);
      if (e.hasChildNodes() && s < e.childNodes.length) {
        const u = e.childNodes[s];
        e.insertBefore(i, u);
      } else
        e.appendChild(i);
    }, oA = (e, n) => {
      if (e.hasChildNodes() && n < e.childNodes.length) {
        const s = e.childNodes[n];
        e.removeChild(s);
      }
    }, o0 = (e, n) => {
      let s = 0;
      je(e, (i) => {
        i[0] === ON ? s++ : i[0] === WL ? (jW(n, i[1], s), s++) : i[0] === ZL && oA(n, s);
      });
    }, GL = (e, n) => on(tn(Ss(e.childNodes), B(Qc, ES)), (s) => s.length > 0), od = (e, n) => {
      const s = tn(Ss(n.childNodes), ES);
      return o0(UW(s, e), n), n;
    }, s0 = Ct(() => document.implementation.createHTMLDocument("undo")), qL = (e) => e.querySelector("iframe") !== null, WW = (e) => ({
      type: "fragmented",
      fragments: e,
      content: "",
      bookmark: null,
      beforeBookmark: null
    }), KL = (e) => ({
      type: "complete",
      fragments: null,
      content: e,
      bookmark: null,
      beforeBookmark: null
    }), sA = (e) => {
      const n = e.serializer.getTempAttrs(), s = tR(e.getBody(), n);
      return qL(s) ? WW(GL(s)) : KL(Qc(s.innerHTML));
    }, rA = (e, n, s) => {
      const i = s ? n.beforeBookmark : n.bookmark;
      n.type === "fragmented" ? od(n.fragments, e.getBody()) : e.setContent(n.content, {
        format: "raw",
        no_selection: Ue(i) && _E(i) ? !i.isFakeCaret : !0
      }), i && (e.selection.moveToBookmark(i), e.selection.scrollIntoView());
    }, r0 = (e) => e.type === "fragmented" ? e.fragments.join("") : e.content, aA = (e) => {
      const n = Me.fromTag("body", s0());
      return yd(n, r0(e)), je(va(n, "*[data-mce-bogus]"), Uc), Pr(n);
    }, ZW = (e, n) => r0(e) === r0(n), YL = (e, n) => aA(e) === aA(n), DN = (e, n) => !e || !n ? !1 : ZW(e, n) ? !0 : YL(e, n), TS = (e) => e.get() === 0, Fx = (e, n, s) => {
      TS(s) && (e.typing = n);
    }, XL = (e, n) => {
      e.typing && (Fx(e, !1, n), e.add());
    }, GW = (e) => {
      e.typing && (e.typing = !1, e.add());
    }, vh = (e, n, s) => {
      TS(n) && s.set(Pw(e.selection));
    }, RN = (e, n, s, i, u, p, b) => {
      const S = sA(e), T = Kt.extend(p || {}, S);
      if (!TS(i) || e.removed)
        return null;
      const M = n.data[s.get()];
      if (e.dispatch("BeforeAddUndo", {
        level: T,
        lastLevel: M,
        originalEvent: b
      }).isDefaultPrevented() || M && DN(M, T))
        return null;
      n.data[s.get()] && u.get().each((G) => {
        n.data[s.get()].beforeBookmark = G;
      });
      const j = WO(e);
      if (j && n.data.length > j) {
        for (let G = 0; G < n.data.length - 1; G++)
          n.data[G] = n.data[G + 1];
        n.data.length--, s.set(n.data.length);
      }
      T.bookmark = Pw(e.selection), s.get() < n.data.length - 1 && (n.data.length = s.get() + 1), n.data.push(T), s.set(n.data.length - 1);
      const W = {
        level: T,
        lastLevel: M,
        originalEvent: b
      };
      return s.get() > 0 ? (e.setDirty(!0), e.dispatch("AddUndo", W), e.dispatch("change", W)) : e.dispatch("AddUndo", W), T;
    }, qW = (e, n, s) => {
      n.data = [], s.set(0), n.typing = !1, e.dispatch("ClearUndos");
    }, iA = (e, n, s, i, u) => {
      if (n.transact(i)) {
        const p = n.data[s.get()].bookmark, b = n.data[s.get() - 1];
        rA(e, b, !0), n.transact(u) && (n.data[s.get() - 1].beforeBookmark = p);
      }
    }, NN = (e, n, s) => {
      let i;
      return n.get() < s.length - 1 && (n.set(n.get() + 1), i = s[n.get()], rA(e, i, !1), e.setDirty(!0), e.dispatch("Redo", { level: i })), i;
    }, QL = (e, n, s, i) => {
      let u;
      return n.typing && (n.add(), n.typing = !1, Fx(n, !1, s)), i.get() > 0 && (i.set(i.get() - 1), u = n.data[i.get()], rA(e, u, !0), e.setDirty(!0), e.dispatch("Undo", { level: u })), u;
    }, JL = (e) => {
      e.clear(), e.add();
    }, e6 = (e, n, s) => s.get() > 0 || n.typing && n.data[0] && !DN(sA(e), n.data[0]), KW = (e, n) => n.get() < e.data.length - 1 && !e.typing, YW = (e, n, s) => (XL(e, n), e.beforeChange(), e.ignore(s), e.add()), XW = (e, n) => {
      try {
        e.set(e.get() + 1), n();
      } finally {
        e.set(e.get() - 1);
      }
    }, QW = (e, n) => {
      const s = e.dom, i = Ue(n) ? n : e.getBody();
      je(s.select("table,a", i), (u) => {
        switch (u.nodeName) {
          case "TABLE":
            const p = Xw(e), b = s.getAttrib(u, "border");
            (!b || b === "0") && e.hasVisual ? s.addClass(u, p) : s.removeClass(u, p);
            break;
          case "A":
            if (!s.getAttrib(u, "href")) {
              const S = s.getAttrib(u, "name") || u.id, T = Qw(e);
              S && e.hasVisual ? s.addClass(u, T) : s.removeClass(u, T);
            }
            break;
        }
      }), e.dispatch("VisualAid", {
        element: n,
        hasVisual: e.hasVisual
      });
    }, t6 = (e) => ({
      init: { bindEvents: ot },
      undoManager: {
        beforeChange: (n, s) => vh(e, n, s),
        add: (n, s, i, u, p, b) => RN(e, n, s, i, u, p, b),
        undo: (n, s, i) => QL(e, n, s, i),
        redo: (n, s) => NN(e, n, s),
        clear: (n, s) => qW(e, n, s),
        reset: (n) => JL(n),
        hasUndo: (n, s) => e6(e, n, s),
        hasRedo: (n, s) => KW(n, s),
        transact: (n, s, i) => YW(n, s, i),
        ignore: (n, s) => XW(n, s),
        extra: (n, s, i, u) => iA(e, n, s, i, u)
      },
      formatter: {
        match: (n, s, i, u) => HR(e, n, s, i, u),
        matchAll: (n, s) => Vj(e, n, s),
        matchNode: (n, s, i, u) => hh(e, n, s, i, u),
        canApply: (n) => jj(e, n),
        closest: (n) => Uj(e, n),
        apply: (n, s, i) => iN(e, n, s, i),
        remove: (n, s, i, u) => sN(e, n, s, i, u),
        toggle: (n, s, i) => oi(e, n, s, i),
        formatChanged: (n, s, i, u, p) => lN(e, n, s, i, u, p)
      },
      editor: {
        getContent: (n) => jU(e, n),
        setContent: (n, s) => FR(e, n, s),
        insertContent: (n, s) => zj(e, n, s),
        addVisual: (n) => QW(e, n)
      },
      selection: { getContent: (n, s) => VW(e, n, s) },
      autocompleter: {
        addDecoration: ot,
        removeDecoration: ot
      },
      raw: { getModel: () => X.none() }
    }), n6 = (e) => {
      const n = (M) => ve(M) ? M : {}, { init: s, undoManager: i, formatter: u, editor: p, selection: b, autocompleter: S, raw: T } = e;
      return {
        init: { bindEvents: s.bindEvents },
        undoManager: {
          beforeChange: i.beforeChange,
          add: i.add,
          undo: i.undo,
          redo: i.redo,
          clear: i.clear,
          reset: i.reset,
          hasUndo: i.hasUndo,
          hasRedo: i.hasRedo,
          transact: (M, j, W) => i.transact(W),
          ignore: (M, j) => i.ignore(j),
          extra: (M, j, W, G) => i.extra(W, G)
        },
        formatter: {
          match: (M, j, W, G) => u.match(M, n(j), G),
          matchAll: u.matchAll,
          matchNode: u.matchNode,
          canApply: (M) => u.canApply(M),
          closest: (M) => u.closest(M),
          apply: (M, j, W) => u.apply(M, n(j)),
          remove: (M, j, W, G) => u.remove(M, n(j)),
          toggle: (M, j, W) => u.toggle(M, n(j)),
          formatChanged: (M, j, W, G, ue) => u.formatChanged(j, W, G, ue)
        },
        editor: {
          getContent: (M) => p.getContent(M),
          setContent: (M, j) => ({
            content: p.setContent(M, j),
            html: ""
          }),
          insertContent: (M, j) => (p.insertContent(M), ""),
          addVisual: p.addVisual
        },
        selection: { getContent: (M, j) => b.getContent(j) },
        autocompleter: {
          addDecoration: S.addDecoration,
          removeDecoration: S.removeDecoration
        },
        raw: { getModel: () => X.some(T.getRawModel()) }
      };
    }, JW = () => {
      const e = ze(null), n = ze("");
      return {
        init: { bindEvents: ot },
        undoManager: {
          beforeChange: ot,
          add: e,
          undo: e,
          redo: e,
          clear: ot,
          reset: ot,
          hasUndo: et,
          hasRedo: et,
          transact: e,
          ignore: ot,
          extra: ot
        },
        formatter: {
          match: et,
          matchAll: ze([]),
          matchNode: ze(void 0),
          canApply: et,
          closest: n,
          apply: ot,
          remove: ot,
          toggle: ot,
          formatChanged: ze({ unbind: ot })
        },
        editor: {
          getContent: n,
          setContent: ze({
            content: "",
            html: ""
          }),
          insertContent: ze(""),
          addVisual: ot
        },
        selection: { getContent: n },
        autocompleter: {
          addDecoration: ot,
          removeDecoration: ot
        },
        raw: { getModel: ze(X.none()) }
      };
    }, bh = (e) => Xn(e.plugins, "rtc"), eZ = (e) => _s(e.plugins, "rtc").bind((n) => X.from(n.setup)), o6 = (e) => {
      const n = e;
      return eZ(e).fold(() => (n.rtcInstance = t6(e), X.none()), (s) => (n.rtcInstance = JW(), X.some(() => s().then((i) => (n.rtcInstance = n6(i), i.rtc.isRemote)))));
    }, AS = (e) => e.rtcInstance ? e.rtcInstance : t6(e), _i = (e) => {
      const n = e.rtcInstance;
      if (n)
        return n;
      throw new Error("Failed to get RTC instance not yet initialized.");
    }, s6 = (e, n, s) => {
      _i(e).undoManager.beforeChange(n, s);
    }, PN = (e, n, s, i, u, p, b) => _i(e).undoManager.add(n, s, i, u, p, b), r6 = (e, n, s, i) => _i(e).undoManager.undo(n, s, i), a6 = (e, n, s) => _i(e).undoManager.redo(n, s), MN = (e, n, s) => {
      _i(e).undoManager.clear(n, s);
    }, i6 = (e, n) => {
      _i(e).undoManager.reset(n);
    }, l6 = (e, n, s) => _i(e).undoManager.hasUndo(n, s), c6 = (e, n, s) => _i(e).undoManager.hasRedo(n, s), tZ = (e, n, s, i) => _i(e).undoManager.transact(n, s, i), IN = (e, n, s) => {
      _i(e).undoManager.ignore(n, s);
    }, nZ = (e, n, s, i, u) => {
      _i(e).undoManager.extra(n, s, i, u);
    }, lA = (e, n, s, i, u) => _i(e).formatter.match(n, s, i, u), oZ = (e, n, s) => _i(e).formatter.matchAll(n, s), sZ = (e, n, s, i, u) => _i(e).formatter.matchNode(n, s, i, u), rZ = (e, n) => _i(e).formatter.canApply(n), u6 = (e, n) => _i(e).formatter.closest(n), d6 = (e, n, s, i) => {
      _i(e).formatter.apply(n, s, i);
    }, aZ = (e, n, s, i, u) => {
      _i(e).formatter.remove(n, s, i, u);
    }, iZ = (e, n, s, i) => {
      _i(e).formatter.toggle(n, s, i);
    }, lZ = (e, n, s, i, u, p) => _i(e).formatter.formatChanged(n, s, i, u, p), cZ = (e, n) => AS(e).editor.getContent(n), uZ = (e, n, s) => AS(e).editor.setContent(n, s), f6 = (e, n, s) => AS(e).editor.insertContent(n, s), Lre = (e, n, s) => _i(e).selection.getContent(n, s), dZ = (e, n) => _i(e).editor.addVisual(n), m6 = (e) => _i(e).init.bindEvents(), fZ = (e, n = {}) => {
      const s = n.format ? n.format : "html";
      return Lre(e, s, n);
    }, p6 = (e) => e.dom.length === 0 ? (vr(e), X.none()) : X.some(e), mZ = (e, n) => e.filter((s) => ch.isBookmarkNode(s.dom)).bind(n ? zc : Jl), pZ = (e, n, s, i, u) => {
      const p = e.dom, b = n.dom, S = i ? p.length : b.length;
      i ? (mR(p, b, u, !1, !i), s.setStart(b, S)) : (mR(b, p, u, !1, !i), s.setEnd(b, S));
    }, hZ = (e, n, s) => {
      Ni(e).each((i) => {
        const u = e.dom;
        n && YC(i, gt(u, 0), s) ? QC(u, 0, s) : !n && XC(i, gt(u, u.length), s) && fR(u, u.length, s);
      });
    }, FN = (e, n, s, i, u) => {
      e.bind((p) => ((i ? fR : QC)(p.dom, i ? p.dom.length : 0, u), n.filter(ft).map((S) => pZ(p, S, s, i, u)))).orThunk(() => mZ(n, i).or(n).filter(ft).map((b) => hZ(b, i, u)));
    }, gZ = (e, n, s) => {
      const i = X.from(n.firstChild).map(Me.fromDom), u = X.from(n.lastChild).map(Me.fromDom);
      e.deleteContents(), e.insertNode(n);
      const p = i.bind(Jl).filter(ft).bind(p6), b = u.bind(zc).filter(ft).bind(p6);
      FN(p, i, e, !0, s), FN(b, u, e, !1, s), e.collapse(!1);
    }, vZ = (e, n) => ({
      format: "html",
      ...e,
      set: !0,
      selection: !0,
      content: n
    }), bZ = (e, n) => {
      if (n.format !== "raw") {
        const s = e.selection.getRng(), i = e.dom.getParent(s.commonAncestorContainer, e.dom.isBlock), u = i ? { context: i.nodeName.toLowerCase() } : {}, p = e.parser.parse(n.content, {
          forced_root_block: !1,
          ...u,
          ...n
        });
        return Ig({ validate: !1 }, e.schema).serialize(p);
      } else
        return n.content;
    }, yZ = (e, n, s = {}) => {
      const i = vZ(s, n);
      kN(e, i).each((u) => {
        const p = bZ(e, u), b = e.selection.getRng();
        gZ(b, b.createContextualFragment(p), e.schema), e.selection.setRng(b), WC(e, b), _N(e, p, u);
      });
    }, h6 = (e, n, s) => {
      if (Xn(e, n)) {
        const i = on(e[n], (u) => u !== s);
        i.length === 0 ? delete e[n] : e[n] = i;
      }
    };
    var $re = (e, n) => {
      let s, i;
      const u = (S, T) => Dn(T, (M) => e.is(M, S)), p = (S) => e.getParents(S, void 0, e.getRoot()), b = () => {
        s = {}, i = {}, n.on("NodeChange", (S) => {
          const T = S.element, M = p(T), j = {};
          qt(s, (W, G) => {
            u(G, M).each((ue) => {
              i[G] || (je(W, (we) => {
                we(!0, {
                  node: ue,
                  selector: G,
                  parents: M
                });
              }), i[G] = W), j[G] = W;
            });
          }), qt(i, (W, G) => {
            j[G] || (delete i[G], je(W, (ue) => {
              ue(!1, {
                node: T,
                selector: G,
                parents: M
              });
            }));
          });
        });
      };
      return {
        selectorChangedWithUnbind: (S, T) => (s || b(), s[S] || (s[S] = []), s[S].push(T), u(S, p(n.selection.getStart())).each(() => {
          i[S] = s[S];
        }), {
          unbind: () => {
            h6(s, S, T), h6(i, S, T);
          }
        })
      };
    };
    const xZ = (e) => !!(e && e.ownerDocument) && Gi(Me.fromDom(e.ownerDocument), Me.fromDom(e)), wZ = (e) => e ? xZ(e.startContainer) && xZ(e.endContainer) : !1, g6 = (e, n, s, i) => {
      let u, p;
      const { selectorChangedWithUnbind: b } = $re(e, i), S = (mn, ro) => {
        const Hs = e.createRng();
        Ue(mn) && Ue(ro) ? (Hs.setStart(mn, ro), Hs.setEnd(mn, ro), ut(Hs), He(!1)) : (_C(e, Hs, i.getBody(), !0), ut(Hs));
      }, T = (mn) => fZ(i, mn), M = (mn, ro) => yZ(i, mn, ro), j = (mn) => QD(i.getBody(), We(), mn), W = (mn) => JD(i.getBody(), We(), mn), G = (mn, ro) => yl.getBookmark(mn, ro), ue = (mn) => yl.moveToBookmark(mn), we = (mn, ro) => (MU(e, mn, ro).each(ut), mn), fe = () => {
        const mn = We(), ro = Ye();
        return !mn || mn.item ? !1 : mn.compareEndPoints ? mn.compareEndPoints("StartToEnd", mn) === 0 : !ro || mn.collapsed;
      }, ke = () => {
        const mn = We(), ro = i.getBody().querySelectorAll('[data-mce-selected="1"]');
        return ro.length > 0 ? Qo(ro, (Hs) => e.isEditable(Hs.parentElement)) : yF(e, mn);
      }, He = (mn) => {
        const ro = We();
        ro.collapse(!!mn), ut(ro);
      }, Ye = () => n.getSelection ? n.getSelection() : n.document.selection, We = () => {
        let mn;
        const ro = (Sn, bo, cs) => {
          try {
            return bo.compareBoundaryPoints(Sn, cs);
          } catch {
            return -1;
          }
        }, Hs = n.document;
        if (Ue(i.bookmark) && !H1(i)) {
          const Sn = JE(i);
          if (Sn.isSome())
            return Sn.map((bo) => wx(i, [bo])[0]).getOr(Hs.createRange());
        }
        try {
          const Sn = Ye();
          Sn && !zf(Sn.anchorNode) && (Sn.rangeCount > 0 ? mn = Sn.getRangeAt(0) : mn = Hs.createRange(), mn = wx(i, [mn])[0]);
        } catch {
        }
        if (mn || (mn = Hs.createRange()), Pp(mn.startContainer) && mn.collapsed) {
          const Sn = e.getRoot();
          mn.setStart(Sn, 0), mn.setEnd(Sn, 0);
        }
        return u && p && (ro(mn.START_TO_START, mn, u) === 0 && ro(mn.END_TO_END, mn, u) === 0 ? mn = p : (u = null, p = null)), mn;
      }, ut = (mn, ro) => {
        if (!wZ(mn))
          return;
        const Hs = Ye();
        if (mn = i.dispatch("SetSelectionRange", {
          range: mn,
          forward: ro
        }).range, Hs) {
          p = mn;
          try {
            Hs.removeAllRanges(), Hs.addRange(mn);
          } catch {
          }
          ro === !1 && Hs.extend && (Hs.collapse(mn.endContainer, mn.endOffset), Hs.extend(mn.startContainer, mn.startOffset)), u = Hs.rangeCount > 0 ? Hs.getRangeAt(0) : null;
        }
        if (!mn.collapsed && mn.startContainer === mn.endContainer && (Hs != null && Hs.setBaseAndExtent) && mn.endOffset - mn.startOffset < 2 && mn.startContainer.hasChildNodes()) {
          const bo = mn.startContainer.childNodes[mn.startOffset];
          bo && bo.nodeName === "IMG" && (Hs.setBaseAndExtent(mn.startContainer, mn.startOffset, mn.endContainer, mn.endOffset), (Hs.anchorNode !== mn.startContainer || Hs.focusNode !== mn.endContainer) && Hs.setBaseAndExtent(bo, 0, bo, 1));
        }
        i.dispatch("AfterSetSelectionRange", {
          range: mn,
          forward: ro
        });
      }, Ut = (mn) => (M(e.getOuterHTML(mn)), mn), an = () => NU(i.getBody(), We()), Nn = (mn, ro) => PU(e, We(), mn, ro), Et = () => {
        const mn = Ye(), ro = mn == null ? void 0 : mn.anchorNode, Hs = mn == null ? void 0 : mn.focusNode;
        if (!mn || !ro || !Hs || zf(ro) || zf(Hs))
          return !0;
        const Sn = e.createRng(), bo = e.createRng();
        try {
          Sn.setStart(ro, mn.anchorOffset), Sn.collapse(!0), bo.setStart(Hs, mn.focusOffset), bo.collapse(!0);
        } catch {
          return !0;
        }
        return Sn.compareBoundaryPoints(Sn.START_TO_START, bo) <= 0;
      }, Da = {
        dom: e,
        win: n,
        serializer: s,
        editor: i,
        expand: (mn = { type: "word" }) => ut(Wt(e).expand(We(), mn)),
        collapse: He,
        setCursorLocation: S,
        getContent: T,
        setContent: M,
        getBookmark: G,
        moveToBookmark: ue,
        select: we,
        isCollapsed: fe,
        isEditable: ke,
        isForward: Et,
        setNode: Ut,
        getNode: an,
        getSel: Ye,
        setRng: ut,
        getRng: We,
        getStart: j,
        getEnd: W,
        getSelectedBlocks: Nn,
        normalize: () => {
          const mn = We(), ro = Ye();
          if (!mD(ro) && EC(i)) {
            const Hs = vn(e, mn);
            return Hs.each((Sn) => {
              ut(Sn, Et());
            }), Hs.getOr(mn);
          }
          return mn;
        },
        selectorChanged: (mn, ro) => (b(mn, ro), Da),
        selectorChangedWithUnbind: b,
        getScrollContainer: () => {
          let mn, ro = e.getRoot();
          for (; ro && ro.nodeName !== "BODY"; ) {
            if (ro.scrollHeight > ro.clientHeight) {
              mn = ro;
              break;
            }
            ro = ro.parentNode;
          }
          return mn;
        },
        scrollIntoView: (mn, ro) => {
          Ue(mn) ? xU(i, mn, ro) : WC(i, We(), ro);
        },
        placeCaretAt: (mn, ro) => ut(C(mn, ro, i.getDoc())),
        getBoundingClientRect: () => {
          const mn = We();
          return mn.collapsed ? gt.fromRangeStart(mn).getClientRects()[0] : mn.getBoundingClientRect();
        },
        destroy: () => {
          n = u = p = null, mr.destroy();
        }
      }, yl = ch(Da), mr = M1(Da, i);
      return Da.bookmarkManager = yl, Da.controlSelection = mr, Da;
    }, Hre = (e, n, s) => {
      n.addNodeFilter("br", (i, u, p) => {
        const b = Kt.extend({}, s.getBlockElements()), S = s.getNonEmptyElements(), T = s.getWhitespaceElements();
        b.body = 1;
        const M = (j) => j.name in b || Zc(s, j);
        for (let j = 0, W = i.length; j < W; j++) {
          let G = i[j], ue = G.parent;
          if (ue && M(ue) && G === ue.lastChild) {
            let we = G.prev;
            for (; we; ) {
              const fe = we.name;
              if (fe !== "span" || we.attr("data-mce-type") !== "bookmark") {
                fe === "br" && (G = null);
                break;
              }
              we = we.prev;
            }
            if (G && (G.remove(), CT(s, S, T, ue))) {
              const fe = s.getElementRule(ue.name);
              fe && (fe.removeEmpty ? ue.remove() : fe.paddEmpty && wT(e, p, M, ue));
            }
          } else {
            let we = G;
            for (; ue && ue.firstChild === we && ue.lastChild === we && (we = ue, !b[ue.name]); )
              ue = ue.parent;
            if (we === ue) {
              const fe = new ou("#text", 3);
              fe.value = Xa, G.replace(fe);
            }
          }
        }
      });
    }, CZ = (e, n, s) => {
      e.addAttributeFilter("data-mce-tabindex", (i, u) => {
        let p = i.length;
        for (; p--; ) {
          const b = i[p];
          b.attr("tabindex", b.attr("data-mce-tabindex")), b.attr(u, null);
        }
      }), e.addAttributeFilter("src,href,style", (i, u) => {
        const p = "data-mce-" + u, b = n.url_converter, S = n.url_converter_scope;
        let T = i.length;
        for (; T--; ) {
          const M = i[T];
          let j = M.attr(p);
          j !== void 0 ? (M.attr(u, j.length > 0 ? j : null), M.attr(p, null)) : (j = M.attr(u), u === "style" ? j = s.serializeStyle(s.parseStyle(j), M.name) : b && (j = b.call(S, j, u, M.name)), M.attr(u, j.length > 0 ? j : null));
        }
      }), e.addAttributeFilter("class", (i) => {
        let u = i.length;
        for (; u--; ) {
          const p = i[u];
          let b = p.attr("class");
          b && (b = b.replace(/(?:^|\s)mce-item-\w+(?!\S)/g, ""), p.attr("class", b.length > 0 ? b : null));
        }
      }), e.addAttributeFilter("data-mce-type", (i, u, p) => {
        let b = i.length;
        for (; b--; ) {
          const S = i[b];
          S.attr("data-mce-type") === "bookmark" && !p.cleanup && (X.from(S.firstChild).exists((M) => {
            var j;
            return !dg((j = M.value) !== null && j !== void 0 ? j : "");
          }) ? S.unwrap() : S.remove());
        }
      }), e.addNodeFilter("script,style", (i, u) => {
        var p;
        const b = (T) => T.replace(/(<!--\[CDATA\[|\]\]-->)/g, `
`).replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
        let S = i.length;
        for (; S--; ) {
          const T = i[S], M = T.firstChild, j = (p = M == null ? void 0 : M.value) !== null && p !== void 0 ? p : "";
          if (u === "script") {
            const W = T.attr("type");
            W && T.attr("type", W === "mce-no/type" ? null : W.replace(/^mce\-/, "")), n.element_format === "xhtml" && M && j.length > 0 && (M.value = `// <![CDATA[
` + b(j) + `
// ]]>`);
          } else
            n.element_format === "xhtml" && M && j.length > 0 && (M.value = `<!--
` + b(j) + `
-->`);
        }
      }), e.addNodeFilter("#comment", (i) => {
        let u = i.length;
        for (; u--; ) {
          const p = i[u], b = p.value;
          n.preserve_cdata && (b == null ? void 0 : b.indexOf("[CDATA[")) === 0 ? (p.name = "#cdata", p.type = 4, p.value = s.decode(b.replace(/^\[CDATA\[|\]\]$/g, ""))) : (b == null ? void 0 : b.indexOf("mce:protected ")) === 0 && (p.name = "#text", p.type = 3, p.raw = !0, p.value = unescape(b).substr(14));
        }
      }), e.addNodeFilter("xml:namespace,input", (i, u) => {
        let p = i.length;
        for (; p--; ) {
          const b = i[p];
          b.type === 7 ? b.remove() : b.type === 1 && u === "input" && !b.attr("type") && b.attr("type", "text");
        }
      }), e.addAttributeFilter("data-mce-type", (i) => {
        je(i, (u) => {
          u.attr("data-mce-type") === "format-caret" && (u.isEmpty(e.schema.getNonEmptyElements()) ? u.remove() : u.unwrap());
        });
      }), e.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-block,data-mce-type,data-mce-resize,data-mce-placeholder", (i, u) => {
        let p = i.length;
        for (; p--; )
          i[p].attr(u, null);
      }), n.remove_trailing_brs && Hre(n, e, e.schema);
    }, Ia = (e) => {
      const n = (i) => (i == null ? void 0 : i.name) === "br", s = e.lastChild;
      if (n(s)) {
        const i = s.prev;
        n(i) && (s.remove(), i.remove());
      }
    }, BN = (e, n, s) => {
      let i;
      const u = e.dom;
      let p = n.cloneNode(!0);
      const b = document.implementation;
      if (b.createHTMLDocument) {
        const S = b.createHTMLDocument("");
        Kt.each(p.nodeName === "BODY" ? p.childNodes : [p], (T) => {
          S.body.appendChild(S.importNode(T, !0));
        }), p.nodeName !== "BODY" ? p = S.body.firstChild : p = S.body, i = u.doc, u.doc = S;
      }
      return kD(e, {
        ...s,
        node: p
      }), i && (u.doc = i), p;
    }, zre = (e, n) => Ue(e) && e.hasEventListeners("PreProcess") && !n.no_events, SZ = (e, n, s) => zre(e, s) ? BN(e, n, s) : n, kZ = (e, n, s) => {
      Kt.inArray(n, s) === -1 && (e.addAttributeFilter(s, (i, u) => {
        let p = i.length;
        for (; p--; )
          i[p].attr(u, null);
      }), n.push(s));
    }, Bx = (e, n, s) => !n.no_events && e ? cx(e, {
      ...n,
      content: s
    }).content : s, Vre = (e, n, s) => {
      const i = Qc(s.getInner ? n.innerHTML : e.getOuterHTML(n));
      return s.selection || r1(Me.fromDom(n)) ? i : Kt.trim(i);
    }, Ure = (e, n, s) => {
      const i = s.selection ? {
        forced_root_block: !1,
        ...s
      } : s, u = e.parse(n, i);
      return Ia(u), u;
    }, Zl = (e, n, s) => Ig(e, n).serialize(s), v6 = (e, n, s, i, u) => {
      const p = Zl(n, s, i);
      return Bx(e, u, p);
    }, b6 = (e, n) => {
      const s = ["data-mce-selected"], i = {
        entity_encoding: "named",
        remove_trailing_brs: !0,
        pad_empty_with_br: !1,
        ...e
      }, u = n && n.dom ? n.dom : Kr.DOM, p = n && n.schema ? n.schema : Gf(i), b = gh(i, p);
      CZ(b, i, u);
      const S = (T, M = {}) => {
        const j = {
          format: "html",
          ...M
        }, W = SZ(n, T, j), G = Vre(u, W, j), ue = Ure(b, G, j);
        return j.format === "tree" ? ue : v6(n, i, p, ue, j);
      };
      return {
        schema: p,
        addNodeFilter: b.addNodeFilter,
        addAttributeFilter: b.addAttributeFilter,
        serialize: S,
        addRules: p.addValidElements,
        setRules: p.setValidElements,
        addTempAttr: Je(kZ, b, s),
        getTempAttrs: ze(s),
        getNodeFilters: b.getNodeFilters,
        getAttributeFilters: b.getAttributeFilters,
        removeNodeFilter: b.removeNodeFilter,
        removeAttributeFilter: b.removeAttributeFilter
      };
    }, LN = (e, n) => {
      const s = b6(e, n);
      return {
        schema: s.schema,
        addNodeFilter: s.addNodeFilter,
        addAttributeFilter: s.addAttributeFilter,
        serialize: s.serialize,
        addRules: s.addRules,
        setRules: s.setRules,
        addTempAttr: s.addTempAttr,
        getTempAttrs: s.getTempAttrs,
        getNodeFilters: s.getNodeFilters,
        getAttributeFilters: s.getAttributeFilters,
        removeNodeFilter: s.removeNodeFilter,
        removeAttributeFilter: s.removeAttributeFilter
      };
    }, _Z = "html", EZ = (e, n) => ({
      ...e,
      format: n,
      get: !0,
      getInner: !0
    }), cA = (e, n = {}) => {
      const s = n.format ? n.format : _Z, i = EZ(n, s);
      return RL(e, i).fold(jt, (u) => {
        const p = cZ(e, u);
        return SN(e, p, u);
      });
    }, TZ = "html", $N = (e, n) => ({
      format: TZ,
      ...e,
      set: !0,
      content: n
    }), HN = (e, n, s = {}) => {
      const i = $N(s, n);
      return kN(e, i).map((u) => {
        const p = uZ(e, u.content, u);
        return _N(e, p.html, u), p.content;
      }).getOr(n);
    }, y6 = "autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists,template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format".split(","), x6 = [], zN = "bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,template,textcolor,rtc".split(","), VN = [], uA = (e, n) => {
      const s = on(n, (i) => Xn(e, i));
      return kt(s);
    }, AZ = (e) => {
      const n = uA(e, y6), s = e.forced_root_block;
      return (s === !1 || s === "") && n.push("forced_root_block (false only)"), kt(n);
    }, OZ = (e) => uA(e, x6), w6 = (e, n) => {
      const s = Kt.makeMap(e.plugins, " "), u = on(n, (p) => Xn(s, p));
      return kt(u);
    }, wf = (e) => w6(e, zN), DZ = (e) => w6(e, VN.map((n) => n.name)), RZ = (e, n) => {
      const s = AZ(e), i = wf(n), u = i.length > 0, p = s.length > 0, b = n.theme === "mobile";
      if (u || p || b) {
        const S = `
- `, T = b ? `

Themes:${S}mobile` : "", M = u ? `

Plugins:${S}${i.join(S)}` : "", j = p ? `

Options:${S}${s.join(S)}` : "";
        console.warn("The following deprecated features are currently enabled and have been removed in TinyMCE 7.0. These features will no longer work and should be removed from the TinyMCE configuration. See https://www.tiny.cloud/docs/tinymce/7/migration-from-6x/ for more information." + T + M + j);
      }
    }, NZ = (e) => Dn(VN, (n) => n.name === e).fold(() => e, (n) => n.replacedWith ? `${e}, replaced by ${n.replacedWith}` : e), PZ = (e, n) => {
      const s = OZ(e), i = DZ(n), u = i.length > 0, p = s.length > 0;
      if (u || p) {
        const b = `
- `, S = u ? `

Plugins:${b}${i.map(NZ).join(b)}` : "", T = p ? `

Options:${b}${s.join(b)}` : "";
        console.warn("The following deprecated features are currently enabled but will be removed soon." + S + T);
      }
    }, MZ = (e, n) => {
      RZ(e, n), PZ(e, n);
    }, OS = Kr.DOM, IZ = (e) => {
      OS.setStyle(e.id, "display", e.orgDisplay);
    }, dA = (e) => X.from(e).each((n) => n.destroy()), FZ = (e) => {
      const n = e;
      n.contentAreaContainer = n.formElement = n.container = n.editorContainer = null, n.bodyElement = n.contentDocument = n.contentWindow = null, n.iframeElement = n.targetElm = null;
      const s = e.selection;
      if (s) {
        const i = s.dom;
        n.selection = s.win = s.dom = i.doc = null;
      }
    }, fA = (e) => {
      const n = e.formElement;
      n && (n._mceOldSubmit && (n.submit = n._mceOldSubmit, delete n._mceOldSubmit), OS.unbind(n, "submit reset", e.formEventDelegate));
    }, BZ = (e) => {
      if (!e.removed) {
        const { _selectionOverrides: n, editorUpload: s } = e, i = e.getBody(), u = e.getElement();
        i && e.save({ is_removing: !0 }), e.removed = !0, e.unbindAllNativeEvents(), e.hasHiddenInput && Ue(u == null ? void 0 : u.nextSibling) && OS.remove(u.nextSibling), ux(e), e.editorManager.remove(e), !e.inline && i && IZ(e), _D(e), OS.remove(e.getContainer()), dA(n), dA(s), e.destroy();
      }
    }, LZ = (e, n) => {
      const { selection: s, dom: i } = e;
      if (!e.destroyed) {
        if (!n && !e.removed) {
          e.remove();
          return;
        }
        n || (e.editorManager.off("beforeunload", e._beforeUnload), e.theme && e.theme.destroy && e.theme.destroy(), dA(s), dA(i)), fA(e), FZ(e), e.destroyed = !0;
      }
    }, Lx = (() => {
      const e = {};
      return {
        add: (u, p) => {
          e[u] = p;
        },
        get: (u) => e[u] ? e[u] : { icons: {} },
        has: (u) => Xn(e, u)
      };
    })(), $x = ac.ModelManager, C6 = (e, n) => n.dom[e], HZ = (e, n) => parseInt(da(n, e), 10), zZ = Je(C6, "clientWidth"), DS = Je(C6, "clientHeight"), S6 = Je(HZ, "margin-top"), k6 = Je(HZ, "margin-left"), VZ = (e) => e.dom.getBoundingClientRect(), _6 = (e, n, s) => {
      const i = zZ(e), u = DS(e);
      return n >= 0 && s >= 0 && n <= i && s <= u;
    }, UZ = (e, n, s, i) => {
      const u = VZ(n), p = e ? u.left + n.dom.clientLeft + k6(n) : 0, b = e ? u.top + n.dom.clientTop + S6(n) : 0, S = s - p, T = i - b;
      return {
        x: S,
        y: T
      };
    }, jZ = (e, n, s) => {
      const i = Me.fromDom(e.getBody()), u = e.inline ? i : Qd(i), p = UZ(e.inline, u, n, s);
      return _6(u, p.x, p.y);
    }, WZ = (e) => X.from(e).map(Me.fromDom), ZZ = (e) => {
      const n = e.inline ? e.getBody() : e.getContentAreaContainer();
      return WZ(n).map(Lu).getOr(!1);
    };
    var E6 = () => {
      const e = () => {
        throw new Error("Theme did not provide a NotificationManager implementation.");
      };
      return {
        open: e,
        close: e,
        getArgs: e
      };
    };
    const T6 = (e) => {
      const n = [], s = () => {
        const G = e.theme;
        return G && G.getNotificationManagerImpl ? G.getNotificationManagerImpl() : E6();
      }, i = () => X.from(n[0]), u = (G, ue) => G.type === ue.type && G.text === ue.text && !G.progressBar && !G.timeout && !ue.progressBar && !ue.timeout, p = () => {
        i().each((G) => {
          G.reposition();
        });
      }, b = (G) => {
        n.push(G);
      }, S = (G) => {
        ao(n, (ue) => ue === G).each((ue) => {
          n.splice(ue, 1);
        });
      }, T = (G, ue = !0) => e.removed || !ZZ(e) ? {} : (ue && e.dispatch("BeforeOpenNotification", { notification: G }), Dn(n, (we) => u(s().getArgs(we), G)).getOrThunk(() => {
        e.editorManager.setActive(e);
        const we = s().open(G, () => {
          S(we);
        }, () => GC(e));
        return b(we), p(), e.dispatch("OpenNotification", { notification: { ...we } }), we;
      })), M = () => {
        i().each((G) => {
          s().close(G), S(G), p();
        });
      }, j = ze(n);
      return ((G) => {
        G.on("SkinLoaded", () => {
          const ue = cc(G);
          ue && T({
            text: ue,
            type: "warning",
            timeout: 0
          }, !1), p();
        }), G.on("show ResizeEditor NodeChange", () => {
          requestAnimationFrame(p);
        }), G.on("remove", () => {
          je(n.slice(), (ue) => {
            s().close(ue);
          });
        }), G.addShortcut("alt+F12", "Focus to notification", () => i().map((ue) => Me.fromDom(ue.getEl())).each((ue) => yx(ue)));
      })(e), {
        open: T,
        close: M,
        getNotifications: j
      };
    }, Hx = ac.PluginManager, np = ac.ThemeManager;
    var A6 = () => {
      const e = () => {
        throw new Error("Theme did not provide a WindowManager implementation.");
      };
      return {
        open: e,
        openUrl: e,
        alert: e,
        confirm: e,
        close: e
      };
    };
    const UN = (e) => {
      let n = [];
      const s = () => {
        const fe = e.theme;
        return fe && fe.getWindowManagerImpl ? fe.getWindowManagerImpl() : A6();
      }, i = (fe, ke) => (...He) => ke ? ke.apply(fe, He) : void 0, u = (fe) => {
        e.dispatch("OpenWindow", { dialog: fe });
      }, p = (fe) => {
        e.dispatch("CloseWindow", { dialog: fe });
      }, b = (fe) => {
        n.push(fe), u(fe);
      }, S = (fe) => {
        p(fe), n = on(n, (ke) => ke !== fe), n.length === 0 && e.focus();
      }, T = () => X.from(n[n.length - 1]), M = (fe) => {
        e.editorManager.setActive(e), ZC(e), e.ui.show();
        const ke = fe();
        return b(ke), ke;
      }, j = (fe, ke) => M(() => s().open(fe, ke, S)), W = (fe) => M(() => s().openUrl(fe, S)), G = (fe, ke, He) => {
        const Ye = s();
        Ye.alert(fe, i(He || Ye, ke));
      }, ue = (fe, ke, He) => {
        const Ye = s();
        Ye.confirm(fe, i(He || Ye, ke));
      }, we = () => {
        T().each((fe) => {
          s().close(fe), S(fe);
        });
      };
      return e.on("remove", () => {
        je(n, (fe) => {
          s().close(fe);
        });
      }), {
        open: j,
        openUrl: W,
        alert: G,
        confirm: ue,
        close: we
      };
    }, O6 = (e, n) => {
      e.notificationManager.open({
        type: "error",
        text: n
      });
    }, mA = (e, n) => {
      e._skinLoaded ? O6(e, n) : e.on("SkinLoaded", () => {
        O6(e, n);
      });
    }, GZ = (e, n) => {
      mA(e, Fi.translate([
        "Failed to upload image: {0}",
        n
      ]));
    }, zx = (e, n, s) => {
      hl(e, n, { message: s }), console.error(s);
    }, RS = (e, n, s) => s ? `Failed to load ${e}: ${s} from url ${n}` : `Failed to load ${e} url: ${n}`, qZ = (e, n, s) => {
      zx(e, "PluginLoadError", RS("plugin", n, s));
    }, KZ = (e, n, s) => {
      zx(e, "IconsLoadError", RS("icons", n, s));
    }, YZ = (e, n, s) => {
      zx(e, "LanguageLoadError", RS("language", n, s));
    }, jre = (e, n, s) => {
      zx(e, "ThemeLoadError", RS("theme", n, s));
    }, op = (e, n, s) => {
      zx(e, "ModelLoadError", RS("model", n, s));
    }, jN = (e, n, s) => {
      const i = Fi.translate([
        "Failed to initialize plugin: {0}",
        n
      ]);
      hl(e, "PluginLoadError", { message: i }), pA(i, s), mA(e, i);
    }, pA = (e, ...n) => {
      const s = window.console;
      s && (s.error ? s.error(e, ...n) : s.log(e, ...n));
    }, XZ = (e) => /^[a-z0-9\-]+$/i.test(e), WN = (e) => "content/" + e + "/content.css", QZ = (e) => tinymce.Resource.has(WN(e)), fr = (e) => Vx(e, bg(e)), JZ = (e) => Vx(e, Rc(e)), Vx = (e, n) => {
      const s = e.editorManager.baseURL + "/skins/content", u = `content${e.editorManager.suffix}.css`;
      return tn(n, (p) => QZ(p) ? p : XZ(p) && !e.inline ? `${s}/${p}/${u}` : e.documentBaseURI.toAbsolute(p));
    }, eG = (e) => {
      e.contentCSS = e.contentCSS.concat(fr(e), JZ(e));
    }, tG = (e) => e ? Ss(e.getElementsByTagName("img")) : [], nG = (e, n) => {
      const s = {};
      return { findAll: (u, p = xt) => {
        const b = on(tG(u), (T) => {
          const M = T.src;
          return T.hasAttribute("data-mce-bogus") || T.hasAttribute("data-mce-placeholder") || !M || M === sn.transparentSrc ? !1 : co(M, "blob:") ? !e.isUploaded(M) && p(T) : co(M, "data:") ? p(T) : !1;
        }), S = tn(b, (T) => {
          const M = T.src;
          if (Xn(s, M))
            return s[M].then((j) => U(j) ? j : {
              image: T,
              blobInfo: j.blobInfo
            });
          {
            const j = VT(n, M).then((W) => (delete s[M], {
              image: T,
              blobInfo: W
            })).catch((W) => (delete s[M], W));
            return s[M] = j, j;
          }
        });
        return Promise.all(S);
      } };
    }, ZN = () => {
      let s = {};
      const i = (G, ue) => ({
        status: G,
        resultUri: ue
      }), u = (G) => G in s;
      return {
        hasBlobUri: u,
        getResultUri: (G) => {
          const ue = s[G];
          return ue ? ue.resultUri : null;
        },
        isPending: (G) => u(G) ? s[G].status === 1 : !1,
        isUploaded: (G) => u(G) ? s[G].status === 2 : !1,
        markPending: (G) => {
          s[G] = i(1, null);
        },
        markUploaded: (G, ue) => {
          s[G] = i(2, ue);
        },
        removeFailed: (G) => {
          delete s[G];
        },
        destroy: () => {
          s = {};
        }
      };
    };
    let bb = 0;
    const _u = () => {
      const e = () => Math.round(Math.random() * 4294967295).toString(36);
      return "s" + (/* @__PURE__ */ new Date()).getTime().toString(36) + e() + e() + e();
    }, NS = (e) => e + bb++ + _u(), yb = () => {
      let e = [];
      const n = (W) => ({
        "image/jpeg": "jpg",
        "image/jpg": "jpg",
        "image/gif": "gif",
        "image/png": "png",
        "image/apng": "apng",
        "image/avif": "avif",
        "image/svg+xml": "svg",
        "image/webp": "webp",
        "image/bmp": "bmp",
        "image/tiff": "tiff"
      })[W.toLowerCase()] || "dat", s = (W, G, ue, we, fe) => {
        if (U(W))
          return i({
            id: W,
            name: we,
            filename: fe,
            blob: G,
            base64: ue
          });
        if (ve(W))
          return i(W);
        throw new Error("Unknown input type");
      }, i = (W) => {
        if (!W.blob || !W.base64)
          throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
        const G = W.id || NS("blobid"), ue = W.name || G, we = W.blob;
        return {
          id: ze(G),
          name: ze(ue),
          filename: ze(W.filename || ue + "." + n(we.type)),
          blob: ze(we),
          base64: ze(W.base64),
          blobUri: ze(W.blobUri || URL.createObjectURL(we)),
          uri: ze(W.uri)
        };
      }, u = (W) => {
        b(W.id()) || e.push(W);
      }, p = (W) => Dn(e, W).getOrUndefined(), b = (W) => p((G) => G.id() === W);
      return {
        create: s,
        add: u,
        get: b,
        getByUri: (W) => p((G) => G.blobUri() === W),
        getByData: (W, G) => p((ue) => ue.base64() === W && ue.blob().type === G),
        findFirst: p,
        removeByUri: (W) => {
          e = on(e, (G) => G.blobUri() === W ? (URL.revokeObjectURL(G.blobUri()), !1) : !0);
        },
        destroy: () => {
          je(e, (W) => {
            URL.revokeObjectURL(W.blobUri());
          }), e = [];
        }
      };
    }, yh = (e, n) => {
      const s = {}, i = (fe, ke) => fe ? fe.replace(/\/$/, "") + "/" + ke.replace(/^\//, "") : ke, u = (fe, ke) => new Promise((He, Ye) => {
        const We = new XMLHttpRequest();
        We.open("POST", n.url), We.withCredentials = n.credentials, We.upload.onprogress = (Ut) => {
          ke(Ut.loaded / Ut.total * 100);
        }, We.onerror = () => {
          Ye("Image upload failed due to a XHR Transport error. Code: " + We.status);
        }, We.onload = () => {
          if (We.status < 200 || We.status >= 300) {
            Ye("HTTP Error: " + We.status);
            return;
          }
          const Ut = JSON.parse(We.responseText);
          if (!Ut || !U(Ut.location)) {
            Ye("Invalid JSON: " + We.responseText);
            return;
          }
          He(i(n.basePath, Ut.location));
        };
        const ut = new FormData();
        ut.append("file", fe.blob(), fe.filename()), We.send(ut);
      }), p = Ce(n.handler) ? n.handler : u, b = () => new Promise((fe) => {
        fe([]);
      }), S = (fe, ke) => ({
        url: ke,
        blobInfo: fe,
        status: !0
      }), T = (fe, ke) => ({
        url: "",
        blobInfo: fe,
        status: !1,
        error: ke
      }), M = (fe, ke) => {
        Kt.each(s[fe], (He) => {
          He(ke);
        }), delete s[fe];
      }, j = (fe, ke, He) => (e.markPending(fe.blobUri()), new Promise((Ye) => {
        let We, ut;
        try {
          const Ut = () => {
            We && (We.close(), ut = ot);
          }, an = (Et) => {
            Ut(), e.markUploaded(fe.blobUri(), Et), M(fe.blobUri(), S(fe, Et)), Ye(S(fe, Et));
          }, Nn = (Et) => {
            Ut(), e.removeFailed(fe.blobUri()), M(fe.blobUri(), T(fe, Et)), Ye(T(fe, Et));
          };
          ut = (Et) => {
            Et < 0 || Et > 100 || X.from(We).orThunk(() => X.from(He).map(Rt)).each((bt) => {
              We = bt, bt.progressBar.value(Et);
            });
          }, ke(fe, ut).then(an, (Et) => {
            Nn(U(Et) ? { message: Et } : Et);
          });
        } catch (Ut) {
          Ye(T(fe, Ut));
        }
      })), W = (fe) => fe === u, G = (fe) => {
        const ke = fe.blobUri();
        return new Promise((He) => {
          s[ke] = s[ke] || [], s[ke].push(He);
        });
      }, ue = (fe, ke) => (fe = Kt.grep(fe, (He) => !e.isUploaded(He.blobUri())), Promise.all(Kt.map(fe, (He) => e.isPending(He.blobUri()) ? G(He) : j(He, p, ke))));
      return { upload: (fe, ke) => !n.url && W(p) ? b() : ue(fe, ke) };
    }, Ux = (e) => () => e.notificationManager.open({
      text: e.translate("Image uploading..."),
      type: "info",
      timeout: -1,
      progressBar: !0
    }), hA = (e, n) => yh(n, {
      url: Uw(e),
      basePath: Ey(e),
      credentials: jw(e),
      handler: W_(e)
    }), GN = (e) => {
      const n = ZN(), s = hA(e, n);
      return { upload: (i, u = !0) => s.upload(i, u ? Ux(e) : void 0) };
    }, D6 = (e, n) => e.dom.isEmpty(n.dom) && Ue(e.schema.getTextBlockElements()[fs(n)]), R6 = (e) => (n) => {
      D6(e, n) && Zr(n, Me.fromHtml('<br data-mce-bogus="1" />'));
    }, oG = (e) => {
      const n = yb();
      let s, i;
      const u = ZN(), p = [], b = (We) => (ut) => e.selection ? We(ut) : [], S = (We) => We + (We.indexOf("?") === -1 ? "?" : "&") + (/* @__PURE__ */ new Date()).getTime(), T = (We, ut, Ut) => {
        let an = 0;
        do
          an = We.indexOf(ut, an), an !== -1 && (We = We.substring(0, an) + Ut + We.substr(an + ut.length), an += Ut.length - ut.length + 1);
        while (an !== -1);
        return We;
      }, M = (We, ut, Ut) => {
        const an = `src="${Ut}"${Ut === sn.transparentSrc ? ' data-mce-placeholder="1"' : ""}`;
        return We = T(We, `src="${ut}"`, an), We = T(We, 'data-mce-src="' + ut + '"', 'data-mce-src="' + Ut + '"'), We;
      }, j = (We, ut) => {
        je(e.undoManager.data, (Ut) => {
          Ut.type === "fragmented" ? Ut.fragments = tn(Ut.fragments, (an) => M(an, We, ut)) : Ut.content = M(Ut.content, We, ut);
        });
      }, W = (We, ut) => {
        const Ut = e.convertURL(ut, "src");
        j(We.src, ut), _a(Me.fromDom(We), {
          src: mi(e) ? S(ut) : ut,
          "data-mce-src": Ut
        });
      }, G = () => (s || (s = hA(e, u)), ke().then(b((We) => {
        const ut = tn(We, (Ut) => Ut.blobInfo);
        return s.upload(ut, Ux(e)).then(b((Ut) => {
          const an = [];
          let Nn = !1;
          const Et = tn(Ut, (bt, Ht) => {
            const { blobInfo: zn, image: uo } = We[Ht];
            let Go = !1;
            return bt.status && br(e) ? (bt.url && !Qn(uo.src, bt.url) && (Nn = !0), n.removeByUri(uo.src), bh(e) || W(uo, bt.url)) : bt.error && (bt.error.remove && (j(uo.src, sn.transparentSrc), an.push(uo), Go = !0), GZ(e, bt.error.message)), {
              element: uo,
              status: bt.status,
              uploadUri: bt.url,
              blobInfo: zn,
              removed: Go
            };
          });
          return an.length > 0 && !bh(e) ? e.undoManager.transact(() => {
            je($u(an), (bt) => {
              const Ht = Ni(bt);
              vr(bt), Ht.each(R6(e)), n.removeByUri(bt.dom.src);
            });
          }) : Nn && e.undoManager.dispatchChange(), Et;
        }));
      }))), ue = () => ei(e) ? G() : Promise.resolve([]), we = (We) => Qo(p, (ut) => ut(We)), fe = (We) => {
        p.push(We);
      }, ke = () => (i || (i = nG(u, n)), i.findAll(e.getBody(), we).then(b((We) => {
        const ut = on(We, (Ut) => U(Ut) ? (mA(e, Ut), !1) : Ut.uriType !== "blob");
        return bh(e) || je(ut, (Ut) => {
          j(Ut.image.src, Ut.blobInfo.blobUri()), Ut.image.src = Ut.blobInfo.blobUri(), Ut.image.removeAttribute("data-mce-src");
        }), ut;
      }))), He = () => {
        n.destroy(), u.destroy(), i = s = null;
      }, Ye = (We) => We.replace(/src="(blob:[^"]+)"/g, (ut, Ut) => {
        const an = u.getResultUri(Ut);
        if (an)
          return 'src="' + an + '"';
        let Nn = n.getByUri(Ut);
        return Nn || (Nn = vt(e.editorManager.get(), (Et, bt) => Et || bt.editorUpload && bt.editorUpload.blobCache.getByUri(Ut), void 0)), Nn ? 'src="data:' + Nn.blob().type + ";base64," + Nn.base64() + '"' : ut;
      });
      return e.on("SetContent", () => {
        ei(e) ? ue() : ke();
      }), e.on("RawSaveContent", (We) => {
        We.content = Ye(We.content);
      }), e.on("GetContent", (We) => {
        We.source_view || We.format === "raw" || We.format === "tree" || (We.content = Ye(We.content));
      }), e.on("PostRender", () => {
        e.parser.addNodeFilter("img", (We) => {
          je(We, (ut) => {
            const Ut = ut.attr("src");
            if (!Ut || n.getByUri(Ut))
              return;
            const an = u.getResultUri(Ut);
            an && ut.attr("src", an);
          });
        });
      }), {
        blobCache: n,
        addFilter: fe,
        uploadImages: G,
        uploadImagesAuto: ue,
        scanForImages: ke,
        destroy: He
      };
    }, sG = (e) => {
      const n = e.dom, s = e.schema.type, i = {
        valigntop: [{
          selector: "td,th",
          styles: { verticalAlign: "top" }
        }],
        valignmiddle: [{
          selector: "td,th",
          styles: { verticalAlign: "middle" }
        }],
        valignbottom: [{
          selector: "td,th",
          styles: { verticalAlign: "bottom" }
        }],
        alignleft: [
          {
            selector: "figure.image",
            collapsed: !1,
            classes: "align-left",
            ceFalseOverride: !0,
            preview: "font-family font-size"
          },
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "left" },
            inherit: !1,
            preview: !1
          },
          {
            selector: "img,audio,video",
            collapsed: !1,
            styles: { float: "left" },
            preview: "font-family font-size"
          },
          {
            selector: "table",
            collapsed: !1,
            styles: {
              marginLeft: "0px",
              marginRight: "auto"
            },
            onformat: (u) => {
              n.setStyle(u, "float", null);
            },
            preview: "font-family font-size"
          },
          {
            selector: ".mce-preview-object,[data-ephox-embed-iri]",
            ceFalseOverride: !0,
            styles: { float: "left" }
          }
        ],
        aligncenter: [
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "center" },
            inherit: !1,
            preview: "font-family font-size"
          },
          {
            selector: "figure.image",
            collapsed: !1,
            classes: "align-center",
            ceFalseOverride: !0,
            preview: "font-family font-size"
          },
          {
            selector: "img,audio,video",
            collapsed: !1,
            styles: {
              display: "block",
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: !1
          },
          {
            selector: "table",
            collapsed: !1,
            styles: {
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: "font-family font-size"
          },
          {
            selector: ".mce-preview-object",
            ceFalseOverride: !0,
            styles: {
              display: "table",
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: !1
          },
          {
            selector: "[data-ephox-embed-iri]",
            ceFalseOverride: !0,
            styles: {
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: !1
          }
        ],
        alignright: [
          {
            selector: "figure.image",
            collapsed: !1,
            classes: "align-right",
            ceFalseOverride: !0,
            preview: "font-family font-size"
          },
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "right" },
            inherit: !1,
            preview: "font-family font-size"
          },
          {
            selector: "img,audio,video",
            collapsed: !1,
            styles: { float: "right" },
            preview: "font-family font-size"
          },
          {
            selector: "table",
            collapsed: !1,
            styles: {
              marginRight: "0px",
              marginLeft: "auto"
            },
            onformat: (u) => {
              n.setStyle(u, "float", null);
            },
            preview: "font-family font-size"
          },
          {
            selector: ".mce-preview-object,[data-ephox-embed-iri]",
            ceFalseOverride: !0,
            styles: { float: "right" },
            preview: !1
          }
        ],
        alignjustify: [{
          selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
          styles: { textAlign: "justify" },
          inherit: !1,
          preview: "font-family font-size"
        }],
        bold: [
          {
            inline: "strong",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          },
          {
            inline: "span",
            styles: { fontWeight: "bold" }
          },
          {
            inline: "b",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        italic: [
          {
            inline: "em",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          },
          {
            inline: "span",
            styles: { fontStyle: "italic" }
          },
          {
            inline: "i",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        underline: [
          {
            inline: "span",
            styles: { textDecoration: "underline" },
            exact: !0
          },
          {
            inline: "u",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        strikethrough: /* @__PURE__ */ (() => {
          const u = {
            inline: "span",
            styles: { textDecoration: "line-through" },
            exact: !0
          }, p = {
            inline: "strike",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }, b = {
            inline: "s",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          };
          return s !== "html4" ? [
            b,
            u,
            p
          ] : [
            u,
            b,
            p
          ];
        })(),
        forecolor: {
          inline: "span",
          styles: { color: "%value" },
          links: !0,
          remove_similar: !0,
          clear_child_styles: !0
        },
        hilitecolor: {
          inline: "span",
          styles: { backgroundColor: "%value" },
          links: !0,
          remove_similar: !0,
          clear_child_styles: !0
        },
        fontname: {
          inline: "span",
          toggle: !1,
          styles: { fontFamily: "%value" },
          clear_child_styles: !0
        },
        fontsize: {
          inline: "span",
          toggle: !1,
          styles: { fontSize: "%value" },
          clear_child_styles: !0
        },
        lineheight: {
          selector: "h1,h2,h3,h4,h5,h6,p,li,td,th,div",
          styles: { lineHeight: "%value" }
        },
        fontsize_class: {
          inline: "span",
          attributes: { class: "%value" }
        },
        blockquote: {
          block: "blockquote",
          wrapper: !0,
          remove: "all"
        },
        subscript: { inline: "sub" },
        superscript: { inline: "sup" },
        code: { inline: "code" },
        link: {
          inline: "a",
          selector: "a",
          remove: "all",
          split: !0,
          deep: !0,
          onmatch: (u, p, b) => Tn(u) && u.hasAttribute("href"),
          onformat: (u, p, b) => {
            Kt.each(b, (S, T) => {
              n.setAttrib(u, T, S);
            });
          }
        },
        lang: {
          inline: "span",
          clear_child_styles: !0,
          remove_similar: !0,
          attributes: {
            lang: "%value",
            "data-mce-lang": (u) => {
              var p;
              return (p = u == null ? void 0 : u.customValue) !== null && p !== void 0 ? p : null;
            }
          }
        },
        removeformat: [
          {
            selector: "b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small",
            remove: "all",
            split: !0,
            expand: !1,
            block_expand: !0,
            deep: !0
          },
          {
            selector: "span",
            attributes: [
              "style",
              "class"
            ],
            remove: "empty",
            split: !0,
            expand: !1,
            deep: !0
          },
          {
            selector: "*",
            attributes: [
              "style",
              "class"
            ],
            split: !1,
            expand: !1,
            deep: !0
          }
        ]
      };
      return Kt.each("p h1 h2 h3 h4 h5 h6 div address pre dt dd samp".split(/\s/), (u) => {
        i[u] = {
          block: u,
          remove: "all"
        };
      }), i;
    }, qN = {
      remove_similar: !0,
      inherit: !1
    }, a0 = {
      selector: "td,th",
      ...qN
    }, N6 = {
      tablecellbackgroundcolor: {
        styles: { backgroundColor: "%value" },
        ...a0
      },
      tablecellverticalalign: {
        styles: { "vertical-align": "%value" },
        ...a0
      },
      tablecellbordercolor: {
        styles: { borderColor: "%value" },
        ...a0
      },
      tablecellclass: {
        classes: ["%value"],
        ...a0
      },
      tableclass: {
        selector: "table",
        classes: ["%value"],
        ...qN
      },
      tablecellborderstyle: {
        styles: { borderStyle: "%value" },
        ...a0
      },
      tablecellborderwidth: {
        styles: { borderWidth: "%value" },
        ...a0
      }
    }, P6 = ze(N6), KN = (e) => {
      const n = {}, s = (b) => Ue(b) ? n[b] : n, i = (b) => Xn(n, b), u = (b, S) => {
        b && (U(b) ? (rt(S) || (S = [S]), je(S, (T) => {
          wt(T.deep) && (T.deep = !Ku(T)), wt(T.split) && (T.split = !Ku(T) || Li(T)), wt(T.remove) && Ku(T) && !Li(T) && (T.remove = "none"), Ku(T) && Li(T) && (T.mixed = !0, T.block_expand = !0), U(T.classes) && (T.classes = T.classes.split(/\s+/));
        }), n[b] = S) : qt(b, (T, M) => {
          u(M, T);
        }));
      }, p = (b) => (b && n[b] && delete n[b], n);
      return u(sG(e)), u(P6()), u(Gw(e)), {
        get: s,
        has: i,
        register: u,
        unregister: p
      };
    }, YN = Kt.each, Cf = Kr.DOM, M6 = (e) => Ue(e) && ve(e), I6 = (e, n) => {
      const s = n && n.schema || Gf({}), i = (T, M) => {
        M.classes.length > 0 && Cf.addClass(T, M.classes.join(" ")), Cf.setAttribs(T, M.attrs);
      }, u = (T) => {
        const M = U(T) ? {
          name: T,
          classes: [],
          attrs: {}
        } : T, j = Cf.create(M.name);
        return i(j, M), j;
      }, p = (T, M) => {
        const j = s.getElementRule(T.nodeName.toLowerCase()), W = j == null ? void 0 : j.parentsRequired;
        return W && W.length ? M && Nt(W, M) ? M : W[0] : !1;
      }, b = (T, M, j) => {
        let W;
        const G = M[0], ue = M6(G) ? G.name : void 0, we = p(T, ue);
        if (we)
          ue === we ? (W = G, M = M.slice(1)) : W = we;
        else if (G)
          W = G, M = M.slice(1);
        else if (!j)
          return T;
        const fe = W ? u(W) : Cf.create("div");
        fe.appendChild(T), j && Kt.each(j, (He) => {
          const Ye = u(He);
          fe.insertBefore(Ye, T);
        });
        const ke = M6(W) ? W.siblings : void 0;
        return b(fe, M, ke);
      }, S = Cf.create("div");
      if (e.length > 0) {
        const T = e[0], M = u(T), j = M6(T) ? T.siblings : void 0;
        S.appendChild(b(M, e.slice(1), j));
      }
      return S;
    }, rG = (e) => {
      e = Kt.trim(e);
      let n = "div";
      const s = {
        name: n,
        classes: [],
        attrs: {},
        selector: e
      };
      return e !== "*" && (n = e.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, (i, u, p, b, S) => {
        switch (u) {
          case "#":
            s.attrs.id = p;
            break;
          case ".":
            s.classes.push(p);
            break;
          case ":":
            Kt.inArray("checked disabled enabled read-only required".split(" "), p) !== -1 && (s.attrs[p] = p);
            break;
        }
        if (b === "[") {
          const T = S.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
          T && (s.attrs[T[1]] = T[2]);
        }
        return "";
      })), s.name = n || "div", s;
    }, xh = (e) => U(e) ? (e = e.split(/\s*,\s*/)[0], e = e.replace(/\s*(~\+|~|\+|>)\s*/g, "$1"), Kt.map(e.split(/(?:>|\s+(?![^\[\]]+\]))/), (n) => {
      const s = Kt.map(n.split(/(?:~\+|~|\+)/), rG), i = s.pop();
      return s.length && (i.siblings = s), i;
    }).reverse()) : [], Wre = (e, n) => {
      let s = "", i = qw(e);
      if (i === "")
        return "";
      const u = (G) => U(G) ? G.replace(/%(\w+)/g, "") : "", p = (G, ue) => Cf.getStyle(ue ?? e.getBody(), G, !0);
      if (U(n)) {
        const G = e.formatter.get(n);
        if (!G)
          return "";
        n = G[0];
      }
      if ("preview" in n) {
        const G = n.preview;
        if (G === !1)
          return "";
        i = G || i;
      }
      let b = n.block || n.inline || "span", S;
      const T = xh(n.selector);
      T.length > 0 ? (T[0].name || (T[0].name = b), b = n.selector, S = I6(T, e)) : S = I6([b], e);
      const M = Cf.select(b, S)[0] || S.firstChild;
      YN(n.styles, (G, ue) => {
        const we = u(G);
        we && Cf.setStyle(M, ue, we);
      }), YN(n.attributes, (G, ue) => {
        const we = u(G);
        we && Cf.setAttrib(M, ue, we);
      }), YN(n.classes, (G) => {
        const ue = u(G);
        Cf.hasClass(M, ue) || Cf.addClass(M, ue);
      }), e.dispatch("PreviewFormats"), Cf.setStyles(S, {
        position: "absolute",
        left: -65535
      }), e.getBody().appendChild(S);
      const j = p("fontSize"), W = /px$/.test(j) ? parseInt(j, 10) : 0;
      return YN(i.split(" "), (G) => {
        let ue = p(G, M);
        if (!(G === "background-color" && /transparent|rgba\s*\([^)]+,\s*0\)/.test(ue) && (ue = p(G), lf(ue).toLowerCase() === "#ffffff")) && !(G === "color" && lf(ue).toLowerCase() === "#000000")) {
          if (G === "font-size" && /em|%$/.test(ue)) {
            if (W === 0)
              return;
            ue = parseFloat(ue) / (/%$/.test(ue) ? 100 : 1) * W + "px";
          }
          G === "border" && ue && (s += "padding:0 2px;"), s += G + ":" + ue + ";";
        }
      }), e.dispatch("AfterPreviewFormats"), Cf.remove(S), s;
    }, Zre = (e) => {
      e.addShortcut("meta+b", "", "Bold"), e.addShortcut("meta+i", "", "Italic"), e.addShortcut("meta+u", "", "Underline");
      for (let n = 1; n <= 6; n++)
        e.addShortcut("access+" + n, "", [
          "FormatBlock",
          !1,
          "h" + n
        ]);
      e.addShortcut("access+7", "", [
        "FormatBlock",
        !1,
        "p"
      ]), e.addShortcut("access+8", "", [
        "FormatBlock",
        !1,
        "div"
      ]), e.addShortcut("access+9", "", [
        "FormatBlock",
        !1,
        "address"
      ]);
    }, F6 = (e) => {
      const n = KN(e), s = Xe({});
      return Zre(e), VB(e), bh(e) || sL(s, e), {
        get: n.get,
        has: n.has,
        register: n.register,
        unregister: n.unregister,
        apply: (i, u, p) => {
          d6(e, i, u, p);
        },
        remove: (i, u, p, b) => {
          aZ(e, i, u, p, b);
        },
        toggle: (i, u, p) => {
          iZ(e, i, u, p);
        },
        match: (i, u, p, b) => lA(e, i, u, p, b),
        closest: (i) => u6(e, i),
        matchAll: (i, u) => oZ(e, i, u),
        matchNode: (i, u, p, b) => sZ(e, i, u, p, b),
        canApply: (i) => rZ(e, i),
        formatChanged: (i, u, p, b) => lZ(e, s, i, u, p, b),
        getCssText: Je(Wre, e)
      };
    }, jx = (e) => {
      switch (e.toLowerCase()) {
        case "undo":
        case "redo":
        case "mcefocus":
          return !0;
        default:
          return !1;
      }
    }, aG = (e, n, s) => {
      const i = Xe(!1), u = (T) => {
        Fx(n, !1, s), n.add({}, T);
      };
      e.on("init", () => {
        n.add();
      }), e.on("BeforeExecCommand", (T) => {
        const M = T.command;
        jx(M) || (XL(n, s), n.beforeChange());
      }), e.on("ExecCommand", (T) => {
        const M = T.command;
        jx(M) || u(T);
      }), e.on("ObjectResizeStart cut", () => {
        n.beforeChange();
      }), e.on("SaveContent ObjectResized blur", u), e.on("dragend", u), e.on("keyup", (T) => {
        const M = T.keyCode;
        if (T.isDefaultPrevented())
          return;
        const j = sn.os.isMacOS() && T.key === "Meta";
        (M >= 33 && M <= 36 || M >= 37 && M <= 40 || M === 45 || T.ctrlKey || j) && (u(), e.nodeChanged()), (M === 46 || M === 8) && e.nodeChanged(), i.get() && n.typing && !DN(sA(e), n.data[0]) && (e.isDirty() || e.setDirty(!0), e.dispatch("TypingUndo"), i.set(!1), e.nodeChanged());
      }), e.on("keydown", (T) => {
        const M = T.keyCode;
        if (T.isDefaultPrevented())
          return;
        if (M >= 33 && M <= 36 || M >= 37 && M <= 40 || M === 45) {
          n.typing && u(T);
          return;
        }
        const j = T.ctrlKey && !T.altKey || T.metaKey;
        if ((M < 16 || M > 20) && M !== 224 && M !== 91 && !n.typing && !j) {
          n.beforeChange(), Fx(n, !0, s), n.add({}, T), i.set(!0);
          return;
        }
        (sn.os.isMacOS() ? T.metaKey : T.ctrlKey && !T.altKey) && n.beforeChange();
      }), e.on("mousedown", (T) => {
        n.typing && u(T);
      });
      const p = (T) => T.inputType === "insertReplacementText", b = (T) => T.inputType === "insertText" && T.data === null, S = (T) => T.inputType === "insertFromPaste" || T.inputType === "insertFromDrop";
      e.on("input", (T) => {
        T.inputType && (p(T) || b(T) || S(T)) && u(T);
      }), e.on("AddUndo Undo Redo ClearUndos", (T) => {
        T.isDefaultPrevented() || e.nodeChanged();
      });
    }, B6 = (e) => {
      e.addShortcut("meta+z", "", "Undo"), e.addShortcut("meta+y,meta+shift+z", "", "Redo");
    }, XN = (e) => {
      const n = Ii(), s = Xe(0), i = Xe(0), u = {
        data: [],
        typing: !1,
        beforeChange: () => {
          s6(e, s, n);
        },
        add: (p, b) => PN(e, u, i, s, n, p, b),
        dispatchChange: () => {
          e.setDirty(!0);
          const p = sA(e);
          p.bookmark = Pw(e.selection), e.dispatch("change", {
            level: p,
            lastLevel: xn(u.data, i.get()).getOrUndefined()
          });
        },
        undo: () => r6(e, u, s, i),
        redo: () => a6(e, i, u.data),
        clear: () => {
          MN(e, u, i);
        },
        reset: () => {
          i6(e, u);
        },
        hasUndo: () => l6(e, u, i),
        hasRedo: () => c6(e, u, i),
        transact: (p) => tZ(e, u, s, p),
        ignore: (p) => {
          IN(e, s, p);
        },
        extra: (p, b) => {
          nZ(e, u, i, p, b);
        }
      };
      return bh(e) || aG(e, u, s), B6(e), u;
    }, L6 = [
      9,
      27,
      Qt.HOME,
      Qt.END,
      19,
      20,
      44,
      144,
      145,
      33,
      34,
      45,
      16,
      17,
      18,
      91,
      92,
      93,
      Qt.DOWN,
      Qt.UP,
      Qt.LEFT,
      Qt.RIGHT
    ].concat(sn.browser.isFirefox() ? [224] : []), $6 = "data-mce-placeholder", H6 = (e) => e.type === "keydown" || e.type === "keyup", Ug = (e) => {
      const n = e.keyCode;
      return n === Qt.BACKSPACE || n === Qt.DELETE;
    }, iG = (e) => {
      if (H6(e)) {
        const n = e.keyCode;
        return !Ug(e) && (Qt.metaKeyPressed(e) || e.altKey || n >= 112 && n <= 123 || Nt(L6, n));
      } else
        return !1;
    }, lG = (e) => H6(e) && !(Ug(e) || e.type === "keyup" && e.keyCode === 229), cG = (e, n, s) => {
      if (e.isEmpty(n, void 0, {
        skipBogus: !1,
        includeZwsp: !0
      })) {
        const i = n.firstElementChild;
        return i ? e.getStyle(n.firstElementChild, "padding-left") || e.getStyle(n.firstElementChild, "padding-right") ? !1 : s === i.nodeName.toLowerCase() : !0;
      } else
        return !1;
    }, uG = (e) => {
      var n;
      const s = e.dom, i = Dl(e), u = (n = g1(e)) !== null && n !== void 0 ? n : "", p = (b, S) => {
        if (iG(b))
          return;
        const T = e.getBody(), M = lG(b) ? !1 : cG(s, T, i);
        (s.getAttrib(T, $6) !== "" !== M || S) && (s.setAttrib(T, $6, M ? u : null), fx(e, M), e.on(M ? "keydown" : "keyup", p), e.off(M ? "keyup" : "keydown", p));
      };
      ko(u) && e.on("init", (b) => {
        p(b, !0), e.on("change SetContent ExecCommand", p), e.on("paste", (S) => Rd.setEditorTimeout(e, () => p(S)));
      });
    }, dG = (e, n) => ({
      block: e,
      position: n
    }), fG = (e, n) => ({
      from: e,
      to: n
    }), QN = (e, n) => {
      const s = Me.fromDom(e), i = Me.fromDom(n.container());
      return lT(s, i).map((u) => dG(u, n));
    }, mG = (e) => !(Gi(e.to.block, e.from.block) || Gi(e.from.block, e.to.block)), pG = (e) => !Bs(e.from.block, e.to.block), PS = (e, n) => sa(n, (u) => Fv(u) || Mt(u.dom), (u) => Bs(u, e)).filter(nt).getOr(e), hG = (e, n) => {
      const s = Me.fromDom(e);
      return Bs(PS(s, n.from.block), PS(s, n.to.block));
    }, gG = (e) => Ls(e.from.block.dom) === !1 && Ls(e.to.block.dom) === !1, Gre = (e) => {
      const n = (s) => x_(s) || ml(s.dom) || Dc(s);
      return n(e.from.block) && n(e.to.block);
    }, MS = (e, n, s, i) => Vs(i.position.getNode()) && !kr(e, i.block) ? Eg(!1, i.block.dom).bind((u) => u.isEqual(i.position) ? yu(s, n, u).bind((p) => QN(n, p)) : X.some(i)).getOr(i) : i, vG = (e, n, s, i) => {
      const u = QN(n, gt.fromRangeStart(i)), p = u.bind((b) => yu(s, n, b.position).bind((S) => QN(n, S).map((T) => MS(e, n, s, T))));
      return ga(u, p, fG).filter((b) => pG(b) && hG(n, b) && gG(b) && Gre(b) && mG(b));
    }, JN = (e, n, s, i) => i.collapsed ? vG(e, n, s, i) : X.none(), z6 = (e, n, s) => {
      const i = s ? wp(e).reverse() : qi(e), u = ao(i, (p) => n.isBlock(fs(p))).fold(ze(i), (p) => i.slice(0, p));
      return s ? u.reverse() : u;
    }, bG = (e, n, s, i, u) => {
      if (u && Gi(e, n))
        return z6(n, s, i);
      if (u && Gi(n, e))
        return z6(e, s, i);
      {
        const p = Ya(n);
        return ao(p, (b) => s.isBlock(fs(b))).fold(ze(p), (b) => p.slice(0, b));
      }
    }, V6 = (e, n, s, i, u) => {
      const p = bG(e, n, s, i, u);
      return je(p, vr), p;
    }, U6 = (e, n, s) => {
      const i = Fg(s, n);
      return Dn(i.reverse(), (u) => kr(e, u)).each(vr);
    }, i0 = (e, n) => on(wp(n), (s) => !kr(e, s)).length === 0, l0 = (e, n, s, i, u, p) => {
      if (kr(i, s))
        return Xc(s), jl(s.dom);
      i0(i, p) && kr(i, n) && Ki(p, Me.fromTag("br"));
      const b = eu(s.dom, gt.before(p.dom));
      return je(V6(s, n, i, u, !1), (S) => {
        Ki(p, S);
      }), U6(i, e, n), b;
    }, gA = (e, n) => e.isInline(fs(n)), vA = (e, n, s, i, u) => {
      if (kr(i, s)) {
        if (kr(i, n)) {
          const S = zt(((T) => {
            const M = (j, W) => Lf(j).fold(() => W, (G) => gA(i, G) ? M(G, W.concat(uf(G))) : W);
            return M(T, []);
          })(s), (T, M) => (Xh(T, M), M), ug());
          Vc(n), Zr(n, S);
        }
        return vr(s), jl(n.dom);
      }
      const p = xu(s.dom);
      return je(V6(s, n, i, u, !0), (b) => {
        u && Gi(n, s) ? Rm(s, b) : Zr(s, b);
      }), U6(i, e, n), p;
    }, c0 = (e, n) => {
      const s = Fg(n, e);
      return X.from(s[s.length - 1]);
    }, u0 = (e, n) => Gi(n, e) ? c0(n, e) : X.none(), IS = (e, n) => {
      Eg(e, n.dom).bind((s) => X.from(s.getNode())).map(Me.fromDom).filter(Mv).each(vr);
    }, d0 = (e, n, s, i, u) => (IS(!0, n), IS(!1, s), u0(n, s).fold(Je(vA, e, n, s, i, u), Je(l0, e, n, s, i, u))), eP = (e, n, s, i, u, p = !1) => {
      if (p) {
        if (Gi(i, s))
          return d0(e, i, s, u, !n);
        if (Gi(s, i))
          return d0(e, s, i, u, n);
      }
      return n ? d0(e, i, s, u, n) : d0(e, s, i, u, !n);
    }, FS = (e, n) => {
      const s = Me.fromDom(e.getBody());
      return JN(e.schema, s.dom, n, e.selection.getRng()).map((u) => () => {
        eP(s, n, u.from.block, u.to.block, e.schema, !0).each((p) => {
          e.selection.setRng(p.toRange());
        });
      });
    }, tP = (e, n, s) => {
      const i = n.getRng();
      return ga(lT(e, Me.fromDom(i.startContainer)), lT(e, Me.fromDom(i.endContainer)), (u, p) => Bs(u, p) ? X.none() : X.some(() => {
        i.deleteContents(), eP(e, !0, u, p, s).each((b) => {
          n.setRng(b.toRange());
        });
      })).getOr(X.none());
    }, nP = (e, n) => {
      const s = Me.fromDom(n), i = Je(Bs, e);
      return Nr(s, Fv, i).isSome();
    }, j6 = (e, n) => nP(e, n.startContainer) || nP(e, n.endContainer), Wx = (e, n) => {
      const s = eu(e.dom, gt.fromRangeStart(n)).isNone(), i = Ul(e.dom, gt.fromRangeEnd(n)).isNone();
      return !j6(e, n) && s && i;
    }, W6 = (e) => X.some(() => {
      e.setContent(""), e.selection.setCursorLocation();
    }), Z6 = (e) => {
      const n = Me.fromDom(e.getBody()), s = e.selection.getRng();
      return Wx(n, s) ? W6(e) : tP(n, e.selection, e.schema);
    }, bA = (e, n) => e.selection.isCollapsed() ? X.none() : Z6(e), fm = (e, n, s, i, u) => X.from(n._selectionOverrides.showCaret(e, s, i, u)), G6 = (e) => {
      const n = e.ownerDocument.createRange();
      return n.selectNode(e), n;
    }, Zx = (e, n) => e.dispatch("BeforeObjectSelected", { target: n }).isDefaultPrevented() ? X.none() : X.some(G6(n)), q6 = (e, n, s) => {
      const i = Rl(1, e.getBody(), n), u = gt.fromRangeStart(i), p = u.getNode();
      if (Uy(p))
        return fm(1, e, p, !u.isAtEnd(), !1);
      const b = u.getNode(!0);
      if (Uy(b))
        return fm(1, e, b, !1, !1);
      const S = Lg(e.dom.getRoot(), u.getNode());
      return Uy(S) ? fm(1, e, S, !1, s) : X.none();
    }, yA = (e, n, s) => n.collapsed ? q6(e, n, s).getOr(n) : n, jg = (e) => ph(e) || so(e), xb = (e) => ub(e) || Sx(e), mm = (e, n) => {
      Gt(n) && n.data.length === 0 && e.remove(n);
    }, K6 = (e, n, s, i, u, p) => {
      fm(i, e, p.getNode(!u), u, !0).each((b) => {
        if (n.collapsed) {
          const S = n.cloneRange();
          u ? S.setEnd(b.startContainer, b.startOffset) : S.setStart(b.endContainer, b.endOffset), S.deleteContents();
        } else
          n.deleteContents();
        e.selection.setRng(b);
      }), mm(e.dom, s);
    }, yG = (e, n) => {
      const s = e.selection.getRng();
      if (!Gt(s.commonAncestorContainer))
        return X.none();
      const i = n ? Bi.Forwards : Bi.Backwards, u = pl(e.getBody()), p = Je(uC, n ? u.next : u.prev), b = n ? jg : xb, S = kg(i, e.getBody(), s), T = p(S), M = T && Nd(n, T);
      if (!M || !qy(S, M))
        return X.none();
      if (b(M))
        return X.some(() => K6(e, s, S.getNode(), i, n, M));
      const j = p(M);
      return j && b(j) && qy(M, j) ? X.some(() => K6(e, s, S.getNode(), i, n, j)) : X.none();
    }, oP = (e, n) => yG(e, n), sP = (e, n) => {
      const s = e.getBody();
      return n ? jl(s).filter(ph) : xu(s).filter(ub);
    }, rP = (e) => {
      const n = e.selection.getRng();
      return !n.collapsed && (sP(e, !0).exists((s) => s.isEqual(gt.fromRangeStart(n))) || sP(e, !1).exists((s) => s.isEqual(gt.fromRangeEnd(n))));
    }, xG = (e) => Ue(e) && (Fv(Me.fromDom(e)) || Dc(Me.fromDom(e))), Md = or.generate([
      { remove: ["element"] },
      { moveToElement: ["element"] },
      { moveToPosition: ["position"] }
    ]), wG = (e, n) => {
      const s = n.getNode(!e), i = e ? "after" : "before";
      return Tn(s) && s.getAttribute("data-mce-caret") === i;
    }, CG = (e, n, s, i, u) => {
      const p = (b) => u.isInline(b.nodeName.toLowerCase()) && !bu(s, i, e);
      return Zy(!n, s).fold(() => Zy(n, i).fold(et, p), p);
    }, Y6 = (e, n, s, i, u) => {
      const p = u.getNode(!s);
      return lT(Me.fromDom(n), Me.fromDom(i.getNode())).map((b) => kr(e, b) ? Md.remove(b.dom) : Md.moveToElement(p)).orThunk(() => X.some(Md.moveToElement(p)));
    }, X6 = (e, n, s, i) => yu(n, e, s).bind((u) => xG(u.getNode()) || CG(e, n, s, u, i) ? X.none() : n && Ls(u.getNode()) || !n && Ls(u.getNode(!0)) ? Y6(i, e, n, s, u) : n && ub(s) || !n && ph(s) ? X.some(Md.moveToPosition(u)) : X.none()), SG = (e, n) => Vt(n) ? X.none() : e && Ls(n.nextSibling) ? X.some(Md.moveToElement(n.nextSibling)) : !e && Ls(n.previousSibling) ? X.some(Md.moveToElement(n.previousSibling)) : X.none(), aP = (e, n, s) => s.fold((i) => X.some(Md.remove(i)), (i) => X.some(Md.moveToElement(i)), (i) => bu(n, i, e) ? X.none() : X.some(Md.moveToPosition(i))), iP = (e, n, s, i) => wG(n, s) ? SG(n, s.getNode(!n)).orThunk(() => X6(e, n, s, i)) : X6(e, n, s, i).bind((u) => aP(e, s, u)), Q6 = (e, n, s, i) => {
      const u = Rl(n ? 1 : -1, e, s), p = gt.fromRangeStart(u), b = Me.fromDom(e);
      return !n && ub(p) ? X.some(Md.remove(p.getNode(!0))) : n && ph(p) ? X.some(Md.remove(p.getNode())) : !n && ph(p) && cR(b, p, i) ? UF(b, p, i).map((S) => Md.remove(S.getNode())) : n && ub(p) && VF(b, p, i) ? oj(b, p, i).map((S) => Md.remove(S.getNode())) : iP(e, n, p, i);
    }, kG = (e, n) => (s) => (e._selectionOverrides.hideFakeCaret(), z1(e, n, Me.fromDom(s)), !0), _G = (e, n) => (s) => {
      const i = n ? gt.before(s) : gt.after(s);
      return e.selection.setRng(i.toRange()), !0;
    }, J6 = (e) => (n) => (e.selection.setRng(n.toRange()), !0), lP = (e, n) => X.from(Lg(e.getBody(), n)), cP = (e, n) => {
      const s = e.selection.getNode();
      return lP(e, s).filter(Ls).fold(() => Q6(e.getBody(), n, e.selection.getRng(), e.schema).map((i) => () => i.fold(kG(e, n), _G(e, n), J6(e))), () => X.some(ot));
    }, e$ = (e) => {
      je(va(e, ".mce-offscreen-selection"), vr);
    }, t$ = (e, n) => {
      const s = e.selection.getNode();
      return Ls(s) && !yv(s) ? lP(e, s.parentNode).filter(Ls).fold(() => X.some(() => {
        e$(Me.fromDom(e.getBody())), z1(e, n, Me.fromDom(e.selection.getNode())), aa(e);
      }), () => X.some(ot)) : rP(e) ? X.some(() => {
        fB(e, e.selection.getRng(), Me.fromDom(e.getBody()));
      }) : X.none();
    }, xA = (e) => {
      const n = e.dom, s = e.selection, i = Lg(e.getBody(), s.getNode());
      if (Mt(i) && n.isBlock(i) && n.isEmpty(i)) {
        const u = n.create("br", { "data-mce-bogus": "1" });
        n.setHTML(i, ""), i.appendChild(u), s.setRng(gt.before(u).toRange());
      }
      return !0;
    }, uP = (e, n) => e.selection.isCollapsed() ? cP(e, n) : t$(e, n), n$ = (e) => e.hasOwnProperty("text"), sp = (e) => e.hasOwnProperty("marker"), Sf = (e, n) => {
      const s = (p, b) => {
        if (Gt(p))
          return {
            text: p,
            offset: b
          };
        {
          const S = n(), T = p.childNodes;
          return b < T.length ? (p.insertBefore(S, T[b]), {
            marker: S,
            before: !0
          }) : (p.appendChild(S), {
            marker: S,
            before: !1
          });
        }
      }, i = s(e.endContainer, e.endOffset);
      return {
        start: s(e.startContainer, e.startOffset),
        end: i
      };
    }, BS = (e) => {
      var n, s;
      const { start: i, end: u } = e, p = new window.Range();
      return n$(i) ? p.setStart(i.text, i.offset) : sp(i) && (i.before ? p.setStartBefore(i.marker) : p.setStartAfter(i.marker), (n = i.marker.parentNode) === null || n === void 0 || n.removeChild(i.marker)), n$(u) ? p.setEnd(u.text, u.offset) : sp(u) && (u.before ? p.setEndBefore(u.marker) : p.setEndAfter(u.marker), (s = u.marker.parentNode) === null || s === void 0 || s.removeChild(u.marker)), p;
    }, wA = (e, n) => {
      var s;
      const i = e.dom, u = i.getParent(e.selection.getStart(), i.isBlock), p = i.getParent(e.selection.getEnd(), i.isBlock), b = e.getBody();
      if (((s = u == null ? void 0 : u.nodeName) === null || s === void 0 ? void 0 : s.toLowerCase()) === "div" && u && p && u === b.firstChild && p === b.lastChild && !i.isEmpty(b)) {
        const T = u.cloneNode(!1), M = () => {
          if (n ? dB(e) : iT(e), b.firstChild !== u) {
            const j = Sf(e.selection.getRng(), () => document.createElement("span"));
            Array.from(b.childNodes).forEach((W) => T.appendChild(W)), b.appendChild(T), e.selection.setRng(BS(j));
          }
        };
        return X.some(M);
      }
      return X.none();
    }, CA = (e, n) => {
      const s = gt.fromRangeStart(e.selection.getRng());
      return yu(n, e.getBody(), s).filter((i) => n ? QU(i) : JU(i)).bind((i) => Wy(n ? 0 : -1, i)).map((i) => () => e.selection.select(i));
    }, SA = (e, n) => e.selection.isCollapsed() ? CA(e, n) : X.none(), f0 = Gt, dP = (e) => f0(e) && e.data[0] === Ma, fP = (e) => f0(e) && e.data[e.data.length - 1] === Ma, mP = (e) => {
      var n;
      return ((n = e.ownerDocument) !== null && n !== void 0 ? n : document).createTextNode(Ma);
    }, o$ = (e) => {
      var n;
      if (f0(e.previousSibling))
        return fP(e.previousSibling) || e.previousSibling.appendData(Ma), e.previousSibling;
      if (f0(e))
        return dP(e) || e.insertData(0, Ma), e;
      {
        const s = mP(e);
        return (n = e.parentNode) === null || n === void 0 || n.insertBefore(s, e), s;
      }
    }, kA = (e) => {
      var n, s;
      if (f0(e.nextSibling))
        return dP(e.nextSibling) || e.nextSibling.insertData(0, Ma), e.nextSibling;
      if (f0(e))
        return fP(e) || e.appendData(Ma), e;
      {
        const i = mP(e);
        return e.nextSibling ? (n = e.parentNode) === null || n === void 0 || n.insertBefore(i, e.nextSibling) : (s = e.parentNode) === null || s === void 0 || s.appendChild(i), i;
      }
    }, Gx = (e, n) => e ? o$(n) : kA(n), EG = Je(Gx, !0), TG = Je(Gx, !1), s$ = (e, n) => Gt(e.container()) ? Gx(n, e.container()) : Gx(n, e.getNode()), r$ = (e, n) => {
      const s = n.get();
      return s && e.container() === s && ff(s);
    }, _A = (e, n) => n.fold((s) => {
      oh(e.get());
      const i = EG(s);
      return e.set(i), X.some(gt(i, i.length - 1));
    }, (s) => jl(s).map((i) => {
      if (r$(i, e)) {
        const u = e.get();
        return gt(u, 1);
      } else {
        oh(e.get());
        const u = s$(i, !0);
        return e.set(u), gt(u, 1);
      }
    }), (s) => xu(s).map((i) => {
      if (r$(i, e)) {
        const u = e.get();
        return gt(u, u.length - 1);
      } else {
        oh(e.get());
        const u = s$(i, !1);
        return e.set(u), gt(u, u.length - 1);
      }
    }), (s) => {
      oh(e.get());
      const i = TG(s);
      return e.set(i), X.some(gt(i, 1));
    }), a$ = (e, n) => {
      for (let s = 0; s < e.length; s++) {
        const i = e[s].apply(null, n);
        if (i.isSome())
          return i;
      }
      return X.none();
    }, su = or.generate([
      { before: ["element"] },
      { start: ["element"] },
      { end: ["element"] },
      { after: ["element"] }
    ]), EA = (e, n) => {
      const s = gf(n, e);
      return s || e;
    }, AG = (e, n, s) => {
      const i = Pc(s), u = EA(n, i.container());
      return Bg(e, u, i).fold(() => Ul(u, i).bind(Je(Bg, e, u)).map((p) => su.before(p)), X.none);
    }, OG = (e, n) => Tg(e, n) === null, i$ = (e, n, s) => Bg(e, n, s).filter(Je(OG, n)), DG = (e, n, s) => {
      const i = cB(s);
      return i$(e, n, i).bind((u) => eu(u, i).isNone() ? X.some(su.start(u)) : X.none());
    }, RG = (e, n, s) => {
      const i = Pc(s);
      return i$(e, n, i).bind((u) => Ul(u, i).isNone() ? X.some(su.end(u)) : X.none());
    }, NG = (e, n, s) => {
      const i = cB(s), u = EA(n, i.container());
      return Bg(e, u, i).fold(() => eu(u, i).bind(Je(Bg, e, u)).map((p) => su.after(p)), X.none);
    }, l$ = (e) => !aB(LS(e)), kf = (e, n, s) => a$([
      AG,
      DG,
      RG,
      NG
    ], [
      e,
      n,
      s
    ]).filter(l$), LS = (e) => e.fold(jt, jt, jt, jt), c$ = (e) => e.fold(ze("before"), ze("start"), ze("end"), ze("after")), TA = (e) => e.fold(su.before, su.before, su.after, su.after), pP = (e) => e.fold(su.start, su.start, su.end, su.end), PG = (e, n) => c$(e) === c$(n) && LS(e) === LS(n), u$ = (e, n, s, i, u, p) => ga(Bg(n, s, i), Bg(n, s, u), (b, S) => b !== S && iB(s, b, S) ? su.after(e ? b : S) : p).getOr(p), MG = (e, n) => e.fold(xt, (s) => !PG(s, n)), IG = (e, n, s, i, u) => {
      const p = Nd(e, u);
      return yu(e, s, p).map(Je(Nd, e)).fold(() => i.map(TA), (T) => kf(n, s, T).map(Je(u$, e, n, s, p, T)).filter(Je(MG, i))).filter(l$);
    }, hP = (e, n) => e ? n.fold(B(X.some, su.start), X.none, B(X.some, su.after), X.none) : n.fold(X.none, B(X.some, su.before), X.none, B(X.some, su.end)), FG = (e, n, s, i) => {
      const u = Nd(e, i), p = kf(n, s, u);
      return kf(n, s, u).bind(Je(hP, e)).orThunk(() => IG(e, n, s, p, i));
    }, BG = (e) => Ce(e.selection.getSel().modify), d$ = (e, n, s) => {
      const i = e ? 1 : -1;
      return n.setRng(gt(s.container(), s.offset() + i).toRange()), n.getSel().modify("move", e ? "forward" : "backward", "word"), !0;
    }, LG = (e, n) => {
      const s = n.selection.getRng(), i = e ? gt.fromRangeEnd(s) : gt.fromRangeStart(s);
      return BG(n) ? e && ww(i) ? d$(!0, n.selection, i) : !e && mg(i) ? d$(!1, n.selection, i) : !1 : !1;
    };
    var wh;
    (function(e) {
      e[e.Br = 0] = "Br", e[e.Block = 1] = "Block", e[e.Wrap = 2] = "Wrap", e[e.Eol = 3] = "Eol";
    })(wh || (wh = {}));
    const AA = (e, n) => e === Bi.Backwards ? os(n) : n, $G = (e, n, s) => e === Bi.Forwards ? n.next(s) : n.prev(s), OA = (e, n, s, i) => Vs(i.getNode(n === Bi.Forwards)) ? wh.Br : bu(s, i) === !1 ? wh.Block : wh.Wrap, $S = (e, n, s, i) => {
      const u = pl(s);
      let p = i;
      const b = [];
      for (; p; ) {
        const S = $G(n, u, p);
        if (!S)
          break;
        if (Vs(S.getNode(!1)))
          return n === Bi.Forwards ? {
            positions: AA(n, b).concat([S]),
            breakType: wh.Br,
            breakAt: X.some(S)
          } : {
            positions: AA(n, b),
            breakType: wh.Br,
            breakAt: X.some(S)
          };
        if (!S.isVisible()) {
          p = S;
          continue;
        }
        if (e(p, S)) {
          const T = OA(s, n, p, S);
          return {
            positions: AA(n, b),
            breakType: T,
            breakAt: X.some(S)
          };
        }
        b.push(S), p = S;
      }
      return {
        positions: AA(n, b),
        breakType: wh.Eol,
        breakAt: X.none()
      };
    }, f$ = (e, n, s, i) => n(s, i).breakAt.map((u) => {
      const p = n(s, u).positions;
      return e === Bi.Backwards ? p.concat(u) : [u].concat(p);
    }).getOr([]), gP = (e, n) => vt(e, (s, i) => s.fold(() => X.some(i), (u) => ga(hn(u.getClientRects()), hn(i.getClientRects()), (p, b) => {
      const S = Math.abs(n - p.left);
      return Math.abs(n - b.left) <= S ? i : u;
    }).or(s)), X.none()), m0 = (e, n) => hn(n.getClientRects()).bind((s) => gP(e, s.left)), HS = Je($S, gt.isAbove, -1), zS = Je($S, gt.isBelow, 1), m$ = Je(f$, -1, HS), p$ = Je(f$, 1, zS), h$ = (e, n) => HS(e, n).breakAt.isNone(), g$ = (e, n) => zS(e, n).breakAt.isNone(), HG = (e) => jl(e).map((n) => [n].concat(zS(e, n).positions)).getOr([]), zG = (e) => xu(e).map((n) => HS(e, n).positions.concat(n)).getOr([]), VG = (e, n) => m0(m$(e, n), n), UG = (e, n) => m0(p$(e, n), n), jG = Ls, WG = (e, n) => Math.abs(e.left - n), _f = (e, n) => Math.abs(e.right - n), vP = (e) => wr(e, "node"), bP = (e, n) => Ne(e, (s, i) => {
      const u = Math.min(WG(s, n), _f(s, n)), p = Math.min(WG(i, n), _f(i, n));
      return p === u && vP(i) && jG(i.node) || p < u ? i : s;
    }), v$ = (e) => {
      const n = (s) => tn(s, (i) => {
        const u = Hm(i);
        return u.node = e, u;
      });
      if (Tn(e))
        return n(e.getClientRects());
      if (Gt(e)) {
        const s = e.ownerDocument.createRange();
        return s.setStart(e, 0), s.setEnd(e, e.data.length), n(s.getClientRects());
      } else
        return [];
    }, b$ = (e) => rs(e, v$);
    var qx;
    (function(e) {
      e[e.Up = -1] = "Up", e[e.Down = 1] = "Down";
    })(qx || (qx = {}));
    const ZG = (e, n, s, i) => {
      let u = i;
      for (; u = Kv(u, e, kw, n); )
        if (s(u))
          return;
    }, yP = (e, n, s, i, u, p) => {
      let b = 0;
      const S = [], T = (W) => {
        let G = b$([W]);
        e === -1 && (G = G.reverse());
        for (let ue = 0; ue < G.length; ue++) {
          const we = G[ue];
          if (!s(we, M)) {
            if (S.length > 0 && n(we, ct(S)) && b++, we.line = b, u(we))
              return !0;
            S.push(we);
          }
        }
        return !1;
      }, M = ct(p.getClientRects());
      if (!M)
        return S;
      const j = p.getNode();
      return j && (T(j), ZG(e, i, T, j)), S;
    }, GG = (e, n) => n.line > e, qG = (e, n) => n.line === e, KG = Je(yP, qx.Up, i1, py), Kx = Je(yP, qx.Down, py, i1), xP = (e) => ct(e.getClientRects()), y$ = (e, n, s, i) => {
      const u = pl(n);
      let p, b, S, T;
      const M = [];
      let j = 0;
      e === 1 ? (p = u.next, b = py, S = i1, T = gt.after(i)) : (p = u.prev, b = i1, S = py, T = gt.before(i));
      const W = xP(T);
      do {
        if (!T.isVisible())
          continue;
        const G = xP(T);
        if (S(G, W))
          continue;
        M.length > 0 && b(G, ct(M)) && j++;
        const ue = Hm(G);
        if (ue.position = T, ue.line = j, s(ue))
          return M;
        M.push(ue);
      } while (T = p(T));
      return M;
    }, wP = (e) => (n) => GG(e, n), VS = (e) => (n) => qG(e, n), Wg = (e, n) => {
      e.selection.setRng(n), WC(e, e.selection.getRng());
    }, CP = (e, n, s) => X.some(yA(e, n, s)), x$ = (e, n, s, i, u, p) => {
      const b = n === Bi.Forwards, S = pl(e.getBody()), T = Je(uC, b ? S.next : S.prev), M = b ? i : u;
      if (!s.collapsed) {
        const we = Lv(s);
        if (p(we))
          return fm(n, e, we, n === Bi.Backwards, !1);
        if (rP(e)) {
          const fe = s.cloneRange();
          return fe.collapse(n === Bi.Backwards), X.from(fe);
        }
      }
      const j = kg(n, e.getBody(), s);
      if (M(j))
        return Zx(e, j.getNode(!b));
      let W = T(j);
      const G = ic(s);
      if (W)
        W = Nd(b, W);
      else
        return G ? X.some(s) : X.none();
      if (M(W))
        return fm(n, e, W.getNode(!b), b, !1);
      const ue = T(W);
      return ue && M(ue) && qy(W, ue) ? fm(n, e, ue.getNode(!b), b, !1) : G ? CP(e, W.toRange(), !1) : X.none();
    }, YG = (e, n, s, i, u, p) => {
      const b = kg(n, e.getBody(), s), S = ct(b.getClientRects()), T = n === qx.Down, M = e.getBody();
      if (!S)
        return X.none();
      if (rP(e)) {
        const ke = T ? gt.fromRangeEnd(s) : gt.fromRangeStart(s);
        return (T ? UG : VG)(M, ke).orThunk(() => X.from(ke)).map((Ye) => Ye.toRange());
      }
      const W = (T ? Kx : KG)(M, wP(1), b), G = on(W, VS(1)), ue = S.left, we = bP(G, ue);
      if (we && p(we.node)) {
        const ke = Math.abs(ue - we.left), He = Math.abs(ue - we.right);
        return fm(n, e, we.node, ke < He, !1);
      }
      let fe;
      if (i(b) ? fe = b.getNode() : u(b) ? fe = b.getNode(!0) : fe = Lv(s), fe) {
        const ke = y$(n, M, wP(1), fe);
        let He = bP(on(ke, VS(1)), ue);
        if (He || (He = ct(on(ke, VS(0))), He))
          return CP(e, He.position.toRange(), !1);
      }
      return G.length === 0 ? w$(e, T).filter(T ? u : i).map((ke) => yA(e, ke.toRange(), !1)) : X.none();
    }, w$ = (e, n) => {
      const s = e.selection.getRng(), i = n ? gt.fromRangeEnd(s) : gt.fromRangeStart(s), u = cD(i.container(), e.getBody());
      if (n) {
        const p = zS(u, i);
        return Do(p.positions);
      } else {
        const p = HS(u, i);
        return hn(p.positions);
      }
    }, XG = (e, n, s) => w$(e, n).filter(s).exists((i) => (e.selection.setRng(i.toRange()), !0)), sd = (e, n) => {
      const s = e.dom.createRng();
      s.setStart(n.container(), n.offset()), s.setEnd(n.container(), n.offset()), e.selection.setRng(s);
    }, C$ = (e, n) => {
      e ? n.setAttribute("data-mce-selected", "inline-boundary") : n.removeAttribute("data-mce-selected");
    }, S$ = (e, n, s) => _A(n, s).map((i) => (sd(e, i), s)), p0 = (e, n, s) => {
      const i = gt.fromRangeStart(e);
      if (e.collapsed)
        return i;
      {
        const u = gt.fromRangeEnd(e);
        return s ? eu(n, u).getOr(u) : Ul(n, i).getOr(i);
      }
    }, k$ = (e, n, s) => {
      const i = e.getBody(), u = p0(e.selection.getRng(), i, s), p = Je(db, e);
      return FG(s, p, i, u).bind((S) => S$(e, n, S));
    }, QG = (e, n, s) => {
      const i = tn(va(Me.fromDom(n.getRoot()), '*[data-mce-selected="inline-boundary"]'), (b) => b.dom), u = on(i, e), p = on(s, e);
      je(zs(u, p), Je(C$, !1)), je(zs(p, u), Je(C$, !0));
    }, DA = (e, n) => {
      const s = n.get();
      if (e.selection.isCollapsed() && !e.composing && s) {
        const i = gt.fromRangeStart(e.selection.getRng());
        gt.isTextPosition(i) && !lB(i) && (sd(e, rD(s, i)), n.set(null));
      }
    }, JG = (e, n, s, i) => {
      if (n.selection.isCollapsed()) {
        const u = on(i, e);
        je(u, (p) => {
          const b = gt.fromRangeStart(n.selection.getRng());
          kf(e, n.getBody(), b).bind((S) => S$(n, s, S));
        });
      }
    }, _$ = (e, n, s) => yg(e) ? k$(e, n, s).isSome() : !1, E$ = (e, n, s) => yg(n) ? LG(e, n) : !1, eq = (e) => {
      const n = Xe(null), s = Je(db, e);
      return e.on("NodeChange", (i) => {
        yg(e) && (QG(s, e.dom, i.parents), DA(e, n), JG(s, e, n, i.parents));
      }), n;
    }, T$ = Je(E$, !0), tq = Je(E$, !1), pm = (e, n, s) => {
      if (yg(e)) {
        const i = w$(e, n).getOrThunk(() => {
          const u = e.selection.getRng();
          return n ? gt.fromRangeEnd(u) : gt.fromRangeStart(u);
        });
        return kf(Je(db, e), e.getBody(), i).exists((u) => {
          const p = TA(u);
          return _A(s, p).exists((b) => (sd(e, b), !0));
        });
      } else
        return !1;
    }, nq = (e, n) => {
      const s = document.createRange();
      return s.setStart(e.container(), e.offset()), s.setEnd(n.container(), n.offset()), s;
    }, oq = (e) => ga(jl(e), xu(e), (n, s) => {
      const i = Nd(!0, n), u = Nd(!1, s);
      return Ul(e, i).forall((p) => p.isEqual(u));
    }).getOr(!0), A$ = (e, n) => (s) => _A(n, s).map((i) => () => sd(e, i)), O$ = (e, n, s, i) => {
      const u = e.getBody(), p = Je(db, e);
      e.undoManager.ignore(() => {
        e.selection.setRng(nq(s, i)), iT(e), kf(p, u, gt.fromRangeStart(e.selection.getRng())).map(pP).bind(A$(e, n)).each(Cn);
      }), e.nodeChanged();
    }, sq = (e, n) => {
      const s = gf(n, e);
      return s || e;
    }, SP = (e, n, s, i) => {
      const u = sq(e.getBody(), i.container()), p = Je(db, e), b = kf(p, u, i);
      return b.bind((T) => s ? T.fold(ze(X.some(pP(T))), X.none, ze(X.some(TA(T))), X.none) : T.fold(X.none, ze(X.some(TA(T))), X.none, ze(X.some(pP(T))))).map(A$(e, n)).getOrThunk(() => {
        const T = Zm(s, u, i), M = T.bind((j) => kf(p, u, j));
        return ga(b, M, () => Bg(p, u, i).bind((j) => oq(j) ? X.some(() => {
          z1(e, s, Me.fromDom(j));
        }) : X.none())).getOrThunk(() => M.bind(() => T.map((j) => () => {
          s ? O$(e, n, i, j) : O$(e, n, j, i);
        })));
      });
    }, US = (e, n, s) => {
      if (e.selection.isCollapsed() && yg(e)) {
        const i = gt.fromRangeStart(e.selection.getRng());
        return SP(e, n, s, i);
      }
      return X.none();
    }, kP = (e) => Ci(e) > 1, _P = (e, n) => {
      const s = Me.fromDom(e.getBody()), i = Me.fromDom(e.selection.getStart()), u = Fg(i, s);
      return ao(u, n).fold(ze(u), (p) => u.slice(0, p));
    }, D$ = (e) => Ci(e) === 1, R$ = (e) => _P(e, (n) => e.schema.isBlock(fs(n)) || kP(n)), rq = (e) => _P(e, (n) => e.schema.isBlock(fs(n))), Yx = (e, n) => {
      const s = Je(GR, e);
      return rs(n, (i) => s(i) ? [i.dom] : []);
    }, jS = (e) => {
      const n = rq(e);
      return Yx(e, n);
    }, N$ = (e, n, s, i) => {
      const u = Yx(n, i);
      if (u.length === 0)
        z1(n, e, s);
      else {
        const p = jB(s.dom, u);
        n.selection.setRng(p.toRange());
      }
    }, P$ = (e, n) => {
      const s = on(R$(e), D$);
      return Do(s).bind((i) => {
        const u = gt.fromRangeStart(e.selection.getRng());
        return JC(n, u, i.dom) && !T1(i) ? X.some(() => N$(n, e, i, s)) : X.none();
      });
    }, M$ = (e, n) => {
      const s = n.parentElement;
      return Vs(n) && !ee(s) && e.dom.isEmpty(s);
    }, I$ = (e) => T1(Me.fromDom(e)), WS = (e, n) => {
      const s = e.selection.getStart(), i = M$(e, s) || I$(s) ? jB(s, n) : ZR(e.selection.getRng(), n);
      e.selection.setRng(i.toRange());
    }, EP = (e, n) => {
      const s = zs(n, jS(e));
      s.length > 0 && WS(e, s);
    }, Xx = (e) => Gt(e.startContainer), aq = (e) => e.startOffset === 0 && Xx(e), F$ = (e, n) => {
      const s = n.startContainer.parentElement;
      return !ee(s) && GR(e, Me.fromDom(s));
    }, iq = (e) => {
      const n = e.startContainer.parentNode, s = e.endContainer.parentNode;
      return !ee(n) && !ee(s) && n.isEqualNode(s);
    }, lq = (e) => {
      const n = e.endContainer;
      return e.endOffset === (Gt(n) ? n.length : n.childNodes.length);
    }, B$ = (e) => iq(e) && lq(e), cq = (e) => !e.endContainer.isEqualNode(e.commonAncestorContainer), L$ = (e) => B$(e) || cq(e), qre = (e) => {
      const n = e.selection.getRng();
      return aq(n) && F$(e, n) && L$(n);
    }, uq = (e) => {
      if (qre(e)) {
        const n = jS(e);
        return X.some(() => {
          iT(e), EP(e, n);
        });
      } else
        return X.none();
    }, TP = (e, n) => e.selection.isCollapsed() ? P$(e, n) : uq(e), dq = (e, n) => gv(e, (s) => wu(s.dom), (s) => n.isBlock(fs(s))), fq = (e) => dq(Me.fromDom(e.selection.getStart()), e.schema), mq = (e) => {
      const n = e.selection.getRng();
      return n.collapsed && (Xx(n) || e.dom.isEmpty(n.startContainer)) && !fq(e);
    }, ZS = (e) => (mq(e) && WS(e, []), !0), AP = (e, n, s) => Ue(s) ? X.some(() => {
      e._selectionOverrides.hideFakeCaret(), z1(e, n, Me.fromDom(s));
    }) : X.none(), pq = (e, n) => {
      const s = n ? so : Sx, i = n ? Bi.Forwards : Bi.Backwards, u = kg(i, e.getBody(), e.selection.getRng());
      return s(u) ? AP(e, n, u.getNode(!n)) : X.from(Nd(n, u)).filter((p) => s(p) && qy(u, p)).bind((p) => AP(e, n, p.getNode(!n)));
    }, $$ = (e, n) => {
      const s = e.selection.getNode();
      return Yi(s) ? AP(e, n, s) : X.none();
    }, OP = (e, n) => e.selection.isCollapsed() ? pq(e, n) : $$(e, n), h0 = (e) => sa(e, (n) => Mt(n.dom) || Ls(n.dom)).exists((n) => Mt(n.dom)), RA = (e) => Ba(e ?? "").getOr(0), NA = (e, n) => {
      const s = e || bw(n) ? "margin" : "padding", i = da(n, "direction") === "rtl" ? "-right" : "-left";
      return s + i;
    }, H$ = (e, n, s, i, u, p) => {
      const b = NA(s, Me.fromDom(p)), S = RA(e.getStyle(p, b));
      if (n === "outdent") {
        const T = Math.max(0, S - i);
        e.setStyle(p, b, T ? T + u : "");
      } else {
        const T = S + i + u;
        e.setStyle(p, b, T);
      }
    }, DP = (e, n) => Qo(n, (s) => {
      const i = NA(Ww(e), s), u = Sl(s, i).map(RA).getOr(0);
      return e.dom.getContentEditable(s.dom) !== "false" && u > 0;
    }), Zg = (e) => {
      const n = wb(e);
      return !e.mode.isReadOnly() && (n.length > 1 || DP(e, n));
    }, RP = (e) => df(e) || Dc(e), Ef = (e) => Ni(e).exists(RP), wb = (e) => on($u(e.selection.getSelectedBlocks()), (n) => !RP(n) && !Ef(n) && h0(n)), PA = (e, n) => {
      var s, i;
      const { dom: u } = e, p = yU(e), b = (i = (s = /[a-z%]+$/i.exec(p)) === null || s === void 0 ? void 0 : s[0]) !== null && i !== void 0 ? i : "px", S = RA(p), T = Ww(e);
      je(wb(e), (M) => {
        H$(u, n, T, S, b, M.dom);
      });
    }, hq = (e) => PA(e, "indent"), NP = (e) => PA(e, "outdent"), z$ = (e) => {
      if (e.selection.isCollapsed() && Zg(e)) {
        const n = e.dom, s = e.selection.getRng(), i = gt.fromRangeStart(s), u = n.getParent(s.startContainer, n.isBlock);
        if (u !== null && lR(Me.fromDom(u), i, e.schema))
          return X.some(() => NP(e));
      }
      return X.none();
    }, V$ = (e, n, s) => pr([
      z$,
      uP,
      oP,
      (i, u) => US(i, n, u),
      FS,
      G1,
      SA,
      OP,
      bA,
      TP,
      wA
    ], (i) => i(e, s)).filter((i) => e.selection.isEditable()), gq = (e, n) => {
      V$(e, n, !1).fold(() => {
        e.selection.isEditable() && (iT(e), aa(e));
      }, Cn);
    }, vq = (e, n) => {
      V$(e, n, !0).fold(() => {
        e.selection.isEditable() && dB(e);
      }, Cn);
    }, bq = (e, n) => {
      e.addCommand("delete", () => {
        gq(e, n);
      }), e.addCommand("forwardDelete", () => {
        vq(e, n);
      });
    }, PP = 5, yq = 400, U$ = (e) => e.touches === void 0 || e.touches.length !== 1 ? X.none() : X.some(e.touches[0]), Qx = (e, n) => {
      const s = Math.abs(e.clientX - n.x), i = Math.abs(e.clientY - n.y);
      return s > PP || i > PP;
    }, MA = (e) => {
      const n = Ii(), s = Xe(!1), i = Up((u) => {
        e.dispatch("longpress", {
          ...u,
          type: "longpress"
        }), s.set(!0);
      }, yq);
      e.on("touchstart", (u) => {
        U$(u).each((p) => {
          i.cancel();
          const b = {
            x: p.clientX,
            y: p.clientY,
            target: u.target
          };
          i.throttle(u), s.set(!1), n.set(b);
        });
      }, !0), e.on("touchmove", (u) => {
        i.cancel(), U$(u).each((p) => {
          n.on((b) => {
            Qx(p, b) && (n.clear(), s.set(!1), e.dispatch("longpresscancel"));
          });
        });
      }, !0), e.on("touchend touchcancel", (u) => {
        i.cancel(), u.type !== "touchcancel" && n.get().filter((p) => p.target.isEqualNode(u.target)).each(() => {
          s.get() ? u.preventDefault() : e.dispatch("tap", {
            ...u,
            type: "tap"
          });
        });
      }, !0);
    }, IA = (e, n) => Xn(e, n.nodeName), j$ = (e, n) => Gt(n) ? !0 : Tn(n) ? !IA(e.getBlockElements(), n) && !Cu(n) && !Uu(e, n) && !Ca(n) : !1, MP = (e, n, s) => Vn(LF(Me.fromDom(s), Me.fromDom(n)), (i) => IA(e, i.dom)), xq = (e, n) => {
      if (Gt(n)) {
        if (n.data.length === 0)
          return !0;
        if (/^\s+$/.test(n.data))
          return !n.nextSibling || IA(e, n.nextSibling) || Ca(n.nextSibling);
      }
      return !1;
    }, IP = (e) => e.dom.create(Dl(e), Xp(e)), wq = (e) => {
      const n = e.dom, s = e.selection, i = e.schema, u = i.getBlockElements(), p = s.getStart(), b = e.getBody();
      let S, T, M = null;
      const j = Dl(e);
      if (!p || !Tn(p))
        return;
      const W = b.nodeName.toLowerCase();
      if (!i.isValidChild(W, j.toLowerCase()) || MP(u, b, p))
        return;
      if (b.firstChild === b.lastChild && Vs(b.firstChild)) {
        S = IP(e), S.appendChild(ug().dom), b.replaceChild(S, b.firstChild), e.selection.setCursorLocation(S, 0), e.nodeChanged();
        return;
      }
      let G = b.firstChild;
      for (; G; )
        if (Tn(G) && oc(i, G), j$(i, G)) {
          if (xq(u, G)) {
            T = G, G = G.nextSibling, n.remove(T);
            continue;
          }
          if (!S) {
            if (!M && e.hasFocus() && (M = Sf(e.selection.getRng(), () => document.createElement("span"))), !G.parentNode) {
              G = null;
              break;
            }
            S = IP(e), b.insertBefore(S, G);
          }
          T = G, G = G.nextSibling, S.appendChild(T);
        } else
          S = null, G = G.nextSibling;
      M && (e.selection.setRng(BS(M)), e.nodeChanged());
    }, W$ = (e, n, s) => {
      const i = Me.fromDom(IP(e)), u = ug();
      Zr(i, u), s(n, i);
      const p = document.createRange();
      return p.setStartBefore(u.dom), p.setEndBefore(u.dom), p;
    }, Cq = (e) => {
      e.on("NodeChange", () => wq(e));
    }, Z$ = (e) => (n) => (" " + n.attr("class") + " ").indexOf(e) !== -1, Sq = (e, n, s) => function(i) {
      const u = arguments, p = u[u.length - 2], b = p > 0 ? n.charAt(p - 1) : "";
      if (b === '"')
        return i;
      if (b === ">") {
        const S = n.lastIndexOf("<", p);
        if (S !== -1 && n.substring(S, p).indexOf('contenteditable="false"') !== -1)
          return i;
      }
      return '<span class="' + s + '" data-mce-content="' + e.dom.encode(u[0]) + '">' + e.dom.encode(typeof u[1] == "string" ? u[1] : u[0]) + "</span>";
    }, G$ = (e, n, s) => {
      let i = n.length, u = s.content;
      if (s.format !== "raw") {
        for (; i--; )
          u = u.replace(n[i], Sq(e, u, My(e)));
        s.content = u;
      }
    }, kq = (e, n) => Qo(e, (s) => {
      const i = n.match(s);
      return i !== null && i[0].length === n.length;
    }), _q = (e) => {
      const n = "contenteditable", s = " " + Kt.trim(QO(e)) + " ", i = " " + Kt.trim(My(e)) + " ", u = Z$(s), p = Z$(i), b = Od(e);
      b.length > 0 && e.on("BeforeSetContent", (S) => {
        G$(e, b, S);
      }), e.parser.addAttributeFilter("class", (S) => {
        let T = S.length;
        for (; T--; ) {
          const M = S[T];
          u(M) ? M.attr(n, "true") : p(M) && M.attr(n, "false");
        }
      }), e.serializer.addAttributeFilter(n, (S) => {
        let T = S.length;
        for (; T--; ) {
          const M = S[T];
          if (!u(M) && !p(M))
            continue;
          const j = M.attr("data-mce-content");
          b.length > 0 && j ? kq(b, j) ? (M.name = "#text", M.type = 3, M.raw = !0, M.value = j) : M.remove() : M.attr(n, null);
        }
      });
    }, Id = (e) => to(Me.fromDom(e.getBody()), "*[data-mce-caret]").map((n) => n.dom).getOrNull(), q$ = (e, n) => {
      n.hasAttribute("data-mce-caret") && (Os(n), e.selection.setRng(e.selection.getRng()), e.selection.scrollIntoView(n));
    }, FP = (e, n) => {
      const s = Id(e);
      if (s) {
        if (n.type === "compositionstart") {
          n.preventDefault(), n.stopPropagation(), q$(e, s);
          return;
        }
        yw(s) && (q$(e, s), e.undoManager.add());
      }
    }, K$ = (e) => {
      e.on("keyup compositionstart", Je(FP, e));
    }, FA = Ls, Eq = (e, n, s) => x$(n, e, s, ph, ub, FA), Tq = (e, n, s) => YG(n, e, s, (p) => ph(p) || aR(p), (p) => ub(p) || iR(p), FA), Aq = (e) => {
      const n = e.dom.create(Dl(e));
      return n.innerHTML = '<br data-mce-bogus="1">', n;
    }, Y$ = (e, n, s) => {
      const i = pl(e.getBody()), u = Je(uC, n === 1 ? i.next : i.prev);
      if (s.collapsed) {
        const p = e.dom.getParent(s.startContainer, "PRE");
        if (!p)
          return;
        if (!u(gt.fromRangeStart(s))) {
          const S = Me.fromDom(Aq(e));
          n === 1 ? tc(Me.fromDom(p), S) : Ki(Me.fromDom(p), S), e.selection.select(S.dom, !0), e.selection.collapse();
        }
      }
    }, Oq = (e, n) => {
      const s = n ? Bi.Forwards : Bi.Backwards, i = e.selection.getRng();
      return Eq(s, e, i).orThunk(() => (Y$(e, s, i), X.none()));
    }, X$ = (e, n) => {
      const s = n ? 1 : -1, i = e.selection.getRng();
      return Tq(s, e, i).orThunk(() => (Y$(e, s, i), X.none()));
    }, Dq = (e, n) => {
      const s = n ? e.getEnd(!0) : e.getStart(!0);
      return aB(s) ? !n : n;
    }, Q$ = (e, n) => Oq(e, Dq(e.selection, n)).exists((s) => (Wg(e, s), !0)), Jx = (e, n) => X$(e, n).exists((s) => (Wg(e, s), !0)), Ch = (e, n) => XG(e, n, n ? ub : ph), Sh = (e, n) => sP(e, !n).map((s) => {
      const i = s.toRange(), u = e.selection.getRng();
      return n ? i.setStart(u.startContainer, u.startOffset) : i.setEnd(u.endContainer, u.endOffset), i;
    }).exists((s) => (Wg(e, s), !0)), BA = (e) => Nt(["figcaption"], fs(e)), BP = (e, n, s) => {
      const i = Je(Bs, n);
      return sa(Me.fromDom(e.container()), (u) => s.isBlock(fs(u)), i).filter(BA);
    }, LP = (e, n, s) => n ? g$(e.dom, s) : h$(e.dom, s), J$ = (e, n) => {
      const s = Me.fromDom(e.getBody()), i = gt.fromRangeStart(e.selection.getRng());
      return BP(i, s, e.schema).exists(() => {
        if (LP(s, n, i)) {
          const p = W$(e, s, n ? Zr : Rm);
          return e.selection.setRng(p), !0;
        } else
          return !1;
      });
    }, e8 = (e, n) => e.selection.isCollapsed() ? J$(e, n) : !1, t8 = (e, n, s) => {
      const i = e.selection.getRng(), u = gt.fromRangeStart(i);
      return e.getBody().firstChild === n && h$(s, u) ? (e.execCommand("InsertNewBlockBefore"), !0) : !1;
    }, n8 = (e, n) => {
      const s = e.selection.getRng(), i = gt.fromRangeStart(s);
      return e.getBody().lastChild === n && g$(n, i) ? (e.execCommand("InsertNewBlockAfter"), !0) : !1;
    }, Rq = (e, n) => n ? X.from(e.dom.getParent(e.selection.getNode(), "details")).map((s) => n8(e, s)).getOr(!1) : X.from(e.dom.getParent(e.selection.getNode(), "summary")).bind((s) => X.from(e.dom.getParent(s, "details")).map((i) => t8(e, i, s))).getOr(!1), o8 = (e, n) => Rq(e, n), s8 = {
      shiftKey: !1,
      altKey: !1,
      ctrlKey: !1,
      metaKey: !1,
      keyCode: 0
    }, Nq = (e) => tn(e, (n) => ({
      ...s8,
      ...n
    })), Pq = (e) => tn(e, (n) => ({
      ...s8,
      ...n
    })), r8 = (e, n) => n.keyCode === e.keyCode && n.shiftKey === e.shiftKey && n.altKey === e.altKey && n.ctrlKey === e.ctrlKey && n.metaKey === e.metaKey, a8 = (e, n) => rs(Nq(e), (s) => r8(s, n) ? [s] : []), i8 = (e, n) => rs(Pq(e), (s) => r8(s, n) ? [s] : []), Io = (e, ...n) => () => e.apply(null, n), LA = (e, n) => Dn(a8(e, n), (s) => s.action()), Mq = (e, n) => pr(i8(e, n), (s) => s.action()), l8 = (e, n) => {
      const s = n ? Bi.Forwards : Bi.Backwards, i = e.selection.getRng();
      return x$(e, s, i, so, Sx, Yi).exists((u) => (Wg(e, u), !0));
    }, Iq = (e, n) => {
      const s = n ? 1 : -1, i = e.selection.getRng();
      return YG(e, s, i, so, Sx, Yi).exists((u) => (Wg(e, u), !0));
    }, Fq = (e, n) => XG(e, n, n ? Sx : so), c8 = or.generate([
      { none: ["current"] },
      { first: ["current"] },
      {
        middle: [
          "current",
          "target"
        ]
      },
      { last: ["current"] }
    ]), $A = {
      ...c8,
      none: (e) => c8.none(e)
    }, Bq = (e, n) => ru(e, n, xt), ru = (e, n, s) => rs(Ya(e), (i) => wl(i, n) ? s(i) ? [i] : [] : ru(i, n, s)), u8 = (e, n, s = et) => {
      if (s(n))
        return X.none();
      if (Nt(e, fs(n)))
        return X.some(n);
      const i = (u) => wl(u, "table") || s(u);
      return Na(n, e.join(","), i);
    }, GS = (e, n) => u8([
      "td",
      "th"
    ], e, n), Lq = (e) => Bq(e, "th,td"), $P = (e, n) => mu(e, "table", n), HA = (e, n, s, i, u = xt) => {
      const p = i === 1;
      if (!p && s <= 0)
        return $A.first(e[0]);
      if (p && s >= e.length - 1)
        return $A.last(e[e.length - 1]);
      {
        const b = s + i, S = e[b];
        return u(S) ? $A.middle(n, S) : HA(e, n, b, i, u);
      }
    }, zA = (e, n) => $P(e, n).bind((s) => {
      const i = Lq(s);
      return ao(i, (p) => Bs(e, p)).map((p) => ({
        index: p,
        all: i
      }));
    }), $q = (e, n, s) => zA(e, s).fold(() => $A.none(e), (u) => HA(u.all, e, u.index, 1, n)), Hq = (e, n, s) => zA(e, s).fold(() => $A.none(), (u) => HA(u.all, e, u.index, -1, n)), d8 = (e) => vO(e).filter((n) => n.trim().length !== 0 || n.indexOf(Xa) > -1).isSome(), zq = (e) => Te(e) && Rr(e, "contenteditable") === "false", Vq = [
      "img",
      "br"
    ], Uq = (e) => d8(e) || Nt(Vq, fs(e)) || zq(e), HP = (e) => Kh(e, Uq), jq = (e, n) => ({
      left: e.left - n,
      top: e.top - n,
      right: e.right + n * 2,
      bottom: e.bottom + n * 2,
      width: e.width + n,
      height: e.height + n
    }), Wq = (e, n) => rs(n, (s) => {
      const i = jq(Hm(s.getBoundingClientRect()), -1);
      return [
        {
          x: i.left,
          y: e(i),
          cell: s
        },
        {
          x: i.right,
          y: e(i),
          cell: s
        }
      ];
    }), Yre = (e, n, s) => vt(e, (i, u) => i.fold(() => X.some(u), (p) => {
      const b = Math.sqrt(Math.abs(p.x - n) + Math.abs(p.y - s)), S = Math.sqrt(Math.abs(u.x - n) + Math.abs(u.y - s));
      return X.some(S < b ? u : p);
    }), X.none()), f8 = (e, n, s, i, u) => {
      const p = va(Me.fromDom(s), "td,th,caption").map((S) => S.dom), b = on(Wq(e, p), (S) => n(S, u));
      return Yre(b, i, u).map((S) => S.cell);
    }, m8 = (e) => e.bottom, Xre = (e) => e.top, Zq = (e, n) => e.y < n, Gq = (e, n) => e.y > n, qq = Je(f8, m8, Zq), zP = Je(f8, Xre, Gq), VA = (e, n) => hn(n.getClientRects()).bind((s) => qq(e, s.left, s.top)).bind((s) => m0(zG(s), n)), p8 = (e, n) => Do(n.getClientRects()).bind((s) => zP(e, s.left, s.top)).bind((s) => m0(HG(s), n)), h8 = (e, n, s) => s.breakAt.exists((i) => e(n, i).breakAt.isSome()), Kq = (e) => e.breakType === wh.Wrap && e.positions.length === 0, Yq = (e) => e.breakType === wh.Br && e.positions.length === 1, UA = (e, n, s) => {
      const i = e(n, s);
      return Kq(i) || !Vs(s.getNode()) && Yq(i) ? !h8(e, n, i) : i.breakAt.isNone();
    }, Xq = Je(UA, HS), Qq = Je(UA, zS), Jq = (e, n, s) => {
      const i = gt.fromRangeStart(n);
      return Eg(!e, s).exists((u) => u.isEqual(i));
    }, eK = (e, n, s, i) => {
      const u = e.selection.getRng(), p = n ? 1 : -1;
      return iD() && Jq(n, u, s) ? (fm(p, e, s, !n, !1).each((b) => {
        Wg(e, b);
      }), !0) : !1;
    }, hm = (e, n, s) => VA(n, s).orThunk(() => hn(s.getClientRects()).bind((i) => gP(m$(e, gt.before(n)), i.left))).getOr(gt.before(n)), g8 = (e, n, s) => p8(n, s).orThunk(() => hn(s.getClientRects()).bind((i) => gP(p$(e, gt.after(n)), i.left))).getOr(gt.after(n)), VP = (e, n) => {
      const s = n.getNode(e);
      return Hu(s) ? X.some(s) : X.none();
    }, Qre = (e, n, s) => {
      n.undoManager.transact(() => {
        const i = e ? tc : Ki, u = W$(n, Me.fromDom(s), i);
        Wg(n, u);
      });
    }, tK = (e, n, s) => {
      const i = VP(!!n, s), u = n === !1;
      i.fold(() => Wg(e, s.toRange()), (p) => Eg(u, e.getBody()).filter((b) => b.isEqual(s)).fold(() => Wg(e, s.toRange()), (b) => Qre(n, e, p)));
    }, Jre = (e, n, s, i) => {
      const u = e.selection.getRng(), p = gt.fromRangeStart(u), b = e.getBody();
      if (!n && Xq(i, p)) {
        const S = hm(b, s, p);
        return tK(e, n, S), !0;
      } else if (n && Qq(i, p)) {
        const S = g8(b, s, p);
        return tK(e, n, S), !0;
      } else
        return !1;
    }, nK = (e, n, s) => X.from(e.dom.getParent(e.selection.getNode(), "td,th")).bind((i) => X.from(e.dom.getParent(i, "table")).map((u) => s(e, n, u, i))).getOr(!1), v8 = (e, n) => nK(e, n, eK), e2 = (e, n) => nK(e, n, Jre), oK = (e) => {
      const n = lb.exact(e, 0, e, 0);
      return m(n);
    }, jA = (e, n, s) => s.fold(X.none, X.none, (i, u) => HP(u).map((p) => oK(p)), (i) => (e.execCommand("mceTableInsertRowAfter"), UP(e, n, i))), UP = (e, n, s) => jA(e, n, $q(s, za)), b8 = (e, n, s) => jA(e, n, Hq(s, za)), jP = (e, n) => {
      const s = [
        "table",
        "li",
        "dl"
      ], i = Me.fromDom(e.getBody()), u = (S) => {
        const T = fs(S);
        return Bs(S, i) || Nt(s, T);
      }, p = e.selection.getRng(), b = Me.fromDom(n ? p.endContainer : p.startContainer);
      return GS(b, u).map((S) => ($P(S, u).each((j) => {
        e.model.table.clearSelectedCells(j.dom);
      }), e.selection.collapse(!n), (n ? UP : b8)(e, u, S).each((j) => {
        e.selection.setRng(j);
      }), !0)).getOr(!1);
    }, sK = (e, n, s) => {
      const i = sn.os.isMacOS() || sn.os.isiOS();
      LA([
        {
          keyCode: Qt.RIGHT,
          action: Io(Q$, e, !0)
        },
        {
          keyCode: Qt.LEFT,
          action: Io(Q$, e, !1)
        },
        {
          keyCode: Qt.UP,
          action: Io(Jx, e, !1)
        },
        {
          keyCode: Qt.DOWN,
          action: Io(Jx, e, !0)
        },
        ...i ? [
          {
            keyCode: Qt.UP,
            action: Io(Sh, e, !1),
            metaKey: !0,
            shiftKey: !0
          },
          {
            keyCode: Qt.DOWN,
            action: Io(Sh, e, !0),
            metaKey: !0,
            shiftKey: !0
          }
        ] : [],
        {
          keyCode: Qt.RIGHT,
          action: Io(v8, e, !0)
        },
        {
          keyCode: Qt.LEFT,
          action: Io(v8, e, !1)
        },
        {
          keyCode: Qt.UP,
          action: Io(e2, e, !1)
        },
        {
          keyCode: Qt.DOWN,
          action: Io(e2, e, !0)
        },
        {
          keyCode: Qt.UP,
          action: Io(e2, e, !1)
        },
        {
          keyCode: Qt.UP,
          action: Io(o8, e, !1)
        },
        {
          keyCode: Qt.DOWN,
          action: Io(o8, e, !0)
        },
        {
          keyCode: Qt.RIGHT,
          action: Io(l8, e, !0)
        },
        {
          keyCode: Qt.LEFT,
          action: Io(l8, e, !1)
        },
        {
          keyCode: Qt.UP,
          action: Io(Iq, e, !1)
        },
        {
          keyCode: Qt.DOWN,
          action: Io(Iq, e, !0)
        },
        {
          keyCode: Qt.RIGHT,
          action: Io(_$, e, n, !0)
        },
        {
          keyCode: Qt.LEFT,
          action: Io(_$, e, n, !1)
        },
        {
          keyCode: Qt.RIGHT,
          ctrlKey: !i,
          altKey: i,
          action: Io(T$, e, n)
        },
        {
          keyCode: Qt.LEFT,
          ctrlKey: !i,
          altKey: i,
          action: Io(tq, e, n)
        },
        {
          keyCode: Qt.UP,
          action: Io(e8, e, !1)
        },
        {
          keyCode: Qt.DOWN,
          action: Io(e8, e, !0)
        }
      ], s).each((u) => {
        s.preventDefault();
      });
    }, rK = (e, n) => {
      e.on("keydown", (s) => {
        s.isDefaultPrevented() || sK(e, n, s);
      });
    }, rp = (e, n) => ({
      container: e,
      offset: n
    }), WA = Kr.DOM, g0 = (e) => (n) => e === n ? -1 : 0, aK = (e) => (n) => e.isBlock(n) || Nt([
      "BR",
      "IMG",
      "HR",
      "INPUT"
    ], n.nodeName) || e.getContentEditable(n) === "false", WP = (e, n, s) => {
      if (Gt(e) && n >= 0)
        return X.some(rp(e, n));
      {
        const i = Wp(WA);
        return X.from(i.backwards(e, n, g0(e), s)).map((u) => rp(u.container, u.container.data.length));
      }
    }, iK = (e, n, s) => {
      if (Gt(e) && n >= e.length)
        return X.some(rp(e, n));
      {
        const i = Wp(WA);
        return X.from(i.forwards(e, n, g0(e), s)).map((u) => rp(u.container, 0));
      }
    }, qS = (e, n, s) => {
      if (!Gt(e))
        return X.none();
      const i = e.data;
      if (n >= 0 && n <= i.length)
        return X.some(rp(e, n));
      {
        const u = Wp(WA);
        return X.from(u.backwards(e, n, g0(e), s)).bind((p) => {
          const b = p.container.data;
          return qS(p.container, n + b.length, s);
        });
      }
    }, y8 = (e, n, s) => {
      if (!Gt(e))
        return X.none();
      const i = e.data;
      if (n <= i.length)
        return X.some(rp(e, n));
      {
        const u = Wp(WA);
        return X.from(u.forwards(e, n, g0(e), s)).bind((p) => y8(p.container, n - i.length, s));
      }
    }, ZP = (e, n, s, i, u) => {
      const p = Wp(e, aK(e));
      return X.from(p.backwards(n, s, i, u));
    }, x8 = (e) => e.collapsed && Gt(e.startContainer), lK = (e) => Qc(e.toString().replace(/\u00A0/g, " ")), w8 = (e) => e !== "" && `  \f
\r	\v`.indexOf(e) !== -1, cK = (e, n) => e.substring(n.length), uK = (e, n, s, i = !1) => {
      let u;
      const p = s.charAt(0);
      for (u = n - 1; u >= 0; u--) {
        const b = e.charAt(u);
        if (!i && w8(b))
          return X.none();
        if (p === b && Qn(e, s, u, n))
          break;
      }
      return X.some(u);
    }, GP = (e, n, s, i = !1) => {
      if (!x8(n))
        return X.none();
      const u = {
        text: "",
        offset: 0
      }, p = (S, T, M) => (u.text = M + u.text, u.offset += T, uK(u.text, u.offset, s, i).getOr(T)), b = e.getParent(n.startContainer, e.isBlock) || e.getRoot();
      return ZP(e, n.startContainer, n.startOffset, p, b).bind((S) => {
        const T = n.cloneRange();
        if (T.setStart(S.container, S.offset), T.setEnd(n.endContainer, n.endOffset), T.collapsed)
          return X.none();
        const M = lK(T);
        return M.lastIndexOf(s) !== 0 ? X.none() : X.some({
          text: cK(M, s),
          range: T,
          trigger: s
        });
      });
    }, dK = (e) => e.nodeType === If, qP = (e) => e.nodeType === wi, C8 = (e) => {
      if (dK(e))
        return rp(e, e.data.length);
      {
        const n = e.childNodes;
        return n.length > 0 ? C8(n[n.length - 1]) : rp(e, n.length);
      }
    }, KP = (e, n) => {
      const s = e.childNodes;
      return s.length > 0 && n < s.length ? KP(s[n], 0) : s.length > 0 && qP(e) && s.length === n ? C8(s[s.length - 1]) : rp(e, n);
    }, fK = (e, n) => {
      var s;
      const i = (s = e.getParent(n.container, e.isBlock)) !== null && s !== void 0 ? s : e.getRoot();
      return ZP(e, n.container, n.offset, (u, p) => p === 0 ? -1 : p, i).filter((u) => {
        const p = u.container.data.charAt(u.offset - 1);
        return !w8(p);
      }).isSome();
    }, mK = (e) => (n) => {
      const s = KP(n.startContainer, n.startOffset);
      return !fK(e, s);
    }, pK = (e, n, s) => pr(s.triggers, (i) => GP(e, n, i)), hK = (e, n) => {
      const s = n(), i = e.selection.getRng();
      return pK(e.dom, i, s).bind((u) => S8(e, n, u));
    }, S8 = (e, n, s, i = {}) => {
      var u;
      const p = n(), S = (u = e.selection.getRng().startContainer.nodeValue) !== null && u !== void 0 ? u : "", T = on(p.lookupByTrigger(s.trigger), (j) => s.text.length >= j.minChars && j.matches.getOrThunk(() => mK(e.dom))(s.range, S, s.text));
      if (T.length === 0)
        return X.none();
      const M = Promise.all(tn(T, (j) => j.fetch(s.text, j.maxResults, i).then((G) => ({
        matchText: s.text,
        items: G,
        columns: j.columns,
        onAction: j.onAction,
        highlightOn: j.highlightOn
      }))));
      return X.some({
        lookupData: M,
        context: s
      });
    };
    var ap;
    (function(e) {
      e[e.Error = 0] = "Error", e[e.Value = 1] = "Value";
    })(ap || (ap = {}));
    const pi = (e, n, s) => e.stype === ap.Error ? n(e.serror) : s(e.svalue), gK = (e) => {
      const n = [], s = [];
      return je(e, (i) => {
        pi(i, (u) => s.push(u), (u) => n.push(u));
      }), {
        values: n,
        errors: s
      };
    }, vK = (e, n) => e.stype === ap.Error ? {
      stype: ap.Error,
      serror: n(e.serror)
    } : e, bK = (e, n) => e.stype === ap.Value ? {
      stype: ap.Value,
      svalue: n(e.svalue)
    } : e, k8 = (e, n) => e.stype === ap.Value ? n(e.svalue) : e, YP = (e, n) => e.stype === ap.Error ? n(e.serror) : e, XP = (e) => ({
      stype: ap.Value,
      svalue: e
    }), Gg = (e) => ({
      stype: ap.Error,
      serror: e
    }), vl = {
      fromResult: (e) => e.fold(Gg, XP),
      toResult: (e) => pi(e, lc.error, lc.value),
      svalue: XP,
      partition: gK,
      serror: Gg,
      bind: k8,
      bindError: YP,
      map: bK,
      mapError: vK,
      fold: pi
    }, KS = (e) => ve(e) && Ms(e).length > 100 ? " removed due to size" : JSON.stringify(e, null, 2), QP = (e) => {
      const n = e.length > 10 ? e.slice(0, 10).concat([{
        path: [],
        getErrorInfo: ze("... (only showing first ten failures)")
      }]) : e;
      return tn(n, (s) => "Failed path: (" + s.path.join(" > ") + `)
` + s.getErrorInfo());
    }, YS = (e, n) => vl.serror([{
      path: e,
      getErrorInfo: n
    }]), ZA = (e, n, s) => YS(e, () => 'Could not find valid *required* value for "' + n + '" in ' + KS(s)), GA = (e, n) => YS(e, () => 'Choice schema did not contain choice key: "' + n + '"'), XS = (e, n, s) => YS(e, () => 'The chosen schema: "' + s + '" did not exist in branches: ' + KS(n)), QS = (e, n) => YS(e, ze(n)), gm = (e, n, s, i) => _s(s, i).fold(() => XS(e, s, i), (p) => p.extract(e.concat(["branch: " + i]), n)), JS = (e, n) => ({
      extract: (u, p) => _s(p, e).fold(() => GA(u, e), (S) => gm(u, p, n, S)),
      toString: () => "chooseOn(" + e + "). Possible values: " + Ms(n)
    }), E8 = (e, n) => n, T8 = (e, n) => Ze(e) && Ze(n) ? ek(e, n) : n, A8 = (e) => (...n) => {
      if (n.length === 0)
        throw new Error("Can't merge zero objects");
      const s = {};
      for (let i = 0; i < n.length; i++) {
        const u = n[i];
        for (const p in u)
          Xn(u, p) && (s[p] = e(s[p], u[p]));
      }
      return s;
    }, ek = A8(T8), O8 = A8(E8), D8 = () => ({
      tag: "required",
      process: {}
    }), tk = (e) => ({
      tag: "defaultedThunk",
      process: e
    }), R8 = (e) => tk(ze(e)), xK = () => ({
      tag: "option",
      process: {}
    }), wK = (e, n) => e.length > 0 ? vl.svalue(ek(n, O8.apply(void 0, e))) : vl.svalue(n), N8 = (e) => B(vl.serror, xs)(e), CK = {
      consolidateObj: (e, n) => {
        const s = vl.partition(e);
        return s.errors.length > 0 ? N8(s.errors) : wK(s.values, n);
      },
      consolidateArr: (e) => {
        const n = vl.partition(e);
        return n.errors.length > 0 ? N8(n.errors) : vl.svalue(n.values);
      }
    }, SK = (e, n, s, i) => ({
      tag: "field",
      key: e,
      newKey: n,
      presence: s,
      prop: i
    }), kK = (e, n) => ({
      tag: "custom",
      newKey: e,
      instantiator: n
    }), P8 = (e, n, s) => {
      switch (e.tag) {
        case "field":
          return n(e.key, e.newKey, e.presence, e.prop);
        case "custom":
          return s(e.newKey, e.instantiator);
      }
    }, JP = (e) => {
      const n = (i, u) => vl.bindError(e(u), (p) => QS(i, p)), s = ze("val");
      return {
        extract: n,
        toString: s
      };
    }, _K = JP(vl.svalue), EK = (e, n, s, i) => _s(n, s).fold(() => ZA(e, s, n), i), M8 = (e, n, s, i) => {
      const u = _s(e, n).getOrThunk(() => s(e));
      return i(u);
    }, I8 = (e, n, s) => s(_s(e, n)), F8 = (e, n, s, i) => {
      const u = _s(e, n).map((p) => p === !0 ? s(e) : p);
      return i(u);
    }, B8 = (e, n, s, i, u) => {
      const p = (S) => u.extract(n.concat([i]), S), b = (S) => S.fold(() => vl.svalue(X.none()), (T) => {
        const M = u.extract(n.concat([i]), T);
        return vl.map(M, X.some);
      });
      switch (e.tag) {
        case "required":
          return EK(n, s, i, p);
        case "defaultedThunk":
          return M8(s, i, e.process, p);
        case "option":
          return I8(s, i, b);
        case "defaultedOptionThunk":
          return F8(s, i, e.process, b);
        case "mergeWithThunk":
          return M8(s, i, ze({}), (S) => {
            const T = ek(e.process(s), S);
            return p(T);
          });
      }
    }, TK = (e, n, s) => {
      const i = {}, u = [];
      for (const p of s)
        P8(p, (b, S, T, M) => {
          const j = B8(T, e, n, b, M);
          vl.fold(j, (W) => {
            u.push(...W);
          }, (W) => {
            i[S] = W;
          });
        }, (b, S) => {
          i[b] = S(n);
        });
      return u.length > 0 ? vl.serror(u) : vl.svalue(i);
    }, eM = (e) => ({
      extract: (i, u) => TK(i, u, e),
      toString: () => `obj{
` + tn(e, (u) => P8(u, (p, b, S, T) => p + " -> " + T.toString(), (p, b) => "state(" + p + ")")).join(`
`) + "}"
    }), L8 = (e) => ({
      extract: (i, u) => {
        const p = tn(u, (b, S) => e.extract(i.concat(["[" + S + "]"]), b));
        return CK.consolidateArr(p);
      },
      toString: () => "array(" + e.toString() + ")"
    }), AK = (e) => JP((n) => e(n).fold(vl.serror, vl.svalue)), $8 = (e, n, s) => {
      const i = n.extract([e], s);
      return vl.mapError(i, (u) => ({
        input: s,
        errors: u
      }));
    }, OK = (e, n, s) => vl.toResult($8(e, n, s)), H8 = (e) => `Errors: 
` + QP(e.errors).join(`
`) + `

Input object: ` + KS(e.input), z8 = (e, n) => JS(e, Ko(n, eM)), V8 = ze(_K), nk = (e, n) => JP((s) => {
      const i = typeof s;
      return e(s) ? vl.svalue(s) : vl.serror(`Expected type: ${n} but got: ${i}`);
    }), DK = nk(Rn, "number"), qA = nk(U, "string"), RK = nk(lt, "boolean"), tM = nk(Ce, "function"), t2 = SK, U8 = kK, NK = (e) => AK((n) => Nt(e, n) ? lc.value(n) : lc.error(`Unsupported value: "${n}", choose one of "${e.join(", ")}".`)), nM = (e, n) => t2(e, e, D8(), n), j8 = (e) => nM(e, qA), W8 = (e) => nM(e, tM), Z8 = (e, n) => t2(e, e, D8(), L8(n)), oM = (e, n) => t2(e, e, xK(), n), KA = (e) => oM(e, qA), PK = (e) => oM(e, tM), G8 = (e, n) => t2(e, e, R8(n), V8()), v0 = (e, n, s) => t2(e, e, R8(n), s), q8 = (e, n) => v0(e, n, DK), MK = (e, n) => v0(e, n, qA), K8 = (e, n, s) => v0(e, n, NK(s)), sM = (e, n) => v0(e, n, RK), rM = (e, n) => v0(e, n, tM), IK = (e, n, s) => v0(e, n, L8(s)), FK = j8("type"), BK = W8("fetch"), Y8 = W8("onAction"), LK = rM("onSetup", () => ot), YA = KA("text"), X8 = KA("icon"), Q8 = KA("tooltip"), $K = KA("label"), J8 = sM("active", !1), e7 = sM("enabled", !0), t7 = sM("primary", !1), HK = (e) => G8("columns", e), ok = (e) => MK("type", e), n7 = eM([
      FK,
      j8("trigger"),
      q8("minChars", 1),
      HK(1),
      q8("maxResults", 10),
      PK("matches"),
      BK,
      Y8,
      IK("highlightOn", [], qA)
    ]), zK = (e) => OK("Autocompleter", n7, e), sk = [
      e7,
      Q8,
      X8,
      YA,
      LK
    ], o7 = [J8].concat(sk), VK = [
      rM("predicate", et),
      K8("scope", "node", [
        "node",
        "editor"
      ]),
      K8("position", "selection", [
        "node",
        "selection",
        "line"
      ])
    ], UK = sk.concat([
      ok("contextformbutton"),
      t7,
      Y8,
      U8("original", jt)
    ]), s7 = o7.concat([
      ok("contextformbutton"),
      t7,
      Y8,
      U8("original", jt)
    ]), jK = sk.concat([ok("contextformbutton")]), WK = o7.concat([ok("contextformtogglebutton")]), ZK = z8("type", {
      contextformbutton: UK,
      contextformtogglebutton: s7
    });
    eM([
      ok("contextform"),
      rM("initValue", ze("")),
      $K,
      Z8("commands", ZK),
      oM("launch", z8("type", {
        contextformbutton: jK,
        contextformtogglebutton: WK
      }))
    ].concat(VK));
    const GK = (e) => {
      const n = e.ui.registry.getAll().popups, s = Ko(n, (b) => zK(b).fold((S) => {
        throw new Error(H8(S));
      }, jt)), i = ht(xa(s, (b) => b.trigger)), u = la(s);
      return {
        dataset: s,
        triggers: i,
        lookupByTrigger: (b) => on(u, (S) => S.trigger === b)
      };
    }, qK = (e, n) => {
      const s = Up(n.load, 50);
      e.on("input", (i) => {
        i.inputType === "insertCompositionText" && !e.composing || s.throttle();
      }), e.on("keydown", (i) => {
        const u = i.which;
        u === 8 ? s.throttle() : u === 27 ? (s.cancel(), n.cancelIfNecessary()) : (u === 38 || u === 40) && s.cancel();
      }, !0), e.on("remove", s.cancel);
    }, ol = (e) => {
      const n = Ii(), s = Xe(!1), i = n.isSet, u = () => {
        i() && (zE(e), s.set(!1), n.clear());
      }, p = (W) => {
        i() || n.set({
          trigger: W.trigger,
          matchLength: W.text.length
        });
      }, b = Ct(() => GK(e)), S = (W) => n.get().map((G) => GP(e.dom, e.selection.getRng(), G.trigger, !0).bind((ue) => S8(e, b, ue, W))).getOrThunk(() => hK(e, b)), T = (W) => {
        S(W).fold(u, (G) => {
          p(G.context), G.lookupData.then((ue) => {
            n.get().map((we) => {
              const fe = G.context;
              we.trigger === fe.trigger && (n.set({
                ...we,
                matchLength: fe.text.length
              }), s.get() ? (HE(e, { range: fe.range }), IC(e, { lookupData: ue })) : (s.set(!0), HE(e, { range: fe.range }), $E(e, { lookupData: ue })));
            });
          });
        });
      }, M = (W, G) => {
        const ue = W.compareBoundaryPoints(window.Range.START_TO_START, G), we = W.compareBoundaryPoints(window.Range.END_TO_END, G);
        return ue >= 0 && we <= 0;
      }, j = () => n.get().bind(({ trigger: W }) => {
        const G = e.selection.getRng();
        return GP(e.dom, G, W, s.get()).filter(({ range: ue }) => M(G, ue)).map(({ range: ue }) => ue);
      });
      e.addCommand("mceAutocompleterReload", (W, G) => {
        const ue = ve(G) ? G.fetchOptions : {};
        T(ue);
      }), e.addCommand("mceAutocompleterClose", u), e.addCommand("mceAutocompleterRefreshActiveRange", () => {
        j().each((W) => {
          HE(e, { range: W });
        });
      }), e.editorCommands.addQueryStateHandler("mceAutoCompleterInRange", () => j().isSome()), qK(e, {
        cancelIfNecessary: u,
        load: T
      });
    }, KK = Xt().browser.isSafari(), YK = (e) => Xc(Me.fromDom(e)), r7 = (e, n) => {
      var s;
      return e.startOffset === 0 && e.endOffset === ((s = n.textContent) === null || s === void 0 ? void 0 : s.length);
    }, XA = (e, n) => X.from(e.getParent(n.container(), "details")), a7 = (e, n) => XA(e, n).isSome(), XK = (e, n) => {
      const s = X.from(e.getParent(n.startContainer, "details")), i = X.from(e.getParent(n.endContainer, "details"));
      if (s.isSome() || i.isSome()) {
        const u = s.bind((p) => X.from(e.select("summary", p)[0]));
        return X.some({
          startSummary: u,
          startDetails: s,
          endDetails: i
        });
      } else
        return X.none();
    }, i7 = (e, n) => jl(n).exists((s) => s.isEqual(e)), n2 = (e, n) => xu(n).exists((s) => Vs(s.getNode()) && eu(n, s).exists((i) => i.isEqual(e)) || s.isEqual(e)), nae = (e, n) => n.startSummary.exists((s) => i7(e, s)), QK = (e, n) => n.startSummary.exists((s) => n2(e, s)), JK = (e, n) => n.startDetails.exists((s) => eu(s, e).forall((i) => n.startSummary.exists((u) => !u.contains(e.container()) && u.contains(i.container())))), ip = (e, n, s) => s.startDetails.exists((i) => Ul(e, n).forall((u) => !i.contains(u.container()))), l7 = (e, n) => {
      const s = n.getNode();
      wt(s) || e.selection.setCursorLocation(s, n.offset());
    }, c7 = (e, n, s) => {
      const i = e.dom.getParent(n.container(), "details");
      if (i && !i.open) {
        const u = e.dom.select("summary", i)[0];
        u && (s ? jl(u) : xu(u)).each((b) => l7(e, b));
      } else
        l7(e, n);
    }, u7 = (e, n) => {
      const s = (T) => T.contains(e.startContainer), i = (T) => T.contains(e.endContainer), u = n.startSummary.exists(s), p = n.startSummary.exists(i), b = n.startDetails.forall((T) => n.endDetails.forall((M) => T !== M));
      return (u || p) && !(u && p) || b;
    }, d7 = (e, n, s) => {
      const { dom: i, selection: u } = e, p = e.getBody();
      if (s === "character") {
        const b = gt.fromRangeStart(u.getRng()), S = i.getParent(b.container(), i.isBlock), T = XA(i, b), M = S && i.isEmpty(S), j = ee(S == null ? void 0 : S.previousSibling), W = ee(S == null ? void 0 : S.nextSibling);
        return M && (n ? W : j) && Zm(!n, p, b).exists((we) => a7(i, we) && !yi(T, XA(i, we))) ? !0 : Zm(n, p, b).fold(et, (G) => {
          const ue = XA(i, G);
          if (a7(i, G) && !yi(T, ue)) {
            if (n || c7(e, G, !1), S && M) {
              if (n && j)
                return !0;
              if (!n && W)
                return !0;
              c7(e, G, n), e.dom.remove(S);
            }
            return !0;
          } else
            return !1;
        });
      } else
        return !1;
    }, aM = (e, n, s, i) => {
      const p = e.selection.getRng(), b = gt.fromRangeStart(p), S = e.getBody();
      return i === "selection" ? u7(p, n) : s ? QK(b, n) || ip(S, b, n) : nae(b, n) || JK(b, n);
    }, kh = (e, n, s) => XK(e.dom, e.selection.getRng()).fold(() => d7(e, n, s), (i) => aM(e, i, n, s) || d7(e, n, s)), f7 = (e, n, s) => {
      const i = e.selection, u = i.getNode(), p = i.getRng(), b = gt.fromRangeStart(p);
      return X2(u) ? (s === "selection" && r7(p, u) || JC(n, b, u) ? YK(u) : e.undoManager.transact(() => {
        const S = i.getSel();
        let { anchorNode: T, anchorOffset: M, focusNode: j, focusOffset: W } = S ?? {};
        const G = () => {
          Ue(T) && Ue(M) && Ue(j) && Ue(W) && (S == null || S.setBaseAndExtent(T, M, j, W));
        }, ue = () => {
          T = S == null ? void 0 : S.anchorNode, M = S == null ? void 0 : S.anchorOffset, j = S == null ? void 0 : S.focusNode, W = S == null ? void 0 : S.focusOffset;
        }, we = (ke, He) => {
          je(ke.childNodes, (Ye) => {
            sb(Ye) && He.appendChild(Ye);
          });
        }, fe = e.dom.create("span", { "data-mce-bogus": "1" });
        we(u, fe), u.appendChild(fe), G(), (s === "word" || s === "line") && (S == null || S.modify("extend", n ? "right" : "left", s)), !i.isCollapsed() && r7(i.getRng(), fe) ? YK(u) : (e.execCommand(n ? "ForwardDelete" : "Delete"), ue(), we(fe, u), G()), e.dom.remove(fe);
      }), !0) : !1;
    }, Cb = (e, n, s) => kh(e, n, s) || KK && f7(e, n, s) ? X.some(ot) : X.none(), m7 = (e) => (n, s, i = {}) => {
      const u = n.getBody(), p = {
        bubbles: !0,
        composed: !0,
        data: null,
        isComposing: !1,
        detail: 0,
        view: null,
        target: u,
        currentTarget: u,
        eventPhase: Event.AT_TARGET,
        originalTarget: u,
        explicitOriginalTarget: u,
        isTrusted: !1,
        srcElement: u,
        cancelable: !1,
        preventDefault: ot,
        inputType: s
      }, b = Td(new InputEvent(e));
      return n.dispatch(e, {
        ...b,
        ...p,
        ...i
      });
    }, Sb = m7("input"), o2 = m7("beforeinput"), iM = Xt(), lM = iM.os, p7 = lM.isMacOS() || lM.isiOS(), eY = iM.browser.isFirefox(), tY = (e, n, s) => {
      const i = s.keyCode === Qt.BACKSPACE ? "deleteContentBackward" : "deleteContentForward", u = e.selection.isCollapsed(), p = u ? "character" : "selection", b = (S) => u ? S ? "word" : "line" : "selection";
      Mq([
        {
          keyCode: Qt.BACKSPACE,
          action: Io(z$, e)
        },
        {
          keyCode: Qt.BACKSPACE,
          action: Io(uP, e, !1)
        },
        {
          keyCode: Qt.DELETE,
          action: Io(uP, e, !0)
        },
        {
          keyCode: Qt.BACKSPACE,
          action: Io(oP, e, !1)
        },
        {
          keyCode: Qt.DELETE,
          action: Io(oP, e, !0)
        },
        {
          keyCode: Qt.BACKSPACE,
          action: Io(US, e, n, !1)
        },
        {
          keyCode: Qt.DELETE,
          action: Io(US, e, n, !0)
        },
        {
          keyCode: Qt.BACKSPACE,
          action: Io(G1, e, !1)
        },
        {
          keyCode: Qt.DELETE,
          action: Io(G1, e, !0)
        },
        {
          keyCode: Qt.BACKSPACE,
          action: Io(Cb, e, !1, p)
        },
        {
          keyCode: Qt.DELETE,
          action: Io(Cb, e, !0, p)
        },
        ...p7 ? [
          {
            keyCode: Qt.BACKSPACE,
            altKey: !0,
            action: Io(Cb, e, !1, b(!0))
          },
          {
            keyCode: Qt.DELETE,
            altKey: !0,
            action: Io(Cb, e, !0, b(!0))
          },
          {
            keyCode: Qt.BACKSPACE,
            metaKey: !0,
            action: Io(Cb, e, !1, b(!1))
          }
        ] : [
          {
            keyCode: Qt.BACKSPACE,
            ctrlKey: !0,
            action: Io(Cb, e, !1, b(!0))
          },
          {
            keyCode: Qt.DELETE,
            ctrlKey: !0,
            action: Io(Cb, e, !0, b(!0))
          }
        ],
        {
          keyCode: Qt.BACKSPACE,
          action: Io(SA, e, !1)
        },
        {
          keyCode: Qt.DELETE,
          action: Io(SA, e, !0)
        },
        {
          keyCode: Qt.BACKSPACE,
          action: Io(OP, e, !1)
        },
        {
          keyCode: Qt.DELETE,
          action: Io(OP, e, !0)
        },
        {
          keyCode: Qt.BACKSPACE,
          action: Io(bA, e, !1)
        },
        {
          keyCode: Qt.DELETE,
          action: Io(bA, e, !0)
        },
        {
          keyCode: Qt.BACKSPACE,
          action: Io(FS, e, !1)
        },
        {
          keyCode: Qt.DELETE,
          action: Io(FS, e, !0)
        },
        {
          keyCode: Qt.BACKSPACE,
          action: Io(TP, e, !1)
        },
        {
          keyCode: Qt.DELETE,
          action: Io(TP, e, !0)
        },
        {
          keyCode: Qt.BACKSPACE,
          action: Io(wA, e, !1)
        },
        {
          keyCode: Qt.DELETE,
          action: Io(wA, e, !0)
        }
      ], s).filter((S) => e.selection.isEditable()).each((S) => {
        s.preventDefault(), o2(e, i).isDefaultPrevented() || (S(), Sb(e, i));
      });
    }, nY = (e, n, s) => LA([
      {
        keyCode: Qt.BACKSPACE,
        action: Io(xA, e)
      },
      {
        keyCode: Qt.DELETE,
        action: Io(xA, e)
      },
      ...p7 ? [
        {
          keyCode: Qt.BACKSPACE,
          altKey: !0,
          action: Io(ZS, e)
        },
        {
          keyCode: Qt.DELETE,
          altKey: !0,
          action: Io(ZS, e)
        },
        ...s ? [{
          keyCode: eY ? 224 : 91,
          action: Io(ZS, e)
        }] : []
      ] : [
        {
          keyCode: Qt.BACKSPACE,
          ctrlKey: !0,
          action: Io(ZS, e)
        },
        {
          keyCode: Qt.DELETE,
          ctrlKey: !0,
          action: Io(ZS, e)
        }
      ]
    ], n), h7 = (e, n) => {
      let s = !1;
      e.on("keydown", (i) => {
        s = i.keyCode === Qt.BACKSPACE, i.isDefaultPrevented() || tY(e, n, i);
      }), e.on("keyup", (i) => {
        i.isDefaultPrevented() || nY(e, i, s), s = !1;
      });
    }, oY = (e) => {
      for (; e; ) {
        if (Tn(e) || Gt(e) && e.data && /[\r\n\s]/.test(e.data))
          return e;
        e = e.nextSibling;
      }
      return null;
    }, s2 = (e, n) => {
      const s = e.dom, i = e.schema.getMoveCaretBeforeOnEnterElements();
      if (!n)
        return;
      if (/^(LI|DT|DD)$/.test(n.nodeName)) {
        const p = oY(n.firstChild);
        p && /^(UL|OL|DL)$/.test(p.nodeName) && n.insertBefore(s.doc.createTextNode(Xa), n.firstChild);
      }
      const u = s.createRng();
      if (n.normalize(), n.hasChildNodes()) {
        const p = new Pi(n, n);
        let b = n, S;
        for (; S = p.current(); ) {
          if (Gt(S)) {
            u.setStart(S, 0), u.setEnd(S, 0);
            break;
          }
          if (i[S.nodeName.toLowerCase()]) {
            u.setStartBefore(S), u.setEndBefore(S);
            break;
          }
          b = S, S = p.next();
        }
        S || (u.setStart(b, 0), u.setEnd(b, 0));
      } else
        Vs(n) ? n.nextSibling && s.isBlock(n.nextSibling) ? (u.setStartBefore(n), u.setEndBefore(n)) : (u.setStartAfter(n), u.setEndAfter(n)) : (u.setStart(n, 0), u.setEnd(n, 0));
      e.selection.setRng(u), WC(e, u);
    }, rk = (e, n) => {
      const s = e.getRoot();
      let i, u = n;
      for (; u !== s && u && e.getContentEditable(u) !== "false"; ) {
        if (e.getContentEditable(u) === "true") {
          i = u;
          break;
        }
        u = u.parentNode;
      }
      return u !== s ? i : s;
    }, cM = (e) => X.from(e.dom.getParent(e.selection.getStart(!0), e.dom.isBlock)), sY = (e) => cM(e).fold(ze(""), (n) => n.nodeName.toUpperCase()), g7 = (e) => cM(e).filter((n) => Dc(Me.fromDom(n))).isSome(), QA = (e) => {
      e.innerHTML = '<br data-mce-bogus="1">';
    }, rY = (e, n, s) => {
      const i = e.dom;
      X.from(s.style).map(i.parseStyle).each((T) => {
        const j = {
          ...fl(Me.fromDom(n)),
          ...T
        };
        i.setStyles(n, j);
      });
      const u = X.from(s.class).map((T) => T.split(/\s+/)), p = X.from(n.className).map((T) => on(T.split(/\s+/), (M) => M !== ""));
      ga(u, p, (T, M) => {
        const j = on(M, (G) => !Nt(T, G)), W = [
          ...T,
          ...j
        ];
        i.setAttrib(n, "class", W.join(" "));
      });
      const b = [
        "style",
        "class"
      ], S = ks(s, (T, M) => !Nt(b, M));
      i.setAttribs(n, S);
    }, ak = (e, n) => {
      if (Dl(e).toLowerCase() === n.tagName.toLowerCase()) {
        const i = Xp(e);
        rY(e, n, i);
      }
    }, aY = (e, n, s, i, u = !0, p, b) => {
      const S = e.dom, T = e.schema, M = Dl(e), j = s ? s.nodeName.toUpperCase() : "";
      let W = n;
      const G = T.getTextInlineElements();
      let ue;
      p || j === "TABLE" || j === "HR" ? ue = S.create(p || M, b || {}) : ue = s.cloneNode(!1);
      let we = ue;
      if (!u)
        S.setAttrib(ue, "style", null), S.setAttrib(ue, "class", null);
      else
        do
          if (G[W.nodeName]) {
            if (wu(W) || Cu(W))
              continue;
            const fe = W.cloneNode(!1);
            S.setAttrib(fe, "id", ""), ue.hasChildNodes() ? (fe.appendChild(ue.firstChild), ue.appendChild(fe)) : (we = fe, ue.appendChild(fe));
          }
        while ((W = W.parentNode) && W !== i);
      return ak(e, ue), QA(we), ue;
    }, uM = (e, n) => e.dom.getParent(n, Tc), iY = (e, n, s) => {
      let i = n;
      for (; i && i !== e && ee(i.nextSibling); ) {
        const u = i.parentElement;
        if (!u || !s(u))
          return Tc(u);
        i = u;
      }
      return !1;
    }, lY = (e, n, s) => !n && s.nodeName.toLowerCase() === Dl(e) && e.dom.isEmpty(s) && iY(e.getBody(), s, (i) => Xn(e.schema.getTextBlockElements(), i.nodeName.toLowerCase())), cY = (e, n, s) => {
      var i, u, p;
      const b = n(Dl(e)), S = uM(e, s);
      S && (e.dom.insertAfter(b, S), s2(e, b), ((p = (u = (i = s.parentElement) === null || i === void 0 ? void 0 : i.childNodes) === null || u === void 0 ? void 0 : u.length) !== null && p !== void 0 ? p : 0) > 1 && e.dom.remove(s));
    }, v7 = (e, n) => e.firstChild && e.firstChild.nodeName === n, uY = (e) => {
      var n;
      return ((n = e.parentNode) === null || n === void 0 ? void 0 : n.firstChild) === e;
    }, dM = (e, n) => {
      const s = e == null ? void 0 : e.parentNode;
      return Ue(s) && s.nodeName === n;
    }, b7 = (e) => Ue(e) && /^(OL|UL|LI)$/.test(e.nodeName), fM = (e) => Ue(e) && /^(LI|DT|DD)$/.test(e.nodeName), sae = (e) => b7(e) && b7(e.parentNode), bl = (e) => {
      const n = e.parentNode;
      return fM(n) ? n : e;
    }, JA = (e, n, s) => {
      let i = e[s ? "firstChild" : "lastChild"];
      for (; i && !Tn(i); )
        i = i[s ? "nextSibling" : "previousSibling"];
      return i === n;
    }, y7 = (e) => vt(xa(fl(Me.fromDom(e)), (n, s) => `${s}: ${n};`), (n, s) => n + s, ""), dY = (e, n, s, i, u) => {
      const p = e.dom, b = e.selection.getRng(), S = s.parentNode;
      if (s === e.getBody() || !S)
        return;
      sae(s) && (u = "LI");
      const T = fM(i) ? y7(i) : void 0;
      let M = fM(i) && T ? n(u, { style: y7(i) }) : n(u);
      if (JA(s, i, !0) && JA(s, i, !1))
        if (dM(s, "LI")) {
          const j = bl(s);
          p.insertAfter(M, j), uY(s) ? p.remove(j) : p.remove(s);
        } else
          p.replace(M, s);
      else if (JA(s, i, !0))
        dM(s, "LI") ? (p.insertAfter(M, bl(s)), M.appendChild(p.doc.createTextNode(" ")), M.appendChild(s)) : S.insertBefore(M, s), p.remove(i);
      else if (JA(s, i, !1))
        p.insertAfter(M, bl(s)), p.remove(i);
      else {
        s = bl(s);
        const j = b.cloneRange();
        j.setStartAfter(i), j.setEndAfter(s);
        const W = j.extractContents();
        if (u === "LI" && v7(W, "LI")) {
          const G = on(tn(M.children, Me.fromDom), pn(Sr("br")));
          M = W.firstChild, p.insertAfter(W, s), je(G, (ue) => Rm(Me.fromDom(M), ue)), T && M.setAttribute("style", T);
        } else
          p.insertAfter(W, s), p.insertAfter(M, s);
        p.remove(i);
      }
      s2(e, M);
    }, fY = (e) => {
      je(_l(Me.fromDom(e), ft), (n) => {
        const s = n.dom;
        s.nodeValue = Qc(s.data);
      });
    }, mY = (e, n) => {
      const s = e.dom.getParent(n, "ol,ul,dl");
      return s !== null && e.dom.getContentEditableParent(s) === "false";
    }, pY = (e, n) => n && n.nodeName === "A" && e.isEmpty(n), mM = (e, n) => e.nodeName === n || e.previousSibling && e.previousSibling.nodeName === n, r2 = (e, n) => Ue(n) && e.isBlock(n) && !/^(TD|TH|CAPTION|FORM)$/.test(n.nodeName) && !/^(fixed|absolute)/i.test(n.style.position) && e.isEditable(n.parentNode) && e.getContentEditable(n) !== "false", hY = (e, n, s) => {
      var i;
      const u = [];
      if (!s)
        return;
      let p = s;
      for (; p = p.firstChild; ) {
        if (e.isBlock(p))
          return;
        Tn(p) && !n[p.nodeName.toLowerCase()] && u.push(p);
      }
      let b = u.length;
      for (; b--; )
        p = u[b], (!p.hasChildNodes() || p.firstChild === p.lastChild && ((i = p.firstChild) === null || i === void 0 ? void 0 : i.nodeValue) === "" || pY(e, p)) && e.remove(p);
    }, pM = (e, n, s) => Gt(n) ? e ? s === 1 && n.data.charAt(s - 1) === Ma ? 0 : s : s === n.data.length - 1 && n.data.charAt(s) === Ma ? n.data.length : s : s, hM = (e) => {
      const n = e.cloneRange();
      return n.setStart(e.startContainer, pM(!0, e.startContainer, e.startOffset)), n.setEnd(e.endContainer, pM(!1, e.endContainer, e.endOffset)), n;
    }, gM = (e) => {
      let n = e;
      do
        Gt(n) && (n.data = n.data.replace(/^[\r\n]+/, "")), n = n.firstChild;
      while (n);
    }, gY = (e, n, s, i, u) => {
      var p, b;
      const S = e.dom, T = (p = rk(S, i)) !== null && p !== void 0 ? p : S.getRoot();
      let M = S.getParent(i, S.isBlock);
      if (!M || !r2(S, M)) {
        if (M = M || T, !M.hasChildNodes()) {
          const ue = S.create(n);
          return ak(e, ue), M.appendChild(ue), s.setStart(ue, 0), s.setEnd(ue, 0), ue;
        }
        let j = i;
        for (; j && j.parentNode !== M; )
          j = j.parentNode;
        let W;
        for (; j && !S.isBlock(j); )
          W = j, j = j.previousSibling;
        const G = (b = W == null ? void 0 : W.parentElement) === null || b === void 0 ? void 0 : b.nodeName;
        if (W && G && e.schema.isValidChild(G, n.toLowerCase())) {
          const ue = W.parentNode, we = S.create(n);
          for (ak(e, we), ue.insertBefore(we, W), j = W; j && !S.isBlock(j); ) {
            const fe = j.nextSibling;
            we.appendChild(j), j = fe;
          }
          s.setStart(i, u), s.setEnd(i, u);
        }
      }
      return i;
    }, rae = (e, n) => {
      n.normalize();
      const s = n.lastChild;
      (!s || Tn(s) && /^(left|right)$/gi.test(e.getStyle(s, "float", !0))) && e.add(n, "br");
    }, aae = (e, n) => {
      const s = fi(e);
      return Vt(n) ? !1 : U(s) ? Nt(Kt.explode(s), n.nodeName.toLowerCase()) : s;
    }, x7 = {
      insert: (e, n) => {
        let s, i, u, p, b = !1;
        const S = e.dom, T = e.schema, M = T.getNonEmptyElements(), j = e.selection.getRng(), W = Dl(e), G = Me.fromDom(j.startContainer), ue = vd(G, j.startOffset), we = ue.exists((Ht) => Te(Ht) && !za(Ht)), fe = j.collapsed && we, ke = (Ht, zn) => aY(e, s, an, Ut, VO(e), Ht, zn), He = (Ht) => {
          const zn = pM(Ht, s, i);
          if (Gt(s) && (Ht ? zn > 0 : zn < s.data.length))
            return !1;
          if ((s.parentNode === an || s === an) && b && !Ht || Ht && Tn(s) && s === an.firstChild)
            return !0;
          if (mM(s, "TABLE") || mM(s, "HR"))
            return b && !Ht || !b && Ht;
          const uo = new Pi(s, an);
          Gt(s) && (Ht && zn === 0 ? uo.prev() : !Ht && zn === s.data.length && uo.next());
          let Go;
          for (; Go = uo.current(); ) {
            if (Tn(Go)) {
              if (!Go.getAttribute("data-mce-bogus")) {
                const ys = Go.nodeName.toLowerCase();
                if (M[ys] && ys !== "br")
                  return !1;
              }
            } else if (Gt(Go) && !jc(Go.data))
              return !1;
            Ht ? uo.prev() : uo.next();
          }
          return !0;
        }, Ye = () => {
          let Ht;
          return /^(H[1-6]|PRE|FIGURE)$/.test(u) && Nn !== "HGROUP" ? Ht = ke(W) : Ht = ke(), aae(e, p) && r2(S, p) && S.isEmpty(an, void 0, { includeZwsp: !0 }) ? Ht = S.split(p, an) : S.insertAfter(Ht, an), s2(e, Ht), Ht;
        };
        vn(S, j).each((Ht) => {
          j.setStart(Ht.startContainer, Ht.startOffset), j.setEnd(Ht.endContainer, Ht.endOffset);
        }), s = j.startContainer, i = j.startOffset;
        const We = !!(n && n.shiftKey), ut = !!(n && n.ctrlKey);
        Tn(s) && s.hasChildNodes() && !fe && (b = i > s.childNodes.length - 1, s = s.childNodes[Math.min(i, s.childNodes.length - 1)] || s, b && Gt(s) ? i = s.data.length : i = 0);
        const Ut = rk(S, s);
        if (!Ut || mY(e, s))
          return;
        We || (s = gY(e, W, j, s, i));
        let an = S.getParent(s, S.isBlock) || S.getRoot();
        p = Ue(an == null ? void 0 : an.parentNode) ? S.getParent(an.parentNode, S.isBlock) : null, u = an ? an.nodeName.toUpperCase() : "";
        const Nn = p ? p.nodeName.toUpperCase() : "";
        if (Nn === "LI" && !ut) {
          const Ht = p;
          an = Ht, p = Ht.parentNode, u = Nn;
        }
        if (Tn(p) && lY(e, We, an))
          return cY(e, ke, an);
        if (/^(LI|DT|DD)$/.test(u) && Tn(p) && S.isEmpty(an)) {
          dY(e, ke, p, an, W);
          return;
        }
        if (!fe && (an === e.getBody() || !r2(S, an)))
          return;
        const Et = an.parentNode;
        let bt;
        if (fe)
          bt = ke(W), ue.fold(() => {
            Zr(G, Me.fromDom(bt));
          }, (Ht) => {
            Ki(Ht, Me.fromDom(bt));
          }), e.selection.setCursorLocation(bt, 0);
        else if (fg(an))
          bt = Os(an), S.isEmpty(an) && QA(an), ak(e, bt), s2(e, bt);
        else if (He(!1))
          bt = Ye();
        else if (He(!0) && Et) {
          const Ht = gt.fromRangeStart(j), zn = iR(Ht), uo = Me.fromDom(an), ys = cR(uo, Ht, e.schema) ? UF(uo, Ht, e.schema).bind((xr) => X.from(xr.getNode())) : X.none();
          bt = Et.insertBefore(ke(), an);
          const Js = mM(an, "HR") || zn ? bt : ys.getOr(an);
          s2(e, Js);
        } else {
          const Ht = hM(j).cloneRange();
          Ht.setEndAfter(an);
          const zn = Ht.extractContents();
          fY(zn), gM(zn), bt = zn.firstChild, S.insertAfter(zn, an), hY(S, M, bt), rae(S, an), S.isEmpty(an) && QA(an), bt.normalize(), S.isEmpty(bt) ? (S.remove(bt), Ye()) : (ak(e, bt), s2(e, bt));
        }
        S.setAttrib(bt, "id", ""), e.dispatch("NewBlock", { newBlock: bt });
      },
      fakeEventName: "insertParagraph"
    }, lae = (e, n, s) => {
      const i = new Pi(n, s);
      let u;
      const p = e.getNonEmptyElements();
      for (; u = i.next(); )
        if (p[u.nodeName.toLowerCase()] || Gt(u) && u.length > 0)
          return !0;
      return !1;
    }, w7 = (e, n, s) => {
      const i = e.dom.createRng();
      s ? (i.setStartBefore(n), i.setEndBefore(n)) : (i.setStartAfter(n), i.setEndAfter(n)), e.selection.setRng(i), WC(e, i);
    }, lp = (e, n) => {
      const s = e.selection, i = e.dom, u = s.getRng();
      let p, b = !1;
      vn(i, u).each((ue) => {
        u.setStart(ue.startContainer, ue.startOffset), u.setEnd(ue.endContainer, ue.endOffset);
      });
      let S = u.startOffset, T = u.startContainer;
      if (Tn(T) && T.hasChildNodes()) {
        const ue = S > T.childNodes.length - 1;
        T = T.childNodes[Math.min(S, T.childNodes.length - 1)] || T, ue && Gt(T) ? S = T.data.length : S = 0;
      }
      let M = i.getParent(T, i.isBlock);
      const j = M && M.parentNode ? i.getParent(M.parentNode, i.isBlock) : null, W = j ? j.nodeName.toUpperCase() : "", G = !!(n && n.ctrlKey);
      W === "LI" && !G && (M = j), Gt(T) && S >= T.data.length && (lae(e.schema, T, M || i.getRoot()) || (p = i.create("br"), u.insertNode(p), u.setStartAfter(p), u.setEndAfter(p), b = !0)), p = i.create("br"), d1(i, u, p), w7(e, p, b), e.undoManager.add();
    }, vY = (e, n) => {
      const s = Me.fromTag("br");
      Ki(Me.fromDom(n), s), e.undoManager.add();
    }, C7 = (e, n) => {
      yY(e.getBody(), n) || tc(Me.fromDom(n), Me.fromTag("br"));
      const s = Me.fromTag("br");
      tc(Me.fromDom(n), s), w7(e, s.dom, !1), e.undoManager.add();
    }, bY = (e) => Vs(e.getNode()), yY = (e, n) => bY(gt.after(n)) ? !0 : Ul(e, gt.after(n)).map((s) => Vs(s.getNode())).getOr(!1), S7 = (e) => e && e.nodeName === "A" && "href" in e, xY = (e) => e.fold(et, S7, S7, et), wY = (e) => {
      const n = Je(db, e), s = gt.fromRangeStart(e.selection.getRng());
      return kf(n, e.getBody(), s).filter(xY);
    }, CY = (e, n) => {
      n.fold(ot, Je(vY, e), Je(C7, e), ot);
    }, vM = {
      insert: (e, n) => {
        const s = wY(e);
        s.isSome() ? s.each(Je(CY, e)) : lp(e, n);
      },
      fakeEventName: "insertLineBreak"
    }, ik = (e, n) => cM(e).filter((s) => n.length > 0 && wl(Me.fromDom(s), n)).isSome(), SY = (e) => ik(e, Qp(e)), kY = (e) => ik(e, zO(e)), Fd = or.generate([
      { br: [] },
      { block: [] },
      { none: [] }
    ]), _Y = (e, n) => kY(e), _7 = (e) => (n, s) => g7(n) === e, bM = (e, n) => (s, i) => sY(s) === e.toUpperCase() === n, EY = (e) => {
      const n = rk(e.dom, e.selection.getStart());
      return Vt(n);
    }, a2 = (e) => bM("pre", e), E7 = () => bM("summary", !0), e3 = (e) => (n, s) => j_(n) === e, TY = (e, n) => SY(e), i2 = (e, n) => n, AY = (e) => {
      const n = Dl(e), s = rk(e.dom, e.selection.getStart());
      return Ue(s) && e.schema.isValidChild(s.nodeName, n);
    }, OY = (e) => {
      const n = e.selection.getRng(), s = Me.fromDom(n.startContainer), u = vd(s, n.startOffset).map((p) => Te(p) && !za(p));
      return n.collapsed && u.getOr(!0);
    }, Eu = (e, n) => (s, i) => vt(e, (p, b) => p && b(s, i), !0) ? X.some(n) : X.none(), DY = (e, n) => a$([
      Eu([_Y], Fd.none()),
      Eu([
        a2(!0),
        EY
      ], Fd.none()),
      Eu([E7()], Fd.br()),
      Eu([
        a2(!0),
        e3(!1),
        i2
      ], Fd.br()),
      Eu([
        a2(!0),
        e3(!1)
      ], Fd.block()),
      Eu([
        a2(!0),
        e3(!0),
        i2
      ], Fd.block()),
      Eu([
        a2(!0),
        e3(!0)
      ], Fd.br()),
      Eu([
        _7(!0),
        i2
      ], Fd.br()),
      Eu([_7(!0)], Fd.block()),
      Eu([TY], Fd.br()),
      Eu([i2], Fd.br()),
      Eu([AY], Fd.block()),
      Eu([OY], Fd.block())
    ], [
      e,
      !!(n && n.shiftKey)
    ]).getOr(Fd.none()), l2 = (e, n, s) => {
      n.selection.isCollapsed() || Cj(n), !(Ue(s) && o2(n, e.fakeEventName).isDefaultPrevented()) && (e.insert(n, s), Ue(s) && Sb(n, e.fakeEventName));
    }, t3 = (e, n) => {
      const s = () => l2(vM, e, n), i = () => l2(x7, e, n), u = DY(e, n);
      switch (_y(e)) {
        case "linebreak":
          u.fold(s, s, ot);
          break;
        case "block":
          u.fold(i, i, ot);
          break;
        case "invert":
          u.fold(i, s, ot);
          break;
        default:
          u.fold(s, i, ot);
          break;
      }
    }, yM = Xt(), RY = yM.os.isiOS() && yM.browser.isSafari(), NY = (e, n) => {
      n.isDefaultPrevented() || (n.preventDefault(), GW(e.undoManager), e.undoManager.transact(() => {
        t3(e, n);
      }));
    }, kb = (e) => {
      if (!e.collapsed)
        return !1;
      const n = e.startContainer;
      if (Gt(n)) {
        const s = /^[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF]$/, i = n.data.charAt(e.startOffset - 1);
        return s.test(i);
      } else
        return !1;
    }, PY = (e) => {
      let n = X.none();
      const s = (u) => {
        n = X.some(u.selection.getBookmark()), u.undoManager.add();
      }, i = (u, p) => {
        u.undoManager.undo(), n.fold(ot, (b) => u.selection.moveToBookmark(b)), NY(u, p), n = X.none();
      };
      e.on("keydown", (u) => {
        u.keyCode === Qt.ENTER && (RY && kb(e.selection.getRng()) ? s(e) : NY(e, u));
      }), e.on("keyup", (u) => {
        u.keyCode === Qt.ENTER && n.each(() => i(e, u));
      });
    }, MY = (e, n, s) => {
      const i = sn.os.isMacOS() || sn.os.isiOS();
      LA([
        {
          keyCode: Qt.END,
          action: Io(Ch, e, !0)
        },
        {
          keyCode: Qt.HOME,
          action: Io(Ch, e, !1)
        },
        ...i ? [] : [
          {
            keyCode: Qt.HOME,
            action: Io(Sh, e, !1),
            ctrlKey: !0,
            shiftKey: !0
          },
          {
            keyCode: Qt.END,
            action: Io(Sh, e, !0),
            ctrlKey: !0,
            shiftKey: !0
          }
        ],
        {
          keyCode: Qt.END,
          action: Io(Fq, e, !0)
        },
        {
          keyCode: Qt.HOME,
          action: Io(Fq, e, !1)
        },
        {
          keyCode: Qt.END,
          action: Io(pm, e, !0, n)
        },
        {
          keyCode: Qt.HOME,
          action: Io(pm, e, !1, n)
        }
      ], s).each((u) => {
        s.preventDefault();
      });
    }, IY = (e, n) => {
      e.on("keydown", (s) => {
        s.isDefaultPrevented() || MY(e, n, s);
      });
    }, n3 = (e) => {
      e.on("input", (n) => {
        n.isComposing || eB(e);
      });
    }, T7 = Xt(), A7 = (e, n, s) => {
      LA([
        {
          keyCode: Qt.PAGE_UP,
          action: Io(pm, e, !1, n)
        },
        {
          keyCode: Qt.PAGE_DOWN,
          action: Io(pm, e, !0, n)
        }
      ], s);
    }, O7 = (e) => e.stopImmediatePropagation(), xM = (e) => e.keyCode === Qt.PAGE_UP || e.keyCode === Qt.PAGE_DOWN, D7 = (e, n, s) => {
      s && !e.get() ? n.on("NodeChange", O7, !0) : !s && e.get() && n.off("NodeChange", O7), e.set(s);
    }, FY = (e, n) => {
      if (T7.os.isMacOS())
        return;
      const s = Xe(!1);
      e.on("keydown", (i) => {
        xM(i) && D7(s, e, !0);
      }), e.on("keyup", (i) => {
        i.isDefaultPrevented() || A7(e, n, i), xM(i) && s.get() && (D7(s, e, !1), e.nodeChanged());
      });
    }, BY = (e) => {
      e.on("beforeinput", (n) => {
        (!e.selection.isEditable() || Vn(n.getTargetRanges(), (s) => !yF(e.dom, s))) && n.preventDefault();
      });
    }, o3 = (e, n) => {
      const s = n.container(), i = n.offset();
      return Gt(s) ? (s.insertData(i, e), X.some(gt(s, i + e.length))) : Gy(n).map((u) => {
        const p = Me.fromText(e);
        return n.isAtEnd() ? tc(u, p) : Ki(u, p), gt(p.dom, e.length);
      });
    }, s3 = Je(o3, Xa), R7 = Je(o3, " "), wM = (e, n, s) => KF(e, n, s) ? s3(n) : R7(n), N7 = (e) => (n) => n.fold((s) => eu(e.dom, gt.before(s)), (s) => jl(s), (s) => xu(s), (s) => Ul(e.dom, gt.after(s))), r3 = (e, n, s) => (i) => KF(e, i, s) ? s3(n) : R7(n), CM = (e) => (n) => {
      e.selection.setRng(n.toRange()), e.nodeChanged();
    }, P7 = (e, n) => e.isEditable(e.getParent(n, "summary")), LY = (e) => {
      const n = gt.fromRangeStart(e.selection.getRng()), s = Me.fromDom(e.getBody());
      if (e.selection.isCollapsed()) {
        const i = Je(db, e), u = gt.fromRangeStart(e.selection.getRng());
        return kf(i, e.getBody(), u).bind(N7(s)).map((p) => () => r3(s, n, e.schema)(p).each(CM(e)));
      } else
        return X.none();
    }, $Y = (e) => {
      const n = () => {
        const s = Me.fromDom(e.getBody());
        e.selection.isCollapsed() || e.getDoc().execCommand("Delete");
        const i = gt.fromRangeStart(e.selection.getRng());
        wM(s, i, e.schema).each(CM(e));
      };
      return gs(sn.browser.isFirefox() && e.selection.isEditable() && P7(e.dom, e.selection.getRng().startContainer), n);
    }, a3 = (e, n) => {
      Mq([
        {
          keyCode: Qt.SPACEBAR,
          action: Io(LY, e)
        },
        {
          keyCode: Qt.SPACEBAR,
          action: Io($Y, e)
        }
      ], n).each((s) => {
        n.preventDefault(), o2(e, "insertText", { data: " " }).isDefaultPrevented() || (s(), Sb(e, "insertText", { data: " " }));
      });
    }, M7 = (e) => {
      e.on("keydown", (n) => {
        n.isDefaultPrevented() || a3(e, n);
      });
    }, HY = (e) => eD(e) ? [
      {
        keyCode: Qt.TAB,
        action: Io(jP, e, !0)
      },
      {
        keyCode: Qt.TAB,
        shiftKey: !0,
        action: Io(jP, e, !1)
      }
    ] : [], zY = (e, n) => {
      LA([...HY(e)], n).each((s) => {
        n.preventDefault();
      });
    }, I7 = (e) => {
      e.on("keydown", (n) => {
        n.isDefaultPrevented() || zY(e, n);
      });
    }, VY = (e) => {
      if (e.addShortcut("Meta+P", "", "mcePrint"), ol(e), bh(e))
        return Xe(null);
      {
        const n = eq(e);
        return BY(e), K$(e), rK(e, n), h7(e, n), PY(e), M7(e), n3(e), I7(e), IY(e, n), FY(e, n), n;
      }
    };
    class UY {
      constructor(n) {
        this.lastPath = [], this.editor = n;
        let s;
        const i = this;
        "onselectionchange" in n.getDoc() || n.on("NodeChange click mouseup keyup focus", (u) => {
          const p = n.selection.getRng(), b = {
            startContainer: p.startContainer,
            startOffset: p.startOffset,
            endContainer: p.endContainer,
            endOffset: p.endOffset
          };
          (u.type === "nodechange" || !_(b, s)) && n.dispatch("SelectionChange"), s = b;
        }), n.on("contextmenu", () => {
          ZC(n), n.dispatch("SelectionChange");
        }), n.on("SelectionChange", () => {
          const u = n.selection.getStart(!0);
          u && EC(n) && !i.isSameElementPath(u) && n.dom.isChildOf(u, n.getBody()) && n.nodeChanged({ selectionChange: !0 });
        }), n.on("mouseup", (u) => {
          !u.isDefaultPrevented() && EC(n) && (n.selection.getNode().nodeName === "IMG" ? Rd.setEditorTimeout(n, () => {
            n.nodeChanged();
          }) : n.nodeChanged());
        });
      }
      nodeChanged(n = {}) {
        const s = this.editor.selection;
        let i;
        if (this.editor.initialized && s && !Dy(this.editor) && !this.editor.mode.isReadOnly()) {
          const u = this.editor.getBody();
          i = s.getStart(!0) || u, (i.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(i, u)) && (i = u);
          const p = [];
          this.editor.dom.getParent(i, (b) => b === u ? !0 : (p.push(b), !1)), this.editor.dispatch("NodeChange", {
            ...n,
            element: i,
            parents: p
          });
        }
      }
      isSameElementPath(n) {
        let s;
        const i = this.editor, u = os(i.dom.getParents(n, xt, i.getBody()));
        if (u.length === this.lastPath.length) {
          for (s = u.length; s >= 0 && u[s] === this.lastPath[s]; s--)
            ;
          if (s === -1)
            return this.lastPath = u, !0;
        }
        return this.lastPath = u, !1;
      }
    }
    const F7 = Rv("image"), jY = (e) => {
      const n = e;
      return X.from(n[F7]);
    }, WY = (e, n) => {
      const s = e;
      s[F7] = n;
    }, i3 = Rv("event"), ZY = (e) => {
      const n = e;
      return X.from(n[i3]);
    }, lk = (e) => (n) => {
      const s = n;
      s[i3] = e;
    }, GY = (e, n) => lk(n)(e), B7 = lk(0), qY = lk(2), KY = lk(1), c2 = ((e) => (n) => {
      const s = n;
      return X.from(s[i3]).exists((i) => i === e);
    })(0), YY = () => Object.freeze({
      length: 0,
      item: (e) => null
    }), SM = Rv("mode"), L7 = (e) => {
      const n = e;
      return X.from(n[SM]);
    }, l3 = (e) => (n) => {
      const s = n;
      s[SM] = e;
    }, $7 = (e, n) => l3(n)(e), H7 = l3(0), c3 = l3(2), XY = l3(1), z7 = (e) => (n) => {
      const s = n;
      return X.from(s[SM]).exists((i) => i === e);
    }, ck = z7(0), uk = z7(1), QY = (e, n) => ({
      ...n,
      get length() {
        return n.length;
      },
      add: (s, i) => {
        if (ck(e))
          if (U(s)) {
            if (!wt(i))
              return n.add(s, i);
          } else
            return n.add(s);
        return null;
      },
      remove: (s) => {
        ck(e) && n.remove(s);
      },
      clear: () => {
        ck(e) && n.clear();
      }
    }), JY = [
      "none",
      "copy",
      "link",
      "move"
    ], eX = [
      "none",
      "copy",
      "copyLink",
      "copyMove",
      "link",
      "linkMove",
      "move",
      "all",
      "uninitialized"
    ], kM = () => {
      const e = new window.DataTransfer();
      let n = "move", s = "all";
      const i = {
        get dropEffect() {
          return n;
        },
        set dropEffect(u) {
          Nt(JY, u) && (n = u);
        },
        get effectAllowed() {
          return s;
        },
        set effectAllowed(u) {
          c2(i) && Nt(eX, u) && (s = u);
        },
        get items() {
          return QY(i, e.items);
        },
        get files() {
          return uk(i) ? YY() : e.files;
        },
        get types() {
          return e.types;
        },
        setDragImage: (u, p, b) => {
          ck(i) && (WY(i, {
            image: u,
            x: p,
            y: b
          }), e.setDragImage(u, p, b));
        },
        getData: (u) => uk(i) ? "" : e.getData(u),
        setData: (u, p) => {
          ck(i) && e.setData(u, p);
        },
        clearData: (u) => {
          ck(i) && e.clearData(u);
        }
      };
      return H7(i), i;
    }, tX = (e) => {
      const n = kM(), s = L7(e);
      return c3(e), B7(n), n.dropEffect = e.dropEffect, n.effectAllowed = e.effectAllowed, jY(e).each((i) => n.setDragImage(i.image, i.x, i.y)), je(e.types, (i) => {
        i !== "Files" && n.setData(i, e.getData(i));
      }), je(e.files, (i) => n.items.add(i)), ZY(e).each((i) => {
        GY(n, i);
      }), s.each((i) => {
        $7(e, i), $7(n, i);
      }), n;
    }, nX = (e) => {
      const n = e.getData("text/html");
      return n === "" ? X.none() : X.some(n);
    }, V7 = (e, n) => e.setData("text/html", n), U7 = "x-tinymce/html", u3 = ze(U7), _M = "<!-- " + U7 + " -->", oX = (e) => _M + e, sX = (e) => e.replace(_M, ""), j7 = (e) => e.indexOf(_M) !== -1, Wr = (e) => !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(e), rX = (e, n) => {
      let s = "<" + e;
      const i = xa(n, (u, p) => p + '="' + rf.encodeAllRaw(u) + '"');
      return i.length && (s += " " + i.join(" ")), s + ">";
    }, W7 = (e, n, s) => {
      const i = e.split(/\n\n/), u = rX(n, s), p = "</" + n + ">", b = tn(i, (T) => T.split(/\n/).join("<br />")), S = (T) => u + T + p;
      return b.length === 1 ? b[0] : tn(b, S).join("");
    }, Z7 = "%MCEPASTEBIN%", EM = (e, n) => {
      const { dom: s, selection: i } = e, u = e.getBody();
      n.set(i.getRng());
      const p = s.add(e.getBody(), "div", {
        id: "mcepastebin",
        class: "mce-pastebin",
        contentEditable: !0,
        "data-mce-bogus": "all",
        style: "position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0"
      }, Z7);
      sn.browser.isFirefox() && s.setStyle(p, "left", s.getStyle(u, "direction", !0) === "rtl" ? 65535 : -65535), s.bind(p, "beforedeactivate focusin focusout", (b) => {
        b.stopPropagation();
      }), p.focus(), i.select(p, !0);
    }, G7 = (e, n) => {
      const s = e.dom;
      if (TM(e)) {
        let i;
        const u = n.get();
        for (; i = TM(e); )
          s.remove(i), s.unbind(i);
        u && e.selection.setRng(u);
      }
      n.set(null);
    }, TM = (e) => e.dom.get("mcepastebin"), aX = (e) => Ue(e) && e.id === "mcepastebin", q7 = (e) => {
      const n = e.dom, s = (b, S) => {
        b.appendChild(S), n.remove(S, !0);
      }, [i, ...u] = on(e.getBody().childNodes, aX);
      je(u, (b) => {
        s(i, b);
      });
      const p = n.select("div[id=mcepastebin]", i);
      for (let b = p.length - 1; b >= 0; b--) {
        const S = n.create("div");
        i.insertBefore(S, p[b]), s(S, p[b]);
      }
      return i ? i.innerHTML : "";
    }, d3 = (e) => e === Z7, iX = (e) => {
      const n = Xe(null);
      return {
        create: () => EM(e, n),
        remove: () => G7(e, n),
        getEl: () => TM(e),
        getHtml: () => q7(e),
        getLastRng: n.get
      };
    }, K7 = (e, n) => (Kt.each(n, (s) => {
      oe(s, RegExp) ? e = e.replace(s, "") : e = e.replace(s[0], s[1]);
    }), e), lX = (e) => {
      const n = Gf(), s = gh({}, n);
      let i = "";
      const u = n.getVoidElements(), p = Kt.makeMap("script noscript style textarea video audio iframe object", " "), b = n.getBlockElements(), S = (T) => {
        const M = T.name, j = T;
        if (M === "br") {
          i += `
`;
          return;
        }
        if (M !== "wbr") {
          if (u[M] && (i += " "), p[M]) {
            i += " ";
            return;
          }
          if (T.type === 3 && (i += T.value), !(T.name in n.getVoidElements())) {
            let W = T.firstChild;
            if (W)
              do
                S(W);
              while (W = W.next);
          }
          b[M] && j.next && (i += `
`, M === "p" && (i += `
`));
        }
      };
      return e = K7(e, [/<!\[[^\]]+\]>/g]), S(s.parse(e)), i;
    }, AM = (e) => (e = K7(e, [
      /^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/ig,
      /<!--StartFragment-->|<!--EndFragment-->/g,
      [
        /( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g,
        (s, i, u) => !i && !u ? " " : Xa
      ],
      /<br class="Apple-interchange-newline">/g,
      /<br>$/i
    ]), e), cX = (e) => {
      let n = 0;
      return () => e + n++;
    }, uX = (e) => {
      const n = e.toLowerCase(), s = {
        jpg: "jpeg",
        jpe: "jpeg",
        jfi: "jpeg",
        jif: "jpeg",
        jfif: "jpeg",
        pjpeg: "jpeg",
        pjp: "jpeg",
        svg: "svg+xml"
      };
      return Kt.hasOwn(s, n) ? "image/" + s[n] : "image/" + n;
    }, u2 = (e, n) => {
      const s = gh({
        sanitize: By(e),
        sandbox_iframes: Ly(e),
        sandbox_iframes_exclusions: $y(e),
        convert_unsafe_embeds: nD(e)
      }, e.schema);
      s.addNodeFilter("meta", (u) => {
        Kt.each(u, (p) => {
          p.remove();
        });
      });
      const i = s.parse(n, {
        forced_root_block: !1,
        isRootContent: !0
      });
      return Ig({ validate: !0 }, e.schema).serialize(i);
    }, Y7 = (e, n) => ({
      content: e,
      cancelled: n
    }), d2 = (e, n, s) => {
      const i = e.dom.create("div", { style: "display:none" }, n), u = RD(e, i, s);
      return Y7(u.node.innerHTML, u.isDefaultPrevented());
    }, dk = (e, n, s) => {
      const i = DD(e, n, s), u = u2(e, i.content);
      return e.hasEventListeners("PastePostProcess") && !i.isDefaultPrevented() ? d2(e, u, s) : Y7(u, i.isDefaultPrevented());
    }, dX = (e, n, s) => dk(e, n, s), OM = (e, n) => (e.insertContent(n, {
      merge: rE(e),
      paste: !0
    }), !0), _b = (e) => /^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(e), fX = (e, n) => _b(n) && Vn(x1(e), (s) => Jo(n.toLowerCase(), `.${s.toLowerCase()}`)), DM = (e, n, s) => (e.undoManager.extra(() => {
      s(e, n);
    }, () => {
      e.insertContent('<img src="' + n + '">');
    }), !0), mX = (e, n, s) => (e.undoManager.extra(() => {
      s(e, n);
    }, () => {
      e.execCommand("mceInsertLink", !1, n);
    }), !0), X7 = (e, n, s) => !e.selection.isCollapsed() && _b(n) ? mX(e, n, s) : !1, Q7 = (e, n, s) => fX(e, n) ? DM(e, n, s) : !1, RM = (e, n) => {
      Kt.each([
        X7,
        Q7,
        OM
      ], (s) => !s(e, n, OM));
    }, J7 = (e, n, s) => {
      s || !aE(e) ? OM(e, n) : RM(e, n);
    }, pX = cX("mceclip"), hX = (e) => {
      const n = kM();
      return V7(n, e), c3(n), n;
    }, NM = (e, n, s, i, u) => {
      const p = dX(e, n, s);
      if (!p.cancelled) {
        const b = p.content, S = () => J7(e, b, i);
        u ? o2(e, "insertFromPaste", { dataTransfer: hX(b) }).isDefaultPrevented() || (S(), Sb(e, "insertFromPaste")) : S();
      }
    }, f3 = (e, n, s, i) => {
      const u = s || j7(n);
      NM(e, sX(n), u, !1, i);
    }, m3 = (e, n, s) => {
      const i = e.dom.encode(n).replace(/\r\n/g, `
`), u = pu(i, Py(e)), p = W7(u, Dl(e), Xp(e));
      NM(e, p, !1, !0, s);
    }, p3 = (e) => {
      const n = {};
      if (e && e.types)
        for (let s = 0; s < e.types.length; s++) {
          const i = e.types[s];
          try {
            n[i] = e.getData(i);
          } catch {
            n[i] = "";
          }
        }
      return n;
    }, Kg = (e, n) => n in e && e[n].length > 0, eH = (e) => Kg(e, "text/html") || Kg(e, "text/plain"), gX = (e, n) => {
      const s = n.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
      return Ue(s) ? e.dom.encode(s[1]) : void 0;
    }, vX = (e, n, s, i) => {
      const u = pX(), p = mi(e) && Ue(s.name), b = p ? gX(e, s.name) : u, S = p ? s.name : void 0, T = n.create(u, s, i, b, S);
      return n.add(T), T;
    }, tH = (e, n) => {
      cN(n.uri).each(({ data: s, type: i, base64Encoded: u }) => {
        const p = u ? s : btoa(s), b = n.file, S = e.editorUpload.blobCache, T = S.getByData(p, i), M = T ?? vX(e, S, b, p);
        f3(e, `<img src="${M.blobUri()}">`, !1, !0);
      });
    }, PM = (e) => e.type === "paste", bX = (e) => Promise.all(tn(e, (n) => uL(n).then((s) => ({
      file: n,
      uri: s
    })))), nH = (e) => {
      const n = x1(e);
      return (s) => co(s.type, "image/") && Vn(n, (i) => uX(i) === s.type);
    }, oH = (e, n) => {
      const s = n.items ? rs(Ss(n.items), (u) => u.kind === "file" ? [u.getAsFile()] : []) : [], i = n.files ? Ss(n.files) : [];
      return on(s.length > 0 ? s : i, nH(e));
    }, sH = (e, n, s) => {
      const i = PM(n) ? n.clipboardData : n.dataTransfer;
      if (y1(e) && i) {
        const u = oH(e, i);
        if (u.length > 0)
          return n.preventDefault(), bX(u).then((p) => {
            s && e.selection.setRng(s), je(p, (b) => {
              tH(e, b);
            });
          }), !0;
      }
      return !1;
    }, rH = (e) => {
      var n, s;
      return sn.os.isAndroid() && ((s = (n = e.clipboardData) === null || n === void 0 ? void 0 : n.items) === null || s === void 0 ? void 0 : s.length) === 0;
    }, yX = (e) => Qt.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45, MM = (e, n, s, i, u) => {
      let p = AM(s);
      const b = Kg(n, u3()) || j7(s), S = !b && Wr(p), T = _b(p);
      (d3(p) || !p.length || S && !T) && (i = !0), (i || T) && (Kg(n, "text/plain") && S ? p = n["text/plain"] : p = lX(p)), !d3(p) && (i ? m3(e, p, u) : f3(e, p, b, u));
    }, xX = (e, n, s) => {
      let i;
      const u = () => n.getLastRng() || e.selection.getRng();
      e.on("keydown", (p) => {
        yX(p) && !p.isDefaultPrevented() && (i = p.shiftKey && p.keyCode === 86);
      }), e.on("paste", (p) => {
        if (p.isDefaultPrevented() || rH(p))
          return;
        const b = s.get() === "text" || i;
        i = !1;
        const S = p3(p.clipboardData);
        !eH(S) && sH(e, p, u()) || (Kg(S, "text/html") ? (p.preventDefault(), MM(e, S, S["text/html"], b, !0)) : Kg(S, "text/plain") && Kg(S, "text/uri-list") ? (p.preventDefault(), MM(e, S, S["text/plain"], b, !0)) : (n.create(), Rd.setEditorTimeout(e, () => {
          const T = n.getHtml();
          n.remove(), MM(e, S, T, b, !1);
        }, 0)));
      });
    }, wX = (e) => {
      const n = (u) => co(u, "webkit-fake-url"), s = (u) => co(u, "data:"), i = (u) => {
        var p;
        return ((p = u.data) === null || p === void 0 ? void 0 : p.paste) === !0;
      };
      e.parser.addNodeFilter("img", (u, p, b) => {
        if (!y1(e) && i(b))
          for (const S of u) {
            const T = S.attr("src");
            U(T) && !S.attr("data-mce-object") && T !== sn.transparentSrc && (n(T) || !jv(e) && s(T)) && S.remove();
          }
      });
    }, CX = (e, n, s) => {
      xX(e, n, s), wX(e);
    }, h3 = (e, n) => {
      n.get() === "text" ? (n.set("html"), hx(e, !1)) : (n.set("text"), hx(e, !0)), e.focus();
    }, SX = (e, n) => {
      e.addCommand("mceTogglePlainTextPaste", () => {
        h3(e, n);
      }), e.addCommand("mceInsertClipboardContent", (s, i) => {
        i.html && f3(e, i.html, i.internal, !1), i.text && m3(e, i.text, !1);
      });
    }, aH = (e, n, s) => {
      if (e)
        try {
          return e.clearData(), e.setData("text/html", n), e.setData("text/plain", s), e.setData(u3(), n), !0;
        } catch {
          return !1;
        }
      else
        return !1;
    }, iH = (e, n, s, i) => {
      aH(e.clipboardData, n.html, n.text) ? (e.preventDefault(), i()) : s(n.html, i);
    }, lH = (e) => (n, s) => {
      const { dom: i, selection: u } = e, p = i.create("div", {
        contenteditable: "false",
        "data-mce-bogus": "all"
      }), b = i.create("div", { contenteditable: "true" }, n);
      i.setStyles(p, {
        position: "fixed",
        top: "0",
        left: "-3000px",
        width: "1000px",
        overflow: "hidden"
      }), p.appendChild(b), i.add(e.getBody(), p);
      const S = u.getRng();
      b.focus();
      const T = i.createRng();
      T.selectNodeContents(b), u.setRng(T), Rd.setEditorTimeout(e, () => {
        u.setRng(S), i.remove(p), s();
      }, 0);
    }, IM = (e) => ({
      html: oX(e.selection.getContent({ contextual: !0 })),
      text: e.selection.getContent({ format: "text" })
    }), cH = (e) => !!e.dom.getParent(e.selection.getStart(), "td[data-mce-selected],th[data-mce-selected]", e.getBody()), uH = (e) => !e.selection.isCollapsed() || cH(e), kX = (e) => (n) => {
      !n.isDefaultPrevented() && uH(e) && e.selection.isEditable() && iH(n, IM(e), lH(e), () => {
        if (sn.browser.isChromium() || sn.browser.isFirefox()) {
          const s = e.selection.getRng();
          Rd.setEditorTimeout(e, () => {
            e.selection.setRng(s), e.execCommand("Delete");
          }, 0);
        } else
          e.execCommand("Delete");
      });
    }, _X = (e) => (n) => {
      !n.isDefaultPrevented() && uH(e) && iH(n, IM(e), lH(e), ot);
    }, EX = (e) => {
      e.on("cut", kX(e)), e.on("copy", _X(e));
    }, dH = (e, n) => {
      var s, i;
      return Wt.getCaretRangeFromPoint((s = n.clientX) !== null && s !== void 0 ? s : 0, (i = n.clientY) !== null && i !== void 0 ? i : 0, e.getDoc());
    }, fH = (e) => {
      const n = e["text/plain"];
      return n ? n.indexOf("file://") === 0 : !1;
    }, mH = (e, n) => {
      e.focus(), n && e.selection.setRng(n);
    }, TX = (e) => Vn(e.files, (n) => /^image\//.test(n.type)), AX = (e, n, s, i) => {
      const u = e.getParent(s, (b) => Uu(n, b));
      if (!ee(e.getParent(s, "summary")))
        return !0;
      if (u && Xn(i, "text/html")) {
        const b = new DOMParser().parseFromString(i["text/html"], "text/html").body;
        return !ee(b.querySelector(u.nodeName.toLowerCase()));
      } else
        return !1;
    }, OX = (e) => {
      e.on("input", (n) => {
        const s = (i) => ee(i.querySelector("summary"));
        if (n.inputType === "deleteByDrag") {
          const i = on(e.dom.select("details"), s);
          je(i, (u) => {
            Vs(u.firstChild) && u.firstChild.remove();
            const p = e.dom.create("summary");
            p.appendChild(ug().dom), u.prepend(p);
          });
        }
      });
    }, DX = (e, n) => {
      tC(e) && e.on("dragend dragover draggesture dragdrop drop drag", (s) => {
        s.preventDefault(), s.stopPropagation();
      }), y1(e) || e.on("drop", (s) => {
        const i = s.dataTransfer;
        i && TX(i) && s.preventDefault();
      }), e.on("drop", (s) => {
        if (s.isDefaultPrevented())
          return;
        const i = dH(e, s);
        if (Vt(i))
          return;
        const u = p3(s.dataTransfer), p = Kg(u, u3());
        if ((!eH(u) || fH(u)) && sH(e, s, i))
          return;
        const b = u[u3()], S = b || u["text/html"] || u["text/plain"], T = AX(e.dom, e.schema, i.startContainer, u), M = n.get();
        M && !T || S && (s.preventDefault(), Rd.setEditorTimeout(e, () => {
          e.undoManager.transact(() => {
            (b || M && T) && e.execCommand("Delete"), mH(e, i);
            const j = AM(S);
            u["text/html"] ? f3(e, j, p, !0) : m3(e, j, !0);
          });
        }));
      }), e.on("dragstart", (s) => {
        n.set(!0);
      }), e.on("dragover dragend", (s) => {
        y1(e) && !n.get() && (s.preventDefault(), mH(e, dH(e, s))), s.type === "dragend" && n.set(!1);
      }), OX(e);
    }, RX = (e) => {
      const n = (u) => (p) => {
        u(e, p);
      }, s = nC(e);
      Ce(s) && e.on("PastePreProcess", n(s));
      const i = nE(e);
      Ce(i) && e.on("PastePostProcess", n(i));
    }, NX = (e, n) => {
      e.on("PastePreProcess", (s) => {
        s.content = n(e, s.content, s.internal);
      });
    }, PX = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi, FM = (e) => Kt.trim(e).replace(PX, lf).toLowerCase(), pH = (e, n, s) => {
      const i = sE(e);
      if (s || i === "all" || !YO(e))
        return n;
      const u = i ? i.split(/[, ]/) : [];
      if (u && i !== "none") {
        const p = e.dom, b = e.selection.getNode();
        n = n.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, (S, T, M, j) => {
          const W = p.parseStyle(p.decode(M)), G = {};
          for (let we = 0; we < u.length; we++) {
            const fe = W[u[we]];
            let ke = fe, He = p.getStyle(b, u[we], !0);
            /color/.test(u[we]) && (ke = FM(ke), He = FM(He)), He !== ke && (G[u[we]] = fe);
          }
          const ue = p.serializeStyle(G, "span");
          return ue ? T + ' style="' + ue + '"' + j : T + j;
        });
      } else
        n = n.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, "$1$3");
      return n = n.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, (p, b, S, T) => b + ' style="' + S + '"' + T), n;
    }, MX = (e) => {
      (sn.browser.isChromium() || sn.browser.isSafari()) && NX(e, pH);
    }, IX = (e) => {
      const n = Xe(!1), s = Xe(iE(e) ? "text" : "html"), i = iX(e);
      MX(e), SX(e, s), RX(e), e.addQueryStateHandler("mceTogglePlainTextPaste", () => s.get() === "text"), e.on("PreInit", () => {
        EX(e), DX(e, n), CX(e, i, s);
      });
    }, FX = (e) => {
      e.on("click", (n) => {
        e.dom.getParent(n.target, "details") && n.preventDefault();
      });
    }, BX = (e) => {
      e.parser.addNodeFilter("details", (n) => {
        const s = tD(e);
        je(n, (i) => {
          s === "expanded" ? i.attr("open", "open") : s === "collapsed" && i.attr("open", null);
        });
      }), e.serializer.addNodeFilter("details", (n) => {
        const s = cE(e);
        je(n, (i) => {
          s === "expanded" ? i.attr("open", "open") : s === "collapsed" && i.attr("open", null);
        });
      });
    }, LX = (e) => {
      FX(e), BX(e);
    }, $X = Vs, hH = Gt, g3 = (e) => Ls(e.dom), gH = (e) => Mt(e.dom), vH = (e) => (n) => Bs(Me.fromDom(e), n), bH = (e, n, s) => sa(Me.fromDom(e), (i) => gH(i) || s.isBlock(fs(i)), vH(n)).getOr(Me.fromDom(n)).dom, BM = (e, n) => sa(Me.fromDom(e), g3, vH(n)), v3 = (e, n, s) => {
      const i = new Pi(e, n), u = s ? i.next.bind(i) : i.prev.bind(i);
      let p = e;
      for (let b = s ? e : u(); b && !$X(b); b = u())
        mf(b) && (p = b);
      return p;
    }, HX = (e, n, s) => {
      const u = gt.fromRangeStart(e).getNode(), p = bH(u, n, s), b = v3(u, p, !1), S = v3(u, p, !0), T = document.createRange();
      return BM(b, p).fold(() => {
        hH(b) ? T.setStart(b, 0) : T.setStartBefore(b);
      }, (M) => T.setStartBefore(M.dom)), BM(S, p).fold(() => {
        hH(S) ? T.setEnd(S, S.data.length) : T.setEndAfter(S);
      }, (M) => T.setEndAfter(M.dom)), T;
    }, yH = (e) => {
      const n = HX(e.selection.getRng(), e.getBody(), e.schema);
      e.selection.setRng(jr(n));
    }, zX = (e) => {
      e.on("mousedown", (n) => {
        n.detail >= 3 && (n.preventDefault(), yH(e));
      });
    };
    var b0;
    (function(e) {
      e.Before = "before", e.After = "after";
    })(b0 || (b0 = {}));
    const VX = (e, n) => Math.abs(e.left - n), xH = (e, n) => Math.abs(e.right - n), UX = (e, n) => e >= n.top && e <= n.bottom, jX = (e, n) => e.top < n.bottom && e.bottom > n.top, WX = (e, n) => {
      const s = CO(e, n) / Math.min(e.height, n.height);
      return jX(e, n) && s > 0.5;
    }, fk = (e, n) => {
      const s = on(e, (i) => UX(n, i));
      return ma(s).fold(() => [
        [],
        e
      ], (i) => {
        const {
          pass: u,
          fail: p
        } = qn(e, (b) => WX(b, i));
        return [
          u,
          p
        ];
      });
    }, ZX = (e, n) => ({
      node: e.node,
      position: VX(e, n) < xH(e, n) ? b0.Before : b0.After
    }), GX = (e, n, s) => n > e.left && n < e.right ? 0 : Math.min(Math.abs(e.left - n), Math.abs(e.right - n)), b3 = (e, n, s, i) => {
      const u = (W) => mf(W.node) ? X.some(W) : Tn(W.node) ? b3(Ss(W.node.childNodes), n, s, !1) : X.none(), p = (W, G, ue) => u(G).filter((we) => Math.abs(ue(W, n, s) - ue(we, n, s)) < 2 && Gt(we.node)), b = (W, G) => {
        const ue = kt(W, (we, fe) => G(we, n, s) - G(fe, n, s));
        return pr(ue, u).map((we) => i && !Gt(we.node) && ue.length > 1 ? p(we, ue[1], G).getOr(we) : we);
      }, [S, T] = fk(b$(e), s), {
        pass: M,
        fail: j
      } = qn(T, (W) => W.top < s);
      return b(S, GX).orThunk(() => b(j, Cw)).orThunk(() => b(M, Cw));
    }, qX = (e, n, s, i) => {
      const u = (p, b) => {
        const S = (M) => Tn(M) && M.classList.contains("mce-drag-container"), T = on(p.dom.childNodes, pn(S));
        return b.fold(() => b3(T, s, i, !0), (M) => {
          const j = on(T, (W) => W !== M.dom);
          return b3(j, s, i, !0);
        }).orThunk(() => (Bs(p, e) ? X.none() : Hc(p)).bind((j) => u(j, X.some(p))));
      };
      return u(n, X.none());
    }, KX = (e, n, s) => {
      const i = Me.fromDom(e), u = Ka(i), b = Me.fromPoint(u, n, s).filter((S) => Gi(i, S)).getOr(i);
      return qX(i, b, n, s);
    }, wH = (e, n, s) => KX(e, n, s).filter((i) => Um(i.node)).map((i) => ZX(i, n)), CH = (e) => {
      var n, s;
      const i = e.getBoundingClientRect(), u = e.ownerDocument, p = u.documentElement, b = u.defaultView;
      return {
        top: i.top + ((n = b == null ? void 0 : b.scrollY) !== null && n !== void 0 ? n : 0) - p.clientTop,
        left: i.left + ((s = b == null ? void 0 : b.scrollX) !== null && s !== void 0 ? s : 0) - p.clientLeft
      };
    }, YX = (e) => e.inline ? CH(e.getBody()) : {
      left: 0,
      top: 0
    }, y3 = (e) => {
      const n = e.getBody();
      return e.inline ? {
        left: n.scrollLeft,
        top: n.scrollTop
      } : {
        left: 0,
        top: 0
      };
    }, SH = (e) => {
      const n = e.getBody(), s = e.getDoc().documentElement, i = {
        left: n.scrollLeft,
        top: n.scrollTop
      }, u = {
        left: n.scrollLeft || s.scrollLeft,
        top: n.scrollTop || s.scrollTop
      };
      return e.inline ? i : u;
    }, kH = (e, n) => {
      if (n.target.ownerDocument !== e.getDoc()) {
        const s = CH(e.getContentAreaContainer()), i = SH(e);
        return {
          left: n.pageX - s.left + i.left,
          top: n.pageY - s.top + i.top
        };
      }
      return {
        left: n.pageX,
        top: n.pageY
      };
    }, XX = (e, n, s) => ({
      pageX: s.left - e.left + n.left,
      pageY: s.top - e.top + n.top
    }), QX = (e, n) => XX(YX(e), y3(e), kH(e, n)), _H = (e) => ({
      target: e,
      srcElement: e
    }), dae = (e, n, s, i) => ({
      ...n,
      dataTransfer: i,
      type: e,
      ..._H(s)
    }), JX = (e, n, s) => {
      const i = Ro("Function not supported on simulated event.");
      return {
        bubbles: !0,
        cancelBubble: !1,
        cancelable: !0,
        composed: !1,
        currentTarget: null,
        defaultPrevented: !1,
        eventPhase: 0,
        isTrusted: !0,
        returnValue: !1,
        timeStamp: 0,
        type: e,
        composedPath: i,
        initEvent: i,
        preventDefault: ot,
        stopImmediatePropagation: ot,
        stopPropagation: ot,
        AT_TARGET: window.Event.AT_TARGET,
        BUBBLING_PHASE: window.Event.BUBBLING_PHASE,
        CAPTURING_PHASE: window.Event.CAPTURING_PHASE,
        NONE: window.Event.NONE,
        altKey: !1,
        button: 0,
        buttons: 0,
        clientX: 0,
        clientY: 0,
        ctrlKey: !1,
        metaKey: !1,
        movementX: 0,
        movementY: 0,
        offsetX: 0,
        offsetY: 0,
        pageX: 0,
        pageY: 0,
        relatedTarget: null,
        screenX: 0,
        screenY: 0,
        shiftKey: !1,
        x: 0,
        y: 0,
        detail: 0,
        view: null,
        which: 0,
        initUIEvent: i,
        initMouseEvent: i,
        getModifierState: i,
        dataTransfer: s,
        ..._H(n)
      };
    }, EH = (e, n) => {
      const s = tX(e);
      return n === "dragstart" ? (B7(s), H7(s)) : n === "drop" ? (qY(s), c3(s)) : (KY(s), XY(s)), s;
    }, LM = (e, n, s, i) => {
      const u = EH(s, e);
      return wt(i) ? JX(e, n, u) : dae(e, i, n, u);
    }, y0 = 32, eQ = 100, x3 = 8, mk = 16, TH = Ls, $M = Sw(TH, Mt), AH = (e, n, s) => TH(s) && s !== n && e.isEditable(s.parentElement), tQ = (e, n, s) => Vt(n) || n === s || e.dom.isChildOf(n, s) ? !1 : e.dom.isEditable(n), nQ = (e, n, s, i) => {
      const u = e.dom, p = n.cloneNode(!0);
      u.setStyles(p, {
        width: s,
        height: i
      }), u.setAttrib(p, "data-mce-selected", null);
      const b = u.create("div", {
        class: "mce-drag-container",
        "data-mce-bogus": "all",
        unselectable: "on",
        contenteditable: "false"
      });
      return u.setStyles(b, {
        position: "absolute",
        opacity: 0.5,
        overflow: "hidden",
        border: 0,
        padding: 0,
        margin: 0,
        width: s,
        height: i
      }), u.setStyles(p, {
        margin: 0,
        boxSizing: "border-box"
      }), b.appendChild(p), b;
    }, OH = (e, n) => {
      e.parentNode !== n && n.appendChild(e);
    }, w3 = (e, n) => (s) => () => {
      const i = e === "left" ? s.scrollX : s.scrollY;
      s.scroll({
        [e]: i + n,
        behavior: "smooth"
      });
    }, oQ = w3("left", -y0), DH = w3("left", y0), RH = w3("top", -y0), NH = w3("top", y0), PH = (e, n, s, i, u, p, b, S, T, M, j, W) => {
      let G = 0, ue = 0;
      e.style.left = n.pageX + "px", e.style.top = n.pageY + "px", n.pageX + s > u && (G = n.pageX + s - u), n.pageY + i > p && (ue = n.pageY + i - p), e.style.width = s - G + "px", e.style.height = i - ue + "px";
      const we = T.clientHeight, fe = T.clientWidth, ke = b + T.getBoundingClientRect().top, He = S + T.getBoundingClientRect().left;
      j.on((Ye) => {
        Ye.intervalId.clear(), Ye.dragging && W && (b + x3 >= we ? Ye.intervalId.set(NH(M)) : b - x3 <= 0 ? Ye.intervalId.set(RH(M)) : S + x3 >= fe ? Ye.intervalId.set(DH(M)) : S - x3 <= 0 ? Ye.intervalId.set(oQ(M)) : ke + mk >= window.innerHeight ? Ye.intervalId.set(NH(window)) : ke - mk <= 0 ? Ye.intervalId.set(RH(window)) : He + mk >= window.innerWidth ? Ye.intervalId.set(DH(window)) : He - mk <= 0 && Ye.intervalId.set(oQ(window)));
      });
    }, MH = (e) => {
      e && e.parentNode && e.parentNode.removeChild(e);
    }, IH = (e, n) => {
      const s = e.getParent(n.parentNode, e.isBlock);
      MH(n), s && s !== e.getRoot() && e.isEmpty(s) && Xc(Me.fromDom(s));
    }, sQ = (e) => e.button === 0, rQ = (e, n) => ({
      pageX: n.pageX - e.relX,
      pageY: n.pageY + 5
    }), aQ = (e, n) => (s) => {
      if (sQ(s)) {
        const i = Dn(n.dom.getParents(s.target), $M).getOr(null);
        if (Ue(i) && AH(n.dom, n.getBody(), i)) {
          const u = n.dom.getPos(i), p = n.getBody(), b = n.getDoc().documentElement;
          e.set({
            element: i,
            dataTransfer: kM(),
            dragging: !1,
            screenX: s.screenX,
            screenY: s.screenY,
            maxX: (n.inline ? p.scrollWidth : b.offsetWidth) - 2,
            maxY: (n.inline ? p.scrollHeight : b.offsetHeight) - 2,
            relX: s.pageX - u.x,
            relY: s.pageY - u.y,
            width: i.offsetWidth,
            height: i.offsetHeight,
            ghost: nQ(n, i, i.offsetWidth, i.offsetHeight),
            intervalId: Ip(eQ)
          });
        }
      }
    }, iQ = (e, n, s) => {
      e._selectionOverrides.hideFakeCaret(), wH(e.getBody(), n, s).fold(() => e.selection.placeCaretAt(n, s), (i) => {
        const u = e._selectionOverrides.showCaret(1, i.node, i.position === b0.Before, !1);
        u ? e.selection.setRng(u) : e.selection.placeCaretAt(n, s);
      });
    }, pk = (e, n, s, i, u) => {
      n === "dragstart" && V7(i, e.dom.getOuterHTML(s));
      const p = LM(n, s, i, u);
      return e.dispatch(n, p);
    }, FH = (e, n) => {
      const s = n1((u, p) => iQ(n, u, p), 0);
      n.on("remove", s.cancel);
      const i = e;
      return (u) => e.on((p) => {
        const b = Math.max(Math.abs(u.screenX - p.screenX), Math.abs(u.screenY - p.screenY));
        if (!p.dragging && b > 10) {
          const S = pk(n, "dragstart", p.element, p.dataTransfer, u);
          if (Ue(S.dataTransfer) && (p.dataTransfer = S.dataTransfer), S.isDefaultPrevented())
            return;
          p.dragging = !0, n.focus();
        }
        if (p.dragging) {
          const S = u.currentTarget === n.getDoc().documentElement, T = rQ(p, QX(n, u));
          OH(p.ghost, n.getBody()), PH(p.ghost, T, p.width, p.height, p.maxX, p.maxY, u.clientY, u.clientX, n.getContentAreaContainer(), n.getWin(), i, S), s.throttle(u.clientX, u.clientY);
        }
      });
    }, fae = (e) => {
      const n = e.getSel();
      if (Ue(n)) {
        const i = n.getRangeAt(0).startContainer;
        return Gt(i) ? i.parentNode : i;
      } else
        return null;
    }, lQ = (e, n) => (s) => {
      e.on((i) => {
        var u;
        if (i.intervalId.clear(), i.dragging) {
          if (tQ(n, fae(n.selection), i.element)) {
            const p = (u = n.getDoc().elementFromPoint(s.clientX, s.clientY)) !== null && u !== void 0 ? u : n.getBody();
            pk(n, "drop", p, i.dataTransfer, s).isDefaultPrevented() || n.undoManager.transact(() => {
              IH(n.dom, i.element), nX(i.dataTransfer).each((S) => n.insertContent(S)), n._selectionOverrides.hideFakeCaret();
            });
          }
          pk(n, "dragend", n.getBody(), i.dataTransfer, s);
        }
      }), C3(e);
    }, HM = (e, n, s) => {
      e.on((i) => {
        i.intervalId.clear(), i.dragging && s.fold(() => pk(n, "dragend", i.element, i.dataTransfer), (u) => pk(n, "dragend", i.element, i.dataTransfer, u));
      }), C3(e);
    }, cQ = (e, n) => (s) => HM(e, n, X.some(s)), C3 = (e) => {
      e.on((n) => {
        n.intervalId.clear(), MH(n.ghost);
      }), e.clear();
    }, uQ = (e) => {
      const n = Ii(), s = Kr.DOM, i = document, u = aQ(n, e), p = FH(n, e), b = lQ(n, e), S = cQ(n, e);
      e.on("mousedown", u), e.on("mousemove", p), e.on("mouseup", b), s.bind(i, "mousemove", p), s.bind(i, "mouseup", S), e.on("remove", () => {
        s.unbind(i, "mousemove", p), s.unbind(i, "mouseup", S);
      }), e.on("keydown", (T) => {
        T.keyCode === Qt.ESC && HM(n, e, X.none());
      });
    }, dQ = (e) => {
      const n = (u) => {
        if (!u.isDefaultPrevented()) {
          const p = u.dataTransfer;
          p && (Nt(p.types, "Files") || p.files.length > 0) && (u.preventDefault(), u.type === "drop" && mA(e, "Dropped file type is not supported"));
        }
      }, s = (u) => {
        eT(e, u.target) && n(u);
      }, i = () => {
        const u = Kr.DOM, p = e.dom, b = document, S = e.inline ? e.getBody() : e.getDoc(), T = [
          "drop",
          "dragover"
        ];
        je(T, (M) => {
          u.bind(b, M, s), p.bind(S, M, n);
        }), e.on("remove", () => {
          je(T, (M) => {
            u.unbind(b, M, s), p.unbind(S, M, n);
          });
        });
      };
      e.on("init", () => {
        Rd.setEditorTimeout(e, i, 0);
      });
    }, fQ = (e) => {
      uQ(e), eE(e) && dQ(e);
    }, BH = (e) => {
      const n = n1(() => {
        if (!e.removed && e.getBody().contains(document.activeElement)) {
          const s = e.selection.getRng();
          if (s.collapsed) {
            const i = yA(e, s, !1);
            e.selection.setRng(i);
          }
        }
      }, 0);
      e.on("focus", () => {
        n.throttle();
      }), e.on("blur", () => {
        n.cancel();
      });
    }, S3 = (e) => {
      e.on("init", () => {
        e.on("focusin", (n) => {
          const s = n.target;
          if (Yi(s)) {
            const i = Lg(e.getBody(), s), u = Ls(i) ? i : s;
            e.selection.getNode() !== u && Zx(e, u).each((p) => e.selection.setRng(p));
          }
        });
      });
    }, f2 = Ls, zM = (e, n) => Lg(e.getBody(), n), mQ = (e) => {
      const n = e.selection, s = e.dom, i = e.getBody(), u = fE(e, i, s.isBlock, () => H1(e)), p = "sel-" + s.uniqueId(), b = "data-mce-selected";
      let S;
      const T = (Nn) => Ue(Nn) && s.hasClass(Nn, "mce-offscreen-selection"), M = (Nn) => Nn !== i && (f2(Nn) || Yi(Nn)) && s.isChildOf(Nn, i) && s.isEditable(Nn.parentNode), j = (Nn) => {
        Nn && n.setRng(Nn);
      }, W = (Nn, Et, bt, Ht = !0) => e.dispatch("ShowCaret", {
        target: Et,
        direction: Nn,
        before: bt
      }).isDefaultPrevented() ? null : (Ht && n.scrollIntoView(Et, Nn === -1), u.show(bt, Et)), G = (Nn) => {
        Nn.hasAttribute("data-mce-caret") && (Os(Nn), n.scrollIntoView(Nn));
      }, ue = () => {
        e.on("click", (Et) => {
          s.isEditable(Et.target) || (Et.preventDefault(), e.focus());
        }), e.on("blur NewBlock", ut), e.on("ResizeWindow FullscreenStateChanged", u.reposition), e.on("tap", (Et) => {
          const bt = Et.target, Ht = zM(e, bt);
          f2(Ht) ? (Et.preventDefault(), Zx(e, Ht).each(We)) : M(bt) && Zx(e, bt).each(We);
        }, !0), e.on("mousedown", (Et) => {
          const bt = Et.target;
          if (bt !== i && bt.nodeName !== "HTML" && !s.isChildOf(bt, i) || !jZ(e, Et.clientX, Et.clientY))
            return;
          ut(), an();
          const Ht = zM(e, bt);
          f2(Ht) ? (Et.preventDefault(), Zx(e, Ht).each(We)) : wH(i, Et.clientX, Et.clientY).each((zn) => {
            Et.preventDefault();
            const uo = W(1, zn.node, zn.position === b0.Before, !1);
            j(uo), Ec(Ht) ? Ht.focus() : e.getBody().focus();
          });
        }), e.on("keypress", (Et) => {
          Qt.modifierPressed(Et) || f2(n.getNode()) && Et.preventDefault();
        }), e.on("GetSelectionRange", (Et) => {
          let bt = Et.range;
          if (S) {
            if (!S.parentNode) {
              S = null;
              return;
            }
            bt = bt.cloneRange(), bt.selectNode(S), Et.range = bt;
          }
        }), e.on("SetSelectionRange", (Et) => {
          Et.range = ke(Et.range);
          const bt = We(Et.range, Et.forward);
          bt && (Et.range = bt);
        });
        const Nn = (Et) => Tn(Et) && Et.id === "mcepastebin";
        e.on("AfterSetSelectionRange", (Et) => {
          const bt = Et.range, Ht = bt.startContainer.parentElement;
          !fe(bt) && !Nn(Ht) && an(), T(Ht) || ut();
        }), fQ(e), BH(e), S3(e);
      }, we = (Nn) => Jc(Nn) || pg(Nn) || Xf(Nn), fe = (Nn) => we(Nn.startContainer) || we(Nn.endContainer), ke = (Nn) => {
        const Et = e.schema.getVoidElements(), bt = s.createRng(), Ht = Nn.startContainer, zn = Nn.startOffset, uo = Nn.endContainer, Go = Nn.endOffset;
        return Xn(Et, Ht.nodeName.toLowerCase()) ? zn === 0 ? bt.setStartBefore(Ht) : bt.setStartAfter(Ht) : bt.setStart(Ht, zn), Xn(Et, uo.nodeName.toLowerCase()) ? Go === 0 ? bt.setEndBefore(uo) : bt.setEndAfter(uo) : bt.setEnd(uo, Go), bt;
      }, He = (Nn, Et) => {
        const bt = Me.fromDom(e.getBody()), Ht = e.getDoc(), zn = to(bt, "#" + p).getOrThunk(() => {
          const ys = Me.fromHtml('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>', Ht);
          return is(ys, "id", p), Zr(bt, ys), ys;
        }), uo = s.createRng();
        Vc(zn), bd(zn, [
          Me.fromText(Xa, Ht),
          Me.fromDom(Et),
          Me.fromText(Xa, Ht)
        ]), uo.setStart(zn.dom.firstChild, 1), uo.setEnd(zn.dom.lastChild, 0), Ho(zn, { top: s.getPos(Nn, e.getBody()).y + "px" }), yx(zn);
        const Go = n.getSel();
        return Go && (Go.removeAllRanges(), Go.addRange(uo)), uo;
      }, Ye = (Nn) => {
        const Et = Nn.cloneNode(!0), bt = e.dispatch("ObjectSelected", {
          target: Nn,
          targetClone: Et
        });
        if (bt.isDefaultPrevented())
          return null;
        const Ht = He(Nn, bt.targetClone), zn = Me.fromDom(Nn);
        return je(va(Me.fromDom(e.getBody()), `*[${b}]`), (uo) => {
          Bs(zn, uo) || Jr(uo, b);
        }), s.getAttrib(Nn, b) || Nn.setAttribute(b, "1"), S = Nn, an(), Ht;
      }, We = (Nn, Et) => {
        if (!Nn)
          return null;
        if (Nn.collapsed) {
          if (!fe(Nn)) {
            const uo = Et ? 1 : -1, Go = kg(uo, i, Nn), ys = Go.getNode(!Et);
            if (Ue(ys)) {
              if (Um(ys))
                return W(uo, ys, Et ? !Go.isAtEnd() : !1, !1);
              if (ff(ys) && Ls(ys.nextSibling)) {
                const xr = s.createRng();
                return xr.setStart(ys, 0), xr.setEnd(ys, 0), xr;
              }
            }
            const Js = Go.getNode(Et);
            if (Ue(Js)) {
              if (Um(Js))
                return W(uo, Js, Et ? !1 : !Go.isAtEnd(), !1);
              if (ff(Js) && Ls(Js.previousSibling)) {
                const xr = s.createRng();
                return xr.setStart(Js, 1), xr.setEnd(Js, 1), xr;
              }
            }
          }
          return null;
        }
        let bt = Nn.startContainer, Ht = Nn.startOffset;
        const zn = Nn.endOffset;
        if (Gt(bt) && Ht === 0 && f2(bt.parentNode) && (bt = bt.parentNode, Ht = s.nodeIndex(bt), bt = bt.parentNode), !Tn(bt))
          return null;
        if (zn === Ht + 1 && bt === Nn.endContainer) {
          const uo = bt.childNodes[Ht];
          if (M(uo))
            return Ye(uo);
        }
        return null;
      }, ut = () => {
        S && S.removeAttribute(b), to(Me.fromDom(e.getBody()), "#" + p).each(vr), S = null;
      }, Ut = () => {
        u.destroy(), S = null;
      }, an = () => {
        u.hide();
      };
      return bh(e) || ue(), {
        showCaret: W,
        showBlockCaretContainer: G,
        hideFakeCaret: an,
        destroy: Ut
      };
    }, pQ = (e, n) => {
      let s = n;
      for (let i = e.previousSibling; Gt(i); i = i.previousSibling)
        s += i.data.length;
      return s;
    }, VM = (e, n, s, i, u) => {
      if (Gt(s) && (i < 0 || i > s.data.length))
        return [];
      const p = u && Gt(s) ? [pQ(s, i)] : [i];
      let b = s;
      for (; b !== n && b.parentNode; )
        p.push(e.nodeIndex(b, u)), b = b.parentNode;
      return b === n ? p.reverse() : [];
    }, UM = (e, n, s, i, u, p, b = !1) => {
      const S = VM(e, n, s, i, b), T = VM(e, n, u, p, b);
      return {
        start: S,
        end: T
      };
    }, LH = (e, n) => {
      const s = n.slice(), i = s.pop();
      return Rn(i) ? vt(s, (p, b) => p.bind((S) => X.from(S.childNodes[b])), X.some(e)).bind((p) => Gt(p) && (i < 0 || i > p.data.length) ? X.none() : X.some({
        node: p,
        offset: i
      })) : X.none();
    }, $H = (e, n) => LH(e, n.start).bind(({
      node: s,
      offset: i
    }) => LH(e, n.end).map(({
      node: u,
      offset: p
    }) => {
      const b = document.createRange();
      return b.setStart(s, i), b.setEnd(u, p), b;
    })), jM = (e, n, s, i = !1) => UM(e, n, s.startContainer, s.startOffset, s.endContainer, s.endOffset, i), m2 = (e, n, s) => {
      if (n && e.isEmpty(n) && !s(n)) {
        const i = n.parentNode;
        e.remove(n, Gt(n.firstChild) && jc(n.firstChild.data)), m2(e, i, s);
      }
    }, k3 = (e, n, s, i = !0) => {
      const u = n.startContainer.parentNode, p = n.endContainer.parentNode;
      n.deleteContents(), i && !s(n.startContainer) && (Gt(n.startContainer) && n.startContainer.data.length === 0 && e.remove(n.startContainer), Gt(n.endContainer) && n.endContainer.data.length === 0 && e.remove(n.endContainer), m2(e, u, s), u !== p && m2(e, p, s));
    }, _3 = (e, n) => X.from(e.dom.getParent(n.startContainer, e.dom.isBlock)), WM = (e, n, s) => {
      const i = e.dynamicPatternsLookup({
        text: s,
        block: n
      });
      return {
        ...e,
        blockPatterns: qp(i).concat(e.blockPatterns),
        inlinePatterns: Ji(i).concat(e.inlinePatterns)
      };
    }, ZM = (e, n, s, i) => {
      const u = e.createRng();
      return u.setStart(n, 0), u.setEnd(s, i), u.toString();
    }, HH = (e, n) => e.create("span", {
      "data-mce-type": "bookmark",
      id: n
    }), hk = (e, n) => {
      const s = e.createRng();
      return s.setStartAfter(n.start), s.setEndBefore(n.end), s;
    }, GM = (e, n, s) => {
      const i = $H(e.getRoot(), s).getOrDie("Unable to resolve path range"), u = i.startContainer, p = i.endContainer, b = i.endOffset === 0 ? p : p.splitText(i.endOffset), S = i.startOffset === 0 ? u : u.splitText(i.startOffset), T = S.parentNode, M = b.parentNode;
      return {
        prefix: n,
        end: M.insertBefore(HH(e, n + "-end"), b),
        start: T.insertBefore(HH(e, n + "-start"), S)
      };
    }, E3 = (e, n, s) => {
      m2(e, e.get(n.prefix + "-end"), s), m2(e, e.get(n.prefix + "-start"), s);
    }, gk = (e) => e.start.length === 0, hQ = (e) => (n, s) => {
      const u = n.data.substring(0, s), p = u.lastIndexOf(e.charAt(e.length - 1)), b = u.lastIndexOf(e);
      return b !== -1 ? b + e.length : p !== -1 ? p + 1 : -1;
    }, T3 = (e, n, s, i) => {
      const u = n.start;
      return ZP(e, i.container, i.offset, hQ(u), s).bind((b) => {
        var S, T;
        const M = (T = (S = s.textContent) === null || S === void 0 ? void 0 : S.indexOf(u)) !== null && T !== void 0 ? T : -1;
        if (M !== -1 && b.offset >= M + u.length) {
          const W = e.createRng();
          return W.setStart(b.container, b.offset - u.length), W.setEnd(b.container, b.offset), X.some(W);
        } else {
          const W = b.offset - u.length;
          return qS(b.container, W, s).map((G) => {
            const ue = e.createRng();
            return ue.setStart(G.container, G.offset), ue.setEnd(b.container, b.offset), ue;
          }).filter((G) => G.toString() === u).orThunk(() => T3(e, n, s, rp(b.container, 0)));
        }
      });
    }, gQ = (e, n, s, i, u, p = !1) => {
      if (n.start.length === 0 && !p) {
        const b = e.createRng();
        return b.setStart(s, i), b.setEnd(s, i), X.some(b);
      }
      return WP(s, i, u).bind((b) => T3(e, n, u, b).bind((T) => {
        var M;
        if (p) {
          if (T.endContainer === b.container && T.endOffset === b.offset)
            return X.none();
          if (b.offset === 0 && ((M = T.endContainer.textContent) === null || M === void 0 ? void 0 : M.length) === T.endOffset)
            return X.none();
        }
        return X.some(T);
      }));
    }, vQ = (e, n, s, i) => {
      const u = e.dom, p = u.getRoot(), b = s.pattern, S = s.position.container, T = s.position.offset;
      return qS(S, T - s.pattern.end.length, n).bind((M) => {
        const j = UM(u, p, M.container, M.offset, S, T, i);
        if (gk(b))
          return X.some({
            matches: [{
              pattern: b,
              startRng: j,
              endRng: j
            }],
            position: M
          });
        {
          const W = vk(e, s.remainingPatterns, M.container, M.offset, n, i), G = W.getOr({
            matches: [],
            position: M
          }), ue = G.position;
          return gQ(u, b, ue.container, ue.offset, n, W.isNone()).map((fe) => {
            const ke = jM(u, p, fe, i);
            return {
              matches: G.matches.concat([{
                pattern: b,
                startRng: ke,
                endRng: j
              }]),
              position: rp(fe.startContainer, fe.startOffset)
            };
          });
        }
      });
    }, vk = (e, n, s, i, u, p) => {
      const b = e.dom;
      return WP(s, i, b.getRoot()).bind((S) => {
        const T = ZM(b, u, s, i);
        for (let M = 0; M < n.length; M++) {
          const j = n[M];
          if (!Jo(T, j.end))
            continue;
          const W = n.slice();
          W.splice(M, 1);
          const G = vQ(e, u, {
            pattern: j,
            remainingPatterns: W,
            position: S
          }, p);
          if (G.isNone() && i > 0)
            return vk(e, n, s, i - 1, u, p);
          if (G.isSome())
            return G;
        }
        return X.none();
      });
    }, zH = (e, n, s) => {
      e.selection.setRng(s), n.type === "inline-format" ? je(n.format, (i) => {
        e.formatter.apply(i);
      }) : e.execCommand(n.cmd, !1, n.value);
    }, bQ = (e, n, s, i) => {
      const u = hk(e.dom, s);
      k3(e.dom, u, i), zH(e, n, u);
    }, yQ = (e, n, s, i, u) => {
      const p = e.dom, b = hk(p, i), S = hk(p, s);
      k3(p, S, u), k3(p, b, u);
      const T = {
        prefix: s.prefix,
        start: s.end,
        end: i.start
      }, M = hk(p, T);
      zH(e, n, M);
    }, xQ = (e, n) => {
      const s = Rv("mce_textpattern"), i = zt(n, (u, p) => {
        const b = GM(e, s + `_end${u.length}`, p.endRng);
        return u.concat([{
          ...p,
          endMarker: b
        }]);
      }, []);
      return zt(i, (u, p) => {
        const b = i.length - u.length - 1, S = gk(p.pattern) ? p.endMarker : GM(e, s + `_start${b}`, p.startRng);
        return u.concat([{
          ...p,
          startMarker: S
        }]);
      }, []);
    }, wQ = (e) => kt(e, (n, s) => s.end.length - n.end.length), CQ = (e, n) => {
      const s = Qo(e, (i) => Vn(n, (u) => i.pattern.start === u.pattern.start && i.pattern.end === u.pattern.end));
      return e.length === n.length ? s ? e : n : e.length > n.length ? e : n;
    }, VH = (e, n, s, i, u, p) => {
      const b = vk(e, u.inlinePatterns, s, i, n, p).fold(() => [], (T) => T.matches), S = vk(e, wQ(u.inlinePatterns), s, i, n, p).fold(() => [], (T) => T.matches);
      return CQ(b, S);
    }, qM = (e, n) => {
      if (n.length === 0)
        return;
      const s = e.dom, i = e.selection.getBookmark(), u = xQ(s, n);
      je(u, (p) => {
        const b = s.getParent(p.startMarker.start, s.isBlock), S = (T) => T === b;
        gk(p.pattern) ? bQ(e, p.pattern, p.endMarker, S) : yQ(e, p.pattern, p.startMarker, p.endMarker, S), E3(s, p.endMarker, S), E3(s, p.startMarker, S);
      }), e.selection.moveToBookmark(i);
    }, UH = (e, n, s) => iK(n, 0, n).map((i) => {
      const u = i.container;
      return y8(u, s.start.length, n).each((p) => {
        const b = e.createRng();
        b.setStart(u, 0), b.setEnd(p.container, p.offset), k3(e, b, (S) => S === n);
      }), u;
    }), A3 = (e) => (n, s) => {
      const i = n.dom, u = s.pattern, p = $H(i.getRoot(), s.range).getOrDie("Unable to resolve path range"), b = (S, T) => {
        const M = T.get(S);
        return rt(M) && hn(M).exists((j) => Xn(j, "block"));
      };
      return _3(n, p).each((S) => {
        u.type === "block-format" ? b(u.format, n.formatter) && n.undoManager.transact(() => {
          e(n.dom, S, u), n.formatter.apply(u.format);
        }) : u.type === "block-command" && n.undoManager.transact(() => {
          e(n.dom, S, u), n.execCommand(u.cmd, !1, u.value);
        });
      }), !0;
    }, SQ = (e) => kt(e, (n, s) => s.start.length - n.start.length), jH = (e) => (n, s) => {
      const i = SQ(n), u = s.replace(Xa, " ");
      return Dn(i, (p) => e(p, s, u));
    }, WH = (e, n) => (s, i, u, p, b) => {
      var S;
      b === void 0 && (b = (S = i.textContent) !== null && S !== void 0 ? S : "");
      const T = s.dom, M = Dl(s);
      return T.is(i, M) ? e(u.blockPatterns, b).map((j) => n && Kt.trim(b).length === j.start.length ? [] : [{
        pattern: j,
        range: UM(T, T.getRoot(), i, 0, i, 0, p)
      }]).getOr([]) : [];
    }, kQ = (e) => /^\s[^\s]/.test(e), _Q = A3((e, n, s) => {
      UH(e, n, s).each((i) => {
        const u = Me.fromDom(i), p = o1(u);
        kQ(p) && uy(u, p.slice(1));
      });
    }), O3 = jH((e, n, s) => n.indexOf(e.start) === 0 || s.indexOf(e.start) === 0), EQ = WH(O3, !0), TQ = (e, n) => {
      const s = e.selection.getRng();
      return _3(e, s).map((i) => {
        var u;
        const p = Math.max(0, s.startOffset), b = WM(n, i, (u = i.textContent) !== null && u !== void 0 ? u : ""), S = VH(e, i, s.startContainer, p, b, !0), T = EQ(e, i, b, !0);
        return {
          inlineMatches: S,
          blockMatches: T
        };
      }).filter(({ inlineMatches: i, blockMatches: u }) => u.length > 0 || i.length > 0);
    }, AQ = (e, n) => {
      if (n.length === 0)
        return;
      const s = e.selection.getBookmark();
      je(n, (i) => _Q(e, i)), e.selection.moveToBookmark(s);
    }, OQ = A3(UH), DQ = jH((e, n, s) => n === e.start || s === e.start), RQ = WH(DQ, !1), NQ = (e, n) => {
      const s = e.selection.getRng();
      return _3(e, s).map((i) => {
        const u = Math.max(0, s.startOffset), p = ZM(e.dom, i, s.startContainer, u), b = WM(n, i, p);
        return RQ(e, i, b, !1, p);
      }).filter((i) => i.length > 0);
    }, PQ = (e, n) => {
      je(n, (s) => OQ(e, s));
    }, MQ = (e, n) => TQ(e, n).fold(et, ({ inlineMatches: s, blockMatches: i }) => (e.undoManager.add(), e.undoManager.extra(() => {
      e.execCommand("mceInsertNewLine");
    }, () => {
      WI(e), qM(e, s), AQ(e, i);
      const u = e.selection.getRng(), p = WP(u.startContainer, u.startOffset, e.dom.getRoot());
      e.execCommand("mceInsertNewLine"), p.each((b) => {
        const S = b.container;
        S.data.charAt(b.offset - 1) === vv && (S.deleteData(b.offset - 1, 1), m2(e.dom, S.parentNode, (T) => T === e.dom.getRoot()));
      });
    }), !0)), ZH = (e, n) => {
      const s = e.selection.getRng();
      _3(e, s).map((i) => {
        const u = Math.max(0, s.startOffset - 1), p = ZM(e.dom, i, s.startContainer, u), b = WM(n, i, p), S = VH(e, i, s.startContainer, u, b, !1);
        S.length > 0 && e.undoManager.transact(() => {
          qM(e, S);
        });
      });
    }, IQ = (e, n) => NQ(e, n).fold(et, (s) => (e.undoManager.transact(() => {
      PQ(e, s);
    }), !0)), KM = (e, n, s) => {
      for (let i = 0; i < e.length; i++)
        if (s(e[i], n))
          return !0;
      return !1;
    }, FQ = (e, n) => KM(e, n, (s, i) => s === i.keyCode && !Qt.modifierPressed(i)), BQ = (e, n) => KM(e, n, (s, i) => s.charCodeAt(0) === i.charCode), GH = (e) => {
      const n = [
        ",",
        ".",
        ";",
        ":",
        "!",
        "?"
      ], s = [32], i = () => Kp(lE(e), XO(e)), u = () => eh(e);
      e.on("keydown", (b) => {
        if (b.keyCode === 13 && !Qt.modifierPressed(b) && e.selection.isCollapsed()) {
          const S = Fw(i(), "enter");
          (S.inlinePatterns.length > 0 || S.blockPatterns.length > 0 || u()) && MQ(e, S) && b.preventDefault();
        }
      }, !0), e.on("keydown", (b) => {
        if (b.keyCode === 32 && e.selection.isCollapsed()) {
          const S = Fw(i(), "space");
          (S.blockPatterns.length > 0 || u()) && IQ(e, S) && b.preventDefault();
        }
      }, !0);
      const p = () => {
        if (e.selection.isCollapsed()) {
          const b = Fw(i(), "space");
          (b.inlinePatterns.length > 0 || u()) && ZH(e, b);
        }
      };
      e.on("keyup", (b) => {
        FQ(s, b) && p();
      }), e.on("keypress", (b) => {
        BQ(n, b) && Rd.setEditorTimeout(e, p);
      });
    }, bk = (e) => {
      GH(e);
    }, LQ = (e) => {
      const n = Kt.each, s = Qt.BACKSPACE, i = Qt.DELETE, u = e.dom, p = e.selection, b = e.parser, S = sn.browser, T = S.isFirefox(), M = S.isChromium() || S.isSafari(), j = sn.deviceType.isiPhone() || sn.deviceType.isiPad(), W = sn.os.isMacOS() || sn.os.isiOS(), G = (Sn, bo) => {
        try {
          e.getDoc().execCommand(Sn, !1, String(bo));
        } catch {
        }
      }, ue = (Sn) => Sn.isDefaultPrevented(), we = () => {
        const Sn = (cs) => {
          const On = u.create("body"), us = cs.cloneContents();
          return On.appendChild(us), p.serializer.serialize(On, { format: "html" });
        }, bo = (cs) => {
          const On = Sn(cs), us = u.createRng();
          us.selectNode(e.getBody());
          const ws = Sn(us);
          return On === ws;
        };
        e.on("keydown", (cs) => {
          const On = cs.keyCode;
          if (!ue(cs) && (On === i || On === s) && e.selection.isEditable()) {
            const us = e.selection.isCollapsed(), ws = e.getBody();
            if (us && !Vu(e.schema, ws) || !us && !bo(e.selection.getRng()))
              return;
            cs.preventDefault(), e.setContent(""), ws.firstChild && u.isBlock(ws.firstChild) ? e.selection.setCursorLocation(ws.firstChild, 0) : e.selection.setCursorLocation(ws, 0), e.nodeChanged();
          }
        });
      }, fe = () => {
        e.shortcuts.add("meta+a", null, "SelectAll");
      }, ke = () => {
        e.inline || u.bind(e.getDoc(), "mousedown mouseup", (Sn) => {
          let bo;
          if (Sn.target === e.getDoc().documentElement)
            if (bo = p.getRng(), e.getBody().focus(), Sn.type === "mousedown") {
              if (Jc(bo.startContainer))
                return;
              p.placeCaretAt(Sn.clientX, Sn.clientY);
            } else
              p.setRng(bo);
        });
      }, He = () => {
        e.on("keydown", (Sn) => {
          if (!ue(Sn) && Sn.keyCode === s) {
            if (!e.getBody().getElementsByTagName("hr").length)
              return;
            if (p.isCollapsed() && p.getRng().startOffset === 0) {
              const bo = p.getNode(), cs = bo.previousSibling;
              if (bo.nodeName === "HR") {
                u.remove(bo), Sn.preventDefault();
                return;
              }
              cs && cs.nodeName && cs.nodeName.toLowerCase() === "hr" && (u.remove(cs), Sn.preventDefault());
            }
          }
        });
      }, Ye = () => {
        Range.prototype.getClientRects || e.on("mousedown", (Sn) => {
          if (!ue(Sn) && Sn.target.nodeName === "HTML") {
            const bo = e.getBody();
            bo.blur(), Rd.setEditorTimeout(e, () => {
              bo.focus();
            });
          }
        });
      }, We = () => {
        const Sn = Qw(e);
        e.on("click", (bo) => {
          const cs = bo.target;
          /^(IMG|HR)$/.test(cs.nodeName) && u.isEditable(cs) && (bo.preventDefault(), e.selection.select(cs), e.nodeChanged()), cs.nodeName === "A" && u.hasClass(cs, Sn) && cs.childNodes.length === 0 && u.isEditable(cs.parentNode) && (bo.preventDefault(), p.select(cs));
        });
      }, ut = () => {
        const Sn = () => {
          const cs = u.getAttribs(p.getStart().cloneNode(!1));
          return () => {
            const On = p.getStart();
            On !== e.getBody() && (u.setAttrib(On, "style", null), n(cs, (us) => {
              On.setAttributeNode(us.cloneNode(!0));
            }));
          };
        }, bo = () => !p.isCollapsed() && u.getParent(p.getStart(), u.isBlock) !== u.getParent(p.getEnd(), u.isBlock);
        e.on("keypress", (cs) => {
          let On;
          return !ue(cs) && (cs.keyCode === 8 || cs.keyCode === 46) && bo() ? (On = Sn(), e.getDoc().execCommand("delete", !1), On(), cs.preventDefault(), !1) : !0;
        }), u.bind(e.getDoc(), "cut", (cs) => {
          if (!ue(cs) && bo()) {
            const On = Sn();
            Rd.setEditorTimeout(e, () => {
              On();
            });
          }
        });
      }, Ut = () => {
        e.on("keydown", (Sn) => {
          if (!ue(Sn) && Sn.keyCode === s && p.isCollapsed() && p.getRng().startOffset === 0) {
            const bo = p.getNode().previousSibling;
            if (bo && bo.nodeName && bo.nodeName.toLowerCase() === "table")
              return Sn.preventDefault(), !1;
          }
          return !0;
        });
      }, an = () => {
        e.on("keydown", (Sn) => {
          if (ue(Sn) || Sn.keyCode !== Qt.BACKSPACE)
            return;
          let bo = p.getRng();
          const cs = bo.startContainer, On = bo.startOffset, us = u.getRoot();
          let ws = cs;
          if (!(!bo.collapsed || On !== 0)) {
            for (; ws.parentNode && ws.parentNode.firstChild === ws && ws.parentNode !== us; )
              ws = ws.parentNode;
            ws.nodeName === "BLOCKQUOTE" && (e.formatter.toggle("blockquote", void 0, ws), bo = u.createRng(), bo.setStart(cs, 0), bo.setEnd(cs, 0), p.setRng(bo));
          }
        });
      }, Nn = () => {
        const Sn = () => {
          G("StyleWithCSS", !1), G("enableInlineTableEditing", !1), vu(e) || G("enableObjectResizing", !1);
        };
        Q_(e) || e.on("BeforeExecCommand mousedown", Sn);
      }, Et = () => {
        const Sn = () => {
          n(u.select("a:not([data-mce-block])"), (bo) => {
            var cs;
            let On = bo.parentNode;
            const us = u.getRoot();
            if ((On == null ? void 0 : On.lastChild) === bo) {
              for (; On && !u.isBlock(On); ) {
                if (((cs = On.parentNode) === null || cs === void 0 ? void 0 : cs.lastChild) !== On || On === us)
                  return;
                On = On.parentNode;
              }
              u.add(On, "br", { "data-mce-bogus": 1 });
            }
          });
        };
        e.on("SetContent ExecCommand", (bo) => {
          (bo.type === "setcontent" || bo.command === "mceInsertLink") && Sn();
        });
      }, bt = () => {
        e.on("init", () => {
          G("DefaultParagraphSeparator", Dl(e));
        });
      }, Ht = (Sn) => {
        const bo = Sn.getBody(), cs = Sn.selection.getRng();
        return cs.startContainer === cs.endContainer && cs.startContainer === bo && cs.startOffset === 0 && cs.endOffset === bo.childNodes.length;
      }, zn = () => {
        e.on("keyup focusin mouseup", (Sn) => {
          !Qt.modifierPressed(Sn) && !Ht(e) && p.normalize();
        }, !0);
      }, uo = () => {
        e.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}");
      }, Go = () => {
        e.inline || e.on("keydown", () => {
          document.activeElement === document.body && e.getWin().focus();
        });
      }, ys = () => {
        e.inline || (e.contentStyles.push("body {min-height: 150px}"), e.on("click", (Sn) => {
          let bo;
          Sn.target.nodeName === "HTML" && (bo = e.selection.getRng(), e.getBody().focus(), e.selection.setRng(bo), e.selection.normalize(), e.nodeChanged());
        }));
      }, Js = () => {
        W && e.on("keydown", (Sn) => {
          Qt.metaKeyPressed(Sn) && !Sn.shiftKey && (Sn.keyCode === 37 || Sn.keyCode === 39) && (Sn.preventDefault(), e.selection.getSel().modify("move", Sn.keyCode === 37 ? "backward" : "forward", "lineboundary"));
        });
      }, xr = () => {
        e.on("click", (Sn) => {
          let bo = Sn.target;
          do
            if (bo.tagName === "A") {
              Sn.preventDefault();
              return;
            }
          while (bo = bo.parentNode);
        }), e.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}");
      }, Da = () => {
        e.on("init", () => {
          e.dom.bind(e.getBody(), "submit", (Sn) => {
            Sn.preventDefault();
          });
        });
      }, yl = () => {
        b.addNodeFilter("br", (Sn) => {
          let bo = Sn.length;
          for (; bo--; )
            Sn[bo].attr("class") === "Apple-interchange-newline" && Sn[bo].remove();
        });
      }, mr = ot, mn = () => {
        if (!T || e.removed)
          return !1;
        const Sn = e.selection.getSel();
        return !Sn || !Sn.rangeCount || Sn.rangeCount === 0;
      }, ro = () => {
        M && (ke(), We(), Da(), fe(), j && (Go(), ys(), xr())), T && (Ye(), Nn(), uo(), Js());
      }, Hs = () => {
        an(), we(), sn.windowsPhone || zn(), M && (ke(), We(), bt(), Da(), Ut(), yl(), j ? (Go(), ys(), xr()) : fe()), T && (He(), Ye(), ut(), Nn(), Et(), uo(), Js(), Ut());
      };
      return bh(e) ? ro() : Hs(), {
        refreshContentEditable: mr,
        isHidden: mn
      };
    }, qH = (e) => e.toLowerCase() === "gpl", $Q = (e) => e.length >= 64 && e.length <= 255, HQ = (e) => qH(e) || $Q(e) ? "VALID" : "INVALID", zQ = (e) => {
      const n = w1(e);
      !U(oC(e)) && (wt(n) || HQ(n) === "INVALID") && console.warn("TinyMCE is running in evaluation mode. Provide a valid license key or add license_key: 'gpl' to the init config to agree to the open source license terms. Read more at https://www.tiny.cloud/license-key/");
    }, YM = Kr.DOM, KH = (e, n) => {
      const s = Me.fromDom(e.getBody()), i = _p(ec(s)), u = Me.fromTag("style");
      is(u, "type", "text/css"), Zr(u, Me.fromText(n)), Zr(i, u), e.on("remove", () => {
        vr(u);
      });
    }, VQ = (e) => e.inline ? e.getElement().nodeName.toLowerCase() : void 0, D3 = (e) => ks(e, (n) => wt(n) === !1), YH = (e) => {
      const n = e.options.get, s = e.editorUpload.blobCache;
      return D3({
        allow_conditional_comments: n("allow_conditional_comments"),
        allow_html_data_urls: n("allow_html_data_urls"),
        allow_svg_data_urls: n("allow_svg_data_urls"),
        allow_html_in_named_anchor: n("allow_html_in_named_anchor"),
        allow_script_urls: n("allow_script_urls"),
        allow_unsafe_link_target: n("allow_unsafe_link_target"),
        convert_unsafe_embeds: n("convert_unsafe_embeds"),
        convert_fonts_to_spans: n("convert_fonts_to_spans"),
        fix_list_elements: n("fix_list_elements"),
        font_size_legacy_values: n("font_size_legacy_values"),
        forced_root_block: n("forced_root_block"),
        forced_root_block_attrs: n("forced_root_block_attrs"),
        preserve_cdata: n("preserve_cdata"),
        inline_styles: n("inline_styles"),
        root_name: VQ(e),
        sandbox_iframes: n("sandbox_iframes"),
        sandbox_iframes_exclusions: $y(e),
        sanitize: n("xss_sanitization"),
        validate: !0,
        blob_cache: s,
        document: e.getDoc()
      });
    }, XH = (e) => {
      const n = e.options.get;
      return D3({
        custom_elements: n("custom_elements"),
        extended_valid_elements: n("extended_valid_elements"),
        invalid_elements: n("invalid_elements"),
        invalid_styles: n("invalid_styles"),
        schema: n("schema"),
        valid_children: n("valid_children"),
        valid_classes: n("valid_classes"),
        valid_elements: n("valid_elements"),
        valid_styles: n("valid_styles"),
        verify_html: n("verify_html"),
        padd_empty_block_inline_children: n("format_empty_lines")
      });
    }, UQ = (e) => {
      const n = e.options.get;
      return {
        ...YH(e),
        ...XH(e),
        ...D3({
          remove_trailing_brs: n("remove_trailing_brs"),
          pad_empty_with_br: n("pad_empty_with_br"),
          url_converter: n("url_converter"),
          url_converter_scope: n("url_converter_scope"),
          element_format: n("element_format"),
          entities: n("entities"),
          entity_encoding: n("entity_encoding"),
          indent: n("indent"),
          indent_after: n("indent_after"),
          indent_before: n("indent_before")
        })
      };
    }, jQ = (e) => {
      const n = gh(YH(e), e.schema);
      return n.addAttributeFilter("src,href,style,tabindex", (s, i) => {
        const u = e.dom, p = "data-mce-" + i;
        let b = s.length;
        for (; b--; ) {
          const S = s[b];
          let T = S.attr(i);
          if (T && !S.attr(p)) {
            if (T.indexOf("data:") === 0 || T.indexOf("blob:") === 0)
              continue;
            i === "style" ? (T = u.serializeStyle(u.parseStyle(T), S.name), T.length || (T = null), S.attr(p, T), S.attr(i, T)) : i === "tabindex" ? (S.attr(p, T), S.attr(i, null)) : S.attr(p, e.convertURL(T, i, S.name));
          }
        }
      }), n.addNodeFilter("script", (s) => {
        let i = s.length;
        for (; i--; ) {
          const u = s[i], p = u.attr("type") || "no/type";
          p.indexOf("mce-") !== 0 && u.attr("type", "mce-" + p);
        }
      }), Iy(e) && n.addNodeFilter("#cdata", (s) => {
        var i;
        let u = s.length;
        for (; u--; ) {
          const p = s[u];
          p.type = 8, p.name = "#comment", p.value = "[CDATA[" + e.dom.encode((i = p.value) !== null && i !== void 0 ? i : "") + "]]";
        }
      }), n.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", (s) => {
        let i = s.length;
        const u = e.schema.getNonEmptyElements();
        for (; i--; ) {
          const p = s[i];
          p.isEmpty(u) && p.getAll("br").length === 0 && p.append(new ou("br", 1));
        }
      }), n;
    }, WQ = (e) => {
      const n = Ny(e);
      n && Rd.setEditorTimeout(e, () => {
        let s;
        n === !0 ? s = e : s = e.editorManager.get(n), s && !s.destroyed && (s.focus(), s.selection.scrollIntoView());
      }, 100);
    }, ZQ = (e) => {
      const n = e.dom.getRoot();
      !e.inline && (!EC(e) || e.selection.getStart(!0) === n) && jl(n).each((s) => {
        const i = s.getNode(), u = Hu(i) ? jl(i).getOr(s) : s;
        e.selection.setRng(u.toRange());
      });
    }, GQ = (e) => {
      e.bindPendingEventDelegates(), e.initialized = !0, OD(e), e.focus(!0), ZQ(e), e.nodeChanged({ initial: !0 });
      const n = qO(e);
      Ce(n) && n.call(e, e), WQ(e);
    }, XM = (e) => e.inline ? e.ui.styleSheetLoader : e.dom.styleSheetLoader, qQ = (e, n, s) => {
      const {
        pass: i,
        fail: u
      } = qn(n, (S) => tinymce.Resource.has(WN(S))), b = [
        ...i.map((S) => {
          const T = tinymce.Resource.get(WN(S));
          return U(T) ? Promise.resolve(XM(e).loadRawCss(S, T)) : Promise.resolve();
        }),
        XM(e).loadAll(u)
      ];
      return e.inline ? b : b.concat([e.ui.styleSheetLoader.loadAll(s)]);
    }, QM = (e) => {
      const n = XM(e), s = Rc(e), i = e.contentCSS, u = () => {
        n.unloadAll(i), e.inline || e.ui.styleSheetLoader.unloadAll(s);
      }, p = () => {
        e.removed ? u() : e.on("remove", u);
      };
      if (e.contentStyles.length > 0) {
        let T = "";
        Kt.each(e.contentStyles, (M) => {
          T += M + `\r
`;
        }), e.dom.addStyle(T);
      }
      const b = Promise.all(qQ(e, i, s)).then(p).catch(p), S = UO(e);
      return S && KH(e, S), b;
    }, JM = (e) => {
      const n = e.getDoc(), s = e.getBody();
      BE(e), tE(e) || (n.body.spellcheck = !1, YM.setAttrib(s, "spellcheck", "false")), e.quirks = LQ(e), dx(e);
      const i = GI(e);
      i !== void 0 && (s.dir = i);
      const u = eC(e);
      u && e.on("BeforeSetContent", (p) => {
        Kt.each(u, (b) => {
          p.content = p.content.replace(b, (S) => "<!--mce:protected " + escape(S) + "-->");
        });
      }), e.on("SetContent", () => {
        e.addVisual(e.getBody());
      }), e.on("compositionstart compositionend", (p) => {
        e.composing = p.type === "compositionstart";
      });
    }, QH = (e) => {
      bh(e) || e.load({
        initial: !0,
        format: "html"
      }), e.startContent = e.getContent({ format: "raw" });
    }, R3 = (e) => {
      e.removed !== !0 && (QH(e), GQ(e));
    }, KQ = (e) => {
      let n = !1;
      const s = setTimeout(() => {
        n || e.setProgressState(!0);
      }, 500);
      return () => {
        clearTimeout(s), n = !0, e.setProgressState(!1);
      };
    }, JH = (e) => {
      const n = e.getElement();
      let s = e.getDoc();
      e.inline && (YM.addClass(n, "mce-content-body"), e.contentDocument = s = document, e.contentWindow = window, e.bodyElement = n, e.contentAreaContainer = n);
      const i = e.getBody();
      i.disabled = !0, e.readonly = Q_(e), e._editableRoot = ZO(e), !e.readonly && e.hasEditableRoot() && (e.inline && YM.getStyle(i, "position", !0) === "static" && (i.style.position = "relative"), i.contentEditable = "true"), i.disabled = !1, e.editorUpload = oG(e), e.schema = Gf(XH(e)), e.dom = Kr(s, {
        keep_values: !0,
        url_converter: e.convertURL,
        url_converter_scope: e,
        update_styles: !0,
        root_element: e.inline ? e.getBody() : null,
        collect: e.inline,
        schema: e.schema,
        contentCssCors: Z_(e),
        referrerPolicy: Ty(e),
        onSetAttrib: (b) => {
          e.dispatch("SetAttrib", b);
        }
      }), e.parser = jQ(e), e.serializer = LN(UQ(e), e), e.selection = g6(e.dom, e.getWin(), e.serializer, e), e.annotator = om(e), e.formatter = F6(e), e.undoManager = XN(e), e._nodeChangeDispatcher = new UY(e), e._selectionOverrides = mQ(e), MA(e), LX(e), _q(e), bh(e) || (zX(e), bk(e));
      const u = VY(e);
      bq(e, u), Cq(e), uG(e), IX(e);
      const p = o6(e);
      JM(e), zQ(e), p.fold(() => {
        const b = KQ(e);
        QM(e).then(() => {
          R3(e), b();
        });
      }, (b) => {
        e.setProgressState(!0), QM(e).then(() => {
          b().then((S) => {
            e.setProgressState(!1), R3(e), m6(e);
          }, (S) => {
            e.notificationManager.open({
              type: "error",
              text: String(S)
            }), R3(e), m6(e);
          });
        });
      });
    }, YQ = xt, ez = (e, n, s) => pv(e, n, YQ, s), N3 = Kr.DOM, XQ = (e, n, s, i) => {
      const u = Me.fromTag("iframe");
      return i.each((p) => is(u, "tabindex", p)), _a(u, s), _a(u, {
        id: e + "_ifr",
        frameBorder: "0",
        allowTransparency: "true",
        title: n
      }), gd(u, "tox-edit-area__iframe"), u;
    }, QQ = (e) => {
      let n = $O(e) + "<html><head>";
      el(e) !== e.documentBaseUrl && (n += '<base href="' + e.documentBaseURI.getURI() + '" />'), n += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
      const s = HO(e), i = Yp(e), u = e.translate(Jw(e));
      return Vw(e) && (n += '<meta http-equiv="Content-Security-Policy" content="' + Vw(e) + '" />'), n += `</head><body id="${s}" class="mce-content-body ${i}" data-id="${e.id}" aria-label="${u}"><br></body></html>`, n;
    }, e5 = (e, n) => {
      const s = sn.browser.isFirefox() ? Jw(e) : "Rich Text Area", i = e.translate(s), u = ua(Me.fromDom(e.getElement()), "tabindex").bind(Ba), p = XQ(e.id, i, Ad(e), u).dom;
      p.onload = () => {
        p.onload = null, e.dispatch("load");
      }, e.contentAreaContainer = n.iframeContainer, e.iframeElement = p, e.iframeHTML = QQ(e), N3.add(n.iframeContainer, p);
    }, P3 = (e) => {
      const n = e.iframeElement, s = () => {
        e.contentDocument = n.contentDocument, JH(e);
      };
      if (dc(e) || sn.browser.isFirefox()) {
        const i = e.getDoc();
        i.open(), i.write(e.iframeHTML), i.close(), s();
      } else {
        const i = ez(Me.fromDom(n), "load", () => {
          i.unbind(), s();
        });
        n.srcdoc = e.iframeHTML;
      }
    }, M3 = (e, n) => {
      e5(e, n), n.editorContainer && (n.editorContainer.style.display = e.orgDisplay, e.hidden = N3.isHidden(n.editorContainer)), e.getElement().style.display = "none", N3.setAttrib(e.id, "aria-hidden", "true"), e.getElement().style.visibility = e.orgVisibility, P3(e);
    }, _h = Kr.DOM, I3 = (e, n, s) => {
      const i = Hx.get(s), u = Hx.urls[s] || e.documentBaseUrl.replace(/\/$/, "");
      if (s = Kt.trim(s), i && Kt.inArray(n, s) === -1) {
        if (e.plugins[s])
          return;
        try {
          const p = i(e, u) || {};
          e.plugins[s] = p, Ce(p.init) && (p.init(e, u), n.push(s));
        } catch (p) {
          jN(e, s, p);
        }
      }
    }, p2 = (e) => e.replace(/^\-/, ""), tz = (e) => {
      const n = [];
      je(b1(e), (s) => {
        I3(e, n, p2(s));
      });
    }, JQ = (e) => {
      const n = Kt.trim(Si(e)), s = e.ui.registry.getAll().icons, i = {
        ...Lx.get("default").icons,
        ...Lx.get(n).icons
      };
      qt(i, (u, p) => {
        Xn(s, p) || e.ui.registry.addIcon(p, u);
      });
    }, eJ = (e) => {
      const n = Jp(e);
      if (U(n)) {
        const s = np.get(n);
        e.theme = s(e, np.urls[n]) || {}, Ce(e.theme.init) && e.theme.init(e, np.urls[n] || e.documentBaseUrl.replace(/\/$/, ""));
      } else
        e.theme = {};
    }, nz = (e) => {
      const n = Oy(e), s = $x.get(n);
      e.model = s(e, $x.urls[n]);
    }, tJ = (e) => {
      const n = e.theme.renderUI;
      return n ? n() : Tb(e);
    }, t5 = (e) => {
      const n = e.getElement(), i = Jp(e)(e, n);
      return i.editorContainer.nodeType && (i.editorContainer.id = i.editorContainer.id || e.id + "_parent"), i.iframeContainer && i.iframeContainer.nodeType && (i.iframeContainer.id = i.iframeContainer.id || e.id + "_iframecontainer"), i.height = i.iframeHeight ? i.iframeHeight : n.offsetHeight, i;
    }, yk = (e, n) => ({
      editorContainer: e,
      iframeContainer: n,
      api: {}
    }), Eb = (e) => {
      const n = _h.create("div");
      return _h.insertAfter(n, e), yk(n, n);
    }, Tb = (e) => {
      const n = e.getElement();
      return e.inline ? yk(null) : Eb(n);
    }, oz = (e) => {
      const n = e.getElement();
      return e.orgDisplay = n.style.display, U(Jp(e)) ? tJ(e) : Ce(Jp(e)) ? t5(e) : Tb(e);
    }, nJ = (e, n) => {
      const s = {
        show: X.from(n.show).getOr(ot),
        hide: X.from(n.hide).getOr(ot),
        isEnabled: X.from(n.isEnabled).getOr(xt),
        setEnabled: (i) => {
          e.mode.isReadOnly() || X.from(n.setEnabled).each((u) => u(i));
        }
      };
      e.ui = {
        ...e.ui,
        ...s
      };
    }, oJ = async (e) => {
      e.dispatch("ScriptsLoaded"), JQ(e), eJ(e), nz(e), tz(e);
      const n = await oz(e);
      nJ(e, X.from(n.api).getOr({})), e.editorContainer = n.editorContainer, eG(e), e.inline ? JH(e) : M3(e, {
        editorContainer: n.editorContainer,
        iframeContainer: n.iframeContainer
      });
    }, x0 = Kr.DOM, sz = (e) => e.charAt(0) === "-", sJ = (e, n) => {
      const s = Ay(n), i = vg(n);
      if (!Fi.hasCode(s) && s !== "en") {
        const u = ko(i) ? i : `${n.editorManager.baseURL}/langs/${s}.js`;
        e.add(u).catch(() => {
          YZ(n, u, s);
        });
      }
    }, rJ = (e, n) => {
      const s = Jp(e);
      if (U(s) && !sz(s) && !Xn(np.urls, s)) {
        const i = Zw(e), u = i ? e.documentBaseURI.toAbsolute(i) : `themes/${s}/theme${n}.js`;
        np.load(s, u).catch(() => {
          jre(e, u, s);
        });
      }
    }, rz = (e, n) => {
      const s = Oy(e);
      if (s !== "plugin" && !Xn($x.urls, s)) {
        const i = G_(e), u = U(i) ? e.documentBaseURI.toAbsolute(i) : `models/${s}/model${n}.js`;
        $x.load(s, u).catch(() => {
          op(e, u, s);
        });
      }
    }, aJ = (e) => X.from(ti(e)).filter(ko).map((n) => ({
      url: n,
      name: X.none()
    })), az = (e, n, s) => X.from(n).filter((i) => ko(i) && !Lx.has(i)).map((i) => ({
      url: `${e.editorManager.baseURL}/icons/${i}/icons${s}.js`,
      name: X.some(i)
    })), iJ = (e, n, s) => {
      const i = az(n, "default", s), u = aJ(n).orThunk(() => az(n, Si(n), ""));
      je(Cr([
        i,
        u
      ]), (p) => {
        e.add(p.url).catch(() => {
          KZ(n, p.url, p.name.getOrUndefined());
        });
      });
    }, pae = (e, n) => {
      const s = (i, u) => {
        Hx.load(i, u).catch(() => {
          qZ(e, u, i);
        });
      };
      qt(GO(e), (i, u) => {
        s(u, i), e.options.set("plugins", b1(e).concat(u));
      }), je(b1(e), (i) => {
        i = Kt.trim(i), i && !Hx.urls[i] && !sz(i) && s(i, `plugins/${i}/plugin${n}.js`);
      });
    }, lJ = (e) => {
      const n = Jp(e);
      return !U(n) || Ue(np.get(n));
    }, n5 = (e) => {
      const n = Oy(e);
      return Ue($x.get(n));
    }, cJ = (e, n) => {
      const s = cf.ScriptLoader, i = () => {
        !e.removed && lJ(e) && n5(e) && oJ(e);
      };
      rJ(e, n), rz(e, n), sJ(s, e), iJ(s, e, n), pae(e, n), s.loadQueue().then(i, i);
    }, uJ = (e, n) => Ja.forElement(e, {
      contentCssCors: J_(n),
      referrerPolicy: Ty(n)
    }), iz = (e) => {
      const n = e.id;
      Fi.setCode(Ay(e));
      const s = () => {
        x0.unbind(window, "ready", s), e.render();
      };
      if (!Vp.Event.domLoaded) {
        x0.bind(window, "ready", s);
        return;
      }
      if (!e.getElement())
        return;
      const i = Me.fromDom(e.getElement()), u = Sc(i);
      e.on("remove", () => {
        An(i.dom.attributes, (b) => Jr(i, b.name)), _a(i, u);
      }), e.ui.styleSheetLoader = uJ(i, e), xg(e) ? e.inline = !0 : (e.orgVisibility = e.getElement().style.visibility, e.getElement().style.visibility = "hidden");
      const p = e.getElement().form || x0.getParent(n, "form");
      p && (e.formElement = p, Kw(e) && !ra(e.getElement()) && (x0.insertAfter(x0.create("input", {
        type: "hidden",
        name: n
      }), n), e.hasHiddenInput = !0), e.formEventDelegate = (b) => {
        e.dispatch(b.type, b);
      }, x0.bind(p, "submit reset", e.formEventDelegate), e.on("reset", () => {
        e.resetContent();
      }), Yw(e) && !p.submit.nodeType && !p.submit.length && !p._mceOldSubmit && (p._mceOldSubmit = p.submit, p.submit = () => (e.editorManager.triggerSave(), e.setDirty(!1), p._mceOldSubmit(p)))), e.windowManager = UN(e), e.notificationManager = T6(e), nh(e) && e.on("GetContent", (b) => {
        b.save && (b.content = x0.encode(b.content));
      }), Y_(e) && e.on("submit", () => {
        e.initialized && e.save();
      }), X_(e) && (e._beforeUnload = () => {
        e.initialized && !e.destroyed && !e.isHidden() && e.save({
          format: "raw",
          no_events: !0,
          set_dirty: !1
        });
      }, e.editorManager.on("BeforeUnload", e._beforeUnload)), e.editorManager.add(e), cJ(e, e.suffix);
    }, dJ = (e, n) => {
      e._editableRoot !== n && (e._editableRoot = n, e.readonly || (e.getBody().contentEditable = String(e.hasEditableRoot()), e.nodeChanged()), FC(e, n));
    }, lz = (e) => e._editableRoot, fJ = (e, n) => ({
      sections: ze(e),
      options: ze(n)
    }), F3 = Xt().deviceType, cz = F3.isPhone(), mJ = F3.isTablet(), xk = (e) => {
      if (Vt(e))
        return [];
      {
        const n = rt(e) ? e : e.split(/[ ,]/), s = tn(n, Wa);
        return on(s, ko);
      }
    }, pJ = (e, n) => {
      const s = na(n, (i, u) => Nt(e, u));
      return fJ(s.t, s.f);
    }, uz = (e, n, s = {}) => {
      const i = e.sections(), u = _s(i, n).getOr({});
      return Kt.extend({}, s, u);
    }, wk = (e, n) => Xn(e.sections(), n), dz = (e, n) => wk(e, n) ? e.sections()[n] : {}, o5 = (e, n) => ({
      ...{
        table_grid: !1,
        object_resizing: !1,
        resize: !1,
        toolbar_mode: _s(e, "toolbar_mode").getOr("scrolling"),
        toolbar_sticky: !1
      },
      ...n ? { menubar: !1 } : {}
    }), hJ = (e, n) => {
      var s;
      const i = (s = n.external_plugins) !== null && s !== void 0 ? s : {};
      return e && e.external_plugins ? Kt.extend({}, e.external_plugins, i) : i;
    }, hae = (e, n) => [
      ...xk(e),
      ...xk(n)
    ], gae = (e, n, s, i) => e && wk(n, "mobile") ? i : s, gJ = (e, n, s, i) => {
      const u = xk(s.forced_plugins), p = xk(i.plugins), b = dz(n, "mobile"), S = b.plugins ? xk(b.plugins) : p, T = gae(e, n, p, S), M = hae(u, T);
      return Kt.extend(i, {
        forced_plugins: u,
        plugins: M
      });
    }, fz = (e, n) => e && wk(n, "mobile"), vJ = (e, n, s, i, u) => {
      var p;
      const b = e ? { mobile: o5((p = u.mobile) !== null && p !== void 0 ? p : {}, n) } : {}, S = pJ(["mobile"], ek(b, u)), T = Kt.extend(s, i, S.options(), fz(e, S) ? uz(S, "mobile") : {}, { external_plugins: hJ(i, S.options()) });
      return gJ(e, S, i, T);
    }, bJ = (e, n) => {
      const s = O8(n);
      return vJ(cz || mJ, cz, s, e, s);
    }, yJ = (e, n) => dZ(e, n), vae = (e) => {
      const n = (i, u) => {
        e.formatter.toggle(i, u), e.nodeChanged();
      }, s = (i) => () => {
        je("left,center,right,justify".split(","), (u) => {
          i !== u && e.formatter.remove("align" + u);
        }), i !== "none" && n("align" + i);
      };
      e.editorCommands.addCommands({
        JustifyLeft: s("left"),
        JustifyCenter: s("center"),
        JustifyRight: s("right"),
        JustifyFull: s("justify"),
        JustifyNone: s("none")
      });
    }, bae = (e) => {
      const n = (s) => () => {
        const i = e.selection, u = i.isCollapsed() ? [e.dom.getParent(i.getNode(), e.dom.isBlock)] : i.getSelectedBlocks();
        return Vn(u, (p) => Ue(e.formatter.matchNode(p, s)));
      };
      e.editorCommands.addCommands({
        JustifyLeft: n("alignleft"),
        JustifyCenter: n("aligncenter"),
        JustifyRight: n("alignright"),
        JustifyFull: n("alignjustify")
      }, "state");
    }, mz = (e) => {
      vae(e), bae(e);
    }, pz = (e) => {
      e.editorCommands.addCommands({
        "Cut,Copy,Paste": (n) => {
          const s = e.getDoc();
          let i;
          try {
            s.execCommand(n);
          } catch {
            i = !0;
          }
          if (n === "paste" && !s.queryCommandEnabled(n) && (i = !0), i || !s.queryCommandSupported(n)) {
            let u = e.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.");
            (sn.os.isMacOS() || sn.os.isiOS()) && (u = u.replace(/Ctrl\+/g, "⌘+")), e.notificationManager.open({
              text: u,
              type: "error"
            });
          }
        }
      });
    }, xJ = (e, n, s, i) => {
      const u = Me.fromDom(e.getRoot());
      return YC(u, gt.fromRangeStart(n), i) ? s = s.replace(/^ /, "&nbsp;") : s = s.replace(/^&nbsp;/, " "), XC(u, gt.fromRangeEnd(n), i) ? s = s.replace(/(&nbsp;| )(<br( \/)>)?$/, "&nbsp;") : s = s.replace(/&nbsp;(<br( \/)?>)?$/, " "), s;
    }, wJ = (e) => {
      if (typeof e != "string") {
        const n = Kt.extend({
          paste: e.paste,
          data: { paste: e.paste }
        }, e);
        return {
          content: e.content,
          details: n
        };
      }
      return {
        content: e,
        details: {}
      };
    }, CJ = (e, n) => {
      const s = e.selection, i = e.dom;
      return /^ | $/.test(n) ? xJ(i, s.getRng(), n, e.schema) : n;
    }, s5 = (e, n) => {
      if (e.selection.isEditable()) {
        const { content: s, details: i } = wJ(n);
        kN(e, {
          ...i,
          content: CJ(e, s),
          format: "html",
          set: !1,
          selection: !0
        }).each((u) => {
          const p = f6(e, u.content, i);
          _N(e, p, u), e.addVisual();
        });
      }
    }, yae = (e) => {
      e.editorCommands.addCommands({
        mceCleanup: () => {
          const n = e.selection.getBookmark();
          e.setContent(e.getContent()), e.selection.moveToBookmark(n);
        },
        insertImage: (n, s, i) => {
          s5(e, e.dom.createHTML("img", { src: i }));
        },
        insertHorizontalRule: () => {
          e.execCommand("mceInsertContent", !1, "<hr>");
        },
        insertText: (n, s, i) => {
          s5(e, e.dom.encode(i));
        },
        insertHTML: (n, s, i) => {
          s5(e, i);
        },
        mceInsertContent: (n, s, i) => {
          s5(e, i);
        },
        mceSetContent: (n, s, i) => {
          e.setContent(i);
        },
        mceReplaceContent: (n, s, i) => {
          e.execCommand("mceInsertContent", !1, i.replace(/\{\$selection\}/g, e.selection.getContent({ format: "text" })));
        },
        mceNewDocument: () => {
          e.setContent(oE(e));
        }
      });
    }, xae = {
      "font-size": "size",
      "font-family": "face"
    }, SJ = Sr("font"), wae = (e, n, s) => {
      const i = (p) => Sl(p, e).orThunk(() => SJ(p) ? _s(xae, e).bind((b) => ua(p, b)) : X.none()), u = (p) => Bs(Me.fromDom(n), p);
      return LR(Me.fromDom(s), (p) => i(p), u);
    }, kJ = (e) => e.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ","), w0 = (e, n) => X.from(Kr.DOM.getStyle(n, e, !0)), B3 = (e) => (n, s) => X.from(s).map(Me.fromDom).filter(nt).bind((i) => wae(e, n, i.dom).or(w0(e, i.dom))).getOr(""), L3 = B3("font-size"), hz = B(kJ, B3("font-family")), gz = (e) => jl(e.getBody()).bind((n) => {
      const s = n.container();
      return X.from(Gt(s) ? s.parentNode : s);
    }), vz = (e) => X.from(e.selection.getRng()).bind((n) => {
      const s = e.getBody();
      return n.startContainer === s && n.startOffset === 0 ? X.none() : X.from(e.selection.getStart(!0));
    }), _J = (e, n) => vz(e).orThunk(Je(gz, e)).map(Me.fromDom).filter(nt).bind(n), r5 = (e, n) => _J(e, fn(X.some, n)), bz = (e, n) => {
      if (/^[0-9.]+$/.test(n)) {
        const s = parseInt(n, 10);
        if (s >= 1 && s <= 7) {
          const i = th(e), u = JO(e);
          return u.length > 0 ? u[s - 1] || n : i[s - 1] || n;
        } else
          return n;
      } else
        return n;
    }, EJ = (e) => {
      const n = e.split(/\s*,\s*/);
      return tn(n, (s) => s.indexOf(" ") !== -1 && !(co(s, '"') || co(s, "'")) ? `'${s}'` : s).join(",");
    }, TJ = (e, n) => {
      const s = bz(e, n);
      e.formatter.toggle("fontname", { value: EJ(s) }), e.nodeChanged();
    }, AJ = (e) => r5(e, (n) => hz(e.getBody(), n.dom)).getOr(""), Ab = (e, n) => {
      e.formatter.toggle("fontsize", { value: bz(e, n) }), e.nodeChanged();
    }, OJ = (e) => r5(e, (n) => L3(e.getBody(), n.dom)).getOr(""), yz = (e) => r5(e, (n) => {
      const s = Me.fromDom(e.getBody()), i = LR(n, (p) => Sl(p, "line-height"), Je(Bs, s)), u = () => {
        const p = parseFloat(da(n, "line-height")), b = parseFloat(da(n, "font-size"));
        return String(p / b);
      };
      return i.getOrThunk(u);
    }).getOr(""), DJ = (e, n) => {
      e.formatter.toggle("lineheight", { value: String(n) }), e.nodeChanged();
    }, $3 = (e) => {
      const n = (s, i) => {
        e.formatter.toggle(s, i), e.nodeChanged();
      };
      e.editorCommands.addCommands({
        "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (s) => {
          n(s);
        },
        "ForeColor,HiliteColor": (s, i, u) => {
          n(s, { value: u });
        },
        BackColor: (s, i, u) => {
          n("hilitecolor", { value: u });
        },
        FontName: (s, i, u) => {
          TJ(e, u);
        },
        FontSize: (s, i, u) => {
          Ab(e, u);
        },
        LineHeight: (s, i, u) => {
          DJ(e, u);
        },
        Lang: (s, i, u) => {
          var p;
          n(s, {
            value: u.code,
            customValue: (p = u.customCode) !== null && p !== void 0 ? p : null
          });
        },
        RemoveFormat: (s) => {
          e.formatter.remove(s);
        },
        mceBlockQuote: () => {
          n("blockquote");
        },
        FormatBlock: (s, i, u) => {
          n(U(u) ? u : "p");
        },
        mceToggleFormat: (s, i, u) => {
          n(u);
        }
      });
    }, RJ = (e) => {
      const n = (s) => e.formatter.match(s);
      e.editorCommands.addCommands({
        "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (s) => n(s),
        mceBlockQuote: () => n("blockquote")
      }, "state"), e.editorCommands.addQueryValueHandler("FontName", () => AJ(e)), e.editorCommands.addQueryValueHandler("FontSize", () => OJ(e)), e.editorCommands.addQueryValueHandler("LineHeight", () => yz(e));
    }, NJ = (e) => {
      $3(e), RJ(e);
    }, PJ = (e) => {
      e.editorCommands.addCommands({
        mceAddUndoLevel: () => {
          e.undoManager.add();
        },
        mceEndUndoLevel: () => {
          e.undoManager.add();
        },
        Undo: () => {
          e.undoManager.undo();
        },
        Redo: () => {
          e.undoManager.redo();
        }
      });
    }, xz = (e) => {
      e.editorCommands.addCommands({
        Indent: () => {
          hq(e);
        },
        Outdent: () => {
          NP(e);
        }
      }), e.editorCommands.addCommands({ Outdent: () => Zg(e) }, "state");
    }, MJ = (e) => {
      const n = (s, i, u) => {
        const p = U(u) ? { href: u } : u, b = e.dom.getParent(e.selection.getNode(), "a");
        ve(p) && U(p.href) && (p.href = p.href.replace(/ /g, "%20"), (!b || !p.href) && e.formatter.remove("link"), p.href && e.formatter.apply("link", p, b));
      };
      e.editorCommands.addCommands({
        unlink: () => {
          if (e.selection.isEditable()) {
            if (e.selection.isCollapsed()) {
              const s = e.dom.getParent(e.selection.getStart(), "a");
              s && e.dom.remove(s, !0);
              return;
            }
            e.formatter.remove("link");
          }
        },
        mceInsertLink: n,
        createLink: n
      });
    }, IJ = (e, n, s, i) => {
      const u = e.dom, p = (S) => u.isBlock(S) && S.parentElement === s, b = p(n) ? n : u.getParent(i, p, s);
      return X.from(b).map(Me.fromDom);
    }, wz = (e, n) => {
      const s = e.dom, i = e.selection.getRng(), u = n ? e.selection.getStart() : e.selection.getEnd(), p = n ? i.startContainer : i.endContainer, b = rk(s, p);
      if (!b || !b.isContentEditable)
        return;
      const S = n ? Ki : tc, T = Dl(e);
      IJ(e, u, b, p).each((M) => {
        const j = aY(e, p, M.dom, b, !1, T);
        S(M, Me.fromDom(j)), e.selection.setCursorLocation(j, 0), e.dispatch("NewBlock", { newBlock: j }), Sb(e, "insertParagraph");
      });
    }, FJ = (e) => wz(e, !0), a5 = (e) => wz(e, !1), BJ = (e) => {
      e.editorCommands.addCommands({
        InsertNewBlockBefore: () => {
          FJ(e);
        },
        InsertNewBlockAfter: () => {
          a5(e);
        }
      });
    }, LJ = (e) => {
      e.editorCommands.addCommands({
        insertParagraph: () => {
          l2(x7, e);
        },
        mceInsertNewLine: (n, s, i) => {
          t3(e, i);
        },
        InsertLineBreak: (n, s, i) => {
          l2(vM, e);
        }
      });
    }, zi = (e) => {
      e.editorCommands.addCommands({
        mceSelectNodeDepth: (n, s, i) => {
          let u = 0;
          e.dom.getParent(e.selection.getNode(), (p) => Tn(p) && u++ === i ? (e.selection.select(p), !1) : !0, e.getBody());
        },
        mceSelectNode: (n, s, i) => {
          e.selection.select(i);
        },
        selectAll: () => {
          const n = e.dom.getParent(e.selection.getStart(), Mt);
          if (n) {
            const s = e.dom.createRng();
            s.selectNodeContents(n), e.selection.setRng(s);
          }
        }
      });
    }, $J = (e) => {
      e.editorCommands.addCommands({
        mceRemoveNode: (n, s, i) => {
          const u = i ?? e.selection.getNode();
          if (u !== e.getBody()) {
            const p = e.selection.getBookmark();
            e.dom.remove(u, !0), e.selection.moveToBookmark(p);
          }
        },
        mcePrint: () => {
          e.getWin().print();
        },
        mceFocus: (n, s, i) => {
          YD(e, i === !0);
        },
        mceToggleVisualAid: () => {
          e.hasVisual = !e.hasVisual, e.addVisual();
        }
      });
    }, HJ = (e) => {
      mz(e), pz(e), PJ(e), zi(e), yae(e), MJ(e), xz(e), BJ(e), LJ(e), NJ(e), $J(e);
    }, i5 = ["toggleview"], l5 = (e) => Nt(i5, e.toLowerCase());
    class H3 {
      constructor(n) {
        this.commands = {
          state: {},
          exec: {},
          value: {}
        }, this.editor = n;
      }
      execCommand(n, s = !1, i, u) {
        const p = this.editor, b = n.toLowerCase(), S = u == null ? void 0 : u.skip_focus;
        if (p.removed || (b !== "mcefocus" && (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(b) && !S ? p.focus() : iF(p)), p.dispatch("BeforeExecCommand", {
          command: n,
          ui: s,
          value: i
        }).isDefaultPrevented()))
          return !1;
        const M = this.commands.exec[b];
        return Ce(M) ? (M(b, s, i), p.dispatch("ExecCommand", {
          command: n,
          ui: s,
          value: i
        }), !0) : !1;
      }
      queryCommandState(n) {
        if (!l5(n) && this.editor.quirks.isHidden() || this.editor.removed)
          return !1;
        const s = n.toLowerCase(), i = this.commands.state[s];
        return Ce(i) ? i(s) : !1;
      }
      queryCommandValue(n) {
        if (!l5(n) && this.editor.quirks.isHidden() || this.editor.removed)
          return "";
        const s = n.toLowerCase(), i = this.commands.value[s];
        return Ce(i) ? i(s) : "";
      }
      addCommands(n, s = "exec") {
        const i = this.commands;
        qt(n, (u, p) => {
          je(p.toLowerCase().split(","), (b) => {
            i[s][b] = u;
          });
        });
      }
      addCommand(n, s, i) {
        const u = n.toLowerCase();
        this.commands.exec[u] = (p, b, S) => s.call(i ?? this.editor, b, S);
      }
      queryCommandSupported(n) {
        const s = n.toLowerCase();
        return !!this.commands.exec[s];
      }
      addQueryStateHandler(n, s, i) {
        this.commands.state[n.toLowerCase()] = () => s.call(i ?? this.editor);
      }
      addQueryValueHandler(n, s, i) {
        this.commands.value[n.toLowerCase()] = () => s.call(i ?? this.editor);
      }
    }
    const C0 = "data-mce-contenteditable", zJ = (e, n, s) => {
      Bf(e, n) && !s ? fu(e, n) : s && gd(e, n);
    }, c5 = (e, n, s) => {
      try {
        e.getDoc().execCommand(n, !1, String(s));
      } catch {
      }
    }, z3 = (e, n) => {
      e.dom.contentEditable = n ? "true" : "false";
    }, VJ = (e) => {
      je(va(e, '*[contenteditable="true"]'), (n) => {
        is(n, C0, "true"), z3(n, !1);
      });
    }, UJ = (e) => {
      je(va(e, `*[${C0}="true"]`), (n) => {
        Jr(n, C0), z3(n, !0);
      });
    }, jJ = (e) => {
      X.from(e.selection.getNode()).each((n) => {
        n.removeAttribute("data-mce-selected");
      });
    }, WJ = (e) => {
      e.selection.setRng(e.selection.getRng());
    }, h2 = (e, n) => {
      const s = Me.fromDom(e.getBody());
      zJ(s, "mce-content-readonly", n), n ? (e.selection.controlSelection.hideResizeRect(), e._selectionOverrides.hideFakeCaret(), jJ(e), e.readonly = !0, z3(s, !1), VJ(s)) : (e.readonly = !1, e.hasEditableRoot() && z3(s, !0), UJ(s), c5(e, "StyleWithCSS", !1), c5(e, "enableInlineTableEditing", !1), c5(e, "enableObjectResizing", !1), GC(e) && e.focus(), WJ(e), e.nodeChanged());
    }, au = (e) => e.readonly, Cz = (e) => {
      e.parser.addAttributeFilter("contenteditable", (n) => {
        au(e) && je(n, (s) => {
          s.attr(C0, s.attr("contenteditable")), s.attr("contenteditable", "false");
        });
      }), e.serializer.addAttributeFilter(C0, (n) => {
        au(e) && je(n, (s) => {
          s.attr("contenteditable", s.attr(C0));
        });
      }), e.serializer.addTempAttr(C0);
    }, ZJ = (e) => {
      e.serializer ? Cz(e) : e.on("PreInit", () => {
        Cz(e);
      });
    }, GJ = (e) => e.type === "click", qJ = ["copy"], KJ = (e) => Nt(qJ, e.type), YJ = (e, n) => mu(n, "a", (i) => Bs(i, Me.fromDom(e.getBody()))).bind((i) => ua(i, "href")), XJ = (e, n) => {
      if (GJ(n) && !Qt.metaKeyPressed(n)) {
        const s = Me.fromDom(n.target);
        YJ(e, s).each((i) => {
          if (n.preventDefault(), /^#/.test(i)) {
            const u = e.dom.select(`${i},[name="${Gn(i, "#")}"]`);
            u.length && e.selection.scrollIntoView(u[0], !0);
          } else
            window.open(i, "_blank", "rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes");
        });
      } else KJ(n) && e.dispatch(n.type, n);
    }, QJ = (e) => {
      e.on("ShowCaret", (n) => {
        au(e) && n.preventDefault();
      }), e.on("ObjectSelected", (n) => {
        au(e) && n.preventDefault();
      });
    }, JJ = Kt.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel", " ");
    class Sz {
      static isNative(n) {
        return !!JJ[n.toLowerCase()];
      }
      constructor(n) {
        this.bindings = {}, this.settings = n || {}, this.scope = this.settings.scope || this, this.toggleEvent = this.settings.toggleEvent || et;
      }
      fire(n, s) {
        return this.dispatch(n, s);
      }
      dispatch(n, s) {
        const i = n.toLowerCase(), u = iw(i, s ?? {}, this.scope);
        this.settings.beforeFire && this.settings.beforeFire(u);
        const p = this.bindings[i];
        if (p)
          for (let b = 0, S = p.length; b < S; b++) {
            const T = p[b];
            if (!T.removed) {
              if (T.once && this.off(i, T.func), u.isImmediatePropagationStopped())
                return u;
              if (T.func.call(this.scope, u) === !1)
                return u.preventDefault(), u;
            }
          }
        return u;
      }
      on(n, s, i, u) {
        if (s === !1 && (s = et), s) {
          const p = {
            func: s,
            removed: !1
          };
          u && Kt.extend(p, u);
          const b = n.toLowerCase().split(" ");
          let S = b.length;
          for (; S--; ) {
            const T = b[S];
            let M = this.bindings[T];
            M || (M = [], this.toggleEvent(T, !0)), i ? M = [
              p,
              ...M
            ] : M = [
              ...M,
              p
            ], this.bindings[T] = M;
          }
        }
        return this;
      }
      off(n, s) {
        if (n) {
          const i = n.toLowerCase().split(" ");
          let u = i.length;
          for (; u--; ) {
            const p = i[u];
            let b = this.bindings[p];
            if (!p)
              return qt(this.bindings, (S, T) => {
                this.toggleEvent(T, !1), delete this.bindings[T];
              }), this;
            if (b) {
              if (!s)
                b.length = 0;
              else {
                const S = qn(b, (T) => T.func === s);
                b = S.fail, this.bindings[p] = b, je(S.pass, (T) => {
                  T.removed = !0;
                });
              }
              b.length || (this.toggleEvent(n, !1), delete this.bindings[p]);
            }
          }
        } else
          qt(this.bindings, (i, u) => {
            this.toggleEvent(u, !1);
          }), this.bindings = {};
        return this;
      }
      once(n, s, i) {
        return this.on(n, s, i, { once: !0 });
      }
      has(n) {
        n = n.toLowerCase();
        const s = this.bindings[n];
        return !(!s || s.length === 0);
      }
    }
    const Ck = (e) => (e._eventDispatcher || (e._eventDispatcher = new Sz({
      scope: e,
      toggleEvent: (n, s) => {
        Sz.isNative(n) && e.toggleNativeEvent && e.toggleNativeEvent(n, s);
      }
    })), e._eventDispatcher), u5 = {
      fire(e, n, s) {
        return this.dispatch(e, n, s);
      },
      dispatch(e, n, s) {
        const i = this;
        if (i.removed && e !== "remove" && e !== "detach")
          return iw(e.toLowerCase(), n ?? {}, i);
        const u = Ck(i).dispatch(e, n);
        if (s !== !1 && i.parent) {
          let p = i.parent();
          for (; p && !u.isPropagationStopped(); )
            p.dispatch(e, u, !1), p = p.parent ? p.parent() : void 0;
        }
        return u;
      },
      on(e, n, s) {
        return Ck(this).on(e, n, s);
      },
      off(e, n) {
        return Ck(this).off(e, n);
      },
      once(e, n) {
        return Ck(this).once(e, n);
      },
      hasEventListeners(e) {
        return Ck(this).has(e);
      }
    }, V3 = Kr.DOM;
    let S0;
    const U3 = (e, n) => {
      if (n === "selectionchange")
        return e.getDoc();
      if (!e.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(n))
        return e.getDoc().documentElement;
      const s = hf(e);
      return s ? (e.eventRoot || (e.eventRoot = V3.select(s)[0]), e.eventRoot) : e.getBody();
    }, eee = (e) => !e.hidden && !au(e), tee = (e, n, s) => {
      eee(e) ? e.dispatch(n, s) : au(e) && XJ(e, s);
    }, kz = (e, n) => {
      if (e.delegates || (e.delegates = {}), e.delegates[n] || e.removed)
        return;
      const s = U3(e, n);
      if (hf(e)) {
        if (S0 || (S0 = {}, e.editorManager.on("removeEditor", () => {
          e.editorManager.activeEditor || S0 && (qt(S0, (u, p) => {
            e.dom.unbind(U3(e, p));
          }), S0 = null);
        })), S0[n])
          return;
        const i = (u) => {
          const p = u.target, b = e.editorManager.get();
          let S = b.length;
          for (; S--; ) {
            const T = b[S].getBody();
            (T === p || V3.isChildOf(p, T)) && tee(b[S], n, u);
          }
        };
        S0[n] = i, V3.bind(s, n, i);
      } else {
        const i = (u) => {
          tee(e, n, u);
        };
        V3.bind(s, n, i), e.delegates[n] = i;
      }
    }, _z = {
      ...u5,
      bindPendingEventDelegates() {
        const e = this;
        Kt.each(e._pendingNativeEvents, (n) => {
          kz(e, n);
        });
      },
      toggleNativeEvent(e, n) {
        const s = this;
        e === "focus" || e === "blur" || s.removed || (n ? s.initialized ? kz(s, e) : s._pendingNativeEvents ? s._pendingNativeEvents.push(e) : s._pendingNativeEvents = [e] : s.initialized && s.delegates && (s.dom.unbind(U3(s, e), e, s.delegates[e]), delete s.delegates[e]));
      },
      unbindAllNativeEvents() {
        const e = this, n = e.getBody(), s = e.dom;
        e.delegates && (qt(e.delegates, (i, u) => {
          e.dom.unbind(U3(e, u), u, i);
        }), delete e.delegates), !e.inline && n && s && (n.onload = null, s.unbind(e.getWin()), s.unbind(e.getDoc())), s && (s.unbind(n), s.unbind(e.getContainer()));
      }
    }, nee = (e) => U(e) ? {
      value: e.split(/[ ,]/),
      valid: !0
    } : _t(e, U) ? {
      value: e,
      valid: !0
    } : {
      valid: !1,
      message: "The value must be a string[] or a comma/space separated string."
    }, oee = (e) => {
      const n = (() => {
        switch (e) {
          case "array":
            return rt;
          case "boolean":
            return lt;
          case "function":
            return Ce;
          case "number":
            return Rn;
          case "object":
            return ve;
          case "string":
            return U;
          case "string[]":
            return nee;
          case "object[]":
            return (s) => _t(s, ve);
          case "regexp":
            return (s) => oe(s, RegExp);
          default:
            return xt;
        }
      })();
      return (s) => d5(s, n, `The value must be a ${e}.`);
    }, see = (e) => U(e.processor), Ez = (e, n) => {
      const s = Zo(n.message) ? "" : `. ${n.message}`;
      return e + s;
    }, Tz = (e) => e.valid, d5 = (e, n, s = "") => {
      const i = n(e);
      return lt(i) ? i ? {
        value: e,
        valid: !0
      } : {
        valid: !1,
        message: s
      } : i;
    }, ree = (e, n, s) => {
      if (!wt(n)) {
        const i = d5(n, s);
        if (Tz(i))
          return i.value;
        console.error(Ez(`Invalid default value passed for the "${e}" option`, i));
      }
    }, aee = (e, n, s = n) => {
      const i = {}, u = {}, p = (ue, we, fe) => {
        const ke = d5(we, fe);
        return Tz(ke) ? (u[ue] = ke.value, !0) : (console.warn(Ez(`Invalid value passed for the ${ue} option`, ke)), !1);
      }, b = (ue, we) => {
        const fe = see(we) ? oee(we.processor) : we.processor, ke = ree(ue, we.default, fe);
        i[ue] = {
          ...we,
          default: ke,
          processor: fe
        }, _s(u, ue).orThunk(() => _s(n, ue)).each((Ye) => p(ue, Ye, fe));
      }, S = (ue) => Xn(i, ue);
      return {
        register: b,
        isRegistered: S,
        get: (ue) => _s(u, ue).orThunk(() => _s(i, ue).map((we) => we.default)).getOrUndefined(),
        set: (ue, we) => {
          if (S(ue)) {
            const fe = i[ue];
            return fe.immutable ? (console.error(`"${ue}" is an immutable option and cannot be updated`), !1) : p(ue, we, fe.processor);
          } else
            return console.warn(`"${ue}" is not a registered option. Ensure the option has been registered before setting a value.`), !1;
        },
        unset: (ue) => {
          const we = S(ue);
          return we && delete u[ue], we;
        },
        isSet: (ue) => Xn(u, ue),
        debug: () => {
          try {
            console.log(JSON.parse(JSON.stringify(s, (ue, we) => lt(we) || Rn(we) || U(we) || ee(we) || rt(we) || Ze(we) ? we : Object.prototype.toString.call(we))));
          } catch (ue) {
            console.error(ue);
          }
        }
      };
    }, iee = [
      "design",
      "readonly"
    ], Az = (e, n, s, i) => {
      const u = s[n.get()], p = s[i];
      try {
        p.activate();
      } catch (b) {
        console.error(`problem while activating editor mode ${i}:`, b);
        return;
      }
      u.deactivate(), u.editorReadOnly !== p.editorReadOnly && h2(e, p.editorReadOnly), n.set(i), ED(e, i);
    }, lee = (e, n, s, i) => {
      if (i !== s.get()) {
        if (!Xn(n, i))
          throw new Error(`Editor mode '${i}' is invalid`);
        e.initialized ? Az(e, s, n, i) : e.on("init", () => Az(e, s, n, i));
      }
    }, cee = (e, n, s) => {
      if (Nt(iee, n))
        throw new Error(`Cannot override default mode ${n}`);
      return {
        ...e,
        [n]: {
          ...s,
          deactivate: () => {
            try {
              s.deactivate();
            } catch (i) {
              console.error(`problem while deactivating editor mode ${n}:`, i);
            }
          }
        }
      };
    }, uee = (e) => {
      const n = Xe("design"), s = Xe({
        design: {
          activate: ot,
          deactivate: ot,
          editorReadOnly: !1
        },
        readonly: {
          activate: ot,
          deactivate: ot,
          editorReadOnly: !0
        }
      });
      return ZJ(e), QJ(e), {
        isReadOnly: () => au(e),
        set: (i) => lee(e, s.get(), n, i),
        get: () => n.get(),
        register: (i, u) => {
          s.set(cee(s.get(), i, u));
        }
      };
    }, f5 = Kt.each, j3 = Kt.explode, dee = {
      f1: 112,
      f2: 113,
      f3: 114,
      f4: 115,
      f5: 116,
      f6: 117,
      f7: 118,
      f8: 119,
      f9: 120,
      f10: 121,
      f11: 122,
      f12: 123
    }, Oz = Kt.makeMap("alt,ctrl,shift,meta,access"), fee = (e) => e in Oz, mee = (e) => {
      const n = {}, s = sn.os.isMacOS() || sn.os.isiOS();
      f5(j3(e.toLowerCase(), "+"), (p) => {
        fee(p) ? n[p] = !0 : /^[0-9]{2,}$/.test(p) ? n.keyCode = parseInt(p, 10) : (n.charCode = p.charCodeAt(0), n.keyCode = dee[p] || p.toUpperCase().charCodeAt(0));
      });
      const i = [n.keyCode];
      let u;
      for (u in Oz)
        n[u] ? i.push(u) : n[u] = !1;
      return n.id = i.join(","), n.access && (n.alt = !0, s ? n.ctrl = !0 : n.shift = !0), n.meta && (s ? n.meta = !0 : (n.ctrl = !0, n.meta = !1)), n;
    };
    class Dz {
      constructor(n) {
        this.shortcuts = {}, this.pendingPatterns = [], this.editor = n;
        const s = this;
        n.on("keyup keypress keydown", (i) => {
          (s.hasModifier(i) || s.isFunctionKey(i)) && !i.isDefaultPrevented() && (f5(s.shortcuts, (u) => {
            s.matchShortcut(i, u) && (s.pendingPatterns = u.subpatterns.slice(0), i.type === "keydown" && s.executeShortcutAction(u));
          }), s.matchShortcut(i, s.pendingPatterns[0]) && (s.pendingPatterns.length === 1 && i.type === "keydown" && s.executeShortcutAction(s.pendingPatterns[0]), s.pendingPatterns.shift()));
        });
      }
      add(n, s, i, u) {
        const p = this, b = p.normalizeCommandFunc(i);
        return f5(j3(Kt.trim(n)), (S) => {
          const T = p.createShortcut(S, s, b, u);
          p.shortcuts[T.id] = T;
        }), !0;
      }
      remove(n) {
        const s = this.createShortcut(n);
        return this.shortcuts[s.id] ? (delete this.shortcuts[s.id], !0) : !1;
      }
      normalizeCommandFunc(n) {
        const s = this, i = n;
        return typeof i == "string" ? () => {
          s.editor.execCommand(i, !1, null);
        } : Kt.isArray(i) ? () => {
          s.editor.execCommand(i[0], i[1], i[2]);
        } : i;
      }
      createShortcut(n, s, i, u) {
        const p = Kt.map(j3(n, ">"), mee);
        return p[p.length - 1] = Kt.extend(p[p.length - 1], {
          func: i,
          scope: u || this.editor
        }), Kt.extend(p[0], {
          desc: this.editor.translate(s),
          subpatterns: p.slice(1)
        });
      }
      hasModifier(n) {
        return n.altKey || n.ctrlKey || n.metaKey;
      }
      isFunctionKey(n) {
        return n.type === "keydown" && n.keyCode >= 112 && n.keyCode <= 123;
      }
      matchShortcut(n, s) {
        return !s || s.ctrl !== n.ctrlKey || s.meta !== n.metaKey || s.alt !== n.altKey || s.shift !== n.shiftKey ? !1 : n.keyCode === s.keyCode || n.charCode && n.charCode === s.charCode ? (n.preventDefault(), !0) : !1;
      }
      executeShortcutAction(n) {
        return n.func ? n.func.call(n.scope) : null;
      }
    }
    const pee = () => {
      const e = {}, n = {}, s = {}, i = {}, u = {}, p = {}, b = {}, S = {}, T = (j, W) => (G, ue) => {
        j[G.toLowerCase()] = {
          ...ue,
          type: W
        };
      }, M = (j, W) => i[j.toLowerCase()] = W;
      return {
        addButton: T(e, "button"),
        addGroupToolbarButton: T(e, "grouptoolbarbutton"),
        addToggleButton: T(e, "togglebutton"),
        addMenuButton: T(e, "menubutton"),
        addSplitButton: T(e, "splitbutton"),
        addMenuItem: T(n, "menuitem"),
        addNestedMenuItem: T(n, "nestedmenuitem"),
        addToggleMenuItem: T(n, "togglemenuitem"),
        addAutocompleter: T(s, "autocompleter"),
        addContextMenu: T(u, "contextmenu"),
        addContextToolbar: T(p, "contexttoolbar"),
        addContextForm: T(p, "contextform"),
        addSidebar: T(b, "sidebar"),
        addView: T(S, "views"),
        addIcon: M,
        getAll: () => ({
          buttons: e,
          menuItems: n,
          icons: i,
          popups: s,
          contextMenus: u,
          contextToolbars: p,
          sidebars: b,
          views: S
        })
      };
    }, hee = () => {
      const e = pee();
      return {
        addAutocompleter: e.addAutocompleter,
        addButton: e.addButton,
        addContextForm: e.addContextForm,
        addContextMenu: e.addContextMenu,
        addContextToolbar: e.addContextToolbar,
        addIcon: e.addIcon,
        addMenuButton: e.addMenuButton,
        addMenuItem: e.addMenuItem,
        addNestedMenuItem: e.addNestedMenuItem,
        addSidebar: e.addSidebar,
        addSplitButton: e.addSplitButton,
        addToggleButton: e.addToggleButton,
        addGroupToolbarButton: e.addGroupToolbarButton,
        addToggleMenuItem: e.addToggleMenuItem,
        addView: e.addView,
        getAll: e.getAll
      };
    }, k0 = Kr.DOM, m5 = Kt.extend, gee = Kt.each;
    class W3 {
      constructor(n, s, i) {
        this.plugins = {}, this.contentCSS = [], this.contentStyles = [], this.loadedCSS = {}, this.isNotDirty = !1, this.composing = !1, this.destroyed = !1, this.hasHiddenInput = !1, this.iframeElement = null, this.initialized = !1, this.readonly = !1, this.removed = !1, this.startContent = "", this._pendingNativeEvents = [], this._skinLoaded = !1, this._editableRoot = !0, this.editorManager = i, this.documentBaseUrl = i.documentBaseURL, m5(this, _z);
        const u = this;
        this.id = n, this.hidden = !1;
        const p = bJ(i.defaultOptions, s);
        this.options = aee(u, p, s), Uv(u);
        const b = this.options.get;
        b("deprecation_warnings") && MZ(s, p);
        const S = b("suffix");
        S && (i.suffix = S), this.suffix = i.suffix;
        const T = b("base_url");
        T && i._setBaseUrl(T), this.baseUri = i.baseURI;
        const M = Ty(u);
        M && (cf.ScriptLoader._setReferrerPolicy(M), Kr.DOM.styleSheetLoader._setReferrerPolicy(M));
        const j = J_(u);
        Ue(j) && Kr.DOM.styleSheetLoader._setContentCssCors(j), ac.languageLoad = b("language_load"), ac.baseURL = i.baseURL, this.setDirty(!1), this.documentBaseURI = new hc(el(u), { base_uri: this.baseUri }), this.baseURI = this.baseUri, this.inline = xg(u), this.hasVisual = uc(u), this.shortcuts = new Dz(this), this.editorCommands = new H3(this), HJ(this);
        const W = b("cache_suffix");
        W && (sn.cacheSuffix = W.replace(/^[\?\&]+/, "")), this.ui = {
          registry: hee(),
          styleSheetLoader: void 0,
          show: ot,
          hide: ot,
          setEnabled: ot,
          isEnabled: xt
        }, this.mode = uee(u), i.dispatch("SetupEditor", { editor: this });
        const G = Ry(u);
        Ce(G) && G.call(u, u);
      }
      render() {
        iz(this);
      }
      focus(n) {
        this.execCommand("mceFocus", !1, n);
      }
      hasFocus() {
        return H1(this);
      }
      translate(n) {
        return Fi.translate(n);
      }
      getParam(n, s, i) {
        const u = this.options;
        return u.isRegistered(n) || (Ue(i) ? u.register(n, {
          processor: i,
          default: s
        }) : u.register(n, {
          processor: xt,
          default: s
        })), !u.isSet(n) && !wt(s) ? s : u.get(n);
      }
      hasPlugin(n, s) {
        return Nt(b1(this), n) ? s ? Hx.get(n) !== void 0 : !0 : !1;
      }
      nodeChanged(n) {
        this._nodeChangeDispatcher.nodeChanged(n);
      }
      addCommand(n, s, i) {
        this.editorCommands.addCommand(n, s, i);
      }
      addQueryStateHandler(n, s, i) {
        this.editorCommands.addQueryStateHandler(n, s, i);
      }
      addQueryValueHandler(n, s, i) {
        this.editorCommands.addQueryValueHandler(n, s, i);
      }
      addShortcut(n, s, i, u) {
        this.shortcuts.add(n, s, i, u);
      }
      execCommand(n, s, i, u) {
        return this.editorCommands.execCommand(n, s, i, u);
      }
      queryCommandState(n) {
        return this.editorCommands.queryCommandState(n);
      }
      queryCommandValue(n) {
        return this.editorCommands.queryCommandValue(n);
      }
      queryCommandSupported(n) {
        return this.editorCommands.queryCommandSupported(n);
      }
      show() {
        const n = this;
        n.hidden && (n.hidden = !1, n.inline ? n.getBody().contentEditable = "true" : (k0.show(n.getContainer()), k0.hide(n.id)), n.load(), n.dispatch("show"));
      }
      hide() {
        const n = this;
        n.hidden || (n.save(), n.inline ? (n.getBody().contentEditable = "false", n === n.editorManager.focusedEditor && (n.editorManager.focusedEditor = null)) : (k0.hide(n.getContainer()), k0.setStyle(n.id, "display", n.orgDisplay)), n.hidden = !0, n.dispatch("hide"));
      }
      isHidden() {
        return this.hidden;
      }
      setProgressState(n, s) {
        this.dispatch("ProgressState", {
          state: n,
          time: s
        });
      }
      load(n = {}) {
        const s = this, i = s.getElement();
        if (s.removed)
          return "";
        if (i) {
          const u = {
            ...n,
            load: !0
          }, p = ra(i) ? i.value : i.innerHTML, b = s.setContent(p, u);
          return u.no_events || s.dispatch("LoadContent", {
            ...u,
            element: i
          }), b;
        } else
          return "";
      }
      save(n = {}) {
        const s = this;
        let i = s.getElement();
        if (!i || !s.initialized || s.removed)
          return "";
        const u = {
          ...n,
          save: !0,
          element: i
        };
        let p = s.getContent(u);
        const b = {
          ...u,
          content: p
        };
        if (b.no_events || s.dispatch("SaveContent", b), b.format === "raw" && s.dispatch("RawSaveContent", b), p = b.content, ra(i))
          i.value = p;
        else {
          (n.is_removing || !s.inline) && (i.innerHTML = p);
          const S = k0.getParent(s.id, "form");
          S && gee(S.elements, (T) => T.name === s.id ? (T.value = p, !1) : !0);
        }
        return b.element = u.element = i = null, b.set_dirty !== !1 && s.setDirty(!1), p;
      }
      setContent(n, s) {
        return HN(this, n, s);
      }
      getContent(n) {
        return cA(this, n);
      }
      insertContent(n, s) {
        s && (n = m5({ content: n }, s)), this.execCommand("mceInsertContent", !1, n);
      }
      resetContent(n) {
        n === void 0 ? HN(this, this.startContent, { format: "raw" }) : HN(this, n), this.undoManager.reset(), this.setDirty(!1), this.nodeChanged();
      }
      isDirty() {
        return !this.isNotDirty;
      }
      setDirty(n) {
        const s = !this.isNotDirty;
        this.isNotDirty = !n, n && n !== s && this.dispatch("dirty");
      }
      getContainer() {
        const n = this;
        return n.container || (n.container = n.editorContainer || k0.get(n.id + "_parent")), n.container;
      }
      getContentAreaContainer() {
        return this.contentAreaContainer;
      }
      getElement() {
        return this.targetElm || (this.targetElm = k0.get(this.id)), this.targetElm;
      }
      getWin() {
        const n = this;
        if (!n.contentWindow) {
          const s = n.iframeElement;
          s && (n.contentWindow = s.contentWindow);
        }
        return n.contentWindow;
      }
      getDoc() {
        const n = this;
        if (!n.contentDocument) {
          const s = n.getWin();
          s && (n.contentDocument = s.document);
        }
        return n.contentDocument;
      }
      getBody() {
        var n, s;
        const i = this.getDoc();
        return (s = (n = this.bodyElement) !== null && n !== void 0 ? n : i == null ? void 0 : i.body) !== null && s !== void 0 ? s : null;
      }
      convertURL(n, s, i) {
        const u = this, p = u.options.get, b = KO(u);
        if (Ce(b))
          return b.call(u, n, i, !0, s);
        if (!p("convert_urls") || i === "link" || ve(i) && i.nodeName === "LINK" || n.indexOf("file:") === 0 || n.length === 0)
          return n;
        const S = new hc(n);
        return S.protocol !== "http" && S.protocol !== "https" && S.protocol !== "" ? n : p("relative_urls") ? u.documentBaseURI.toRelative(n) : (n = u.documentBaseURI.toAbsolute(n, p("remove_script_host")), n);
      }
      addVisual(n) {
        yJ(this, n);
      }
      setEditableRoot(n) {
        dJ(this, n);
      }
      hasEditableRoot() {
        return lz(this);
      }
      remove() {
        BZ(this);
      }
      destroy(n) {
        LZ(this, n);
      }
      uploadImages() {
        return this.editorUpload.uploadImages();
      }
      _scanForImages() {
        return this.editorUpload.scanForImages();
      }
    }
    const g2 = Kr.DOM, Z3 = Kt.each;
    let Rz = !1, G3, Tu = [];
    const q3 = (e) => {
      const n = e.type;
      Z3(Yg.get(), (s) => {
        switch (n) {
          case "scroll":
            s.dispatch("ScrollWindow", e);
            break;
          case "resize":
            s.dispatch("ResizeWindow", e);
            break;
        }
      });
    }, p5 = (e) => {
      if (e !== Rz) {
        const n = Kr.DOM;
        e ? (n.bind(window, "resize", q3), n.bind(window, "scroll", q3)) : (n.unbind(window, "resize", q3), n.unbind(window, "scroll", q3)), Rz = e;
      }
    }, vee = (e) => {
      const n = Tu;
      return Tu = on(Tu, (s) => e !== s), Yg.activeEditor === e && (Yg.activeEditor = Tu.length > 0 ? Tu[0] : null), Yg.focusedEditor === e && (Yg.focusedEditor = null), n.length !== Tu.length;
    }, Nz = (e) => {
      e && e.initialized && !(e.getContainer() || e.getBody()).parentNode && (vee(e), e.unbindAllNativeEvents(), e.destroy(!0), e.removed = !0);
    }, bee = document.compatMode !== "CSS1Compat", Yg = {
      ...u5,
      baseURI: null,
      baseURL: null,
      defaultOptions: {},
      documentBaseURL: null,
      suffix: null,
      majorVersion: "7",
      minorVersion: "2.1",
      releaseDate: "2024-07-03",
      i18n: Fi,
      activeEditor: null,
      focusedEditor: null,
      setup() {
        const e = this;
        let n = "", s = "", i = hc.getDocumentBaseUrl(document.location);
        /^[^:]+:\/\/\/?[^\/]+\//.test(i) && (i = i.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(i) || (i += "/"));
        const u = window.tinymce || window.tinyMCEPreInit;
        if (u)
          n = u.base || u.baseURL, s = u.suffix;
        else {
          const p = document.getElementsByTagName("script");
          for (let b = 0; b < p.length; b++) {
            const S = p[b].src || "";
            if (S === "")
              continue;
            const T = S.substring(S.lastIndexOf("/"));
            if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(S)) {
              T.indexOf(".min") !== -1 && (s = ".min"), n = S.substring(0, S.lastIndexOf("/"));
              break;
            }
          }
          if (!n && document.currentScript) {
            const b = document.currentScript.src;
            b.indexOf(".min") !== -1 && (s = ".min"), n = b.substring(0, b.lastIndexOf("/"));
          }
        }
        e.baseURL = new hc(i).toAbsolute(n), e.documentBaseURL = i, e.baseURI = new hc(e.baseURL), e.suffix = s, pF(e);
      },
      overrideDefaults(e) {
        const n = e.base_url;
        n && this._setBaseUrl(n);
        const s = e.suffix;
        s && (this.suffix = s), this.defaultOptions = e;
        const i = e.plugin_base_urls;
        i !== void 0 && qt(i, (u, p) => {
          ac.PluginManager.urls[p] = u;
        });
      },
      init(e) {
        const n = this;
        let s;
        const i = Kt.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu", " "), u = (j, W) => j.inline && W.tagName.toLowerCase() in i, p = (j) => {
          let W = j.id;
          return W || (W = _s(j, "name").filter((G) => !g2.get(G)).getOrThunk(g2.uniqueId), j.setAttribute("id", W)), W;
        }, b = (j) => {
          const W = e[j];
          if (W)
            return W.apply(n, []);
        }, S = (j) => sn.browser.isIE() || sn.browser.isEdge() ? (pA("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tiny.cloud/docs/tinymce/7/support/#supportedwebbrowsers"), []) : bee ? (pA("Failed to initialize the editor as the document is not in standards mode. TinyMCE requires standards mode."), []) : U(j.selector) ? g2.select(j.selector) : Ue(j.target) ? [j.target] : [];
        let T = (j) => {
          s = j;
        };
        const M = () => {
          let j = 0;
          const W = [];
          let G;
          const ue = (we, fe, ke) => {
            const He = new W3(we, fe, n);
            W.push(He), He.on("init", () => {
              ++j === G.length && T(W);
            }), He.targetElm = He.targetElm || ke, He.render();
          };
          g2.unbind(window, "ready", M), b("onpageload"), G = ta(S(e)), Kt.each(G, (we) => {
            Nz(n.get(we.id));
          }), G = Kt.grep(G, (we) => !n.get(we.id)), G.length === 0 ? T([]) : Z3(G, (we) => {
            u(e, we) ? pA("Could not initialize inline editor on invalid inline target element", we) : ue(p(we), e, we);
          });
        };
        return g2.bind(window, "ready", M), new Promise((j) => {
          s ? j(s) : T = (W) => {
            j(W);
          };
        });
      },
      get(e) {
        return arguments.length === 0 ? Tu.slice(0) : U(e) ? Dn(Tu, (n) => n.id === e).getOr(null) : Rn(e) && Tu[e] ? Tu[e] : null;
      },
      add(e) {
        const n = this, s = n.get(e.id);
        return s === e || (s === null && Tu.push(e), p5(!0), n.activeEditor = e, n.dispatch("AddEditor", { editor: e }), G3 || (G3 = (i) => {
          const u = n.dispatch("BeforeUnload");
          if (u.returnValue)
            return i.preventDefault(), i.returnValue = u.returnValue, u.returnValue;
        }, window.addEventListener("beforeunload", G3))), e;
      },
      createEditor(e, n) {
        return this.add(new W3(e, n, this));
      },
      remove(e) {
        const n = this;
        let s;
        if (!e) {
          for (let i = Tu.length - 1; i >= 0; i--)
            n.remove(Tu[i]);
          return;
        }
        if (U(e)) {
          Z3(g2.select(e), (i) => {
            s = n.get(i.id), s && n.remove(s);
          });
          return;
        }
        return s = e, ee(n.get(s.id)) ? null : (vee(s) && n.dispatch("RemoveEditor", { editor: s }), Tu.length === 0 && window.removeEventListener("beforeunload", G3), s.remove(), p5(Tu.length > 0), s);
      },
      execCommand(e, n, s) {
        var i;
        const u = this, p = ve(s) ? (i = s.id) !== null && i !== void 0 ? i : s.index : s;
        switch (e) {
          case "mceAddEditor": {
            if (!u.get(p)) {
              const b = s.options;
              new W3(p, b, u).render();
            }
            return !0;
          }
          case "mceRemoveEditor": {
            const b = u.get(p);
            return b && b.remove(), !0;
          }
          case "mceToggleEditor": {
            const b = u.get(p);
            return b ? (b.isHidden() ? b.show() : b.hide(), !0) : (u.execCommand("mceAddEditor", !1, s), !0);
          }
        }
        return u.activeEditor ? u.activeEditor.execCommand(e, n, s) : !1;
      },
      triggerSave: () => {
        Z3(Tu, (e) => {
          e.save();
        });
      },
      addI18n: (e, n) => {
        Fi.add(e, n);
      },
      translate: (e) => Fi.translate(e),
      setActive(e) {
        const n = this.activeEditor;
        this.activeEditor !== e && (n && n.dispatch("deactivate", { relatedTarget: e }), e.dispatch("activate", { relatedTarget: n })), this.activeEditor = e;
      },
      _setBaseUrl(e) {
        this.baseURL = new hc(this.documentBaseURL).toAbsolute(e.replace(/\/+$/, "")), this.baseURI = new hc(this.baseURL);
      }
    };
    Yg.setup();
    const yee = (() => {
      const e = Ii(), n = (p) => ({
        items: p,
        types: Ms(p),
        getType: (b) => _s(p, b).getOrUndefined()
      }), s = (p) => {
        e.set(p);
      }, i = () => e.get().getOrUndefined(), u = e.clear;
      return {
        FakeClipboardItem: n,
        write: s,
        read: i,
        clear: u
      };
    })(), Pz = Math.min, v2 = Math.max, K3 = Math.round, Mz = (e, n, s) => {
      let i = n.x, u = n.y;
      const p = e.w, b = e.h, S = n.w, T = n.h, M = (s || "").split("");
      return M[0] === "b" && (u += T), M[1] === "r" && (i += S), M[0] === "c" && (u += K3(T / 2)), M[1] === "c" && (i += K3(S / 2)), M[3] === "b" && (u -= b), M[4] === "r" && (i -= p), M[3] === "c" && (u -= K3(b / 2)), M[4] === "c" && (i -= K3(p / 2)), b2(i, u, p, b);
    }, h5 = (e, n, s, i) => {
      for (let u = 0; u < i.length; u++) {
        const p = Mz(e, n, i[u]);
        if (p.x >= s.x && p.x + p.w <= s.w + s.x && p.y >= s.y && p.y + p.h <= s.h + s.y)
          return i[u];
      }
      return null;
    }, g5 = (e, n, s) => b2(e.x - n, e.y - s, e.w + n * 2, e.h + s * 2), xee = (e, n) => {
      const s = v2(e.x, n.x), i = v2(e.y, n.y), u = Pz(e.x + e.w, n.x + n.w), p = Pz(e.y + e.h, n.y + n.h);
      return u - s < 0 || p - i < 0 ? null : b2(s, i, u - s, p - i);
    }, Iz = (e, n, s) => {
      let i = e.x, u = e.y, p = e.x + e.w, b = e.y + e.h;
      const S = n.x + n.w, T = n.y + n.h, M = v2(0, n.x - i), j = v2(0, n.y - u), W = v2(0, p - S), G = v2(0, b - T);
      return i += M, u += j, s && (p += M, b += j, i -= W, u -= G), p -= W, b -= G, b2(i, u, p - i, b - u);
    }, b2 = (e, n, s, i) => ({
      x: e,
      y: n,
      w: s,
      h: i
    }), wee = {
      inflate: g5,
      relativePosition: Mz,
      findBestRelativePosition: h5,
      intersect: xee,
      clamp: Iz,
      create: b2,
      fromClientRect: (e) => b2(e.left, e.top, e.width, e.height)
    }, Cee = (e, n, s = 1e3) => {
      let i = !1, u = null;
      const p = (M) => (...j) => {
        i || (i = !0, u !== null && (clearTimeout(u), u = null), M.apply(null, j));
      }, b = p(e), S = p(n);
      return {
        start: (...M) => {
          !i && u === null && (u = setTimeout(() => S.apply(null, M), s));
        },
        resolve: b,
        reject: S
      };
    }, See = (() => {
      const e = {}, n = {}, s = {};
      return {
        load: (T, M) => {
          const j = `Script at URL "${M}" failed to load`, W = `Script at URL "${M}" did not call \`tinymce.Resource.add('${T}', data)\` within 1 second`;
          if (e[T] !== void 0)
            return e[T];
          {
            const G = new Promise((ue, we) => {
              const fe = Cee(ue, we);
              n[T] = fe.resolve, cf.ScriptLoader.loadScript(M).then(() => fe.start(W), () => fe.reject(j));
            });
            return e[T] = G, G;
          }
        },
        add: (T, M) => {
          n[T] !== void 0 && (n[T](M), delete n[T]), e[T] = Promise.resolve(M), s[T] = M;
        },
        has: (T) => T in s,
        get: (T) => s[T],
        unload: (T) => {
          delete e[T], delete s[T];
        }
      };
    })(), kee = () => (() => {
      let e = {}, n = [];
      const s = {
        getItem: (i) => {
          const u = e[i];
          return u || null;
        },
        setItem: (i, u) => {
          n.push(i), e[i] = String(u);
        },
        key: (i) => n[i],
        removeItem: (i) => {
          n = n.filter((u) => u === i), delete e[i];
        },
        clear: () => {
          n = [], e = {};
        },
        length: 0
      };
      return Object.defineProperty(s, "length", {
        get: () => n.length,
        configurable: !1,
        enumerable: !1
      }), s;
    })();
    let Sk;
    try {
      const e = "__storage_test__";
      Sk = window.localStorage, Sk.setItem(e, e), Sk.removeItem(e);
    } catch {
      Sk = kee();
    }
    var _ee = Sk;
    const Eee = {
      geom: { Rect: wee },
      util: {
        Delay: Rd,
        Tools: Kt,
        VK: Qt,
        URI: hc,
        EventDispatcher: Sz,
        Observable: u5,
        I18n: Fi,
        LocalStorage: _ee,
        ImageUploader: GN
      },
      dom: {
        EventUtils: Vp,
        TreeWalker: Pi,
        TextSeeker: Wp,
        DOMUtils: Kr,
        ScriptLoader: cf,
        RangeUtils: Wt,
        Serializer: LN,
        StyleSheetLoader: vs,
        ControlSelection: M1,
        BookmarkManager: ch,
        Selection: g6,
        Event: Vp.Event
      },
      html: {
        Styles: aw,
        Entities: rf,
        Node: ou,
        Schema: Gf,
        DomParser: gh,
        Writer: RF,
        Serializer: Ig
      },
      Env: sn,
      AddOnManager: ac,
      Annotator: om,
      Formatter: F6,
      UndoManager: XN,
      EditorCommands: H3,
      WindowManager: UN,
      NotificationManager: T6,
      EditorObservable: _z,
      Shortcuts: Dz,
      Editor: W3,
      FocusManager: lF,
      EditorManager: Yg,
      DOM: Kr.DOM,
      ScriptLoader: cf.ScriptLoader,
      PluginManager: Hx,
      ThemeManager: np,
      ModelManager: $x,
      IconManager: Lx,
      Resource: See,
      FakeClipboard: yee,
      trim: Kt.trim,
      isArray: Kt.isArray,
      is: Kt.is,
      toArray: Kt.toArray,
      makeMap: Kt.makeMap,
      each: Kt.each,
      map: Kt.map,
      grep: Kt.grep,
      inArray: Kt.inArray,
      extend: Kt.extend,
      walk: Kt.walk,
      resolve: Kt.resolve,
      explode: Kt.explode,
      _addCacheSuffix: Kt._addCacheSuffix
    }, Y3 = Kt.extend(Yg, Eee), Tee = (e) => {
      try {
        o.exports = e;
      } catch {
      }
    };
    ((e) => {
      window.tinymce = e, window.tinyMCE = e;
    })(Y3), Tee(Y3);
  })();
})(SCe);
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.ModelManager");
  const a = (m, v, C) => {
    var _;
    return C(m, v.prototype) ? !0 : ((_ = m.constructor) === null || _ === void 0 ? void 0 : _.name) === v.name;
  }, c = (m) => {
    const v = typeof m;
    return m === null ? "null" : v === "object" && Array.isArray(m) ? "array" : v === "object" && a(m, String, (C, _) => _.isPrototypeOf(C)) ? "string" : v;
  }, f = (m) => (v) => c(v) === m, g = (m) => (v) => typeof v === m, x = (m) => (v) => m === v, k = f("string"), A = f("object"), N = f("array"), H = x(null), Z = g("boolean"), K = x(void 0), J = (m) => m == null, pe = (m) => !J(m), Se = g("function"), be = g("number"), ye = () => {
  }, re = (m, v) => (...C) => m(v.apply(null, C)), oe = (m, v) => (C) => m(v(C)), U = (m) => () => m, ve = (m) => m, Ze = (m, v) => m === v;
  function rt(m, ...v) {
    return (...C) => {
      const _ = v.concat(C);
      return m.apply(null, _);
    };
  }
  const ee = (m) => (v) => !m(v), lt = (m) => () => {
    throw new Error(m);
  }, wt = (m) => m(), Vt = U(!1), Ue = U(!0);
  class Ce {
    constructor(v, C) {
      this.tag = v, this.value = C;
    }
    static some(v) {
      return new Ce(!0, v);
    }
    static none() {
      return Ce.singletonNone;
    }
    fold(v, C) {
      return this.tag ? C(this.value) : v();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(v) {
      return this.tag ? Ce.some(v(this.value)) : Ce.none();
    }
    bind(v) {
      return this.tag ? v(this.value) : Ce.none();
    }
    exists(v) {
      return this.tag && v(this.value);
    }
    forall(v) {
      return !this.tag || v(this.value);
    }
    filter(v) {
      return !this.tag || v(this.value) ? this : Ce.none();
    }
    getOr(v) {
      return this.tag ? this.value : v;
    }
    or(v) {
      return this.tag ? this : v;
    }
    getOrThunk(v) {
      return this.tag ? this.value : v();
    }
    orThunk(v) {
      return this.tag ? this : v();
    }
    getOrDie(v) {
      if (this.tag)
        return this.value;
      throw new Error(v ?? "Called getOrDie on None");
    }
    static from(v) {
      return pe(v) ? Ce.some(v) : Ce.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(v) {
      this.tag && v(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Ce.singletonNone = new Ce(!1);
  const Rn = Array.prototype.slice, _t = Array.prototype.indexOf, ot = Array.prototype.push, B = (m, v) => _t.call(m, v), fn = (m, v) => B(m, v) > -1, ze = (m, v) => {
    for (let C = 0, _ = m.length; C < _; C++) {
      const P = m[C];
      if (v(P, C))
        return !0;
    }
    return !1;
  }, jt = (m, v) => {
    const C = [];
    for (let _ = 0; _ < m; _++)
      C.push(v(_));
    return C;
  }, Tt = (m, v) => {
    const C = m.length, _ = new Array(C);
    for (let P = 0; P < C; P++) {
      const z = m[P];
      _[P] = v(z, P);
    }
    return _;
  }, Je = (m, v) => {
    for (let C = 0, _ = m.length; C < _; C++) {
      const P = m[C];
      v(P, C);
    }
  }, pn = (m, v) => {
    for (let C = m.length - 1; C >= 0; C--) {
      const _ = m[C];
      v(_, C);
    }
  }, Ro = (m, v) => {
    const C = [], _ = [];
    for (let P = 0, z = m.length; P < z; P++) {
      const Q = m[P];
      (v(Q, P) ? C : _).push(Q);
    }
    return {
      pass: C,
      fail: _
    };
  }, Rt = (m, v) => {
    const C = [];
    for (let _ = 0, P = m.length; _ < P; _++) {
      const z = m[_];
      v(z, _) && C.push(z);
    }
    return C;
  }, Cn = (m, v, C) => (pn(m, (_, P) => {
    C = v(C, _, P);
  }), C), et = (m, v, C) => (Je(m, (_, P) => {
    C = v(C, _, P);
  }), C), xt = (m, v, C) => {
    for (let _ = 0, P = m.length; _ < P; _++) {
      const z = m[_];
      if (v(z, _))
        return Ce.some(z);
      if (C(z, _))
        break;
    }
    return Ce.none();
  }, X = (m, v) => xt(m, v, Vt), ds = (m, v) => {
    for (let C = 0, _ = m.length; C < _; C++) {
      const P = m[C];
      if (v(P, C))
        return Ce.some(C);
    }
    return Ce.none();
  }, So = (m) => {
    const v = [];
    for (let C = 0, _ = m.length; C < _; ++C) {
      if (!N(m[C]))
        throw new Error("Arr.flatten item " + C + " was not an array, input: " + m);
      ot.apply(v, m[C]);
    }
    return v;
  }, At = (m, v) => So(Tt(m, v)), Pt = (m, v) => {
    for (let C = 0, _ = m.length; C < _; ++C) {
      const P = m[C];
      if (v(P, C) !== !0)
        return !1;
    }
    return !0;
  }, Hn = (m) => {
    const v = Rn.call(m, 0);
    return v.reverse(), v;
  }, Nt = (m, v) => {
    const C = {};
    for (let _ = 0, P = m.length; _ < P; _++) {
      const z = m[_];
      C[String(z)] = v(z, _);
    }
    return C;
  }, Vn = (m, v) => {
    const C = Rn.call(m, 0);
    return C.sort(v), C;
  }, tn = (m, v) => v >= 0 && v < m.length ? Ce.some(m[v]) : Ce.none(), je = (m) => tn(m, 0), An = (m) => tn(m, m.length - 1), qn = (m, v) => {
    for (let C = 0; C < m.length; C++) {
      const _ = v(m[C], C);
      if (_.isSome())
        return _;
    }
    return Ce.none();
  }, on = Object.keys, zt = Object.hasOwnProperty, vt = (m, v) => {
    const C = on(m);
    for (let _ = 0, P = C.length; _ < P; _++) {
      const z = C[_], Q = m[z];
      v(Q, z);
    }
  }, oo = (m, v) => Dn(m, (C, _) => ({
    k: _,
    v: v(C, _)
  })), Dn = (m, v) => {
    const C = {};
    return vt(m, (_, P) => {
      const z = v(_, P);
      C[z.k] = z.v;
    }), C;
  }, ao = (m) => (v, C) => {
    m[C] = v;
  }, xs = (m, v, C, _) => {
    vt(m, (P, z) => {
      (v(P, z) ? C : _)(P, z);
    });
  }, rs = (m, v) => {
    const C = {};
    return xs(m, v, ao(C), ye), C;
  }, Qo = (m, v) => {
    const C = [];
    return vt(m, (_, P) => {
      C.push(v(_, P));
    }), C;
  }, os = (m) => Qo(m, ve), zs = (m, v) => it(m, v) ? Ce.from(m[v]) : Ce.none(), it = (m, v) => zt.call(m, v), kt = (m, v) => it(m, v) && m[v] !== void 0 && m[v] !== null, xn = (m) => {
    for (const v in m)
      if (zt.call(m, v))
        return !1;
    return !0;
  }, hn = typeof window < "u" ? window : Function("return this;")(), Do = (m, v) => {
    let C = v ?? hn;
    for (let _ = 0; _ < m.length && C !== void 0 && C !== null; ++_)
      C = C[m[_]];
    return C;
  }, Ss = (m, v) => {
    const C = m.split(".");
    return Do(C, v);
  }, pr = (m, v) => Ss(m, v), ta = (m, v) => {
    const C = pr(m, v);
    if (C == null)
      throw new Error(m + " not available on this browser");
    return C;
  }, Ms = Object.getPrototypeOf, hr = (m) => ta("HTMLElement", m), qt = (m) => {
    const v = Ss("ownerDocument.defaultView", m);
    return A(m) && (hr(v).prototype.isPrototypeOf(m) || /^HTML\w*Element$/.test(Ms(m).constructor.name));
  }, Ko = 8, Lr = 9, ha = 11, ia = 1, na = 3, ks = (m) => m.dom.nodeName.toLowerCase(), xa = (m) => m.dom.nodeType, la = (m) => (v) => xa(v) === m, _s = (m) => xa(m) === Ko || ks(m) === "#comment", Xn = (m) => wr(m) && qt(m.dom), wr = la(ia), Ke = la(na), ht = la(Lr), gn = la(ha), En = (m) => (v) => wr(v) && ks(v) === m, Ao = (m, v, C) => {
    if (k(C) || Z(C) || be(C))
      m.setAttribute(v, C + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", v, ":: Value ", C, ":: Element ", m), new Error("Attribute value was not simple");
  }, as = (m, v, C) => {
    Ao(m.dom, v, C);
  }, Yr = (m, v) => {
    const C = m.dom;
    vt(v, (_, P) => {
      Ao(C, P, _);
    });
  }, Xr = (m, v) => {
    vt(v, (C, _) => {
      C.fold(() => {
        Ae(m, _);
      }, (P) => {
        Ao(m.dom, _, P);
      });
    });
  }, Tr = (m, v) => {
    const C = m.dom.getAttribute(v);
    return C === null ? void 0 : C;
  }, Ne = (m, v) => Ce.from(Tr(m, v)), Ae = (m, v) => {
    m.dom.removeAttribute(v);
  }, ct = (m) => et(m.dom.attributes, (v, C) => (v[C.name] = C.value, v), {}), Ct = (m, v) => {
    const _ = (v || document).createElement("div");
    if (_.innerHTML = m, !_.hasChildNodes() || _.childNodes.length > 1) {
      const P = "HTML does not have a single root node";
      throw console.error(P, m), new Error(P);
    }
    return Bo(_.childNodes[0]);
  }, Kn = (m, v) => {
    const _ = (v || document).createElement(m);
    return Bo(_);
  }, lo = (m, v) => {
    const _ = (v || document).createTextNode(m);
    return Bo(_);
  }, Bo = (m) => {
    if (m == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: m };
  }, $e = {
    fromHtml: Ct,
    fromTag: Kn,
    fromText: lo,
    fromDom: Bo,
    fromPoint: (m, v, C) => Ce.from(m.dom.elementFromPoint(v, C)).map(Bo)
  }, Oo = (m, v) => {
    const C = m.dom;
    if (C.nodeType !== ia)
      return !1;
    {
      const _ = C;
      if (_.matches !== void 0)
        return _.matches(v);
      if (_.msMatchesSelector !== void 0)
        return _.msMatchesSelector(v);
      if (_.webkitMatchesSelector !== void 0)
        return _.webkitMatchesSelector(v);
      if (_.mozMatchesSelector !== void 0)
        return _.mozMatchesSelector(v);
      throw new Error("Browser lacks native selectors");
    }
  }, Pe = (m) => m.nodeType !== ia && m.nodeType !== Lr && m.nodeType !== ha || m.childElementCount === 0, Ie = (m, v) => {
    const C = v === void 0 ? document : v.dom;
    return Pe(C) ? [] : Tt(C.querySelectorAll(m), $e.fromDom);
  }, Lt = (m, v) => {
    const C = v === void 0 ? document : v.dom;
    return Pe(C) ? Ce.none() : Ce.from(C.querySelector(m)).map($e.fromDom);
  }, Zt = (m, v) => m.dom === v.dom, kn = (m, v) => {
    const C = m.dom, _ = v.dom;
    return C === _ ? !1 : C.contains(_);
  }, Jn = Oo, Zn = (m) => $e.fromDom(m.dom.ownerDocument), Gn = (m) => ht(m) ? m : Zn(m), Qn = (m) => $e.fromDom(Gn(m).dom.documentElement), co = (m) => $e.fromDom(Gn(m).dom.defaultView), Jo = (m) => Ce.from(m.dom.parentNode).map($e.fromDom), Gs = (m) => Ce.from(m.dom.parentElement).map($e.fromDom), Wa = (m, v) => {
    const C = Se(v) ? v : Vt;
    let _ = m.dom;
    const P = [];
    for (; _.parentNode !== null && _.parentNode !== void 0; ) {
      const z = _.parentNode, Q = $e.fromDom(z);
      if (P.push(Q), C(Q) === !0)
        break;
      _ = z;
    }
    return P;
  }, Ti = (m) => Ce.from(m.dom.previousSibling).map($e.fromDom), Ai = (m) => Ce.from(m.dom.nextSibling).map($e.fromDom), ko = (m) => Tt(m.dom.childNodes, $e.fromDom), Zo = (m, v) => {
    const C = m.dom.childNodes;
    return Ce.from(C[v]).map($e.fromDom);
  }, Rs = (m) => Zo(m, 0), Ba = (m, v) => {
    Jo(m).each((_) => {
      _.dom.insertBefore(v.dom, m.dom);
    });
  }, ca = (m, v) => {
    Ai(m).fold(() => {
      Jo(m).each((P) => {
        Qs(P, v);
      });
    }, (_) => {
      Ba(_, v);
    });
  }, gr = (m, v) => {
    Rs(m).fold(() => {
      Qs(m, v);
    }, (_) => {
      m.dom.insertBefore(v.dom, _.dom);
    });
  }, Qs = (m, v) => {
    m.dom.appendChild(v.dom);
  }, ii = (m, v, C) => {
    Zo(m, C).fold(() => {
      Qs(m, v);
    }, (_) => {
      Ba(_, v);
    });
  }, xc = (m, v) => {
    Ba(m, v), Qs(v, m);
  }, Is = (m, v) => {
    Je(v, (C, _) => {
      const P = _ === 0 ? m : v[_ - 1];
      ca(P, C);
    });
  }, ka = (m, v) => {
    Je(v, (C) => {
      Qs(m, C);
    });
  }, li = (m) => {
    m.dom.textContent = "", Je(ko(m), (v) => {
      Qr(v);
    });
  }, Qr = (m) => {
    const v = m.dom;
    v.parentNode !== null && v.parentNode.removeChild(v);
  }, Oi = (m) => {
    const v = ko(m);
    v.length > 0 && Is(m, v), Qr(m);
  }, cl = (m, v) => $e.fromDom(m.dom.cloneNode(v)), Za = (m) => cl(m, !1), Di = (m) => cl(m, !0), ji = (m, v) => {
    const C = $e.fromTag(v), _ = ct(m);
    return Yr(C, _), C;
  }, uu = (m, v) => {
    const C = ji(m, v), _ = ko(Di(m));
    return ka(C, _), C;
  }, vi = (m, v) => {
    const C = ji(m, v);
    ca(m, C);
    const _ = ko(m);
    return ka(C, _), Qr(m), C;
  }, Bl = [
    "tfoot",
    "thead",
    "tbody",
    "colgroup"
  ], La = (m) => fn(Bl, m), Wi = (m, v) => ({
    rows: m,
    columns: v
  }), Xl = (m, v) => ({
    row: m,
    column: v
  }), wc = (m, v, C) => ({
    element: m,
    rowspan: v,
    colspan: C
  }), fd = (m, v, C, _) => ({
    element: m,
    rowspan: v,
    colspan: C,
    isNew: _
  }), du = (m, v, C, _, P, z) => ({
    element: m,
    rowspan: v,
    colspan: C,
    row: _,
    column: P,
    isLocked: z
  }), bi = (m, v, C) => ({
    element: m,
    cells: v,
    section: C
  }), Fu = (m, v, C, _) => ({
    element: m,
    cells: v,
    section: C,
    isNew: _
  }), ie = (m, v, C) => ({
    element: m,
    isNew: v,
    isLocked: C
  }), Oe = (m, v, C, _) => ({
    element: m,
    cells: v,
    section: C,
    isNew: _
  }), Ge = (m, v, C, _) => ({
    startRow: m,
    startCol: v,
    finishRow: C,
    finishCol: _
  }), Dt = (m, v, C) => ({
    element: m,
    colspan: v,
    column: C
  }), Xt = (m, v) => ({
    element: m,
    columns: v
  }), jn = (m) => gn(m) && pe(m.dom.host), ss = Se(Element.prototype.attachShadow) && Se(Node.prototype.getRootNode), hs = U(ss), Uo = ss ? (m) => $e.fromDom(m.dom.getRootNode()) : Gn, qs = (m) => {
    const v = Uo(m);
    return jn(v) ? Ce.some(v) : Ce.none();
  }, Ar = (m) => $e.fromDom(m.dom.host), sn = (m) => {
    if (hs() && pe(m.target)) {
      const v = $e.fromDom(m.target);
      if (wr(v) && md(v) && m.composed && m.composedPath) {
        const C = m.composedPath();
        if (C)
          return je(C);
      }
    }
    return Ce.from(m.target);
  }, md = (m) => pe(m.dom.shadowRoot), tr = (m) => {
    const v = Ke(m) ? m.dom.parentNode : m.dom;
    if (v == null || v.ownerDocument === null)
      return !1;
    const C = v.ownerDocument;
    return qs($e.fromDom(v)).fold(() => C.body.contains(v), oe(tr, Ar));
  }, Y = () => ge($e.fromDom(document)), ge = (m) => {
    const v = m.dom.body;
    if (v == null)
      throw new Error("Body is not available yet");
    return $e.fromDom(v);
  }, Ee = (m, v, C) => Rt(Wa(m, C), v), dt = (m, v) => Rt(ko(m), v), wn = (m, v) => {
    let C = [];
    return Je(ko(m), (_) => {
      v(_) && (C = C.concat([_])), C = C.concat(wn(_, v));
    }), C;
  }, Yo = (m, v, C) => Ee(m, (_) => Oo(_, v), C), Ln = (m, v) => dt(m, (C) => Oo(C, v)), Or = (m, v) => Ie(v, m);
  var Kt = (m, v, C, _, P) => m(C, _) ? Ce.some(C) : Se(P) && P(C) ? Ce.none() : v(C, _, P);
  const lr = (m, v, C) => {
    let _ = m.dom;
    const P = Se(C) ? C : Vt;
    for (; _.parentNode; ) {
      _ = _.parentNode;
      const z = $e.fromDom(_);
      if (v(z))
        return Ce.some(z);
      if (P(z))
        break;
    }
    return Ce.none();
  }, yi = (m, v, C) => Kt((P, z) => z(P), lr, m, v, C), Cr = (m, v) => {
    const C = (P) => v($e.fromDom(P));
    return X(m.dom.childNodes, C).map($e.fromDom);
  }, ga = (m, v) => {
    const C = (_) => {
      for (let P = 0; P < _.childNodes.length; P++) {
        const z = $e.fromDom(_.childNodes[P]);
        if (v(z))
          return Ce.some(z);
        const Q = C(_.childNodes[P]);
        if (Q.isSome())
          return Q;
      }
      return Ce.none();
    };
    return C(m.dom);
  }, Ll = (m, v, C) => lr(m, (_) => Oo(_, v), C), gs = (m, v) => Cr(m, (C) => Oo(C, v)), xi = (m, v) => Lt(v, m), Dr = (m, v, C) => Kt((P, z) => Oo(P, z), Ll, m, v, C), Cc = (m, v, C = Ze) => m.exists((_) => C(_, v)), Mr = (m) => {
    const v = [], C = (_) => {
      v.push(_);
    };
    for (let _ = 0; _ < m.length; _++)
      m[_].each(C);
    return v;
  }, pd = (m, v) => m != null ? v(m) : Ce.none(), Tm = (m, v) => m ? Ce.some(v) : Ce.none(), zh = (m, v) => m.substring(v), $r = (m, v, C) => v === "" || m.length >= v.length && m.substr(C, C + v.length) === v, Ql = (m, v) => Ga(m, v) ? zh(m, v.length) : m, $a = (m, v, C = 0, _) => {
    const P = m.indexOf(v, C);
    return P !== -1 ? K(_) ? !0 : P + v.length <= _ : !1;
  }, Ga = (m, v) => $r(m, v, 0), wi = (m, v) => $r(m, v, m.length - v.length), fs = ((m) => (v) => v.replace(m, ""))(/^\s+|\s+$/g), Ri = (m) => m.length > 0, ci = (m) => {
    const v = parseFloat(m);
    return isNaN(v) ? Ce.none() : Ce.some(v);
  }, me = (m) => m.style !== void 0 && Se(m.style.getPropertyValue), Te = (m, v, C) => {
    if (!k(C))
      throw console.error("Invalid call to CSS.set. Property ", v, ":: Value ", C, ":: Element ", m), new Error("CSS value must be a string: " + C);
    me(m) && m.style.setProperty(v, C);
  }, nt = (m, v) => {
    me(m) && m.style.removeProperty(v);
  }, ft = (m, v, C) => {
    const _ = m.dom;
    Te(_, v, C);
  }, eo = (m, v) => {
    const C = m.dom;
    vt(v, (_, P) => {
      Te(C, P, _);
    });
  }, es = (m, v) => {
    const C = m.dom, P = window.getComputedStyle(C).getPropertyValue(v);
    return P === "" && !tr(m) ? Sr(C, v) : P;
  }, Sr = (m, v) => me(m) ? m.style.getPropertyValue(v) : "", Ha = (m, v) => {
    const C = m.dom, _ = Sr(C, v);
    return Ce.from(_).filter((P) => P.length > 0);
  }, is = (m, v) => {
    const C = m.dom;
    nt(C, v), Cc(Ne(m, "style").map(fs), "") && Ae(m, "style");
  }, _a = (m, v) => {
    const C = m.dom, _ = v.dom;
    me(C) && me(_) && (_.style.cssText = C.style.cssText);
  }, Rr = (m, v, C = 0) => Ne(m, v).map((_) => parseInt(_, 10)).getOr(C), ua = (m, v) => Rr(m, v, 1), oa = (m) => En("col")(m) ? Rr(m, "span", 1) > 1 : ua(m, "colspan") > 1, Jr = (m) => ua(m, "rowspan") > 1, ul = (m, v) => parseInt(es(m, v), 10), Sc = U(10), qa = U(10), dl = (m, v) => Bc(m, v, Ue), Bc = (m, v, C) => At(ko(m), (_) => Oo(_, v) ? C(_) ? [_] : [] : Bc(_, v, C)), Lc = (m, v, C = Vt) => {
    if (C(v))
      return Ce.none();
    if (fn(m, ks(v)))
      return Ce.some(v);
    const _ = (P) => Oo(P, "table") || C(P);
    return Ll(v, m.join(","), _);
  }, xp = (m, v) => Lc([
    "td",
    "th"
  ], m, v), hd = (m) => dl(m, "th,td"), kc = (m) => Oo(m, "colgroup") ? Ln(m, "col") : At(Ff(m), (v) => Ln(v, "col")), Zi = (m, v) => Dr(m, "table", v), gd = (m) => dl(m, "tr"), Ff = (m) => Zi(m).fold(U([]), (v) => Ln(v, "colgroup")), fu = (m, v) => Tt(m, (C) => {
    if (ks(C) === "colgroup") {
      const _ = Tt(kc(C), (P) => {
        const z = Rr(P, "span", 1);
        return wc(P, 1, z);
      });
      return bi(C, _, "colgroup");
    } else {
      const _ = Tt(hd(C), (P) => {
        const z = Rr(P, "rowspan", 1), Q = Rr(P, "colspan", 1);
        return wc(P, z, Q);
      });
      return bi(C, _, v(C));
    }
  }), Vh = (m) => Jo(m).map((v) => {
    const C = ks(v);
    return La(C) ? C : "tbody";
  }).getOr("tbody"), Bf = (m) => {
    const v = gd(m), _ = [
      ...Ff(m),
      ...v
    ];
    return fu(_, Vh);
  }, Uh = (m, v) => fu(m, () => v), Yd = (m) => {
    let v = !1, C;
    return (..._) => (v || (v = !0, C = m.apply(null, _)), C);
  }, jh = (m, v, C, _) => {
    const P = m.isiOS() && /ipad/i.test(C) === !0, z = m.isiOS() && !P, Q = m.isiOS() || m.isAndroid(), le = Q || _("(pointer:coarse)"), xe = P || !z && Q && _("(min-device-width:768px)"), Fe = z || Q && !xe, at = v.isSafari() && m.isiOS() && /safari/i.test(C) === !1, Yt = !Fe && !xe && !at;
    return {
      isiPad: U(P),
      isiPhone: U(z),
      isTablet: U(xe),
      isPhone: U(Fe),
      isTouch: U(le),
      isAndroid: m.isAndroid,
      isiOS: m.isiOS,
      isWebView: U(at),
      isDesktop: U(Yt)
    };
  }, Xd = (m, v) => {
    for (let C = 0; C < m.length; C++) {
      const _ = m[C];
      if (_.test(v))
        return _;
    }
  }, Hb = (m, v) => {
    const C = Xd(m, v);
    if (!C)
      return {
        major: 0,
        minor: 0
      };
    const _ = (P) => Number(v.replace(C, "$" + P));
    return wl(_(1), _(2));
  }, Me = (m, v) => {
    const C = String(v).toLowerCase();
    return m.length === 0 ? Am() : Hb(m, C);
  }, Am = () => wl(0, 0), wl = (m, v) => ({
    major: m,
    minor: v
  }), Bu = {
    nu: wl,
    detect: Me,
    unknown: Am
  }, Wh = (m, v) => qn(v.brands, (C) => {
    const _ = C.brand.toLowerCase();
    return X(m, (P) => {
      var z;
      return _ === ((z = P.brand) === null || z === void 0 ? void 0 : z.toLowerCase());
    }).map((P) => ({
      current: P.name,
      version: Bu.nu(parseInt(C.version, 10), 0)
    }));
  }), cv = (m, v) => {
    const C = String(v).toLowerCase();
    return X(m, (_) => _.search(C));
  }, Bs = (m, v) => cv(m, v).map((C) => {
    const _ = Bu.detect(C.versionRegexes, v);
    return {
      current: C.name,
      version: _
    };
  }), Gi = (m, v) => cv(m, v).map((C) => {
    const _ = Bu.detect(C.versionRegexes, v);
    return {
      current: C.name,
      version: _
    };
  }), $l = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, Ka = (m) => (v) => $a(v, m), Qd = [
    {
      name: "Edge",
      versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
      search: (m) => $a(m, "edge/") && $a(m, "chrome") && $a(m, "safari") && $a(m, "applewebkit")
    },
    {
      name: "Chromium",
      brand: "Chromium",
      versionRegexes: [
        /.*?chrome\/([0-9]+)\.([0-9]+).*/,
        $l
      ],
      search: (m) => $a(m, "chrome") && !$a(m, "chromeframe")
    },
    {
      name: "IE",
      versionRegexes: [
        /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
        /.*?rv:([0-9]+)\.([0-9]+).*/
      ],
      search: (m) => $a(m, "msie") || $a(m, "trident")
    },
    {
      name: "Opera",
      versionRegexes: [
        $l,
        /.*?opera\/([0-9]+)\.([0-9]+).*/
      ],
      search: Ka("opera")
    },
    {
      name: "Firefox",
      versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
      search: Ka("firefox")
    },
    {
      name: "Safari",
      versionRegexes: [
        $l,
        /.*?cpu os ([0-9]+)_([0-9]+).*/
      ],
      search: (m) => ($a(m, "safari") || $a(m, "mobile/")) && $a(m, "applewebkit")
    }
  ], $c = [
    {
      name: "Windows",
      search: Ka("win"),
      versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "iOS",
      search: (m) => $a(m, "iphone") || $a(m, "ipad"),
      versionRegexes: [
        /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
        /.*cpu os ([0-9]+)_([0-9]+).*/,
        /.*cpu iphone os ([0-9]+)_([0-9]+).*/
      ]
    },
    {
      name: "Android",
      search: Ka("android"),
      versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "macOS",
      search: Ka("mac os x"),
      versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    },
    {
      name: "Linux",
      search: Ka("linux"),
      versionRegexes: []
    },
    {
      name: "Solaris",
      search: Ka("sunos"),
      versionRegexes: []
    },
    {
      name: "FreeBSD",
      search: Ka("freebsd"),
      versionRegexes: []
    },
    {
      name: "ChromeOS",
      search: Ka("cros"),
      versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }
  ], Ni = {
    browsers: U(Qd),
    oses: U($c)
  }, Hc = "Edge", Zh = "Chromium", uv = "IE", Jl = "Opera", zc = "Firefox", wp = "Safari", qi = () => Ya({
    current: void 0,
    version: Bu.unknown()
  }), Ya = (m) => {
    const v = m.current, C = m.version, _ = (P) => () => v === P;
    return {
      current: v,
      version: C,
      isEdge: _(Hc),
      isChromium: _(Zh),
      isIE: _(uv),
      isOpera: _(Jl),
      isFirefox: _(zc),
      isSafari: _(wp)
    };
  }, vd = {
    unknown: qi,
    nu: Ya,
    edge: U(Hc),
    chromium: U(Zh),
    ie: U(uv),
    opera: U(Jl),
    firefox: U(zc),
    safari: U(wp)
  }, Lf = "Windows", _c = "iOS", Ci = "Android", Cp = "Linux", Sp = "macOS", kp = "Solaris", Om = "FreeBSD", ec = "ChromeOS", _p = () => dv({
    current: void 0,
    version: Bu.unknown()
  }), dv = (m) => {
    const v = m.current, C = m.version, _ = (P) => () => v === P;
    return {
      current: v,
      version: C,
      isWindows: _(Lf),
      isiOS: _(_c),
      isAndroid: _(Ci),
      isMacOS: _(Sp),
      isLinux: _(Cp),
      isSolaris: _(kp),
      isFreeBSD: _(Om),
      isChromeOS: _(ec)
    };
  }, zb = {
    unknown: _p,
    nu: dv,
    windows: U(Lf),
    ios: U(_c),
    android: U(Ci),
    linux: U(Cp),
    macos: U(Sp),
    solaris: U(kp),
    freebsd: U(Om),
    chromeos: U(ec)
  }, Ep = { detect: (m, v, C) => {
    const _ = Ni.browsers(), P = Ni.oses(), z = v.bind((xe) => Wh(_, xe)).orThunk(() => Bs(_, m)).fold(vd.unknown, vd.nu), Q = Gi(P, m).fold(zb.unknown, zb.nu), le = jh(Q, z, m, C);
    return {
      browser: z,
      os: Q,
      deviceType: le
    };
  } }, Dm = (m) => window.matchMedia(m).matches;
  let Lu = Yd(() => Ep.detect(navigator.userAgent, Ce.from(navigator.userAgentData), Dm));
  const Gh = () => Lu(), Nr = (m, v) => {
    const C = (le, xe) => {
      if (!be(xe) && !xe.match(/^[0-9]+$/))
        throw new Error(m + ".set accepts only positive integer values. Value was " + xe);
      const Fe = le.dom;
      me(Fe) && (Fe.style[m] = xe + "px");
    }, _ = (le) => {
      const xe = v(le);
      if (xe <= 0 || xe === null) {
        const Fe = es(le, m);
        return parseFloat(Fe) || 0;
      }
      return xe;
    }, P = _, z = (le, xe) => et(xe, (Fe, at) => {
      const Yt = es(le, at), _n = Yt === void 0 ? 0 : parseInt(Yt, 10);
      return isNaN(_n) ? Fe : Fe + _n;
    }, 0);
    return {
      set: C,
      get: _,
      getOuter: P,
      aggregate: z,
      max: (le, xe, Fe) => {
        const at = z(le, Fe);
        return xe > at ? xe - at : 0;
      }
    };
  }, sa = (m, v) => ci(m).getOr(v), Cl = (m, v, C) => sa(es(m, v), C), qh = (m, v, C, _) => {
    const P = Cl(m, `padding-${C}`, 0), z = Cl(m, `padding-${_}`, 0), Q = Cl(m, `border-${C}-width`, 0), le = Cl(m, `border-${_}-width`, 0);
    return v - P - z - Q - le;
  }, Kh = (m, v) => {
    const C = m.dom, _ = C.getBoundingClientRect().width || C.offsetWidth;
    return v === "border-box" ? _ : qh(m, _, "left", "right");
  }, Na = (m) => Cl(m, "height", m.dom.offsetHeight), to = (m) => Cl(m, "width", m.dom.offsetWidth), mu = (m) => Kh(m, "content-box"), mv = Nr("width", (m) => m.dom.offsetWidth), za = (m) => mv.get(m), cr = (m) => mv.getOuter(m), Jd = mu, Yh = to, Tp = (m, v, C) => {
    const _ = m.cells, P = _.slice(0, v), z = _.slice(v), Q = P.concat(C).concat(z);
    return da(m, Q);
  }, Ap = (m, v, C) => Tp(m, v, [C]), Ho = (m, v, C) => {
    const _ = m.cells;
    _[v] = C;
  }, da = (m, v) => Oe(m.element, v, m.section, m.isNew), $f = (m, v) => {
    const C = m.cells, _ = Tt(C, v);
    return Oe(m.element, _, m.section, m.isNew);
  }, Sl = (m, v) => m.cells[v], fl = (m, v) => Sl(m, v).element, kl = (m) => m.cells.length, Pa = (m) => {
    const v = Ro(m, (C) => C.section === "colgroup");
    return {
      rows: v.fail,
      cols: v.pass
    };
  }, Ki = (m, v, C) => {
    const _ = Tt(m.cells, C);
    return Oe(v(m.element), _, m.section, !0);
  }, tc = "data-snooker-locked-cols", Rm = (m) => Ne(m, tc).bind((v) => Ce.from(v.match(/\d+/g))).map((v) => Nt(v, Ue)), Zr = (m) => {
    const v = et(Pa(m).rows, (_, P) => (Je(P.cells, (z, Q) => {
      z.isLocked && (_[Q] = !0);
    }), _), {}), C = Qo(v, (_, P) => parseInt(P, 10));
    return Vn(C);
  }, Xh = (m, v) => m + "," + v, wa = (m, v, C) => Ce.from(m.access[Xh(v, C)]), bd = (m, v, C) => {
    const _ = Vc(m, (P) => C(v, P.element));
    return _.length > 0 ? Ce.some(_[0]) : Ce.none();
  }, Vc = (m, v) => {
    const C = At(m.all, (_) => _.cells);
    return Rt(C, v);
  }, vr = (m) => {
    const v = {};
    let C = 0;
    return Je(m.cells, (_) => {
      const P = _.colspan;
      jt(P, (z) => {
        const Q = C + z;
        v[Q] = Dt(_.element, P, Q);
      }), C += P;
    }), v;
  }, Uc = (m) => {
    const v = {}, C = [], P = je(m).map((vn) => vn.element).bind(Zi).bind(Rm).getOr({});
    let z = 0, Q = 0, le = 0;
    const {
      pass: xe,
      fail: Fe
    } = Ro(m, (vn) => vn.section === "colgroup");
    Je(Fe, (vn) => {
      const ln = [];
      Je(vn.cells, (Wn) => {
        let Wt = 0;
        for (; v[Xh(le, Wt)] !== void 0; )
          Wt++;
        const un = kt(P, Wt.toString()), wo = du(Wn.element, Wn.rowspan, Wn.colspan, le, Wt, un);
        for (let yn = 0; yn < Wn.colspan; yn++)
          for (let Ks = 0; Ks < Wn.rowspan; Ks++) {
            const yr = le + Ks, ur = Wt + yn, nl = Xh(yr, ur);
            v[nl] = wo, Q = Math.max(Q, ur + 1);
          }
        ln.push(wo);
      }), z++, C.push(bi(vn.element, ln, vn.section)), le++;
    });
    const { columns: at, colgroups: Yt } = An(xe).map((vn) => {
      const ln = vr(vn);
      return {
        colgroups: [Xt(vn.element, os(ln))],
        columns: ln
      };
    }).getOrThunk(() => ({
      colgroups: [],
      columns: {}
    }));
    return {
      grid: Wi(z, Q),
      access: v,
      all: C,
      columns: at,
      colgroups: Yt
    };
  }, ls = {
    fromTable: (m) => {
      const v = Bf(m);
      return Uc(v);
    },
    generate: Uc,
    getAt: wa,
    findItem: bd,
    filterItems: Vc,
    justCells: (m) => At(m.all, (v) => v.cells),
    justColumns: (m) => os(m.columns),
    hasColumns: (m) => on(m.columns).length > 0,
    getColumnAt: (m, v) => Ce.from(m.columns[v])
  }, ef = (m, v = Ue) => {
    const C = m.grid, _ = jt(C.columns, ve), P = jt(C.rows, ve);
    return Tt(_, (z) => Nm(() => At(P, (Fe) => ls.getAt(m, Fe, z).filter((at) => at.column === z).toArray()), (Fe) => Fe.colspan === 1 && v(Fe.element), () => ls.getAt(m, 0, z)));
  }, Nm = (m, v, C) => {
    const _ = m();
    return X(_, v).orThunk(() => Ce.from(_[0]).orThunk(C)).map((Q) => Q.element);
  }, Op = (m) => {
    const v = m.grid, C = jt(v.rows, ve), _ = jt(v.columns, ve);
    return Tt(C, (P) => Nm(() => At(_, (xe) => ls.getAt(m, P, xe).filter((Fe) => Fe.row === P).fold(U([]), (Fe) => [Fe])), (xe) => xe.rowspan === 1, () => ls.getAt(m, P, 0)));
  }, pv = (m, v) => {
    if (v < 0 || v >= m.length - 1)
      return Ce.none();
    const C = m[v].fold(() => {
      const P = Hn(m.slice(0, v));
      return qn(P, (z, Q) => z.map((le) => ({
        value: le,
        delta: Q + 1
      })));
    }, (P) => Ce.some({
      value: P,
      delta: 0
    })), _ = m[v + 1].fold(() => {
      const P = m.slice(v + 1);
      return qn(P, (z, Q) => z.map((le) => ({
        value: le,
        delta: Q + 1
      })));
    }, (P) => Ce.some({
      value: P,
      delta: 1
    }));
    return C.bind((P) => _.map((z) => {
      const Q = z.delta + P.delta;
      return Math.abs(z.value - P.value) / Q;
    }));
  }, Dp = (m, v) => (C) => hv(C) === "rtl" ? v : m, hv = (m) => es(m, "direction") === "rtl" ? "rtl" : "ltr", R = Nr("height", (m) => {
    const v = m.dom;
    return tr(m) ? v.getBoundingClientRect().height : v.offsetHeight;
  }), V = (m) => R.get(m), se = (m) => R.getOuter(m), De = Na, Le = (m, v) => ({
    left: m,
    top: v,
    translate: (_, P) => Le(m + _, v + P)
  }), $t = Le, vo = (m) => {
    const v = m.getBoundingClientRect();
    return $t(v.left, v.top);
  }, Lo = (m, v) => m !== void 0 ? m : v !== void 0 ? v : 0, Mo = (m) => {
    const v = m.dom.ownerDocument, C = v.body, _ = v.defaultView, P = v.documentElement;
    if (C === m.dom)
      return $t(C.offsetLeft, C.offsetTop);
    const z = Lo(_ == null ? void 0 : _.pageYOffset, P.scrollTop), Q = Lo(_ == null ? void 0 : _.pageXOffset, P.scrollLeft), le = Lo(P.clientTop, C.clientTop), xe = Lo(P.clientLeft, C.clientLeft);
    return go(m).translate(Q - xe, z - le);
  }, go = (m) => {
    const v = m.dom, _ = v.ownerDocument.body;
    return _ === v ? $t(_.offsetLeft, _.offsetTop) : tr(m) ? vo(v) : $t(0, 0);
  }, Hr = (m, v) => ({
    row: m,
    y: v
  }), fa = (m, v) => ({
    col: m,
    x: v
  }), _l = (m) => Mo(m).left + cr(m), va = (m) => Mo(m).left, gv = (m, v) => fa(m, va(v)), q0 = (m, v) => fa(m, _l(v)), Vb = (m) => Mo(m).top, Pi = (m, v) => Hr(m, Vb(v)), vv = (m, v) => Hr(m, Vb(v) + se(v)), Xa = (m, v, C) => {
    if (C.length === 0)
      return [];
    const _ = Tt(C.slice(1), (z, Q) => z.map((le) => m(Q, le))), P = C[C.length - 1].map((z) => v(C.length - 1, z));
    return _.concat([P]);
  }, Ub = (m) => -m, Mi = {
    delta: ve,
    positions: (m) => Xa(Pi, vv, m),
    edge: Vb
  }, Rp = Dp({
    delta: ve,
    edge: va,
    positions: (m) => Xa(gv, q0, m)
  }, {
    delta: Ub,
    edge: _l,
    positions: (m) => Xa(q0, gv, m)
  }), Np = {
    delta: (m, v) => Rp(v).delta(m, v),
    positions: (m, v) => Rp(v).positions(m, v),
    edge: (m) => Rp(m).edge(m)
  }, K0 = {
    unsupportedLength: [
      "em",
      "ex",
      "cap",
      "ch",
      "ic",
      "rem",
      "lh",
      "rlh",
      "vw",
      "vh",
      "vi",
      "vb",
      "vmin",
      "vmax",
      "cm",
      "mm",
      "Q",
      "in",
      "pc",
      "pt",
      "px"
    ],
    fixed: [
      "px",
      "pt"
    ],
    relative: ["%"],
    empty: [""]
  }, jb = (() => {
    const m = "[0-9]+", C = "[eE]" + ("[+-]?" + m), _ = "\\.", P = (le) => `(?:${le})?`, Q = `[+-]?(?:${[
      "Infinity",
      m + _ + P(m) + P(C),
      _ + m + P(C),
      m + P(C)
    ].join("|")})`;
    return new RegExp(`^(${Q})(.*)$`);
  })(), pu = (m, v) => ze(v, (C) => ze(K0[C], (_) => m === _)), xd = (m, v) => Ce.from(jb.exec(m)).bind((_) => {
    const P = Number(_[1]), z = _[2];
    return pu(z, v) ? Ce.some({
      value: P,
      unit: z
    }) : Ce.none();
  }), zf = /(\d+(\.\d+)?)%/, Tn = /(\d+(\.\d+)?)px|em/, Ec = En("col"), Wb = En("tr"), Pm = (m, v, C) => {
    const _ = Gs(m).getOrThunk(() => ge(Zn(m)));
    return v(m) / C(_) * 100;
  }, hu = (m, v) => {
    ft(m, "width", v + "px");
  }, Qh = (m, v) => {
    ft(m, "width", v + "%");
  }, Vf = (m, v) => {
    ft(m, "height", v + "px");
  }, Mm = (m) => {
    is(m, "height");
  }, Jh = (m) => De(m) + "px", Hu = (m, v, C, _) => {
    const P = Zi(m).map((z) => {
      const Q = C(z);
      return Math.floor(v / 100 * Q);
    }).getOr(v);
    return _(m, P), P;
  }, Y0 = (m, v, C, _) => {
    const P = parseFloat(m);
    return wi(m, "%") && ks(v) !== "table" ? Hu(v, P, C, _) : P;
  }, ra = (m) => {
    const v = Jh(m);
    return v ? Y0(v, m, V, Vf) : V(m);
  }, Gt = (m, v, C) => {
    const _ = C(m), P = ua(m, v);
    return _ / P;
  }, El = (m, v) => Ha(m, v).orThunk(() => Ne(m, v).map((C) => C + "px")), zu = (m) => El(m, "width"), ui = (m) => El(m, "height"), Pp = (m) => Pm(m, za, Jd), Qa = (m) => Ec(m) ? za(m) : Yh(m), Vs = (m) => Wb(m) ? V(m) : Gt(m, "rowspan", ra), bv = (m) => zu(m).bind((C) => xd(C, [
    "fixed",
    "relative",
    "empty"
  ])), Mt = (m, v, C) => {
    ft(m, "width", v + C);
  }, Ls = (m) => za(m) + "px", yv = (m) => V(m) + "px", Va = (m) => Pm(m, za, Jd) + "%", Yi = (m) => zu(m).exists((v) => zf.test(v)), Y2 = (m) => zu(m).exists((v) => Tn.test(v)), Tc = (m) => zu(m).isNone(), X2 = U(zf), tf = En("col"), X0 = (m) => zu(m).getOrThunk(() => Qa(m) + "px"), Ac = (m) => ui(m).getOrThunk(() => Vs(m) + "px"), $s = (m) => Tt(ls.justColumns(m), (v) => Ce.from(v.element)), wd = (m) => {
    const v = Gh().browser, C = v.isChromium() || v.isFirefox();
    return tf(m) ? C : !0;
  }, Im = (m, v, C, _, P, z) => m.filter(_).fold(() => z(pv(C, v)), (Q) => P(Q)), Ua = (m, v, C, _) => {
    const P = ef(m), z = ls.hasColumns(m) ? $s(m) : P, Q = [Ce.some(Np.edge(v))].concat(Tt(Np.positions(P, v), (xe) => xe.map((Fe) => Fe.x))), le = ee(oa);
    return Tt(z, (xe, Fe) => Im(xe, Fe, Q, le, (at) => {
      if (wd(at))
        return C(at);
      {
        const Yt = pd(P[Fe], ve);
        return Im(Yt, Fe, Q, le, (_n) => _(Ce.some(za(_n))), _);
      }
    }, _));
  }, Zb = (m) => m.map((v) => v + "px").getOr(""), Cd = (m, v) => Ua(m, v, X0, Zb), Vu = (m, v, C) => Ua(m, v, Pp, (_) => _.fold(() => C.minCellWidth(), (P) => P / C.pixelWidth() * 100)), kr = (m, v, C) => Ua(m, v, Qa, (_) => _.getOrThunk(C.minCellWidth)), Mp = (m, v, C, _) => {
    const P = Op(m), z = Tt(m.all, (le) => Ce.some(le.element)), Q = [Ce.some(Mi.edge(v))].concat(Tt(Mi.positions(P, v), (le) => le.map((xe) => xe.y)));
    return Tt(z, (le, xe) => Im(le, xe, Q, Ue, C, _));
  }, Xe = (m, v) => Mp(m, v, Vs, (C) => C.getOrThunk(qa)), Wc = (m, v) => Mp(m, v, Ac, Zb), Ip = (m, v) => () => tr(m) ? v(m) : parseFloat(Ha(m, "width").getOr("0")), Ii = (m) => {
    const v = Ip(m, za), C = U(0);
    return {
      width: v,
      pixelWidth: v,
      getWidths: (P, z) => kr(P, m, z),
      getCellDelta: C,
      singleColumnWidth: U([0]),
      minCellWidth: C,
      setElementWidth: ye,
      adjustTableWidth: ye,
      isRelative: !0,
      label: "none"
    };
  }, gu = (m) => {
    const v = Ip(m, (xe) => parseFloat(Va(xe))), C = Ip(m, za);
    return {
      width: v,
      pixelWidth: C,
      getWidths: (xe, Fe) => Vu(xe, m, Fe),
      getCellDelta: (xe) => xe / C() * 100,
      singleColumnWidth: (xe, Fe) => [100 - xe],
      minCellWidth: () => Sc() / C() * 100,
      setElementWidth: Qh,
      adjustTableWidth: (xe) => {
        const Fe = v(), at = xe / 100 * Fe, Yt = Fe + at;
        Qh(m, Yt);
      },
      isRelative: !0,
      label: "percent"
    };
  }, Ea = (m) => {
    const v = Ip(m, za);
    return {
      width: v,
      pixelWidth: v,
      getWidths: (Q, le) => kr(Q, m, le),
      getCellDelta: ve,
      singleColumnWidth: (Q, le) => [Math.max(Sc(), Q + le) - Q],
      minCellWidth: Sc,
      setElementWidth: hu,
      adjustTableWidth: (Q) => {
        const le = v() + Q;
        hu(m, le);
      },
      isRelative: !1,
      label: "pixel"
    };
  }, Ca = (m, v) => X2().exec(v) !== null ? gu(m) : Ea(m), I = {
    getTableSize: (m) => zu(m).fold(() => Ii(m), (C) => Ca(m, C)),
    pixelSize: Ea,
    percentageSize: gu,
    noneSize: Ii
  }, te = (m, v, C, _, P, z) => ({
    minRow: m,
    minCol: v,
    maxRow: C,
    maxCol: _,
    allCells: P,
    selectedCells: z
  }), he = (m, v) => {
    const C = m.grid.columns;
    let P = m.grid.rows, z = C, Q = 0, le = 0;
    const xe = [], Fe = [];
    return vt(m.access, (at) => {
      if (xe.push(at), v(at)) {
        Fe.push(at);
        const Yt = at.row, _n = Yt + at.rowspan - 1, vn = at.column, ln = vn + at.colspan - 1;
        Yt < P ? P = Yt : _n > Q && (Q = _n), vn < z ? z = vn : ln > le && (le = ln);
      }
    }), te(P, z, Q, le, xe, Fe);
  }, Be = (m, v, C) => {
    const _ = m[C].element, P = $e.fromTag("td");
    Qs(P, $e.fromTag("br")), (v ? Qs : gr)(_, P);
  }, Ot = (m, v, C, _) => {
    const P = Rt(m, (le) => le.section !== "colgroup"), z = v.grid.columns, Q = v.grid.rows;
    for (let le = 0; le < Q; le++) {
      let xe = !1;
      for (let Fe = 0; Fe < z; Fe++)
        le < C.minRow || le > C.maxRow || Fe < C.minCol || Fe > C.maxCol || (ls.getAt(v, le, Fe).filter(_).isNone() ? Be(P, xe, le) : xe = !0);
    }
  }, rn = (m, v, C, _) => {
    vt(C.columns, (Q) => {
      (Q.column < v.minCol || Q.column > v.maxCol) && Qr(Q.element);
    });
    const P = Rt(dl(m, "tr"), (Q) => Q.dom.childElementCount === 0);
    Je(P, Qr), (v.minCol === v.maxCol || v.minRow === v.maxRow) && Je(dl(m, "th,td"), (Q) => {
      Ae(Q, "rowspan"), Ae(Q, "colspan");
    }), Ae(m, tc), Ae(m, "data-snooker-col-series"), I.getTableSize(m).adjustTableWidth(_);
  }, $n = (m, v, C, _) => {
    if (_.minCol === 0 && v.grid.columns === _.maxCol + 1)
      return 0;
    const P = kr(v, m, C), z = et(P, (Fe, at) => Fe + at, 0), xe = et(P.slice(_.minCol, _.maxCol + 1), (Fe, at) => Fe + at, 0) / z * C.pixelWidth() - C.pixelWidth();
    return C.getCellDelta(xe);
  }, No = (m, v) => {
    const C = (_n) => Oo(_n.element, v), _ = Di(m), P = Bf(_), z = I.getTableSize(m), Q = ls.generate(P), le = he(Q, C), xe = "th:not(" + v + "),td:not(" + v + ")", Fe = Bc(_, "th,td", (_n) => Oo(_n, xe));
    Je(Fe, Qr), Ot(P, Q, le, C);
    const at = ls.fromTable(m), Yt = $n(m, at, z, le);
    return rn(_, le, Q, Yt), _;
  }, ts = " ", Us = ((m, v) => {
    const C = (z) => {
      if (!m(z))
        throw new Error("Can only get " + v + " value of a " + v + " node");
      return _(z).getOr("");
    }, _ = (z) => m(z) ? Ce.from(z.dom.nodeValue) : Ce.none();
    return {
      get: C,
      getOption: _,
      set: (z, Q) => {
        if (!m(z))
          throw new Error("Can only set raw " + v + " value of a " + v + " node");
        z.dom.nodeValue = Q;
      }
    };
  })(Ke, "text"), Ir = (m) => Us.get(m), oc = (m) => Us.getOption(m), Sd = (m, v) => Us.set(m, v), ml = (m) => ks(m) === "img" ? 1 : oc(m).fold(() => ko(m).length, (v) => v.length), kd = (m) => oc(m).filter((v) => v.trim().length !== 0 || v.indexOf(ts) > -1).isSome(), Uf = (m) => Xn(m) && Tr(m, "contenteditable") === "false", Uu = [
    "img",
    "br"
  ], Fp = (m) => kd(m) || fn(Uu, ks(m)) || Uf(m), Zc = (m) => ga(m, Fp), xv = (m) => eg(m, Fp), eg = (m, v) => {
    const C = (_) => {
      const P = ko(_);
      for (let z = P.length - 1; z >= 0; z--) {
        const Q = P[z];
        if (v(Q))
          return Ce.some(Q);
        const le = C(Q);
        if (le.isSome())
          return le;
      }
      return Ce.none();
    };
    return C(m);
  }, wv = {
    scope: [
      "row",
      "col"
    ]
  }, Cv = (m) => () => {
    const v = $e.fromTag("td", m.dom);
    return Qs(v, $e.fromTag("br", m.dom)), v;
  }, di = (m) => () => $e.fromTag("col", m.dom), vs = (m) => () => $e.fromTag("colgroup", m.dom), Gr = (m) => () => $e.fromTag("tr", m.dom), Ja = (m, v, C) => {
    const _ = uu(m, v);
    return vt(C, (P, z) => {
      P === null ? Ae(_, z) : as(_, z, P);
    }), _;
  }, Oc = (m) => m, sc = (m, v, C) => Zc(m).map((P) => {
    const z = C.join(","), Q = Yo(P, z, (le) => Zt(le, m));
    return Cn(Q, (le, xe) => {
      const Fe = Za(xe);
      return Qs(le, Fe), Fe;
    }, v);
  }).getOr(v), Sv = (m, v) => {
    vt(wv, (C, _) => Ne(m, _).filter((P) => fn(C, P)).each((P) => as(v, _, P)));
  }, _d = (m, v, C) => {
    const _ = (Q, le) => {
      _a(Q.element, le), is(le, "height"), Q.colspan !== 1 && is(le, "width");
    }, P = (Q) => {
      const le = $e.fromTag(ks(Q.element), v.dom), xe = C.getOr([
        "strong",
        "em",
        "b",
        "i",
        "span",
        "font",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "p",
        "div"
      ]), Fe = xe.length > 0 ? sc(Q.element, le, xe) : le;
      return Qs(Fe, $e.fromTag("br")), _(Q, le), Sv(Q.element, le), m(Q.element, le), le;
    };
    return {
      col: (Q) => {
        const le = $e.fromTag(ks(Q.element), v.dom);
        return _(Q, le), m(Q.element, le), le;
      },
      colgroup: vs(v),
      row: Gr(v),
      cell: P,
      replace: Ja,
      colGap: di(v),
      gap: Cv(v)
    };
  }, Fm = (m) => ({
    col: di(m),
    colgroup: vs(m),
    row: Gr(m),
    cell: Cv(m),
    replace: Oc,
    colGap: di(m),
    gap: Cv(m)
  }), jf = (m, v) => {
    const _ = document.createElement("div");
    return _.innerHTML = m, ko($e.fromDom(_));
  }, nf = (m) => Tt(m, $e.fromDom), Wf = (m) => (v) => v.options.get(m), Ed = "100%", Gb = (m) => {
    var v;
    const C = m.dom, _ = (v = C.getParent(m.selection.getStart(), C.isBlock)) !== null && v !== void 0 ? v : m.getBody();
    return Jd($e.fromDom(_)) + "px";
  }, Zf = (m, v) => ju(m) || !qb(m) ? v : Bm(m) ? {
    ...v,
    width: Gb(m)
  } : {
    ...v,
    width: Ed
  }, kv = (m, v) => ju(m) || qb(m) ? v : Bm(m) ? {
    ...v,
    width: Gb(m)
  } : {
    ...v,
    width: Ed
  }, tg = (m) => {
    const v = m.options.register;
    v("table_clone_elements", { processor: "string[]" }), v("table_use_colgroups", {
      processor: "boolean",
      default: !0
    }), v("table_header_type", {
      processor: (C) => {
        const _ = fn([
          "section",
          "cells",
          "sectionCells",
          "auto"
        ], C);
        return _ ? {
          value: C,
          valid: _
        } : {
          valid: !1,
          message: "Must be one of: section, cells, sectionCells or auto."
        };
      },
      default: "section"
    }), v("table_sizing_mode", {
      processor: "string",
      default: "auto"
    }), v("table_default_attributes", {
      processor: "object",
      default: { border: "1" }
    }), v("table_default_styles", {
      processor: "object",
      default: { "border-collapse": "collapse" }
    }), v("table_column_resizing", {
      processor: (C) => {
        const _ = fn([
          "preservetable",
          "resizetable"
        ], C);
        return _ ? {
          value: C,
          valid: _
        } : {
          valid: !1,
          message: "Must be preservetable, or resizetable."
        };
      },
      default: "preservetable"
    }), v("table_resize_bars", {
      processor: "boolean",
      default: !0
    }), v("table_style_by_css", {
      processor: "boolean",
      default: !0
    }), v("table_merge_content_on_paste", {
      processor: "boolean",
      default: !0
    });
  }, n_ = (m) => Ce.from(m.options.get("table_clone_elements")), of = (m) => {
    const v = m.options.get("object_resizing");
    return fn(v.split(","), "table");
  }, o_ = Wf("table_header_type"), Q2 = Wf("table_column_resizing"), Ta = (m) => Q2(m) === "preservetable", Q0 = (m) => Q2(m) === "resizetable", sf = Wf("table_sizing_mode"), Bp = (m) => sf(m) === "relative", Bm = (m) => sf(m) === "fixed", ju = (m) => sf(m) === "responsive", Wu = Wf("table_resize_bars"), qb = Wf("table_style_by_css"), rf = Wf("table_merge_content_on_paste"), Tl = (m) => {
    const v = m.options, C = v.get("table_default_attributes");
    return v.isSet("table_default_attributes") ? C : kv(m, C);
  }, Kb = (m) => {
    const v = m.options, C = v.get("table_default_styles");
    return v.isSet("table_default_styles") ? C : Zf(m, C);
  }, J2 = Wf("table_use_colgroups"), Yb = (m) => Dr(m, "[contenteditable]"), Xb = (m, v = !1) => tr(m) ? m.dom.isContentEditable : Yb(m).fold(U(v), (C) => ew(C) === "true"), ew = (m) => m.dom.contentEditable, ng = (m) => $e.fromDom(m.getBody()), af = (m) => (v) => Zt(v, ng(m)), rc = (m) => {
    Ae(m, "data-mce-style");
    const v = (C) => Ae(C, "data-mce-style");
    Je(hd(m), v), Je(kc(m), v), Je(gd(m), v);
  }, Zu = (m) => $e.fromDom(m.selection.getStart()), Lp = (m) => m.getBoundingClientRect().width, tw = (m) => m.getBoundingClientRect().height, og = (m) => (v, C) => {
    const _ = v.dom.getStyle(C, m) || v.dom.getAttrib(C, m);
    return Ce.from(_).filter(Ri);
  }, nw = og("width"), s_ = og("height"), r_ = (m) => /^(\d+(\.\d+)?)%$/.test(m), a_ = (m) => /^(\d+(\.\d+)?)px$/.test(m), $p = (m) => yi(m, En("table")).exists(Xb), sg = (m, v) => {
    const C = v.column, _ = v.column + v.colspan - 1, P = v.row, z = v.row + v.rowspan - 1;
    return C <= m.finishCol && _ >= m.startCol && P <= m.finishRow && z >= m.startRow;
  }, Xo = (m, v) => v.column >= m.startCol && v.column + v.colspan - 1 <= m.finishCol && v.row >= m.startRow && v.row + v.rowspan - 1 <= m.finishRow, po = (m, v) => {
    let C = !0;
    const _ = rt(Xo, v);
    for (let P = v.startRow; P <= v.finishRow; P++)
      for (let z = v.startCol; z <= v.finishCol; z++)
        C = C && ls.getAt(m, P, z).exists(_);
    return C ? Ce.some(v) : Ce.none();
  }, Hp = (m, v) => Ge(Math.min(m.row, v.row), Math.min(m.column, v.column), Math.max(m.row + m.rowspan - 1, v.row + v.rowspan - 1), Math.max(m.column + m.colspan - 1, v.column + v.colspan - 1)), Qb = (m, v, C) => {
    const _ = ls.findItem(m, v, Zt), P = ls.findItem(m, C, Zt);
    return _.bind((z) => P.map((Q) => Hp(z, Q)));
  }, J0 = (m, v, C) => Qb(m, v, C).bind((_) => po(m, _)), ow = (m, v, C, _) => ls.findItem(m, v, Zt).bind((P) => {
    const z = C > 0 ? P.row + P.rowspan - 1 : P.row, Q = _ > 0 ? P.column + P.colspan - 1 : P.column;
    return ls.getAt(m, z + C, Q + _).map((xe) => xe.element);
  }), Gf = (m, v, C) => Qb(m, v, C).map((_) => {
    const P = ls.filterItems(m, rt(sg, _));
    return Tt(P, (z) => z.element);
  }), zr = (m, v) => {
    const C = (_, P) => kn(P, _);
    return ls.findItem(m, v, C).map((_) => _.element);
  }, i_ = (m, v, C) => Zi(m).bind((_) => {
    const P = rg(_);
    return ow(P, m, v, C);
  }), sw = (m, v, C) => {
    const _ = rg(m);
    return Gf(_, v, C);
  }, ey = (m, v, C, _, P) => {
    const z = rg(m), Q = Zt(m, C) ? Ce.some(v) : zr(z, v), le = Zt(m, P) ? Ce.some(_) : zr(z, _);
    return Q.bind((xe) => le.bind((Fe) => Gf(z, xe, Fe)));
  }, Ft = (m, v, C) => {
    const _ = rg(m);
    return J0(_, v, C);
  }, rg = ls.fromTable;
  var iO = [
    "body",
    "p",
    "div",
    "article",
    "aside",
    "figcaption",
    "figure",
    "footer",
    "header",
    "nav",
    "section",
    "ol",
    "ul",
    "li",
    "table",
    "thead",
    "tbody",
    "tfoot",
    "caption",
    "tr",
    "td",
    "th",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "blockquote",
    "pre",
    "address"
  ], zp = () => {
    const m = (Fe) => $e.fromDom(Fe.dom.cloneNode(!1)), v = (Fe) => Gn(Fe).dom, C = (Fe) => wr(Fe) ? ks(Fe) === "body" ? !0 : fn(iO, ks(Fe)) : !1, _ = (Fe) => wr(Fe) ? fn([
      "br",
      "img",
      "hr",
      "input"
    ], ks(Fe)) : !1, P = (Fe) => wr(Fe) && Tr(Fe, "contenteditable") === "false", z = (Fe, at) => Fe.dom.compareDocumentPosition(at.dom), Q = (Fe, at) => {
      const Yt = ct(Fe);
      Yr(at, Yt);
    }, le = (Fe) => {
      const at = ks(Fe);
      return fn([
        "script",
        "noscript",
        "iframe",
        "noframes",
        "noembed",
        "title",
        "style",
        "textarea",
        "xmp"
      ], at);
    }, xe = (Fe) => wr(Fe) ? Ne(Fe, "lang") : Ce.none();
    return {
      up: U({
        selector: Ll,
        closest: Dr,
        predicate: lr,
        all: Wa
      }),
      down: U({
        selector: Or,
        predicate: wn
      }),
      styles: U({
        get: es,
        getRaw: Ha,
        set: ft,
        remove: is
      }),
      attrs: U({
        get: Tr,
        set: as,
        remove: Ae,
        copyTo: Q
      }),
      insert: U({
        before: Ba,
        after: ca,
        afterAll: Is,
        append: Qs,
        appendAll: ka,
        prepend: gr,
        wrap: xc
      }),
      remove: U({
        unwrap: Oi,
        remove: Qr
      }),
      create: U({
        nu: $e.fromTag,
        clone: m,
        text: $e.fromText
      }),
      query: U({
        comparePosition: z,
        prevSibling: Ti,
        nextSibling: Ai
      }),
      property: U({
        children: ko,
        name: ks,
        parent: Jo,
        document: v,
        isText: Ke,
        isComment: _s,
        isElement: wr,
        isSpecial: le,
        getLanguage: xe,
        getText: Ir,
        setText: Sd,
        isBoundary: C,
        isEmptyTag: _,
        isNonEditable: P
      }),
      eq: Zt,
      is: Jn
    };
  };
  const lO = (m, v, C, _) => {
    const P = C[0], z = C.slice(1);
    return _(m, v, P, z);
  }, ag = (m, v, C) => C.length > 0 ? lO(m, v, C, rw) : Ce.none(), rw = (m, v, C, _) => {
    const P = v(m, C);
    return Cn(_, (z, Q) => {
      const le = v(m, Q);
      return lf(m, z, le);
    }, P);
  }, lf = (m, v, C) => v.bind((_) => C.filter(rt(m.eq, _))), aw = (m, v) => rt(m.eq, v), _v = (m, v, C, _ = Vt) => {
    const P = [v].concat(m.up().all(v)), z = [C].concat(m.up().all(C)), Q = (at) => ds(at, _).fold(() => at, (_n) => at.slice(0, _n + 1)), le = Q(P), xe = Q(z), Fe = X(le, (at) => ze(xe, aw(m, at)));
    return {
      firstpath: le,
      secondpath: xe,
      shared: Fe
    };
  }, qr = ag, qf = _v, l_ = zp(), Td = (m, v) => qr(l_, (C, _) => m(_), v), iw = (m, v, C) => qf(l_, m, v, C), Jb = (m) => Ll(m, "table"), Ev = (m, v, C) => {
    const _ = (P) => (z) => C !== void 0 && C(z) || Zt(z, P);
    return Zt(m, v) ? Ce.some({
      boxes: Ce.some([m]),
      start: m,
      finish: v
    }) : Jb(m).bind((P) => Jb(v).bind((z) => {
      if (Zt(P, z))
        return Ce.some({
          boxes: sw(P, m, v),
          start: m,
          finish: v
        });
      if (kn(P, z)) {
        const Q = Yo(v, "td,th", _(P)), le = Q.length > 0 ? Q[Q.length - 1] : v;
        return Ce.some({
          boxes: ey(P, m, P, v, z),
          start: m,
          finish: le
        });
      } else if (kn(z, P)) {
        const Q = Yo(m, "td,th", _(z)), le = Q.length > 0 ? Q[Q.length - 1] : m;
        return Ce.some({
          boxes: ey(z, m, P, v, z),
          start: m,
          finish: le
        });
      } else
        return iw(m, v).shared.bind((Q) => Dr(Q, "table", C).bind((le) => {
          const xe = Yo(v, "td,th", _(le)), Fe = xe.length > 0 ? xe[xe.length - 1] : v, at = Yo(m, "td,th", _(le)), Yt = at.length > 0 ? at[at.length - 1] : m;
          return Ce.some({
            boxes: ey(le, m, P, v, z),
            start: Yt,
            finish: Fe
          });
        }));
    }));
  }, e1 = (m, v) => {
    const C = Or(m, v);
    return C.length > 0 ? Ce.some(C) : Ce.none();
  }, Gc = (m, v) => X(m, (C) => Oo(C, v)), c_ = (m, v, C) => xi(m, v).bind((_) => xi(m, C).bind((P) => Td(Jb, [
    _,
    P
  ]).map((z) => ({
    first: _,
    last: P,
    table: z
  })))), t1 = (m, v) => Ll(m, "table").bind((C) => xi(C, v).bind((_) => Ev(_, m).bind((P) => P.boxes.map((z) => ({
    boxes: z,
    start: P.start,
    finish: P.finish
  }))))), lw = (m, v, C, _, P) => Gc(m, P).bind((z) => i_(z, v, C).bind((Q) => t1(Q, _))), Vp = (m, v) => e1(m, v), cw = (m, v, C) => c_(m, v, C).bind((_) => {
    const P = (xe) => Zt(m, xe), z = "thead,tfoot,tbody,table", Q = Ll(_.first, z, P), le = Ll(_.last, z, P);
    return Q.bind((xe) => le.bind((Fe) => Zt(xe, Fe) ? Ft(_.table, _.first, _.last) : Ce.none()));
  }), u_ = ve, uw = (m) => {
    const v = (_, P) => Ne(_, P).exists((z) => parseInt(z, 10) > 1), C = (_) => v(_, "rowspan") || v(_, "colspan");
    return m.length > 0 && Pt(m, C) ? Ce.some(m) : Ce.none();
  }, d_ = (m, v, C) => v.length <= 1 ? Ce.none() : cw(m, C.firstSelectedSelector, C.lastSelectedSelector).map((_) => ({
    bounds: _,
    cells: v
  })), Hl = "data-mce-selected", qc = "td[" + Hl + "],th[" + Hl + "]", Jt = "[" + Hl + "]", ty = "data-mce-first-selected", Xi = "td[" + ty + "],th[" + ty + "]", ny = "data-mce-last-selected", f_ = "td[" + ny + "],th[" + ny + "]", Kr = Jt, Lm = {
    selected: Hl,
    selectedSelector: qc,
    firstSelected: ty,
    firstSelectedSelector: Xi,
    lastSelected: ny,
    lastSelectedSelector: f_
  }, oy = (m, v, C) => ({
    element: C,
    mergable: d_(v, m, Lm),
    unmergable: uw(m),
    selection: u_(m)
  }), cO = (m, v, C) => ({
    element: m,
    clipboard: v,
    generators: C
  }), $m = (m, v, C, _) => ({
    selection: u_(m),
    clipboard: C,
    generators: _
  }), sy = (m) => Zi(m).bind((v) => Vp(v, Lm.firstSelectedSelector)).fold(U(m), (v) => v[0]), cf = (m) => (v, C) => {
    const _ = ks(v), P = _ === "col" || _ === "colgroup" ? sy(v) : v;
    return Dr(P, m, C);
  }, m_ = cf("th,td,caption"), dw = cf("th,td"), Vr = (m) => nf(m.model.table.getSelectedCells()), Tv = (m) => Rt(Vr(m), (v) => Oo(v, Lm.selectedSelector)), ba = (m) => Zi(m[0]).map((v) => {
    const C = No(v, Kr);
    return rc(C), [C];
  }), p_ = (m, v) => Tt(v, (C) => m.selection.serializer.serialize(C.dom, {})).join(""), Kc = (m) => Tt(m, (v) => v.dom.innerText).join(""), Av = (m, v) => {
    m.on("BeforeGetContent", (C) => {
      const _ = (P) => {
        C.preventDefault(), ba(P).each((z) => {
          C.content = C.format === "text" ? Kc(z) : p_(m, z);
        });
      };
      if (C.selection === !0) {
        const P = Tv(m);
        P.length >= 1 && _(P);
      }
    }), m.on("BeforeSetContent", (C) => {
      if (C.selection === !0 && C.paste === !0) {
        const _ = Vr(m);
        je(_).each((P) => {
          Zi(P).each((z) => {
            const Q = Rt(jf(C.content), (xe) => ks(xe) !== "meta"), le = En("table");
            if (rf(m) && Q.length === 1 && le(Q[0])) {
              C.preventDefault();
              const xe = $e.fromDom(m.getDoc()), Fe = Fm(xe), at = cO(P, Q[0], Fe);
              v.pasteCells(z, at).each(() => {
                m.focus();
              });
            }
          });
        });
      }
    });
  }, Yc = (m, v) => ({
    element: m,
    offset: v
  }), uO = (m, v, C) => m.property().isText(v) && m.property().getText(v).trim().length === 0 || m.property().isComment(v) ? C(v).bind((_) => uO(m, _, C).orThunk(() => Ce.some(_))) : Ce.none(), dO = (m, v) => m.property().isText(v) ? m.property().getText(v).length : m.property().children(v).length, fO = (m, v) => {
    const C = uO(m, v, m.query().prevSibling).getOr(v);
    if (m.property().isText(C))
      return Yc(C, dO(m, C));
    const _ = m.property().children(C);
    return _.length > 0 ? fO(m, _[_.length - 1]) : Yc(C, dO(m, C));
  }, mO = fO, Fi = zp(), ac = (m) => mO(Fi, m), n1 = (m, v) => {
    oa(m) || bv(m).each((_) => {
      const P = _.value / 2;
      Mt(m, P, _.unit), Mt(v, P, _.unit);
    });
  }, Up = (m) => Tt(m, U(0)), fw = (m, v, C, _, P) => P(m.slice(0, v)).concat(_).concat(P(m.slice(C))), Ov = (m) => (v, C, _, P) => {
    if (m(_)) {
      const z = Math.max(P, v[C] - Math.abs(_)), Q = Math.abs(z - v[C]);
      return _ >= 0 ? Q : -Q;
    } else
      return _;
  }, Kf = Ov((m) => m < 0), Dv = Ov(Ue), ig = () => {
    const m = (le, xe, Fe, at, Yt) => {
      const _n = Kf(le, xe, at, Yt);
      return fw(le, xe, Fe + 1, [
        _n,
        0
      ], Up);
    }, v = (le, xe, Fe, at) => {
      const Yt = (100 + Fe) / 100, _n = Math.max(at, (le[xe] + Fe) / Yt);
      return Tt(le, (vn, ln) => (ln === xe ? _n : vn / Yt) - vn);
    }, C = (le, xe, Fe, at, Yt, _n) => _n ? v(le, xe, at, Yt) : m(le, xe, Fe, at, Yt);
    return {
      resizeTable: (le, xe) => le(xe),
      clampTableDelta: Kf,
      calcLeftEdgeDeltas: C,
      calcMiddleDeltas: (le, xe, Fe, at, Yt, _n, vn) => C(le, Fe, at, Yt, _n, vn),
      calcRightEdgeDeltas: (le, xe, Fe, at, Yt, _n) => {
        if (_n)
          return v(le, Fe, at, Yt);
        {
          const vn = Kf(le, Fe, at, Yt);
          return Up(le.slice(0, Fe)).concat([vn]);
        }
      },
      calcRedestributedWidths: (le, xe, Fe, at) => {
        if (at) {
          const _n = (xe + Fe) / xe, vn = Tt(le, (ln) => ln / _n);
          return {
            delta: _n * 100 - 100,
            newSizes: vn
          };
        } else
          return {
            delta: Fe,
            newSizes: le
          };
      }
    };
  }, jp = () => {
    const m = (Q, le, xe, Fe, at) => {
      const Yt = Fe >= 0 ? xe : le, _n = Dv(Q, Yt, Fe, at);
      return fw(Q, le, xe + 1, [
        _n,
        -_n
      ], Up);
    };
    return {
      resizeTable: (Q, le, xe) => {
        xe && Q(le);
      },
      clampTableDelta: (Q, le, xe, Fe, at) => {
        if (at) {
          if (xe >= 0)
            return xe;
          {
            const Yt = et(Q, (_n, vn) => _n + vn - Fe, 0);
            return Math.max(-Yt, xe);
          }
        } else
          return Kf(Q, le, xe, Fe);
      },
      calcLeftEdgeDeltas: m,
      calcMiddleDeltas: (Q, le, xe, Fe, at, Yt) => m(Q, xe, Fe, at, Yt),
      calcRightEdgeDeltas: (Q, le, xe, Fe, at, Yt) => {
        if (Yt)
          return Up(Q);
        {
          const _n = Fe / Q.length;
          return Tt(Q, U(_n));
        }
      },
      calcRedestributedWidths: (Q, le, xe, Fe) => ({
        delta: 0,
        newSizes: Q
      })
    };
  }, Yf = (m) => ls.fromTable(m).grid, lg = En("th"), cg = (m) => Pt(m, (v) => lg(v.element)), pO = (m, v) => m && v ? "sectionCells" : m ? "section" : "cells", mw = (m) => {
    const v = m.section === "thead", C = Cc(ry(m.cells), "th");
    return m.section === "tfoot" ? { type: "footer" } : v || C ? {
      type: "header",
      subType: pO(v, C)
    } : { type: "body" };
  }, ry = (m) => {
    const v = Rt(m, (C) => lg(C.element));
    return v.length === 0 ? Ce.some("td") : v.length === m.length ? Ce.some("th") : Ce.none();
  }, h_ = (m) => {
    const v = Tt(m, (P) => mw(P).type), C = fn(v, "header"), _ = fn(v, "footer");
    if (!C && !_)
      return Ce.some("body");
    {
      const P = fn(v, "body");
      return C && !P && !_ ? Ce.some("header") : !C && !P && _ ? Ce.some("footer") : Ce.none();
    }
  }, pw = (m) => qn(m.all, (v) => {
    const C = mw(v);
    return C.type === "header" ? Ce.from(C.subType) : Ce.none();
  }), ay = (m, v, C) => ie(C(m.element, v), !0, m.isLocked), hw = (m, v) => m.section !== v ? Oe(m.element, m.cells, v, m.isNew) : m, iy = () => ({
    transformRow: hw,
    transformCell: (m, v, C) => {
      const _ = C(m.element, v), P = ks(_) !== "td" ? vi(_, "td") : _;
      return ie(P, m.isNew, m.isLocked);
    }
  }), Rv = () => ({
    transformRow: hw,
    transformCell: ay
  }), ly = () => ({
    transformRow: (m, v) => hw(m, v === "thead" ? "tbody" : v),
    transformCell: ay
  }), uf = {
    getTableSectionType: (m, v) => {
      const C = ls.fromTable(m);
      switch (pw(C).getOr(v)) {
        case "section":
          return iy();
        case "sectionCells":
          return Rv();
        case "cells":
          return ly();
      }
    },
    section: iy,
    sectionCells: Rv,
    cells: ly,
    fallback: () => ({
      transformRow: ve,
      transformCell: ay
    })
  }, Nv = (m, v, C, _) => {
    C === _ ? Ae(m, v) : as(m, v, C);
  }, g_ = (m, v, C) => {
    An(Ln(m, v)).fold(() => gr(m, C), (_) => ca(_, C));
  }, v_ = (m, v) => {
    const C = gs(m, v).getOrThunk(() => {
      const _ = $e.fromTag(v, Zn(m).dom);
      return v === "thead" ? g_(m, "caption,colgroup", _) : v === "colgroup" ? g_(m, "caption", _) : Qs(m, _), _;
    });
    return li(C), C;
  }, cy = (m, v) => {
    const C = [], _ = [], P = (vn) => Tt(vn, (ln) => {
      ln.isNew && C.push(ln.element);
      const Wn = ln.element;
      return li(Wn), Je(ln.cells, (Wt) => {
        Wt.isNew && _.push(Wt.element), Nv(Wt.element, "colspan", Wt.colspan, 1), Nv(Wt.element, "rowspan", Wt.rowspan, 1), Qs(Wn, Wt.element);
      }), Wn;
    }), z = (vn) => At(vn, (ln) => Tt(ln.cells, (Wn) => (Nv(Wn.element, "span", Wn.colspan, 1), Wn.element))), Q = (vn, ln) => {
      const Wn = v_(m, ln), un = (ln === "colgroup" ? z : P)(vn);
      ka(Wn, un);
    }, le = (vn) => {
      gs(m, vn).each(Qr);
    }, xe = (vn, ln) => {
      vn.length > 0 ? Q(vn, ln) : le(ln);
    }, Fe = [], at = [], Yt = [], _n = [];
    return Je(v, (vn) => {
      switch (vn.section) {
        case "thead":
          Fe.push(vn);
          break;
        case "tbody":
          at.push(vn);
          break;
        case "tfoot":
          Yt.push(vn);
          break;
        case "colgroup":
          _n.push(vn);
          break;
      }
    }), xe(_n, "colgroup"), xe(Fe, "thead"), xe(at, "tbody"), xe(Yt, "tfoot"), {
      newRows: C,
      newCells: _
    };
  }, Wp = (m) => Tt(m, (v) => {
    const C = Za(v.element);
    return Je(v.cells, (_) => {
      const P = Di(_.element);
      Nv(P, "colspan", _.colspan, 1), Nv(P, "rowspan", _.rowspan, 1), Qs(C, P);
    }), C;
  }), gO = (m, v) => Tt(m, (C) => Sl(C, v)), gw = (m, v) => m[v], o1 = (m, v) => {
    if (m.length === 0)
      return 0;
    const C = m[0];
    return ds(m, (P) => !v(C.element, P.element)).getOr(m.length);
  }, vO = (m, v, C, _) => {
    const P = gw(m, v), z = P.section === "colgroup", Q = o1(P.cells.slice(C), _), le = z ? 1 : o1(gO(m.slice(v), C), _);
    return {
      colspan: Q,
      rowspan: le
    };
  }, uy = (m, v) => {
    const C = Tt(m, (P) => Tt(P.cells, Vt)), _ = (P, z, Q, le) => {
      for (let xe = P; xe < P + Q; xe++)
        for (let Fe = z; Fe < z + le; Fe++)
          C[xe][Fe] = !0;
    };
    return Tt(m, (P, z) => {
      const Q = At(P.cells, (le, xe) => {
        if (C[z][xe] === !1) {
          const Fe = vO(m, z, xe, v);
          return _(z, xe, Fe.rowspan, Fe.colspan), [fd(le.element, Fe.rowspan, Fe.colspan, le.isNew)];
        } else
          return [];
      });
      return Fu(P.element, Q, P.section, P.isNew);
    });
  }, Pv = (m, v, C) => {
    const _ = [];
    Je(m.colgroups, (P) => {
      const z = [];
      for (let Q = 0; Q < m.grid.columns; Q++) {
        const le = ls.getColumnAt(m, Q).map((xe) => ie(xe.element, C, !1)).getOrThunk(() => ie(v.colGap(), !0, !1));
        z.push(le);
      }
      _.push(Oe(P.element, z, "colgroup", C));
    });
    for (let P = 0; P < m.grid.rows; P++) {
      const z = [];
      for (let xe = 0; xe < m.grid.columns; xe++) {
        const Fe = ls.getAt(m, P, xe).map((at) => ie(at.element, C, at.isLocked)).getOrThunk(() => ie(v.gap(), !0, !1));
        z.push(Fe);
      }
      const Q = m.all[P], le = Oe(Q.element, z, Q.section, C);
      _.push(le);
    }
    return _;
  }, b_ = (m, v) => Pv(m, v, !1), dy = (m) => uy(m, Zt), vw = (m, v) => qn(m.all, (C) => X(C.cells, (_) => Zt(v, _.element))), y_ = (m, v, C) => {
    const _ = Tt(v.selection, (z) => xp(z).bind((Q) => vw(m, Q)).filter(C)), P = Mr(_);
    return Tm(P.length > 0, P);
  }, Al = (m, v, C, _, P) => (z, Q, le, xe) => {
    const Fe = ls.fromTable(z), at = Ce.from(xe == null ? void 0 : xe.section).getOrThunk(uf.fallback);
    return v(Fe, Q).map((_n) => {
      const vn = b_(Fe, le), ln = m(vn, _n, Zt, P(le), at), Wn = Zr(ln.grid), Wt = dy(ln.grid);
      return {
        info: _n,
        grid: Wt,
        cursor: ln.cursor,
        lockedColumns: Wn
      };
    }).bind((_n) => {
      const vn = cy(z, _n.grid), ln = Ce.from(xe == null ? void 0 : xe.sizing).getOrThunk(() => I.getTableSize(z)), Wn = Ce.from(xe == null ? void 0 : xe.resize).getOrThunk(jp);
      return C(z, _n.grid, _n.info, {
        sizing: ln,
        resize: Wn,
        section: at
      }), _(z), Ae(z, tc), _n.lockedColumns.length > 0 && as(z, tc, _n.lockedColumns.join(",")), Ce.some({
        cursor: _n.cursor,
        newRows: vn.newRows,
        newCells: vn.newCells
      });
    });
  }, s1 = (m, v) => xp(v.element).bind((C) => vw(m, C).map((_) => ({
    ..._,
    generators: v.generators,
    clipboard: v.clipboard
  }))), bw = (m, v) => y_(m, v, Ue).map((C) => ({
    cells: C,
    generators: v.generators,
    clipboard: v.clipboard
  })), Mv = (m, v) => v.mergable, x_ = (m, v) => v.unmergable, df = (m, v) => y_(m, v, Ue), Dc = (m, v) => y_(m, v, (C) => !C.isLocked), Iv = (m, v) => vw(m, v).exists((C) => !C.isLocked), Fv = (m, v) => Pt(v, (C) => Iv(m, C)), r1 = (m, v) => Mv(m, v).filter((C) => Fv(m, C.cells)), bO = (m, v) => x_(m, v).filter((C) => Fv(m, C)), yO = (m, v, C, _) => {
    const P = Pa(m).rows;
    if (P.length === 0)
      return m;
    for (let z = v.startRow; z <= v.finishRow; z++)
      for (let Q = v.startCol; Q <= v.finishCol; Q++) {
        const le = P[z], xe = Sl(le, Q).isLocked;
        Ho(le, Q, ie(_(), !1, xe));
      }
    return m;
  }, ug = (m, v, C, _) => {
    const P = Pa(m).rows;
    let z = !0;
    for (let Q = 0; Q < P.length; Q++)
      for (let le = 0; le < kl(P[0]); le++) {
        const xe = P[Q], Fe = Sl(xe, le), at = Fe.element, Yt = C(at, v);
        Yt && !z ? Ho(xe, le, ie(_(), !0, Fe.isLocked)) : Yt && (z = !1);
      }
    return m;
  }, Xc = (m, v) => et(m, (C, _) => ze(C, (P) => v(P.element, _.element)) ? C : C.concat([_]), []), w_ = (m, v, C, _) => (v > 0 && v < m[0].cells.length && Je(m, (P) => {
    const z = P.cells[v - 1];
    let Q = 0;
    const le = _();
    for (; P.cells.length > v + Q && C(z.element, P.cells[v + Q].element); )
      Ho(P, v + Q, ie(le, !0, P.cells[v + Q].isLocked)), Q++;
  }), m), Ma = (m, v, C, _) => {
    const P = Pa(m).rows;
    if (v > 0 && v < P.length) {
      const z = P[v - 1].cells, Q = Xc(z, C);
      Je(Q, (le) => {
        let xe = Ce.none();
        for (let Fe = v; Fe < P.length; Fe++)
          for (let at = 0; at < kl(P[0]); at++) {
            const Yt = P[Fe], _n = Sl(Yt, at);
            C(_n.element, le.element) && (xe.isNone() && (xe = Ce.some(_())), xe.each((ln) => {
              Ho(Yt, at, ie(ln, !0, _n.isLocked));
            }));
          }
      });
    }
    return m;
  }, dg = (m) => {
    const v = (z) => z(m), C = U(m), _ = () => P, P = {
      tag: !0,
      inner: m,
      fold: (z, Q) => Q(m),
      isValue: Ue,
      isError: Vt,
      map: (z) => fy.value(z(m)),
      mapError: _,
      bind: v,
      exists: v,
      forall: v,
      getOr: C,
      or: _,
      getOrThunk: C,
      orThunk: _,
      getOrDie: C,
      each: (z) => {
        z(m);
      },
      toOptional: () => Ce.some(m)
    };
    return P;
  }, Qc = (m) => {
    const v = () => C, C = {
      tag: !1,
      inner: m,
      fold: (_, P) => _(m),
      isValue: Vt,
      isError: Ue,
      map: v,
      mapError: (_) => fy.error(_(m)),
      bind: v,
      exists: Vt,
      forall: Ue,
      getOr: ve,
      or: ve,
      getOrThunk: wt,
      orThunk: wt,
      getOrDie: lt(String(m)),
      each: ye,
      toOptional: Ce.none
    };
    return C;
  }, fy = {
    value: dg,
    error: Qc,
    fromOption: (m, v) => m.fold(() => Qc(v), dg)
  }, Bv = (m, v, C) => {
    if (m.row >= v.length || m.column > kl(v[0]))
      return fy.error("invalid start address out of table bounds, row: " + m.row + ", column: " + m.column);
    const _ = v.slice(m.row), P = _[0].cells.slice(m.column), z = kl(C[0]), Q = C.length;
    return fy.value({
      rowDelta: _.length - Q,
      colDelta: P.length - z
    });
  }, fg = (m, v) => {
    const C = kl(m[0]), _ = kl(v[0]);
    return {
      rowDelta: 0,
      colDelta: C - _
    };
  }, ff = (m, v) => {
    const C = m.length, _ = v.length;
    return {
      rowDelta: C - _,
      colDelta: 0
    };
  }, Jc = (m, v, C, _) => {
    const P = v.section === "colgroup" ? C.col : C.cell;
    return jt(m, (z) => ie(P(), !0, _(z)));
  }, yw = (m, v, C, _) => {
    const P = m[m.length - 1];
    return m.concat(jt(v, () => {
      const z = P.section === "colgroup" ? C.colgroup : C.row, Q = Ki(P, z, ve), le = Jc(Q.cells.length, Q, C, (xe) => it(_, xe.toString()));
      return da(Q, le);
    }));
  }, xw = (m, v, C, _) => Tt(m, (P) => {
    const z = Jc(v, P, C, Vt);
    return Tp(P, _, z);
  }), ww = (m, v, C) => Tt(m, (_) => et(C, (P, z) => {
    const Q = Jc(1, _, v, Ue)[0];
    return Ap(P, z, Q);
  }, _)), mg = (m, v, C) => {
    const _ = v.colDelta < 0 ? xw : ve, P = v.rowDelta < 0 ? yw : ve, z = Zr(m), Q = kl(m[0]), le = ze(z, (at) => at === Q - 1), xe = _(m, Math.abs(v.colDelta), C, le ? Q - 1 : Q), Fe = Zr(xe);
    return P(xe, Math.abs(v.rowDelta), C, Nt(Fe, Ue));
  }, xO = (m, v, C, _) => {
    const P = Sl(m[v], C), z = rt(_, P.element), Q = m[v];
    return m.length > 1 && kl(Q) > 1 && (C > 0 && z(fl(Q, C - 1)) || C < Q.cells.length - 1 && z(fl(Q, C + 1)) || v > 0 && z(fl(m[v - 1], C)) || v < m.length - 1 && z(fl(m[v + 1], C)));
  }, pg = (m, v, C, _, P, z) => {
    const Q = m.row, le = m.column, xe = C.length, Fe = kl(C[0]), at = Q + xe, Yt = le + Fe + z.length, _n = Nt(z, Ue);
    for (let vn = Q; vn < at; vn++) {
      let ln = 0;
      for (let Wn = le; Wn < Yt; Wn++) {
        if (_n[Wn]) {
          ln++;
          continue;
        }
        xO(v, vn, Wn, P) && ug(v, fl(v[vn], Wn), P, _.cell);
        const Wt = Wn - le - ln, un = Sl(C[vn - Q], Wt), wo = un.element, yn = _.replace(wo);
        Ho(v[vn], Wn, ie(yn, !0, un.isLocked));
      }
    }
    return v;
  }, Xf = (m, v, C) => {
    const _ = kl(v[0]), P = Pa(v).cols.length + m.row, z = jt(_ - m.column, (le) => le + m.column), Q = X(z, (le) => Pt(C, (xe) => xe !== le)).getOr(_ - 1);
    return {
      row: P,
      column: Q
    };
  }, a1 = (m, v, C) => Rt(C, (_) => _ >= m.column && _ <= kl(v[0]) + m.column), Os = (m, v, C, _, P) => {
    const z = Zr(v), Q = Xf(m, v, z), le = Pa(C).rows, xe = a1(Q, le, z);
    return Bv(Q, v, le).map((at) => {
      const Yt = {
        ...at,
        colDelta: at.colDelta - xe.length
      }, _n = mg(v, Yt, _), vn = Zr(_n), ln = a1(Q, le, vn);
      return pg(Q, _n, le, _, P, ln);
    });
  }, ic = (m, v, C, _, P) => {
    w_(v, m, P, _.cell);
    const z = ff(C, v), Q = mg(C, z, _), le = ff(v, Q), xe = mg(v, le, _);
    return Tt(xe, (Fe, at) => Tp(Fe, m, Q[at].cells));
  }, Gu = (m, v, C, _, P) => {
    Ma(v, m, P, _.cell);
    const z = Zr(v), Q = fg(v, C), le = {
      ...Q,
      colDelta: Q.colDelta - z.length
    }, xe = mg(v, le, _), {
      cols: Fe,
      rows: at
    } = Pa(xe), Yt = Zr(xe), _n = fg(C, v), vn = {
      ..._n,
      colDelta: _n.colDelta + Yt.length
    }, ln = ww(C, _, Yt), Wn = mg(ln, vn, _);
    return [
      ...Fe,
      ...at.slice(0, m),
      ...Wn,
      ...at.slice(m, at.length)
    ];
  }, Hm = (m, v, C, _) => Ki(m, (P) => _(P, C), v), Ur = (m, v, C, _, P) => {
    const { rows: z, cols: Q } = Pa(m), le = z.slice(0, v), xe = z.slice(v), Fe = Hm(z[C], (at, Yt) => v > 0 && v < z.length && _(fl(z[v - 1], Yt), fl(z[v], Yt)) ? Sl(z[v], Yt) : ie(P(at.element, _), !0, at.isLocked), _, P);
    return [
      ...Q,
      ...le,
      Fe,
      ...xe
    ];
  }, C_ = (m, v, C, _, P, z, Q) => {
    if (C === "colgroup" || !_) {
      const le = Sl(m, P);
      return ie(Q(le.element, z), !0, !1);
    } else
      return Sl(m, v);
  }, my = (m, v, C, _, P) => Tt(m, (z) => {
    const Q = v > 0 && v < kl(z) && _(fl(z, v - 1), fl(z, v)), le = C_(z, v, z.section, Q, C, _, P);
    return Ap(z, v, le);
  }), i1 = (m, v) => At(m, (C) => {
    const _ = C.cells, P = Cn(v, (z, Q) => Q >= 0 && Q < z.length ? z.slice(0, Q).concat(z.slice(Q + 1)) : z, _);
    return P.length > 0 ? [Oe(C.element, P, C.section, C.isNew)] : [];
  }), py = (m, v, C) => {
    const { rows: _, cols: P } = Pa(m);
    return [
      ...P,
      ..._.slice(0, v),
      ..._.slice(C + 1)
    ];
  }, wO = (m, v, C, _) => fl(m[v], C) !== void 0 && v > 0 && _(fl(m[v - 1], C), fl(m[v], C)), ma = (m, v, C) => v > 0 && C(fl(m, v - 1), fl(m, v)), Cw = (m, v, C, _) => wO(m, v, C, _) || ma(m[v], C, _), CO = (m, v) => Pt(v, ve) && cg(m.cells) ? Ue : (_, P, z) => !(ks(_.element) === "th" && v[z]), SO = (m, v) => Pt(v, ve) && cg(m) ? Ue : (_, P, z) => !(ks(_.element) === "th" && v[P]), Lv = (m, v, C, _) => {
    const P = (Q) => Q === "row" ? Jr(v) : oa(v), z = (Q) => P(Q) ? `${Q}group` : Q;
    return m ? lg(v) ? z(C) : null : _ && lg(v) ? z(C === "row" ? "col" : "row") : null;
  }, Mn = (m, v) => (C, _, P) => Ce.some(Lv(m, C.element, "col", v[P])), kO = (m, v) => (C, _) => Ce.some(Lv(m, C.element, "row", v[_])), S_ = (m, v, C) => ie(C(m.element, v), !0, m.isLocked), hy = (m, v, C, _, P, z, Q) => {
    const le = (xe) => ze(v, (Fe) => C(xe.element, Fe.element));
    return Tt(m, (xe, Fe) => $f(xe, (at, Yt) => {
      if (le(at)) {
        const _n = Q(at, Fe, Yt) ? P(at, C, _) : at;
        return z(_n, Fe, Yt).each((vn) => {
          Xr(_n.element, { scope: Ce.from(vn) });
        }), _n;
      } else
        return at;
    }));
  }, Sw = (m, v, C) => At(m, (_, P) => Cw(m, P, v, C) ? [] : [Sl(_, v)]), _O = (m, v, C) => {
    const _ = m[v];
    return At(_.cells, (P, z) => Cw(m, v, z, C) ? [] : [P]);
  }, l1 = (m, v, C, _, P) => {
    const z = Pa(m).rows, Q = At(v, (at) => Sw(z, at, _)), le = Tt(z, (at) => cg(at.cells)), xe = SO(Q, le), Fe = kO(C, le);
    return hy(m, Q, _, P, S_, Fe, xe);
  }, c1 = (m, v, C, _, P, z, Q) => {
    const { cols: le, rows: xe } = Pa(m), Fe = xe[v[0]], at = At(v, (Wt) => _O(xe, Wt, P)), Yt = Tt(Fe.cells, (Wt, un) => cg(Sw(xe, un, P))), _n = [...xe];
    Je(v, (Wt) => {
      _n[Wt] = Q.transformRow(xe[Wt], C);
    });
    const vn = [
      ...le,
      ..._n
    ], ln = CO(Fe, Yt), Wn = Mn(_, Yt);
    return hy(vn, at, P, z, Q.transformCell, Wn, ln);
  }, hg = (m, v, C, _) => {
    const P = Pa(m).rows, z = Tt(v, (Q) => Sl(P[Q.row], Q.column));
    return hy(m, z, C, _, S_, Ce.none, Ue);
  }, Qf = { generate: (m) => {
    if (!N(m))
      throw new Error("cases must be an array");
    if (m.length === 0)
      throw new Error("there must be at least one case");
    const v = [], C = {};
    return Je(m, (_, P) => {
      const z = on(_);
      if (z.length !== 1)
        throw new Error("one and only one name per case");
      const Q = z[0], le = _[Q];
      if (C[Q] !== void 0)
        throw new Error("duplicate key detected:" + Q);
      if (Q === "cata")
        throw new Error("cannot have a case named cata (sorry)");
      if (!N(le))
        throw new Error("case arguments must be an array");
      v.push(Q), C[Q] = (...xe) => {
        const Fe = xe.length;
        if (Fe !== le.length)
          throw new Error("Wrong number of arguments to case " + Q + ". Expected " + le.length + " (" + le + "), got " + Fe);
        return {
          fold: (...Yt) => {
            if (Yt.length !== m.length)
              throw new Error("Wrong number of arguments to fold. Expected " + m.length + ", got " + Yt.length);
            return Yt[P].apply(null, xe);
          },
          match: (Yt) => {
            const _n = on(Yt);
            if (v.length !== _n.length)
              throw new Error("Wrong number of arguments to match. Expected: " + v.join(",") + `
Actual: ` + _n.join(","));
            if (!Pt(v, (ln) => fn(_n, ln)))
              throw new Error("Not all branches were specified when using match. Specified: " + _n.join(", ") + `
Required: ` + v.join(", "));
            return Yt[Q].apply(null, xe);
          },
          log: (Yt) => {
            console.log(Yt, {
              constructors: v,
              constructor: Q,
              params: xe
            });
          }
        };
      };
    }), C;
  } }, zm = { ...Qf.generate([
    { none: [] },
    { only: ["index"] },
    {
      left: [
        "index",
        "next"
      ]
    },
    {
      middle: [
        "prev",
        "index",
        "next"
      ]
    },
    {
      right: [
        "prev",
        "index"
      ]
    }
  ]) }, k_ = (m, v) => m.length === 0 ? zm.none() : m.length === 1 ? zm.only(0) : v === 0 ? zm.left(0, 1) : v === m.length - 1 ? zm.right(v - 1, v) : v > 0 && v < m.length - 1 ? zm.middle(v - 1, v, v + 1) : zm.none(), mf = (m, v, C, _, P) => {
    const z = m.slice(0), Q = k_(m, v), le = U(Tt(z, U(0))), xe = (_n) => _.singleColumnWidth(z[_n], C), Fe = (_n, vn) => P.calcLeftEdgeDeltas(z, _n, vn, C, _.minCellWidth(), _.isRelative), at = (_n, vn, ln) => P.calcMiddleDeltas(z, _n, vn, ln, C, _.minCellWidth(), _.isRelative), Yt = (_n, vn) => P.calcRightEdgeDeltas(z, _n, vn, C, _.minCellWidth(), _.isRelative);
    return Q.fold(le, xe, Fe, at, Yt);
  }, __ = (m, v, C) => {
    let _ = 0;
    for (let P = m; P < v; P++)
      _ += C[P] !== void 0 ? C[P] : 0;
    return _;
  }, $v = (m, v) => {
    const C = ls.justCells(m);
    return Tt(C, (_) => {
      const P = __(_.column, _.column + _.colspan, v);
      return {
        element: _.element,
        width: P,
        colspan: _.colspan
      };
    });
  }, TO = (m, v) => {
    const C = ls.justColumns(m);
    return Tt(C, (_, P) => ({
      element: _.element,
      width: v[P],
      colspan: _.colspan
    }));
  }, AO = (m, v) => Tt(m.all, (C, _) => ({
    element: C.element,
    height: v[_]
  })), OO = (m) => Cn(m, (v, C) => v + C, 0), kw = (m, v) => ls.hasColumns(m) ? TO(m, v) : $v(m, v), gy = (m, v, C) => {
    const _ = kw(m, v);
    Je(_, (P) => {
      C.setElementWidth(P.element, P.width);
    });
  }, E_ = (m, v, C, _, P) => {
    const z = ls.fromTable(m), Q = P.getCellDelta(v), le = P.getWidths(z, P), xe = C === z.grid.columns - 1, Fe = _.clampTableDelta(le, C, Q, P.minCellWidth(), xe), at = mf(le, C, Fe, P, _), Yt = Tt(at, (_n, vn) => _n + le[vn]);
    gy(z, Yt, P), _.resizeTable(P.adjustTableWidth, Fe, xe);
  }, _w = (m, v, C) => {
    const _ = ls.fromTable(m), P = Xe(_, m), z = Tt(P, (xe, Fe) => C === Fe ? Math.max(v + xe, qa()) : xe), Q = AO(_, z);
    Je(Q, (xe) => {
      Vf(xe.element, xe.height);
    }), Je(ls.justCells(_), (xe) => {
      Mm(xe.element);
    });
    const le = OO(z);
    Vf(m, le);
  }, DO = (m, v, C, _, P) => {
    const z = ls.generate(v), Q = _.getWidths(z, _), le = _.pixelWidth(), { newSizes: xe, delta: Fe } = P.calcRedestributedWidths(Q, le, C.pixelDelta, _.isRelative);
    gy(z, xe, _), _.adjustTableWidth(Fe);
  }, u1 = (m, v, C, _) => {
    const P = ls.generate(v), z = _.getWidths(P, _);
    gy(P, z, _);
  }, Zp = (m) => et(m, (C, _) => ze(C, (z) => z.column === _.column) ? C : C.concat([_]), []).sort((C, _) => C.column - _.column), Hv = En("col"), vy = En("colgroup"), Ew = (m) => ks(m) === "tr" || vy(m), by = (m) => {
    const v = Rr(m, "colspan", 1), C = Rr(m, "rowspan", 1);
    return {
      element: m,
      colspan: v,
      rowspan: C
    };
  }, Tw = (m, v = by) => {
    const C = (le) => Hv(le.element) ? m.col(le) : m.cell(le), _ = (le) => vy(le.element) ? m.colgroup(le) : m.row(le), P = (le) => {
      if (Ew(le))
        return _({ element: le });
      {
        const xe = le, Fe = C(v(xe));
        return z = Ce.some({
          item: xe,
          replacement: Fe
        }), Fe;
      }
    };
    let z = Ce.none();
    return { getOrInit: (le, xe) => z.fold(() => P(le), (Fe) => xe(le, Fe.item) ? Fe.replacement : P(le)) };
  }, Aw = (m) => (v) => {
    const C = [], _ = (Q, le) => X(C, (xe) => le(xe.item, Q)), P = (Q) => {
      const le = m === "td" ? { scope: null } : {}, xe = v.replace(Q, m, le);
      return C.push({
        item: Q,
        sub: xe
      }), xe;
    };
    return { replaceOrInit: (Q, le) => {
      if (Ew(Q) || Hv(Q))
        return Q;
      {
        const xe = Q;
        return _(xe, le).fold(() => P(xe), (Fe) => le(Q, Fe.item) ? Fe.sub : P(xe));
      }
    } };
  }, Ow = (m) => Ne(m, "scope").map((v) => v.substr(0, 3)), Qi = {
    modification: Tw,
    transform: Aw,
    merging: (m) => ({
      unmerge: (_) => {
        const P = Ow(_);
        return P.each((z) => as(_, "scope", z)), () => {
          const z = m.cell({
            element: _,
            colspan: 1,
            rowspan: 1
          });
          return is(z, "width"), is(_, "width"), P.each((Q) => as(z, "scope", Q)), z;
        };
      },
      merge: (_) => {
        const P = () => {
          const z = Mr(Tt(_, Ow));
          if (z.length === 0)
            return Ce.none();
          {
            const Q = z[0], le = [
              "row",
              "col"
            ];
            return ze(z, (Fe) => Fe !== Q && fn(le, Fe)) ? Ce.none() : Ce.from(Q);
          }
        };
        return is(_[0], "width"), P().fold(() => Ae(_[0], "scope"), (z) => as(_[0], "scope", z + "group")), U(_[0]);
      }
    })
  }, RO = [
    "body",
    "p",
    "div",
    "article",
    "aside",
    "figcaption",
    "figure",
    "footer",
    "header",
    "nav",
    "section",
    "ol",
    "ul",
    "table",
    "thead",
    "tfoot",
    "tbody",
    "caption",
    "tr",
    "td",
    "th",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "blockquote",
    "pre",
    "address"
  ], A_ = (m, v) => {
    const C = m.property().name(v);
    return fn([
      "ol",
      "ul"
    ], C);
  }, Gp = (m, v) => {
    const C = m.property().name(v);
    return fn(RO, C);
  }, gg = (m, v) => fn([
    "br",
    "img",
    "hr",
    "input"
  ], m.property().name(v)), Dw = zp(), gt = (m) => Gp(Dw, m), Jf = (m) => A_(Dw, m), NO = (m) => gg(Dw, m), O_ = (m) => {
    const v = En("br"), C = (xe) => Pt(xe, (Fe) => v(Fe) || Ke(Fe) && Ir(Fe).trim().length === 0), _ = (xe) => ks(xe) === "li" || lr(xe, Jf).isSome(), P = (xe) => Ai(xe).map((Fe) => gt(Fe) ? !0 : NO(Fe) ? ks(Fe) !== "img" : !1).getOr(!1), z = (xe) => xv(xe).bind((Fe) => {
      const at = P(Fe);
      return Jo(Fe).map((Yt) => at === !0 || _(Yt) || v(Fe) || gt(Yt) && !Zt(xe, Yt) ? [] : [$e.fromTag("br")]);
    }).getOr([]), le = (() => {
      const xe = At(m, (Fe) => {
        const at = ko(Fe);
        return C(at) ? [] : at.concat(z(Fe));
      });
      return xe.length === 0 ? [$e.fromTag("br")] : xe;
    })();
    li(m[0]), ka(m[0], le);
  }, d1 = (m) => Xb(m, !0), qu = (m) => {
    hd(m).length === 0 && Qr(m);
  }, f1 = (m, v) => ({
    grid: m,
    cursor: v
  }), D_ = (m) => qn(m, (v) => qn(v.cells, (C) => {
    const _ = C.element;
    return Tm(d1(_), _);
  })), Rw = (m, v, C) => {
    var _, P;
    const z = Pa(m).rows;
    return Ce.from((P = (_ = z[v]) === null || _ === void 0 ? void 0 : _.cells[C]) === null || P === void 0 ? void 0 : P.element).filter(d1).orThunk(() => D_(z));
  }, zl = (m, v, C) => {
    const _ = Rw(m, v, C);
    return f1(m, _);
  }, yy = (m) => et(m, (C, _) => ze(C, (z) => z.row === _.row) ? C : C.concat([_]), []).sort((C, _) => C.row - _.row), R_ = (m, v, C, _) => {
    const P = v[0].row, z = yy(v), Q = Cn(z, (le, xe) => ({
      grid: Ur(le.grid, P, xe.row + le.delta, C, _.getOrInit),
      delta: le.delta + 1
    }), {
      grid: m,
      delta: 0
    }).grid;
    return zl(Q, P, v[0].column);
  }, PO = (m, v, C, _) => {
    const P = yy(v), z = P[P.length - 1], Q = z.row + z.rowspan, le = Cn(P, (xe, Fe) => Ur(xe, Q, Fe.row, C, _.getOrInit), m);
    return zl(le, Q, v[0].column);
  }, N_ = (m, v, C, _) => {
    const P = v.details, z = Zp(P), Q = z[0].column, le = Cn(z, (xe, Fe) => ({
      grid: my(xe.grid, Q, Fe.column + xe.delta, C, _.getOrInit),
      delta: xe.delta + 1
    }), {
      grid: m,
      delta: 0
    }).grid;
    return zl(le, P[0].row, Q);
  }, MO = (m, v, C, _) => {
    const P = v.details, z = P[P.length - 1], Q = z.column + z.colspan, le = Zp(P), xe = Cn(le, (Fe, at) => my(Fe, Q, at.column, C, _.getOrInit), m);
    return zl(xe, P[0].row, Q);
  }, P_ = (m, v, C, _) => {
    const P = Zp(v), z = Tt(P, (le) => le.column), Q = l1(m, z, !0, C, _.replaceOrInit);
    return zl(Q, v[0].row, v[0].column);
  }, IO = (m, v, C, _) => {
    const P = hg(m, v, C, _.replaceOrInit);
    return zl(P, v[0].row, v[0].column);
  }, FO = (m, v, C, _) => {
    const P = Zp(v), z = Tt(P, (le) => le.column), Q = l1(m, z, !1, C, _.replaceOrInit);
    return zl(Q, v[0].row, v[0].column);
  }, M_ = (m, v, C, _) => {
    const P = hg(m, v, C, _.replaceOrInit);
    return zl(P, v[0].row, v[0].column);
  }, zv = (m, v) => (C, _, P, z, Q) => {
    const le = yy(_), xe = Tt(le, (at) => at.row), Fe = c1(C, xe, m, v, P, z.replaceOrInit, Q);
    return zl(Fe, _[0].row, _[0].column);
  }, BO = zv("thead", !0), I_ = zv("tbody", !1), Aa = zv("tfoot", !1), xy = (m, v, C, _) => {
    const P = Zp(v.details), z = i1(m, Tt(P, (le) => le.column)), Q = z.length > 0 ? z[0].cells.length - 1 : 0;
    return zl(z, P[0].row, Math.min(P[0].column, Q));
  }, F_ = (m, v, C, _) => {
    const P = yy(v), z = py(m, P[0].row, P[P.length - 1].row), Q = Math.max(Pa(z).rows.length - 1, 0);
    return zl(z, Math.min(v[0].row, Q), v[0].column);
  }, B_ = (m, v, C, _) => {
    const P = v.cells;
    O_(P);
    const z = yO(m, v.bounds, C, _.merge(P));
    return f1(z, Ce.from(P[0]));
  }, wy = (m, v, C, _) => {
    const z = Cn(v, (Q, le) => ug(Q, le, C, _.unmerge(le)), m);
    return f1(z, Ce.from(v[0]));
  }, Ol = (m, v, C, _) => {
    const z = ((xe, Fe) => {
      const at = ls.fromTable(xe);
      return Pv(at, Fe, !0);
    })(v.clipboard, v.generators), Q = Xl(v.row, v.column);
    return Os(Q, m, z, v.generators, C).fold(() => f1(m, Ce.some(v.element)), (xe) => zl(xe, v.row, v.column));
  }, Vl = (m, v, C) => {
    const _ = Uh(m, C.section), P = ls.generate(_);
    return Pv(P, v, !0);
  }, L_ = (m, v, C, _) => {
    const P = Pa(m).rows, z = v.cells[0].column, Q = P[v.cells[0].row], le = Vl(v.clipboard, v.generators, Q), xe = ic(z, m, le, v.generators, C);
    return zl(xe, v.cells[0].row, v.cells[0].column);
  }, $_ = (m, v, C, _) => {
    const P = Pa(m).rows, z = v.cells[v.cells.length - 1].column + v.cells[v.cells.length - 1].colspan, Q = P[v.cells[0].row], le = Vl(v.clipboard, v.generators, Q), xe = ic(z, m, le, v.generators, C);
    return zl(xe, v.cells[0].row, z);
  }, Nw = (m, v, C, _) => {
    const P = Pa(m).rows, z = v.cells[0].row, Q = P[z], le = Vl(v.clipboard, v.generators, Q), xe = Gu(z, m, le, v.generators, C);
    return zl(xe, v.cells[0].row, v.cells[0].column);
  }, H_ = (m, v, C, _) => {
    const P = Pa(m).rows, z = v.cells[v.cells.length - 1].row + v.cells[v.cells.length - 1].rowspan, Q = P[v.cells[0].row], le = Vl(v.clipboard, v.generators, Q), xe = Gu(z, m, le, v.generators, C);
    return zl(xe, z, v.cells[0].column);
  }, z_ = (m, v) => {
    const C = ls.fromTable(m);
    return df(C, v).bind((P) => {
      const z = P[P.length - 1], Q = P[0].column, le = z.column + z.colspan, xe = So(Tt(C.all, (Fe) => Rt(Fe.cells, (at) => at.column >= Q && at.column < le)));
      return ry(xe);
    }).getOr("");
  }, Pw = (m, v) => {
    const C = ls.fromTable(m);
    return df(C, v).bind(ry).getOr("");
  }, Mw = (m, v) => {
    const C = ls.fromTable(m);
    return df(C, v).bind((P) => {
      const z = P[P.length - 1], Q = P[0].row, le = z.row + z.rowspan, xe = C.all.slice(Q, le);
      return h_(xe);
    }).getOr("");
  }, Cy = (m, v, C, _) => u1(m, v, C, _.sizing), Vm = (m, v, C, _) => DO(m, v, C, _.sizing, _.resize), lc = (m, v) => ze(v, (C) => C.column === 0 && C.isLocked), Iw = (m, v) => ze(v, (C) => C.column + C.colspan >= m.grid.columns && C.isLocked), or = (m, v) => {
    const C = ef(m), _ = Zp(v);
    return et(_, (P, z) => {
      const le = C[z.column].map(cr).getOr(0);
      return P + le;
    }, 0);
  }, pf = (m) => (v, C) => df(v, C).filter((_) => !(m ? lc : Iw)(v, _)).map((_) => ({
    details: _,
    pixelDelta: or(v, _)
  })), m1 = (m, v) => Dc(m, v).map((C) => ({
    details: C,
    pixelDelta: -or(m, C)
  })), V_ = (m) => (v, C) => bw(v, C).filter((_) => !(m ? lc : Iw)(v, _.cells)), Sy = Qi.transform("th"), ky = Qi.transform("td"), qp = Al(R_, df, ye, ye, Qi.modification), Ji = Al(PO, df, ye, ye, Qi.modification), Kp = Al(N_, pf(!0), Vm, ye, Qi.modification), Fw = Al(MO, pf(!1), Vm, ye, Qi.modification), U_ = Al(xy, m1, Vm, qu, Qi.modification), LO = Al(F_, df, ye, qu, Qi.modification), Vv = Al(P_, Dc, ye, ye, Sy), Bw = Al(FO, Dc, ye, ye, ky), Lw = Al(BO, Dc, ye, ye, Sy), $w = Al(I_, Dc, ye, ye, ky), Hw = Al(Aa, Dc, ye, ye, ky), Bn = Al(IO, Dc, ye, ye, Sy), p1 = Al(M_, Dc, ye, ye, ky), zw = Al(B_, r1, Cy, ye, Qi.merging), Uv = Al(wy, bO, Cy, ye, Qi.merging), Ad = Al(Ol, s1, Cy, ye, Qi.modification), $O = Al(L_, V_(!0), ye, ye, Qi.modification), el = Al($_, V_(!1), ye, ye, Qi.modification), HO = Al(Nw, bw, ye, ye, Qi.modification), Yp = Al(H_, bw, ye, ye, Qi.modification), Vw = z_, j_ = Pw, Dl = Mw, Xp = (m, v) => m.dispatch("NewRow", { node: v }), _y = (m, v) => m.dispatch("NewCell", { node: v }), Qp = (m, v, C) => {
    m.dispatch("TableModified", {
      ...C,
      table: v
    });
  }, zO = (m, v, C, _, P) => {
    m.dispatch("TableSelectionChange", {
      cells: v,
      start: C,
      finish: _,
      otherCells: P
    });
  }, VO = (m) => {
    m.dispatch("TableSelectionClear");
  }, fi = (m, v, C, _, P) => {
    m.dispatch("ObjectResizeStart", {
      target: v,
      width: C,
      height: _,
      origin: P
    });
  }, ei = (m, v, C, _, P) => {
    m.dispatch("ObjectResized", {
      target: v,
      width: C,
      height: _,
      origin: P
    });
  }, mi = {
    structure: !1,
    style: !0
  }, br = {
    structure: !0,
    style: !1
  }, Si = {
    structure: !0,
    style: !0
  }, ti = (m, v) => Bp(m) ? I.percentageSize(v) : Bm(m) ? I.pixelSize(v) : I.getTableSize(v), Uw = (m, v, C) => {
    const _ = (Oa) => ks(ng(Oa)) === "table", P = (Oa) => !_(m) || Yf(Oa).rows > 1, z = (Oa) => !_(m) || Yf(Oa).columns > 1, Q = n_(m), le = Q0(m) ? ye : n1, xe = (Oa) => {
      switch (o_(m)) {
        case "section":
          return uf.section();
        case "sectionCells":
          return uf.sectionCells();
        case "cells":
          return uf.cells();
        default:
          return uf.getTableSectionType(Oa, "section");
      }
    }, Fe = (Oa, rm) => rm.cursor.fold(() => {
      const B1 = hd(Oa);
      return je(B1).filter(tr).map((nu) => {
        C.clearSelectedCells(Oa.dom);
        const zo = m.dom.createRng();
        return zo.selectNode(nu.dom), m.selection.setRng(zo), as(nu, "data-mce-selected", "1"), zo;
      });
    }, (B1) => {
      const nu = ac(B1), zo = m.dom.createRng();
      return zo.setStart(nu.element.dom, nu.offset), zo.setEnd(nu.element.dom, nu.offset), m.selection.setRng(zo), C.clearSelectedCells(Oa.dom), Ce.some(zo);
    }), at = (Oa, rm, B1, nu) => (zo, UC, jC = !1) => {
      rc(zo);
      const bx = $e.fromDom(m.getDoc()), XE = _d(B1, bx, Q), Mg = {
        sizing: ti(m, zo),
        resize: Q0(m) ? ig() : jp(),
        section: xe(zo)
      };
      return rm(zo) ? Oa(zo, UC, XE, Mg).bind((Xm) => {
        v.refresh(zo.dom), Je(Xm.newRows, (L1) => {
          Xp(m, L1.dom);
        }), Je(Xm.newCells, (L1) => {
          _y(m, L1.dom);
        });
        const QE = Fe(zo, Xm);
        return tr(zo) && (rc(zo), jC || Qp(m, zo.dom, nu)), QE.map((L1) => ({
          rng: L1,
          effect: nu
        }));
      }) : Ce.none();
    }, Yt = at(LO, P, ye, br), _n = at(U_, z, ye, br), vn = at(qp, Ue, ye, br), ln = at(Ji, Ue, ye, br), Wn = at(Kp, Ue, le, br), Wt = at(Fw, Ue, le, br), un = at(zw, Ue, ye, br), wo = at(Uv, Ue, ye, br), yn = at($O, Ue, ye, br), Ks = at(el, Ue, ye, br), yr = at(HO, Ue, ye, br), ur = at(Yp, Ue, ye, br), nl = at(Ad, Ue, ye, Si), ni = at(Bn, Ue, ye, br), sm = at(p1, Ue, ye, br), fh = at(Vv, Ue, ye, br), mh = at(Bw, Ue, ye, br), sr = at(Lw, Ue, ye, br), mc = at($w, Ue, ye, br), pc = at(Hw, Ue, ye, br);
    return {
      deleteRow: Yt,
      deleteColumn: _n,
      insertRowsBefore: vn,
      insertRowsAfter: ln,
      insertColumnsBefore: Wn,
      insertColumnsAfter: Wt,
      mergeCells: un,
      unmergeCells: wo,
      pasteColsBefore: yn,
      pasteColsAfter: Ks,
      pasteRowsBefore: yr,
      pasteRowsAfter: ur,
      pasteCells: nl,
      makeCellsHeader: ni,
      unmakeCellsHeader: sm,
      makeColumnsHeader: fh,
      unmakeColumnsHeader: mh,
      makeRowsHeader: sr,
      makeRowsBody: mc,
      makeRowsFooter: pc,
      getTableRowType: Dl,
      getTableCellType: j_,
      getTableColType: Vw
    };
  }, Ey = (m, v, C) => {
    const _ = Rr(m, v, 1);
    C === 1 || _ <= 1 ? Ae(m, v) : as(m, v, Math.min(C, _));
  }, jw = (m, v) => (C) => {
    const _ = C.column + C.colspan - 1, P = C.column;
    return _ >= m && P < v;
  }, W_ = (m, v, C) => {
    if (ls.hasColumns(m)) {
      const _ = Rt(ls.justColumns(m), jw(v, C)), P = Tt(_, (Q) => {
        const le = Di(Q.element);
        return Ey(le, "span", C - v), le;
      }), z = $e.fromTag("colgroup");
      return ka(z, P), [z];
    } else
      return [];
  }, Z_ = (m, v, C) => Tt(m.all, (_) => {
    const P = Rt(_.cells, jw(v, C)), z = Tt(P, (le) => {
      const xe = Di(le.element);
      return Ey(xe, "colspan", C - v), xe;
    }), Q = $e.fromTag("tr");
    return ka(Q, z), Q;
  }), Ty = (m, v) => {
    const C = ls.fromTable(m);
    return Dc(C, v).map((P) => {
      const z = P[P.length - 1], Q = P[0].column, le = z.column + z.colspan, xe = W_(C, Q, le), Fe = Z_(C, Q, le);
      return [
        ...xe,
        ...Fe
      ];
    });
  }, Ay = (m, v, C) => {
    const _ = ls.fromTable(m);
    return df(_, v).bind((z) => {
      const Q = Pv(_, C, !1), xe = Pa(Q).rows.slice(z[0].row, z[z.length - 1].row + z[z.length - 1].rowspan), Fe = At(xe, (Yt) => {
        const _n = Rt(Yt.cells, (vn) => !vn.isLocked);
        return _n.length > 0 ? [{
          ...Yt,
          cells: _n
        }] : [];
      }), at = dy(Fe);
      return Tm(at.length > 0, at);
    }).map((z) => Wp(z));
  }, vg = Qf.generate([
    { invalid: ["raw"] },
    { pixels: ["value"] },
    { percent: ["value"] }
  ]), Ww = (m, v, C) => {
    const _ = C.substring(0, C.length - m.length), P = parseFloat(_);
    return _ === P.toString() ? v(P) : vg.invalid(C);
  }, bg = {
    ...vg,
    from: (m) => wi(m, "%") ? Ww("%", vg.percent, m) : wi(m, "px") ? Ww("px", vg.pixels, m) : vg.invalid(m)
  }, UO = (m, v) => Tt(m, (C) => bg.from(C).fold(() => C, (P) => P / v * 100 + "%", (P) => P + "%")), Rc = (m, v, C) => {
    const _ = C / v;
    return Tt(m, (P) => bg.from(P).fold(() => P, (Q) => Q * _ + "px", (Q) => Q / 100 * C + "px"));
  }, GI = (m, v) => {
    const C = m.fold(() => U(""), (_) => {
      const P = _ / v;
      return U(P + "px");
    }, () => {
      const _ = 100 / v;
      return U(_ + "%");
    });
    return jt(v, C);
  }, jO = (m, v, C) => m.fold(() => v, (_) => Rc(v, C, _), (_) => UO(v, C)), vu = (m, v, C) => {
    const _ = bg.from(C), P = Pt(m, (z) => z === "0px") ? GI(_, m.length) : jO(_, m, v);
    return cc(P);
  }, h1 = (m, v) => m.length === 0 ? v : Cn(m, (C, _) => bg.from(_).fold(U(0), ve, ve) + C, 0), g1 = (m, v) => {
    const C = Math.floor(m);
    return {
      value: C + v,
      remainder: m - C
    };
  }, hf = (m, v) => bg.from(m).fold(U(m), (C) => C + v + "px", (C) => C + v + "%"), cc = (m) => {
    if (m.length === 0)
      return m;
    const v = Cn(m, (_, P) => {
      const z = bg.from(P).fold(() => ({
        value: P,
        remainder: 0
      }), (Q) => g1(Q, "px"), (Q) => ({
        value: Q + "%",
        remainder: 0
      }));
      return {
        output: [z.value].concat(_.output),
        remainder: _.remainder + z.remainder
      };
    }, {
      output: [],
      remainder: 0
    }), C = v.output;
    return C.slice(0, C.length - 1).concat([hf(C[C.length - 1], Math.round(v.remainder))]);
  }, Jp = bg.from, Zw = (m, v, C) => {
    Je(v, (_) => {
      const P = m.slice(_.column, _.colspan + _.column), z = h1(P, Sc());
      ft(_.element, "width", z + C);
    });
  }, Oy = (m, v, C) => {
    Je(v, (_, P) => {
      const z = h1([m[P]], Sc());
      ft(_.element, "width", z + C);
    });
  }, G_ = (m, v, C) => {
    Je(C, (_) => {
      is(_.element, "height");
    }), Je(v, (_, P) => {
      ft(_.element, "height", m[P]);
    });
  }, yg = (m) => Jp(m).fold(U("px"), U("px"), U("%")), Gw = (m, v, C) => {
    const _ = ls.fromTable(m), P = _.all, z = ls.justCells(_), Q = ls.justColumns(_);
    v.each((le) => {
      const xe = yg(le), Fe = za(m), at = Cd(_, m), Yt = vu(at, Fe, le);
      ls.hasColumns(_) ? Oy(Yt, Q, xe) : Zw(Yt, z, xe), ft(m, "width", le);
    }), C.each((le) => {
      const xe = V(m), Fe = Wc(_, m), at = vu(Fe, xe, le);
      G_(at, P, z), ft(m, "height", le);
    });
  }, qw = Yi, q_ = Y2, K_ = Tc, v1 = (m) => {
    Ae(m, "width"), Ae(m, "height");
  }, xg = (m) => {
    const v = Va(m);
    Gw(m, Ce.some(v), Ce.none()), v1(m);
  }, Kw = (m) => {
    const v = Ls(m);
    Gw(m, Ce.some(v), Ce.none()), v1(m);
  }, Yw = (m) => {
    const v = yv(m);
    Gw(m, Ce.none(), Ce.some(v)), v1(m);
  }, Y_ = (m) => {
    is(m, "width");
    const v = kc(m), C = v.length > 0 ? v : hd(m);
    Je(C, (_) => {
      is(_, "width"), v1(_);
    }), v1(m);
  }, X_ = {
    styles: {
      "border-collapse": "collapse",
      width: "100%"
    },
    attributes: { border: "1" },
    colGroups: !1
  }, WO = () => $e.fromTag("th"), Dy = () => $e.fromTag("td"), Q_ = () => $e.fromTag("col"), ZO = (m, v, C, _) => {
    const P = $e.fromTag("tr");
    for (let z = 0; z < m; z++) {
      const Q = _ < v || z < C ? WO() : Dy();
      z < C && as(Q, "scope", "row"), _ < v && as(Q, "scope", "col"), Qs(Q, $e.fromTag("br")), Qs(P, Q);
    }
    return P;
  }, J_ = (m) => {
    const v = $e.fromTag("colgroup");
    return jt(m, () => Qs(v, Q_())), v;
  }, b1 = (m, v, C, _) => jt(m, (P) => ZO(v, C, _, P)), GO = (m, v, C, _, P, z = X_) => {
    const Q = $e.fromTag("table"), le = P !== "cells";
    eo(Q, z.styles), Yr(Q, z.attributes), z.colGroups && Qs(Q, J_(v));
    const xe = Math.min(m, C);
    if (le && C > 0) {
      const vn = $e.fromTag("thead");
      Qs(Q, vn);
      const Wn = b1(C, v, P === "sectionCells" ? xe : 0, _);
      ka(vn, Wn);
    }
    const Fe = $e.fromTag("tbody");
    Qs(Q, Fe);
    const at = le ? m - xe : m, _n = b1(at, v, le ? 0 : C, _);
    return ka(Fe, _n), Q;
  }, eE = (m) => m.dom.innerHTML, uc = (m) => {
    const v = $e.fromTag("div"), C = $e.fromDom(m.dom.cloneNode(!0));
    return Qs(v, C), eE(v);
  }, Xw = (m, v) => {
    m.selection.select(v.dom, !0), m.selection.collapse(!0);
  }, Qw = (m, v) => {
    xi(v, "td,th").each(rt(Xw, m));
  }, Jw = (m, v) => {
    Je(Or(v, "tr"), (C) => {
      Xp(m, C.dom), Je(Or(C, "th,td"), (_) => {
        _y(m, _.dom);
      });
    });
  }, Ry = (m) => k(m) && m.indexOf("%") !== -1, qO = (m, v, C, _, P) => {
    const z = Kb(m), Q = {
      styles: z,
      attributes: Tl(m),
      colGroups: J2(m)
    };
    return m.undoManager.ignore(() => {
      const le = GO(C, v, P, _, o_(m), Q);
      as(le, "data-mce-id", "__mce");
      const xe = uc(le);
      m.insertContent(xe), m.addVisual();
    }), xi(ng(m), 'table[data-mce-id="__mce"]').map((le) => (Bm(m) ? Kw(le) : ju(m) ? Y_(le) : (Bp(m) || Ry(z.width)) && xg(le), rc(le), Ae(le, "data-mce-id"), Jw(m, le), Qw(m, le), le.dom)).getOrNull();
  }, KO = (m, v, C, _ = {}) => {
    const P = (z) => be(z) && z > 0;
    if (P(v) && P(C)) {
      const z = _.headerRows || 0, Q = _.headerColumns || 0;
      return qO(m, C, v, Q, z);
    } else
      return console.error("Invalid values for mceInsertTable - rows and columns values are required to insert a table."), null;
  };
  var Ny = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
  const tE = "x-tinymce/dom-table-", eC = tE + "rows", tC = tE + "columns", y1 = (m) => {
    const v = Ny.FakeClipboardItem(m);
    Ny.write([v]);
  }, nC = (m) => {
    var v;
    const C = (v = Ny.read()) !== null && v !== void 0 ? v : [];
    return qn(C, (_) => Ce.from(_.getType(m)));
  }, nE = (m) => {
    nC(m).isSome() && Ny.clear();
  }, oE = (m) => {
    m.fold(YO, (v) => y1({ [eC]: v }));
  }, sE = () => nC(eC), YO = () => nE(eC), rE = (m) => {
    m.fold(iE, (v) => y1({ [tC]: v }));
  }, aE = () => nC(tC), iE = () => nE(tC), Py = (m) => m_(Zu(m), af(m)).filter($p), jv = (m) => dw(Zu(m), af(m)).filter($p), lE = (m, v) => {
    const C = af(m), _ = () => Py(m).each((Wt) => {
      Zi(Wt, C).filter(ee(C)).each((un) => {
        const wo = $e.fromText("");
        if (ca(un, wo), Qr(un), m.dom.isEmpty(m.getBody()))
          m.setContent(""), m.selection.setCursorLocation();
        else {
          const yn = m.dom.createRng();
          yn.setStart(wo.dom, 0), yn.setEnd(wo.dom, 0), m.selection.setRng(yn), m.nodeChanged();
        }
      });
    }), P = (Wt) => Py(m).each((un) => {
      ju(m) || Bm(m) || Bp(m) || Zi(un, C).each((yn) => {
        Wt === "relative" && !qw(yn) ? xg(yn) : Wt === "fixed" && !q_(yn) ? Kw(yn) : Wt === "responsive" && !K_(yn) && Y_(yn), rc(yn), Qp(m, yn.dom, br);
      });
    }), z = (Wt) => Zi(Wt, C), Q = (Wt) => jv(m).bind((un) => z(un).map((wo) => Wt(wo, un))), le = (Wt, un) => {
      Q((wo) => {
        m.formatter.toggle("tableclass", { value: un }, wo.dom), Qp(m, wo.dom, mi);
      });
    }, xe = (Wt, un) => {
      Q((wo) => {
        const yn = Vr(m), yr = Pt(yn, (ur) => m.formatter.match("tablecellclass", { value: un }, ur.dom)) ? m.formatter.remove : m.formatter.apply;
        Je(yn, (ur) => yr("tablecellclass", { value: un }, ur.dom)), Qp(m, wo.dom, mi);
      });
    }, Fe = () => {
      Py(m).each((Wt) => {
        Zi(Wt, C).each((un) => {
          gs(un, "caption").fold(() => {
            const wo = $e.fromTag("caption");
            Qs(wo, $e.fromText("Caption")), ii(un, wo, 0), m.selection.setCursorLocation(wo.dom, 0);
          }, (wo) => {
            En("caption")(Wt) && Lt("td", un).each((yn) => m.selection.setCursorLocation(yn.dom, 0)), Qr(wo);
          }), Qp(m, un.dom, br);
        });
      });
    }, at = (Wt) => {
      m.focus();
    }, Yt = (Wt, un = !1) => Q((wo, yn) => {
      const Ks = oy(Vr(m), wo, yn);
      Wt(wo, Ks, un).each(at);
    }), _n = () => Q((Wt, un) => {
      const wo = oy(Vr(m), Wt, un), yn = _d(ye, $e.fromDom(m.getDoc()), Ce.none());
      return Ay(Wt, wo, yn);
    }), vn = () => Q((Wt, un) => {
      const wo = oy(Vr(m), Wt, un);
      return Ty(Wt, wo);
    }), ln = (Wt, un) => un().each((wo) => {
      const yn = Tt(wo, (Ks) => Di(Ks));
      Q((Ks, yr) => {
        const ur = Fm($e.fromDom(m.getDoc())), nl = $m(Vr(m), yr, yn, ur);
        Wt(Ks, nl).each(at);
      });
    }), Wn = (Wt) => (un, wo) => zs(wo, "type").each((yn) => {
      Yt(Wt(yn), wo.no_events);
    });
    vt({
      mceTableSplitCells: () => Yt(v.unmergeCells),
      mceTableMergeCells: () => Yt(v.mergeCells),
      mceTableInsertRowBefore: () => Yt(v.insertRowsBefore),
      mceTableInsertRowAfter: () => Yt(v.insertRowsAfter),
      mceTableInsertColBefore: () => Yt(v.insertColumnsBefore),
      mceTableInsertColAfter: () => Yt(v.insertColumnsAfter),
      mceTableDeleteCol: () => Yt(v.deleteColumn),
      mceTableDeleteRow: () => Yt(v.deleteRow),
      mceTableCutCol: () => vn().each((Wt) => {
        rE(Wt), Yt(v.deleteColumn);
      }),
      mceTableCutRow: () => _n().each((Wt) => {
        oE(Wt), Yt(v.deleteRow);
      }),
      mceTableCopyCol: () => vn().each((Wt) => rE(Wt)),
      mceTableCopyRow: () => _n().each((Wt) => oE(Wt)),
      mceTablePasteColBefore: () => ln(v.pasteColsBefore, aE),
      mceTablePasteColAfter: () => ln(v.pasteColsAfter, aE),
      mceTablePasteRowBefore: () => ln(v.pasteRowsBefore, sE),
      mceTablePasteRowAfter: () => ln(v.pasteRowsAfter, sE),
      mceTableDelete: _,
      mceTableCellToggleClass: xe,
      mceTableToggleClass: le,
      mceTableToggleCaption: Fe,
      mceTableSizingMode: (Wt, un) => P(un),
      mceTableCellType: Wn((Wt) => Wt === "th" ? v.makeCellsHeader : v.unmakeCellsHeader),
      mceTableColType: Wn((Wt) => Wt === "th" ? v.makeColumnsHeader : v.unmakeColumnsHeader),
      mceTableRowType: Wn((Wt) => {
        switch (Wt) {
          case "header":
            return v.makeRowsHeader;
          case "footer":
            return v.makeRowsFooter;
          default:
            return v.makeRowsBody;
        }
      })
    }, (Wt, un) => m.addCommand(un, Wt)), m.addCommand("mceInsertTable", (Wt, un) => {
      KO(m, un.rows, un.columns, un.options);
    }), m.addCommand("mceTableApplyCellStyle", (Wt, un) => {
      const wo = (yr) => "tablecell" + yr.toLowerCase().replace("-", "");
      if (!A(un))
        return;
      const yn = Rt(Vr(m), $p);
      if (yn.length === 0)
        return;
      const Ks = rs(un, (yr, ur) => m.formatter.has(wo(ur)) && k(yr));
      xn(Ks) || (vt(Ks, (yr, ur) => {
        const nl = wo(ur);
        Je(yn, (ni) => {
          yr === "" ? m.formatter.remove(nl, { value: null }, ni.dom, !0) : m.formatter.apply(nl, { value: yr }, ni.dom);
        });
      }), z(yn[0]).each((yr) => Qp(m, yr.dom, mi)));
    });
  }, XO = (m, v) => {
    const C = af(m), _ = (P) => dw(Zu(m)).bind((z) => Zi(z, C).map((Q) => {
      const le = oy(Vr(m), Q, z);
      return P(Q, le);
    })).getOr("");
    vt({
      mceTableRowType: () => _(v.getTableRowType),
      mceTableCellType: () => _(v.getTableCellType),
      mceTableColType: () => _(v.getTableColType)
    }, (P, z) => m.addQueryValueHandler(z, P));
  }, My = Qf.generate([
    { before: ["element"] },
    {
      on: [
        "element",
        "offset"
      ]
    },
    { after: ["element"] }
  ]), QO = (m, v, C, _) => m.fold(v, C, _), Od = (m) => m.fold(ve, ve, ve), Iy = My.before, Fy = My.on, By = My.after, dc = {
    before: Iy,
    on: Fy,
    after: By,
    cata: QO,
    getStart: Od
  }, th = { create: (m, v) => ({
    selection: m,
    kill: v
  }) }, JO = (m, v) => {
    const C = m.document.createRange();
    return C.selectNode(v.dom), C;
  }, nh = (m, v) => {
    const C = m.document.createRange();
    return x1(C, v), C;
  }, x1 = (m, v) => m.selectNodeContents(v.dom), eD = (m, v) => {
    v.fold((C) => {
      m.setStartBefore(C.dom);
    }, (C, _) => {
      m.setStart(C.dom, _);
    }, (C) => {
      m.setStartAfter(C.dom);
    });
  }, tD = (m, v) => {
    v.fold((C) => {
      m.setEndBefore(C.dom);
    }, (C, _) => {
      m.setEnd(C.dom, _);
    }, (C) => {
      m.setEndAfter(C.dom);
    });
  }, cE = (m, v, C) => {
    const _ = m.document.createRange();
    return eD(_, v), tD(_, C), _;
  }, Ly = (m, v, C, _, P) => {
    const z = m.document.createRange();
    return z.setStart(v.dom, C), z.setEnd(_.dom, P), z;
  }, $y = (m) => ({
    left: m.left,
    top: m.top,
    right: m.right,
    bottom: m.bottom,
    width: m.width,
    height: m.height
  }), nD = (m) => {
    const v = m.getClientRects(), C = v.length > 0 ? v[0] : m.getBoundingClientRect();
    return C.width > 0 || C.height > 0 ? Ce.some(C).map($y) : Ce.none();
  }, w1 = Qf.generate([
    {
      ltr: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    },
    {
      rtl: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]), oC = (m, v, C) => v($e.fromDom(C.startContainer), C.startOffset, $e.fromDom(C.endContainer), C.endOffset), oD = (m, v) => v.match({
    domRange: (C) => ({
      ltr: U(C),
      rtl: Ce.none
    }),
    relative: (C, _) => ({
      ltr: Yd(() => cE(m, C, _)),
      rtl: Yd(() => Ce.some(cE(m, _, C)))
    }),
    exact: (C, _, P, z) => ({
      ltr: Yd(() => Ly(m, C, _, P, z)),
      rtl: Yd(() => Ce.some(Ly(m, P, z, C, _)))
    })
  }), sC = (m, v) => {
    const C = v.ltr();
    return C.collapsed ? v.rtl().filter((P) => P.collapsed === !1).map((P) => w1.rtl($e.fromDom(P.endContainer), P.endOffset, $e.fromDom(P.startContainer), P.startOffset)).getOrThunk(() => oC(m, w1.ltr, C)) : oC(m, w1.ltr, C);
  }, rC = (m, v) => {
    const C = oD(m, v);
    return sC(m, C);
  }, Hy = (m, v) => rC(m, v).match({
    ltr: (_, P, z, Q) => {
      const le = m.document.createRange();
      return le.setStart(_.dom, P), le.setEnd(z.dom, Q), le;
    },
    rtl: (_, P, z, Q) => {
      const le = m.document.createRange();
      return le.setStart(z.dom, Q), le.setEnd(_.dom, P), le;
    }
  });
  w1.ltr, w1.rtl;
  const wg = { create: (m, v, C, _) => ({
    start: m,
    soffset: v,
    finish: C,
    foffset: _
  }) }, aC = { create: (m, v, C, _) => ({
    start: dc.on(m, v),
    finish: dc.on(C, _)
  }) }, dE = (m, v) => {
    const C = Hy(m, v);
    return wg.create($e.fromDom(C.startContainer), C.startOffset, $e.fromDom(C.endContainer), C.endOffset);
  }, zy = aC.create, rD = (m, v, C, _, P, z, Q) => Zt(C, P) && _ === z ? Ce.none() : Dr(C, "td,th", v).bind((le) => Dr(P, "td,th", v).bind((xe) => oh(m, v, le, xe, Q))), oh = (m, v, C, _, P) => Zt(C, _) ? Ce.none() : Ev(C, _, v).bind((z) => {
    const Q = z.boxes.getOr([]);
    return Q.length > 1 ? (P(m, Q, z.start, z.finish), Ce.some(th.create(Ce.some(zy(C, 0, C, ml(C))), !0))) : Ce.none();
  }), qI = (m, v, C, _, P) => {
    const z = (Q) => (P.clearBeforeUpdate(C), P.selectRange(C, Q.boxes, Q.start, Q.finish), Q.boxes);
    return lw(_, m, v, P.firstSelectedSelector, P.lastSelectedSelector).map(z);
  }, Wv = (m, v) => ({
    item: m,
    mode: v
  }), Vy = (m, v, C, _ = Zv) => m.property().parent(v).map((P) => Wv(P, _)), Zv = (m, v, C, _ = Gv) => C.sibling(m, v).map((P) => Wv(P, _)), Gv = (m, v, C, _ = Gv) => {
    const P = m.property().children(v);
    return C.first(P).map((Q) => Wv(Q, _));
  }, aD = [
    {
      current: Vy,
      next: Zv,
      fallback: Ce.none()
    },
    {
      current: Zv,
      next: Gv,
      fallback: Ce.some(Vy)
    },
    {
      current: Gv,
      next: Gv,
      fallback: Ce.some(Zv)
    }
  ], fE = (m, v, C, _, P = aD) => X(P, (Q) => Q.current === C).bind((Q) => Q.current(m, v, _, Q.next).orThunk(() => Q.fallback.bind((le) => fE(m, v, le, _)))), Um = {
    left: () => ({
      sibling: (C, _) => C.query().prevSibling(_),
      first: (C) => C.length > 0 ? Ce.some(C[C.length - 1]) : Ce.none()
    }),
    right: () => ({
      sibling: (C, _) => C.query().nextSibling(_),
      first: (C) => C.length > 0 ? Ce.some(C[0]) : Ce.none()
    })
  }, iC = (m, v, C, _, P, z) => fE(m, v, _, P).bind((le) => z(le.item) ? Ce.none() : C(le.item) ? Ce.some(le.item) : iC(m, le.item, C, le.mode, P, z)), lC = (m, v, C, _) => iC(m, v, C, Zv, Um.left(), _), lD = (m, v, C, _) => iC(m, v, C, Zv, Um.right(), _), cC = (m) => (v) => m.property().children(v).length === 0, mE = (m, v, C) => hE(m, v, cC(m), C), pE = (m, v, C) => qv(m, v, cC(m), C), hE = lC, qv = lD, jy = zp(), Cg = (m, v) => mE(jy, m, v), jm = (m, v) => pE(jy, m, v), C1 = (m, v, C) => hE(jy, m, v, C), Kv = (m, v, C) => qv(jy, m, v, C), cD = (m, v, C) => lr(m, v, C).isSome(), gf = Qf.generate([
    { none: ["message"] },
    { success: [] },
    { failedUp: ["cell"] },
    { failedDown: ["cell"] }
  ]), bu = (m, v, C) => {
    const _ = m.getRect(v), P = m.getRect(C);
    return P.right > _.left && P.left < _.right;
  }, Wy = (m) => Dr(m, "tr"), Sg = {
    ...gf,
    verify: (m, v, C, _, P, z, Q) => Dr(_, "td,th", Q).bind((le) => Dr(v, "td,th", Q).map((xe) => Zt(le, xe) ? Zt(_, le) && ml(le) === P ? z(xe) : gf.none("in same cell") : Td(Wy, [
      le,
      xe
    ]).fold(() => bu(m, xe, le) ? gf.success() : z(xe), (Fe) => z(xe)))).getOr(gf.none("default")),
    cata: (m, v, C, _, P) => m.fold(v, C, _, P)
  }, Yv = (m, v, C, _) => ({
    parent: m,
    children: v,
    element: C,
    index: _
  }), Xv = (m) => Jo(m).bind((v) => {
    const C = ko(v);
    return Rl(C, m).map((_) => Yv(v, C, m, _));
  }), Rl = (m, v) => ds(m, rt(Zt, v)), Zy = En("br"), kg = (m, v, C) => v(m, C).bind((_) => Ke(_) && Ir(_).trim().length === 0 ? kg(_, v, C) : Ce.some(_)), Gy = (m, v, C) => C.traverse(v).orThunk(() => kg(v, C.gather, m)).map(C.relative), gE = (m, v) => Zo(m, v).filter(Zy).orThunk(() => Zo(m, v - 1).filter(Zy)), uC = (m, v, C, _) => gE(v, C).bind((P) => _.traverse(P).fold(() => kg(P, _.gather, m).map(_.relative), (z) => Xv(z).map((Q) => dc.on(Q.parent, Q.index)))), qy = (m, v, C, _) => (Zy(v) ? Gy(m, v, _) : uC(m, v, C, _)).map((z) => ({
    start: z,
    finish: z
  })), Bi = (m) => Sg.cata(m, (v) => Ce.none(), () => Ce.none(), (v) => Ce.some(Yc(v, 0)), (v) => Ce.some(Yc(v, ml(v)))), Ky = (m, v) => ({
    left: m.left,
    top: m.top + v,
    right: m.right,
    bottom: m.bottom + v
  }), Dd = (m, v) => ({
    left: m.left,
    top: m.top - v,
    right: m.right,
    bottom: m.bottom - v
  }), dC = (m, v, C) => ({
    left: m.left + v,
    top: m.top + C,
    right: m.right + v,
    bottom: m.bottom + C
  }), fC = (m) => m.top, Wm = (m) => m.bottom, vE = (m, v, C) => C >= 0 && C < ml(v) ? m.getRangedRect(v, C, v, C + 1) : C > 0 ? m.getRangedRect(v, C - 1, v, C) : Ce.none(), sh = (m) => ({
    left: m.left,
    top: m.top,
    right: m.right,
    bottom: m.bottom
  }), Yy = (m, v) => Ce.some(m.getRect(v)), Xy = (m, v, C) => wr(v) ? Yy(m, v).map(sh) : Ke(v) ? vE(m, v, C).map(sh) : Ce.none(), mC = (m, v) => wr(v) ? Yy(m, v).map(sh) : Ke(v) ? m.getRangedRect(v, 0, v, ml(v)).map(sh) : Ce.none(), _g = 5, Qv = 100, pl = Qf.generate([
    { none: [] },
    { retry: ["caret"] }
  ]), bE = (m, v) => m.left < v.left || Math.abs(v.right - m.left) < 1 || m.left > v.right, pC = (m, v, C) => yi(v, gt).fold(Vt, (_) => mC(m, _).exists((P) => bE(C, P))), hC = (m, v, C, _, P) => {
    const z = Ky(P, _g);
    return Math.abs(C.bottom - _.bottom) < 1 || C.top > P.bottom ? pl.retry(z) : C.top === P.bottom ? pl.retry(Ky(P, 1)) : pC(m, v, P) ? pl.retry(dC(z, _g, 0)) : pl.none();
  }, gC = {
    point: fC,
    adjuster: (m, v, C, _, P) => {
      const z = Dd(P, _g);
      return Math.abs(C.top - _.top) < 1 || C.bottom < P.top ? pl.retry(z) : C.bottom === P.top ? pl.retry(Dd(P, 1)) : pC(m, v, P) ? pl.retry(dC(z, _g, 0)) : pl.none();
    },
    move: Dd,
    gather: Cg
  }, xE = {
    point: Wm,
    adjuster: hC,
    move: Ky,
    gather: jm
  }, wE = (m, v, C) => m.elementFromPoint(v, C).filter((_) => ks(_) === "table").isSome(), yu = (m, v, C, _, P) => Zm(m, v, C, v.move(_, _g), P), Zm = (m, v, C, _, P) => P === 0 ? Ce.some(_) : wE(m, _.left, v.point(_)) ? yu(m, v, C, _, P - 1) : m.situsFromPoint(_.left, v.point(_)).bind((z) => z.start.fold(Ce.none, (Q) => mC(m, Q).bind((le) => v.adjuster(m, Q, le, C, _).fold(Ce.none, (xe) => Zm(m, v, C, xe, P - 1))).orThunk(() => Ce.some(_)), Ce.none)), CE = (m, v, C) => m.point(v) > C.getInnerHeight() ? Ce.some(m.point(v) - C.getInnerHeight()) : m.point(v) < 0 ? Ce.some(-m.point(v)) : Ce.none(), Eg = (m, v, C) => {
    const _ = m.move(C, _g), P = Zm(v, m, C, _, Qv).getOr(_);
    return CE(m, P, v).fold(() => v.situsFromPoint(P.left, m.point(P)), (z) => (v.scrollBy(0, z), v.situsFromPoint(P.left, m.point(P) - z)));
  }, Ul = {
    tryUp: rt(Eg, gC),
    tryDown: rt(Eg, xE),
    getJumpSize: U(_g)
  }, eu = 20, jl = (m, v, C) => m.getSelection().bind((_) => qy(v, _.finish, _.foffset, C).fold(() => Ce.some(Yc(_.finish, _.foffset)), (P) => {
    const z = m.fromSitus(P), Q = Sg.verify(m, _.finish, _.foffset, z.finish, z.foffset, C.failure, v);
    return Bi(Q);
  })), xu = (m, v, C, _, P, z) => z === 0 ? Ce.none() : Tg(m, v, C, _, P).bind((Q) => {
    const le = m.fromSitus(Q), xe = Sg.verify(m, C, _, le.finish, le.foffset, P.failure, v);
    return Sg.cata(xe, () => Ce.none(), () => Ce.some(Q), (Fe) => Zt(C, Fe) && _ === 0 ? Qy(m, C, _, Dd, P) : xu(m, v, Fe, 0, P, z - 1), (Fe) => Zt(C, Fe) && _ === ml(Fe) ? Qy(m, C, _, Ky, P) : xu(m, v, Fe, ml(Fe), P, z - 1));
  }), Qy = (m, v, C, _, P) => Xy(m, v, C).bind((z) => wu(m, P, _(z, Ul.getJumpSize()))), wu = (m, v, C) => {
    const _ = Gh().browser;
    return _.isChromium() || _.isSafari() || _.isFirefox() ? v.retry(m, C) : Ce.none();
  }, Tg = (m, v, C, _, P) => Xy(m, C, _).bind((z) => wu(m, P, z)), dD = (m, v, C) => jl(m, v, C).bind((_) => xu(m, v, _.element, _.offset, C, eu).map(m.fromSitus)), SE = (m, v) => cD(m, (C) => Jo(C).exists((_) => Zt(_, v))), fD = (m, v, C, _, P) => Dr(_, "td,th", v).bind((z) => Dr(z, "table", v).bind((Q) => SE(P, Q) ? dD(m, v, C).bind((le) => Dr(le.finish, "td,th", v).map((xe) => ({
    start: z,
    finish: xe,
    range: le
  }))) : Ce.none())), kE = (m, v, C, _, P, z) => z(_, v).orThunk(() => fD(m, v, C, _, P).map((Q) => {
    const le = Q.range;
    return th.create(Ce.some(zy(le.start, le.soffset, le.finish, le.foffset)), !0);
  })), _E = (m, v) => Dr(m, "tr", v).bind((C) => Dr(C, "table", v).bind((_) => {
    const P = Or(_, "tr");
    return Zt(C, P[0]) ? C1(_, (z) => xv(z).isSome(), v).map((z) => {
      const Q = ml(z);
      return th.create(Ce.some(zy(z, Q, z, Q)), !0);
    }) : Ce.none();
  })), vC = (m, v) => Dr(m, "tr", v).bind((C) => Dr(C, "table", v).bind((_) => {
    const P = Or(_, "tr");
    return Zt(C, P[P.length - 1]) ? Kv(_, (z) => Zc(z).isSome(), v).map((z) => th.create(Ce.some(zy(z, 0, z, 0)), !0)) : Ce.none();
  })), bC = (m, v, C, _, P, z, Q) => fD(m, C, _, P, z).bind((le) => oh(v, C, le.start, le.finish, Q)), tl = (m) => {
    let v = m;
    return {
      get: () => v,
      set: (P) => {
        v = P;
      }
    };
  }, yC = (m) => {
    const v = tl(Ce.none()), C = () => v.get().each(m);
    return {
      clear: () => {
        C(), v.set(Ce.none());
      },
      isSet: () => v.get().isSome(),
      get: () => v.get(),
      set: (le) => {
        C(), v.set(Ce.some(le));
      }
    };
  }, rh = () => {
    const m = yC(ye);
    return {
      ...m,
      on: (C) => m.get().each(C)
    };
  }, Jv = (m, v) => Dr(m, "td,th", v), xC = (m) => Gs(m).exists(Xb), Jy = (m, v, C, _) => {
    const P = rh(), z = P.clear, Q = (at) => {
      P.on((Yt) => {
        _.clearBeforeUpdate(v), Jv(at.target, C).each((_n) => {
          Ev(Yt, _n, C).each((vn) => {
            const ln = vn.boxes.getOr([]);
            if (ln.length === 1) {
              const Wn = ln[0], Wt = ew(Wn) === "false", un = Cc(Yb(at.target), Wn, Zt);
              Wt && un && _.selectRange(v, ln, Wn, Wn);
            } else ln.length > 1 && (_.selectRange(v, ln, vn.start, vn.finish), m.selectContents(_n));
          });
        });
      });
    };
    return {
      clearstate: z,
      mousedown: (at) => {
        _.clear(v), Jv(at.target, C).filter(xC).each(P.set);
      },
      mouseover: (at) => {
        Q(at);
      },
      mouseup: (at) => {
        Q(at), z();
      }
    };
  }, S1 = {
    traverse: Ai,
    gather: jm,
    relative: dc.before,
    retry: Ul.tryDown,
    failure: Sg.failedDown
  }, wC = {
    traverse: Ti,
    gather: Cg,
    relative: dc.before,
    retry: Ul.tryUp,
    failure: Sg.failedUp
  }, eb = (m) => (v) => v === m, CC = eb(38), em = eb(40), Ag = (m) => m >= 37 && m <= 40, EE = {
    isBackward: eb(37),
    isForward: eb(39)
  }, Gm = {
    isBackward: eb(39),
    isForward: eb(37)
  }, Cu = (m) => {
    const v = m !== void 0 ? m.dom : document, C = v.body.scrollLeft || v.documentElement.scrollLeft, _ = v.body.scrollTop || v.documentElement.scrollTop;
    return $t(C, _);
  }, TE = (m, v, C) => {
    const P = (C !== void 0 ? C.dom : document).defaultView;
    P && P.scrollBy(m, v);
  }, tm = Qf.generate([
    { domRange: ["rng"] },
    {
      relative: [
        "startSitu",
        "finishSitu"
      ]
    },
    {
      exact: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]), Og = (m) => tm.exact(m.start, m.soffset, m.finish, m.foffset), SC = (m) => m.match({
    domRange: (v) => $e.fromDom(v.startContainer),
    relative: (v, C) => dc.getStart(v),
    exact: (v, C, _, P) => v
  }), ex = tm.domRange, AE = tm.relative, mD = tm.exact, pD = (m) => {
    const v = SC(m);
    return co(v);
  }, OE = wg.create, ah = {
    domRange: ex,
    relative: AE,
    exact: mD,
    exactFromRange: Og,
    getWin: pD,
    range: OE
  }, tb = (m, v, C) => {
    var _, P;
    return Ce.from((P = (_ = m.dom).caretPositionFromPoint) === null || P === void 0 ? void 0 : P.call(_, v, C)).bind((z) => {
      if (z.offsetNode === null)
        return Ce.none();
      const Q = m.dom.createRange();
      return Q.setStart(z.offsetNode, z.offset), Q.collapse(), Ce.some(Q);
    });
  }, k1 = (m, v, C) => {
    var _, P;
    return Ce.from((P = (_ = m.dom).caretRangeFromPoint) === null || P === void 0 ? void 0 : P.call(_, v, C));
  }, hD = document.caretPositionFromPoint ? tb : document.caretRangeFromPoint ? k1 : Ce.none, gD = (m, v, C) => {
    const _ = $e.fromDom(m.document);
    return hD(_, v, C).map((P) => wg.create($e.fromDom(P.startContainer), P.startOffset, $e.fromDom(P.endContainer), P.endOffset));
  }, nb = (m, v) => {
    const C = ks(m);
    return C === "input" ? dc.after(m) : fn([
      "br",
      "img"
    ], C) ? v === 0 ? dc.before(m) : dc.after(m) : dc.on(m, v);
  }, kC = (m, v) => {
    const C = m.fold(dc.before, nb, dc.after), _ = v.fold(dc.before, nb, dc.after);
    return ah.relative(C, _);
  }, tx = (m, v, C, _) => {
    const P = nb(m, v), z = nb(C, _);
    return ah.relative(P, z);
  }, _C = (m, v, C, _) => {
    const z = Zn(m).dom.createRange();
    return z.setStart(m.dom, v), z.setEnd(C.dom, _), z;
  }, EC = (m, v, C, _) => {
    const P = _C(m, v, C, _), z = Zt(m, C) && v === _;
    return P.collapsed && !z;
  }, ob = (m) => Ce.from(m.getSelection()), TC = (m, v) => {
    ob(m).each((C) => {
      C.removeAllRanges(), C.addRange(v);
    });
  }, sb = (m, v, C, _, P) => {
    const z = Ly(m, v, C, _, P);
    TC(m, z);
  }, AC = (m, v, C, _, P, z) => {
    v.collapse(C.dom, _), v.extend(P.dom, z);
  }, Ns = (m, v) => rC(m, v).match({
    ltr: (C, _, P, z) => {
      sb(m, C, _, P, z);
    },
    rtl: (C, _, P, z) => {
      ob(m).each((Q) => {
        if (Q.setBaseAndExtent)
          Q.setBaseAndExtent(C.dom, _, P.dom, z);
        else if (Q.extend)
          try {
            AC(m, Q, C, _, P, z);
          } catch {
            sb(m, P, z, C, _);
          }
        else
          sb(m, P, z, C, _);
      });
    }
  }), nm = (m, v, C, _, P) => {
    const z = tx(v, C, _, P);
    Ns(m, z);
  }, Dg = (m, v, C) => {
    const _ = kC(v, C);
    Ns(m, _);
  }, _1 = (m) => {
    if (m.rangeCount > 0) {
      const v = m.getRangeAt(0), C = m.getRangeAt(m.rangeCount - 1);
      return Ce.some(wg.create($e.fromDom(v.startContainer), v.startOffset, $e.fromDom(C.endContainer), C.endOffset));
    } else
      return Ce.none();
  }, OC = (m) => {
    if (m.anchorNode === null || m.focusNode === null)
      return _1(m);
    {
      const v = $e.fromDom(m.anchorNode), C = $e.fromDom(m.focusNode);
      return EC(v, m.anchorOffset, C, m.focusOffset) ? Ce.some(wg.create(v, m.anchorOffset, C, m.focusOffset)) : _1(m);
    }
  }, qm = (m, v, C = !0) => {
    const P = (C ? nh : JO)(m, v);
    TC(m, P);
  }, DC = (m) => ob(m).filter((v) => v.rangeCount > 0).bind(OC), nx = (m) => DC(m).map((v) => ah.exact(v.start, v.soffset, v.finish, v.foffset)), RC = (m, v) => {
    const C = Hy(m, v);
    return nD(C);
  }, NC = (m, v, C) => gD(m, v, C), Rg = (m) => {
    ob(m).each((v) => v.removeAllRanges());
  }, ox = (m) => ({
    elementFromPoint: (Wt, un) => $e.fromPoint($e.fromDom(m.document), Wt, un),
    getRect: (Wt) => Wt.dom.getBoundingClientRect(),
    getRangedRect: (Wt, un, wo, yn) => {
      const Ks = ah.exact(Wt, un, wo, yn);
      return RC(m, Ks);
    },
    getSelection: () => nx(m).map((Wt) => dE(m, Wt)),
    fromSitus: (Wt) => {
      const un = ah.relative(Wt.start, Wt.finish);
      return dE(m, un);
    },
    situsFromPoint: (Wt, un) => NC(m, Wt, un).map((wo) => aC.create(wo.start, wo.soffset, wo.finish, wo.foffset)),
    clearSelection: () => {
      Rg(m);
    },
    collapseSelection: (Wt = !1) => {
      nx(m).each((un) => un.fold((wo) => wo.collapse(Wt), (wo, yn) => {
        const Ks = Wt ? wo : yn;
        Dg(m, Ks, Ks);
      }, (wo, yn, Ks, yr) => {
        const ur = Wt ? wo : Ks, nl = Wt ? yn : yr;
        nm(m, ur, nl, ur, nl);
      }));
    },
    setSelection: (Wt) => {
      nm(m, Wt.start, Wt.soffset, Wt.finish, Wt.foffset);
    },
    setRelativeSelection: (Wt, un) => {
      Dg(m, Wt, un);
    },
    selectNode: (Wt) => {
      qm(m, Wt, !1);
    },
    selectContents: (Wt) => {
      qm(m, Wt);
    },
    getInnerHeight: () => m.innerHeight,
    getScrollY: () => Cu($e.fromDom(m.document)).top,
    scrollBy: (Wt, un) => {
      TE(Wt, un, $e.fromDom(m.document));
    }
  }), Ng = (m, v) => ({
    rows: m,
    cols: v
  }), sx = (m, v, C, _) => {
    const P = ox(m), z = Jy(P, v, C, _);
    return {
      clearstate: z.clearstate,
      mousedown: z.mousedown,
      mouseover: z.mouseover,
      mouseup: z.mouseup
    };
  }, DE = (m) => yi(m, Xn).exists(Xb), rb = (m, v) => DE(m) || DE(v), rx = (m, v, C, _) => {
    const P = ox(m), z = () => (_.clear(v), Ce.none());
    return {
      keydown: (xe, Fe, at, Yt, _n, vn) => {
        const ln = xe.raw, Wn = ln.which, Wt = ln.shiftKey === !0;
        return e1(v, _.selectedSelector).fold(() => (Ag(Wn) && !Wt && _.clearBeforeUpdate(v), Ag(Wn) && Wt && !rb(Fe, Yt) ? Ce.none : em(Wn) && Wt ? rt(bC, P, v, C, S1, Yt, Fe, _.selectRange) : CC(Wn) && Wt ? rt(bC, P, v, C, wC, Yt, Fe, _.selectRange) : em(Wn) ? rt(kE, P, C, S1, Yt, Fe, vC) : CC(Wn) ? rt(kE, P, C, wC, Yt, Fe, _E) : Ce.none), (wo) => {
          const yn = (Ks) => () => qn(Ks, (ur) => qI(ur.rows, ur.cols, v, wo, _)).fold(() => c_(v, _.firstSelectedSelector, _.lastSelectedSelector).map((ur) => {
            const nl = em(Wn) || vn.isForward(Wn) ? dc.after : dc.before;
            return P.setRelativeSelection(dc.on(ur.first, 0), nl(ur.table)), _.clear(v), th.create(Ce.none(), !0);
          }), (ur) => Ce.some(th.create(Ce.none(), !0)));
          return Ag(Wn) && Wt && !rb(Fe, Yt) ? Ce.none : em(Wn) && Wt ? yn([Ng(1, 0)]) : CC(Wn) && Wt ? yn([Ng(-1, 0)]) : vn.isBackward(Wn) && Wt ? yn([
            Ng(0, -1),
            Ng(-1, 0)
          ]) : vn.isForward(Wn) && Wt ? yn([
            Ng(0, 1),
            Ng(1, 0)
          ]) : Ag(Wn) && !Wt ? z : Ce.none;
        })();
      },
      keyup: (xe, Fe, at, Yt, _n) => e1(v, _.selectedSelector).fold(() => {
        const vn = xe.raw, ln = vn.which;
        return vn.shiftKey === !0 && Ag(ln) && rb(Fe, Yt) ? rD(v, C, Fe, at, Yt, _n, _.selectRange) : Ce.none();
      }, Ce.none)
    };
  }, vD = (m, v, C, _) => {
    const P = ox(m);
    return (z, Q) => {
      _.clearBeforeUpdate(v), Ev(z, Q, C).each((le) => {
        const xe = le.boxes.getOr([]);
        _.selectRange(v, xe, le.start, le.finish), P.selectContents(Q), P.collapseSelection();
      });
    };
  }, ax = (m, v) => {
    const C = Tr(m, v);
    return C === void 0 || C === "" ? [] : C.split(" ");
  }, Km = (m, v, C) => {
    const P = ax(m, v).concat([C]);
    return as(m, v, P.join(" ")), !0;
  }, bD = (m, v, C) => {
    const _ = Rt(ax(m, v), (P) => P !== C);
    return _.length > 0 ? as(m, v, _.join(" ")) : Ae(m, v), !1;
  }, E1 = (m) => m.dom.classList !== void 0, Ku = (m) => ax(m, "class"), Li = (m, v) => Km(m, "class", v), yD = (m, v) => bD(m, "class", v), vf = (m, v) => {
    E1(m) ? m.dom.classList.add(v) : Li(m, v);
  }, xD = (m) => {
    (E1(m) ? m.dom.classList : Ku(m)).length === 0 && Ae(m, "class");
  }, RE = (m, v) => {
    E1(m) ? m.dom.classList.remove(v) : yD(m, v), xD(m);
  }, T1 = (m, v) => E1(m) && m.dom.classList.contains(v), ab = (m, v) => {
    Je(v, (C) => {
      RE(m, C);
    });
  }, NE = (m) => (v) => {
    vf(v, m);
  }, PE = (m) => (v) => {
    ab(v, m);
  }, ME = {
    byClass: (m) => {
      const v = NE(m.selected), C = PE([
        m.selected,
        m.lastSelected,
        m.firstSelected
      ]), _ = (z) => {
        const Q = Or(z, m.selectedSelector);
        Je(Q, C);
      };
      return {
        clearBeforeUpdate: _,
        clear: _,
        selectRange: (z, Q, le, xe) => {
          _(z), Je(Q, v), vf(le, m.firstSelected), vf(xe, m.lastSelected);
        },
        selectedSelector: m.selectedSelector,
        firstSelectedSelector: m.firstSelectedSelector,
        lastSelectedSelector: m.lastSelectedSelector
      };
    },
    byAttr: (m, v, C) => {
      const _ = (xe) => {
        Ae(xe, m.selected), Ae(xe, m.firstSelected), Ae(xe, m.lastSelected);
      }, P = (xe) => {
        as(xe, m.selected, "1");
      }, z = (xe) => {
        Q(xe), C();
      }, Q = (xe) => {
        const Fe = Or(xe, `${m.selectedSelector},${m.firstSelectedSelector},${m.lastSelectedSelector}`);
        Je(Fe, _);
      };
      return {
        clearBeforeUpdate: Q,
        clear: z,
        selectRange: (xe, Fe, at, Yt) => {
          z(xe), Je(Fe, P), as(at, m.firstSelected, "1"), as(Yt, m.lastSelected, "1"), v(Fe, at, Yt);
        },
        selectedSelector: m.selectedSelector,
        firstSelectedSelector: m.firstSelectedSelector,
        lastSelectedSelector: m.lastSelectedSelector
      };
    }
  }, IE = (m, v, C, _) => {
    switch (m.tag) {
      case "none":
        return v();
      case "single":
        return _(m.element);
      case "multiple":
        return C(m.elements);
    }
  }, In = () => ({ tag: "none" }), $i = (m) => ({
    tag: "multiple",
    elements: m
  }), A1 = (m) => ({
    tag: "single",
    element: m
  }), Hi = (m, v, C) => ({ get: () => Vp(m(), C).fold(() => v().fold(In, A1), $i) }), Yu = (m, v) => {
    const C = m.slice(0, v[v.length - 1].row + 1), _ = dy(C);
    return At(_, (P) => {
      const z = P.cells.slice(0, v[v.length - 1].column + 1);
      return Tt(z, (Q) => Q.element);
    });
  }, PC = (m, v) => {
    const C = m.slice(v[0].row + v[0].rowspan - 1, m.length), _ = dy(C);
    return At(_, (P) => {
      const z = P.cells.slice(v[0].column + v[0].colspan - 1, P.cells.length);
      return Tt(z, (Q) => Q.element);
    });
  }, Pg = (m, v, C) => {
    const _ = ls.fromTable(m);
    return df(_, v).map((z) => {
      const Q = Pv(_, C, !1), { rows: le } = Pa(Q), xe = Yu(le, z), Fe = PC(le, z);
      return {
        upOrLeftCells: xe,
        downOrRightCells: Fe
      };
    });
  }, ix = (m, v, C, _, P, z, Q) => ({
    target: m,
    x: v,
    y: C,
    stop: _,
    prevent: P,
    kill: z,
    raw: Q
  }), ih = (m) => {
    const v = $e.fromDom(sn(m).getOr(m.target)), C = () => m.stopPropagation(), _ = () => m.preventDefault(), P = re(_, C);
    return ix(v, m.clientX, m.clientY, C, _, P, m);
  }, O1 = (m, v) => (C) => {
    m(C) && v(ih(C));
  }, FE = (m, v, C, _, P) => {
    const z = O1(C, _);
    return m.dom.addEventListener(v, z, P), { unbind: rt(CD, m, v, z, P) };
  }, wD = (m, v, C, _) => FE(m, v, C, _, !1), CD = (m, v, C, _) => {
    m.dom.removeEventListener(v, C, _);
  }, SD = Ue, lh = (m, v, C) => wD(m, v, SD, C), D1 = ih, R1 = (m) => !T1($e.fromDom(m.target), "ephox-snooker-resizer-bar"), lx = (m, v) => {
    const C = Hi(() => $e.fromDom(m.getBody()), () => dw(Zu(m), af(m)), Lm.selectedSelector), _ = (xe, Fe, at) => {
      Zi(Fe).each((_n) => {
        const vn = Tt(xe, (wo) => wo.dom), ln = n_(m), Wn = _d(ye, $e.fromDom(m.getDoc()), ln), Wt = Vr(m), un = Pg(_n, { selection: Wt }, Wn).map((wo) => oo(wo, (yn) => Tt(yn, (Ks) => Ks.dom))).getOrUndefined();
        zO(m, vn, Fe.dom, at.dom, un);
      });
    }, P = () => VO(m), z = ME.byAttr(Lm, _, P);
    return m.on("init", (xe) => {
      const Fe = m.getWin(), at = ng(m), Yt = af(m), _n = () => {
        const sr = m.selection, mc = $e.fromDom(sr.getStart()), pc = $e.fromDom(sr.getEnd());
        Td(Zi, [
          mc,
          pc
        ]).fold(() => z.clear(at), ye);
      }, vn = sx(Fe, at, Yt, z), ln = rx(Fe, at, Yt, z), Wn = vD(Fe, at, Yt, z), Wt = (sr) => sr.raw.shiftKey === !0;
      m.on("TableSelectorChange", (sr) => Wn(sr.start, sr.finish));
      const un = (sr, mc) => {
        Wt(sr) && (mc.kill && sr.kill(), mc.selection.each((pc) => {
          const Qu = ah.relative(pc.start, pc.finish), Ju = Hy(Fe, Qu);
          m.selection.setRng(Ju);
        }));
      }, wo = (sr) => {
        const mc = D1(sr);
        if (mc.raw.shiftKey && Ag(mc.raw.which)) {
          const pc = m.selection.getRng(), Qu = $e.fromDom(pc.startContainer), Ju = $e.fromDom(pc.endContainer);
          ln.keyup(mc, Qu, pc.startOffset, Ju, pc.endOffset).each((bs) => {
            un(mc, bs);
          });
        }
      }, yn = (sr) => {
        const mc = D1(sr);
        v.hide();
        const pc = m.selection.getRng(), Qu = $e.fromDom(pc.startContainer), Ju = $e.fromDom(pc.endContainer), bs = Dp(EE, Gm)($e.fromDom(m.selection.getStart()));
        ln.keydown(mc, Qu, pc.startOffset, Ju, pc.endOffset, bs).each((Oa) => {
          un(mc, Oa);
        }), v.show();
      }, Ks = (sr) => sr.button === 0, yr = (sr) => sr.buttons === void 0 ? !0 : (sr.buttons & 1) !== 0, ur = (sr) => {
        vn.clearstate();
      }, nl = (sr) => {
        Ks(sr) && R1(sr) && vn.mousedown(D1(sr));
      }, ni = (sr) => {
        yr(sr) && R1(sr) && vn.mouseover(D1(sr));
      }, sm = (sr) => {
        Ks(sr) && R1(sr) && vn.mouseup(D1(sr));
      }, mh = (() => {
        const sr = tl($e.fromDom(at)), mc = tl(0);
        return { touchEnd: (Qu) => {
          const Ju = $e.fromDom(Qu.target);
          if (En("td")(Ju) || En("th")(Ju)) {
            const bs = sr.get(), Oa = mc.get();
            Zt(bs, Ju) && Qu.timeStamp - Oa < 300 && (Qu.preventDefault(), Wn(Ju, Ju));
          }
          sr.set(Ju), mc.set(Qu.timeStamp);
        } };
      })();
      m.on("dragstart", ur), m.on("mousedown", nl), m.on("mouseover", ni), m.on("mouseup", sm), m.on("touchend", mh.touchEnd), m.on("keyup", wo), m.on("keydown", yn), m.on("NodeChange", _n);
    }), m.on("PreInit", () => {
      m.serializer.addTempAttr(Lm.firstSelected), m.serializer.addTempAttr(Lm.lastSelected);
    }), {
      getSelectedCells: () => IE(C.get(), U([]), (xe) => Tt(xe, (Fe) => Fe.dom), (xe) => [xe.dom]),
      clearSelectedCells: (xe) => z.clear($e.fromDom(xe))
    };
  }, tu = (m) => {
    let v = [];
    return {
      bind: (z) => {
        if (z === void 0)
          throw new Error("Event bind error: undefined handler");
        v.push(z);
      },
      unbind: (z) => {
        v = Rt(v, (Q) => Q !== z);
      },
      trigger: (...z) => {
        const Q = {};
        Je(m, (le, xe) => {
          Q[le] = z[xe];
        }), Je(v, (le) => {
          le(Q);
        });
      }
    };
  }, om = (m) => {
    const v = oo(m, (_) => ({
      bind: _.bind,
      unbind: _.unbind
    })), C = oo(m, (_) => _.trigger);
    return {
      registry: v,
      trigger: C
    };
  }, ch = (m, v) => {
    let C = null;
    const _ = () => {
      H(C) || (clearTimeout(C), C = null);
    };
    return {
      cancel: _,
      throttle: (...z) => {
        _(), C = setTimeout(() => {
          C = null, m.apply(null, z);
        }, v);
      }
    };
  }, uh = (m) => m.slice(0).sort(), kD = (m, v) => {
    throw new Error("All required keys (" + uh(m).join(", ") + ") were not specified. Specified keys were: " + uh(v).join(", ") + ".");
  }, cx = (m) => {
    throw new Error("Unsupported keys for object: " + uh(m).join(", "));
  }, ux = (m, v) => {
    if (!N(v))
      throw new Error("The " + m + " fields must be an array. Was: " + v + ".");
    Je(v, (C) => {
      if (!k(C))
        throw new Error("The value " + C + " in the " + m + " fields was not a string.");
    });
  }, _D = (m, v) => {
    throw new Error("All values need to be of type: " + v + ". Keys (" + uh(m).join(", ") + ") were not.");
  }, ED = (m) => {
    const v = uh(m);
    X(v, (_, P) => P < v.length - 1 && _ === v[P + 1]).each((_) => {
      throw new Error("The field: " + _ + " occurs more than once in the combined fields: [" + v.join(", ") + "].");
    });
  }, TD = (m, v) => AD(m, v, {
    validate: Se,
    label: "function"
  }), AD = (m, v, C) => {
    if (v.length === 0)
      throw new Error("You must specify at least one required field.");
    return ux("required", v), ED(v), (_) => {
      const P = on(_);
      Pt(v, (le) => fn(P, le)) || kD(v, P), m(v, P);
      const Q = Rt(v, (le) => !C.validate(_[le], le));
      return Q.length > 0 && _D(Q, C.label), _;
    };
  }, BE = (m, v) => {
    const C = Rt(v, (_) => !fn(m, _));
    C.length > 0 && cx(C);
  }, dx = (m) => TD(BE, m), OD = dx([
    "compare",
    "extract",
    "mutate",
    "sink"
  ]), fx = dx([
    "element",
    "start",
    "stop",
    "destroy"
  ]), hl = dx([
    "forceDrop",
    "drop",
    "move",
    "delayDrop"
  ]), Xu = () => {
    let m = Ce.none();
    const v = () => {
      m = Ce.none();
    }, C = (z, Q) => {
      const le = m.map((xe) => z.compare(xe, Q));
      return m = Ce.some(Q), le;
    }, _ = (z, Q) => {
      Q.extract(z).each((xe) => {
        C(Q, xe).each((at) => {
          P.trigger.move(at);
        });
      });
    }, P = om({ move: tu(["info"]) });
    return {
      onEvent: _,
      reset: v,
      events: P.registry
    };
  }, Su = () => {
    const m = om({ move: tu(["info"]) });
    return {
      onEvent: ye,
      reset: ye,
      events: m.registry
    };
  }, mx = () => {
    const m = Su(), v = Xu();
    let C = m;
    return {
      on: () => {
        C.reset(), C = v;
      },
      off: () => {
        C.reset(), C = m;
      },
      isOn: () => C === v,
      onEvent: (le, xe) => {
        C.onEvent(le, xe);
      },
      events: v.events
    };
  }, px = (m, v, C) => {
    let _ = !1;
    const P = om({
      start: tu([]),
      stop: tu([])
    }), z = mx(), Q = () => {
      ln.stop(), z.isOn() && (z.off(), P.trigger.stop());
    }, le = ch(Q, 200), xe = (Wt) => {
      ln.start(Wt), z.on(), P.trigger.start();
    }, Fe = (Wt) => {
      le.cancel(), z.onEvent(Wt, v);
    };
    z.events.move.bind((Wt) => {
      v.mutate(m, Wt.info);
    });
    const at = () => {
      _ = !0;
    }, Yt = () => {
      _ = !1;
    }, _n = () => _, vn = (Wt) => (...un) => {
      _ && Wt.apply(null, un);
    }, ln = v.sink(hl({
      forceDrop: Q,
      drop: vn(Q),
      move: vn(Fe),
      delayDrop: vn(le.throttle)
    }), C), Wn = () => {
      ln.destroy();
    };
    return {
      element: ln.element,
      go: xe,
      on: at,
      off: Yt,
      isActive: _n,
      destroy: Wn,
      events: P.registry
    };
  }, LE = (m) => {
    const v = m.replace(/\./g, "-");
    return { resolve: (_) => v + "-" + _ };
  }, $E = LE("ephox-dragster").resolve, IC = (m) => {
    const v = {
      layerClass: $E("blocker"),
      ...m
    }, C = $e.fromTag("div");
    return as(C, "role", "presentation"), eo(C, {
      position: "fixed",
      left: "0px",
      top: "0px",
      width: "100%",
      height: "100%"
    }), vf(C, $E("blocker")), vf(C, v.layerClass), {
      element: U(C),
      destroy: () => {
        Qr(C);
      }
    };
  };
  var hx = OD({
    compare: (m, v) => $t(v.left - m.left, v.top - m.top),
    extract: (m) => Ce.some($t(m.x, m.y)),
    sink: (m, v) => {
      const C = IC(v), _ = lh(C.element(), "mousedown", m.forceDrop), P = lh(C.element(), "mouseup", m.drop), z = lh(C.element(), "mousemove", m.move), Q = lh(C.element(), "mouseout", m.delayDrop), le = () => {
        C.destroy(), P.unbind(), z.unbind(), Q.unbind(), _.unbind();
      }, xe = (at) => {
        Qs(at, C.element());
      }, Fe = () => {
        Qr(C.element());
      };
      return fx({
        element: C.element,
        start: xe,
        stop: Fe,
        destroy: le
      });
    },
    mutate: (m, v) => {
      m.mutate(v.left, v.top);
    }
  });
  const FC = (m, v = {}) => {
    var C;
    const _ = (C = v.mode) !== null && C !== void 0 ? C : hx;
    return px(m, _, v);
  }, fc = LE("ephox-snooker").resolve, VE = () => {
    const m = om({
      drag: tu([
        "xDelta",
        "yDelta"
      ])
    });
    return {
      mutate: (C, _) => {
        m.trigger.drag(C, _);
      },
      events: m.registry
    };
  }, BC = () => {
    const m = om({
      drag: tu([
        "xDelta",
        "yDelta",
        "target"
      ])
    });
    let v = Ce.none();
    const C = VE();
    return C.events.drag.bind((z) => {
      v.each((Q) => {
        m.trigger.drag(z.xDelta, z.yDelta, Q);
      });
    }), {
      assign: (z) => {
        v = Ce.some(z);
      },
      get: () => v,
      mutate: C.mutate,
      events: m.registry
    };
  }, N1 = (m, v, C, _, P) => {
    const z = $e.fromTag("div");
    return eo(z, {
      position: "absolute",
      left: v - _ / 2 + "px",
      top: C + "px",
      height: P + "px",
      width: _ + "px"
    }), Yr(z, {
      "data-column": m,
      role: "presentation"
    }), z;
  }, P1 = (m, v, C, _, P) => {
    const z = $e.fromTag("div");
    return eo(z, {
      position: "absolute",
      left: v + "px",
      top: C - P / 2 + "px",
      height: P + "px",
      width: _ + "px"
    }), Yr(z, {
      "data-row": m,
      role: "presentation"
    }), z;
  }, gx = fc("resizer-bar"), M1 = fc("resizer-rows"), UE = fc("resizer-cols"), jE = 7, LC = (m, v) => At(m.all, (C, _) => v(C.element) ? [_] : []), $C = (m, v) => {
    const C = [];
    return jt(m.grid.columns, (_) => {
      ls.getColumnAt(m, _).map((z) => z.element).forall(v) && C.push(_);
    }), Rt(C, (_) => {
      const P = ls.filterItems(m, (z) => z.column === _);
      return Pt(P, (z) => v(z.element));
    });
  }, Ym = (m) => {
    const v = Or(m.parent(), "." + gx);
    Je(v, Qr);
  }, HC = (m, v, C) => {
    const _ = m.origin();
    Je(v, (P) => {
      P.each((z) => {
        const Q = C(_, z);
        vf(Q, gx), Qs(m.parent(), Q);
      });
    });
  }, WE = (m, v, C, _) => {
    HC(m, v, (P, z) => {
      const Q = N1(z.col, z.x - P.left, C.top - P.top, jE, _);
      return vf(Q, UE), Q;
    });
  }, ND = (m, v, C, _) => {
    HC(m, v, (P, z) => {
      const Q = P1(z.row, C.left - P.left, z.y - P.top, _, jE);
      return vf(Q, M1), Q;
    });
  }, PD = (m, v, C, _, P) => {
    const z = Mo(C), Q = v.isResizable, le = _.length > 0 ? Mi.positions(_, C) : [], xe = le.length > 0 ? LC(m, Q) : [], Fe = Rt(le, (vn, ln) => ze(xe, (Wn) => ln === Wn));
    ND(v, Fe, z, cr(C));
    const at = P.length > 0 ? Np.positions(P, C) : [], Yt = at.length > 0 ? $C(m, Q) : [], _n = Rt(at, (vn, ln) => ze(Yt, (Wn) => ln === Wn));
    WE(v, _n, z, se(C));
  }, ZE = (m, v) => {
    if (Ym(m), m.isResizable(v)) {
      const C = ls.fromTable(v), _ = Op(C), P = ef(C);
      PD(C, m, v, _, P);
    }
  }, Nc = (m, v) => {
    const C = Or(m.parent(), "." + gx);
    Je(C, v);
  }, Wl = (m) => {
    Nc(m, (v) => {
      ft(v, "display", "none");
    });
  }, ib = (m) => {
    Nc(m, (v) => {
      ft(v, "display", "block");
    });
  }, QI = (m) => T1(m, M1), MD = (m) => T1(m, UE), zC = fc("resizer-bar-dragging"), Ds = (m) => {
    const v = BC(), C = FC(v, {});
    let _ = Ce.none();
    const P = (ln, Wn) => Ce.from(Tr(ln, Wn));
    v.events.drag.bind((ln) => {
      P(ln.target, "data-row").each((Wn) => {
        const Wt = ul(ln.target, "top");
        ft(ln.target, "top", Wt + ln.yDelta + "px");
      }), P(ln.target, "data-column").each((Wn) => {
        const Wt = ul(ln.target, "left");
        ft(ln.target, "left", Wt + ln.xDelta + "px");
      });
    });
    const z = (ln, Wn) => {
      const Wt = ul(ln, Wn), un = Rr(ln, "data-initial-" + Wn, 0);
      return Wt - un;
    };
    C.events.stop.bind(() => {
      v.get().each((ln) => {
        _.each((Wn) => {
          P(ln, "data-row").each((Wt) => {
            const un = z(ln, "top");
            Ae(ln, "data-initial-top"), vn.trigger.adjustHeight(Wn, un, parseInt(Wt, 10));
          }), P(ln, "data-column").each((Wt) => {
            const un = z(ln, "left");
            Ae(ln, "data-initial-left"), vn.trigger.adjustWidth(Wn, un, parseInt(Wt, 10));
          }), ZE(m, Wn);
        });
      });
    });
    const Q = (ln, Wn) => {
      vn.trigger.startAdjust(), v.assign(ln), as(ln, "data-initial-" + Wn, ul(ln, Wn)), vf(ln, zC), ft(ln, "opacity", "0.2"), C.go(m.parent());
    }, le = lh(m.parent(), "mousedown", (ln) => {
      QI(ln.target) && Q(ln.target, "top"), MD(ln.target) && Q(ln.target, "left");
    }), xe = (ln) => Zt(ln, m.view()), Fe = (ln) => Dr(ln, "table", xe).filter(Xb), at = lh(m.view(), "mouseover", (ln) => {
      Fe(ln.target).fold(() => {
        tr(ln.target) && Ym(m);
      }, (Wn) => {
        C.isActive() && (_ = Ce.some(Wn), ZE(m, Wn));
      });
    }), Yt = () => {
      le.unbind(), at.unbind(), C.destroy(), Ym(m);
    }, _n = (ln) => {
      ZE(m, ln);
    }, vn = om({
      adjustHeight: tu([
        "table",
        "delta",
        "row"
      ]),
      adjustWidth: tu([
        "table",
        "delta",
        "column"
      ]),
      startAdjust: tu([])
    });
    return {
      destroy: Yt,
      refresh: _n,
      on: C.on,
      off: C.off,
      hideBars: rt(Wl, m),
      showBars: rt(ib, m),
      events: vn.registry
    };
  }, GE = { create: (m, v, C) => {
    const _ = Mi, P = Np, z = Ds(m), Q = om({
      beforeResize: tu([
        "table",
        "type"
      ]),
      afterResize: tu([
        "table",
        "type"
      ]),
      startDrag: tu([])
    });
    return z.events.adjustHeight.bind((le) => {
      const xe = le.table;
      Q.trigger.beforeResize(xe, "row");
      const Fe = _.delta(le.delta, xe);
      _w(xe, Fe, le.row), Q.trigger.afterResize(xe, "row");
    }), z.events.startAdjust.bind((le) => {
      Q.trigger.startDrag();
    }), z.events.adjustWidth.bind((le) => {
      const xe = le.table;
      Q.trigger.beforeResize(xe, "col");
      const Fe = P.delta(le.delta, xe), at = C(xe);
      E_(xe, Fe, le.column, v, at), Q.trigger.afterResize(xe, "col");
    }), {
      on: z.on,
      off: z.off,
      refreshBars: z.refresh,
      hideBars: z.hideBars,
      showBars: z.showBars,
      destroy: z.destroy,
      events: Q.registry
    };
  } }, I1 = {
    only: (m, v) => {
      const C = ht(m) ? Qn(m) : m;
      return {
        parent: U(C),
        view: U(m),
        origin: U($t(0, 0)),
        isResizable: v
      };
    },
    detached: (m, v, C) => {
      const _ = () => Mo(v);
      return {
        parent: U(v),
        view: U(m),
        origin: _,
        isResizable: C
      };
    },
    body: (m, v, C) => ({
      parent: U(v),
      view: U(m),
      origin: U($t(0, 0)),
      isResizable: C
    })
  }, ID = () => {
    const m = $e.fromTag("div");
    return eo(m, {
      position: "static",
      height: "0",
      width: "0",
      padding: "0",
      margin: "0",
      border: "0"
    }), Qs(Y(), m), m;
  }, FD = (m, v) => m.inline ? I1.body($e.fromDom(m.getBody()), ID(), v) : I1.only($e.fromDom(m.getDoc()), v), BD = (m, v) => {
    m.inline && Qr(v.parent());
  }, vx = (m) => pe(m) && m.nodeName === "TABLE", F1 = "bar-", KE = (m) => Tr(m, "data-mce-resize") !== "false", tF = (m) => {
    const v = ls.fromTable(m);
    ls.hasColumns(v) || Je(hd(m), (C) => {
      const _ = es(C, "width");
      ft(C, "width", _), Ae(C, "width");
    });
  }, lb = (m) => Ga(m, "corner-"), VC = (m) => Ql(m, "corner-"), nF = (m) => {
    const v = rh(), C = rh(), _ = rh();
    let P, z, Q, le;
    const xe = (un) => ti(m, un), Fe = () => Ta(m) ? jp() : ig(), at = (un) => Yf(un).columns, Yt = (un) => Yf(un).rows, _n = (un, wo, yn, Ks) => {
      const yr = VC(wo), ur = wi(yr, "e"), nl = Ga(yr, "n");
      if (z === "" && xg(un), le === "" && Yw(un), yn !== P && z !== "") {
        ft(un, "width", z);
        const ni = Fe(), sm = xe(un), fh = Ta(m) || ur ? at(un) - 1 : 0;
        E_(un, yn - P, fh, ni, sm);
      } else if (r_(z)) {
        const ni = parseFloat(z.replace("%", "")), sm = yn * ni / P;
        ft(un, "width", sm + "%");
      }
      if (a_(z) && tF(un), Ks !== Q && le !== "") {
        ft(un, "height", le);
        const ni = nl ? 0 : Yt(un) - 1;
        _w(un, Ks - Q, ni);
      }
    }, vn = () => {
      C.on((un) => {
        un.destroy();
      }), _.on((un) => {
        BD(m, un);
      });
    };
    return m.on("init", () => {
      const un = FD(m, KE);
      if (_.set(un), of(m) && Wu(m)) {
        const wo = Fe(), yn = GE.create(un, wo, xe);
        yn.on(), yn.events.startDrag.bind((Ks) => {
          v.set(m.selection.getRng());
        }), yn.events.beforeResize.bind((Ks) => {
          const yr = Ks.table.dom;
          fi(m, yr, Lp(yr), tw(yr), F1 + Ks.type);
        }), yn.events.afterResize.bind((Ks) => {
          const yr = Ks.table, ur = yr.dom;
          rc(yr), v.on((nl) => {
            m.selection.setRng(nl), m.focus();
          }), ei(m, ur, Lp(ur), tw(ur), F1 + Ks.type), m.undoManager.add();
        }), C.set(yn);
      }
    }), m.on("ObjectResizeStart", (un) => {
      const wo = un.target;
      if (vx(wo)) {
        const yn = $e.fromDom(wo);
        Je(m.dom.select(".mce-clonedresizable"), (Ks) => {
          m.dom.addClass(Ks, "mce-" + Q2(m) + "-columns");
        }), !q_(yn) && Bm(m) ? Kw(yn) : !qw(yn) && Bp(m) && xg(yn), K_(yn) && Ga(un.origin, F1) && xg(yn), P = un.width, z = ju(m) ? "" : nw(m, wo).getOr(""), Q = un.height, le = s_(m, wo).getOr("");
      }
    }), m.on("ObjectResized", (un) => {
      const wo = un.target;
      if (vx(wo)) {
        const yn = $e.fromDom(wo), Ks = un.origin;
        lb(Ks) && _n(yn, Ks, un.width, un.height), rc(yn), Qp(m, yn.dom, mi);
      }
    }), m.on("SwitchMode", () => {
      C.on((un) => {
        m.mode.isReadOnly() ? un.hideBars() : un.showBars();
      });
    }), m.on("dragstart dragend", (un) => {
      C.on((wo) => {
        un.type === "dragstart" ? (wo.hideBars(), wo.off()) : (wo.on(), wo.showBars());
      });
    }), m.on("remove", () => {
      vn();
    }), {
      refresh: (un) => {
        C.on((wo) => wo.refreshBars($e.fromDom(un)));
      },
      hide: () => {
        C.on((un) => un.hideBars());
      },
      show: () => {
        C.on((un) => un.showBars());
      }
    };
  }, YE = (m) => {
    tg(m);
    const v = nF(m), C = lx(m, v), _ = Uw(m, v, C);
    return lE(m, _), XO(m, _), Av(m, _), {
      getSelectedCells: C.getSelectedCells,
      clearSelectedCells: C.clearSelectedCells
    };
  }, LD = (m) => ({ table: YE(m) });
  var _o = () => {
    o.add("dom", LD);
  };
  _o();
})();
(function() {
  const o = Object.getPrototypeOf, a = (t, r, l) => {
    var d;
    return l(t, r.prototype) ? !0 : ((d = t.constructor) === null || d === void 0 ? void 0 : d.name) === r.name;
  }, c = (t) => {
    const r = typeof t;
    return t === null ? "null" : r === "object" && Array.isArray(t) ? "array" : r === "object" && a(t, String, (l, d) => d.isPrototypeOf(l)) ? "string" : r;
  }, f = (t) => (r) => c(r) === t, g = (t) => (r) => typeof r === t, x = (t) => (r) => t === r, k = (t, r) => N(t) && a(t, r, (l, d) => o(l) === d), A = f("string"), N = f("object"), H = (t) => k(t, Object), Z = f("array"), K = x(null), J = g("boolean"), pe = x(void 0), Se = (t) => t == null, be = (t) => !Se(t), ye = g("function"), re = g("number"), oe = (t, r) => {
    if (Z(t)) {
      for (let l = 0, d = t.length; l < d; ++l)
        if (!r(t[l]))
          return !1;
      return !0;
    }
    return !1;
  }, U = () => {
  }, ve = (t) => () => t(), Ze = (t, r) => (...l) => t(r.apply(null, l)), rt = (t, r) => (l) => t(r(l)), ee = (t) => () => t, lt = (t) => t, wt = (t, r) => t === r;
  function Vt(t, ...r) {
    return (...l) => {
      const d = r.concat(l);
      return t.apply(null, d);
    };
  }
  const Ue = (t) => (r) => !t(r), Ce = (t) => () => {
    throw new Error(t);
  }, Rn = (t) => t(), _t = ee(!1), ot = ee(!0);
  class B {
    constructor(r, l) {
      this.tag = r, this.value = l;
    }
    static some(r) {
      return new B(!0, r);
    }
    static none() {
      return B.singletonNone;
    }
    fold(r, l) {
      return this.tag ? l(this.value) : r();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(r) {
      return this.tag ? B.some(r(this.value)) : B.none();
    }
    bind(r) {
      return this.tag ? r(this.value) : B.none();
    }
    exists(r) {
      return this.tag && r(this.value);
    }
    forall(r) {
      return !this.tag || r(this.value);
    }
    filter(r) {
      return !this.tag || r(this.value) ? this : B.none();
    }
    getOr(r) {
      return this.tag ? this.value : r;
    }
    or(r) {
      return this.tag ? this : r;
    }
    getOrThunk(r) {
      return this.tag ? this.value : r();
    }
    orThunk(r) {
      return this.tag ? this : r();
    }
    getOrDie(r) {
      if (this.tag)
        return this.value;
      throw new Error(r ?? "Called getOrDie on None");
    }
    static from(r) {
      return be(r) ? B.some(r) : B.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(r) {
      this.tag && r(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  B.singletonNone = new B(!1);
  const fn = Array.prototype.slice, ze = Array.prototype.indexOf, jt = Array.prototype.push, Tt = (t, r) => ze.call(t, r), Je = (t, r) => {
    const l = Tt(t, r);
    return l === -1 ? B.none() : B.some(l);
  }, pn = (t, r) => Tt(t, r) > -1, Ro = (t, r) => {
    for (let l = 0, d = t.length; l < d; l++) {
      const h = t[l];
      if (r(h, l))
        return !0;
    }
    return !1;
  }, Rt = (t, r) => {
    const l = [];
    for (let d = 0; d < t; d++)
      l.push(r(d));
    return l;
  }, Cn = (t, r) => {
    const l = [];
    for (let d = 0; d < t.length; d += r) {
      const h = fn.call(t, d, d + r);
      l.push(h);
    }
    return l;
  }, et = (t, r) => {
    const l = t.length, d = new Array(l);
    for (let h = 0; h < l; h++) {
      const y = t[h];
      d[h] = r(y, h);
    }
    return d;
  }, xt = (t, r) => {
    for (let l = 0, d = t.length; l < d; l++) {
      const h = t[l];
      r(h, l);
    }
  }, X = (t, r) => {
    for (let l = t.length - 1; l >= 0; l--) {
      const d = t[l];
      r(d, l);
    }
  }, ds = (t, r) => {
    const l = [], d = [];
    for (let h = 0, y = t.length; h < y; h++) {
      const w = t[h];
      (r(w, h) ? l : d).push(w);
    }
    return {
      pass: l,
      fail: d
    };
  }, So = (t, r) => {
    const l = [];
    for (let d = 0, h = t.length; d < h; d++) {
      const y = t[d];
      r(y, d) && l.push(y);
    }
    return l;
  }, At = (t, r, l) => (X(t, (d, h) => {
    l = r(l, d, h);
  }), l), Pt = (t, r, l) => (xt(t, (d, h) => {
    l = r(l, d, h);
  }), l), Hn = (t, r, l) => {
    for (let d = 0, h = t.length; d < h; d++) {
      const y = t[d];
      if (r(y, d))
        return B.some(y);
      if (l(y, d))
        break;
    }
    return B.none();
  }, Nt = (t, r) => Hn(t, r, _t), Vn = (t, r) => {
    for (let l = 0, d = t.length; l < d; l++) {
      const h = t[l];
      if (r(h, l))
        return B.some(l);
    }
    return B.none();
  }, tn = (t) => {
    const r = [];
    for (let l = 0, d = t.length; l < d; ++l) {
      if (!Z(t[l]))
        throw new Error("Arr.flatten item " + l + " was not an array, input: " + t);
      jt.apply(r, t[l]);
    }
    return r;
  }, je = (t, r) => tn(et(t, r)), An = (t, r) => {
    for (let l = 0, d = t.length; l < d; ++l) {
      const h = t[l];
      if (r(h, l) !== !0)
        return !1;
    }
    return !0;
  }, qn = (t) => {
    const r = fn.call(t, 0);
    return r.reverse(), r;
  }, on = (t, r) => So(t, (l) => !pn(r, l)), zt = (t, r) => {
    const l = {};
    for (let d = 0, h = t.length; d < h; d++) {
      const y = t[d];
      l[String(y)] = r(y, d);
    }
    return l;
  }, vt = (t) => [t], oo = (t, r) => {
    const l = fn.call(t, 0);
    return l.sort(r), l;
  }, Dn = (t, r) => r >= 0 && r < t.length ? B.some(t[r]) : B.none(), ao = (t) => Dn(t, 0), xs = (t) => Dn(t, t.length - 1), rs = ye(Array.from) ? Array.from : (t) => fn.call(t), Qo = (t, r) => {
    for (let l = 0; l < t.length; l++) {
      const d = r(t[l], l);
      if (d.isSome())
        return d;
    }
    return B.none();
  }, os = Object.keys, zs = Object.hasOwnProperty, it = (t, r) => {
    const l = os(t);
    for (let d = 0, h = l.length; d < h; d++) {
      const y = l[d], w = t[y];
      r(w, y);
    }
  }, kt = (t, r) => xn(t, (l, d) => ({
    k: d,
    v: r(l, d)
  })), xn = (t, r) => {
    const l = {};
    return it(t, (d, h) => {
      const y = r(d, h);
      l[y.k] = y.v;
    }), l;
  }, hn = (t) => (r, l) => {
    t[l] = r;
  }, Do = (t, r, l, d) => {
    it(t, (h, y) => {
      (r(h, y) ? l : d)(h, y);
    });
  }, Ss = (t, r) => {
    const l = {}, d = {};
    return Do(t, r, hn(l), hn(d)), {
      t: l,
      f: d
    };
  }, pr = (t, r) => {
    const l = {};
    return Do(t, r, hn(l), U), l;
  }, ta = (t, r) => {
    const l = [];
    return it(t, (d, h) => {
      l.push(r(d, h));
    }), l;
  }, Ms = (t, r) => {
    const l = os(t);
    for (let d = 0, h = l.length; d < h; d++) {
      const y = l[d], w = t[y];
      if (r(w, y, t))
        return B.some(w);
    }
    return B.none();
  }, hr = (t) => ta(t, lt), qt = (t, r) => Ko(t, r) ? B.from(t[r]) : B.none(), Ko = (t, r) => zs.call(t, r), Lr = (t, r) => Ko(t, r) && t[r] !== void 0 && t[r] !== null, ha = (t, r, l = wt) => t.exists((d) => l(d, r)), ia = (t, r, l = wt) => xa(t, r, l).getOr(t.isNone() && r.isNone()), na = (t) => {
    const r = [], l = (d) => {
      r.push(d);
    };
    for (let d = 0; d < t.length; d++)
      t[d].each(l);
    return r;
  }, ks = (t) => {
    const r = [];
    for (let l = 0; l < t.length; l++) {
      const d = t[l];
      if (d.isSome())
        r.push(d.getOrDie());
      else
        return B.none();
    }
    return B.some(r);
  }, xa = (t, r, l) => t.isSome() && r.isSome() ? B.some(l(t.getOrDie(), r.getOrDie())) : B.none(), la = (t, r, l, d) => t.isSome() && r.isSome() && l.isSome() ? B.some(d(t.getOrDie(), r.getOrDie(), l.getOrDie())) : B.none(), _s = (t, r) => t != null ? B.some(r(t)) : B.none(), Xn = (t, r) => t ? B.some(r) : B.none(), wr = (t, r) => t + r, Ke = (t, r) => t.substring(r), ht = (t, r, l) => r === "" || t.length >= r.length && t.substr(l, l + r.length) === r, gn = (t, r) => as(t, r) ? Ke(t, r.length) : t, En = (t, r) => Yr(t, r) ? t : wr(t, r), Ao = (t, r, l = 0, d) => {
    const h = t.indexOf(r, l);
    return h !== -1 ? pe(d) ? !0 : h + r.length <= d : !1;
  }, as = (t, r) => ht(t, r, 0), Yr = (t, r) => ht(t, r, t.length - r.length), Tr = ((t) => (r) => r.replace(t, ""))(/^\s+|\s+$/g), Ne = (t) => t.length > 0, Ae = (t) => !Ne(t), ct = (t) => t.style !== void 0 && ye(t.style.getPropertyValue), Ct = (t, r) => {
    const d = (r || document).createElement("div");
    if (d.innerHTML = t, !d.hasChildNodes() || d.childNodes.length > 1) {
      const h = "HTML does not have a single root node";
      throw console.error(h, t), new Error(h);
    }
    return Bo(d.childNodes[0]);
  }, Kn = (t, r) => {
    const d = (r || document).createElement(t);
    return Bo(d);
  }, lo = (t, r) => {
    const d = (r || document).createTextNode(t);
    return Bo(d);
  }, Bo = (t) => {
    if (t == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: t };
  }, $e = {
    fromHtml: Ct,
    fromTag: Kn,
    fromText: lo,
    fromDom: Bo,
    fromPoint: (t, r, l) => B.from(t.dom.elementFromPoint(r, l)).map(Bo)
  }, Oo = typeof window < "u" ? window : Function("return this;")(), Pe = (t, r) => {
    let l = r ?? Oo;
    for (let d = 0; d < t.length && l !== void 0 && l !== null; ++d)
      l = l[t[d]];
    return l;
  }, Ie = (t, r) => {
    const l = t.split(".");
    return Pe(l, r);
  }, Lt = (t, r) => Ie(t, r), Zt = (t, r) => {
    const l = Lt(t, r);
    if (l == null)
      throw new Error(t + " not available on this browser");
    return l;
  }, kn = Object.getPrototypeOf, Jn = (t) => Zt("HTMLElement", t), Zn = (t) => {
    const r = Ie("ownerDocument.defaultView", t);
    return N(t) && (Jn(r).prototype.isPrototypeOf(t) || /^HTML\w*Element$/.test(kn(t).constructor.name));
  }, Gn = 9, Qn = 11, co = 1, Jo = 3, Gs = (t) => t.dom.nodeName.toLowerCase(), Wa = (t) => t.dom.nodeType, Ti = (t) => (r) => Wa(r) === t, Ai = (t) => ko(t) && Zn(t.dom), ko = Ti(co), Zo = Ti(Jo), Rs = Ti(Gn), Ba = Ti(Qn), ca = (t) => (r) => ko(r) && Gs(r) === t, gr = (t, r) => {
    const l = t.dom;
    if (l.nodeType !== co)
      return !1;
    {
      const d = l;
      if (d.matches !== void 0)
        return d.matches(r);
      if (d.msMatchesSelector !== void 0)
        return d.msMatchesSelector(r);
      if (d.webkitMatchesSelector !== void 0)
        return d.webkitMatchesSelector(r);
      if (d.mozMatchesSelector !== void 0)
        return d.mozMatchesSelector(r);
      throw new Error("Browser lacks native selectors");
    }
  }, Qs = (t) => t.nodeType !== co && t.nodeType !== Gn && t.nodeType !== Qn || t.childElementCount === 0, ii = (t, r) => {
    const l = r === void 0 ? document : r.dom;
    return Qs(l) ? [] : et(l.querySelectorAll(t), $e.fromDom);
  }, xc = (t, r) => {
    const l = r === void 0 ? document : r.dom;
    return Qs(l) ? B.none() : B.from(l.querySelector(t)).map($e.fromDom);
  }, Is = (t, r) => t.dom === r.dom, ka = (t, r) => {
    const l = t.dom, d = r.dom;
    return l === d ? !1 : l.contains(d);
  }, li = (t) => $e.fromDom(t.dom.ownerDocument), Qr = (t) => Rs(t) ? t : li(t), Oi = (t) => $e.fromDom(Qr(t).dom.documentElement), cl = (t) => $e.fromDom(Qr(t).dom.defaultView), Za = (t) => B.from(t.dom.parentNode).map($e.fromDom), Di = (t) => Za(t), ji = (t) => B.from(t.dom.parentElement).map($e.fromDom), uu = (t, r) => {
    const l = ye(r) ? r : _t;
    let d = t.dom;
    const h = [];
    for (; d.parentNode !== null && d.parentNode !== void 0; ) {
      const y = d.parentNode, w = $e.fromDom(y);
      if (h.push(w), l(w) === !0)
        break;
      d = y;
    }
    return h;
  }, vi = (t) => B.from(t.dom.offsetParent).map($e.fromDom), Bl = (t) => B.from(t.dom.nextSibling).map($e.fromDom), La = (t) => et(t.dom.childNodes, $e.fromDom), Wi = (t, r) => {
    const l = t.dom.childNodes;
    return B.from(l[r]).map($e.fromDom);
  }, Xl = (t) => Wi(t, 0), wc = (t, r) => ({
    element: t,
    offset: r
  }), fd = (t, r) => {
    const l = La(t);
    return l.length > 0 && r < l.length ? wc(l[r], 0) : wc(t, r);
  }, du = (t) => Ba(t) && be(t.dom.host), bi = ye(Element.prototype.attachShadow) && ye(Node.prototype.getRootNode), Fu = ee(bi), ie = bi ? (t) => $e.fromDom(t.dom.getRootNode()) : Qr, Oe = (t) => du(t) ? t : $e.fromDom(Qr(t).dom.body), Ge = (t) => Dt(t).isSome(), Dt = (t) => {
    const r = ie(t);
    return du(r) ? B.some(r) : B.none();
  }, Xt = (t) => $e.fromDom(t.dom.host), jn = (t) => {
    if (Fu() && be(t.target)) {
      const r = $e.fromDom(t.target);
      if (ko(r) && ss(r) && t.composed && t.composedPath) {
        const l = t.composedPath();
        if (l)
          return ao(l);
      }
    }
    return B.from(t.target);
  }, ss = (t) => be(t.dom.shadowRoot), hs = (t) => {
    const r = Zo(t) ? t.dom.parentNode : t.dom;
    if (r == null || r.ownerDocument === null)
      return !1;
    const l = r.ownerDocument;
    return Dt($e.fromDom(r)).fold(() => l.body.contains(r), rt(hs, Xt));
  }, Uo = () => qs($e.fromDom(document)), qs = (t) => {
    const r = t.dom.body;
    if (r == null)
      throw new Error("Body is not available yet");
    return $e.fromDom(r);
  }, Ar = (t, r, l) => {
    if (A(l) || J(l) || re(l))
      t.setAttribute(r, l + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", r, ":: Value ", l, ":: Element ", t), new Error("Attribute value was not simple");
  }, sn = (t, r, l) => {
    Ar(t.dom, r, l);
  }, md = (t, r) => {
    const l = t.dom;
    it(r, (d, h) => {
      Ar(l, h, d);
    });
  }, tr = (t, r) => {
    const l = t.dom.getAttribute(r);
    return l === null ? void 0 : l;
  }, Y = (t, r) => B.from(tr(t, r)), ge = (t, r) => {
    const l = t.dom;
    return l && l.hasAttribute ? l.hasAttribute(r) : !1;
  }, Ee = (t, r) => {
    t.dom.removeAttribute(r);
  }, dt = (t) => Pt(t.dom.attributes, (r, l) => (r[l.name] = l.value, r), {}), wn = (t, r, l) => {
    if (!A(l))
      throw console.error("Invalid call to CSS.set. Property ", r, ":: Value ", l, ":: Element ", t), new Error("CSS value must be a string: " + l);
    ct(t) && t.style.setProperty(r, l);
  }, Yo = (t, r) => {
    ct(t) && t.style.removeProperty(r);
  }, Ln = (t, r, l) => {
    const d = t.dom;
    wn(d, r, l);
  }, Or = (t, r) => {
    const l = t.dom;
    it(r, (d, h) => {
      wn(l, h, d);
    });
  }, Kt = (t, r) => {
    const l = t.dom;
    it(r, (d, h) => {
      d.fold(() => {
        Yo(l, h);
      }, (y) => {
        wn(l, h, y);
      });
    });
  }, lr = (t, r) => {
    const l = t.dom, h = window.getComputedStyle(l).getPropertyValue(r);
    return h === "" && !hs(t) ? yi(l, r) : h;
  }, yi = (t, r) => ct(t) ? t.style.getPropertyValue(r) : "", Cr = (t, r) => {
    const l = t.dom, d = yi(l, r);
    return B.from(d).filter((h) => h.length > 0);
  }, ga = (t) => {
    const r = {}, l = t.dom;
    if (ct(l))
      for (let d = 0; d < l.style.length; d++) {
        const h = l.style.item(d);
        r[h] = l.style[h];
      }
    return r;
  }, Ll = (t, r, l) => {
    const d = $e.fromTag(t);
    return Ln(d, r, l), Cr(d, r).isSome();
  }, gs = (t, r) => {
    const l = t.dom;
    Yo(l, r), ha(Y(t, "style").map(Tr), "") && Ee(t, "style");
  }, xi = (t) => t.dom.offsetWidth, Dr = (t, r) => {
    const l = (E, O) => {
      if (!re(O) && !O.match(/^[0-9]+$/))
        throw new Error(t + ".set accepts only positive integer values. Value was " + O);
      const F = E.dom;
      ct(F) && (F.style[t] = O + "px");
    }, d = (E) => {
      const O = r(E);
      if (O <= 0 || O === null) {
        const F = lr(E, t);
        return parseFloat(F) || 0;
      }
      return O;
    }, h = d, y = (E, O) => Pt(O, (F, L) => {
      const q = lr(E, L), ne = q === void 0 ? 0 : parseInt(q, 10);
      return isNaN(ne) ? F : F + ne;
    }, 0);
    return {
      set: l,
      get: d,
      getOuter: h,
      aggregate: y,
      max: (E, O, F) => {
        const L = y(E, F);
        return O > L ? O - L : 0;
      }
    };
  }, Cc = Dr("height", (t) => {
    const r = t.dom;
    return hs(t) ? r.getBoundingClientRect().height : r.offsetHeight;
  }), Mr = (t) => Cc.get(t), pd = (t) => Cc.getOuter(t), Tm = (t, r) => {
    const l = [
      "margin-top",
      "border-top-width",
      "padding-top",
      "padding-bottom",
      "border-bottom-width",
      "margin-bottom"
    ], d = Cc.max(t, r, l);
    Ln(t, "max-height", d + "px");
  }, zh = (t, r) => ({
    left: t,
    top: r,
    translate: (d, h) => zh(t + d, r + h)
  }), $r = zh, Ql = (t) => {
    const r = t.getBoundingClientRect();
    return $r(r.left, r.top);
  }, $a = (t, r) => t !== void 0 ? t : r !== void 0 ? r : 0, Ga = (t) => {
    const r = t.dom.ownerDocument, l = r.body, d = r.defaultView, h = r.documentElement;
    if (l === t.dom)
      return $r(l.offsetLeft, l.offsetTop);
    const y = $a(d == null ? void 0 : d.pageYOffset, h.scrollTop), w = $a(d == null ? void 0 : d.pageXOffset, h.scrollLeft), E = $a(h.clientTop, l.clientTop), O = $a(h.clientLeft, l.clientLeft);
    return wi(t).translate(w - O, y - E);
  }, wi = (t) => {
    const r = t.dom, d = r.ownerDocument.body;
    return d === r ? $r(d.offsetLeft, d.offsetTop) : hs(t) ? Ql(r) : $r(0, 0);
  }, If = Dr("width", (t) => t.dom.offsetWidth), fs = (t, r) => If.set(t, r), Ri = (t) => If.get(t), ci = (t) => If.getOuter(t), me = (t, r) => {
    const l = [
      "margin-left",
      "border-left-width",
      "padding-left",
      "padding-right",
      "border-right-width",
      "margin-right"
    ], d = If.max(t, r, l);
    Ln(t, "max-width", d + "px");
  }, Te = (t) => {
    let r = !1, l;
    return (...d) => (r || (r = !0, l = t.apply(null, d)), l);
  }, nt = (t, r, l, d) => {
    const h = t.isiOS() && /ipad/i.test(l) === !0, y = t.isiOS() && !h, w = t.isiOS() || t.isAndroid(), E = w || d("(pointer:coarse)"), O = h || !y && w && d("(min-device-width:768px)"), F = y || w && !O, L = r.isSafari() && t.isiOS() && /safari/i.test(l) === !1, q = !F && !O && !L;
    return {
      isiPad: ee(h),
      isiPhone: ee(y),
      isTablet: ee(O),
      isPhone: ee(F),
      isTouch: ee(E),
      isAndroid: t.isAndroid,
      isiOS: t.isiOS,
      isWebView: ee(L),
      isDesktop: ee(q)
    };
  }, ft = (t, r) => {
    for (let l = 0; l < t.length; l++) {
      const d = t[l];
      if (d.test(r))
        return d;
    }
  }, eo = (t, r) => {
    const l = ft(t, r);
    if (!l)
      return {
        major: 0,
        minor: 0
      };
    const d = (h) => Number(r.replace(l, "$" + h));
    return Ha(d(1), d(2));
  }, es = (t, r) => {
    const l = String(r).toLowerCase();
    return t.length === 0 ? Sr() : eo(t, l);
  }, Sr = () => Ha(0, 0), Ha = (t, r) => ({
    major: t,
    minor: r
  }), is = {
    nu: Ha,
    detect: es,
    unknown: Sr
  }, _a = (t, r) => Qo(r.brands, (l) => {
    const d = l.brand.toLowerCase();
    return Nt(t, (h) => {
      var y;
      return d === ((y = h.brand) === null || y === void 0 ? void 0 : y.toLowerCase());
    }).map((h) => ({
      current: h.name,
      version: is.nu(parseInt(l.version, 10), 0)
    }));
  }), Rr = (t, r) => {
    const l = String(r).toLowerCase();
    return Nt(t, (d) => d.search(l));
  }, ua = (t, r) => Rr(t, r).map((l) => {
    const d = is.detect(l.versionRegexes, r);
    return {
      current: l.name,
      version: d
    };
  }), oa = (t, r) => Rr(t, r).map((l) => {
    const d = is.detect(l.versionRegexes, r);
    return {
      current: l.name,
      version: d
    };
  }), Jr = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, ul = (t) => (r) => Ao(r, t), Sc = [
    {
      name: "Edge",
      versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
      search: (t) => Ao(t, "edge/") && Ao(t, "chrome") && Ao(t, "safari") && Ao(t, "applewebkit")
    },
    {
      name: "Chromium",
      brand: "Chromium",
      versionRegexes: [
        /.*?chrome\/([0-9]+)\.([0-9]+).*/,
        Jr
      ],
      search: (t) => Ao(t, "chrome") && !Ao(t, "chromeframe")
    },
    {
      name: "IE",
      versionRegexes: [
        /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
        /.*?rv:([0-9]+)\.([0-9]+).*/
      ],
      search: (t) => Ao(t, "msie") || Ao(t, "trident")
    },
    {
      name: "Opera",
      versionRegexes: [
        Jr,
        /.*?opera\/([0-9]+)\.([0-9]+).*/
      ],
      search: ul("opera")
    },
    {
      name: "Firefox",
      versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
      search: ul("firefox")
    },
    {
      name: "Safari",
      versionRegexes: [
        Jr,
        /.*?cpu os ([0-9]+)_([0-9]+).*/
      ],
      search: (t) => (Ao(t, "safari") || Ao(t, "mobile/")) && Ao(t, "applewebkit")
    }
  ], qa = [
    {
      name: "Windows",
      search: ul("win"),
      versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "iOS",
      search: (t) => Ao(t, "iphone") || Ao(t, "ipad"),
      versionRegexes: [
        /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
        /.*cpu os ([0-9]+)_([0-9]+).*/,
        /.*cpu iphone os ([0-9]+)_([0-9]+).*/
      ]
    },
    {
      name: "Android",
      search: ul("android"),
      versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "macOS",
      search: ul("mac os x"),
      versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    },
    {
      name: "Linux",
      search: ul("linux"),
      versionRegexes: []
    },
    {
      name: "Solaris",
      search: ul("sunos"),
      versionRegexes: []
    },
    {
      name: "FreeBSD",
      search: ul("freebsd"),
      versionRegexes: []
    },
    {
      name: "ChromeOS",
      search: ul("cros"),
      versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }
  ], dl = {
    browsers: ee(Sc),
    oses: ee(qa)
  }, Bc = "Edge", Lc = "Chromium", xp = "IE", hd = "Opera", kc = "Firefox", Zi = "Safari", gd = () => Ff({
    current: void 0,
    version: is.unknown()
  }), Ff = (t) => {
    const r = t.current, l = t.version, d = (h) => () => r === h;
    return {
      current: r,
      version: l,
      isEdge: d(Bc),
      isChromium: d(Lc),
      isIE: d(xp),
      isOpera: d(hd),
      isFirefox: d(kc),
      isSafari: d(Zi)
    };
  }, fu = {
    unknown: gd,
    nu: Ff,
    edge: ee(Bc),
    chromium: ee(Lc),
    ie: ee(xp),
    opera: ee(hd),
    firefox: ee(kc),
    safari: ee(Zi)
  }, Vh = "Windows", Bf = "iOS", Uh = "Android", Yd = "Linux", jh = "macOS", Xd = "Solaris", Hb = "FreeBSD", Me = "ChromeOS", Am = () => wl({
    current: void 0,
    version: is.unknown()
  }), wl = (t) => {
    const r = t.current, l = t.version, d = (h) => () => r === h;
    return {
      current: r,
      version: l,
      isWindows: d(Vh),
      isiOS: d(Bf),
      isAndroid: d(Uh),
      isMacOS: d(jh),
      isLinux: d(Yd),
      isSolaris: d(Xd),
      isFreeBSD: d(Hb),
      isChromeOS: d(Me)
    };
  }, Bu = {
    unknown: Am,
    nu: wl,
    windows: ee(Vh),
    ios: ee(Bf),
    android: ee(Uh),
    linux: ee(Yd),
    macos: ee(jh),
    solaris: ee(Xd),
    freebsd: ee(Hb),
    chromeos: ee(Me)
  }, cv = { detect: (t, r, l) => {
    const d = dl.browsers(), h = dl.oses(), y = r.bind((O) => _a(d, O)).orThunk(() => ua(d, t)).fold(fu.unknown, fu.nu), w = oa(h, t).fold(Bu.unknown, Bu.nu), E = nt(w, y, t, l);
    return {
      browser: y,
      os: w,
      deviceType: E
    };
  } }, Bs = (t) => window.matchMedia(t).matches;
  let Gi = Te(() => cv.detect(navigator.userAgent, B.from(navigator.userAgentData), Bs));
  const $l = () => Gi(), Ka = (t, r, l, d, h, y, w) => ({
    target: t,
    x: r,
    y: l,
    stop: d,
    prevent: h,
    kill: y,
    raw: w
  }), Qd = (t) => {
    const r = $e.fromDom(jn(t).getOr(t.target)), l = () => t.stopPropagation(), d = () => t.preventDefault(), h = Ze(d, l);
    return Ka(r, t.clientX, t.clientY, l, d, h, t);
  }, $c = (t, r) => (l) => {
    t(l) && r(Qd(l));
  }, Ni = (t, r, l, d, h) => {
    const y = $c(l, d);
    return t.dom.addEventListener(r, y, h), { unbind: Vt(uv, t, r, y, h) };
  }, Hc = (t, r, l, d) => Ni(t, r, l, d, !1), Zh = (t, r, l, d) => Ni(t, r, l, d, !0), uv = (t, r, l, d) => {
    t.dom.removeEventListener(r, l, d);
  }, Jl = (t, r) => {
    Za(t).each((d) => {
      d.dom.insertBefore(r.dom, t.dom);
    });
  }, zc = (t, r) => {
    Bl(t).fold(() => {
      Za(t).each((h) => {
        qi(h, r);
      });
    }, (d) => {
      Jl(d, r);
    });
  }, wp = (t, r) => {
    Xl(t).fold(() => {
      qi(t, r);
    }, (d) => {
      t.dom.insertBefore(r.dom, d.dom);
    });
  }, qi = (t, r) => {
    t.dom.appendChild(r.dom);
  }, Ya = (t, r, l) => {
    Wi(t, l).fold(() => {
      qi(t, r);
    }, (d) => {
      Jl(d, r);
    });
  }, vd = (t, r) => {
    xt(r, (l) => {
      qi(t, l);
    });
  }, Lf = (t) => {
    t.dom.textContent = "", xt(La(t), (r) => {
      _c(r);
    });
  }, _c = (t) => {
    const r = t.dom;
    r.parentNode !== null && r.parentNode.removeChild(r);
  }, Ci = (t) => {
    const r = t !== void 0 ? t.dom : document, l = r.body.scrollLeft || r.documentElement.scrollLeft, d = r.body.scrollTop || r.documentElement.scrollTop;
    return $r(l, d);
  }, Cp = (t, r, l) => {
    const h = (l !== void 0 ? l.dom : document).defaultView;
    h && h.scrollTo(t, r);
  }, Sp = (t) => {
    const r = t === void 0 ? window : t;
    return $l().browser.isFirefox() ? B.none() : B.from(r.visualViewport);
  }, kp = (t, r, l, d) => ({
    x: t,
    y: r,
    width: l,
    height: d,
    right: t + l,
    bottom: r + d
  }), Om = (t) => {
    const r = t === void 0 ? window : t, l = r.document, d = Ci($e.fromDom(l));
    return Sp(r).fold(() => {
      const h = r.document.documentElement, y = h.clientWidth, w = h.clientHeight;
      return kp(d.left, d.top, y, w);
    }, (h) => kp(Math.max(h.pageLeft, d.left), Math.max(h.pageTop, d.top), h.width, h.height));
  }, ec = () => $e.fromDom(document), _p = (t, r) => t.view(r).fold(ee([]), (d) => {
    const h = t.owner(d), y = _p(t, h);
    return [d].concat(y);
  }), dv = (t, r) => {
    const l = r.owner(t), d = _p(r, l);
    return B.some(d);
  };
  var Ep = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    view: (t) => {
      var r;
      return (t.dom === document ? B.none() : B.from((r = t.dom.defaultView) === null || r === void 0 ? void 0 : r.frameElement)).map($e.fromDom);
    },
    owner: (t) => li(t)
  });
  const Dm = (t) => {
    const r = ec(), l = Ci(r);
    return dv(t, Ep).fold(Vt(Ga, t), (h) => {
      const y = wi(t), w = At(h, (E, O) => {
        const F = wi(O);
        return {
          left: E.left + F.left,
          top: E.top + F.top
        };
      }, {
        left: 0,
        top: 0
      });
      return $r(w.left + y.left + l.left, w.top + y.top + l.top);
    });
  }, Lu = (t, r, l) => ({
    point: t,
    width: r,
    height: l
  }), Gh = (t, r, l, d) => ({
    x: t,
    y: r,
    width: l,
    height: d
  }), Nr = (t, r, l, d) => ({
    x: t,
    y: r,
    width: l,
    height: d,
    right: t + l,
    bottom: r + d
  }), sa = (t) => {
    const r = Ga(t), l = ci(t), d = pd(t);
    return Nr(r.left, r.top, l, d);
  }, Cl = (t) => {
    const r = Dm(t), l = ci(t), d = pd(t);
    return Nr(r.left, r.top, l, d);
  }, qh = (t, r) => {
    const l = Math.max(t.x, r.x), d = Math.max(t.y, r.y), h = Math.min(t.right, r.right), y = Math.min(t.bottom, r.bottom), w = h - l, E = y - d;
    return Nr(l, d, w, E);
  }, Kh = (t, r) => Pt(r, (l, d) => qh(l, d), t), Na = () => Om(window), to = (t) => {
    let r = t;
    return {
      get: () => r,
      set: (h) => {
        r = h;
      }
    };
  }, mu = (t) => {
    const r = to(B.none()), l = () => r.get().each(t);
    return {
      clear: () => {
        l(), r.set(B.none());
      },
      isSet: () => r.get().isSome(),
      get: () => r.get(),
      set: (E) => {
        l(), r.set(B.some(E));
      }
    };
  }, mv = () => mu((t) => t.destroy()), za = () => mu((t) => t.unbind()), cr = () => {
    const t = mu(U);
    return {
      ...t,
      on: (l) => t.get().each(l)
    };
  };
  var Jd = tinymce.util.Tools.resolve("tinymce.ThemeManager");
  const Yh = (t) => {
    const r = (y) => y(t), l = ee(t), d = () => h, h = {
      tag: !0,
      inner: t,
      fold: (y, w) => w(t),
      isValue: ot,
      isError: _t,
      map: (y) => Ho.value(y(t)),
      mapError: d,
      bind: r,
      exists: r,
      forall: r,
      getOr: l,
      or: d,
      getOrThunk: l,
      orThunk: d,
      getOrDie: l,
      each: (y) => {
        y(t);
      },
      toOptional: () => B.some(t)
    };
    return h;
  }, Tp = (t) => {
    const r = () => l, l = {
      tag: !1,
      inner: t,
      fold: (d, h) => d(t),
      isValue: _t,
      isError: ot,
      map: r,
      mapError: (d) => Ho.error(d(t)),
      bind: r,
      exists: _t,
      forall: ot,
      getOr: lt,
      or: lt,
      getOrThunk: Rn,
      orThunk: Rn,
      getOrDie: Ce(String(t)),
      each: U,
      toOptional: B.none
    };
    return l;
  }, Ho = {
    value: Yh,
    error: Tp,
    fromOption: (t, r) => t.fold(() => Tp(r), Yh)
  };
  var da;
  (function(t) {
    t[t.Error = 0] = "Error", t[t.Value = 1] = "Value";
  })(da || (da = {}));
  const $f = (t, r, l) => t.stype === da.Error ? r(t.serror) : l(t.svalue), Sl = (t) => {
    const r = [], l = [];
    return xt(t, (d) => {
      $f(d, (h) => l.push(h), (h) => r.push(h));
    }), {
      values: r,
      errors: l
    };
  }, fl = (t, r) => t.stype === da.Error ? {
    stype: da.Error,
    serror: r(t.serror)
  } : t, kl = (t, r) => t.stype === da.Value ? {
    stype: da.Value,
    svalue: r(t.svalue)
  } : t, Pa = (t, r) => t.stype === da.Value ? r(t.svalue) : t, Ki = (t, r) => t.stype === da.Error ? r(t.serror) : t, tc = (t) => ({
    stype: da.Value,
    svalue: t
  }), Rm = (t) => ({
    stype: da.Error,
    serror: t
  }), wa = {
    fromResult: (t) => t.fold(Rm, tc),
    toResult: (t) => $f(t, Ho.error, Ho.value),
    svalue: tc,
    partition: Sl,
    serror: Rm,
    bind: Pa,
    bindError: Ki,
    map: kl,
    mapError: fl,
    fold: $f
  }, bd = (t, r, l, d) => ({
    tag: "field",
    key: t,
    newKey: r,
    presence: l,
    prop: d
  }), Vc = (t, r) => ({
    tag: "custom",
    newKey: t,
    instantiator: r
  }), vr = (t, r, l) => {
    switch (t.tag) {
      case "field":
        return r(t.key, t.newKey, t.presence, t.prop);
      case "custom":
        return l(t.newKey, t.instantiator);
    }
  }, Uc = (t, r) => r, Hf = (t, r) => H(t) && H(r) ? Pr(t, r) : r, $u = (t) => (...r) => {
    if (r.length === 0)
      throw new Error("Can't merge zero objects");
    const l = {};
    for (let d = 0; d < r.length; d++) {
      const h = r[d];
      for (const y in h)
        Ko(h, y) && (l[y] = t(l[y], h[y]));
    }
    return l;
  }, Pr = $u(Hf), yd = $u(Uc), nc = () => ({
    tag: "required",
    process: {}
  }), ls = (t) => ({
    tag: "defaultedThunk",
    process: t
  }), ef = (t) => ls(ee(t)), Nm = () => ({
    tag: "option",
    process: {}
  }), Op = (t) => ({
    tag: "mergeWithThunk",
    process: t
  }), pv = (t) => Op(ee(t)), Dp = (t, r) => t.length > 0 ? wa.svalue(Pr(r, yd.apply(void 0, t))) : wa.svalue(r), hv = (t) => Ze(wa.serror, tn)(t), se = {
    consolidateObj: (t, r) => {
      const l = wa.partition(t);
      return l.errors.length > 0 ? hv(l.errors) : Dp(l.values, r);
    },
    consolidateArr: (t) => {
      const r = wa.partition(t);
      return r.errors.length > 0 ? hv(r.errors) : wa.svalue(r.values);
    }
  }, De = (t) => N(t) && os(t).length > 100 ? " removed due to size" : JSON.stringify(t, null, 2), Le = (t) => {
    const r = t.length > 10 ? t.slice(0, 10).concat([{
      path: [],
      getErrorInfo: ee("... (only showing first ten failures)")
    }]) : t;
    return et(r, (l) => "Failed path: (" + l.path.join(" > ") + `)
` + l.getErrorInfo());
  }, $t = (t, r) => wa.serror([{
    path: t,
    getErrorInfo: r
  }]), vo = (t, r, l) => $t(t, () => 'Could not find valid *required* value for "' + r + '" in ' + De(l)), Lo = (t, r) => $t(t, () => 'Choice schema did not contain choice key: "' + r + '"'), Mo = (t, r, l) => $t(t, () => 'The chosen schema: "' + l + '" did not exist in branches: ' + De(r)), go = (t, r) => $t(t, () => "There are unsupported fields: [" + r.join(", ") + "] specified"), Hr = (t, r) => $t(t, ee(r)), fa = (t) => {
    const r = (d, h) => wa.bindError(t(h), (y) => Hr(d, y)), l = ee("val");
    return {
      extract: r,
      toString: l
    };
  }, _l = fa(wa.svalue), va = (t, r, l, d) => qt(r, l).fold(() => vo(t, l, r), d), gv = (t, r, l, d) => {
    const h = qt(t, r).getOrThunk(() => l(t));
    return d(h);
  }, q0 = (t, r, l) => l(qt(t, r)), Vb = (t, r, l, d) => {
    const h = qt(t, r).map((y) => y === !0 ? l(t) : y);
    return d(h);
  }, Pi = (t, r, l, d, h) => {
    const y = (E) => h.extract(r.concat([d]), E), w = (E) => E.fold(() => wa.svalue(B.none()), (O) => {
      const F = h.extract(r.concat([d]), O);
      return wa.map(F, B.some);
    });
    switch (t.tag) {
      case "required":
        return va(r, l, d, y);
      case "defaultedThunk":
        return gv(l, d, t.process, y);
      case "option":
        return q0(l, d, w);
      case "defaultedOptionThunk":
        return Vb(l, d, t.process, w);
      case "mergeWithThunk":
        return gv(l, d, ee({}), (E) => {
          const O = Pr(t.process(l), E);
          return y(O);
        });
    }
  }, vv = (t, r, l) => {
    const d = {}, h = [];
    for (const y of l)
      vr(y, (w, E, O, F) => {
        const L = Pi(O, t, r, w, F);
        wa.fold(L, (q) => {
          h.push(...q);
        }, (q) => {
          d[E] = q;
        });
      }, (w, E) => {
        d[w] = E(r);
      });
    return h.length > 0 ? wa.serror(h) : wa.svalue(d);
  }, Xa = (t) => ({
    extract: (d, h) => t().extract(d, h),
    toString: () => t().toString()
  }), Ub = (t) => os(pr(t, be)), Mi = (t) => {
    const r = xo(t), l = At(t, (h, y) => vr(y, (w) => Pr(h, { [w]: !0 }), ee(h)), {});
    return {
      extract: (h, y) => {
        const w = J(y) ? [] : Ub(y), E = So(w, (O) => !Lr(l, O));
        return E.length === 0 ? r.extract(h, y) : go(h, E);
      },
      toString: r.toString
    };
  }, xo = (t) => ({
    extract: (d, h) => vv(d, h, t),
    toString: () => `obj{
` + et(t, (h) => vr(h, (y, w, E, O) => y + " -> " + O.toString(), (y, w) => "state(" + y + ")")).join(`
`) + "}"
  }), jc = (t) => ({
    extract: (d, h) => {
      const y = et(h, (w, E) => t.extract(d.concat(["[" + E + "]"]), w));
      return se.consolidateArr(y);
    },
    toString: () => "array(" + t.toString() + ")"
  }), Rp = (t, r) => {
    const l = r !== void 0 ? r : lt;
    return {
      extract: (y, w) => {
        const E = [];
        for (const O of t) {
          const F = O.extract(y, w);
          if (F.stype === da.Value)
            return {
              stype: da.Value,
              svalue: l(F.svalue)
            };
          E.push(F);
        }
        return se.consolidateArr(E);
      },
      toString: () => "oneOf(" + et(t, (y) => y.toString()).join(", ") + ")"
    };
  }, Np = (t, r) => {
    const l = (y, w) => jc(fa(t)).extract(y, w);
    return {
      extract: (y, w) => {
        const E = os(w), O = l(y, E);
        return wa.bind(O, (F) => {
          const L = et(F, (q) => bd(q, q, nc(), r));
          return xo(L).extract(y, w);
        });
      },
      toString: () => "setOf(" + r.toString() + ")"
    };
  }, K0 = (t, r) => {
    const l = Te(r);
    return {
      extract: (y, w) => l().extract(y, w),
      toString: () => l().toString()
    };
  }, jb = Ze(jc, xo), pu = ee(_l), xd = (t, r) => fa((l) => {
    const d = typeof l;
    return t(l) ? wa.svalue(l) : wa.serror(`Expected type: ${r} but got: ${d}`);
  }), zf = xd(re, "number"), Tn = xd(A, "string"), Ec = xd(J, "boolean"), Wb = xd(ye, "function"), Pm = (t) => {
    if (Object(t) !== t)
      return !0;
    switch ({}.toString.call(t).slice(8, -1)) {
      case "Boolean":
      case "Number":
      case "String":
      case "Date":
      case "RegExp":
      case "Blob":
      case "FileList":
      case "ImageData":
      case "ImageBitmap":
      case "ArrayBuffer":
        return !0;
      case "Array":
      case "Object":
        return Object.keys(t).every((r) => Pm(t[r]));
      default:
        return !1;
    }
  }, hu = fa((t) => Pm(t) ? wa.svalue(t) : wa.serror("Expected value to be acceptable for sending via postMessage")), Qh = (t, r, l, d) => qt(l, d).fold(() => Mo(t, l, d), (y) => y.extract(t.concat(["branch: " + d]), r)), Vf = (t, r) => ({
    extract: (h, y) => qt(y, t).fold(() => Lo(h, t), (E) => Qh(h, y, r, E)),
    toString: () => "chooseOn(" + t + "). Possible values: " + os(r)
  }), Mm = () => jc(_l), Jh = (t) => fa((r) => t(r).fold(wa.serror, wa.svalue)), Hu = (t, r) => Np((l) => wa.fromResult(t(l)), r), Y0 = (t, r, l) => {
    const d = r.extract([t], l);
    return wa.mapError(d, (h) => ({
      input: l,
      errors: h
    }));
  }, ra = (t, r, l) => wa.toResult(Y0(t, r, l)), Gt = (t) => t.fold((r) => {
    throw new Error(zu(r));
  }, lt), El = (t, r, l) => Gt(ra(t, r, l)), zu = (t) => `Errors: 
` + Le(t.errors).join(`
`) + `

Input object: ` + De(t.input), ui = (t, r) => Vf(t, kt(r, xo)), Pp = (t, r) => K0(t, r), Qa = bd, Vs = Vc, bv = (t) => Jh((r) => pn(t, r) ? Ho.value(r) : Ho.error(`Unsupported value: "${r}", choose one of "${t.join(", ")}".`)), Mt = (t) => Qa(t, t, nc(), pu()), Ls = (t, r) => Qa(t, t, nc(), r), yv = (t) => Ls(t, zf), Va = (t) => Ls(t, Tn), Yi = (t, r) => Qa(t, t, nc(), bv(r)), Y2 = (t) => Ls(t, Ec), Tc = (t) => Ls(t, Wb), X2 = (t, r) => Qa(t, t, Nm(), fa((l) => wa.serror("The field: " + t + " is forbidden. " + r))), tf = (t, r) => Qa(t, t, nc(), xo(r)), X0 = (t, r) => Qa(t, t, nc(), jb(r)), Ac = (t, r) => Qa(t, t, nc(), jc(r)), $s = (t) => Qa(t, t, Nm(), pu()), wd = (t, r) => Qa(t, t, Nm(), r), Im = (t) => wd(t, zf), Ua = (t) => wd(t, Tn), Zb = (t, r) => wd(t, bv(r)), Cd = (t) => wd(t, Wb), Vu = (t, r) => wd(t, jc(r)), kr = (t, r) => wd(t, xo(r)), Mp = (t, r) => wd(t, Mi(r)), Xe = (t, r) => Qa(t, t, ef(r), pu()), Wc = (t, r, l) => Qa(t, t, ef(r), l), Ip = (t, r) => Wc(t, r, zf), Ii = (t, r) => Wc(t, r, Tn), gu = (t, r, l) => Wc(t, r, bv(l)), Ea = (t, r) => Wc(t, r, Ec), Ca = (t, r) => Wc(t, r, Wb), D = (t, r) => Wc(t, r, hu), I = (t, r, l) => Wc(t, r, jc(l)), te = (t, r, l) => Wc(t, r, xo(l)), Be = { generate: (t) => {
    if (!Z(t))
      throw new Error("cases must be an array");
    if (t.length === 0)
      throw new Error("there must be at least one case");
    const r = [], l = {};
    return xt(t, (d, h) => {
      const y = os(d);
      if (y.length !== 1)
        throw new Error("one and only one name per case");
      const w = y[0], E = d[w];
      if (l[w] !== void 0)
        throw new Error("duplicate key detected:" + w);
      if (w === "cata")
        throw new Error("cannot have a case named cata (sorry)");
      if (!Z(E))
        throw new Error("case arguments must be an array");
      r.push(w), l[w] = (...O) => {
        const F = O.length;
        if (F !== E.length)
          throw new Error("Wrong number of arguments to case " + w + ". Expected " + E.length + " (" + E + "), got " + F);
        return {
          fold: (...q) => {
            if (q.length !== t.length)
              throw new Error("Wrong number of arguments to fold. Expected " + t.length + ", got " + q.length);
            return q[h].apply(null, O);
          },
          match: (q) => {
            const ne = os(q);
            if (r.length !== ne.length)
              throw new Error("Wrong number of arguments to match. Expected: " + r.join(",") + `
Actual: ` + ne.join(","));
            if (!An(r, (de) => pn(ne, de)))
              throw new Error("Not all branches were specified when using match. Specified: " + ne.join(", ") + `
Required: ` + r.join(", "));
            return q[w].apply(null, O);
          },
          log: (q) => {
            console.log(q, {
              constructors: r,
              constructor: w,
              params: O
            });
          }
        };
      };
    }), l;
  } };
  Be.generate([
    {
      bothErrors: [
        "error1",
        "error2"
      ]
    },
    {
      firstError: [
        "error1",
        "value2"
      ]
    },
    {
      secondError: [
        "value1",
        "error2"
      ]
    },
    {
      bothValues: [
        "value1",
        "value2"
      ]
    }
  ]);
  const Ot = (t) => {
    const r = [], l = [];
    return xt(t, (d) => {
      d.fold((h) => {
        r.push(h);
      }, (h) => {
        l.push(h);
      });
    }), {
      errors: r,
      values: l
    };
  }, rn = (t, r) => {
    const l = {};
    return it(t, (d, h) => {
      pn(r, h) || (l[h] = d);
    }), l;
  }, $n = (t, r) => ({ [t]: r }), No = (t) => {
    const r = {};
    return xt(t, (l) => {
      r[l.key] = l.value;
    }), r;
  }, ts = (t, r) => rn(t, r), nr = (t, r) => $n(t, r), Us = (t) => No(t), Ir = (t, r) => t.length === 0 ? Ho.value(r) : Ho.value(Pr(r, yd.apply(void 0, t))), oc = (t) => Ho.error(tn(t)), Sd = (t, r) => {
    const l = Ot(t);
    return l.errors.length > 0 ? oc(l.errors) : Ir(l.values, r);
  }, ml = (t) => ye(t) ? t : _t, kd = (t, r, l) => {
    let d = t.dom;
    const h = ml(l);
    for (; d.parentNode; ) {
      d = d.parentNode;
      const y = $e.fromDom(d), w = r(y);
      if (w.isSome())
        return w;
      if (h(y))
        break;
    }
    return B.none();
  }, Uf = (t, r, l) => {
    const d = r(t), h = ml(l);
    return d.orThunk(() => h(t) ? B.none() : kd(t, r, h));
  }, Uu = (t, r) => Is(t.element, r.event.target), Fp = {
    can: ot,
    abort: _t,
    run: U
  }, Zc = (t) => {
    if (!Lr(t, "can") && !Lr(t, "abort") && !Lr(t, "run"))
      throw new Error("EventHandler defined by: " + JSON.stringify(t, null, 2) + " does not have can, abort, or run!");
    return {
      ...Fp,
      ...t
    };
  }, xv = (t, r) => (...l) => Pt(t, (d, h) => d && r(h).apply(void 0, l), !0), eg = (t, r) => (...l) => Pt(t, (d, h) => d || r(h).apply(void 0, l), !1), wv = (t) => ye(t) ? {
    can: ot,
    abort: _t,
    run: t
  } : t, Cv = (t) => {
    const r = xv(t, (h) => h.can), l = eg(t, (h) => h.abort);
    return {
      can: r,
      abort: l,
      run: (...h) => {
        xt(t, (y) => {
          y.run.apply(void 0, h);
        });
      }
    };
  }, di = ee, vs = di("touchstart"), Gr = di("touchmove"), Ja = di("touchend"), Oc = di("touchcancel"), sc = di("mousedown"), Sv = di("mousemove"), _d = di("mouseout"), Fm = di("mouseup"), jf = di("mouseover"), nf = di("focusin"), Wf = di("focusout"), Ed = di("keydown"), Gb = di("keyup"), Zf = di("input"), kv = di("change"), tg = di("click"), n_ = di("transitioncancel"), of = di("transitionend"), o_ = di("transitionstart"), Q2 = di("selectstart"), Ta = (t) => ee("alloy." + t), Q0 = { tap: Ta("tap") }, sf = Ta("focus"), Bp = Ta("blur.post"), Bm = Ta("paste.post"), ju = Ta("receive"), Wu = Ta("execute"), qb = Ta("focus.item"), rf = Q0.tap, Tl = Ta("longpress"), Kb = Ta("sandbox.close"), J2 = Ta("typeahead.cancel"), Yb = Ta("system.init"), Xb = Ta("system.touchmove"), ew = Ta("system.touchend"), ng = Ta("system.scroll"), af = Ta("system.resize"), rc = Ta("system.attached"), Zu = Ta("system.detached"), Lp = Ta("system.dismissRequested"), tw = Ta("system.repositionRequested"), og = Ta("focusmanager.shifted"), nw = Ta("slotcontainer.visibility"), s_ = Ta("system.external.element.scroll"), r_ = Ta("change.tab"), a_ = Ta("dismiss.tab"), $p = Ta("highlight"), sg = Ta("dehighlight"), Xo = (t, r) => {
    J0(t, t.element, r, {});
  }, po = (t, r, l) => {
    J0(t, t.element, r, l);
  }, Hp = (t) => {
    Xo(t, Wu());
  }, Qb = (t, r, l) => {
    J0(t, r, l, {});
  }, J0 = (t, r, l, d) => {
    const h = {
      target: r,
      ...d
    };
    t.getSystem().triggerEvent(l, r, h);
  }, ow = (t, r, l, d) => {
    const h = {
      ...d,
      target: r
    };
    t.getSystem().triggerEvent(l, r, h);
  }, Gf = (t, r, l, d) => {
    t.getSystem().triggerEvent(l, r, d.event);
  }, zr = (t) => Us(t), i_ = (t, r) => ({
    key: t,
    value: Zc({ abort: r })
  }), sw = (t, r) => ({
    key: t,
    value: Zc({ can: r })
  }), ey = (t) => ({
    key: t,
    value: Zc({
      run: (r, l) => {
        l.event.prevent();
      }
    })
  }), Ft = (t, r) => ({
    key: t,
    value: Zc({ run: r })
  }), rg = (t, r, l) => ({
    key: t,
    value: Zc({
      run: (d, h) => {
        r.apply(void 0, [
          d,
          h
        ].concat(l));
      }
    })
  }), iO = (t) => (r) => Ft(t, r), zp = (t) => (r) => ({
    key: t,
    value: Zc({
      run: (l, d) => {
        Uu(l, d) && r(l, d);
      }
    })
  }), lO = (t, r) => Ft(t, (l, d) => {
    l.getSystem().getByUid(r).each((h) => {
      Gf(h, h.element, t, d);
    });
  }), ag = (t, r, l) => {
    const d = r.partUids[l];
    return lO(t, d);
  }, rw = (t, r) => Ft(t, (l, d) => {
    const h = d.event, y = l.getSystem().getByDom(h.target).getOrThunk(() => Uf(h.target, (E) => l.getSystem().getByDom(E).toOptional(), _t).getOr(l));
    r(l, y, d);
  }), lf = (t) => Ft(t, (r, l) => {
    l.cut();
  }), aw = (t) => Ft(t, (r, l) => {
    l.stop();
  }), _v = (t, r) => zp(t)(r), qr = zp(rc()), qf = zp(Zu()), l_ = zp(Yb()), Td = iO(Wu()), iw = (t, r, l) => {
    const d = l.toString(), h = d.indexOf(")") + 1, y = d.indexOf("("), w = d.substring(y + 1, h - 1).split(/,\s*/);
    return t.toFunctionAnnotation = () => ({
      name: r,
      parameters: Jb(w.slice(0, 1).concat(w.slice(3)))
    }), t;
  }, Jb = (t) => et(t, (r) => Yr(r, "/*") ? r.substring(0, r.length - 2) : r), Ev = (t, r) => {
    const l = t.toString(), d = l.indexOf(")") + 1, h = l.indexOf("("), y = l.substring(h + 1, d - 1).split(/,\s*/);
    return t.toFunctionAnnotation = () => ({
      name: r,
      parameters: Jb(y)
    }), t;
  }, e1 = (t, r) => {
    const l = r.toString(), d = l.indexOf(")") + 1, h = l.indexOf("("), y = l.substring(h + 1, d - 1).split(/,\s*/);
    return t.toFunctionAnnotation = () => ({
      name: "OVERRIDE",
      parameters: Jb(y.slice(1))
    }), t;
  }, Gc = (t) => ({
    classes: pe(t.classes) ? [] : t.classes,
    attributes: pe(t.attributes) ? {} : t.attributes,
    styles: pe(t.styles) ? {} : t.styles
  }), c_ = (t, r) => ({
    ...t,
    attributes: {
      ...t.attributes,
      ...r.attributes
    },
    styles: {
      ...t.styles,
      ...r.styles
    },
    classes: t.classes.concat(r.classes)
  }), t1 = (t, r, l) => Td((d) => {
    l(d, t, r);
  }), lw = (t, r, l) => l_((d, h) => {
    l(d, t, r);
  }), Vp = (t, r, l, d, h, y) => {
    const w = Mi(t), E = kr(r, [Mp("config", t)]);
    return d_(w, E, r, l, d, h, y);
  }, cw = (t, r, l, d, h, y) => {
    const w = t, E = kr(r, [wd("config", t)]);
    return d_(w, E, r, l, d, h, y);
  }, u_ = (t, r, l) => iw((h, ...y) => {
    const w = [h].concat(y);
    return h.config({ name: ee(t) }).fold(() => {
      throw new Error("We could not find any behaviour configuration for: " + t + ". Using API: " + l);
    }, (E) => {
      const O = Array.prototype.slice.call(w, 1);
      return r.apply(void 0, [
        h,
        E.config,
        E.state
      ].concat(O));
    });
  }, l, r), uw = (t) => ({
    key: t,
    value: void 0
  }), d_ = (t, r, l, d, h, y, w) => {
    const E = (q) => Lr(q, l) ? q[l]() : B.none(), O = kt(h, (q, ne) => u_(l, q, ne)), L = {
      ...kt(y, (q, ne) => Ev(q, ne)),
      ...O,
      revoke: Vt(uw, l),
      config: (q) => {
        const ne = El(l + "-config", t, q);
        return {
          key: l,
          value: {
            config: ne,
            me: L,
            configAsRaw: Te(() => El(l + "-config", t, q)),
            initialConfig: q,
            state: w
          }
        };
      },
      schema: ee(r),
      exhibit: (q, ne) => xa(E(q), qt(d, "exhibit"), (ae, de) => de(ne, ae.config, ae.state)).getOrThunk(() => Gc({})),
      name: ee(l),
      handlers: (q) => E(q).map((ne) => qt(d, "events").getOr(() => ({}))(ne.config, ne.state)).getOr({})
    };
    return L;
  }, Hl = { init: () => qc({ readState: ee("No State required") }) }, qc = (t) => t, Jt = (t) => Us(t), ty = Mi([
    Mt("fields"),
    Mt("name"),
    Xe("active", {}),
    Xe("apis", {}),
    Xe("state", Hl),
    Xe("extra", {})
  ]), Xi = (t) => {
    const r = El("Creating behaviour: " + t.name, ty, t);
    return Vp(r.fields, r.name, r.active, r.apis, r.extra, r.state);
  }, ny = Mi([
    Mt("branchKey"),
    Mt("branches"),
    Mt("name"),
    Xe("active", {}),
    Xe("apis", {}),
    Xe("state", Hl),
    Xe("extra", {})
  ]), f_ = (t) => {
    const r = El("Creating behaviour: " + t.name, ny, t);
    return cw(ui(r.branchKey, r.branches), r.name, r.active, r.apis, r.extra, r.state);
  }, Kr = ee(void 0), Lm = (t, r) => {
    const l = tr(t, r);
    return l === void 0 || l === "" ? [] : l.split(" ");
  }, oy = (t, r, l) => {
    const h = Lm(t, r).concat([l]);
    return sn(t, r, h.join(" ")), !0;
  }, cO = (t, r, l) => {
    const d = So(Lm(t, r), (h) => h !== l);
    return d.length > 0 ? sn(t, r, d.join(" ")) : Ee(t, r), !1;
  }, $m = (t) => t.dom.classList !== void 0, sy = (t) => Lm(t, "class"), cf = (t, r) => oy(t, "class", r), m_ = (t, r) => cO(t, "class", r), dw = (t, r) => pn(sy(t), r) ? m_(t, r) : cf(t, r), Vr = (t, r) => {
    $m(t) ? t.dom.classList.add(r) : cf(t, r);
  }, Tv = (t) => {
    ($m(t) ? t.dom.classList : sy(t)).length === 0 && Ee(t, "class");
  }, ba = (t, r) => {
    $m(t) ? t.dom.classList.remove(r) : m_(t, r), Tv(t);
  }, p_ = (t, r) => {
    const l = $m(t) ? t.dom.classList.toggle(r) : dw(t, r);
    return Tv(t), l;
  }, Kc = (t, r) => $m(t) && t.dom.classList.contains(r), Av = (t, r) => {
    xt(r, (l) => {
      Vr(t, l);
    });
  }, Yc = (t, r) => {
    xt(r, (l) => {
      ba(t, l);
    });
  }, uO = (t, r) => {
    xt(r, (l) => {
      p_(t, l);
    });
  }, dO = (t, r) => An(r, (l) => Kc(t, l)), fO = (t) => {
    const r = t.dom.classList, l = new Array(r.length);
    for (let d = 0; d < r.length; d++) {
      const h = r.item(d);
      h !== null && (l[d] = h);
    }
    return l;
  }, mO = (t) => $m(t) ? fO(t) : sy(t), Fi = (t, r, l, d, h) => {
    const y = (w) => w + "px";
    return {
      position: t,
      left: r.map(y),
      top: l.map(y),
      right: d.map(y),
      bottom: h.map(y)
    };
  }, ac = (t) => ({
    ...t,
    position: B.some(t.position)
  }), n1 = (t, r) => {
    Kt(t, ac(r));
  }, Up = (t) => (ha(Cr(t, "position"), "fixed") ? B.none() : vi(t)).orThunk(() => {
    const d = $e.fromTag("span");
    return Za(t).bind((h) => {
      qi(h, d);
      const y = vi(d);
      return _c(d), y;
    });
  }), fw = (t) => Up(t).map(Ga).getOrThunk(() => $r(0, 0)), Ov = (t, r) => {
    const l = t.element;
    Vr(l, r.transitionClass), ba(l, r.fadeOutClass), Vr(l, r.fadeInClass), r.onShow(t);
  }, Kf = (t, r) => {
    const l = t.element;
    Vr(l, r.transitionClass), ba(l, r.fadeInClass), Vr(l, r.fadeOutClass), r.onHide(t);
  }, Dv = (t, r) => t.y < r.bottom && t.bottom > r.y, ig = (t, r) => t.y >= r.y, jp = (t, r) => t.bottom <= r.bottom, Yf = (t, r, l) => ({
    location: "top",
    leftX: r,
    topY: l.bounds.y - t.y
  }), lg = (t, r, l) => ({
    location: "bottom",
    leftX: r,
    bottomY: t.bottom - l.bounds.bottom
  }), cg = (t) => t.box.x - t.win.x, pO = (t, r, l) => {
    const d = r.win, h = r.box, y = cg(r);
    return Qo(t, (w) => {
      switch (w) {
        case "bottom":
          return jp(h, l.bounds) ? B.none() : B.some(lg(d, y, l));
        case "top":
          return ig(h, l.bounds) ? B.none() : B.some(Yf(d, y, l));
        default:
          return B.none();
      }
    }).getOr({ location: "no-dock" });
  }, mw = (t, r, l) => An(t, (d) => {
    switch (d) {
      case "bottom":
        return jp(r, l.bounds);
      case "top":
        return ig(r, l.bounds);
    }
  }), ry = (t, r) => {
    const l = r.optScrollEnv.fold(ee(t.bounds.y), (d) => d.scrollElmTop + (t.bounds.y - d.currentScrollTop));
    return $r(t.bounds.x, l);
  }, h_ = (t, r) => {
    const l = r.optScrollEnv.fold(ee(t.y), (d) => t.y + d.currentScrollTop - d.scrollElmTop);
    return $r(t.x, l);
  }, pw = (t, r, l) => l.getInitialPos().map((d) => {
    const h = ry(d, r);
    return {
      box: Nr(h.left, h.top, Ri(t), Mr(t)),
      location: d.location
    };
  }), ay = (t, r, l, d, h) => {
    const y = h_(r, l), w = Nr(y.left, y.top, r.width, r.height);
    d.setInitialPos({
      style: ga(t),
      position: lr(t, "position") || "static",
      bounds: w,
      location: h.location
    });
  }, hw = (t, r, l, d, h) => {
    d.getInitialPos().fold(() => ay(t, r, l, d, h), () => U);
  }, iy = (t, r, l) => l.getInitialPos().bind((d) => {
    var h;
    switch (l.clearInitialPos(), d.position) {
      case "static":
        return B.some({ morph: "static" });
      case "absolute":
        const y = Up(t).getOr(Uo()), w = sa(y), E = (h = y.dom.scrollTop) !== null && h !== void 0 ? h : 0;
        return B.some({
          morph: "absolute",
          positionCss: Fi("absolute", qt(d.style, "left").map((O) => r.x - w.x), qt(d.style, "top").map((O) => r.y - w.y + E), qt(d.style, "right").map((O) => w.right - r.right), qt(d.style, "bottom").map((O) => w.bottom - r.bottom))
        });
      default:
        return B.none();
    }
  }), Rv = (t, r, l) => pw(t, r, l).filter(({ box: d }) => mw(l.getModes(), d, r)).bind(({ box: d }) => iy(t, d, l)), ly = (t) => {
    switch (t.location) {
      case "top":
        return B.some({
          morph: "fixed",
          positionCss: Fi("fixed", B.some(t.leftX), B.some(t.topY), B.none(), B.none())
        });
      case "bottom":
        return B.some({
          morph: "fixed",
          positionCss: Fi("fixed", B.some(t.leftX), B.none(), B.none(), B.some(t.bottomY))
        });
      default:
        return B.none();
    }
  }, jI = (t, r, l) => {
    const d = sa(t), h = Na(), y = pO(l.getModes(), {
      win: h,
      box: d
    }, r);
    return y.location === "top" || y.location === "bottom" ? (ay(t, d, r, l, y), ly(y)) : B.none();
  }, hO = (t, r, l) => Rv(t, r, l).orThunk(() => r.optScrollEnv.bind((d) => pw(t, r, l)).bind(({ box: d, location: h }) => {
    const y = Na(), w = cg({
      win: y,
      box: d
    }), E = h === "top" ? Yf(y, w, r) : lg(y, w, r);
    return ly(E);
  })), uf = (t, r, l) => {
    const d = t.element;
    return ha(Cr(d, "position"), "fixed") ? hO(d, r, l) : jI(d, r, l);
  }, Nv = (t, r, l) => {
    const d = t.element;
    return pw(d, r, l).bind(({ box: h }) => iy(d, h, l));
  }, g_ = (t, r, l, d) => {
    const h = sa(t), y = Na(), w = cg({
      win: y,
      box: h
    }), E = d(y, w, r);
    return E.location === "bottom" || E.location === "top" ? (hw(t, h, r, l, E), ly(E)) : B.none();
  }, v_ = (t, r, l) => {
    l.setDocked(!1), xt([
      "left",
      "right",
      "top",
      "bottom",
      "position"
    ], (d) => gs(t.element, d)), r.onUndocked(t);
  }, cy = (t, r, l, d) => {
    const h = d.position === "fixed";
    l.setDocked(h), n1(t.element, d), (h ? r.onDocked : r.onUndocked)(t);
  }, Wp = (t, r, l, d, h = !1) => {
    r.contextual.each((y) => {
      y.lazyContext(t).each((w) => {
        const E = Dv(w, d.bounds);
        E !== l.isVisible() && (l.setVisible(E), h && !E ? (Av(t.element, [y.fadeOutClass]), y.onHide(t)) : (E ? Ov : Kf)(t, y));
      });
    });
  }, gO = (t, r, l, d, h) => {
    Wp(t, r, l, d, !0), cy(t, r, l, h.positionCss);
  }, gw = (t, r, l, d, h) => {
    switch (h.morph) {
      case "static":
        return v_(t, r, l);
      case "absolute":
        return cy(t, r, l, h.positionCss);
      case "fixed":
        return gO(t, r, l, d, h);
    }
  }, o1 = (t, r, l) => {
    const d = r.lazyViewport(t);
    Wp(t, r, l, d), uf(t, d, l).each((h) => {
      gw(t, r, l, d, h);
    });
  }, vO = (t, r, l) => {
    const d = t.element;
    l.setDocked(!1);
    const h = r.lazyViewport(t);
    Nv(t, h, l).each((y) => {
      switch (y.morph) {
        case "static": {
          v_(t, r, l);
          break;
        }
        case "absolute": {
          cy(t, r, l, y.positionCss);
          break;
        }
      }
    }), l.setVisible(!0), r.contextual.each((y) => {
      Yc(d, [
        y.fadeInClass,
        y.fadeOutClass,
        y.transitionClass
      ]), y.onShow(t);
    }), uy(t, r, l);
  }, uy = (t, r, l) => {
    t.getSystem().isConnected() && o1(t, r, l);
  }, Pv = (t, r, l) => {
    l.isDocked() && vO(t, r, l);
  }, b_ = (t) => (r, l, d) => {
    const h = l.lazyViewport(r);
    g_(r.element, h, d, t).each((w) => {
      gO(r, l, d, h, w);
    });
  }, dy = b_(Yf), vw = b_(lg);
  var bw = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    refresh: uy,
    reset: Pv,
    isDocked: (t, r, l) => l.isDocked(),
    getModes: (t, r, l) => l.getModes(),
    setModes: (t, r, l, d) => l.setModes(d),
    forceDockToTop: dy,
    forceDockToBottom: vw
  }), x_ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, r) => zr([
      _v(of(), (l, d) => {
        t.contextual.each((h) => {
          Kc(l.element, h.transitionClass) && (Yc(l.element, [
            h.transitionClass,
            h.fadeInClass
          ]), (r.isVisible() ? h.onShown : h.onHidden)(l)), d.stop();
        });
      }),
      Ft(ng(), (l, d) => {
        uy(l, t, r);
      }),
      Ft(s_(), (l, d) => {
        uy(l, t, r);
      }),
      Ft(af(), (l, d) => {
        Pv(l, t, r);
      })
    ])
  });
  const df = (t, r) => {
    const d = (r || document).createElement("div");
    return d.innerHTML = t, La($e.fromDom(d));
  }, Dc = (t) => t.dom.innerHTML, Iv = (t, r) => {
    const d = li(t).dom, h = $e.fromDom(d.createDocumentFragment()), y = df(r, d);
    vd(h, y), Lf(t), qi(t, h);
  }, Fv = (t) => {
    const r = $e.fromTag("div"), l = $e.fromDom(t.dom.cloneNode(!0));
    return qi(r, l), Dc(r);
  }, r1 = (t, r) => $e.fromDom(t.dom.cloneNode(r)), bO = (t) => r1(t, !1), yO = (t) => r1(t, !0), ug = (t) => {
    if (du(t))
      return "#shadow-root";
    {
      const r = bO(t);
      return Fv(r);
    }
  }, Xc = (t) => ug(t), w_ = "unknown";
  var Ma;
  (function(t) {
    t[t.STOP = 0] = "STOP", t[t.NORMAL = 1] = "NORMAL", t[t.LOGGING = 2] = "LOGGING";
  })(Ma || (Ma = {}));
  const dg = to({}), Qc = (t, r) => {
    const l = [], d = (/* @__PURE__ */ new Date()).getTime();
    return {
      logEventCut: (h, y, w) => {
        l.push({
          outcome: "cut",
          target: y,
          purpose: w
        });
      },
      logEventStopped: (h, y, w) => {
        l.push({
          outcome: "stopped",
          target: y,
          purpose: w
        });
      },
      logNoParent: (h, y, w) => {
        l.push({
          outcome: "no-parent",
          target: y,
          purpose: w
        });
      },
      logEventNoHandlers: (h, y) => {
        l.push({
          outcome: "no-handlers-left",
          target: y
        });
      },
      logEventResponse: (h, y, w) => {
        l.push({
          outcome: "response",
          purpose: w,
          target: y
        });
      },
      write: () => {
        const h = (/* @__PURE__ */ new Date()).getTime();
        pn([
          "mousemove",
          "mouseover",
          "mouseout",
          Yb()
        ], t) || console.log(t, {
          event: t,
          time: h - d,
          target: r.dom,
          sequence: et(l, (y) => pn([
            "cut",
            "stopped",
            "response"
          ], y.outcome) ? "{" + y.purpose + "} " + y.outcome + " at (" + Xc(y.target) + ")" : y.outcome)
        });
      }
    };
  }, WI = (t, r, l) => {
    switch (qt(dg.get(), t).orThunk(() => {
      const h = os(dg.get());
      return Qo(h, (y) => t.indexOf(y) > -1 ? B.some(dg.get()[y]) : B.none());
    }).getOr(Ma.NORMAL)) {
      case Ma.NORMAL:
        return l(Jc());
      case Ma.LOGGING: {
        const h = Qc(t, r), y = l(h);
        return h.write(), y;
      }
      case Ma.STOP:
        return !0;
    }
  }, fy = [
    "alloy/data/Fields",
    "alloy/debugging/Debugging"
  ], Bv = () => {
    const t = new Error();
    if (t.stack !== void 0) {
      const r = t.stack.split(`
`);
      return Nt(r, (l) => l.indexOf("alloy") > 0 && !Ro(fy, (d) => l.indexOf(d) > -1)).getOr(w_);
    } else
      return w_;
  }, fg = {
    logEventCut: U,
    logEventStopped: U,
    logNoParent: U,
    logEventNoHandlers: U,
    logEventResponse: U,
    write: U
  }, ff = (t, r, l) => WI(t, r, l), Jc = ee(fg), yw = ee([
    Mt("menu"),
    Mt("selectedMenu")
  ]), xw = ee([
    Mt("item"),
    Mt("selectedItem")
  ]);
  ee(xo(xw().concat(yw())));
  const ww = ee(xo(xw())), mg = tf("initSize", [
    Mt("numColumns"),
    Mt("numRows")
  ]), xO = () => Ls("markers", ww()), pg = () => tf("markers", [Mt("backgroundMenu")].concat(yw()).concat(xw())), Xf = (t) => tf("markers", et(t, Mt)), a1 = (t, r, l) => (Bv(), Qa(r, r, l, Jh((d) => Ho.value((...h) => d.apply(void 0, h))))), Os = (t) => a1("onHandler", t, ef(U)), ic = (t) => a1("onKeyboardHandler", t, ef(B.none)), Gu = (t) => a1("onHandler", t, nc()), Hm = (t) => a1("onKeyboardHandler", t, nc()), Ur = (t, r) => Vs(t, ee(r)), C_ = (t) => Vs(t, lt), my = ee(mg);
  var i1 = [
    kr("contextual", [
      Va("fadeInClass"),
      Va("fadeOutClass"),
      Va("transitionClass"),
      Tc("lazyContext"),
      Os("onShow"),
      Os("onShown"),
      Os("onHide"),
      Os("onHidden")
    ]),
    Ca("lazyViewport", () => ({
      bounds: Na(),
      optScrollEnv: B.none()
    })),
    I("modes", [
      "top",
      "bottom"
    ], Tn),
    Os("onDocked"),
    Os("onUndocked")
  ], wO = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: (t) => {
      const r = to(!1), l = to(!0), d = cr(), h = to(t.modes), y = () => `docked:  ${r.get()}, visible: ${l.get()}, modes: ${h.get().join(",")}`;
      return qc({
        isDocked: r.get,
        setDocked: r.set,
        getInitialPos: d.get,
        setInitialPos: d.set,
        clearInitialPos: d.clear,
        isVisible: l.get,
        setVisible: l.set,
        getModes: h.get,
        setModes: h.set,
        readState: y
      });
    }
  });
  const ma = Xi({
    fields: i1,
    name: "docking",
    active: x_,
    apis: bw,
    state: wO
  }), Cw = (t, r, l) => Is(r, t.element) && !Is(r, l), CO = zr([sw(sf(), (t, r) => {
    const l = r.event, d = l.originator, h = l.target;
    return Cw(t, d, h) ? (console.warn(sf() + ` did not get interpreted by the desired target. 
Originator: ` + Xc(d) + `
Target: ` + Xc(h) + `
Check the ` + sf() + " event handlers"), !1) : !0;
  })]);
  var SO = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: CO
  });
  let Lv = 0;
  const Mn = (t) => {
    const l = (/* @__PURE__ */ new Date()).getTime(), d = Math.floor(Math.random() * 1e9);
    return Lv++, t + "_" + d + Lv + String(l);
  }, kO = ee("alloy-id-"), S_ = ee("data-alloy-id"), hy = kO(), Sw = S_(), _O = (t, r) => {
    const l = Mn(hy + t);
    return l1(r, l), l;
  }, l1 = (t, r) => {
    Object.defineProperty(t.dom, Sw, {
      value: r,
      writable: !0
    });
  }, c1 = (t) => {
    const r = ko(t) ? t.dom[Sw] : null;
    return B.from(r);
  }, hg = (t) => Mn(t), ZI = lt, Qf = (t) => {
    const r = (h) => `The component must be in a context to execute: ${h}` + (t ? `
` + Xc(t().element) + " is not in context." : ""), l = (h) => () => {
      throw new Error(r(h));
    }, d = (h) => () => {
      console.warn(r(h));
    };
    return {
      debugInfo: ee("fake"),
      triggerEvent: d("triggerEvent"),
      triggerFocus: d("triggerFocus"),
      triggerEscape: d("triggerEscape"),
      broadcast: d("broadcast"),
      broadcastOn: d("broadcastOn"),
      broadcastEvent: d("broadcastEvent"),
      build: l("build"),
      buildOrPatch: l("buildOrPatch"),
      addToWorld: l("addToWorld"),
      removeFromWorld: l("removeFromWorld"),
      addToGui: l("addToGui"),
      removeFromGui: l("removeFromGui"),
      getByUid: l("getByUid"),
      getByDom: l("getByDom"),
      isConnected: _t
    };
  }, EO = Qf(), zm = Mn("alloy-premade"), k_ = (t) => (Object.defineProperty(t.element.dom, zm, {
    value: t.uid,
    writable: !0
  }), nr(zm, t)), mf = (t) => Ko(t.dom, zm), __ = (t) => qt(t, zm), $v = (t) => e1((r, ...l) => t(r.getApis(), r, ...l), t), TO = (t, r) => {
    const l = et(r, (h) => kr(h.name(), [
      Mt("config"),
      Xe("state", Hl)
    ])), d = ra("component.behaviours", xo(l), t.behaviours).fold((h) => {
      throw new Error(zu(h) + `
Complete spec:
` + JSON.stringify(t, null, 2));
    }, lt);
    return {
      list: r,
      data: kt(d, (h) => {
        const y = h.map((w) => ({
          config: w.config,
          state: w.state.init(w.config)
        }));
        return ee(y);
      })
    };
  }, AO = (t) => t.list, OO = (t) => t.data, kw = (t, r) => {
    const l = {};
    return it(t, (d, h) => {
      it(d, (y, w) => {
        const E = qt(l, w).getOr([]);
        l[w] = E.concat([r(h, y)]);
      });
    }), l;
  }, gy = (t, r, l, d) => {
    const h = { ...r };
    xt(l, (L) => {
      h[L.name()] = L.exhibit(t, d);
    });
    const y = kw(h, (L, q) => ({
      name: L,
      modification: q
    })), w = (L) => At(L, (q, ne) => ({
      ...ne.modification,
      ...q
    }), {}), E = At(y.classes, (L, q) => q.modification.concat(L), []), O = w(y.attributes), F = w(y.styles);
    return Gc({
      classes: E,
      attributes: O,
      styles: F
    });
  }, E_ = (t, r, l, d) => {
    try {
      const h = oo(l, (y, w) => {
        const E = y[r], O = w[r], F = d.indexOf(E), L = d.indexOf(O);
        if (F === -1)
          throw new Error("The ordering for " + t + " does not have an entry for " + E + `.
Order specified: ` + JSON.stringify(d, null, 2));
        if (L === -1)
          throw new Error("The ordering for " + t + " does not have an entry for " + O + `.
Order specified: ` + JSON.stringify(d, null, 2));
        return F < L ? -1 : L < F ? 1 : 0;
      });
      return Ho.value(h);
    } catch (h) {
      return Ho.error([h]);
    }
  }, _w = (t, r) => ({
    handler: t,
    purpose: r
  }), DO = (t, r) => ({
    cHandler: t,
    purpose: r
  }), u1 = (t, r) => DO(Vt.apply(void 0, [t.handler].concat(r)), t.purpose), Zp = (t) => t.cHandler, Hv = (t, r) => ({
    name: t,
    handler: r
  }), vy = (t, r) => {
    const l = {};
    return xt(t, (d) => {
      l[d.name()] = d.handlers(r);
    }), l;
  }, Ew = (t, r, l) => {
    const d = {
      ...l,
      ...vy(r, t)
    };
    return kw(d, Hv);
  }, by = (t, r, l, d) => {
    const h = Ew(t, l, d);
    return T_(h, r);
  }, Tw = (t) => {
    const r = wv(t);
    return (l, d, ...h) => {
      const y = [
        l,
        d
      ].concat(h);
      r.abort.apply(void 0, y) ? d.stop() : r.can.apply(void 0, y) && r.run.apply(void 0, y);
    };
  }, Aw = (t, r) => Ho.error(["The event (" + t + `) has more than one behaviour that listens to it.
When this occurs, you must specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).
The behaviours that can trigger it are: ` + JSON.stringify(et(r, (l) => l.name), null, 2)]), Ow = (t, r, l) => {
    const d = r[l];
    return d ? E_("Event: " + l, "name", t, d).map((h) => {
      const y = et(h, (w) => w.handler);
      return Cv(y);
    }) : Aw(l, t);
  }, T_ = (t, r) => {
    const l = ta(t, (d, h) => (d.length === 1 ? Ho.value(d[0].handler) : Ow(d, r, h)).map((w) => {
      const E = Tw(w), O = d.length > 1 ? So(r[h], (F) => Ro(d, (L) => L.name === F)).join(" > ") : d[0].name;
      return nr(h, _w(E, O));
    }));
    return Sd(l, {});
  }, Qi = "alloy.base.behaviour", RO = xo([
    Qa("dom", "dom", nc(), xo([
      Mt("tag"),
      Xe("styles", {}),
      Xe("classes", []),
      Xe("attributes", {}),
      $s("value"),
      $s("innerHtml")
    ])),
    Mt("components"),
    Mt("uid"),
    Xe("events", {}),
    Xe("apis", {}),
    Qa("eventOrder", "eventOrder", pv({
      [Wu()]: [
        "disabling",
        Qi,
        "toggling",
        "typeaheadevents"
      ],
      [sf()]: [
        Qi,
        "focusing",
        "keying"
      ],
      [Yb()]: [
        Qi,
        "disabling",
        "toggling",
        "representing"
      ],
      [Zf()]: [
        Qi,
        "representing",
        "streaming",
        "invalidating"
      ],
      [Zu()]: [
        Qi,
        "representing",
        "item-events",
        "toolbar-button-events",
        "tooltipping"
      ],
      [sc()]: [
        "focusing",
        Qi,
        "item-type-events"
      ],
      [vs()]: [
        "focusing",
        Qi,
        "item-type-events"
      ],
      [jf()]: [
        "item-type-events",
        "tooltipping"
      ],
      [ju()]: [
        "receiving",
        "reflecting",
        "tooltipping"
      ]
    }), pu()),
    $s("domModification")
  ]), A_ = (t) => ra("custom.definition", RO, t), Gp = (t) => ({
    ...t.dom,
    uid: t.uid,
    domChildren: et(t.components, (r) => r.element)
  }), gg = (t) => t.domModification.fold(() => Gc({}), Gc), Dw = (t) => t.events, gt = (t) => t.dom.value, Jf = (t, r) => {
    if (r === void 0)
      throw new Error("Value.set was undefined");
    t.dom.value = r;
  }, NO = (t, r, l) => Wi(t, r).map((h) => {
    if (l.exists((w) => !Is(w, h))) {
      const w = l.map(Gs).getOr("span"), E = $e.fromTag(w);
      return Jl(h, E), E;
    } else
      return h;
  }), O_ = (t, r, l) => {
    l.fold(() => qi(t, r), (d) => {
      Is(d, r) || (Jl(d, r), _c(d));
    });
  }, d1 = (t, r, l) => {
    const d = et(r, l), h = La(t);
    return xt(h.slice(d.length), _c), d;
  }, qu = (t, r, l, d) => {
    const h = Wi(t, r), y = d(l, h), w = NO(t, r, h);
    return O_(t, y.element, w), y;
  }, f1 = (t, r, l) => d1(t, r, (d, h) => qu(t, h, d, l)), D_ = (t, r) => d1(t, r, (l, d) => {
    const h = Wi(t, d);
    return O_(t, l, h), l;
  }), Rw = (t, r) => {
    const l = os(t), d = os(r), h = on(d, l), y = Ss(t, (w, E) => !Ko(r, E) || w !== r[E]).t;
    return {
      toRemove: h,
      toSet: y
    };
  }, zl = (t, r) => {
    const {
      class: l,
      style: d,
      ...h
    } = dt(r), {
      toSet: y,
      toRemove: w
    } = Rw(t.attributes, h), E = () => {
      xt(w, (qe) => Ee(r, qe)), md(r, y);
    }, O = ga(r), {
      toSet: F,
      toRemove: L
    } = Rw(t.styles, O), q = () => {
      xt(L, (qe) => gs(r, qe)), Or(r, F);
    }, ne = mO(r), ae = on(ne, t.classes), de = on(t.classes, ne), _e = () => {
      Av(r, de), Yc(r, ae);
    }, st = (qe) => {
      Iv(r, qe);
    }, Re = () => {
      const qe = t.domChildren;
      D_(r, qe);
    }, Qe = () => {
      const qe = r, Bt = t.value.getOrUndefined();
      Bt !== gt(qe) && Jf(qe, Bt ?? "");
    };
    return E(), _e(), q(), t.innerHtml.fold(Re, st), Qe(), r;
  }, yy = (t) => {
    const r = $e.fromTag(t.tag);
    md(r, t.attributes), Av(r, t.classes), Or(r, t.styles), t.innerHtml.each((d) => Iv(r, d));
    const l = t.domChildren;
    return vd(r, l), t.value.each((d) => {
      Jf(r, d);
    }), r;
  }, R_ = (t, r) => {
    try {
      const l = zl(t, r);
      return B.some(l);
    } catch {
      return B.none();
    }
  }, PO = (t) => t.innerHtml.isSome() && t.domChildren.length > 0, N_ = (t, r) => {
    const l = (h) => Gs(h) === t.tag && !PO(t) && !mf(h), d = r.filter(l).bind((h) => R_(t, h)).getOrThunk(() => yy(t));
    return l1(d, t.uid), d;
  }, MO = (t) => {
    const r = qt(t, "behaviours").getOr({});
    return je(os(r), (l) => {
      const d = r[l];
      return be(d) ? [d.me] : [];
    });
  }, P_ = (t, r) => TO(t, r), IO = (t) => {
    const r = MO(t);
    return P_(t, r);
  }, FO = (t, r, l) => {
    const d = Gp(t), h = gg(t), y = { "alloy.base.modification": h }, w = r.length > 0 ? gy(l, y, r, d) : h;
    return c_(d, w);
  }, M_ = (t, r, l) => {
    const d = { "alloy.base.behaviour": Dw(t) };
    return by(l, t.eventOrder, r, d).getOrDie();
  }, zv = (t, r) => {
    const l = () => qe, d = to(EO), h = Gt(A_(t)), y = IO(t), w = AO(y), E = OO(y), O = FO(h, w, E), F = N_(O, r), L = M_(h, w, E), q = to(h.components), ne = (Bt) => {
      d.set(Bt);
    }, ae = () => {
      d.set(Qf(l));
    }, de = () => {
      const Bt = La(F), pt = je(Bt, (en) => d.get().getByDom(en).fold(() => [], vt));
      q.set(pt);
    }, _e = (Bt) => {
      const pt = E;
      return (ye(pt[Bt.name()]) ? pt[Bt.name()] : () => {
        throw new Error("Could not find " + Bt.name() + " in " + JSON.stringify(t, null, 2));
      })();
    }, st = (Bt) => ye(E[Bt.name()]), Re = () => h.apis, Qe = (Bt) => E[Bt]().map((pt) => pt.state.readState()).getOr("not enabled"), qe = {
      uid: t.uid,
      getSystem: d.get,
      config: _e,
      hasConfigured: st,
      spec: t,
      readState: Qe,
      getApis: Re,
      connect: ne,
      disconnect: ae,
      element: F,
      syncComponents: de,
      components: q.get,
      events: L
    };
    return qe;
  }, BO = (t, r) => {
    const l = qt(t, "components").getOr([]);
    return r.fold(() => et(l, Ol), (d) => et(l, (h, y) => wy(h, Wi(d, y))));
  }, I_ = (t, r) => {
    const {
      events: l,
      ...d
    } = ZI(t), h = BO(d, r), y = {
      ...d,
      events: {
        ...SO,
        ...l
      },
      components: h
    };
    return Ho.value(zv(y, r));
  }, Aa = (t) => {
    const r = $e.fromText(t);
    return xy({ element: r });
  }, xy = (t) => {
    const r = El("external.component", Mi([
      Mt("element"),
      $s("uid")
    ]), t), l = to(Qf()), d = (E) => {
      l.set(E);
    }, h = () => {
      l.set(Qf(() => w));
    }, y = r.uid.getOrThunk(() => hg("external"));
    l1(r.element, y);
    const w = {
      uid: y,
      getSystem: l.get,
      config: B.none,
      hasConfigured: _t,
      connect: d,
      disconnect: h,
      getApis: () => ({}),
      element: r.element,
      spec: t,
      readState: ee("No state"),
      syncComponents: U,
      components: ee([]),
      events: {}
    };
    return k_(w);
  }, F_ = hg, B_ = (t) => Ko(t, "uid"), wy = (t, r) => __(t).getOrThunk(() => {
    const l = B_(t) ? t : {
      uid: F_(""),
      ...t
    };
    return I_(l, r).getOrDie();
  }), Ol = (t) => wy(t, B.none()), Vl = k_;
  var L_ = (t, r, l, d, h) => t(l, d) ? B.some(l) : ye(h) && h(l) ? B.none() : r(l, d, h);
  const $_ = (t, r, l) => {
    let d = t.dom;
    const h = ye(l) ? l : _t;
    for (; d.parentNode; ) {
      d = d.parentNode;
      const y = $e.fromDom(d);
      if (r(y))
        return B.some(y);
      if (h(y))
        break;
    }
    return B.none();
  }, Nw = (t, r, l) => L_((h, y) => y(h), $_, t, r, l), H_ = (t, r) => {
    const l = t.dom;
    return l.parentNode ? z_($e.fromDom(l.parentNode), (d) => !Is(t, d) && r(d)) : B.none();
  }, z_ = (t, r) => {
    const l = (h) => r($e.fromDom(h));
    return Nt(t.dom.childNodes, l).map($e.fromDom);
  }, Pw = (t, r) => {
    const l = (d) => {
      for (let h = 0; h < d.childNodes.length; h++) {
        const y = $e.fromDom(d.childNodes[h]);
        if (r(y))
          return B.some(y);
        const w = l(d.childNodes[h]);
        if (w.isSome())
          return w;
      }
      return B.none();
    };
    return l(t.dom);
  }, Mw = (t, r, l) => Nw(t, r, l).isSome(), Cy = (t) => xc(t), Vm = (t, r, l) => $_(t, (d) => gr(d, r), l), lc = (t, r) => H_(t, (l) => gr(l, r)), Iw = (t, r) => z_(t, (l) => gr(l, r)), or = (t, r) => xc(r, t), pf = (t, r, l) => L_((h, y) => gr(h, y), Vm, t, r, l), m1 = "aria-controls", V_ = (t) => Nw(t, (l) => {
    if (!ko(l))
      return !1;
    const d = tr(l, "id");
    return d !== void 0 && d.indexOf(m1) > -1;
  }).bind((l) => {
    const d = tr(l, "id"), h = ie(l);
    return or(h, `[${m1}="${d}"]`);
  }), Sy = () => {
    const t = Mn(m1);
    return {
      id: t,
      link: (d) => {
        sn(d, m1, t);
      },
      unlink: (d) => {
        Ee(d, m1);
      }
    };
  }, ky = (t, r) => V_(r).exists((l) => qp(t, l)), qp = (t, r) => Mw(r, (l) => Is(l, t.element), _t) || ky(t, r), Ji = (t, r, l, d, h, y, w, E = !1) => ({
    x: t,
    y: r,
    bubble: l,
    direction: d,
    placement: h,
    restriction: y,
    label: `${w}-${h}`,
    alwaysFit: E
  }), Kp = Be.generate([
    { southeast: [] },
    { southwest: [] },
    { northeast: [] },
    { northwest: [] },
    { south: [] },
    { north: [] },
    { east: [] },
    { west: [] }
  ]), Fw = (t, r, l, d, h, y, w, E, O) => t.fold(r, l, d, h, y, w, E, O), U_ = (t, r, l, d) => t.fold(r, r, d, d, r, d, l, l), LO = (t, r, l, d) => t.fold(r, d, r, d, l, l, r, d), Vv = Kp.southeast, Bw = Kp.southwest, Lw = Kp.northeast, $w = Kp.northwest, Hw = Kp.south, Bn = Kp.north, p1 = Kp.east, zw = Kp.west, Uv = (t, r, l, d) => {
    const h = t + r;
    return h > d ? l : h < l ? d : h;
  }, Ad = (t, r, l) => Math.min(Math.max(t, r), l), $O = (t, r) => {
    switch (r) {
      case 1:
        return t.x;
      case 0:
        return t.x + t.width;
      case 2:
        return t.y;
      case 3:
        return t.y + t.height;
    }
  }, el = (t, r) => zt([
    "left",
    "right",
    "top",
    "bottom"
  ], (l) => qt(r, l).map((d) => $O(t, d))), HO = (t, r, l) => {
    const d = (O, F) => r[O].map((L) => {
      const q = O === "top" || O === "bottom", ne = q ? l.top : l.left, de = (O === "left" || O === "top" ? Math.max : Math.min)(L, F) + ne;
      return q ? Ad(de, t.y, t.bottom) : Ad(de, t.x, t.right);
    }).getOr(F), h = d("left", t.x), y = d("top", t.y), w = d("right", t.right), E = d("bottom", t.bottom);
    return Nr(h, y, w - h, E - y);
  }, Yp = "layout", Vw = (t) => t.x, j_ = (t, r) => t.x + t.width / 2 - r.width / 2, Dl = (t, r) => t.x + t.width - r.width, Xp = (t, r) => t.y - r.height, _y = (t) => t.y + t.height, Qp = (t, r) => t.y + t.height / 2 - r.height / 2, zO = (t) => t.x + t.width, VO = (t, r) => t.x - r.width, fi = (t, r, l) => Ji(Vw(t), _y(t), l.southeast(), Vv(), "southeast", el(t, {
    left: 1,
    top: 3
  }), Yp), ei = (t, r, l) => Ji(Dl(t, r), _y(t), l.southwest(), Bw(), "southwest", el(t, {
    right: 0,
    top: 3
  }), Yp), mi = (t, r, l) => Ji(Vw(t), Xp(t, r), l.northeast(), Lw(), "northeast", el(t, {
    left: 1,
    bottom: 2
  }), Yp), br = (t, r, l) => Ji(Dl(t, r), Xp(t, r), l.northwest(), $w(), "northwest", el(t, {
    right: 0,
    bottom: 2
  }), Yp), Si = (t, r, l) => Ji(j_(t, r), Xp(t, r), l.north(), Bn(), "north", el(t, { bottom: 2 }), Yp), ti = (t, r, l) => Ji(j_(t, r), _y(t), l.south(), Hw(), "south", el(t, { top: 3 }), Yp), Uw = (t, r, l) => Ji(zO(t), Qp(t, r), l.east(), p1(), "east", el(t, { left: 0 }), Yp), Ey = (t, r, l) => Ji(VO(t, r), Qp(t, r), l.west(), zw(), "west", el(t, { right: 1 }), Yp), jw = () => [
    fi,
    ei,
    mi,
    br,
    ti,
    Si,
    Uw,
    Ey
  ], W_ = () => [
    ei,
    fi,
    br,
    mi,
    ti,
    Si,
    Uw,
    Ey
  ], Z_ = () => [
    mi,
    br,
    fi,
    ei,
    Si,
    ti
  ], Ty = () => [
    br,
    mi,
    ei,
    fi,
    Si,
    ti
  ], Ay = () => [
    fi,
    ei,
    mi,
    br,
    ti,
    Si
  ], vg = () => [
    ei,
    fi,
    br,
    mi,
    ti,
    Si
  ], Ww = (t, r) => r.universal ? t : So(t, (l) => pn(r.channels, l));
  var bg = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t) => zr([Ft(ju(), (r, l) => {
      const d = t.channels, h = os(d), y = l, w = Ww(h, y);
      xt(w, (E) => {
        const O = d[E], F = O.schema, L = El("channel[" + E + `] data
Receiver: ` + Xc(r.element), F, y.data);
        O.onReceive(r, L);
      });
    })])
  }), UO = [Ls("channels", Hu(Ho.value, Mi([
    Gu("onReceive"),
    Xe("schema", pu())
  ])))];
  const Rc = Xi({
    fields: UO,
    name: "receiving",
    active: bg
  });
  var jO = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, r) => Gc({
      classes: [],
      styles: r.useFixed() ? {} : { position: "relative" }
    })
  });
  const vu = (t, r = !1) => t.dom.focus({ preventScroll: r }), h1 = (t) => t.dom.blur(), g1 = (t) => {
    const r = ie(t).dom;
    return t.dom === r.activeElement;
  }, hf = (t = ec()) => B.from(t.dom.activeElement).map($e.fromDom), cc = (t) => hf(ie(t)).filter((r) => t.dom.contains(r.dom)), Jp = (t, r) => {
    const l = ie(r), d = hf(l).bind((y) => {
      const w = (E) => Is(y, E);
      return w(r) ? B.some(r) : Pw(r, w);
    }), h = t(r);
    return d.each((y) => {
      hf(l).filter((w) => Is(w, y)).fold(() => {
        vu(y);
      }, U);
    }), h;
  }, Zw = Be.generate([
    { none: [] },
    {
      relative: [
        "x",
        "y",
        "width",
        "height"
      ]
    },
    {
      fixed: [
        "x",
        "y",
        "width",
        "height"
      ]
    }
  ]), Oy = (t, r, l, d, h, y) => {
    const w = r.rect, E = w.x - l, O = w.y - d, F = w.width, L = w.height, q = h - (E + F), ne = y - (O + L), ae = B.some(E), de = B.some(O), _e = B.some(q), st = B.some(ne), Re = B.none();
    return Fw(r.direction, () => Fi(t, ae, de, Re, Re), () => Fi(t, Re, de, _e, Re), () => Fi(t, ae, Re, Re, st), () => Fi(t, Re, Re, _e, st), () => Fi(t, ae, de, Re, Re), () => Fi(t, ae, Re, Re, st), () => Fi(t, ae, de, Re, Re), () => Fi(t, Re, de, _e, Re));
  }, G_ = (t, r) => t.fold(() => {
    const l = r.rect;
    return Fi("absolute", B.some(l.x), B.some(l.y), B.none(), B.none());
  }, (l, d, h, y) => Oy("absolute", r, l, d, h, y), (l, d, h, y) => Oy("fixed", r, l, d, h, y)), yg = (t, r) => {
    const l = Vt(Dm, r), d = t.fold(l, l, () => {
      const w = Ci();
      return Dm(r).translate(-w.left, -w.top);
    }), h = ci(r), y = pd(r);
    return Nr(d.left, d.top, h, y);
  }, Gw = (t, r) => r.fold(() => t.fold(Na, Na, Nr), (l) => t.fold(ee(l), ee(l), () => {
    const d = qw(t, l.x, l.y);
    return Nr(d.left, d.top, l.width, l.height);
  })), qw = (t, r, l) => {
    const d = $r(r, l), h = () => {
      const y = Ci();
      return d.translate(-y.left, -y.top);
    };
    return t.fold(ee(d), ee(d), h);
  }, q_ = (t, r, l, d) => t.fold(r, l, d);
  Zw.none;
  const K_ = Zw.relative, v1 = Zw.fixed, xg = (t, r) => ({
    anchorBox: t,
    origin: r
  }), Kw = (t, r) => xg(t, r), Yw = "data-alloy-placement", Y_ = (t, r) => {
    sn(t, Yw, r);
  }, X_ = (t) => Y(t, Yw), WO = (t) => Ee(t, Yw), Dy = Be.generate([
    { fit: ["reposition"] },
    {
      nofit: [
        "reposition",
        "visibleW",
        "visibleH",
        "isVisible"
      ]
    }
  ]), Q_ = (t, r) => {
    const {
      x: l,
      y: d,
      right: h,
      bottom: y
    } = r, { x: w, y: E, right: O, bottom: F, width: L, height: q } = t, ne = w >= l && w <= h, ae = E >= d && E <= y, de = ne && ae, _e = O <= h && O >= l, st = F <= y && F >= d, Re = _e && st, Qe = Math.min(L, w >= l ? h - w : O - l), qe = Math.min(q, E >= d ? y - E : F - d);
    return {
      originInBounds: de,
      sizeInBounds: Re,
      visibleW: Qe,
      visibleH: qe
    };
  }, ZO = (t, r) => {
    const {
      x: l,
      y: d,
      right: h,
      bottom: y
    } = r, { x: w, y: E, width: O, height: F } = t, L = Math.max(l, h - O), q = Math.max(d, y - F), ne = Ad(w, l, L), ae = Ad(E, d, q), de = Math.min(ne + O, h) - ne, _e = Math.min(ae + F, y) - ae;
    return Nr(ne, ae, de, _e);
  }, J_ = (t, r, l) => {
    const d = ee(r.bottom - l.y), h = ee(l.bottom - r.y), y = U_(t, h, h, d), w = ee(r.right - l.x), E = ee(l.right - r.x);
    return {
      maxWidth: LO(t, E, E, w),
      maxHeight: y
    };
  }, b1 = (t, r, l, d) => {
    const h = t.bubble, y = h.offset, w = HO(d, t.restriction, y), E = t.x + y.left, O = t.y + y.top, F = Nr(E, O, r, l), { originInBounds: L, sizeInBounds: q, visibleW: ne, visibleH: ae } = Q_(F, w), de = L && q, _e = de ? F : ZO(F, w), st = _e.width > 0 && _e.height > 0, { maxWidth: Re, maxHeight: Qe } = J_(t.direction, _e, d), qe = {
      rect: _e,
      maxHeight: Qe,
      maxWidth: Re,
      direction: t.direction,
      placement: t.placement,
      classes: {
        on: h.classesOn,
        off: h.classesOff
      },
      layout: t.label,
      testY: O
    };
    return de || t.alwaysFit ? Dy.fit(qe) : Dy.nofit(qe, ne, ae, st);
  }, GO = (t, r, l, d, h, y) => {
    const w = d.width, E = d.height, O = (L, q, ne, ae, de) => {
      const _e = L(l, d, h, t, y), st = b1(_e, w, E, y);
      return st.fold(ee(st), (Re, Qe, qe, Bt) => (de === Bt ? qe > ae || Qe > ne : !de && Bt) ? st : Dy.nofit(q, ne, ae, de));
    };
    return Pt(r, (L, q) => {
      const ne = Vt(O, q);
      return L.fold(ee(L), ne);
    }, Dy.nofit({
      rect: l,
      maxHeight: d.height,
      maxWidth: d.width,
      direction: Vv(),
      placement: "southeast",
      classes: {
        on: [],
        off: []
      },
      layout: "none",
      testY: l.y
    }, -1, -1, !1)).fold(lt, lt);
  }, eE = ot, uc = (t, r, l) => Hc(t, r, eE, l), Xw = (t, r, l) => Zh(t, r, eE, l), Qw = Qd, Jw = [
    "top",
    "bottom",
    "right",
    "left"
  ], Ry = "data-alloy-transition-timer", qO = (t, r) => dO(t, r.classes), KO = (t, r, l) => l.exists((d) => {
    const h = t.mode;
    return h === "all" ? !0 : d[h] !== r[h];
  }), Ny = (t, r) => {
    const l = (d) => parseFloat(d).toFixed(3);
    return Ms(r, (d, h) => {
      const y = t[h].map(l), w = d.map(l);
      return !ia(y, w);
    }).isSome();
  }, tE = (t) => {
    const r = (y) => {
      const E = lr(t, y).split(/\s*,\s*/);
      return So(E, Ne);
    }, l = (y) => {
      if (A(y) && /^[\d.]+/.test(y)) {
        const w = parseFloat(y);
        return Yr(y, "ms") ? w : w * 1e3;
      } else
        return 0;
    }, d = r("transition-delay"), h = r("transition-duration");
    return Pt(h, (y, w, E) => {
      const O = l(d[E]) + l(w);
      return Math.max(y, O);
    }, 0);
  }, eC = (t, r) => {
    const l = za(), d = za();
    let h;
    const y = (F) => {
      var L;
      const q = (L = F.raw.pseudoElement) !== null && L !== void 0 ? L : "";
      return Is(F.target, t) && Ae(q) && pn(Jw, F.raw.propertyName);
    }, w = (F) => {
      if (Se(F) || y(F)) {
        l.clear(), d.clear();
        const L = F == null ? void 0 : F.raw.type;
        (Se(L) || L === of()) && (clearTimeout(h), Ee(t, Ry), Yc(t, r.classes));
      }
    }, E = uc(t, o_(), (F) => {
      y(F) && (E.unbind(), l.set(uc(t, of(), w)), d.set(uc(t, n_(), w)));
    }), O = tE(t);
    requestAnimationFrame(() => {
      h = setTimeout(w, O + 17), sn(t, Ry, h);
    });
  }, tC = (t, r) => {
    Av(t, r.classes), Y(t, Ry).each((l) => {
      clearTimeout(parseInt(l, 10)), Ee(t, Ry);
    }), eC(t, r);
  }, y1 = (t, r, l, d, h, y) => {
    const w = KO(d, h, y);
    if (w || qO(t, d)) {
      Ln(t, "position", l.position);
      const E = yg(r, t), O = G_(r, {
        ...h,
        rect: E
      }), F = zt(Jw, (L) => O[L]);
      Ny(l, F) && (Kt(t, F), w && tC(t, d), xi(t));
    } else
      Yc(t, d.classes);
  }, nC = (t) => ({
    width: ci(t),
    height: pd(t)
  }), nE = (t, r, l, d) => {
    gs(r, "max-height"), gs(r, "max-width");
    const h = nC(r);
    return GO(r, d.preference, t, h, l, d.bounds);
  }, oE = (t, r) => {
    const l = r.classes;
    Yc(t, l.off), Av(t, l.on);
  }, sE = (t, r, l) => {
    const d = l.maxHeightFunction;
    d(t, r.maxHeight);
  }, YO = (t, r, l) => {
    const d = l.maxWidthFunction;
    d(t, r.maxWidth);
  }, rE = (t, r, l) => {
    const d = G_(l.origin, r);
    l.transition.each((h) => {
      y1(t, l.origin, d, h, r, l.lastPlacement);
    }), n1(t, d);
  }, aE = (t, r) => {
    Y_(t, r.placement);
  }, iE = (t, r) => {
    Tm(t, Math.floor(r));
  }, Py = ee((t, r) => {
    iE(t, r), Or(t, {
      "overflow-x": "hidden",
      "overflow-y": "auto"
    });
  }), jv = ee((t, r) => {
    iE(t, r);
  }), lE = (t, r, l) => t[r] === void 0 ? l : t[r], XO = (t, r, l, d, h, y, w, E) => {
    const O = lE(w, "maxHeightFunction", Py()), F = lE(w, "maxWidthFunction", U), L = t.anchorBox, q = t.origin, ne = {
      bounds: Gw(q, y),
      origin: q,
      preference: d,
      maxHeightFunction: O,
      maxWidthFunction: F,
      lastPlacement: h,
      transition: E
    };
    return My(L, r, l, ne);
  }, My = (t, r, l, d) => {
    const h = nE(t, r, l, d);
    return rE(r, h, d), aE(r, h), oE(r, h), sE(r, h, d), YO(r, h, d), {
      layout: h.layout,
      placement: h.placement
    };
  }, QO = [
    "valignCentre",
    "alignLeft",
    "alignRight",
    "alignCentre",
    "top",
    "bottom",
    "left",
    "right",
    "inset"
  ], Od = (t, r, l, d = 1) => {
    const h = t * d, y = r * d, w = (O) => qt(l, O).getOr([]), E = (O, F, L) => {
      const q = on(QO, L);
      return {
        offset: $r(O, F),
        classesOn: je(L, w),
        classesOff: je(q, w)
      };
    };
    return {
      southeast: () => E(-t, r, [
        "top",
        "alignLeft"
      ]),
      southwest: () => E(t, r, [
        "top",
        "alignRight"
      ]),
      south: () => E(-t / 2, r, [
        "top",
        "alignCentre"
      ]),
      northeast: () => E(-t, -r, [
        "bottom",
        "alignLeft"
      ]),
      northwest: () => E(t, -r, [
        "bottom",
        "alignRight"
      ]),
      north: () => E(-t / 2, -r, [
        "bottom",
        "alignCentre"
      ]),
      east: () => E(t, -r / 2, [
        "valignCentre",
        "left"
      ]),
      west: () => E(-t, -r / 2, [
        "valignCentre",
        "right"
      ]),
      insetNortheast: () => E(h, y, [
        "top",
        "alignLeft",
        "inset"
      ]),
      insetNorthwest: () => E(-h, y, [
        "top",
        "alignRight",
        "inset"
      ]),
      insetNorth: () => E(-h / 2, y, [
        "top",
        "alignCentre",
        "inset"
      ]),
      insetSoutheast: () => E(h, -y, [
        "bottom",
        "alignLeft",
        "inset"
      ]),
      insetSouthwest: () => E(-h, -y, [
        "bottom",
        "alignRight",
        "inset"
      ]),
      insetSouth: () => E(-h / 2, -y, [
        "bottom",
        "alignCentre",
        "inset"
      ]),
      insetEast: () => E(-h, -y / 2, [
        "valignCentre",
        "right",
        "inset"
      ]),
      insetWest: () => E(h, -y / 2, [
        "valignCentre",
        "left",
        "inset"
      ])
    };
  }, Iy = () => Od(0, 0, {}), Fy = lt, By = (t, r) => (l) => dc(l) === "rtl" ? r : t, dc = (t) => lr(t, "direction") === "rtl" ? "rtl" : "ltr";
  var eh;
  (function(t) {
    t.TopToBottom = "toptobottom", t.BottomToTop = "bottomtotop";
  })(eh || (eh = {}));
  const th = "data-alloy-vertical-dir", JO = (t) => Mw(t, (r) => ko(r) && tr(r, "data-alloy-vertical-dir") === eh.BottomToTop), nh = () => kr("layouts", [
    Mt("onLtr"),
    Mt("onRtl"),
    $s("onBottomLtr"),
    $s("onBottomRtl")
  ]), x1 = (t, r, l, d, h, y, w) => {
    const E = w.map(JO).getOr(!1), O = r.layouts.map((ae) => ae.onLtr(t)), F = r.layouts.map((ae) => ae.onRtl(t)), L = E ? r.layouts.bind((ae) => ae.onBottomLtr.map((de) => de(t))).or(O).getOr(h) : O.getOr(l), q = E ? r.layouts.bind((ae) => ae.onBottomRtl.map((de) => de(t))).or(F).getOr(y) : F.getOr(d);
    return By(L, q)(t);
  }, eD = (t, r, l) => {
    const d = r.hotspot, h = yg(l, d.element), y = x1(t.element, r, Ay(), vg(), Z_(), Ty(), B.some(r.hotspot.element));
    return B.some(Fy({
      anchorBox: h,
      bubble: r.bubble.getOr(Iy()),
      overrides: r.overrides,
      layouts: y
    }));
  };
  var tD = [
    Mt("hotspot"),
    $s("bubble"),
    Xe("overrides", {}),
    nh(),
    Ur("placement", eD)
  ];
  const cE = (t, r, l) => {
    const d = qw(l, r.x, r.y), h = Nr(d.left, d.top, r.width, r.height), y = x1(t.element, r, jw(), W_(), jw(), W_(), B.none());
    return B.some(Fy({
      anchorBox: h,
      bubble: r.bubble,
      overrides: r.overrides,
      layouts: y
    }));
  };
  var Ly = [
    Mt("x"),
    Mt("y"),
    Xe("height", 0),
    Xe("width", 0),
    Xe("bubble", Iy()),
    Xe("overrides", {}),
    nh(),
    Ur("placement", cE)
  ];
  const $y = Be.generate([
    { screen: ["point"] },
    {
      absolute: [
        "point",
        "scrollLeft",
        "scrollTop"
      ]
    }
  ]), nD = (t) => t.fold(lt, (r, l, d) => r.translate(-l, -d)), w1 = (t) => t.fold(lt, lt), oC = (t) => Pt(t, (r, l) => r.translate(l.left, l.top), $r(0, 0)), oD = (t) => {
    const r = et(t, nD);
    return oC(r);
  }, sC = (t) => {
    const r = et(t, w1);
    return oC(r);
  }, rC = $y.screen, Hy = $y.absolute, sD = (t, r, l) => {
    const d = cl(l.root).dom, h = (y) => {
      const w = li(y), E = li(t.element);
      return Is(w, E);
    };
    return B.from(d.frameElement).map($e.fromDom).filter(h).map(Ga);
  }, wg = (t, r, l) => {
    const d = li(t.element), h = Ci(d), y = sD(t, r, l).getOr(h);
    return Hy(y, h.left, h.top);
  }, uE = (t, r, l, d) => {
    const h = rC($r(t, r));
    return B.some(Lu(h, l, d));
  }, aC = (t, r, l, d, h) => t.map((y) => {
    const w = [
      r,
      y.point
    ], E = q_(d, () => sC(w), () => sC(w), () => oD(w)), O = Gh(E.left, E.top, y.width, y.height), F = l.showAbove ? Z_() : Ay(), L = l.showAbove ? Ty() : vg(), q = x1(h, l, F, L, F, L, B.none());
    return Fy({
      anchorBox: O,
      bubble: l.bubble.getOr(Iy()),
      overrides: l.overrides,
      layouts: q
    });
  }), dE = (t, r, l) => {
    const d = wg(t, l, r);
    return r.node.filter(hs).bind((h) => {
      const y = h.dom.getBoundingClientRect(), w = uE(y.left, y.top, y.width, y.height), E = r.node.getOr(t.element);
      return aC(w, d, r, l, E);
    });
  };
  var zy = [
    Mt("node"),
    Mt("root"),
    $s("bubble"),
    nh(),
    Xe("overrides", {}),
    Xe("showAbove", !1),
    Ur("placement", dE)
  ];
  const rD = "\uFEFF", oh = " ", Wv = { create: (t, r, l, d) => ({
    start: t,
    soffset: r,
    finish: l,
    foffset: d
  }) }, Vy = Be.generate([
    { before: ["element"] },
    {
      on: [
        "element",
        "offset"
      ]
    },
    { after: ["element"] }
  ]), Zv = (t, r, l, d) => t.fold(r, l, d), Gv = (t) => t.fold(lt, lt, lt), aD = Vy.before, fE = Vy.on, iD = Vy.after, Uy = {
    before: aD,
    on: fE,
    after: iD,
    cata: Zv,
    getStart: Gv
  }, Um = Be.generate([
    { domRange: ["rng"] },
    {
      relative: [
        "startSitu",
        "finishSitu"
      ]
    },
    {
      exact: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]), iC = (t) => Um.exact(t.start, t.soffset, t.finish, t.foffset), lC = (t) => t.match({
    domRange: (r) => $e.fromDom(r.startContainer),
    relative: (r, l) => Uy.getStart(r),
    exact: (r, l, d, h) => r
  }), lD = Um.domRange, cC = Um.relative, mE = Um.exact, pE = (t) => {
    const r = lC(t);
    return cl(r);
  }, hE = Wv.create, qv = {
    domRange: lD,
    relative: cC,
    exact: mE,
    exactFromRange: iC,
    getWin: pE,
    range: hE
  }, jy = (t, r) => {
    r.fold((l) => {
      t.setStartBefore(l.dom);
    }, (l, d) => {
      t.setStart(l.dom, d);
    }, (l) => {
      t.setStartAfter(l.dom);
    });
  }, Cg = (t, r) => {
    r.fold((l) => {
      t.setEndBefore(l.dom);
    }, (l, d) => {
      t.setEnd(l.dom, d);
    }, (l) => {
      t.setEndAfter(l.dom);
    });
  }, jm = (t, r, l) => {
    const d = t.document.createRange();
    return jy(d, r), Cg(d, l), d;
  }, C1 = (t, r, l, d, h) => {
    const y = t.document.createRange();
    return y.setStart(r.dom, l), y.setEnd(d.dom, h), y;
  }, Kv = (t) => ({
    left: t.left,
    top: t.top,
    right: t.right,
    bottom: t.bottom,
    width: t.width,
    height: t.height
  }), cD = (t) => {
    const r = t.getClientRects(), l = r.length > 0 ? r[0] : t.getBoundingClientRect();
    return l.width > 0 || l.height > 0 ? B.some(l).map(Kv) : B.none();
  }, gf = (t) => {
    const r = t.getBoundingClientRect();
    return r.width > 0 || r.height > 0 ? B.some(r).map(Kv) : B.none();
  }, bu = Be.generate([
    {
      ltr: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    },
    {
      rtl: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]), Wy = (t, r, l) => r($e.fromDom(l.startContainer), l.startOffset, $e.fromDom(l.endContainer), l.endOffset), uD = (t, r) => r.match({
    domRange: (l) => ({
      ltr: ee(l),
      rtl: B.none
    }),
    relative: (l, d) => ({
      ltr: Te(() => jm(t, l, d)),
      rtl: Te(() => B.some(jm(t, d, l)))
    }),
    exact: (l, d, h, y) => ({
      ltr: Te(() => C1(t, l, d, h, y)),
      rtl: Te(() => B.some(C1(t, h, y, l, d)))
    })
  }), KI = (t, r) => {
    const l = r.ltr();
    return l.collapsed ? r.rtl().filter((h) => h.collapsed === !1).map((h) => bu.rtl($e.fromDom(h.endContainer), h.endOffset, $e.fromDom(h.startContainer), h.startOffset)).getOrThunk(() => Wy(t, bu.ltr, l)) : Wy(t, bu.ltr, l);
  }, Sg = (t, r) => {
    const l = uD(t, r);
    return KI(t, l);
  }, Yv = (t, r) => Sg(t, r).match({
    ltr: (d, h, y, w) => {
      const E = t.document.createRange();
      return E.setStart(d.dom, h), E.setEnd(y.dom, w), E;
    },
    rtl: (d, h, y, w) => {
      const E = t.document.createRange();
      return E.setStart(y.dom, w), E.setEnd(d.dom, h), E;
    }
  });
  bu.ltr, bu.rtl;
  const Xv = (t, r, l) => So(uu(t, l), r), Rl = (t, r) => ii(r, t), Zy = (t, r, l, d) => {
    const y = li(t).dom.createRange();
    return y.setStart(t.dom, r), y.setEnd(l.dom, d), y;
  }, kg = (t, r, l, d) => {
    const h = Zy(t, r, l, d), y = Is(t, l) && r === d;
    return h.collapsed && !y;
  }, Gy = (t) => B.from(t.getSelection()), gE = (t) => {
    if (t.rangeCount > 0) {
      const r = t.getRangeAt(0), l = t.getRangeAt(t.rangeCount - 1);
      return B.some(Wv.create($e.fromDom(r.startContainer), r.startOffset, $e.fromDom(l.endContainer), l.endOffset));
    } else
      return B.none();
  }, uC = (t) => {
    if (t.anchorNode === null || t.focusNode === null)
      return gE(t);
    {
      const r = $e.fromDom(t.anchorNode), l = $e.fromDom(t.focusNode);
      return kg(r, t.anchorOffset, l, t.focusOffset) ? B.some(Wv.create(r, t.anchorOffset, l, t.focusOffset)) : gE(t);
    }
  }, qy = (t) => Gy(t).filter((r) => r.rangeCount > 0).bind(uC), Bi = (t, r) => {
    const l = Yv(t, r);
    return cD(l);
  }, Ky = (t, r) => {
    const l = Yv(t, r);
    return gf(l);
  }, dC = ((t, r) => {
    const l = (y) => {
      if (!t(y))
        throw new Error("Can only get " + r + " value of a " + r + " node");
      return d(y).getOr("");
    }, d = (y) => t(y) ? B.from(y.dom.nodeValue) : B.none();
    return {
      get: l,
      getOption: d,
      set: (y, w) => {
        if (!t(y))
          throw new Error("Can only set raw " + r + " value of a " + r + " node");
        y.dom.nodeValue = w;
      }
    };
  })(Zo, "text"), fC = (t) => dC.get(t), Wm = (t, r) => ({
    element: t,
    offset: r
  }), vE = (t, r) => {
    const l = La(t);
    if (l.length === 0)
      return Wm(t, r);
    if (r < l.length)
      return Wm(l[r], 0);
    {
      const d = l[l.length - 1], h = Zo(d) ? fC(d).length : La(d).length;
      return Wm(d, h);
    }
  }, sh = (t, r) => Zo(t) ? Wm(t, r) : vE(t, r), Yy = (t) => t.foffset !== void 0, Xy = (t, r) => r.getSelection.getOrThunk(() => () => qy(t))().map((d) => {
    if (Yy(d)) {
      const h = sh(d.start, d.soffset), y = sh(d.finish, d.foffset);
      return qv.range(h.element, h.offset, y.element, y.offset);
    } else
      return d;
  }), mC = (t, r, l) => {
    const d = cl(r.root).dom, h = wg(t, l, r), y = Xy(d, r).bind((O) => {
      if (Yy(O))
        return Ky(d, qv.exactFromRange(O)).orThunk(() => {
          const L = $e.fromText(rD);
          Jl(O.start, L);
          const q = Bi(d, qv.exact(L, 0, L, 1));
          return _c(L), q;
        }).bind((L) => uE(L.left, L.top, L.width, L.height));
      {
        const F = kt(O, (q) => q.dom.getBoundingClientRect()), L = {
          left: Math.min(F.firstCell.left, F.lastCell.left),
          right: Math.max(F.firstCell.right, F.lastCell.right),
          top: Math.min(F.firstCell.top, F.lastCell.top),
          bottom: Math.max(F.firstCell.bottom, F.lastCell.bottom)
        };
        return uE(L.left, L.top, L.right - L.left, L.bottom - L.top);
      }
    }), E = Xy(d, r).bind((O) => Yy(O) ? ko(O.start) ? B.some(O.start) : ji(O.start) : B.some(O.firstCell)).getOr(t.element);
    return aC(y, h, r, l, E);
  };
  var _g = [
    $s("getSelection"),
    Mt("root"),
    $s("bubble"),
    nh(),
    Xe("overrides", {}),
    Xe("showAbove", !1),
    Ur("placement", mC)
  ];
  const Qv = "link-layout", pl = (t) => t.x + t.width, bE = (t, r) => t.x - r.width, pC = (t, r) => t.y - r.height + t.height, hC = (t) => t.y, yE = (t, r, l) => Ji(pl(t), hC(t), l.southeast(), Vv(), "southeast", el(t, {
    left: 0,
    top: 2
  }), Qv), gC = (t, r, l) => Ji(bE(t, r), hC(t), l.southwest(), Bw(), "southwest", el(t, {
    right: 1,
    top: 2
  }), Qv), xE = (t, r, l) => Ji(pl(t), pC(t, r), l.northeast(), Lw(), "northeast", el(t, {
    left: 0,
    bottom: 3
  }), Qv), wE = (t, r, l) => Ji(bE(t, r), pC(t, r), l.northwest(), $w(), "northwest", el(t, {
    right: 1,
    bottom: 3
  }), Qv), yu = () => [
    yE,
    gC,
    xE,
    wE
  ], Zm = () => [
    gC,
    yE,
    wE,
    xE
  ], CE = (t, r, l) => {
    const d = yg(l, r.item.element), h = x1(t.element, r, yu(), Zm(), yu(), Zm(), B.none());
    return B.some(Fy({
      anchorBox: d,
      bubble: Iy(),
      overrides: r.overrides,
      layouts: h
    }));
  };
  var Eg = [
    Mt("item"),
    nh(),
    Xe("overrides", {}),
    Ur("placement", CE)
  ], Ul = ui("type", {
    selection: _g,
    node: zy,
    hotspot: tD,
    submenu: Eg,
    makeshift: Ly
  });
  const eu = [
    Ac("classes", Tn),
    gu("mode", "all", [
      "all",
      "layout",
      "placement"
    ])
  ], jl = [
    Xe("useFixed", _t),
    $s("getBounds")
  ], xu = [
    Ls("anchor", Ul),
    kr("transition", eu)
  ], Qy = () => {
    const t = document.documentElement;
    return v1(0, 0, t.clientWidth, t.clientHeight);
  }, wu = (t) => {
    const r = Ga(t.element), l = t.element.dom.getBoundingClientRect();
    return K_(r.left, r.top, l.width, l.height);
  }, Tg = (t, r, l, d, h, y) => {
    const w = Kw(r.anchorBox, t);
    return XO(w, d.element, r.bubble, r.layouts, h, l, r.overrides, y);
  }, dD = (t, r, l, d, h) => {
    const y = B.none();
    SE(t, r, l, d, h, y);
  }, SE = (t, r, l, d, h, y) => {
    const w = El("placement.info", xo(xu), h), E = w.anchor, O = d.element, F = l.get(d.uid);
    Jp(() => {
      Ln(O, "position", "fixed");
      const L = Cr(O, "visibility");
      Ln(O, "visibility", "hidden");
      const q = r.useFixed() ? Qy() : wu(t);
      E.placement(t, E, q).each((ne) => {
        const ae = y.orThunk(() => r.getBounds.map(Rn)), de = Tg(q, ne, ae, d, F, w.transition);
        l.set(d.uid, de);
      }), L.fold(() => {
        gs(O, "visibility");
      }, (ne) => {
        Ln(O, "visibility", ne);
      }), Cr(O, "left").isNone() && Cr(O, "top").isNone() && Cr(O, "right").isNone() && Cr(O, "bottom").isNone() && ha(Cr(O, "position"), "fixed") && gs(O, "position");
    }, O);
  };
  var _E = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    position: dD,
    positionWithinBounds: SE,
    getMode: (t, r, l) => r.useFixed() ? "fixed" : "absolute",
    reset: (t, r, l, d) => {
      const h = d.element;
      xt([
        "position",
        "left",
        "right",
        "top",
        "bottom"
      ], (y) => gs(h, y)), WO(h), l.clear(d.uid);
    }
  }), bC = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      let t = {};
      return qc({
        readState: () => t,
        clear: (h) => {
          be(h) ? delete t[h] : t = {};
        },
        set: (h, y) => {
          t[h] = y;
        },
        get: (h) => qt(t, h)
      });
    }
  });
  const tl = Xi({
    fields: jl,
    name: "positioning",
    active: jO,
    apis: _E,
    state: bC
  }), yC = (t) => t.getSystem().isConnected(), rh = (t) => {
    Xo(t, Zu());
    const r = t.components();
    xt(r, rh);
  }, Jv = (t) => {
    const r = t.components();
    xt(r, Jv), Xo(t, rc());
  }, xC = (t, r) => {
    t.getSystem().addToWorld(r), hs(t.element) && Jv(r);
  }, Jy = (t) => {
    rh(t), t.getSystem().removeFromWorld(t);
  }, S1 = (t, r) => {
    qi(t.element, r.element);
  }, wC = (t) => {
    xt(t.components(), (r) => _c(r.element)), Lf(t.element), t.syncComponents();
  }, eb = (t, r, l) => {
    const d = t.components();
    wC(t);
    const h = l(r), y = on(d, h);
    xt(y, (w) => {
      rh(w), t.getSystem().removeFromWorld(w);
    }), xt(h, (w) => {
      yC(w) ? S1(t, w) : (t.getSystem().addToWorld(w), S1(t, w), hs(t.element) && Jv(w));
    }), t.syncComponents();
  }, CC = (t, r, l) => {
    const d = t.components(), h = je(r, (E) => __(E).toArray());
    xt(d, (E) => {
      pn(h, E) || Jy(E);
    });
    const y = l(r), w = on(d, y);
    xt(w, (E) => {
      yC(E) && Jy(E);
    }), xt(y, (E) => {
      yC(E) || xC(t, E);
    }), t.syncComponents();
  }, em = (t, r) => {
    Ag(t, r, qi);
  }, Ag = (t, r, l) => {
    t.getSystem().addToWorld(r), l(t.element, r.element), hs(t.element) && Jv(r), t.syncComponents();
  }, EE = (t) => {
    rh(t), _c(t.element), t.getSystem().removeFromWorld(t);
  }, Gm = (t) => {
    const r = Za(t.element).bind((l) => t.getSystem().getByDom(l).toOptional());
    EE(t), r.each((l) => {
      l.syncComponents();
    });
  }, Cu = (t) => {
    const r = t.components();
    xt(r, EE), Lf(t.element), t.syncComponents();
  }, TE = (t, r) => {
    Og(t, r, qi);
  }, tm = (t, r) => {
    Og(t, r, zc);
  }, Og = (t, r, l) => {
    l(t, r.element);
    const d = La(r.element);
    xt(d, (h) => {
      r.getByDom(h).each(Jv);
    });
  }, SC = (t) => {
    const r = La(t.element);
    xt(r, (l) => {
      t.getByDom(l).each(rh);
    }), _c(t.element);
  }, ex = (t, r, l, d) => {
    l.get().each((w) => {
      Cu(t);
    });
    const h = r.getAttachPoint(t);
    em(h, t);
    const y = t.getSystem().build(d);
    return em(t, y), l.set(y), y;
  }, AE = (t, r, l, d) => {
    const h = ex(t, r, l, d);
    return r.onOpen(t, h), h;
  }, mD = (t, r, l, d) => l.get().map(() => ex(t, r, l, d)), pD = (t, r, l, d, h) => {
    nb(t, r), AE(t, r, l, d), h(), tx(t, r);
  }, OE = (t, r, l) => {
    l.get().each((d) => {
      Cu(t), Gm(t), r.onClose(t, d), l.clear();
    });
  }, ah = (t, r, l) => l.isOpen(), tb = (t, r, l, d) => ah(t, r, l) && l.get().exists((h) => r.isPartOf(t, h, d)), k1 = (t, r, l) => l.get(), hD = (t, r, l, d) => {
    Cr(t.element, r).fold(() => {
      Ee(t.element, l);
    }, (h) => {
      sn(t.element, l, h);
    }), Ln(t.element, r, d);
  }, gD = (t, r, l) => {
    Y(t.element, l).fold(() => gs(t.element, r), (d) => Ln(t.element, r, d));
  }, nb = (t, r, l) => {
    const d = r.getAttachPoint(t);
    Ln(t.element, "position", tl.getMode(d)), hD(t, "visibility", r.cloakVisibilityAttr, "hidden");
  }, kC = (t) => Ro([
    "top",
    "left",
    "right",
    "bottom"
  ], (r) => Cr(t, r).isSome()), tx = (t, r, l) => {
    kC(t.element) || gs(t.element, "position"), gD(t, "visibility", r.cloakVisibilityAttr);
  };
  var _C = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    cloak: nb,
    decloak: tx,
    open: AE,
    openWhileCloaked: pD,
    close: OE,
    isOpen: ah,
    isPartOf: tb,
    getState: k1,
    setContent: mD
  }), ob = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, r) => zr([Ft(Kb(), (l, d) => {
      OE(l, t, r);
    })])
  }), TC = [
    Os("onOpen"),
    Os("onClose"),
    Mt("isPartOf"),
    Mt("getAttachPoint"),
    Xe("cloakVisibilityAttr", "data-precloak-visibility")
  ], AC = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = cr(), r = ee("not-implemented");
      return qc({
        readState: r,
        isOpen: t.isSet,
        clear: t.clear,
        set: t.set,
        get: t.get
      });
    }
  });
  const Ns = Xi({
    fields: TC,
    name: "sandboxing",
    active: ob,
    apis: _C,
    state: AC
  }), nm = ee("dismiss.popups"), Dg = ee("reposition.popups"), _1 = ee("mouse.released"), OC = Mi([
    Xe("isExtraPart", _t),
    kr("fireEventInstead", [Xe("event", Lp())])
  ]), qm = (t) => {
    const r = El("Dismissal", OC, t);
    return {
      [nm()]: {
        schema: Mi([Mt("target")]),
        onReceive: (l, d) => {
          Ns.isOpen(l) && (Ns.isPartOf(l, d.target) || r.isExtraPart(l, d.target) || r.fireEventInstead.fold(() => Ns.close(l), (y) => Xo(l, y.event)));
        }
      }
    };
  }, DC = Mi([
    kr("fireEventInstead", [Xe("event", tw())]),
    Tc("doReposition")
  ]), nx = (t) => {
    const r = El("Reposition", DC, t);
    return {
      [Dg()]: {
        onReceive: (l) => {
          Ns.isOpen(l) && r.fireEventInstead.fold(() => r.doReposition(l), (d) => Xo(l, d.event));
        }
      }
    };
  }, RC = (t, r, l) => {
    r.store.manager.onLoad(t, r, l);
  }, NC = (t, r, l) => {
    r.store.manager.onUnload(t, r, l);
  };
  var sx = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    onLoad: RC,
    onUnload: NC,
    setValue: (t, r, l, d) => {
      r.store.manager.setValue(t, r, l, d);
    },
    getValue: (t, r, l) => r.store.manager.getValue(t, r, l),
    getState: (t, r, l) => l
  }), rb = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, r) => {
      const l = t.resetOnDom ? [
        qr((d, h) => {
          RC(d, t, r);
        }),
        qf((d, h) => {
          NC(d, t, r);
        })
      ] : [lw(t, r, RC)];
      return zr(l);
    }
  });
  const rx = () => {
    const t = to(null), r = () => ({
      mode: "memory",
      value: t.get()
    }), l = () => t.get() === null, d = () => {
      t.set(null);
    };
    return qc({
      set: t.set,
      get: t.get,
      isNotSet: l,
      clear: d,
      readState: r
    });
  }, vD = () => qc({ readState: U }), ax = () => {
    const t = to({}), r = to({});
    return qc({
      readState: () => ({
        mode: "dataset",
        dataByValue: t.get(),
        dataByText: r.get()
      }),
      lookup: (w) => qt(t.get(), w).orThunk(() => qt(r.get(), w)),
      update: (w) => {
        const E = t.get(), O = r.get(), F = {}, L = {};
        xt(w, (q) => {
          F[q.value] = q, qt(q, "meta").each((ne) => {
            qt(ne, "text").each((ae) => {
              L[ae] = q;
            });
          });
        }), t.set({
          ...E,
          ...F
        }), r.set({
          ...O,
          ...L
        });
      },
      clear: () => {
        t.set({}), r.set({});
      }
    });
  };
  var bD = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    memory: rx,
    dataset: ax,
    manual: vD,
    init: (t) => t.store.manager.state(t)
  });
  const E1 = (t, r, l, d) => {
    const h = r.store;
    l.update([d]), h.setValue(t, d), r.onSetValue(t, d);
  }, Ku = (t, r, l) => {
    const d = r.store, h = d.getDataKey(t);
    return l.lookup(h).getOrThunk(() => d.getFallbackEntry(h));
  }, Li = (t, r, l) => {
    r.store.initialValue.each((h) => {
      E1(t, r, l, h);
    });
  }, yD = (t, r, l) => {
    l.clear();
  };
  var vf = [
    $s("initialValue"),
    Mt("getFallbackEntry"),
    Mt("getDataKey"),
    Mt("setValue"),
    Ur("manager", {
      setValue: E1,
      getValue: Ku,
      onLoad: Li,
      onUnload: yD,
      state: ax
    })
  ];
  const xD = (t, r, l) => r.store.getValue(t), RE = (t, r, l, d) => {
    r.store.setValue(t, d), r.onSetValue(t, d);
  }, T1 = (t, r, l) => {
    r.store.initialValue.each((d) => {
      r.store.setValue(t, d);
    });
  };
  var ab = [
    Mt("getValue"),
    Xe("setValue", U),
    $s("initialValue"),
    Ur("manager", {
      setValue: RE,
      getValue: xD,
      onLoad: T1,
      onUnload: U,
      state: Hl.init
    })
  ];
  const NE = (t, r, l, d) => {
    l.set(d), r.onSetValue(t, d);
  }, PE = (t, r, l) => l.get(), YI = (t, r, l) => {
    r.store.initialValue.each((d) => {
      l.isNotSet() && l.set(d);
    });
  }, XI = (t, r, l) => {
    l.clear();
  };
  var ME = [
    $s("initialValue"),
    Ur("manager", {
      setValue: NE,
      getValue: PE,
      onLoad: YI,
      onUnload: XI,
      state: rx
    })
  ], IE = [
    Wc("store", { mode: "memory" }, ui("mode", {
      memory: ME,
      manual: ab,
      dataset: vf
    })),
    Os("onSetValue"),
    Xe("resetOnDom", !1)
  ];
  const In = Xi({
    fields: IE,
    name: "representing",
    active: rb,
    apis: sx,
    extra: {
      setValueFrom: (t, r) => {
        const l = In.getValue(r);
        In.setValue(t, l);
      }
    },
    state: bD
  }), $i = (t, r) => te(t, {}, et(r, (l) => X2(l.name(), "Cannot configure " + l.name() + " for " + t)).concat([Vs("dump", lt)])), A1 = (t) => t.dump, Hi = (t, r) => ({
    ...Jt(r),
    ...t.dump
  }), Yu = {
    field: $i,
    augment: Hi,
    get: A1
  }, PC = "placeholder", Pg = Be.generate([
    {
      single: [
        "required",
        "valueThunk"
      ]
    },
    {
      multiple: [
        "required",
        "valueThunks"
      ]
    }
  ]), ix = (t) => Ko(t, "uiType"), ih = (t, r, l, d) => t.exists((h) => h !== l.owner) ? Pg.single(!0, ee(l)) : qt(d, l.name).fold(() => {
    throw new Error("Unknown placeholder component: " + l.name + `
Known: [` + os(d) + `]
Namespace: ` + t.getOr("none") + `
Spec: ` + JSON.stringify(l, null, 2));
  }, (h) => h.replace()), O1 = (t, r, l, d) => ix(l) && l.uiType === PC ? ih(t, r, l, d) : Pg.single(!1, ee(l)), FE = (t, r, l, d) => O1(t, r, l, d).fold((y, w) => {
    const E = ix(l) ? w(r, l.config, l.validated) : w(r), O = qt(E, "components").getOr([]), F = je(O, (L) => FE(t, r, L, d));
    return [{
      ...E,
      components: F
    }];
  }, (y, w) => {
    if (ix(l)) {
      const E = w(r, l.config, l.validated);
      return l.validated.preprocess.getOr(lt)(E);
    } else
      return w(r);
  }), wD = (t, r, l, d) => je(l, (h) => FE(t, r, h, d)), CD = (t, r) => {
    let l = !1;
    const d = () => l, h = () => {
      if (l)
        throw new Error("Trying to use the same placeholder more than once: " + t);
      return l = !0, r;
    }, y = () => r.fold((w, E) => w, (w, E) => w);
    return {
      name: ee(t),
      required: y,
      used: d,
      replace: h
    };
  }, SD = (t, r, l, d) => {
    const h = kt(d, (w, E) => CD(E, w)), y = wD(t, r, l, h);
    return it(h, (w) => {
      if (w.used() === !1 && w.required())
        throw new Error("Placeholder: " + w.name() + ` was not found in components list
Namespace: ` + t.getOr("none") + `
Components: ` + JSON.stringify(r.components, null, 2));
    }), y;
  }, lh = Pg.single, D1 = Pg.multiple, R1 = ee(PC), lx = Be.generate([
    { required: ["data"] },
    { external: ["data"] },
    { optional: ["data"] },
    { group: ["data"] }
  ]), tu = Xe("factory", { sketch: lt }), om = Xe("schema", []), ch = Mt("name"), uh = Qa("pname", "pname", ls((t) => "<alloy." + Mn(t.name) + ">"), pu()), kD = Vs("schema", () => [$s("preprocess")]), cx = Xe("defaults", ee({})), ux = Xe("overrides", ee({})), _D = xo([
    tu,
    om,
    ch,
    uh,
    cx,
    ux
  ]), ED = xo([
    tu,
    om,
    ch,
    cx,
    ux
  ]), TD = xo([
    tu,
    om,
    ch,
    uh,
    cx,
    ux
  ]), AD = xo([
    tu,
    kD,
    ch,
    Mt("unit"),
    uh,
    cx,
    ux
  ]), BE = (t) => t.fold(B.some, B.none, B.some, B.some), dx = (t) => {
    const r = (l) => l.name;
    return t.fold(r, r, r, r);
  }, OD = (t) => t.fold(lt, lt, lt, lt), fx = (t, r) => (l) => {
    const d = El("Converting part type", r, l);
    return t(d);
  }, hl = fx(lx.required, _D), Xu = fx(lx.external, ED), Su = fx(lx.optional, TD), mx = fx(lx.group, AD), px = ee("entirety");
  var LE = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    required: hl,
    external: Xu,
    optional: Su,
    group: mx,
    asNamedPart: BE,
    name: dx,
    asCommon: OD,
    original: px
  });
  const MC = (t, r, l, d) => Pr(r.defaults(t, l, d), l, { uid: t.partUids[r.name] }, r.overrides(t, l, d)), $E = (t, r, l) => {
    const d = {}, h = {};
    return xt(l, (y) => {
      y.fold((w) => {
        d[w.pname] = lh(!0, (E, O, F) => w.factory.sketch(MC(E, w, O, F)));
      }, (w) => {
        const E = r.parts[w.name];
        h[w.name] = ee(w.factory.sketch(MC(r, w, E[px()]), E));
      }, (w) => {
        d[w.pname] = lh(!1, (E, O, F) => w.factory.sketch(MC(E, w, O, F)));
      }, (w) => {
        d[w.pname] = D1(!0, (E, O, F) => {
          const L = E[w.name];
          return et(L, (q) => w.factory.sketch(Pr(w.defaults(E, q, F), q, w.overrides(E, q))));
        });
      });
    }), {
      internals: ee(d),
      externals: ee(h)
    };
  }, IC = (t, r) => {
    const l = {};
    return xt(r, (d) => {
      BE(d).each((h) => {
        const y = HE(t, h.pname);
        l[h.name] = (w) => {
          const E = El("Part: " + h.name + " in " + t, xo(h.schema), w);
          return {
            ...y,
            config: w,
            validated: E
          };
        };
      });
    }), l;
  }, HE = (t, r) => ({
    uiType: R1(),
    owner: t,
    name: r
  }), zE = (t, r, l) => ({
    uiType: R1(),
    owner: t,
    name: r,
    config: l,
    validated: {}
  }), DD = (t) => je(t, (r) => r.fold(B.none, B.some, B.none, B.none).map((l) => tf(l.name, l.schema.concat([C_(px())]))).toArray()), RD = (t) => et(t, dx), hx = (t, r, l) => $E(t, r, l), FC = (t, r, l) => SD(B.some(t), r, r.components, l), Qt = (t, r, l) => {
    const d = r.partUids[l];
    return t.getSystem().getByUid(d).toOptional();
  }, fc = (t, r, l) => Qt(t, r, l).getOrDie("Could not find part: " + l), VE = (t, r, l) => {
    const d = {}, h = r.partUids, y = t.getSystem();
    return xt(l, (w) => {
      d[w] = ee(y.getByUid(h[w]));
    }), d;
  }, BC = (t, r) => {
    const l = t.getSystem();
    return kt(r.partUids, (d, h) => ee(l.getByUid(d)));
  }, N1 = (t) => os(t.partUids), P1 = (t, r, l) => {
    const d = {}, h = r.partUids, y = t.getSystem();
    return xt(l, (w) => {
      d[w] = ee(y.getByUid(h[w]).getOrDie());
    }), d;
  }, gx = (t, r) => {
    const l = RD(r);
    return Us(et(l, (d) => ({
      key: d,
      value: t + "-" + d
    })));
  }, M1 = (t) => Qa("partUids", "partUids", Op((r) => gx(r.uid, t)), pu());
  var UE = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    generate: IC,
    generateOne: zE,
    schemas: DD,
    names: RD,
    substitutes: hx,
    components: FC,
    defaultUids: gx,
    defaultUidsSchema: M1,
    getAllParts: BC,
    getAllPartNames: N1,
    getPart: Qt,
    getPartOrDie: fc,
    getParts: VE,
    getPartsOrDie: P1
  });
  const jE = (t, r) => (t.length > 0 ? [tf("parts", t)] : []).concat([
    Mt("uid"),
    Xe("dom", {}),
    Xe("components", []),
    C_("originalSpec"),
    Xe("debug.sketcher", {})
  ]).concat(r), LC = (t, r, l, d, h) => {
    const y = jE(d, h);
    return El(t + " [SpecSchema]", Mi(y.concat(r)), l);
  }, $C = (t, r, l, d) => {
    const h = WE(d), y = LC(t, r, h, [], []);
    return l(y, h);
  }, Ym = (t, r, l, d, h) => {
    const y = WE(h), w = DD(l), E = M1(l), O = LC(t, r, y, w, [E]), F = hx(t, O, l), L = FC(t, O, F.internals());
    return d(O, L, y, F.externals());
  }, HC = (t) => Ko(t, "uid"), WE = (t) => HC(t) ? t : {
    ...t,
    uid: hg("uid")
  }, ND = (t) => t.uid !== void 0, PD = Mi([
    Mt("name"),
    Mt("factory"),
    Mt("configFields"),
    Xe("apis", {}),
    Xe("extraApis", {})
  ]), ZE = Mi([
    Mt("name"),
    Mt("factory"),
    Mt("configFields"),
    Mt("partFields"),
    Xe("apis", {}),
    Xe("extraApis", {})
  ]), Nc = (t) => {
    const r = El("Sketcher for " + t.name, PD, t), l = (y) => $C(r.name, r.configFields, r.factory, y), d = kt(r.apis, $v), h = kt(r.extraApis, (y, w) => Ev(y, w));
    return {
      name: r.name,
      configFields: r.configFields,
      sketch: l,
      ...d,
      ...h
    };
  }, Wl = (t) => {
    const r = El("Sketcher for " + t.name, ZE, t), l = (w) => Ym(r.name, r.configFields, r.partFields, r.factory, w), d = IC(r.name, r.partFields), h = kt(r.apis, $v), y = kt(r.extraApis, (w, E) => Ev(w, E));
    return {
      name: r.name,
      partFields: r.partFields,
      configFields: r.configFields,
      sketch: l,
      parts: d,
      ...h,
      ...y
    };
  }, ib = (t) => ca("input")(t) && tr(t, "type") !== "radio" || ca("textarea")(t);
  var MD = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getCurrent: (t, r, l) => r.find(t)
  });
  const zC = [Mt("find")], Ds = Xi({
    fields: zC,
    name: "composing",
    apis: MD
  }), JI = [
    "input",
    "button",
    "textarea",
    "select"
  ], GE = (t, r, l) => {
    (r.disabled() ? vx : F1)(t, r);
  }, qE = (t, r) => r.useNative === !0 && pn(JI, Gs(t.element)), eF = (t) => ge(t.element, "disabled"), dh = (t) => {
    sn(t.element, "disabled", "disabled");
  }, I1 = (t) => {
    Ee(t.element, "disabled");
  }, ID = (t) => tr(t.element, "aria-disabled") === "true", FD = (t) => {
    sn(t.element, "aria-disabled", "true");
  }, BD = (t) => {
    sn(t.element, "aria-disabled", "false");
  }, vx = (t, r, l) => {
    r.disableClass.each((h) => {
      Vr(t.element, h);
    }), (qE(t, r) ? dh : FD)(t), r.onDisabled(t);
  }, F1 = (t, r, l) => {
    r.disableClass.each((h) => {
      ba(t.element, h);
    }), (qE(t, r) ? I1 : BD)(t), r.onEnabled(t);
  }, KE = (t, r) => qE(t, r) ? eF(t) : ID(t);
  var lb = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    enable: F1,
    disable: vx,
    isDisabled: KE,
    onLoad: GE,
    set: (t, r, l, d) => {
      (d ? vx : F1)(t, r);
    }
  }), YE = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, r) => Gc({ classes: r.disabled() ? r.disableClass.toArray() : [] }),
    events: (t, r) => zr([
      i_(Wu(), (l, d) => KE(l, t)),
      lw(t, r, GE)
    ])
  }), LD = [
    Ca("disabled", _t),
    Xe("useNative", !0),
    $s("disableClass"),
    Os("onDisabled"),
    Os("onEnabled")
  ];
  const _o = Xi({
    fields: LD,
    name: "disabling",
    active: YE,
    apis: lb
  }), m = (t, r, l, d) => {
    const h = Rl(t.element, "." + r.highlightClass);
    xt(h, (y) => {
      Ro(d, (E) => Is(E.element, y)) || (ba(y, r.highlightClass), t.getSystem().getByDom(y).each((E) => {
        r.onDehighlight(t, E), Xo(E, sg());
      }));
    });
  }, v = (t, r, l) => m(t, r, l, []), C = (t, r, l, d) => {
    xe(t, r, l, d) && (ba(d.element, r.highlightClass), r.onDehighlight(t, d), Xo(d, sg()));
  }, _ = (t, r, l, d) => {
    m(t, r, l, [d]), xe(t, r, l, d) || (Vr(d.element, r.highlightClass), r.onHighlight(t, d), Xo(d, $p()));
  }, P = (t, r, l) => {
    Yt(t, r).each((d) => {
      _(t, r, l, d);
    });
  }, z = (t, r, l) => {
    _n(t, r).each((d) => {
      _(t, r, l, d);
    });
  }, Q = (t, r, l, d) => {
    at(t, r, l, d).fold((h) => {
      throw h;
    }, (h) => {
      _(t, r, l, h);
    });
  }, le = (t, r, l, d) => {
    const h = Wt(t, r);
    Nt(h, d).each((w) => {
      _(t, r, l, w);
    });
  }, xe = (t, r, l, d) => Kc(d.element, r.highlightClass), Fe = (t, r, l) => or(t.element, "." + r.highlightClass).bind((d) => t.getSystem().getByDom(d).toOptional()), at = (t, r, l, d) => {
    const h = Rl(t.element, "." + r.itemClass);
    return B.from(h[d]).fold(() => Ho.error(new Error("No element found with index " + d)), t.getSystem().getByDom);
  }, Yt = (t, r, l) => or(t.element, "." + r.itemClass).bind((d) => t.getSystem().getByDom(d).toOptional()), _n = (t, r, l) => {
    const d = Rl(t.element, "." + r.itemClass);
    return (d.length > 0 ? B.some(d[d.length - 1]) : B.none()).bind((y) => t.getSystem().getByDom(y).toOptional());
  }, vn = (t, r, l, d) => {
    const h = Rl(t.element, "." + r.itemClass);
    return Vn(h, (w) => Kc(w, r.highlightClass)).bind((w) => {
      const E = Uv(w, d, 0, h.length - 1);
      return t.getSystem().getByDom(h[E]).toOptional();
    });
  }, ln = (t, r, l) => vn(t, r, l, -1), Wn = (t, r, l) => vn(t, r, l, 1), Wt = (t, r, l) => {
    const d = Rl(t.element, "." + r.itemClass);
    return na(et(d, (h) => t.getSystem().getByDom(h).toOptional()));
  };
  var un = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    dehighlightAll: v,
    dehighlight: C,
    highlight: _,
    highlightFirst: P,
    highlightLast: z,
    highlightAt: Q,
    highlightBy: le,
    isHighlighted: xe,
    getHighlighted: Fe,
    getFirst: Yt,
    getLast: _n,
    getPrevious: ln,
    getNext: Wn,
    getCandidates: Wt
  }), wo = [
    Mt("highlightClass"),
    Mt("itemClass"),
    Os("onHighlight"),
    Os("onDehighlight")
  ];
  const yn = Xi({
    fields: wo,
    name: "highlighting",
    apis: un
  }), Ks = [8], yr = [9], ur = [13], nl = [27], ni = [32], sm = [37], fh = [38], mh = [39], sr = [40], mc = (t, r, l) => {
    const d = qn(t.slice(0, r)), h = qn(t.slice(r + 1));
    return Nt(d.concat(h), l);
  }, pc = (t, r, l) => {
    const d = qn(t.slice(0, r));
    return Nt(d, l);
  }, Qu = (t, r, l) => {
    const d = t.slice(0, r), h = t.slice(r + 1);
    return Nt(h.concat(d), l);
  }, Ju = (t, r, l) => {
    const d = t.slice(r + 1);
    return Nt(d, l);
  }, bs = (t) => (r) => {
    const l = r.raw;
    return pn(t, l.which);
  }, Oa = (t) => (r) => An(t, (l) => l(r)), rm = (t) => t.raw.shiftKey === !0, B1 = (t) => t.raw.ctrlKey === !0, nu = Ue(rm), zo = (t, r) => ({
    matches: t,
    classification: r
  }), UC = (t, r) => Nt(t, (d) => d.matches(r)).map((d) => d.classification), jC = (t, r, l) => {
    r.exists((h) => l.exists((y) => Is(y, h))) || po(t, og(), {
      prevFocus: r,
      newFocus: l
    });
  }, bx = () => {
    const t = (l) => cc(l.element);
    return {
      get: t,
      set: (l, d) => {
        const h = t(l);
        l.getSystem().triggerFocus(d, l.element);
        const y = t(l);
        jC(l, h, y);
      }
    };
  }, XE = () => {
    const t = (l) => yn.getHighlighted(l).map((d) => d.element);
    return {
      get: t,
      set: (l, d) => {
        const h = t(l);
        l.getSystem().getByDom(d).fold(U, (w) => {
          yn.highlight(l, w);
        });
        const y = t(l);
        jC(l, h, y);
      }
    };
  };
  var Mg;
  (function(t) {
    t.OnFocusMode = "onFocus", t.OnEnterOrSpaceMode = "onEnterOrSpace", t.OnApiMode = "onApi";
  })(Mg || (Mg = {}));
  const Xm = (t, r, l, d, h) => {
    const y = () => t.concat([
      Xe("focusManager", bx()),
      Wc("focusInside", "onFocus", Jh((F) => pn([
        "onFocus",
        "onEnterOrSpace",
        "onApi"
      ], F) ? Ho.value(F) : Ho.error("Invalid value for focusInside"))),
      Ur("handler", O),
      Ur("state", r),
      Ur("sendFocusIn", h)
    ]), w = (F, L, q, ne, ae) => {
      const de = q(F, L, ne, ae);
      return UC(de, L.event).bind((_e) => _e(F, L, ne, ae));
    }, O = {
      schema: y,
      processKey: w,
      toEvents: (F, L) => {
        const q = F.focusInside !== Mg.OnFocusMode ? B.none() : h(F).map((de) => Ft(sf(), (_e, st) => {
          de(_e, F, L), st.stop();
        })), ne = (de, _e) => {
          const st = bs(ni.concat(ur))(_e.event);
          F.focusInside === Mg.OnEnterOrSpaceMode && st && Uu(de, _e) && h(F).each((Re) => {
            Re(de, F, L), _e.stop();
          });
        }, ae = [
          Ft(Ed(), (de, _e) => {
            w(de, _e, l, F, L).fold(() => {
              ne(de, _e);
            }, (st) => {
              _e.stop();
            });
          }),
          Ft(Gb(), (de, _e) => {
            w(de, _e, d, F, L).each((st) => {
              _e.stop();
            });
          })
        ];
        return zr(q.toArray().concat(ae));
      }
    };
    return O;
  }, QE = (t) => {
    const r = [
      $s("onEscape"),
      $s("onEnter"),
      Xe("selector", '[data-alloy-tabstop="true"]:not(:disabled)'),
      Xe("firstTabstop", 0),
      Xe("useTabstopAt", ot),
      $s("visibilitySelector")
    ].concat([t]), l = (Re, Qe) => {
      const qe = Re.visibilitySelector.bind((Bt) => pf(Qe, Bt)).getOr(Qe);
      return Mr(qe) > 0;
    }, d = (Re, Qe) => {
      const qe = Rl(Re.element, Qe.selector), Bt = So(qe, (pt) => l(Qe, pt));
      return B.from(Bt[Qe.firstTabstop]);
    }, h = (Re, Qe) => Qe.focusManager.get(Re).bind((qe) => pf(qe, Qe.selector)), y = (Re, Qe) => l(Re, Qe) && Re.useTabstopAt(Qe), w = (Re, Qe, qe) => {
      d(Re, Qe).each((Bt) => {
        Qe.focusManager.set(Re, Bt);
      });
    }, E = (Re, Qe, qe, Bt, pt) => pt(Qe, qe, (en) => y(Bt, en)).fold(() => Bt.cyclic ? B.some(!0) : B.none(), (en) => (Bt.focusManager.set(Re, en), B.some(!0))), O = (Re, Qe, qe, Bt) => {
      const pt = Rl(Re.element, qe.selector);
      return h(Re, qe).bind((en) => Vn(pt, Vt(Is, en)).bind((It) => E(Re, pt, It, qe, Bt)));
    }, F = (Re, Qe, qe) => {
      const Bt = qe.cyclic ? mc : pc;
      return O(Re, Qe, qe, Bt);
    }, L = (Re, Qe, qe) => {
      const Bt = qe.cyclic ? Qu : Ju;
      return O(Re, Qe, qe, Bt);
    }, q = (Re) => Di(Re).bind(Xl).exists((Qe) => Is(Qe, Re)), ne = (Re, Qe, qe) => h(Re, qe).filter((Bt) => !qe.useTabstopAt(Bt)).bind((Bt) => (q(Bt) ? F : L)(Re, Qe, qe)), ae = (Re, Qe, qe) => qe.onEnter.bind((Bt) => Bt(Re, Qe)), de = (Re, Qe, qe) => qe.onEscape.bind((Bt) => Bt(Re, Qe)), _e = ee([
      zo(Oa([
        rm,
        bs(yr)
      ]), F),
      zo(bs(yr), L),
      zo(Oa([
        nu,
        bs(ur)
      ]), ae)
    ]), st = ee([
      zo(bs(nl), de),
      zo(bs(yr), ne)
    ]);
    return Xm(r, Hl.init, _e, st, () => B.some(w));
  };
  var L1 = QE(Vs("cyclic", _t)), xU = QE(Vs("cyclic", ot));
  const WC = (t, r, l) => (Qb(t, l, Wu()), B.some(!0)), yx = (t, r, l) => ib(l) && bs(ni)(r.event) ? B.none() : WC(t, r, l), $1 = (t, r) => B.some(!0), $D = [
    Xe("execute", yx),
    Xe("useSpace", !1),
    Xe("useEnter", !0),
    Xe("useControlEnter", !1),
    Xe("useDown", !1)
  ], oF = (t, r, l) => l.execute(t, r, t.element), sF = (t, r, l, d) => {
    const h = l.useSpace && !ib(t.element) ? ni : [], y = l.useEnter ? ur : [], w = l.useDown ? sr : [], E = h.concat(y).concat(w);
    return [zo(bs(E), oF)].concat(l.useControlEnter ? [zo(Oa([
      B1,
      bs(ur)
    ]), oF)] : []);
  }, wU = (t, r, l, d) => l.useSpace && !ib(t.element) ? [zo(bs(ni), $1)] : [];
  var rF = Xm($D, Hl.init, sF, wU, () => B.none());
  const HD = () => {
    const t = cr();
    return qc({
      readState: () => t.get().map((h) => ({
        numRows: String(h.numRows),
        numColumns: String(h.numColumns)
      })).getOr({
        numRows: "?",
        numColumns: "?"
      }),
      setGridSize: (h, y) => {
        t.set({
          numRows: h,
          numColumns: y
        });
      },
      getNumRows: () => t.get().map((h) => h.numRows),
      getNumColumns: () => t.get().map((h) => h.numColumns)
    });
  };
  var CU = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    flatgrid: HD,
    init: (t) => t.state(t)
  });
  const aF = (t) => (r, l, d, h) => {
    const y = t(r.element);
    return ZC(y, r, l, d, h);
  }, zD = (t, r) => {
    const l = By(t, r);
    return aF(l);
  }, VD = (t, r) => {
    const l = By(r, t);
    return aF(l);
  }, UD = (t) => (r, l, d, h) => ZC(t, r, l, d, h), ZC = (t, r, l, d, h) => d.focusManager.get(r).bind((w) => t(r.element, w, d, h)).map((w) => (d.focusManager.set(r, w), !0)), JE = UD, iF = UD, jD = UD, lF = (t) => t.offsetWidth <= 0 && t.offsetHeight <= 0, cF = (t) => !lF(t.dom), SU = (t, r) => Vn(t, r).map((l) => ({
    index: l,
    candidates: t
  })), Rd = (t, r, l) => {
    const d = (w) => Is(w, r), h = Rl(t, l), y = So(h, cF);
    return SU(y, d);
  }, uF = (t, r) => Vn(t, (l) => Is(r, l)), dF = (t, r, l, d) => {
    const h = Math.floor(r / l), y = r % l;
    return d(h, y).bind((w) => {
      const E = w.row * l + w.column;
      return E >= 0 && E < t.length ? B.some(t[E]) : B.none();
    });
  }, fF = (t, r, l, d, h) => dF(t, r, d, (y, w) => {
    const O = y === l - 1 ? t.length - y * d : d, F = Uv(w, h, 0, O - 1);
    return B.some({
      row: y,
      column: F
    });
  }), mF = (t, r, l, d, h) => dF(t, r, d, (y, w) => {
    const E = Uv(y, h, 0, l - 1), F = E === l - 1 ? t.length - E * d : d, L = Ad(w, 0, F - 1);
    return B.some({
      row: E,
      column: L
    });
  }), kU = (t, r, l, d) => fF(t, r, l, d, 1), xx = (t, r, l, d) => fF(t, r, l, d, -1), WD = (t, r, l, d) => mF(t, r, l, d, -1), _U = (t, r, l, d) => mF(t, r, l, d, 1), ZD = [
    Mt("selector"),
    Xe("execute", yx),
    ic("onEscape"),
    Xe("captureTab", !1),
    my()
  ], eT = (t, r, l) => {
    or(t.element, r.selector).each((d) => {
      r.focusManager.set(t, d);
    });
  }, GD = (t, r) => r.focusManager.get(t).bind((l) => pf(l, r.selector)), EU = (t, r, l, d) => GD(t, l).bind((h) => l.execute(t, r, h)), tT = (t) => (r, l, d, h) => Rd(r, l, d.selector).bind((y) => t(y.candidates, y.index, h.getNumRows().getOr(d.initSize.numRows), h.getNumColumns().getOr(d.initSize.numColumns))), pF = (t, r, l) => l.captureTab ? B.some(!0) : B.none(), TU = (t, r, l) => l.onEscape(t, r), hF = tT(xx), gF = tT(kU), vF = tT(WD), qD = tT(_U), AU = ee([
    zo(bs(sm), zD(hF, gF)),
    zo(bs(mh), VD(hF, gF)),
    zo(bs(fh), JE(vF)),
    zo(bs(sr), iF(qD)),
    zo(Oa([
      rm,
      bs(yr)
    ]), pF),
    zo(Oa([
      nu,
      bs(yr)
    ]), pF),
    zo(bs(ni.concat(ur)), EU)
  ]), OU = ee([
    zo(bs(nl), TU),
    zo(bs(ni), $1)
  ]);
  var DU = Xm(ZD, HD, AU, OU, () => B.some(eT));
  const bF = (t, r, l, d, h) => {
    const y = (E) => Gs(E) === "button" && tr(E, "disabled") === "disabled", w = (E, O, F) => h(E, O, d, 0, F.length - 1, F[O], (L) => y(F[L]) ? w(E, L, F) : B.from(F[L]));
    return Rd(t, l, r).bind((E) => {
      const O = E.index, F = E.candidates;
      return w(O, O, F);
    });
  }, H1 = (t, r, l, d) => bF(t, r, l, d, (h, y, w, E, O, F, L) => {
    const q = Ad(y + w, E, O);
    return q === h ? B.from(F) : L(q);
  }), GC = (t, r, l, d) => bF(t, r, l, d, (h, y, w, E, O, F, L) => {
    const q = Uv(y, w, E, O);
    return q === h ? B.none() : L(q);
  }), RU = [
    Mt("selector"),
    Xe("getInitial", B.none),
    Xe("execute", yx),
    ic("onEscape"),
    Xe("executeOnMove", !1),
    Xe("allowVertical", !0),
    Xe("allowHorizontal", !0),
    Xe("cycles", !0)
  ], KD = (t, r) => r.focusManager.get(t).bind((l) => pf(l, r.selector)), YD = (t, r, l) => KD(t, l).bind((d) => l.execute(t, r, d)), yF = (t, r, l) => {
    r.getInitial(t).orThunk(() => or(t.element, r.selector)).each((d) => {
      r.focusManager.set(t, d);
    });
  }, XD = (t, r, l) => (l.cycles ? GC : H1)(t, l.selector, r, -1), QD = (t, r, l) => (l.cycles ? GC : H1)(t, l.selector, r, 1), JD = (t) => (r, l, d, h) => t(r, l, d, h).bind(() => d.executeOnMove ? YD(r, l, d) : B.some(!0)), xF = (t, r, l) => l.onEscape(t, r), NU = (t, r, l, d) => {
    const h = [...l.allowHorizontal ? sm : []].concat(l.allowVertical ? fh : []), y = [...l.allowHorizontal ? mh : []].concat(l.allowVertical ? sr : []);
    return [
      zo(bs(h), JD(zD(XD, QD))),
      zo(bs(y), JD(VD(XD, QD))),
      zo(bs(ur), YD),
      zo(bs(ni), YD)
    ];
  }, PU = ee([
    zo(bs(ni), $1),
    zo(bs(nl), xF)
  ]);
  var MU = Xm(RU, Hl.init, NU, PU, () => B.some(yF));
  const wx = (t, r, l) => B.from(t[r]).bind((d) => B.from(d[l]).map((h) => ({
    rowIndex: r,
    columnIndex: l,
    cell: h
  }))), wF = (t, r, l, d) => {
    const y = t[r].length, w = Uv(l, d, 0, y - 1);
    return wx(t, r, w);
  }, qC = (t, r, l, d) => {
    const h = Uv(l, d, 0, t.length - 1), y = t[h].length, w = Ad(r, 0, y - 1);
    return wx(t, h, w);
  }, CF = (t, r, l, d) => {
    const y = t[r].length, w = Ad(l + d, 0, y - 1);
    return wx(t, r, w);
  }, eR = (t, r, l, d) => {
    const h = Ad(l + d, 0, t.length - 1), y = t[h].length, w = Ad(r, 0, y - 1);
    return wx(t, h, w);
  }, ou = (t, r, l) => wF(t, r, l, 1), IU = (t, r, l) => wF(t, r, l, -1), SF = (t, r, l) => qC(t, l, r, -1), kF = (t, r, l) => qC(t, l, r, 1), FU = (t, r, l) => CF(t, r, l, -1), _F = (t, r, l) => CF(t, r, l, 1), EF = (t, r, l) => eR(t, l, r, -1), BU = (t, r, l) => eR(t, l, r, 1), LU = [
    tf("selectors", [
      Mt("row"),
      Mt("cell")
    ]),
    Xe("cycles", !0),
    Xe("previousSelector", B.none),
    Xe("execute", yx)
  ], $U = (t, r, l) => {
    r.previousSelector(t).orThunk(() => {
      const h = r.selectors;
      return or(t.element, h.cell);
    }).each((h) => {
      r.focusManager.set(t, h);
    });
  }, HU = (t, r, l) => cc(t.element).bind((d) => l.execute(t, r, d)), TF = (t, r) => et(t, (l) => Rl(l, r.selectors.cell)), nT = (t, r) => (l, d, h) => {
    const y = h.cycles ? t : r;
    return pf(d, h.selectors.row).bind((w) => {
      const E = Rl(w, h.selectors.cell);
      return uF(E, d).bind((O) => {
        const F = Rl(l, h.selectors.row);
        return uF(F, w).bind((L) => {
          const q = TF(F, h);
          return y(q, L, O).map((ne) => ne.cell);
        });
      });
    });
  }, AF = nT(IU, FU), tR = nT(ou, _F), OF = nT(SF, EF), DF = nT(kF, BU), zU = ee([
    zo(bs(sm), zD(AF, tR)),
    zo(bs(mh), VD(AF, tR)),
    zo(bs(fh), JE(OF)),
    zo(bs(sr), iF(DF)),
    zo(bs(ni.concat(ur)), HU)
  ]), VU = ee([zo(bs(ni), $1)]);
  var UU = Xm(LU, Hl.init, zU, VU, () => B.some($U));
  const jU = [
    Mt("selector"),
    Xe("execute", yx),
    Xe("moveOnTab", !1)
  ], nR = (t, r, l) => l.focusManager.get(t).bind((d) => l.execute(t, r, d)), RF = (t, r, l) => {
    or(t.element, r.selector).each((d) => {
      r.focusManager.set(t, d);
    });
  }, Ig = (t, r, l) => GC(t, l.selector, r, -1), oR = (t, r, l) => GC(t, l.selector, r, 1), NF = (t, r, l, d) => l.moveOnTab ? jD(Ig)(t, r, l, d) : B.none(), PF = (t, r, l, d) => l.moveOnTab ? jD(oR)(t, r, l, d) : B.none(), WU = ee([
    zo(bs(fh), jD(Ig)),
    zo(bs(sr), jD(oR)),
    zo(Oa([
      rm,
      bs(yr)
    ]), NF),
    zo(Oa([
      nu,
      bs(yr)
    ]), PF),
    zo(bs(ur), nR),
    zo(bs(ni), nR)
  ]), Cx = ee([zo(bs(ni), $1)]);
  var ZU = Xm(jU, Hl.init, WU, Cx, () => B.some(RF));
  const GU = [
    ic("onSpace"),
    ic("onEnter"),
    ic("onShiftEnter"),
    ic("onLeft"),
    ic("onRight"),
    ic("onTab"),
    ic("onShiftTab"),
    ic("onUp"),
    ic("onDown"),
    ic("onEscape"),
    Xe("stopSpaceKeyup", !1),
    $s("focusIn")
  ], MF = (t, r, l) => [
    zo(bs(ni), l.onSpace),
    zo(Oa([
      nu,
      bs(ur)
    ]), l.onEnter),
    zo(Oa([
      rm,
      bs(ur)
    ]), l.onShiftEnter),
    zo(Oa([
      rm,
      bs(yr)
    ]), l.onShiftTab),
    zo(Oa([
      nu,
      bs(yr)
    ]), l.onTab),
    zo(bs(fh), l.onUp),
    zo(bs(sr), l.onDown),
    zo(bs(sm), l.onLeft),
    zo(bs(mh), l.onRight),
    zo(bs(ni), l.onSpace)
  ], qU = (t, r, l) => [
    ...l.stopSpaceKeyup ? [zo(bs(ni), $1)] : [],
    zo(bs(nl), l.onEscape)
  ];
  var KU = Xm(GU, Hl.init, MF, qU, (t) => t.focusIn);
  const YU = L1.schema(), IF = xU.schema(), sR = MU.schema(), rR = DU.schema(), XU = UU.schema(), cb = rF.schema(), FF = ZU.schema(), BF = KU.schema();
  var QU = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    acyclic: YU,
    cyclic: IF,
    flow: sR,
    flatgrid: rR,
    matrix: XU,
    execution: cb,
    menu: FF,
    special: BF
  });
  const JU = (t) => Lr(t, "setGridSize"), so = f_({
    branchKey: "mode",
    branches: QU,
    name: "keying",
    active: {
      events: (t, r) => t.handler.toEvents(t, r)
    },
    apis: {
      focusIn: (t, r, l) => {
        r.sendFocusIn(r).fold(() => {
          t.getSystem().triggerFocus(t.element, t.element);
        }, (d) => {
          d(t, r, l);
        });
      },
      setGridSize: (t, r, l, d, h) => {
        JU(l) ? l.setGridSize(d, h) : console.error("Layout does not support setGridSize");
      }
    },
    state: CU
  }), Sx = (t, r) => {
    Jp(() => {
      eb(t, r, () => et(r, t.getSystem().build));
    }, t.element);
  }, aR = (t, r) => {
    Jp(() => {
      CC(t, r, () => f1(t.element, r, t.getSystem().buildOrPatch));
    }, t.element);
  }, iR = (t, r, l, d) => {
    Jy(r);
    const h = qu(t.element, l, d, t.getSystem().buildOrPatch);
    xC(t, h), t.syncComponents();
  }, ph = (t, r, l) => {
    const d = t.getSystem().build(l);
    Ag(t, d, r);
  }, ub = (t, r, l, d) => {
    Gm(r), ph(t, (h, y) => Ya(h, y, l), d);
  }, ej = (t, r, l, d) => (r.reuseDom ? aR : Sx)(t, d), tj = (t, r, l, d) => {
    ph(t, qi, d);
  }, LF = (t, r, l, d) => {
    ph(t, wp, d);
  }, Fg = (t, r, l, d) => {
    const h = kx(t);
    Nt(h, (w) => Is(d.element, w.element)).each(Gm);
  }, kx = (t, r) => t.components(), $F = (t, r, l, d, h) => {
    const y = kx(t);
    return B.from(y[d]).map((w) => (h.fold(() => Gm(w), (E) => {
      (r.reuseDom ? iR : ub)(t, w, d, E);
    }), w));
  };
  var HF = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    append: tj,
    prepend: LF,
    remove: Fg,
    replaceAt: $F,
    replaceBy: (t, r, l, d, h) => {
      const y = kx(t);
      return Vn(y, d).bind((w) => $F(t, r, l, w, h));
    },
    set: ej,
    contents: kx
  });
  const Po = Xi({
    fields: [Ea("reuseDom", !0)],
    name: "replacing",
    apis: HF
  }), lR = (t, r) => {
    const l = zr(r);
    return Xi({
      fields: [Mt("enabled")],
      name: t,
      active: { events: ee(l) }
    });
  }, jo = (t, r) => {
    const l = lR(t, r);
    return {
      key: t,
      value: {
        config: {},
        me: l,
        configAsRaw: ee({}),
        initialConfig: {},
        state: Hl
      }
    };
  }, zF = (t, r) => {
    r.ignore || (vu(t.element), r.onFocus(t));
  };
  var oT = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    focus: zF,
    blur: (t, r) => {
      r.ignore || h1(t.element);
    },
    isFocused: (t) => g1(t.element)
  }), UF = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, r) => {
      const l = r.ignore ? {} : { attributes: { tabindex: "-1" } };
      return Gc(l);
    },
    events: (t) => zr([Ft(sf(), (r, l) => {
      zF(r, t), l.stop();
    })].concat(t.stopMousedown ? [Ft(sc(), (r, l) => {
      l.event.prevent();
    })] : []))
  }), oj = [
    Os("onFocus"),
    Xe("stopMousedown", !1),
    Xe("ignore", !1)
  ];
  const To = Xi({
    fields: oj,
    name: "focusing",
    active: UF,
    apis: oT
  }), jF = (t) => ({ init: () => {
    const l = to(t);
    return {
      get: () => l.get(),
      set: (E) => l.set(E),
      clear: () => l.set(t),
      readState: () => l.get()
    };
  } }), WF = (t, r, l) => {
    const d = r.aria;
    d.update(t, d, l.get());
  }, ZF = (t, r, l) => {
    r.toggleClass.each((d) => {
      l.get() ? Vr(t.element, d) : ba(t.element, d);
    });
  }, KC = (t, r, l, d) => {
    const h = l.get();
    l.set(d), ZF(t, r, l), WF(t, r, l), h !== d && r.onToggled(t, d);
  }, sT = (t, r, l) => {
    KC(t, r, l, !l.get());
  }, sj = (t, r, l) => {
    KC(t, r, l, !0);
  }, rj = (t, r, l) => {
    KC(t, r, l, !1);
  }, aj = (t, r, l) => l.get(), GF = (t, r, l) => {
    KC(t, r, l, r.selected);
  };
  var qF = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    onLoad: GF,
    toggle: sT,
    isOn: aj,
    on: sj,
    off: rj,
    set: KC
  }), KF = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: () => Gc({}),
    events: (t, r) => {
      const l = t1(t, r, sT), d = lw(t, r, GF);
      return zr(tn([
        t.toggleOnExecute ? [l] : [],
        [d]
      ]));
    }
  });
  const YC = (t, r, l) => {
    sn(t.element, "aria-pressed", l), r.syncWithExpanded && rT(t, r, l);
  }, ij = (t, r, l) => {
    sn(t.element, "aria-selected", l);
  }, XC = (t, r, l) => {
    sn(t.element, "aria-checked", l);
  }, rT = (t, r, l) => {
    sn(t.element, "aria-expanded", l);
  };
  var YF = [
    Xe("selected", !1),
    $s("toggleClass"),
    Xe("toggleOnExecute", !0),
    Os("onToggled"),
    Wc("aria", { mode: "none" }, ui("mode", {
      pressed: [
        Xe("syncWithExpanded", !1),
        Ur("update", YC)
      ],
      checked: [Ur("update", XC)],
      expanded: [Ur("update", rT)],
      selected: [Ur("update", ij)],
      none: [Ur("update", U)]
    }))
  ];
  const ns = Xi({
    fields: YF,
    name: "toggling",
    active: KF,
    apis: qF,
    state: jF(!1)
  }), XF = () => {
    const t = (r, l) => {
      l.stop(), Hp(r);
    };
    return [
      Ft(tg(), t),
      Ft(rf(), t),
      lf(vs()),
      lf(sc())
    ];
  }, aT = (t) => {
    const r = (l) => Td((d, h) => {
      l(d), h.stop();
    });
    return zr(tn([
      t.map(r).toArray(),
      XF()
    ]));
  }, uR = "alloy.item-hover", QF = "alloy.item-focus", dR = "alloy.item-toggled", JF = (t) => {
    (cc(t.element).isNone() || To.isFocused(t)) && (To.isFocused(t) || To.focus(t), po(t, uR, { item: t }));
  }, eB = (t) => {
    po(t, QF, { item: t });
  }, tB = (t, r) => {
    po(t, dR, {
      item: t,
      state: r
    });
  }, QC = ee(uR), fR = ee(QF), mR = ee(dR), lj = (t) => t.role.fold(() => t.toggling.map((r) => r.exclusive ? "menuitemradio" : "menuitemcheckbox").getOr("menuitem"), lt), cj = (t, r) => ({
    aria: { mode: r ? "selected" : "checked" },
    ...pr(t, (l, d) => d !== "exclusive"),
    onToggled: (l, d) => {
      ye(t.onToggled) && t.onToggled(l, d), tB(l, d);
    }
  }), uj = (t) => ({
    dom: t.dom,
    domModification: {
      ...t.domModification,
      attributes: {
        role: lj(t),
        ...t.domModification.attributes,
        "aria-haspopup": t.hasSubmenu,
        ...t.hasSubmenu ? { "aria-expanded": !1 } : {}
      }
    },
    behaviours: Yu.augment(t.itemBehaviours, [
      t.toggling.fold(ns.revoke, (r) => ns.config(cj(r, t.role.exists((l) => l === "option")))),
      To.config({
        ignore: t.ignoreFocus,
        stopMousedown: t.ignoreFocus,
        onFocus: (r) => {
          eB(r);
        }
      }),
      so.config({ mode: "execution" }),
      In.config({
        store: {
          mode: "memory",
          initialValue: t.data
        }
      }),
      jo("item-type-events", [
        ...XF(),
        Ft(jf(), JF),
        Ft(qb(), To.focus)
      ])
    ]),
    components: t.components,
    eventOrder: t.eventOrder
  }), dj = [
    Mt("data"),
    Mt("components"),
    Mt("dom"),
    Xe("hasSubmenu", !1),
    $s("toggling"),
    $s("role"),
    Yu.field("itemBehaviours", [
      ns,
      To,
      so,
      In
    ]),
    Xe("ignoreFocus", !1),
    Xe("domModification", {}),
    Ur("builder", uj),
    Xe("eventOrder", {})
  ], nB = (t) => ({
    dom: t.dom,
    components: t.components,
    events: zr([aw(qb())])
  }), oB = [
    Mt("dom"),
    Mt("components"),
    Ur("builder", nB)
  ], pR = ee("item-widget"), hR = ee([hl({
    name: "widget",
    overrides: (t) => ({
      behaviours: Jt([In.config({
        store: {
          mode: "manual",
          getValue: (r) => t.data,
          setValue: U
        }
      })])
    })
  })]), fj = (t) => {
    const r = hx(pR(), t, hR()), l = FC(pR(), t, r.internals()), d = (y) => Qt(y, t, "widget").map((w) => (so.focusIn(w), w)), h = (y, w) => ib(w.event.target) ? B.none() : (t.autofocus && w.setSource(y.element), B.none());
    return {
      dom: t.dom,
      components: l,
      domModification: t.domModification,
      events: zr([
        Td((y, w) => {
          d(y).each((E) => {
            w.stop();
          });
        }),
        Ft(jf(), JF),
        Ft(qb(), (y, w) => {
          t.autofocus ? d(y) : To.focus(y);
        })
      ]),
      behaviours: Yu.augment(t.widgetBehaviours, [
        In.config({
          store: {
            mode: "memory",
            initialValue: t.data
          }
        }),
        To.config({
          ignore: t.ignoreFocus,
          onFocus: (y) => {
            eB(y);
          }
        }),
        so.config({
          mode: "special",
          focusIn: t.autofocus ? (y) => {
            d(y);
          } : Kr(),
          onLeft: h,
          onRight: h,
          onEscape: (y, w) => !To.isFocused(y) && !t.autofocus ? (To.focus(y), B.some(!0)) : (t.autofocus && w.setSource(y.element), B.none())
        })
      ])
    };
  }, mj = [
    Mt("uid"),
    Mt("data"),
    Mt("components"),
    Mt("dom"),
    Xe("autofocus", !1),
    Xe("ignoreFocus", !1),
    Yu.field("widgetBehaviours", [
      In,
      To,
      so
    ]),
    Xe("domModification", {}),
    M1(hR()),
    Ur("builder", fj)
  ], pj = ui("type", {
    widget: mj,
    item: dj,
    separator: oB
  }), hj = (t, r) => ({
    mode: "flatgrid",
    selector: "." + t.markers.item,
    initSize: {
      numColumns: r.initSize.numColumns,
      numRows: r.initSize.numRows
    },
    focusManager: t.focusManager
  }), sB = (t, r) => ({
    mode: "matrix",
    selectors: {
      row: r.rowSelector,
      cell: "." + t.markers.item
    },
    previousSelector: r.previousSelector,
    focusManager: t.focusManager
  }), gj = (t, r) => ({
    mode: "menu",
    selector: "." + t.markers.item,
    moveOnTab: r.moveOnTab,
    focusManager: t.focusManager
  }), vj = ee([mx({
    factory: {
      sketch: (t) => {
        const r = El("menu.spec item", pj, t);
        return r.builder(r);
      }
    },
    name: "items",
    unit: "item",
    defaults: (t, r) => Ko(r, "uid") ? r : {
      ...r,
      uid: hg("item")
    },
    overrides: (t, r) => ({
      type: r.type,
      ignoreFocus: t.fakeFocus,
      domModification: { classes: [t.markers.item] }
    })
  })]), bj = ee([
    Ua("role"),
    Mt("value"),
    Mt("items"),
    Mt("dom"),
    Mt("components"),
    Xe("eventOrder", {}),
    $i("menuBehaviours", [
      yn,
      In,
      Ds,
      so
    ]),
    Wc("movement", {
      mode: "menu",
      moveOnTab: !0
    }, ui("mode", {
      grid: [
        my(),
        Ur("config", hj)
      ],
      matrix: [
        Ur("config", sB),
        Mt("rowSelector"),
        Xe("previousSelector", B.none)
      ],
      menu: [
        Xe("moveOnTab", !0),
        Ur("config", gj)
      ]
    })),
    xO(),
    Xe("fakeFocus", !1),
    Xe("focusManager", bx()),
    Os("onHighlight"),
    Os("onDehighlight"),
    Xe("showMenuRole", !0)
  ]), rB = ee("alloy.menu-focus"), yj = (t, r) => {
    const l = Rl(t.element, '[role="menuitemradio"][aria-checked="true"]');
    xt(l, (d) => {
      Is(d, r.element) || t.getSystem().getByDom(d).each((h) => {
        ns.off(h);
      });
    });
  }, z1 = (t, r, l, d) => ({
    uid: t.uid,
    dom: t.dom,
    markers: t.markers,
    behaviours: Hi(t.menuBehaviours, [
      yn.config({
        highlightClass: t.markers.selectedItem,
        itemClass: t.markers.item,
        onHighlight: t.onHighlight,
        onDehighlight: t.onDehighlight
      }),
      In.config({
        store: {
          mode: "memory",
          initialValue: t.value
        }
      }),
      Ds.config({ find: B.some }),
      so.config(t.movement.config(t, t.movement))
    ]),
    events: zr([
      Ft(fR(), (h, y) => {
        const w = y.event;
        h.getSystem().getByDom(w.target).each((E) => {
          yn.highlight(h, E), y.stop(), po(h, rB(), {
            menu: h,
            item: E
          });
        });
      }),
      Ft(QC(), (h, y) => {
        const w = y.event.item;
        yn.highlight(h, w);
      }),
      Ft(mR(), (h, y) => {
        const { item: w, state: E } = y.event;
        E && tr(w.element, "role") === "menuitemradio" && yj(h, w);
      })
    ]),
    components: r,
    eventOrder: t.eventOrder,
    ...t.showMenuRole ? { domModification: { attributes: { role: t.role.getOr("menu") } } } : {}
  }), V1 = Wl({
    name: "Menu",
    configFields: bj(),
    partFields: vj(),
    factory: z1
  }), xj = (t) => xn(t, (r, l) => ({
    k: r,
    v: l
  })), db = (t, r, l, d) => qt(l, d).bind((h) => qt(t, h).bind((y) => {
    const w = db(t, r, l, y);
    return B.some([y].concat(w));
  })).getOr([]), aB = (t, r) => {
    const l = {};
    it(t, (w, E) => {
      xt(w, (O) => {
        l[O] = E;
      });
    });
    const d = r, h = xj(r), y = kt(h, (w, E) => [E].concat(db(l, d, h, E)));
    return kt(l, (w) => qt(y, w).getOr([w]));
  }, wj = () => {
    const t = to({}), r = to({}), l = to({}), d = cr(), h = to({}), y = () => {
      t.set({}), r.set({}), l.set({}), d.clear();
    }, w = () => d.get().isNone(), E = (pt, en) => {
      r.set({
        ...r.get(),
        [pt]: {
          type: "prepared",
          menu: en
        }
      });
    }, O = (pt, en, bn, It) => {
      d.set(pt), t.set(bn), r.set(en), h.set(It);
      const Yn = aB(It, bn);
      l.set(Yn);
    }, F = (pt) => Ms(t.get(), (en, bn) => en === pt), L = (pt, en, bn) => _e(pt).bind((It) => F(pt).bind((Yn) => en(Yn).map((Fn) => ({
      triggeredMenu: It,
      triggeringItem: Fn,
      triggeringPath: bn
    })))), q = (pt, en) => {
      const bn = So(Re(pt).toArray(), (It) => _e(It).isSome());
      return qt(l.get(), pt).bind((It) => {
        const Yn = qn(bn.concat(It)), Fn = je(Yn, (yo, mo) => L(yo, en, Yn.slice(0, mo + 1)).fold(() => ha(d.get(), yo) ? [] : [B.none()], (js) => [B.some(js)]));
        return ks(Fn);
      });
    }, ne = (pt) => qt(t.get(), pt).map((en) => {
      const bn = qt(l.get(), pt).getOr([]);
      return [en].concat(bn);
    }), ae = (pt) => qt(l.get(), pt).bind((en) => en.length > 1 ? B.some(en.slice(1)) : B.none()), de = (pt) => qt(l.get(), pt), _e = (pt) => st(pt).bind(Bg), st = (pt) => qt(r.get(), pt), Re = (pt) => qt(t.get(), pt);
    return {
      setMenuBuilt: E,
      setContents: O,
      expand: ne,
      refresh: de,
      collapse: ae,
      lookupMenu: st,
      lookupItem: Re,
      otherMenus: (pt) => {
        const en = h.get();
        return on(os(en), pt);
      },
      getPrimary: () => d.get().bind(_e),
      getMenus: () => r.get(),
      clear: y,
      isClear: w,
      getTriggeringPath: q
    };
  }, Bg = (t) => t.type === "prepared" ? B.some(t.menu) : B.none(), iB = {
    init: wj,
    extractPreparedMenu: Bg
  }, lB = Mn("tiered-menu-item-highlight"), Nd = Mn("tiered-menu-item-dehighlight");
  var Pc;
  (function(t) {
    t[t.HighlightMenuAndItem = 0] = "HighlightMenuAndItem", t[t.HighlightJustMenu = 1] = "HighlightJustMenu", t[t.HighlightNone = 2] = "HighlightNone";
  })(Pc || (Pc = {}));
  const cB = (t, r) => {
    const l = cr(), d = (cn, Un, Vo) => kt(Vo, (Co, ho) => {
      const $o = () => V1.sketch({
        ...Co,
        value: ho,
        markers: t.markers,
        fakeFocus: t.fakeFocus,
        onHighlight: (Er, Ys) => {
          po(Er, lB, {
            menuComp: Er,
            itemComp: Ys
          });
        },
        onDehighlight: (Er, Ys) => {
          po(Er, Nd, {
            menuComp: Er,
            itemComp: Ys
          });
        },
        focusManager: t.fakeFocus ? XE() : bx()
      });
      return ho === Un ? {
        type: "prepared",
        menu: cn.getSystem().build($o())
      } : {
        type: "notbuilt",
        nbMenu: $o
      };
    }), h = iB.init(), y = (cn) => {
      const Un = d(cn, t.data.primary, t.data.menus), Vo = O();
      return h.setContents(t.data.primary, Un, t.data.expansions, Vo), h.getPrimary();
    }, w = (cn) => In.getValue(cn).value, E = (cn, Un, Vo) => Qo(Un, (Co) => {
      if (!Co.getSystem().isConnected())
        return B.none();
      const ho = yn.getCandidates(Co);
      return Nt(ho, ($o) => w($o) === Vo);
    }), O = (cn) => kt(t.data.menus, (Un, Vo) => je(Un.items, (Co) => Co.type === "separator" ? [] : [Co.data.value])), F = yn.highlight, L = (cn, Un) => {
      F(cn, Un), yn.getHighlighted(Un).orThunk(() => yn.getFirst(Un)).each((Vo) => {
        t.fakeFocus ? yn.highlight(Un, Vo) : Qb(cn, Vo.element, qb());
      });
    }, q = (cn, Un) => na(et(Un, (Vo) => cn.lookupMenu(Vo).bind((Co) => Co.type === "prepared" ? B.some(Co.menu) : B.none()))), ne = (cn, Un, Vo) => {
      const Co = q(Un, Un.otherMenus(Vo));
      xt(Co, (ho) => {
        Yc(ho.element, [t.markers.backgroundMenu]), t.stayInDom || Po.remove(cn, ho);
      });
    }, ae = (cn) => l.get().getOrThunk(() => {
      const Un = {}, Vo = Rl(cn.element, `.${t.markers.item}`), Co = So(Vo, (ho) => tr(ho, "aria-haspopup") === "true");
      return xt(Co, (ho) => {
        cn.getSystem().getByDom(ho).each(($o) => {
          const Er = w($o);
          Un[Er] = $o;
        });
      }), l.set(Un), Un;
    }), de = (cn, Un) => {
      const Vo = ae(cn);
      it(Vo, (Co, ho) => {
        const $o = pn(Un, ho);
        sn(Co.element, "aria-expanded", $o);
      });
    }, _e = (cn, Un, Vo) => B.from(Vo[0]).bind((Co) => Un.lookupMenu(Co).bind((ho) => {
      if (ho.type === "notbuilt")
        return B.none();
      {
        const $o = ho.menu, Er = q(Un, Vo.slice(1));
        return xt(Er, (Ys) => {
          Vr(Ys.element, t.markers.backgroundMenu);
        }), hs($o.element) || Po.append(cn, Vl($o)), Yc($o.element, [t.markers.backgroundMenu]), L(cn, $o), ne(cn, Un, Vo), B.some($o);
      }
    }));
    let st;
    (function(cn) {
      cn[cn.HighlightSubmenu = 0] = "HighlightSubmenu", cn[cn.HighlightParent = 1] = "HighlightParent";
    })(st || (st = {}));
    const Re = (cn, Un, Vo) => {
      if (Vo.type === "notbuilt") {
        const Co = cn.getSystem().build(Vo.nbMenu());
        return h.setMenuBuilt(Un, Co), Co;
      } else
        return Vo.menu;
    }, Qe = (cn, Un, Vo = st.HighlightSubmenu) => {
      if (Un.hasConfigured(_o) && _o.isDisabled(Un))
        return B.some(Un);
      {
        const Co = w(Un);
        return h.expand(Co).bind((ho) => (de(cn, ho), B.from(ho[0]).bind(($o) => h.lookupMenu($o).bind((Er) => {
          const Ys = Re(cn, $o, Er);
          return hs(Ys.element) || Po.append(cn, Vl(Ys)), t.onOpenSubmenu(cn, Un, Ys, qn(ho)), Vo === st.HighlightSubmenu ? (yn.highlightFirst(Ys), _e(cn, h, ho)) : (yn.dehighlightAll(Ys), B.some(Un));
        }))));
      }
    }, qe = (cn, Un) => {
      const Vo = w(Un);
      return h.collapse(Vo).bind((Co) => (de(cn, Co), _e(cn, h, Co).map((ho) => (t.onCollapseMenu(cn, Un, ho), ho))));
    }, Bt = (cn, Un) => {
      const Vo = w(Un);
      return h.refresh(Vo).bind((Co) => (de(cn, Co), _e(cn, h, Co)));
    }, pt = (cn, Un) => ib(Un.element) ? B.none() : Qe(cn, Un, st.HighlightSubmenu), en = (cn, Un) => ib(Un.element) ? B.none() : qe(cn, Un), bn = (cn, Un) => qe(cn, Un).orThunk(() => t.onEscape(cn, Un).map(() => cn)), It = (cn) => (Un, Vo) => pf(Vo.getSource(), `.${t.markers.item}`).bind((Co) => Un.getSystem().getByDom(Co).toOptional().bind((ho) => cn(Un, ho).map(ot))), Yn = zr([
      Ft(rB(), (cn, Un) => {
        const Vo = Un.event.item;
        h.lookupItem(w(Vo)).each(() => {
          const Co = Un.event.menu;
          yn.highlight(cn, Co);
          const ho = w(Un.event.item);
          h.refresh(ho).each(($o) => ne(cn, h, $o));
        });
      }),
      Td((cn, Un) => {
        const Vo = Un.event.target;
        cn.getSystem().getByDom(Vo).each((Co) => {
          w(Co).indexOf("collapse-item") === 0 && qe(cn, Co), Qe(cn, Co, st.HighlightSubmenu).fold(() => {
            t.onExecute(cn, Co);
          }, U);
        });
      }),
      qr((cn, Un) => {
        y(cn).each((Vo) => {
          Po.append(cn, Vl(Vo)), t.onOpenMenu(cn, Vo), t.highlightOnOpen === Pc.HighlightMenuAndItem ? L(cn, Vo) : t.highlightOnOpen === Pc.HighlightJustMenu && F(cn, Vo);
        });
      }),
      Ft(lB, (cn, Un) => {
        t.onHighlightItem(cn, Un.event.menuComp, Un.event.itemComp);
      }),
      Ft(Nd, (cn, Un) => {
        t.onDehighlightItem(cn, Un.event.menuComp, Un.event.itemComp);
      }),
      ...t.navigateOnHover ? [Ft(QC(), (cn, Un) => {
        const Vo = Un.event.item;
        Bt(cn, Vo), Qe(cn, Vo, st.HighlightParent), t.onHover(cn, Vo);
      })] : []
    ]), Fn = (cn) => yn.getHighlighted(cn).bind(yn.getHighlighted), yo = (cn) => {
      Fn(cn).each((Un) => {
        qe(cn, Un);
      });
    }, mo = (cn) => {
      h.getPrimary().each((Un) => {
        L(cn, Un);
      });
    }, js = (cn) => B.from(cn.components()[0]).filter((Un) => tr(Un.element, "role") === "menu"), ms = {
      collapseMenu: yo,
      highlightPrimary: mo,
      repositionMenus: (cn) => {
        h.getPrimary().bind((Vo) => Fn(cn).bind((Co) => {
          const ho = w(Co), $o = hr(h.getMenus()), Er = na(et($o, iB.extractPreparedMenu));
          return h.getTriggeringPath(ho, (Ys) => E(cn, Er, Ys));
        }).map((Co) => ({
          primary: Vo,
          triggeringPath: Co
        }))).fold(() => {
          js(cn).each((Vo) => {
            t.onRepositionMenu(cn, Vo, []);
          });
        }, ({ primary: Vo, triggeringPath: Co }) => {
          t.onRepositionMenu(cn, Vo, Co);
        });
      }
    };
    return {
      uid: t.uid,
      dom: t.dom,
      markers: t.markers,
      behaviours: Hi(t.tmenuBehaviours, [
        so.config({
          mode: "special",
          onRight: It(pt),
          onLeft: It(en),
          onEscape: It(bn),
          focusIn: (cn, Un) => {
            h.getPrimary().each((Vo) => {
              Qb(cn, Vo.element, qb());
            });
          }
        }),
        yn.config({
          highlightClass: t.markers.selectedMenu,
          itemClass: t.markers.menu
        }),
        Ds.config({
          find: (cn) => yn.getHighlighted(cn)
        }),
        Po.config({})
      ]),
      eventOrder: t.eventOrder,
      apis: ms,
      events: Yn
    };
  }, uB = ee("collapse-item"), Cj = (t, r, l) => ({
    primary: t,
    menus: r,
    expansions: l
  }), iT = (t, r) => ({
    primary: t,
    menus: nr(t, r),
    expansions: {}
  }), dB = (t) => ({
    value: Mn(uB()),
    meta: { text: t }
  }), U1 = Nc({
    name: "TieredMenu",
    configFields: [
      Hm("onExecute"),
      Hm("onEscape"),
      Gu("onOpenMenu"),
      Gu("onOpenSubmenu"),
      Os("onRepositionMenu"),
      Os("onCollapseMenu"),
      Xe("highlightOnOpen", Pc.HighlightMenuAndItem),
      tf("data", [
        Mt("primary"),
        Mt("menus"),
        Mt("expansions")
      ]),
      Xe("fakeFocus", !1),
      Os("onHighlightItem"),
      Os("onDehighlightItem"),
      Os("onHover"),
      pg(),
      Mt("dom"),
      Xe("navigateOnHover", !0),
      Xe("stayInDom", !1),
      $i("tmenuBehaviours", [
        so,
        yn,
        Ds,
        Po
      ]),
      Xe("eventOrder", {})
    ],
    apis: {
      collapseMenu: (t, r) => {
        t.collapseMenu(r);
      },
      highlightPrimary: (t, r) => {
        t.highlightPrimary(r);
      },
      repositionMenus: (t, r) => {
        t.repositionMenus(r);
      }
    },
    factory: cB,
    extraApis: {
      tieredData: Cj,
      singleData: iT,
      collapseItem: dB
    }
  }), Sj = (t, r, l, d, h) => {
    const y = () => t.lazySink(r), w = d.type === "horizontal" ? {
      layouts: {
        onLtr: () => Ay(),
        onRtl: () => vg()
      }
    } : {}, E = (F) => F.length === 2, O = (F) => E(F) ? w : {};
    return U1.sketch({
      dom: { tag: "div" },
      data: d.data,
      markers: d.menu.markers,
      highlightOnOpen: d.menu.highlightOnOpen,
      fakeFocus: d.menu.fakeFocus,
      onEscape: () => (Ns.close(r), t.onEscape.map((F) => F(r)), B.some(!0)),
      onExecute: () => B.some(!0),
      onOpenMenu: (F, L) => {
        tl.positionWithinBounds(y().getOrDie(), L, l, h());
      },
      onOpenSubmenu: (F, L, q, ne) => {
        const ae = y().getOrDie();
        tl.position(ae, q, {
          anchor: {
            type: "submenu",
            item: L,
            ...O(ne)
          }
        });
      },
      onRepositionMenu: (F, L, q) => {
        const ne = y().getOrDie();
        tl.positionWithinBounds(ne, L, l, h()), xt(q, (ae) => {
          const de = O(ae.triggeringPath);
          tl.position(ne, ae.triggeredMenu, {
            anchor: {
              type: "submenu",
              item: ae.triggeringItem,
              ...de
            }
          });
        });
      }
    });
  }, lT = (t, r) => {
    const l = (ne, ae) => t.getRelated(ne).exists((_e) => qp(_e, ae)), d = (ne, ae) => {
      Ns.setContent(ne, ae);
    }, h = (ne, ae, de) => {
      const _e = B.none;
      y(ne, ae, de, _e);
    }, y = (ne, ae, de, _e) => {
      const st = t.lazySink(ne).getOrDie();
      Ns.openWhileCloaked(ne, ae, () => tl.positionWithinBounds(st, ne, de, _e())), In.setValue(ne, B.some({
        mode: "position",
        config: de,
        getBounds: _e
      }));
    }, w = (ne, ae, de) => {
      E(ne, ae, de, B.none);
    }, E = (ne, ae, de, _e) => {
      const st = Sj(t, ne, ae, de, _e);
      Ns.open(ne, st), In.setValue(ne, B.some({
        mode: "menu",
        menu: st
      }));
    }, O = (ne) => {
      Ns.isOpen(ne) && (In.setValue(ne, B.none()), Ns.close(ne));
    }, F = (ne) => Ns.getState(ne), L = (ne) => {
      Ns.isOpen(ne) && In.getValue(ne).each((ae) => {
        switch (ae.mode) {
          case "menu":
            Ns.getState(ne).each(U1.repositionMenus);
            break;
          case "position":
            const de = t.lazySink(ne).getOrDie();
            tl.positionWithinBounds(de, ne, ae.config, ae.getBounds());
            break;
        }
      });
    }, q = {
      setContent: d,
      showAt: h,
      showWithinBounds: y,
      showMenuAt: w,
      showMenuWithinBounds: E,
      hide: O,
      getContent: F,
      reposition: L,
      isOpen: Ns.isOpen
    };
    return {
      uid: t.uid,
      dom: t.dom,
      behaviours: Hi(t.inlineBehaviours, [
        Ns.config({
          isPartOf: (ne, ae, de) => qp(ae, de) || l(ne, de),
          getAttachPoint: (ne) => t.lazySink(ne).getOrDie(),
          onOpen: (ne) => {
            t.onShow(ne);
          },
          onClose: (ne) => {
            t.onHide(ne);
          }
        }),
        In.config({
          store: {
            mode: "memory",
            initialValue: B.none()
          }
        }),
        Rc.config({
          channels: {
            ...qm({
              isExtraPart: r.isExtraPart,
              ...t.fireDismissalEventInstead.map((ne) => ({ fireEventInstead: { event: ne.event } })).getOr({})
            }),
            ...nx({
              ...t.fireRepositionEventInstead.map((ne) => ({ fireEventInstead: { event: ne.event } })).getOr({}),
              doReposition: L
            })
          }
        })
      ]),
      eventOrder: t.eventOrder,
      apis: q
    };
  }, aa = Nc({
    name: "InlineView",
    configFields: [
      Mt("lazySink"),
      Os("onShow"),
      Os("onHide"),
      Cd("onEscape"),
      $i("inlineBehaviours", [
        Ns,
        In,
        Rc
      ]),
      kr("fireDismissalEventInstead", [Xe("event", Lp())]),
      kr("fireRepositionEventInstead", [Xe("event", tw())]),
      Xe("getRelated", B.none),
      Xe("isExtraPart", _t),
      Xe("eventOrder", B.none)
    ],
    factory: lT,
    apis: {
      showAt: (t, r, l, d) => {
        t.showAt(r, l, d);
      },
      showWithinBounds: (t, r, l, d, h) => {
        t.showWithinBounds(r, l, d, h);
      },
      showMenuAt: (t, r, l, d) => {
        t.showMenuAt(r, l, d);
      },
      showMenuWithinBounds: (t, r, l, d, h) => {
        t.showMenuWithinBounds(r, l, d, h);
      },
      hide: (t, r) => {
        t.hide(r);
      },
      isOpen: (t, r) => t.isOpen(r),
      getContent: (t, r) => t.getContent(r),
      setContent: (t, r, l) => {
        t.setContent(r, l);
      },
      reposition: (t, r) => {
        t.reposition(r);
      }
    }
  });
  var JC = tinymce.util.Tools.resolve("tinymce.util.Delay"), j1 = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), fB = tinymce.util.Tools.resolve("tinymce.EditorManager"), _x = tinymce.util.Tools.resolve("tinymce.Env"), ed;
  (function(t) {
    t.default = "wrap", t.floating = "floating", t.sliding = "sliding", t.scrolling = "scrolling";
  })(ed || (ed = {}));
  var Ex;
  (function(t) {
    t.auto = "auto", t.top = "top", t.bottom = "bottom";
  })(Ex || (Ex = {}));
  const Fr = (t) => (r) => r.options.get(t), eS = (t) => (r) => B.from(t(r)), mB = (t) => {
    const r = _x.deviceType.isPhone(), l = _x.deviceType.isTablet() || r, d = t.options.register, h = (w) => A(w) || w === !1, y = (w) => A(w) || re(w);
    d("skin", {
      processor: (w) => A(w) || w === !1,
      default: "oxide"
    }), d("skin_url", { processor: "string" }), d("height", {
      processor: y,
      default: Math.max(t.getElement().offsetHeight, 400)
    }), d("width", {
      processor: y,
      default: j1.DOM.getStyle(t.getElement(), "width")
    }), d("min_height", {
      processor: "number",
      default: 100
    }), d("min_width", { processor: "number" }), d("max_height", { processor: "number" }), d("max_width", { processor: "number" }), d("style_formats", { processor: "object[]" }), d("style_formats_merge", {
      processor: "boolean",
      default: !1
    }), d("style_formats_autohide", {
      processor: "boolean",
      default: !1
    }), d("line_height_formats", {
      processor: "string",
      default: "1 1.1 1.2 1.3 1.4 1.5 2"
    }), d("font_family_formats", {
      processor: "string",
      default: "Andale Mono=andale mono,monospace;Arial=arial,helvetica,sans-serif;Arial Black=arial black,sans-serif;Book Antiqua=book antiqua,palatino,serif;Comic Sans MS=comic sans ms,sans-serif;Courier New=courier new,courier,monospace;Georgia=georgia,palatino,serif;Helvetica=helvetica,arial,sans-serif;Impact=impact,sans-serif;Symbol=symbol;Tahoma=tahoma,arial,helvetica,sans-serif;Terminal=terminal,monaco,monospace;Times New Roman=times new roman,times,serif;Trebuchet MS=trebuchet ms,geneva,sans-serif;Verdana=verdana,geneva,sans-serif;Webdings=webdings;Wingdings=wingdings,zapf dingbats"
    }), d("font_size_formats", {
      processor: "string",
      default: "8pt 10pt 12pt 14pt 18pt 24pt 36pt"
    }), d("font_size_input_default_unit", {
      processor: "string",
      default: "pt"
    }), d("block_formats", {
      processor: "string",
      default: "Paragraph=p;Heading 1=h1;Heading 2=h2;Heading 3=h3;Heading 4=h4;Heading 5=h5;Heading 6=h6;Preformatted=pre"
    }), d("content_langs", { processor: "object[]" }), d("removed_menuitems", {
      processor: "string",
      default: ""
    }), d("menubar", {
      processor: (w) => A(w) || J(w),
      default: !r
    }), d("menu", {
      processor: "object",
      default: {}
    }), d("toolbar", {
      processor: (w) => J(w) || A(w) || Z(w) ? {
        value: w,
        valid: !0
      } : {
        valid: !1,
        message: "Must be a boolean, string or array."
      },
      default: !0
    }), Rt(9, (w) => {
      d("toolbar" + (w + 1), { processor: "string" });
    }), d("toolbar_mode", {
      processor: "string",
      default: l ? "scrolling" : "floating"
    }), d("toolbar_groups", {
      processor: "object",
      default: {}
    }), d("toolbar_location", {
      processor: "string",
      default: Ex.auto
    }), d("toolbar_persist", {
      processor: "boolean",
      default: !1
    }), d("toolbar_sticky", {
      processor: "boolean",
      default: t.inline
    }), d("toolbar_sticky_offset", {
      processor: "number",
      default: 0
    }), d("fixed_toolbar_container", {
      processor: "string",
      default: ""
    }), d("fixed_toolbar_container_target", { processor: "object" }), d("ui_mode", {
      processor: "string",
      default: "combined"
    }), d("file_picker_callback", { processor: "function" }), d("file_picker_validator_handler", { processor: "function" }), d("file_picker_types", { processor: "string" }), d("typeahead_urls", {
      processor: "boolean",
      default: !0
    }), d("anchor_top", {
      processor: h,
      default: "#top"
    }), d("anchor_bottom", {
      processor: h,
      default: "#bottom"
    }), d("draggable_modal", {
      processor: "boolean",
      default: !1
    }), d("statusbar", {
      processor: "boolean",
      default: !0
    }), d("elementpath", {
      processor: "boolean",
      default: !0
    }), d("branding", {
      processor: "boolean",
      default: !0
    }), d("promotion", {
      processor: "boolean",
      default: !0
    }), d("resize", {
      processor: (w) => w === "both" || J(w),
      default: !_x.deviceType.isTouch()
    }), d("sidebar_show", { processor: "string" }), d("help_accessibility", {
      processor: "boolean",
      default: t.hasPlugin("help")
    }), d("default_font_stack", {
      processor: "string[]",
      default: []
    });
  }, cT = Fr("readonly"), gR = Fr("height"), W1 = Fr("width"), Tx = eS(Fr("min_width")), uT = eS(Fr("min_height")), tS = eS(Fr("max_width")), vR = eS(Fr("max_height")), pB = eS(Fr("style_formats")), hB = Fr("style_formats_merge"), gB = Fr("style_formats_autohide"), dT = Fr("content_langs"), bR = Fr("removed_menuitems"), Z1 = Fr("toolbar_mode"), fT = Fr("toolbar_groups"), yR = Fr("toolbar_location"), vB = Fr("fixed_toolbar_container"), kj = Fr("fixed_toolbar_container_target"), bB = Fr("toolbar_persist"), yB = Fr("toolbar_sticky_offset"), xR = Fr("menubar"), mT = Fr("toolbar"), xB = Fr("file_picker_callback"), pT = Fr("file_picker_validator_handler"), wR = Fr("font_size_input_default_unit"), CR = Fr("file_picker_types"), wB = Fr("typeahead_urls"), hT = Fr("anchor_top"), CB = Fr("anchor_bottom"), SB = Fr("draggable_modal"), kB = Fr("statusbar"), _B = Fr("elementpath"), SR = Fr("branding"), kR = Fr("resize"), gT = Fr("paste_as_text"), EB = Fr("sidebar_show"), nS = Fr("promotion"), TB = Fr("help_accessibility"), AB = Fr("default_font_stack"), _R = (t) => t.options.get("skin") === !1, vT = (t) => t.options.get("menubar") !== !1, ER = (t) => {
    const r = t.options.get("skin_url");
    if (_R(t))
      return r;
    if (r)
      return t.documentBaseURI.toAbsolute(r);
    {
      const l = t.options.get("skin");
      return fB.baseURL + "/skins/ui/" + l;
    }
  }, bT = (t) => B.from(t.options.get("skin_url")), TR = (t) => t.options.get("line_height_formats").split(" "), yT = (t) => {
    const r = mT(t), l = A(r), d = Z(r) && r.length > 0;
    return !G1(t) && (d || l || r === !0);
  }, AR = (t) => {
    const r = Rt(9, (d) => t.options.get("toolbar" + (d + 1))), l = So(r, A);
    return Xn(l.length > 0, l);
  }, G1 = (t) => AR(t).fold(() => {
    const r = mT(t);
    return oe(r, A) && r.length > 0;
  }, ot), Lg = (t) => yR(t) === Ex.bottom, OB = (t) => {
    var r;
    if (!t.inline)
      return B.none();
    const l = (r = vB(t)) !== null && r !== void 0 ? r : "";
    if (l.length > 0)
      return or(Uo(), l);
    const d = kj(t);
    return be(d) ? B.some($e.fromDom(d)) : B.none();
  }, Ax = (t) => t.inline && OB(t).isSome(), oS = (t) => OB(t).getOrThunk(() => Oe(ie($e.fromDom(t.getElement())))), xT = (t) => t.inline && !vT(t) && !yT(t) && !G1(t), Ox = (t) => (t.options.get("toolbar_sticky") || t.inline) && !Ax(t) && !xT(t), fb = (t) => !Ax(t) && t.options.get("ui_mode") === "split", OR = (t) => {
    const r = t.options.get("menu");
    return kt(r, (l) => ({
      ...l,
      items: l.items
    }));
  };
  var _j = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    get ToolbarMode() {
      return ed;
    },
    get ToolbarLocation() {
      return Ex;
    },
    register: mB,
    getSkinUrl: ER,
    getSkinUrlOption: bT,
    isReadOnly: cT,
    isSkinDisabled: _R,
    getHeightOption: gR,
    getWidthOption: W1,
    getMinWidthOption: Tx,
    getMinHeightOption: uT,
    getMaxWidthOption: tS,
    getMaxHeightOption: vR,
    getUserStyleFormats: pB,
    shouldMergeStyleFormats: hB,
    shouldAutoHideStyleFormats: gB,
    getLineHeightFormats: TR,
    getContentLanguages: dT,
    getRemovedMenuItems: bR,
    isMenubarEnabled: vT,
    isMultipleToolbars: G1,
    isToolbarEnabled: yT,
    isToolbarPersist: bB,
    getMultipleToolbarsOption: AR,
    getUiContainer: oS,
    useFixedContainer: Ax,
    isSplitUiMode: fb,
    getToolbarMode: Z1,
    isDraggableModal: SB,
    isDistractionFree: xT,
    isStickyToolbar: Ox,
    getStickyToolbarOffset: yB,
    getToolbarLocation: yR,
    isToolbarLocationBottom: Lg,
    getToolbarGroups: fT,
    getMenus: OR,
    getMenubar: xR,
    getToolbar: mT,
    getFilePickerCallback: xB,
    getFilePickerTypes: CR,
    useTypeaheadUrls: wB,
    getAnchorTop: hT,
    getAnchorBottom: CB,
    getFilePickerValidatorHandler: pT,
    getFontSizeInputDefaultUnit: wR,
    useStatusBar: kB,
    useElementPath: _B,
    promotionEnabled: nS,
    useBranding: SR,
    getResize: kR,
    getPasteAsText: gT,
    getSidebarShow: EB,
    useHelpAccessibility: TB,
    getDefaultFontStack: AB
  });
  const DB = [
    "visible",
    "hidden",
    "clip"
  ], DR = (t) => Tr(t).length > 0 && !pn(DB, t), wT = (t) => {
    if (Ai(t)) {
      const r = lr(t, "overflow-x"), l = lr(t, "overflow-y");
      return DR(r) || DR(l);
    } else
      return !1;
  }, Ej = (t) => {
    const r = Xv(t, wT), l = r.length === 0 ? Dt(t).map(Xt).map((d) => Xv(d, wT)).getOr([]) : r;
    return ao(l).map((d) => ({
      element: d,
      others: l.slice(1)
    }));
  }, $g = (t, r) => fb(t) ? Ej(r) : B.none(), q1 = (t) => {
    const r = [
      ...et(t.others, sa),
      Na()
    ];
    return Kh(sa(t.element), r);
  }, Nl = Nc({
    name: "Button",
    factory: (t) => {
      const r = aT(t.action), l = t.dom.tag, d = (y) => qt(t.dom, "attributes").bind((w) => qt(w, y)), h = () => {
        if (l === "button") {
          const y = d("type").getOr("button"), w = d("role").map((E) => ({ role: E })).getOr({});
          return {
            type: y,
            ...w
          };
        } else
          return { role: t.role.getOr(d("role").getOr("button")) };
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: t.components,
        events: r,
        behaviours: Yu.augment(t.buttonBehaviours, [
          To.config({}),
          so.config({
            mode: "execution",
            useSpace: !0,
            useEnter: !0
          })
        ]),
        domModification: { attributes: h() },
        eventOrder: t.eventOrder
      };
    },
    configFields: [
      Xe("uid", void 0),
      Mt("dom"),
      Xe("components", []),
      Yu.field("buttonBehaviours", [
        To,
        so
      ]),
      $s("action"),
      $s("role"),
      Xe("eventOrder", {})
    ]
  }), Tj = (t) => {
    const r = t.dom.attributes !== void 0 ? t.dom.attributes : [];
    return Pt(r, (l, d) => d.name === "class" ? l : {
      ...l,
      [d.name]: d.value
    }, {});
  }, RR = (t) => Array.prototype.slice.call(t.dom.classList, 0), Qm = (t) => {
    const r = $e.fromHtml(t), l = La(r), d = Tj(r), h = RR(r), y = l.length === 0 ? {} : { innerHtml: Dc(r) };
    return {
      tag: Gs(r),
      classes: h,
      attributes: d,
      ...y
    };
  }, rr = (t) => {
    const r = ND(t) && Lr(t, "uid") ? t.uid : hg("memento");
    return {
      get: (y) => y.getSystem().getByUid(r).getOrDie(),
      getOpt: (y) => y.getSystem().getByUid(r).toOptional(),
      asSpec: () => ({
        ...t,
        uid: r
      })
    };
  };
  var Aj = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, r) => Gc({
      attributes: Us([{
        key: r.tabAttr,
        value: "true"
      }])
    })
  }), Oj = [Xe("tabAttr", "data-alloy-tabstop")];
  const jr = Xi({
    fields: Oj,
    name: "tabstopping",
    active: Aj
  }), NB = Mn("tooltip.exclusive"), sS = Mn("tooltip.show"), rS = Mn("tooltip.hide"), ST = Mn("tooltip.immediateHide"), kT = Mn("tooltip.immediateShow"), PB = (t, r, l) => {
    t.getSystem().broadcastOn([NB], {});
  };
  var Dj = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    hideAllExclusive: PB,
    setComponents: (t, r, l, d) => {
      l.getTooltip().each((h) => {
        h.getSystem().isConnected() && Po.set(h, d);
      });
    }
  }), Rj = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, r) => {
      const l = (w) => {
        r.getTooltip().each((E) => {
          E.getSystem().isConnected() && (Gm(E), t.onHide(w, E), r.clearTooltip());
        }), r.clearTimer();
      }, d = (w) => {
        if (!r.isShowing()) {
          PB(w);
          const E = t.lazySink(w).getOrDie(), O = w.getSystem().build({
            dom: t.tooltipDom,
            components: t.tooltipComponents,
            events: zr(t.mode === "normal" ? [
              Ft(jf(), (F) => {
                Xo(w, sS);
              }),
              Ft(_d(), (F) => {
                Xo(w, rS);
              })
            ] : []),
            behaviours: Jt([Po.config({})])
          });
          r.setTooltip(O), em(E, O), t.onShow(w, O), tl.position(E, O, { anchor: t.anchor(w) });
        }
      }, h = (w) => {
        r.getTooltip().each((E) => {
          const O = t.lazySink(w).getOrDie();
          tl.position(O, E, { anchor: t.anchor(w) });
        });
      }, y = () => {
        switch (t.mode) {
          case "normal":
            return [
              Ft(nf(), (w) => {
                Xo(w, kT);
              }),
              Ft(Bp(), (w) => {
                Xo(w, ST);
              }),
              Ft(jf(), (w) => {
                Xo(w, sS);
              }),
              Ft(_d(), (w) => {
                Xo(w, rS);
              })
            ];
          case "follow-highlight":
            return [
              Ft($p(), (w, E) => {
                Xo(w, sS);
              }),
              Ft(sg(), (w) => {
                Xo(w, rS);
              })
            ];
          case "children-normal":
            return [
              Ft(nf(), (w, E) => {
                cc(w.element).each((O) => {
                  gr(E.event.target, "[data-mce-tooltip]") && r.getTooltip().fold(() => {
                    Xo(w, kT);
                  }, (F) => {
                    r.isShowing() && (t.onShow(w, F), h(w));
                  });
                });
              }),
              Ft(Bp(), (w) => {
                cc(w.element).fold(() => {
                  Xo(w, ST);
                }, U);
              }),
              Ft(jf(), (w) => {
                or(w.element, "[data-mce-tooltip]:hover").each((E) => {
                  r.getTooltip().fold(() => {
                    Xo(w, sS);
                  }, (O) => {
                    r.isShowing() && (t.onShow(w, O), h(w));
                  });
                });
              }),
              Ft(_d(), (w) => {
                or(w.element, "[data-mce-tooltip]:hover").fold(() => {
                  Xo(w, rS);
                }, U);
              })
            ];
          default:
            return [
              Ft(nf(), (w, E) => {
                cc(w.element).each((O) => {
                  gr(E.event.target, "[data-mce-tooltip]") && r.getTooltip().fold(() => {
                    Xo(w, kT);
                  }, (F) => {
                    r.isShowing() && (t.onShow(w, F), h(w));
                  });
                });
              }),
              Ft(Bp(), (w) => {
                cc(w.element).fold(() => {
                  Xo(w, ST);
                }, U);
              })
            ];
        }
      };
      return zr(tn([
        [
          Ft(sS, (w) => {
            r.resetTimer(() => {
              d(w);
            }, t.delayForShow());
          }),
          Ft(rS, (w) => {
            r.resetTimer(() => {
              l(w);
            }, t.delayForHide());
          }),
          Ft(kT, (w) => {
            r.resetTimer(() => {
              d(w);
            }, 0);
          }),
          Ft(ST, (w) => {
            r.resetTimer(() => {
              l(w);
            }, 0);
          }),
          Ft(ju(), (w, E) => {
            const O = E;
            O.universal || pn(O.channels, NB) && l(w);
          }),
          qf((w) => {
            l(w);
          })
        ],
        y()
      ]));
    }
  }), Nj = [
    Mt("lazySink"),
    Mt("tooltipDom"),
    Xe("exclusive", !0),
    Xe("tooltipComponents", []),
    Ca("delayForShow", ee(300)),
    Ca("delayForHide", ee(300)),
    gu("mode", "normal", [
      "normal",
      "follow-highlight",
      "children-keyboard-focus",
      "children-normal"
    ]),
    Xe("anchor", (t) => ({
      type: "hotspot",
      hotspot: t,
      layouts: {
        onLtr: ee([
          ti,
          Si,
          fi,
          mi,
          ei,
          br
        ]),
        onRtl: ee([
          ti,
          Si,
          fi,
          mi,
          ei,
          br
        ])
      },
      bubble: Od(0, -2, {})
    })),
    Os("onHide"),
    Os("onShow")
  ], NR = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = cr(), r = cr(), l = () => {
        t.on(clearTimeout);
      }, d = (y, w) => {
        l(), t.set(setTimeout(y, w));
      }, h = ee("not-implemented");
      return qc({
        getTooltip: r.get,
        isShowing: r.isSet,
        setTooltip: r.set,
        clearTooltip: r.clear,
        clearTimer: l,
        resetTimer: d,
        readState: h
      });
    }
  });
  const gl = Xi({
    fields: Nj,
    name: "tooltipping",
    active: Rj,
    state: NR,
    apis: Dj
  }), { entries: MB, setPrototypeOf: IB, isFrozen: FB, getPrototypeOf: Pj, getOwnPropertyDescriptor: Mj } = Object;
  let { freeze: td, seal: Jm, create: Ij } = Object, { apply: PR, construct: aS } = typeof Reflect < "u" && Reflect;
  PR || (PR = function(r, l, d) {
    return r.apply(l, d);
  }), td || (td = function(r) {
    return r;
  }), Jm || (Jm = function(r) {
    return r;
  }), aS || (aS = function(r, l) {
    return new r(...l);
  });
  const Fj = am(Array.prototype.forEach), Bj = am(Array.prototype.pop), iS = am(Array.prototype.push), _T = am(String.prototype.toLowerCase), MR = am(String.prototype.toString), Lj = am(String.prototype.match), ep = am(String.prototype.replace), $j = am(String.prototype.indexOf), Hj = am(String.prototype.trim), bf = am(RegExp.prototype.test), lS = zj(TypeError);
  function am(t) {
    return function(r) {
      for (var l = arguments.length, d = new Array(l > 1 ? l - 1 : 0), h = 1; h < l; h++)
        d[h - 1] = arguments[h];
      return PR(t, r, d);
    };
  }
  function zj(t) {
    return function() {
      for (var r = arguments.length, l = new Array(r), d = 0; d < r; d++)
        l[d] = arguments[d];
      return aS(t, l);
    };
  }
  function dr(t, r, l) {
    var d;
    l = (d = l) !== null && d !== void 0 ? d : _T, IB && IB(t, null);
    let h = r.length;
    for (; h--; ) {
      let y = r[h];
      if (typeof y == "string") {
        const w = l(y);
        w !== y && (FB(r) || (r[h] = w), y = w);
      }
      t[y] = !0;
    }
    return t;
  }
  function Dx(t) {
    const r = Ij(null);
    for (const [l, d] of MB(t))
      r[l] = d;
    return r;
  }
  function Rx(t, r) {
    for (; t !== null; ) {
      const d = Mj(t, r);
      if (d) {
        if (d.get)
          return am(d.get);
        if (typeof d.value == "function")
          return am(d.value);
      }
      t = Pj(t);
    }
    function l(d) {
      return console.warn("fallback value for", d), null;
    }
    return l;
  }
  const BB = td([
    "a",
    "abbr",
    "acronym",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "bdi",
    "bdo",
    "big",
    "blink",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "center",
    "cite",
    "code",
    "col",
    "colgroup",
    "content",
    "data",
    "datalist",
    "dd",
    "decorator",
    "del",
    "details",
    "dfn",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "element",
    "em",
    "fieldset",
    "figcaption",
    "figure",
    "font",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meter",
    "nav",
    "nobr",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "section",
    "select",
    "shadow",
    "small",
    "source",
    "spacer",
    "span",
    "strike",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "track",
    "tt",
    "u",
    "ul",
    "var",
    "video",
    "wbr"
  ]), IR = td([
    "svg",
    "a",
    "altglyph",
    "altglyphdef",
    "altglyphitem",
    "animatecolor",
    "animatemotion",
    "animatetransform",
    "circle",
    "clippath",
    "defs",
    "desc",
    "ellipse",
    "filter",
    "font",
    "g",
    "glyph",
    "glyphref",
    "hkern",
    "image",
    "line",
    "lineargradient",
    "marker",
    "mask",
    "metadata",
    "mpath",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialgradient",
    "rect",
    "stop",
    "style",
    "switch",
    "symbol",
    "text",
    "textpath",
    "title",
    "tref",
    "tspan",
    "view",
    "vkern"
  ]), FR = td([
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence"
  ]), LB = td([
    "animate",
    "color-profile",
    "cursor",
    "discard",
    "font-face",
    "font-face-format",
    "font-face-name",
    "font-face-src",
    "font-face-uri",
    "foreignobject",
    "hatch",
    "hatchpath",
    "mesh",
    "meshgradient",
    "meshpatch",
    "meshrow",
    "missing-glyph",
    "script",
    "set",
    "solidcolor",
    "unknown",
    "use"
  ]), BR = td([
    "math",
    "menclose",
    "merror",
    "mfenced",
    "mfrac",
    "mglyph",
    "mi",
    "mlabeledtr",
    "mmultiscripts",
    "mn",
    "mo",
    "mover",
    "mpadded",
    "mphantom",
    "mroot",
    "mrow",
    "ms",
    "mspace",
    "msqrt",
    "mstyle",
    "msub",
    "msup",
    "msubsup",
    "mtable",
    "mtd",
    "mtext",
    "mtr",
    "munder",
    "munderover",
    "mprescripts"
  ]), LR = td([
    "maction",
    "maligngroup",
    "malignmark",
    "mlongdiv",
    "mscarries",
    "mscarry",
    "msgroup",
    "mstack",
    "msline",
    "msrow",
    "semantics",
    "annotation",
    "annotation-xml",
    "mprescripts",
    "none"
  ]), ET = td(["#text"]), $R = td([
    "accept",
    "action",
    "align",
    "alt",
    "autocapitalize",
    "autocomplete",
    "autopictureinpicture",
    "autoplay",
    "background",
    "bgcolor",
    "border",
    "capture",
    "cellpadding",
    "cellspacing",
    "checked",
    "cite",
    "class",
    "clear",
    "color",
    "cols",
    "colspan",
    "controls",
    "controlslist",
    "coords",
    "crossorigin",
    "datetime",
    "decoding",
    "default",
    "dir",
    "disabled",
    "disablepictureinpicture",
    "disableremoteplayback",
    "download",
    "draggable",
    "enctype",
    "enterkeyhint",
    "face",
    "for",
    "headers",
    "height",
    "hidden",
    "high",
    "href",
    "hreflang",
    "id",
    "inputmode",
    "integrity",
    "ismap",
    "kind",
    "label",
    "lang",
    "list",
    "loading",
    "loop",
    "low",
    "max",
    "maxlength",
    "media",
    "method",
    "min",
    "minlength",
    "multiple",
    "muted",
    "name",
    "nonce",
    "noshade",
    "novalidate",
    "nowrap",
    "open",
    "optimum",
    "pattern",
    "placeholder",
    "playsinline",
    "poster",
    "preload",
    "pubdate",
    "radiogroup",
    "readonly",
    "rel",
    "required",
    "rev",
    "reversed",
    "role",
    "rows",
    "rowspan",
    "spellcheck",
    "scope",
    "selected",
    "shape",
    "size",
    "sizes",
    "span",
    "srclang",
    "start",
    "src",
    "srcset",
    "step",
    "style",
    "summary",
    "tabindex",
    "title",
    "translate",
    "type",
    "usemap",
    "valign",
    "value",
    "width",
    "xmlns",
    "slot"
  ]), cS = td([
    "accent-height",
    "accumulate",
    "additive",
    "alignment-baseline",
    "ascent",
    "attributename",
    "attributetype",
    "azimuth",
    "basefrequency",
    "baseline-shift",
    "begin",
    "bias",
    "by",
    "class",
    "clip",
    "clippathunits",
    "clip-path",
    "clip-rule",
    "color",
    "color-interpolation",
    "color-interpolation-filters",
    "color-profile",
    "color-rendering",
    "cx",
    "cy",
    "d",
    "dx",
    "dy",
    "diffuseconstant",
    "direction",
    "display",
    "divisor",
    "dur",
    "edgemode",
    "elevation",
    "end",
    "fill",
    "fill-opacity",
    "fill-rule",
    "filter",
    "filterunits",
    "flood-color",
    "flood-opacity",
    "font-family",
    "font-size",
    "font-size-adjust",
    "font-stretch",
    "font-style",
    "font-variant",
    "font-weight",
    "fx",
    "fy",
    "g1",
    "g2",
    "glyph-name",
    "glyphref",
    "gradientunits",
    "gradienttransform",
    "height",
    "href",
    "id",
    "image-rendering",
    "in",
    "in2",
    "k",
    "k1",
    "k2",
    "k3",
    "k4",
    "kerning",
    "keypoints",
    "keysplines",
    "keytimes",
    "lang",
    "lengthadjust",
    "letter-spacing",
    "kernelmatrix",
    "kernelunitlength",
    "lighting-color",
    "local",
    "marker-end",
    "marker-mid",
    "marker-start",
    "markerheight",
    "markerunits",
    "markerwidth",
    "maskcontentunits",
    "maskunits",
    "max",
    "mask",
    "media",
    "method",
    "mode",
    "min",
    "name",
    "numoctaves",
    "offset",
    "operator",
    "opacity",
    "order",
    "orient",
    "orientation",
    "origin",
    "overflow",
    "paint-order",
    "path",
    "pathlength",
    "patterncontentunits",
    "patterntransform",
    "patternunits",
    "points",
    "preservealpha",
    "preserveaspectratio",
    "primitiveunits",
    "r",
    "rx",
    "ry",
    "radius",
    "refx",
    "refy",
    "repeatcount",
    "repeatdur",
    "restart",
    "result",
    "rotate",
    "scale",
    "seed",
    "shape-rendering",
    "specularconstant",
    "specularexponent",
    "spreadmethod",
    "startoffset",
    "stddeviation",
    "stitchtiles",
    "stop-color",
    "stop-opacity",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke",
    "stroke-width",
    "style",
    "surfacescale",
    "systemlanguage",
    "tabindex",
    "targetx",
    "targety",
    "transform",
    "transform-origin",
    "text-anchor",
    "text-decoration",
    "text-rendering",
    "textlength",
    "type",
    "u1",
    "u2",
    "unicode",
    "values",
    "viewbox",
    "visibility",
    "version",
    "vert-adv-y",
    "vert-origin-x",
    "vert-origin-y",
    "width",
    "word-spacing",
    "wrap",
    "writing-mode",
    "xchannelselector",
    "ychannelselector",
    "x",
    "x1",
    "x2",
    "xmlns",
    "y",
    "y1",
    "y2",
    "z",
    "zoomandpan"
  ]), uS = td([
    "accent",
    "accentunder",
    "align",
    "bevelled",
    "close",
    "columnsalign",
    "columnlines",
    "columnspan",
    "denomalign",
    "depth",
    "dir",
    "display",
    "displaystyle",
    "encoding",
    "fence",
    "frame",
    "height",
    "href",
    "id",
    "largeop",
    "length",
    "linethickness",
    "lspace",
    "lquote",
    "mathbackground",
    "mathcolor",
    "mathsize",
    "mathvariant",
    "maxsize",
    "minsize",
    "movablelimits",
    "notation",
    "numalign",
    "open",
    "rowalign",
    "rowlines",
    "rowspacing",
    "rowspan",
    "rspace",
    "rquote",
    "scriptlevel",
    "scriptminsize",
    "scriptsizemultiplier",
    "selection",
    "separator",
    "separators",
    "stretchy",
    "subscriptshift",
    "supscriptshift",
    "symmetric",
    "voffset",
    "width",
    "xmlns"
  ]), dS = td([
    "xlink:href",
    "xml:id",
    "xlink:title",
    "xml:space",
    "xmlns:xlink"
  ]), hh = Jm(/\{\{[\w\W]*|[\w\W]*\}\}/gm), HR = Jm(/<%[\w\W]*|[\w\W]*%>/gm), Vj = Jm(/\${[\w\W]*}/gm), Uj = Jm(/^data-[\-\w.\u00B7-\uFFFF]/), jj = Jm(/^aria-[\-\w]+$/), $B = Jm(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), fS = Jm(/^(?:\w+script|data):/i), Wj = Jm(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), zR = Jm(/^html$/i);
  var TT = Object.freeze({
    __proto__: null,
    MUSTACHE_EXPR: hh,
    ERB_EXPR: HR,
    TMPLIT_EXPR: Vj,
    DATA_ATTR: Uj,
    ARIA_ATTR: jj,
    IS_ALLOWED_URI: $B,
    IS_SCRIPT_OR_DATA: fS,
    ATTR_WHITESPACE: Wj,
    DOCTYPE_NAME: zR
  });
  const Zj = () => typeof window > "u" ? null : window, VR = function(r, l) {
    if (typeof r != "object" || typeof r.createPolicy != "function")
      return null;
    let d = null;
    const h = "data-tt-policy-suffix";
    l && l.hasAttribute(h) && (d = l.getAttribute(h));
    const y = "dompurify" + (d ? "#" + d : "");
    try {
      return r.createPolicy(y, {
        createHTML(w) {
          return w;
        },
        createScriptURL(w) {
          return w;
        }
      });
    } catch {
      return console.warn("TrustedTypes policy " + y + " could not be created."), null;
    }
  };
  function AT() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Zj();
    const r = (Ts) => AT(Ts);
    if (r.version = "3.0.5", r.removed = [], !t || !t.document || t.document.nodeType !== 9)
      return r.isSupported = !1, r;
    const l = t.document, d = l.currentScript;
    let { document: h } = t;
    const { DocumentFragment: y, HTMLTemplateElement: w, Node: E, Element: O, NodeFilter: F, NamedNodeMap: L = t.NamedNodeMap || t.MozNamedAttrMap, HTMLFormElement: q, DOMParser: ne, trustedTypes: ae } = t, de = O.prototype, _e = Rx(de, "cloneNode"), st = Rx(de, "nextSibling"), Re = Rx(de, "childNodes"), Qe = Rx(de, "parentNode");
    if (typeof w == "function") {
      const Ts = h.createElement("template");
      Ts.content && Ts.content.ownerDocument && (h = Ts.content.ownerDocument);
    }
    let qe, Bt = "";
    const { implementation: pt, createNodeIterator: en, createDocumentFragment: bn, getElementsByTagName: It } = h, { importNode: Yn } = l;
    let Fn = {};
    r.isSupported = typeof MB == "function" && typeof Qe == "function" && pt && pt.createHTMLDocument !== void 0;
    const { MUSTACHE_EXPR: yo, ERB_EXPR: mo, TMPLIT_EXPR: js, DATA_ATTR: Fs, ARIA_ATTR: ms, IS_SCRIPT_OR_DATA: cn, ATTR_WHITESPACE: Un } = TT;
    let { IS_ALLOWED_URI: Vo } = TT, Co = null;
    const ho = dr({}, [
      ...BB,
      ...IR,
      ...FR,
      ...BR,
      ...ET
    ]);
    let $o = null;
    const Er = dr({}, [
      ...$R,
      ...cS,
      ...uS,
      ...dS
    ]);
    let Ys = Object.seal(Object.create(null, {
      tagNameCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      },
      attributeNameCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: !1
      }
    })), bc = null, Hd = null, cp = !0, ql = !0, zd = !1, Df = !0, Du = !1, Ah = !1, T0 = !1, x5 = !1, y2 = !1, t4 = !1, Hz = !1, Eae = !0, Tae = !1;
    const cpe = "user-content-";
    let Dee = !0, w5 = !1, n4 = {}, o4 = null;
    const Aae = dr({}, [
      "annotation-xml",
      "audio",
      "colgroup",
      "desc",
      "foreignobject",
      "head",
      "iframe",
      "math",
      "mi",
      "mn",
      "mo",
      "ms",
      "mtext",
      "noembed",
      "noframes",
      "noscript",
      "plaintext",
      "script",
      "style",
      "svg",
      "template",
      "thead",
      "title",
      "video",
      "xmp"
    ]);
    let Oae = null;
    const Dae = dr({}, [
      "audio",
      "video",
      "img",
      "source",
      "image",
      "track"
    ]);
    let Ree = null;
    const Rae = dr({}, [
      "alt",
      "class",
      "for",
      "id",
      "label",
      "name",
      "pattern",
      "placeholder",
      "role",
      "summary",
      "title",
      "value",
      "style",
      "xmlns"
    ]), zz = "http://www.w3.org/1998/Math/MathML", Vz = "http://www.w3.org/2000/svg", A0 = "http://www.w3.org/1999/xhtml";
    let s4 = A0, Nee = !1, Pee = null;
    const upe = dr({}, [
      zz,
      Vz,
      A0
    ], MR);
    let _k;
    const dpe = [
      "application/xhtml+xml",
      "text/html"
    ], fpe = "text/html";
    let Ru, r4 = null;
    const mpe = h.createElement("form"), Nae = function(St) {
      return St instanceof RegExp || St instanceof Function;
    }, Mee = function(St) {
      if (!(r4 && r4 === St)) {
        if ((!St || typeof St != "object") && (St = {}), St = Dx(St), _k = dpe.indexOf(St.PARSER_MEDIA_TYPE) === -1 ? _k = fpe : _k = St.PARSER_MEDIA_TYPE, Ru = _k === "application/xhtml+xml" ? MR : _T, Co = "ALLOWED_TAGS" in St ? dr({}, St.ALLOWED_TAGS, Ru) : ho, $o = "ALLOWED_ATTR" in St ? dr({}, St.ALLOWED_ATTR, Ru) : Er, Pee = "ALLOWED_NAMESPACES" in St ? dr({}, St.ALLOWED_NAMESPACES, MR) : upe, Ree = "ADD_URI_SAFE_ATTR" in St ? dr(Dx(Rae), St.ADD_URI_SAFE_ATTR, Ru) : Rae, Oae = "ADD_DATA_URI_TAGS" in St ? dr(Dx(Dae), St.ADD_DATA_URI_TAGS, Ru) : Dae, o4 = "FORBID_CONTENTS" in St ? dr({}, St.FORBID_CONTENTS, Ru) : Aae, bc = "FORBID_TAGS" in St ? dr({}, St.FORBID_TAGS, Ru) : {}, Hd = "FORBID_ATTR" in St ? dr({}, St.FORBID_ATTR, Ru) : {}, n4 = "USE_PROFILES" in St ? St.USE_PROFILES : !1, cp = St.ALLOW_ARIA_ATTR !== !1, ql = St.ALLOW_DATA_ATTR !== !1, zd = St.ALLOW_UNKNOWN_PROTOCOLS || !1, Df = St.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Du = St.SAFE_FOR_TEMPLATES || !1, Ah = St.WHOLE_DOCUMENT || !1, y2 = St.RETURN_DOM || !1, t4 = St.RETURN_DOM_FRAGMENT || !1, Hz = St.RETURN_TRUSTED_TYPE || !1, x5 = St.FORCE_BODY || !1, Eae = St.SANITIZE_DOM !== !1, Tae = St.SANITIZE_NAMED_PROPS || !1, Dee = St.KEEP_CONTENT !== !1, w5 = St.IN_PLACE || !1, Vo = St.ALLOWED_URI_REGEXP || $B, s4 = St.NAMESPACE || A0, Ys = St.CUSTOM_ELEMENT_HANDLING || {}, St.CUSTOM_ELEMENT_HANDLING && Nae(St.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Ys.tagNameCheck = St.CUSTOM_ELEMENT_HANDLING.tagNameCheck), St.CUSTOM_ELEMENT_HANDLING && Nae(St.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Ys.attributeNameCheck = St.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), St.CUSTOM_ELEMENT_HANDLING && typeof St.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Ys.allowCustomizedBuiltInElements = St.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Du && (ql = !1), t4 && (y2 = !0), n4 && (Co = dr({}, [...ET]), $o = [], n4.html === !0 && (dr(Co, BB), dr($o, $R)), n4.svg === !0 && (dr(Co, IR), dr($o, cS), dr($o, dS)), n4.svgFilters === !0 && (dr(Co, FR), dr($o, cS), dr($o, dS)), n4.mathMl === !0 && (dr(Co, BR), dr($o, uS), dr($o, dS))), St.ADD_TAGS && (Co === ho && (Co = Dx(Co)), dr(Co, St.ADD_TAGS, Ru)), St.ADD_ATTR && ($o === Er && ($o = Dx($o)), dr($o, St.ADD_ATTR, Ru)), St.ADD_URI_SAFE_ATTR && dr(Ree, St.ADD_URI_SAFE_ATTR, Ru), St.FORBID_CONTENTS && (o4 === Aae && (o4 = Dx(o4)), dr(o4, St.FORBID_CONTENTS, Ru)), Dee && (Co["#text"] = !0), Ah && dr(Co, [
          "html",
          "head",
          "body"
        ]), Co.table && (dr(Co, ["tbody"]), delete bc.tbody), St.TRUSTED_TYPES_POLICY) {
          if (typeof St.TRUSTED_TYPES_POLICY.createHTML != "function")
            throw lS('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
          if (typeof St.TRUSTED_TYPES_POLICY.createScriptURL != "function")
            throw lS('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
          qe = St.TRUSTED_TYPES_POLICY, Bt = qe.createHTML("");
        } else
          qe === void 0 && (qe = VR(ae, d)), qe !== null && typeof Bt == "string" && (Bt = qe.createHTML(""));
        td && td(St), r4 = St;
      }
    }, Pae = dr({}, [
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext"
    ]), Mae = dr({}, [
      "foreignobject",
      "desc",
      "title",
      "annotation-xml"
    ]), ppe = dr({}, [
      "title",
      "style",
      "font",
      "a",
      "script"
    ]), Uz = dr({}, IR);
    dr(Uz, FR), dr(Uz, LB);
    const Iee = dr({}, BR);
    dr(Iee, LR);
    const hpe = function(St) {
      let io = Qe(St);
      (!io || !io.tagName) && (io = {
        namespaceURI: s4,
        tagName: "template"
      });
      const Fo = _T(St.tagName), gi = _T(io.tagName);
      return Pee[St.namespaceURI] ? St.namespaceURI === Vz ? io.namespaceURI === A0 ? Fo === "svg" : io.namespaceURI === zz ? Fo === "svg" && (gi === "annotation-xml" || Pae[gi]) : !!Uz[Fo] : St.namespaceURI === zz ? io.namespaceURI === A0 ? Fo === "math" : io.namespaceURI === Vz ? Fo === "math" && Mae[gi] : !!Iee[Fo] : St.namespaceURI === A0 ? io.namespaceURI === Vz && !Mae[gi] || io.namespaceURI === zz && !Pae[gi] ? !1 : !Iee[Fo] && (ppe[Fo] || !Uz[Fo]) : !!(_k === "application/xhtml+xml" && Pee[St.namespaceURI]) : !1;
    }, Ek = function(St) {
      iS(r.removed, { element: St });
      try {
        St.parentNode.removeChild(St);
      } catch {
        St.remove();
      }
    }, C5 = function(St, io) {
      try {
        iS(r.removed, {
          attribute: io.getAttributeNode(St),
          from: io
        });
      } catch {
        iS(r.removed, {
          attribute: null,
          from: io
        });
      }
      if (io.removeAttribute(St), St === "is" && !$o[St])
        if (y2 || t4)
          try {
            Ek(io);
          } catch {
          }
        else
          try {
            io.setAttribute(St, "");
          } catch {
          }
    }, Iae = function(St) {
      let io, Fo;
      if (x5)
        St = "<remove></remove>" + St;
      else {
        const Oh = Lj(St, /^[\r\n\t ]+/);
        Fo = Oh && Oh[0];
      }
      _k === "application/xhtml+xml" && s4 === A0 && (St = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + St + "</body></html>");
      const gi = qe ? qe.createHTML(St) : St;
      if (s4 === A0)
        try {
          io = new ne().parseFromString(gi, _k);
        } catch {
        }
      if (!io || !io.documentElement) {
        io = pt.createDocument(s4, "template", null);
        try {
          io.documentElement.innerHTML = Nee ? Bt : gi;
        } catch {
        }
      }
      const Nu = io.body || io.documentElement;
      return St && Fo && Nu.insertBefore(h.createTextNode(Fo), Nu.childNodes[0] || null), s4 === A0 ? It.call(io, Ah ? "html" : "body")[0] : Ah ? io.documentElement : Nu;
    }, Fae = function(St) {
      return en.call(St.ownerDocument || St, St, F.SHOW_ELEMENT | F.SHOW_COMMENT | F.SHOW_TEXT, null, !1);
    }, gpe = function(St) {
      return St instanceof q && (typeof St.nodeName != "string" || typeof St.textContent != "string" || typeof St.removeChild != "function" || !(St.attributes instanceof L) || typeof St.removeAttribute != "function" || typeof St.setAttribute != "function" || typeof St.namespaceURI != "string" || typeof St.insertBefore != "function" || typeof St.hasChildNodes != "function");
    }, jz = function(St) {
      return typeof E == "object" ? St instanceof E : St && typeof St == "object" && typeof St.nodeType == "number" && typeof St.nodeName == "string";
    }, O0 = function(St, io, Fo) {
      Fn[St] && Fj(Fn[St], (gi) => {
        gi.call(r, io, Fo, r4);
      });
    }, Bae = function(St) {
      let io;
      if (O0("beforeSanitizeElements", St, null), gpe(St))
        return Ek(St), !0;
      const Fo = Ru(St.nodeName);
      if (O0("uponSanitizeElement", St, {
        tagName: Fo,
        allowedTags: Co
      }), St.hasChildNodes() && !jz(St.firstElementChild) && (!jz(St.content) || !jz(St.content.firstElementChild)) && bf(/<[/\w]/g, St.innerHTML) && bf(/<[/\w]/g, St.textContent))
        return Ek(St), !0;
      if (!Co[Fo] || bc[Fo]) {
        if (!bc[Fo] && $ae(Fo) && (Ys.tagNameCheck instanceof RegExp && bf(Ys.tagNameCheck, Fo) || Ys.tagNameCheck instanceof Function && Ys.tagNameCheck(Fo)))
          return !1;
        if (Dee && !o4[Fo]) {
          const gi = Qe(St) || St.parentNode, Nu = Re(St) || St.childNodes;
          if (Nu && gi) {
            const Oh = Nu.length;
            for (let Pl = Oh - 1; Pl >= 0; --Pl)
              gi.insertBefore(_e(Nu[Pl], !0), st(St));
          }
        }
        return Ek(St), !0;
      }
      return St instanceof O && !hpe(St) || (Fo === "noscript" || Fo === "noembed" || Fo === "noframes") && bf(/<\/no(script|embed|frames)/i, St.innerHTML) ? (Ek(St), !0) : (Du && St.nodeType === 3 && (io = St.textContent, io = ep(io, yo, " "), io = ep(io, mo, " "), io = ep(io, js, " "), St.textContent !== io && (iS(r.removed, { element: St.cloneNode() }), St.textContent = io)), O0("afterSanitizeElements", St, null), !1);
    }, Lae = function(St, io, Fo) {
      if (Eae && (io === "id" || io === "name") && (Fo in h || Fo in mpe))
        return !1;
      if (!(ql && !Hd[io] && bf(Fs, io))) {
        if (!(cp && bf(ms, io))) {
          if (!$o[io] || Hd[io]) {
            if (!($ae(St) && (Ys.tagNameCheck instanceof RegExp && bf(Ys.tagNameCheck, St) || Ys.tagNameCheck instanceof Function && Ys.tagNameCheck(St)) && (Ys.attributeNameCheck instanceof RegExp && bf(Ys.attributeNameCheck, io) || Ys.attributeNameCheck instanceof Function && Ys.attributeNameCheck(io)) || io === "is" && Ys.allowCustomizedBuiltInElements && (Ys.tagNameCheck instanceof RegExp && bf(Ys.tagNameCheck, Fo) || Ys.tagNameCheck instanceof Function && Ys.tagNameCheck(Fo)))) return !1;
          } else if (!Ree[io]) {
            if (!bf(Vo, ep(Fo, Un, ""))) {
              if (!((io === "src" || io === "xlink:href" || io === "href") && St !== "script" && $j(Fo, "data:") === 0 && Oae[St])) {
                if (!(zd && !bf(cn, ep(Fo, Un, "")))) {
                  if (Fo)
                    return !1;
                }
              }
            }
          }
        }
      }
      return !0;
    }, $ae = function(St) {
      return St.indexOf("-") > 0;
    }, Hae = function(St) {
      let io, Fo, gi, Nu;
      O0("beforeSanitizeAttributes", St, null);
      const { attributes: Oh } = St;
      if (!Oh)
        return;
      const Pl = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: $o
      };
      for (Nu = Oh.length; Nu--; ) {
        io = Oh[Nu];
        const { name: Dh, namespaceURI: Fee } = io;
        Fo = Dh === "value" ? io.value : Hj(io.value);
        const bpe = Fo;
        if (gi = Ru(Dh), Pl.attrName = gi, Pl.attrValue = Fo, Pl.keepAttr = !0, Pl.forceKeepAttr = void 0, O0("uponSanitizeAttribute", St, Pl), Fo = Pl.attrValue, Pl.forceKeepAttr)
          continue;
        if (!Pl.keepAttr) {
          C5(Dh, St);
          continue;
        }
        if (!Df && bf(/\/>/i, Fo)) {
          C5(Dh, St);
          continue;
        }
        Du && (Fo = ep(Fo, yo, " "), Fo = ep(Fo, mo, " "), Fo = ep(Fo, js, " "));
        const zae = Ru(St.nodeName);
        if (!Lae(zae, gi, Fo)) {
          C5(Dh, St);
          continue;
        }
        if (Tae && (gi === "id" || gi === "name") && (C5(Dh, St), Fo = cpe + Fo), qe && typeof ae == "object" && typeof ae.getAttributeType == "function" && !Fee)
          switch (ae.getAttributeType(zae, gi)) {
            case "TrustedHTML": {
              Fo = qe.createHTML(Fo);
              break;
            }
            case "TrustedScriptURL": {
              Fo = qe.createScriptURL(Fo);
              break;
            }
          }
        if (Fo !== bpe)
          try {
            Fee ? St.setAttributeNS(Fee, Dh, Fo) : St.setAttribute(Dh, Fo);
          } catch {
            C5(Dh, St);
          }
      }
      O0("afterSanitizeAttributes", St, null);
    }, vpe = function Ts(St) {
      let io;
      const Fo = Fae(St);
      for (O0("beforeSanitizeShadowDOM", St, null); io = Fo.nextNode(); )
        O0("uponSanitizeShadowNode", io, null), !Bae(io) && (io.content instanceof y && Ts(io.content), Hae(io));
      O0("afterSanitizeShadowDOM", St, null);
    };
    return r.sanitize = function(Ts) {
      let St = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, io, Fo, gi, Nu;
      if (Nee = !Ts, Nee && (Ts = "<!-->"), typeof Ts != "string" && !jz(Ts))
        if (typeof Ts.toString == "function") {
          if (Ts = Ts.toString(), typeof Ts != "string")
            throw lS("dirty is not a string, aborting");
        } else
          throw lS("toString is not a function");
      if (!r.isSupported)
        return Ts;
      if (T0 || Mee(St), r.removed = [], typeof Ts == "string" && (w5 = !1), w5) {
        if (Ts.nodeName) {
          const Dh = Ru(Ts.nodeName);
          if (!Co[Dh] || bc[Dh])
            throw lS("root node is forbidden and cannot be sanitized in-place");
        }
      } else if (Ts instanceof E)
        io = Iae("<!---->"), Fo = io.ownerDocument.importNode(Ts, !0), Fo.nodeType === 1 && Fo.nodeName === "BODY" || Fo.nodeName === "HTML" ? io = Fo : io.appendChild(Fo);
      else {
        if (!y2 && !Du && !Ah && Ts.indexOf("<") === -1)
          return qe && Hz ? qe.createHTML(Ts) : Ts;
        if (io = Iae(Ts), !io)
          return y2 ? null : Hz ? Bt : "";
      }
      io && x5 && Ek(io.firstChild);
      const Oh = Fae(w5 ? Ts : io);
      for (; gi = Oh.nextNode(); )
        Bae(gi) || (gi.content instanceof y && vpe(gi.content), Hae(gi));
      if (w5)
        return Ts;
      if (y2) {
        if (t4)
          for (Nu = bn.call(io.ownerDocument); io.firstChild; )
            Nu.appendChild(io.firstChild);
        else
          Nu = io;
        return ($o.shadowroot || $o.shadowrootmode) && (Nu = Yn.call(l, Nu, !0)), Nu;
      }
      let Pl = Ah ? io.outerHTML : io.innerHTML;
      return Ah && Co["!doctype"] && io.ownerDocument && io.ownerDocument.doctype && io.ownerDocument.doctype.name && bf(zR, io.ownerDocument.doctype.name) && (Pl = "<!DOCTYPE " + io.ownerDocument.doctype.name + `>
` + Pl), Du && (Pl = ep(Pl, yo, " "), Pl = ep(Pl, mo, " "), Pl = ep(Pl, js, " ")), qe && Hz ? qe.createHTML(Pl) : Pl;
    }, r.setConfig = function(Ts) {
      Mee(Ts), T0 = !0;
    }, r.clearConfig = function() {
      r4 = null, T0 = !1;
    }, r.isValidAttribute = function(Ts, St, io) {
      r4 || Mee({});
      const Fo = Ru(Ts), gi = Ru(St);
      return Lae(Fo, gi, io);
    }, r.addHook = function(Ts, St) {
      typeof St == "function" && (Fn[Ts] = Fn[Ts] || [], iS(Fn[Ts], St));
    }, r.removeHook = function(Ts) {
      if (Fn[Ts])
        return Bj(Fn[Ts]);
    }, r.removeHooks = function(Ts) {
      Fn[Ts] && (Fn[Ts] = []);
    }, r.removeAllHooks = function() {
      Fn = {};
    }, r;
  }
  var Gj = AT();
  const UR = (t) => Gj().sanitize(t);
  var Pd = tinymce.util.Tools.resolve("tinymce.util.I18n");
  const qj = {
    indent: !0,
    outdent: !0,
    "table-insert-column-after": !0,
    "table-insert-column-before": !0,
    "paste-column-after": !0,
    "paste-column-before": !0,
    "unordered-list": !0,
    "list-bull-circle": !0,
    "list-bull-default": !0,
    "list-bull-square": !0
  }, HB = "temporary-placeholder", jR = (t) => () => qt(t, HB).getOr("!not found!"), WR = (t, r) => {
    const l = t.toLowerCase();
    if (Pd.isRtl()) {
      const d = En(l, "-rtl");
      return Ko(r, d) ? d : l;
    } else
      return l;
  }, zB = (t, r) => qt(r, WR(t, r)), VB = (t, r) => {
    const l = r();
    return zB(t, l).getOrThunk(jR(l));
  }, UB = (t, r, l) => {
    const d = r();
    return zB(t, d).or(l).getOrThunk(jR(d));
  }, jB = (t) => Pd.isRtl() ? Ko(qj, t) : !1, ZR = () => jo("add-focusable", [qr((t) => {
    Iw(t.element, "svg").each((r) => sn(r, "focusable", "false"));
  })]), GR = (t, r, l, d) => {
    var h, y;
    const w = jB(r) ? ["tox-icon--flip"] : [], E = qt(l, WR(r, l)).or(d).getOrThunk(jR(l));
    return {
      dom: {
        tag: t.tag,
        attributes: (h = t.attributes) !== null && h !== void 0 ? h : {},
        classes: t.classes.concat(w),
        innerHtml: E
      },
      behaviours: Jt([
        ...(y = t.behaviours) !== null && y !== void 0 ? y : [],
        ZR()
      ])
    };
  }, ku = (t, r, l, d = B.none()) => GR(r, t, l(), d), WB = (t, r, l) => {
    const d = l(), h = Nt(t, (y) => Ko(d, WR(y, d)));
    return GR(r, h.getOr(HB), d, B.none());
  }, Kj = {
    success: "checkmark",
    error: "warning",
    err: "error",
    warning: "warning",
    warn: "warning",
    info: "info"
  }, OT = Nc({
    name: "Notification",
    factory: (t) => {
      const r = Mn("notification-text"), l = rr({
        dom: Qm(`<p id=${r}>${UR(t.backstageProvider.translate(t.text))}</p>`),
        behaviours: Jt([Po.config({})])
      }), d = (de) => ({
        dom: {
          tag: "div",
          classes: ["tox-bar"],
          styles: { width: `${de}%` }
        }
      }), h = (de) => ({
        dom: {
          tag: "div",
          classes: ["tox-text"],
          innerHtml: `${de}%`
        }
      }), y = rr({
        dom: {
          tag: "div",
          classes: t.progress ? [
            "tox-progress-bar",
            "tox-progress-indicator"
          ] : ["tox-progress-bar"]
        },
        components: [
          {
            dom: {
              tag: "div",
              classes: ["tox-bar-container"]
            },
            components: [d(0)]
          },
          h(0)
        ],
        behaviours: Jt([Po.config({})])
      }), O = {
        updateProgress: (de, _e) => {
          de.getSystem().isConnected() && y.getOpt(de).each((st) => {
            Po.set(st, [
              {
                dom: {
                  tag: "div",
                  classes: ["tox-bar-container"]
                },
                components: [d(_e)]
              },
              h(_e)
            ]);
          });
        },
        updateText: (de, _e) => {
          if (de.getSystem().isConnected()) {
            const st = l.get(de);
            Po.set(st, [Aa(_e)]);
          }
        }
      }, F = tn([
        t.icon.toArray(),
        t.level.toArray(),
        t.level.bind((de) => B.from(Kj[de])).toArray()
      ]), L = rr(Nl.sketch({
        dom: {
          tag: "button",
          classes: [
            "tox-notification__dismiss",
            "tox-button",
            "tox-button--naked",
            "tox-button--icon"
          ],
          attributes: { "aria-label": t.backstageProvider.translate("Close") }
        },
        components: [ku("close", {
          tag: "span",
          classes: ["tox-icon"]
        }, t.iconProvider)],
        buttonBehaviours: Jt([
          jr.config({}),
          gl.config({ ...t.backstageProvider.tooltips.getConfig({ tooltipText: t.backstageProvider.translate("Close") }) })
        ]),
        action: (de) => {
          t.onAction(de);
        }
      })), q = WB(F, {
        tag: "div",
        classes: ["tox-notification__icon"]
      }, t.iconProvider), ne = {
        dom: {
          tag: "div",
          classes: ["tox-notification__body"]
        },
        components: [l.asSpec()],
        behaviours: Jt([Po.config({})])
      }, ae = [
        q,
        ne
      ];
      return {
        uid: t.uid,
        dom: {
          tag: "div",
          attributes: {
            role: "alert",
            "aria-labelledby": r
          },
          classes: t.level.map((de) => [
            "tox-notification",
            "tox-notification--in",
            `tox-notification--${de}`
          ]).getOr([
            "tox-notification",
            "tox-notification--in"
          ])
        },
        behaviours: Jt([
          jr.config({}),
          To.config({}),
          so.config({
            mode: "special",
            onEscape: (de) => (t.onAction(de), B.some(!0))
          })
        ]),
        components: ae.concat(t.progress ? [y.asSpec()] : []).concat([L.asSpec()]),
        apis: O
      };
    },
    configFields: [
      $s("level"),
      Mt("progress"),
      $s("icon"),
      Mt("onAction"),
      Mt("text"),
      Mt("iconProvider"),
      Mt("backstageProvider")
    ],
    apis: {
      updateProgress: (t, r, l) => {
        t.updateProgress(r, l);
      },
      updateText: (t, r, l) => {
        t.updateText(r, l);
      }
    }
  });
  var Yj = (t, r, l, d) => {
    const h = r.backstage.shared, y = () => {
      const L = sa($e.fromDom(t.getContentAreaContainer()));
      return B.some(L);
    }, w = (L) => {
      y().each((q) => {
        xt(L, (ne) => {
          Ri(ne.element) > q.width && Ln(ne.element, "width", q.width + "px");
        });
      });
    };
    return {
      open: (L, q, ne) => {
        const ae = () => {
          const Re = (pt) => {
            Po.remove(pt, de), _e();
          }, Qe = (pt, en) => {
            La(pt.element).length === 0 ? qe(pt, en) : Bt(pt, en);
          }, qe = (pt, en) => {
            aa.hide(pt), d.clear(), en && t.focus();
          }, Bt = (pt, en) => {
            en && so.focusIn(pt);
          };
          d.on((pt) => {
            q();
            const en = ne();
            Re(pt), Qe(pt, en);
          });
        }, de = Ol(OT.sketch({
          text: L.text,
          level: pn([
            "success",
            "error",
            "warning",
            "warn",
            "info"
          ], L.type) ? L.type : void 0,
          progress: L.progressBar === !0,
          icon: L.icon,
          onAction: ae,
          iconProvider: h.providers.icons,
          backstageProvider: h.providers
        }));
        if (d.isSet()) {
          const Re = Vl(de);
          d.on((Qe) => {
            Po.append(Qe, Re), aa.reposition(Qe), ma.refresh(Qe), w(Qe.components());
          });
        } else {
          const Re = Ol(aa.sketch({
            dom: {
              tag: "div",
              classes: ["tox-notifications-container"],
              attributes: {
                "aria-label": "Notifications",
                role: "region"
              }
            },
            lazySink: h.getSink,
            fireDismissalEventInstead: {},
            ...h.header.isPositionedAtTop() ? {} : { fireRepositionEventInstead: {} },
            inlineBehaviours: Jt([
              so.config({
                mode: "cyclic",
                selector: ".tox-notification, .tox-notification a, .tox-notification button"
              }),
              Po.config({}),
              ...Ox(t) && !h.header.isPositionedAtTop() ? [] : [ma.config({
                contextual: {
                  lazyContext: () => B.some(sa($e.fromDom(t.getContentAreaContainer()))),
                  fadeInClass: "tox-notification-container-dock-fadein",
                  fadeOutClass: "tox-notification-container-dock-fadeout",
                  transitionClass: "tox-notification-container-dock-transition"
                },
                modes: ["top"],
                lazyViewport: (pt) => $g(t, pt.element).map((bn) => ({
                  bounds: q1(bn),
                  optScrollEnv: B.some({
                    currentScrollTop: bn.element.dom.scrollTop,
                    scrollElmTop: Ga(bn.element).top
                  })
                })).getOrThunk(() => ({
                  bounds: Na(),
                  optScrollEnv: B.none()
                }))
              })]
            ])
          })), Qe = Vl(de), qe = { maxHeightFunction: jv() }, Bt = {
            ...h.anchors.banner(),
            overrides: qe
          };
          d.set(Re), l.add(Re), aa.showWithinBounds(Re, Qe, { anchor: Bt }, y);
        }
        re(L.timeout) && L.timeout > 0 && JC.setEditorTimeout(t, () => {
          ae();
        }, L.timeout);
        const _e = () => {
          d.on((Re) => {
            aa.reposition(Re), ma.refresh(Re), w(Re.components());
          });
        };
        return {
          close: ae,
          reposition: _e,
          text: (Re) => {
            OT.updateText(de, Re);
          },
          settings: L,
          getEl: () => de.element.dom,
          progressBar: {
            value: (Re) => {
              OT.updateProgress(de, Re);
            }
          }
        };
      },
      close: (L) => {
        L.close();
      },
      getArgs: (L) => L.settings
    };
  };
  const ZB = { setup: (t, r) => {
    const l = (h, y) => {
      po(h, Ed(), { raw: y });
    }, d = () => t.getMenu().bind(yn.getHighlighted);
    r.on("keydown", (h) => {
      const y = h.which;
      t.isActive() && (t.isMenuOpen() ? y === 13 ? (d().each(Hp), h.preventDefault()) : y === 40 ? (d().fold(() => {
        t.getMenu().each(yn.highlightFirst);
      }, (w) => {
        l(w, h);
      }), h.preventDefault(), h.stopImmediatePropagation()) : (y === 37 || y === 38 || y === 39) && d().each((w) => {
        l(w, h), h.preventDefault(), h.stopImmediatePropagation();
      }) : (y === 13 || y === 38 || y === 40) && t.cancelIfNecessary());
    }), r.on("NodeChange", () => {
      t.isActive() && !t.isProcessingAction() && !r.queryCommandState("mceAutoCompleterInRange") && t.cancelIfNecessary();
    });
  } };
  var DT;
  (function(t) {
    t[t.CLOSE_ON_EXECUTE = 0] = "CLOSE_ON_EXECUTE", t[t.BUBBLE_TO_SANDBOX = 1] = "BUBBLE_TO_SANDBOX";
  })(DT || (DT = {}));
  var im = DT;
  const RT = "tox-menu-nav__js", NT = "tox-collection__item", qR = "tox-swatch", GB = {
    normal: RT,
    color: qR
  }, PT = "tox-collection__item--enabled", KR = "tox-collection__group-heading", YR = "tox-collection__item-icon", MT = "tox-collection__item-label", qB = "tox-collection__item-accessory", KB = "tox-collection__item-caret", XR = "tox-collection__item-checkmark", K1 = "tox-collection__item--active", QR = "tox-collection__item-container", YB = "tox-collection__item-container--column", mb = "tox-collection__item-container--row", Xj = "tox-collection__item-container--align-right", JR = "tox-collection__item-container--align-left", IT = "tox-collection__item-container--valign-top", Qj = "tox-collection__item-container--valign-middle", XB = "tox-collection__item-container--valign-bottom", eN = (t) => qt(GB, t).getOr(RT), QB = (t) => t === "color" ? "tox-swatches" : "tox-menu", mS = (t) => ({
    backgroundMenu: "tox-background-menu",
    selectedMenu: "tox-selected-menu",
    selectedItem: "tox-collection__item--active",
    hasIcons: "tox-menu--has-icons",
    menu: QB(t),
    tieredMenu: "tox-tiered-menu"
  }), pb = (t) => {
    const r = mS(t);
    return {
      backgroundMenu: r.backgroundMenu,
      selectedMenu: r.selectedMenu,
      menu: r.menu,
      selectedItem: r.selectedItem,
      item: eN(t)
    };
  }, Jj = (t, r, l) => {
    const d = mS(l);
    return {
      tag: "div",
      classes: tn([
        [
          d.menu,
          `tox-menu-${r}-column`
        ],
        t ? [d.hasIcons] : []
      ])
    };
  }, JB = [V1.parts.items({})], pS = (t, r, l) => {
    const d = mS(l);
    return {
      dom: {
        tag: "div",
        classes: tn([[d.tieredMenu]])
      },
      markers: pb(l)
    };
  }, tN = ee([
    $s("data"),
    Xe("inputAttributes", {}),
    Xe("inputStyles", {}),
    Xe("tag", "input"),
    Xe("inputClasses", []),
    Os("onSetValue"),
    Xe("styles", {}),
    Xe("eventOrder", {}),
    $i("inputBehaviours", [
      In,
      To
    ]),
    Xe("selectOnFocus", !0)
  ]), nN = (t) => Jt([To.config({
    onFocus: t.selectOnFocus ? (r) => {
      const l = r.element, d = gt(l);
      l.dom.setSelectionRange(0, d.length);
    } : U
  })]), eW = (t) => ({
    ...nN(t),
    ...Hi(t.inputBehaviours, [In.config({
      store: {
        mode: "manual",
        ...t.data.map((r) => ({ initialValue: r })).getOr({}),
        getValue: (r) => gt(r.element),
        setValue: (r, l) => {
          gt(r.element) !== l && Jf(r.element, l);
        }
      },
      onSetValue: t.onSetValue
    })])
  }), oN = (t) => ({
    tag: t.tag,
    attributes: {
      type: "text",
      ...t.inputAttributes
    },
    styles: t.inputStyles,
    classes: t.inputClasses
  }), tW = (t, r) => ({
    uid: t.uid,
    dom: oN(t),
    components: [],
    behaviours: eW(t),
    eventOrder: t.eventOrder
  }), Y1 = Nc({
    name: "Input",
    configFields: tN(),
    factory: tW
  }), eL = Mn("refetch-trigger-event"), tL = Mn("redirect-menu-item-interaction"), sN = "tox-menu__searcher", hb = (t) => or(t.element, `.${sN}`).bind((r) => t.getSystem().getByDom(r).toOptional()), rN = hb, nW = (t, r) => {
    In.setValue(t, r.fetchPattern), t.element.dom.selectionStart = r.selectionStart, t.element.dom.selectionEnd = r.selectionEnd;
  }, nL = (t) => {
    const r = In.getValue(t), l = t.element.dom.selectionStart, d = t.element.dom.selectionEnd;
    return {
      fetchPattern: r,
      selectionStart: l,
      selectionEnd: d
    };
  }, oW = (t, r) => {
    Y(r.element, "id").each((l) => sn(t.element, "aria-activedescendant", l));
  }, sW = (t) => {
    const r = (h, y) => (y.cut(), B.none()), l = (h, y) => {
      const w = {
        interactionEvent: y.event,
        eventType: y.event.raw.type
      };
      return po(h, tL, w), B.some(!0);
    }, d = "searcher-events";
    return {
      dom: {
        tag: "div",
        classes: [NT]
      },
      components: [Y1.sketch({
        inputClasses: [
          sN,
          "tox-textfield"
        ],
        inputAttributes: {
          ...t.placeholder.map((h) => ({ placeholder: t.i18n(h) })).getOr({}),
          type: "search",
          "aria-autocomplete": "list"
        },
        inputBehaviours: Jt([
          jo(d, [
            Ft(Zf(), (h) => {
              Xo(h, eL);
            }),
            Ft(Ed(), (h, y) => {
              y.event.raw.key === "Escape" && y.stop();
            })
          ]),
          so.config({
            mode: "special",
            onLeft: r,
            onRight: r,
            onSpace: r,
            onEnter: l,
            onEscape: l,
            onUp: l,
            onDown: l
          })
        ]),
        eventOrder: {
          keydown: [
            d,
            so.name()
          ]
        }
      })]
    };
  }, FT = "tox-collection--results__js", hS = (t) => {
    var r;
    return t.dom ? {
      ...t,
      dom: {
        ...t.dom,
        attributes: {
          ...(r = t.dom.attributes) !== null && r !== void 0 ? r : {},
          id: Mn("aria-item-search-result-id"),
          "aria-selected": "false"
        }
      }
    } : t;
  }, aN = (t, r) => (l) => {
    const d = Cn(l, r);
    return et(d, (h) => ({
      dom: t,
      components: h
    }));
  }, oL = (t) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-menu",
        "tox-swatches-menu"
      ]
    },
    components: [{
      dom: {
        tag: "div",
        classes: ["tox-swatches"]
      },
      components: [V1.parts.items({
        preprocess: t !== "auto" ? aN({
          tag: "div",
          classes: ["tox-swatches__row"]
        }, t) : lt
      })]
    }]
  }), rW = (t) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-menu",
        "tox-collection",
        "tox-collection--toolbar",
        "tox-collection--toolbar-lg"
      ]
    },
    components: [V1.parts.items({
      preprocess: aN({
        tag: "div",
        classes: ["tox-collection__group"]
      }, t)
    })]
  }), iN = (t, r) => {
    const l = [];
    let d = [];
    return xt(t, (h, y) => {
      r(h, y) ? (d.length > 0 && l.push(d), d = [], (Ko(h.dom, "innerHtml") || h.components && h.components.length > 0) && d.push(h)) : d.push(h);
    }), d.length > 0 && l.push(d), et(l, (h) => ({
      dom: {
        tag: "div",
        classes: ["tox-collection__group"]
      },
      components: h
    }));
  }, BT = (t, r, l) => V1.parts.items({
    preprocess: (d) => {
      const h = et(d, l);
      return t !== "auto" && t > 1 ? aN({
        tag: "div",
        classes: ["tox-collection__group"]
      }, t)(h) : iN(h, (y, w) => r[w].type === "separator");
    }
  }), sL = (t, r, l = !0) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-menu",
        "tox-collection"
      ].concat(t === 1 ? ["tox-collection--list"] : ["tox-collection--grid"])
    },
    components: [BT(t, r, lt)]
  }), rL = (t, r, l = !0) => {
    const d = Mn("aria-controls-search-results");
    return {
      dom: {
        tag: "div",
        classes: [
          "tox-menu",
          "tox-collection",
          FT
        ].concat(t === 1 ? ["tox-collection--list"] : ["tox-collection--grid"]),
        attributes: { id: d }
      },
      components: [BT(t, r, hS)]
    };
  }, aL = (t, r, l) => {
    const d = Mn("aria-controls-search-results");
    return {
      dom: {
        tag: "div",
        classes: [
          "tox-menu",
          "tox-collection"
        ].concat(t === 1 ? ["tox-collection--list"] : ["tox-collection--grid"])
      },
      components: [
        sW({
          i18n: Pd.translate,
          placeholder: l.placeholder
        }),
        {
          dom: {
            tag: "div",
            classes: [
              ...t === 1 ? ["tox-collection--list"] : ["tox-collection--grid"],
              FT
            ],
            attributes: { id: d }
          },
          components: [BT(t, r, hS)]
        }
      ]
    };
  }, iL = (t, r = !0) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-collection",
        "tox-collection--horizontal"
      ]
    },
    components: [V1.parts.items({ preprocess: (l) => iN(l, (d, h) => t[h].type === "separator") })]
  }), gS = (t) => Ro(t, (r) => "icon" in r && r.icon !== void 0), Hg = (t) => (console.error(zu(t)), console.log(t), B.none()), aW = (t, r, l, d, h) => {
    const y = iL(l);
    return {
      value: t,
      dom: y.dom,
      components: y.components,
      items: l
    };
  }, lN = (t, r, l, d, h) => {
    const y = () => h.menuType !== "searchable" ? sL(d, l) : h.searchMode.searchMode === "search-with-field" ? aL(d, l, h.searchMode) : rL(d, l);
    if (h.menuType === "color") {
      const w = oL(d);
      return {
        value: t,
        dom: w.dom,
        components: w.components,
        items: l
      };
    } else if (h.menuType === "normal" && d === "auto") {
      const w = sL(d, l);
      return {
        value: t,
        dom: w.dom,
        components: w.components,
        items: l
      };
    } else if (h.menuType === "normal" || h.menuType === "searchable") {
      const w = y();
      return {
        value: t,
        dom: w.dom,
        components: w.components,
        items: l
      };
    } else if (h.menuType === "listpreview" && d !== "auto") {
      const w = rW(d);
      return {
        value: t,
        dom: w.dom,
        components: w.components,
        items: l
      };
    } else
      return {
        value: t,
        dom: Jj(r, d, h.menuType),
        components: JB,
        items: l
      };
  }, oi = Va("type"), LT = Va("name"), $T = Va("label"), zg = Va("text"), lL = Va("title"), cL = Va("icon"), vS = Va("value"), iW = Tc("fetch"), lW = Tc("getSubmenuItems"), Nx = Tc("onAction"), cN = Tc("onItemAction"), gb = Ca("onSetup", () => U), cW = Ua("name"), vb = Ua("text"), uL = Ua("role"), yf = Ua("icon"), bS = Ua("tooltip"), HT = Ua("label"), zT = Ua("shortcut"), dL = Cd("select"), VT = Ea("active", !1), uW = Ea("borderless", !1), lm = Ea("enabled", !0), yS = Ea("primary", !1), UT = (t) => Xe("columns", t), uN = Xe("meta", {}), dN = Ca("onAction", U), X1 = (t) => Ii("type", t), fN = (t) => Qa("name", "name", ls(() => Mn(`${t}-name`)), Tn), dW = (t) => Qa("value", "value", ls(() => Mn(`${t}-value`)), pu()), fL = xo([
    oi,
    vb
  ]), mL = (t) => ra("separatormenuitem", fL, t), pL = xo([
    X1("autocompleteitem"),
    VT,
    lm,
    uN,
    vS,
    vb,
    yf
  ]), fW = (t) => ra("Autocompleter.Separator", fL, t), mW = (t) => ra("Autocompleter.Item", pL, t), xS = [
    lm,
    bS,
    yf,
    vb,
    gb
  ], nd = xo([
    oi,
    Nx,
    zT
  ].concat(xS)), cm = (t) => ra("toolbarbutton", nd, t), mN = [VT].concat(xS), pN = xo(mN.concat([
    oi,
    Nx,
    zT
  ])), jT = (t) => ra("ToggleButton", pN, t), hL = [
    Ca("predicate", _t),
    gu("scope", "node", [
      "node",
      "editor"
    ]),
    gu("position", "selection", [
      "node",
      "selection",
      "line"
    ])
  ], pW = xS.concat([
    X1("contextformbutton"),
    yS,
    Nx,
    Vs("original", lt)
  ]), wS = mN.concat([
    X1("contextformbutton"),
    yS,
    Nx,
    Vs("original", lt)
  ]), WT = xS.concat([X1("contextformbutton")]), hN = mN.concat([X1("contextformtogglebutton")]), hW = ui("type", {
    contextformbutton: pW,
    contextformtogglebutton: wS
  }), tp = xo([
    X1("contextform"),
    Ca("initValue", ee("")),
    HT,
    Ac("commands", hW),
    wd("launch", ui("type", {
      contextformbutton: WT,
      contextformtogglebutton: hN
    }))
  ].concat(hL)), gW = (t) => ra("ContextForm", tp, t), vW = xo([
    X1("contexttoolbar"),
    Va("items")
  ].concat(hL)), xf = (t) => ra("ContextToolbar", vW, t), CS = [
    oi,
    Va("src"),
    Ua("alt"),
    I("classes", [], Tn)
  ], um = xo(CS), bW = [
    oi,
    zg,
    cW,
    I("classes", ["tox-collection__item-label"], Tn)
  ], _r = xo(bW), Q1 = Xa(() => Vf("type", {
    cardimage: um,
    cardtext: _r,
    cardcontainer: ZT
  })), ZT = xo([
    oi,
    Ii("direction", "horizontal"),
    Ii("align", "left"),
    Ii("valign", "middle"),
    Ac("items", Q1)
  ]), J1 = [
    lm,
    vb,
    uL,
    zT,
    dW("menuitem"),
    uN
  ], gN = xo([
    oi,
    HT,
    Ac("items", Q1),
    gb,
    dN
  ].concat(J1)), vN = (t) => ra("cardmenuitem", gN, t), yW = xo([
    oi,
    VT,
    yf
  ].concat(J1)), bN = (t) => ra("choicemenuitem", yW, t), gL = [
    oi,
    Va("fancytype"),
    dN
  ], vL = [Xe("initData", {})].concat(gL), bL = [
    Cd("select"),
    te("initData", {}, [
      Ea("allowCustomColors", !0),
      Ii("storageKey", "default"),
      Vu("colors", pu())
    ])
  ].concat(gL), yN = ui("fancytype", {
    inserttable: vL,
    colorswatch: bL
  }), yL = (t) => ra("fancymenuitem", yN, t), GT = xo([
    oi,
    gb,
    dN,
    yf
  ].concat(J1)), xW = (t) => ra("menuitem", GT, t), wW = xo([
    oi,
    lW,
    gb,
    yf
  ].concat(J1)), CW = (t) => ra("nestedmenuitem", wW, t), SW = xo([
    oi,
    yf,
    VT,
    gb,
    Nx
  ].concat(J1)), kW = (t) => ra("togglemenuitem", SW, t), qT = (t, r, l) => {
    const d = Rl(t.element, "." + l);
    if (d.length > 0) {
      const h = Vn(d, (y) => {
        const w = y.dom.getBoundingClientRect().top, E = d[0].dom.getBoundingClientRect().top;
        return Math.abs(w - E) > r;
      }).getOr(d.length);
      return B.some({
        numColumns: h,
        numRows: Math.ceil(d.length / h)
      });
    } else
      return B.none();
  }, xL = (t, r) => Jt([jo(t, r)]), Px = {
    namedEvents: xL,
    unnamedEvents: (t) => xL(Mn("unnamed-events"), t)
  }, wL = (t) => t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), CL = "silver.readonly", _W = xo([Y2("readonly")]), SS = (t, r) => {
    const d = t.mainUi.outerContainer.element, h = [
      t.mainUi.mothership,
      ...t.uiMotherships
    ];
    r && xt(h, (y) => {
      y.broadcastOn([nm()], { target: d });
    }), xt(h, (y) => {
      y.broadcastOn([CL], { readonly: r });
    });
  }, KT = (t, r) => {
    t.on("init", () => {
      t.mode.isReadOnly() && SS(r, !0);
    }), t.on("SwitchMode", () => SS(r, t.mode.isReadOnly())), cT(t) && t.mode.set("readonly");
  }, ki = () => Rc.config({
    channels: {
      [CL]: {
        schema: _W,
        onReceive: (t, r) => {
          _o.set(t, r.readonly);
        }
      }
    }
  }), dm = {
    item: (t) => _o.config({
      disabled: t,
      disableClass: "tox-collection__item--state-disabled"
    }),
    button: (t) => _o.config({ disabled: t }),
    splitButton: (t) => _o.config({
      disabled: t,
      disableClass: "tox-tbtn--disabled"
    }),
    toolbarButton: (t) => _o.config({
      disabled: t,
      disableClass: "tox-tbtn--disabled",
      useNative: !1
    })
  }, YT = (t, r) => {
    const l = t.getApi(r);
    return (d) => {
      d(l);
    };
  }, Vg = (t, r) => qr((l) => {
    YT(t, l)((h) => {
      const y = t.onSetup(h);
      ye(y) && r.set(y);
    });
  }), hc = (t, r) => qf((l) => YT(t, l)(r.get())), EW = (t, r) => Td((l, d) => {
    YT(t, l)(t.onAction), !t.triggersSubmenu && r === im.CLOSE_ON_EXECUTE && (l.getSystem().isConnected() && Xo(l, Kb()), d.stop());
  }), xN = {
    [Wu()]: [
      "disabling",
      "alloy.base.behaviour",
      "toggling",
      "item-events"
    ]
  }, e0 = na, t0 = (t, r, l, d) => {
    const h = to(U);
    return {
      type: "item",
      dom: r.dom,
      components: e0(r.optComponents),
      data: t.data,
      eventOrder: xN,
      hasSubmenu: t.triggersSubmenu,
      itemBehaviours: Jt([
        jo("item-events", [
          EW(t, l),
          Vg(t, h),
          hc(t, h)
        ]),
        dm.item(() => !t.enabled || d.isDisabled()),
        ki(),
        Po.config({})
      ].concat(t.itemBehaviours))
    };
  }, Mx = (t) => ({
    value: t.value,
    meta: {
      text: t.text.getOr(""),
      ...t.meta
    }
  }), XT = (t) => {
    const r = _x.os.isMacOS() || _x.os.isiOS(), h = r ? {
      alt: "⌥",
      ctrl: "⌃",
      shift: "⇧",
      meta: "⌘",
      access: "⌃⌥"
    } : {
      meta: "Ctrl",
      access: "Shift+Alt"
    }, y = t.split("+"), w = et(y, (E) => {
      const O = E.toLowerCase().trim();
      return Ko(h, O) ? h[O] : E;
    });
    return r ? w.join("") : w.join("+");
  }, QT = (t, r, l = [YR]) => ku(t, {
    tag: "div",
    classes: l
  }, r), wN = (t) => ({
    dom: {
      tag: "div",
      classes: [MT]
    },
    components: [Aa(Pd.translate(t))]
  }), SL = (t, r) => ({
    dom: {
      tag: "div",
      classes: r,
      innerHtml: t
    }
  }), TW = (t, r) => ({
    dom: {
      tag: "div",
      classes: [MT]
    },
    components: [{
      dom: {
        tag: t.tag,
        styles: t.styles
      },
      components: [Aa(Pd.translate(r))]
    }]
  }), AW = (t) => ({
    dom: {
      tag: "div",
      classes: [qB]
    },
    components: [Aa(XT(t))]
  }), kL = (t) => QT("checkmark", t, [XR]), OW = (t) => QT("chevron-right", t, [KB]), _L = (t) => QT("chevron-down", t, [KB]), EL = (t, r) => {
    const l = t.direction === "vertical" ? YB : mb, d = t.align === "left" ? JR : Xj;
    return {
      dom: {
        tag: "div",
        classes: [
          QR,
          l,
          d,
          (() => {
            switch (t.valign) {
              case "top":
                return IT;
              case "middle":
                return Qj;
              case "bottom":
                return XB;
            }
          })()
        ]
      },
      components: r
    };
  }, TL = (t, r, l) => ({
    dom: {
      tag: "img",
      classes: r,
      attributes: {
        src: t,
        alt: l.getOr("")
      }
    }
  }), DW = (t, r, l) => {
    const d = "custom", h = "remove", y = t.value, w = t.iconContent.map((F) => UB(F, r.icons, l)), E = t.ariaLabel.map((F) => ({
      "aria-label": r.translate(F),
      "data-mce-name": F
    })).getOr({});
    return {
      dom: (() => {
        const F = qR, L = w.getOr(""), q = {
          tag: "div",
          attributes: E,
          classes: [F]
        };
        return y === d ? {
          ...q,
          tag: "button",
          classes: [
            ...q.classes,
            "tox-swatches__picker-btn"
          ],
          innerHtml: L
        } : y === h ? {
          ...q,
          classes: [
            ...q.classes,
            "tox-swatch--remove"
          ],
          innerHtml: L
        } : be(y) ? {
          ...q,
          attributes: {
            ...q.attributes,
            "data-mce-color": y
          },
          styles: { "background-color": y },
          innerHtml: L
        } : q;
      })(),
      optComponents: []
    };
  }, AL = (t) => {
    const r = t.map((l) => ({
      attributes: {
        id: Mn("menu-item"),
        "aria-label": Pd.translate(l)
      }
    })).getOr({});
    return {
      tag: "div",
      classes: [
        RT,
        NT
      ],
      ...r
    };
  }, RW = (t, r, l, d) => {
    const h = {
      tag: "div",
      classes: [YR]
    }, y = (ne) => ku(ne, h, r.icons, d), w = () => B.some({ dom: h }), E = l ? t.iconContent.map(y).orThunk(w) : B.none(), O = t.checkMark, F = B.from(t.meta).fold(() => wN, (ne) => Ko(ne, "style") ? Vt(TW, ne.style) : wN), L = t.htmlContent.fold(() => t.textContent.map(F), (ne) => B.some(SL(ne, [MT])));
    return {
      dom: AL(t.ariaLabel),
      optComponents: [
        E,
        L,
        t.shortcutContent.map(AW),
        O,
        t.caret
      ]
    };
  }, gh = (t, r, l, d = B.none()) => t.presets === "color" ? DW(t, r, d) : RW(t, r, l, d), OL = (t, r, l) => qt(t, "tooltipWorker").map((d) => [gl.config({
    lazySink: r.getSink,
    tooltipDom: {
      tag: "div",
      classes: ["tox-tooltip-worker-container"]
    },
    tooltipComponents: [],
    anchor: (h) => ({
      type: "submenu",
      item: h,
      overrides: { maxHeightFunction: jv }
    }),
    mode: "follow-highlight",
    onShow: (h, y) => {
      d((w) => {
        gl.setComponents(h, [xy({ element: $e.fromDom(w) })]);
      });
    }
  })]).getOrThunk(() => l.map((d) => [gl.config({
    ...r.providers.tooltips.getConfig({ tooltipText: d }),
    mode: "follow-highlight"
  })]).getOr([])), DL = (t) => j1.DOM.encode(t), CN = (t, r) => {
    const l = Pd.translate(t), d = DL(l);
    if (r.length > 0) {
      const h = new RegExp(wL(r), "gi");
      return d.replace(h, (y) => `<span class="tox-autocompleter-highlight">${y}</span>`);
    } else
      return d;
  }, RL = (t, r, l, d, h, y, w, E = !0) => {
    const O = gh({
      presets: d,
      textContent: B.none(),
      htmlContent: l ? t.text.map((L) => CN(L, r)) : B.none(),
      ariaLabel: t.text,
      iconContent: t.icon,
      shortcutContent: B.none(),
      checkMark: B.none(),
      caret: B.none(),
      value: t.value
    }, w.providers, E, t.icon), F = t.text.filter((L) => !l && L !== "");
    return t0({
      data: Mx(t),
      enabled: t.enabled,
      getApi: ee({}),
      onAction: (L) => h(t.value, t.meta),
      onSetup: ee(U),
      triggersSubmenu: !1,
      itemBehaviours: OL(t, w, F)
    }, O, y, w.providers);
  }, SN = (t, r) => et(t, (l) => {
    switch (l.type) {
      case "cardcontainer":
        return EL(l, SN(l.items, r));
      case "cardimage":
        return TL(l.src, l.classes, l.alt);
      case "cardtext":
        const h = l.name.exists((y) => pn(r.cardText.highlightOn, y)) ? B.from(r.cardText.matchText).getOr("") : "";
        return SL(CN(l.text, h), l.classes);
    }
  }), kN = (t, r, l, d) => {
    const h = (w) => ({
      isEnabled: () => !_o.isDisabled(w),
      setEnabled: (E) => {
        _o.set(w, !E), xt(Rl(w.element, "*"), (O) => {
          w.getSystem().getByDom(O).each((F) => {
            F.hasConfigured(_o) && _o.set(F, !E);
          });
        });
      }
    }), y = {
      dom: AL(t.label),
      optComponents: [B.some({
        dom: {
          tag: "div",
          classes: [
            QR,
            mb
          ]
        },
        components: SN(t.items, d)
      })]
    };
    return t0({
      data: Mx({
        text: B.none(),
        ...t
      }),
      enabled: t.enabled,
      getApi: h,
      onAction: t.onAction,
      onSetup: t.onSetup,
      triggersSubmenu: !1,
      itemBehaviours: B.from(d.itemBehaviours).getOr([])
    }, y, r, l.providers);
  }, _N = (t, r, l, d, h, y, w, E = !0) => {
    const O = (q) => ({
      setActive: (ne) => {
        ns.set(q, ne);
      },
      isActive: () => ns.isOn(q),
      isEnabled: () => !_o.isDisabled(q),
      setEnabled: (ne) => _o.set(q, !ne)
    }), F = gh({
      presets: l,
      textContent: r ? t.text : B.none(),
      htmlContent: B.none(),
      ariaLabel: t.text,
      iconContent: t.icon,
      shortcutContent: r ? t.shortcut : B.none(),
      checkMark: r ? B.some(kL(w.icons)) : B.none(),
      caret: B.none(),
      value: t.value
    }, w, E), L = t.text.filter(ee(!r)).map((q) => gl.config(w.tooltips.getConfig({ tooltipText: w.translate(q) })));
    return Pr(t0({
      data: Mx(t),
      enabled: t.enabled,
      getApi: O,
      onAction: (q) => d(t.value),
      onSetup: (q) => (q.setActive(h), U),
      triggersSubmenu: !1,
      itemBehaviours: [...L.toArray()]
    }, F, y, w), {
      toggling: {
        toggleClass: PT,
        toggleOnExecute: !1,
        selected: t.active,
        exclusive: !0
      }
    });
  }, JT = IC(pR(), hR()), EN = (t) => ({ value: ML(t) }), NL = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, TN = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, PL = (t) => NL.test(t) || TN.test(t), ML = (t) => gn(t, "#").toUpperCase(), NW = (t) => PL(t) ? B.some({ value: ML(t) }) : B.none(), IL = (t) => ({ value: t.value.replace(NL, (l, d, h, y) => d + d + h + h + y + y) }), FL = (t) => {
    const r = IL(t), l = TN.exec(r.value);
    return l === null ? [
      "FFFFFF",
      "FF",
      "FF",
      "FF"
    ] : l;
  }, eA = (t) => {
    const r = t.toString(16);
    return (r.length === 1 ? "0" + r : r).toUpperCase();
  }, kS = (t) => {
    const r = eA(t.red) + eA(t.green) + eA(t.blue);
    return EN(r);
  }, BL = Math.min, LL = Math.max, tA = Math.round, PW = /^\s*rgb\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*\)\s*$/i, MW = /^\s*rgba\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*((?:\d?\.\d+|\d+)%?)\s*\)\s*$/i, n0 = (t, r, l, d) => ({
    red: t,
    green: r,
    blue: l,
    alpha: d
  }), AN = (t) => {
    const r = parseInt(t, 10);
    return r.toString() === t && r >= 0 && r <= 255;
  }, $L = (t) => {
    let r, l, d;
    const h = (t.hue || 0) % 360;
    let y = t.saturation / 100, w = t.value / 100;
    if (y = LL(0, BL(y, 1)), w = LL(0, BL(w, 1)), y === 0)
      return r = l = d = tA(255 * w), n0(r, l, d, 1);
    const E = h / 60, O = w * y, F = O * (1 - Math.abs(E % 2 - 1)), L = w - O;
    switch (Math.floor(E)) {
      case 0:
        r = O, l = F, d = 0;
        break;
      case 1:
        r = F, l = O, d = 0;
        break;
      case 2:
        r = 0, l = O, d = F;
        break;
      case 3:
        r = 0, l = F, d = O;
        break;
      case 4:
        r = F, l = 0, d = O;
        break;
      case 5:
        r = O, l = 0, d = F;
        break;
      default:
        r = l = d = 0;
    }
    return r = tA(255 * (r + L)), l = tA(255 * (l + L)), d = tA(255 * (d + L)), n0(r, l, d, 1);
  }, _S = (t) => {
    const r = FL(t), l = parseInt(r[1], 16), d = parseInt(r[2], 16), h = parseInt(r[3], 16);
    return n0(l, d, h, 1);
  }, HL = (t, r, l, d) => {
    const h = parseInt(t, 10), y = parseInt(r, 10), w = parseInt(l, 10), E = parseFloat(d);
    return n0(h, y, w, E);
  }, nA = (t) => {
    const r = PW.exec(t);
    if (r !== null)
      return B.some(HL(r[1], r[2], r[3], "1"));
    const l = MW.exec(t);
    return l !== null ? B.some(HL(l[1], l[2], l[3], l[4])) : B.none();
  }, zL = (t) => `rgba(${t.red},${t.green},${t.blue},${t.alpha})`, VL = n0(255, 0, 0, 1), IW = (t) => {
    t.dispatch("SkinLoaded");
  }, FW = (t, r) => {
    t.dispatch("SkinLoadError", r);
  }, BW = (t) => {
    t.dispatch("ResizeEditor");
  }, Ix = (t, r) => {
    t.dispatch("ResizeContent", r);
  }, UL = (t, r) => {
    t.dispatch("ScrollContent", r);
  }, jL = (t, r) => {
    t.dispatch("TextColorChange", r);
  }, LW = (t, r) => {
    t.dispatch("AfterProgressState", { state: r });
  }, $W = (t, r) => t.dispatch("ResolveName", {
    name: r.nodeName.toLowerCase(),
    target: r
  }), HW = (t, r) => {
    t.dispatch("ToggleToolbarDrawer", { state: r });
  }, zW = (t, r) => {
    t.dispatch("StylesTextUpdate", r);
  }, VW = (t, r) => {
    t.dispatch("AlignTextUpdate", r);
  }, ON = (t, r) => {
    t.dispatch("FontSizeTextUpdate", r);
  }, WL = (t, r) => {
    t.dispatch("FontSizeInputTextUpdate", r);
  }, ZL = (t, r) => {
    t.dispatch("BlocksTextUpdate", r);
  }, UW = (t, r) => {
    t.dispatch("FontFamilyTextUpdate", r);
  }, ES = (t, r) => () => {
    t(), r();
  }, Mc = (t) => o0(t, "NodeChange", (r) => {
    r.setEnabled(t.selection.isEditable());
  }), jW = (t, r) => (l) => {
    const d = za(), h = () => {
      l.setActive(t.formatter.match(r));
      const y = t.formatter.formatChanged(r, l.setActive);
      d.set(y);
    };
    return t.initialized ? h() : t.once("init", h), () => {
      t.off("init", h), d.clear();
    };
  }, oA = (t, r) => (l) => {
    const d = Mc(t)(l), h = jW(t, r)(l);
    return () => {
      d(), h();
    };
  }, o0 = (t, r, l) => (d) => {
    const h = () => l(d), y = () => {
      l(d), t.on(r, h);
    };
    return t.initialized ? y() : t.once("init", y), () => {
      t.off("init", y), t.off(r, h);
    };
  }, GL = (t) => (r) => () => {
    t.undoManager.transact(() => {
      t.focus(), t.execCommand("mceToggleFormat", !1, r.format);
    });
  }, od = (t, r) => () => t.execCommand(r);
  var s0 = tinymce.util.Tools.resolve("tinymce.util.LocalStorage");
  const qL = {}, WW = (t, r = 10) => {
    const l = s0.getItem(t), d = A(l) ? JSON.parse(l) : [], y = ((F) => r - F.length < 0 ? F.slice(0, r) : F)(d), w = (F) => {
      Je(y, F).each(E), y.unshift(F), y.length > r && y.pop(), s0.setItem(t, JSON.stringify(y));
    }, E = (F) => {
      y.splice(F, 1);
    };
    return {
      add: w,
      state: () => y.slice(0)
    };
  }, KL = (t) => qt(qL, t).getOrThunk(() => {
    const r = `tinymce-custom-colors-${t}`, l = s0.getItem(r);
    if (Se(l)) {
      const h = s0.getItem("tinymce-custom-colors");
      s0.setItem(r, be(h) ? h : "[]");
    }
    const d = WW(r, 10);
    return qL[t] = d, d;
  }), sA = (t) => et(KL(t).state(), (r) => ({
    type: "choiceitem",
    text: r,
    icon: "checkmark",
    value: r
  })), rA = (t, r) => {
    KL(t).add(r);
  }, r0 = (t, r, l) => ({
    hue: t,
    saturation: r,
    value: l
  }), aA = (t) => {
    let r = 0, l = 0, d = 0;
    const h = t.red / 255, y = t.green / 255, w = t.blue / 255, E = Math.min(h, Math.min(y, w)), O = Math.max(h, Math.max(y, w));
    if (E === O)
      return d = E, r0(0, 0, d * 100);
    const F = h === E ? y - w : w === E ? h - y : w - h;
    return r = h === E ? 3 : w === E ? 1 : 5, r = 60 * (r - F / (O - E)), l = (O - E) / O, d = O, r0(Math.round(r), Math.round(l * 100), Math.round(d * 100));
  }, ZW = (t) => aA(_S(t)), YL = (t) => kS($L(t)), DN = (t) => NW(t).orThunk(() => nA(t).map(kS)).getOrThunk(() => {
    const r = document.createElement("canvas");
    r.height = 1, r.width = 1;
    const l = r.getContext("2d");
    l.clearRect(0, 0, r.width, r.height), l.fillStyle = "#FFFFFF", l.fillStyle = t, l.fillRect(0, 0, 1, 1);
    const d = l.getImageData(0, 0, 1, 1).data, h = d[0], y = d[1], w = d[2], E = d[3];
    return kS(n0(h, y, w, E));
  }), TS = "forecolor", Fx = "hilitecolor", XL = 5, GW = (t) => {
    const r = [];
    for (let l = 0; l < t.length; l += 2)
      r.push({
        text: t[l + 1],
        value: "#" + DN(t[l]).value,
        icon: "checkmark",
        type: "choiceitem"
      });
    return r;
  }, vh = (t) => (r) => r.options.get(t), RN = "#000000", qW = (t) => {
    const r = t.options.register, l = (h) => oe(h, A) ? {
      value: GW(h),
      valid: !0
    } : {
      valid: !1,
      message: "Must be an array of strings."
    }, d = (h) => re(h) && h > 0 ? {
      value: h,
      valid: !0
    } : {
      valid: !1,
      message: "Must be a positive number."
    };
    r("color_map", {
      processor: l,
      default: [
        "#BFEDD2",
        "Light Green",
        "#FBEEB8",
        "Light Yellow",
        "#F8CAC6",
        "Light Red",
        "#ECCAFA",
        "Light Purple",
        "#C2E0F4",
        "Light Blue",
        "#2DC26B",
        "Green",
        "#F1C40F",
        "Yellow",
        "#E03E2D",
        "Red",
        "#B96AD9",
        "Purple",
        "#3598DB",
        "Blue",
        "#169179",
        "Dark Turquoise",
        "#E67E23",
        "Orange",
        "#BA372A",
        "Dark Red",
        "#843FA1",
        "Dark Purple",
        "#236FA1",
        "Dark Blue",
        "#ECF0F1",
        "Light Gray",
        "#CED4D9",
        "Medium Gray",
        "#95A5A6",
        "Gray",
        "#7E8C8D",
        "Dark Gray",
        "#34495E",
        "Navy Blue",
        "#000000",
        "Black",
        "#ffffff",
        "White"
      ]
    }), r("color_map_background", { processor: l }), r("color_map_foreground", { processor: l }), r("color_cols", {
      processor: d,
      default: NN(t)
    }), r("color_cols_foreground", {
      processor: d,
      default: QL(t, TS)
    }), r("color_cols_background", {
      processor: d,
      default: QL(t, Fx)
    }), r("custom_colors", {
      processor: "boolean",
      default: !0
    }), r("color_default_foreground", {
      processor: "string",
      default: RN
    }), r("color_default_background", {
      processor: "string",
      default: RN
    });
  }, iA = (t, r) => r === TS && t.options.isSet("color_map_foreground") ? vh("color_map_foreground")(t) : r === Fx && t.options.isSet("color_map_background") ? vh("color_map_background")(t) : vh("color_map")(t), NN = (t, r = "default") => Math.max(XL, Math.ceil(Math.sqrt(iA(t, r).length))), QL = (t, r) => {
    const l = vh("color_cols")(t), d = NN(t, r);
    return l === NN(t) ? d : l;
  }, JL = (t, r = "default") => Math.round(r === TS ? vh("color_cols_foreground")(t) : r === Fx ? vh("color_cols_background")(t) : vh("color_cols")(t)), e6 = vh("custom_colors"), KW = vh("color_default_foreground"), YW = vh("color_default_background"), XW = "rgba(0, 0, 0, 0)", QW = (t) => nA(t).exists((r) => r.alpha !== 0), t6 = (t) => Uf(t, (r) => {
    if (ko(r)) {
      const l = lr(r, "background-color");
      return Xn(QW(l), l);
    } else
      return B.none();
  }).getOr(XW), n6 = (t, r) => {
    const l = $e.fromDom(t.selection.getStart()), d = r === "hilitecolor" ? t6(l) : lr(l, "color");
    return nA(d).map((h) => "#" + kS(h).value);
  }, JW = (t, r, l) => {
    t.undoManager.transact(() => {
      t.focus(), t.formatter.apply(r, { value: l }), t.nodeChanged();
    });
  }, bh = (t, r) => {
    t.undoManager.transact(() => {
      t.focus(), t.formatter.remove(r, { value: null }, void 0, !0), t.nodeChanged();
    });
  }, eZ = (t) => {
    t.addCommand("mceApplyTextcolor", (r, l) => {
      JW(t, r, l);
    }), t.addCommand("mceRemoveTextcolor", (r) => {
      bh(t, r);
    });
  }, o6 = (t) => {
    const r = "choiceitem", l = {
      type: r,
      text: "Remove color",
      icon: "color-swatch-remove-color",
      value: "remove"
    };
    return t ? [
      l,
      {
        type: r,
        text: "Custom color",
        icon: "color-picker",
        value: "custom"
      }
    ] : [l];
  }, AS = (t, r, l, d) => {
    l === "custom" ? c6(t)((y) => {
      y.each((w) => {
        rA(r, w), t.execCommand("mceApplyTextcolor", r, w), d(w);
      });
    }, n6(t, r).getOr(RN)) : l === "remove" ? (d(""), t.execCommand("mceRemoveTextcolor", r)) : (d(l), t.execCommand("mceApplyTextcolor", r, l));
  }, _i = (t, r, l) => t.concat(sA(r).concat(o6(l))), s6 = (t, r, l) => (d) => {
    d(_i(t, r, l));
  }, PN = (t, r, l) => {
    const d = r === "forecolor" ? "tox-icon-text-color__color" : "tox-icon-highlight-bg-color__color";
    t.setIconFill(d, l);
  }, r6 = (t, r) => {
    t.setTooltip(r);
  }, a6 = (t, r) => (l) => {
    const d = n6(t, r);
    return ha(d, l.toUpperCase());
  }, MN = (t, r, l) => {
    if (Ae(l))
      return r === "forecolor" ? "Text color" : "Background color";
    const d = r === "forecolor" ? "Text color {0}" : "Background color {0}", h = _i(iA(t, r), r, !1), y = Nt(h, (w) => w.value === l).getOr({ text: "" }).text;
    return t.translate([
      d,
      t.translate(y)
    ]);
  }, i6 = (t, r, l, d) => {
    t.ui.registry.addSplitButton(r, {
      tooltip: MN(t, l, d.get()),
      presets: "color",
      icon: r === "forecolor" ? "text-color" : "highlight-bg-color",
      select: a6(t, l),
      columns: JL(t, l),
      fetch: s6(iA(t, l), l, e6(t)),
      onAction: (h) => {
        AS(t, l, d.get(), U);
      },
      onItemAction: (h, y) => {
        AS(t, l, y, (w) => {
          d.set(w), jL(t, {
            name: r,
            color: w
          });
        });
      },
      onSetup: (h) => {
        PN(h, r, d.get());
        const y = (w) => {
          w.name === r && (PN(h, w.name, w.color), r6(h, MN(t, l, w.color)));
        };
        return t.on("TextColorChange", y), ES(Mc(t)(h), () => {
          t.off("TextColorChange", y);
        });
      }
    });
  }, l6 = (t, r, l, d, h) => {
    t.ui.registry.addNestedMenuItem(r, {
      text: d,
      icon: r === "forecolor" ? "text-color" : "highlight-bg-color",
      onSetup: (y) => (r6(y, MN(t, l, h.get())), PN(y, r, h.get()), Mc(t)(y)),
      getSubmenuItems: () => [{
        type: "fancymenuitem",
        fancytype: "colorswatch",
        select: a6(t, l),
        initData: { storageKey: l },
        onAction: (y) => {
          AS(t, l, y.value, (w) => {
            h.set(w), jL(t, {
              name: r,
              color: w
            });
          });
        }
      }]
    });
  }, c6 = (t) => (r, l) => {
    let d = !1;
    const h = (E) => {
      const F = E.getData().colorpicker;
      d ? (r(B.from(F)), E.close()) : t.windowManager.alert(t.translate([
        "Invalid hex color code: {0}",
        F
      ]));
    }, y = (E, O) => {
      O.name === "hex-valid" && (d = O.value);
    }, w = { colorpicker: l };
    t.windowManager.open({
      title: "Color Picker",
      size: "normal",
      body: {
        type: "panel",
        items: [{
          type: "colorpicker",
          name: "colorpicker",
          label: "Color"
        }]
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: w,
      onAction: y,
      onSubmit: h,
      onClose: U,
      onCancel: () => {
        r(B.none());
      }
    });
  }, tZ = (t) => {
    eZ(t);
    const r = KW(t), l = YW(t), d = to(r), h = to(l);
    i6(t, "forecolor", "forecolor", d), i6(t, "backcolor", "hilitecolor", h), l6(t, "forecolor", "forecolor", "Text color", d), l6(t, "backcolor", "hilitecolor", "Background color", h);
  }, IN = (t, r, l, d, h, y, w, E) => {
    const O = gS(r), L = nZ(r, l, d, h !== "color" ? "normal" : "color", y, w, E);
    return lN(t, O, L, d, { menuType: h });
  }, nZ = (t, r, l, d, h, y, w) => na(et(t, (E) => E.type === "choiceitem" ? bN(E).fold(Hg, (O) => B.some(_N(O, l === 1, d, r, y(O.value), h, w, gS(t)))) : B.none())), lA = (t, r) => {
    const l = pb(r);
    return t === 1 ? {
      mode: "menu",
      moveOnTab: !0
    } : t === "auto" ? {
      mode: "grid",
      selector: "." + l.item,
      initSize: {
        numColumns: 1,
        numRows: 1
      }
    } : {
      mode: "matrix",
      rowSelector: "." + (r === "color" ? "tox-swatches__row" : "tox-collection__group"),
      previousSelector: (h) => r === "color" ? or(h.element, "[aria-checked=true]") : B.none()
    };
  }, oZ = (t, r) => t === 1 ? {
    mode: "menu",
    moveOnTab: !1,
    selector: ".tox-collection__item"
  } : t === "auto" ? {
    mode: "flatgrid",
    selector: ".tox-collection__item",
    initSize: {
      numColumns: 1,
      numRows: 1
    }
  } : {
    mode: "matrix",
    selectors: {
      row: r === "color" ? ".tox-swatches__row" : ".tox-collection__group",
      cell: r === "color" ? `.${qR}` : `.${NT}`
    }
  }, sZ = (t, r) => {
    const l = rZ(t, r), d = r.colorinput.getColorCols(t.initData.storageKey), h = "color", w = {
      ...IN(Mn("menu-value"), l, (E) => {
        t.onAction({ value: E });
      }, d, h, im.CLOSE_ON_EXECUTE, t.select.getOr(_t), r.shared.providers),
      markers: pb(h),
      movement: lA(d, h),
      showMenuRole: !1
    };
    return {
      type: "widget",
      data: { value: Mn("widget-id") },
      dom: {
        tag: "div",
        classes: ["tox-fancymenuitem"]
      },
      autofocus: !0,
      components: [JT.widget(V1.sketch(w))]
    };
  }, rZ = (t, r) => {
    const l = t.initData.allowCustomColors && r.colorinput.hasCustomColors();
    return t.initData.colors.fold(() => _i(r.colorinput.getColors(t.initData.storageKey), t.initData.storageKey, l), (d) => d.concat(o6(l)));
  }, u6 = Mn("cell-over"), d6 = Mn("cell-execute"), aZ = (t) => (r, l) => t.shared.providers.translate([
    "{0} columns, {1} rows",
    l,
    r
  ]), iZ = (t, r, l) => {
    const d = (w) => po(w, u6, {
      row: t,
      col: r
    }), h = (w) => po(w, d6, {
      row: t,
      col: r
    }), y = (w, E) => {
      E.stop(), h(w);
    };
    return Ol({
      dom: {
        tag: "div",
        attributes: {
          role: "button",
          "aria-label": l
        }
      },
      behaviours: Jt([
        jo("insert-table-picker-cell", [
          Ft(jf(), To.focus),
          Ft(Wu(), h),
          Ft(tg(), y),
          Ft(rf(), y)
        ]),
        ns.config({
          toggleClass: "tox-insert-table-picker__selected",
          toggleOnExecute: !1
        }),
        To.config({ onFocus: d })
      ])
    });
  }, lZ = (t, r, l) => {
    const d = [];
    for (let h = 0; h < r; h++) {
      const y = [];
      for (let w = 0; w < l; w++) {
        const E = t(h + 1, w + 1);
        y.push(iZ(h, w, E));
      }
      d.push(y);
    }
    return d;
  }, cZ = (t, r, l, d, h) => {
    for (let y = 0; y < d; y++)
      for (let w = 0; w < h; w++)
        ns.set(t[y][w], y <= r && w <= l);
  }, uZ = (t) => je(t, (r) => et(r, Vl)), f6 = (t, r) => Aa(`${r}x${t}`), dZ = {
    inserttable: (t, r) => {
      const h = aZ(r), y = lZ(h, 10, 10), w = f6(0, 0), E = rr({
        dom: {
          tag: "span",
          classes: ["tox-insert-table-picker__label"]
        },
        components: [w],
        behaviours: Jt([Po.config({})])
      });
      return {
        type: "widget",
        data: { value: Mn("widget-id") },
        dom: {
          tag: "div",
          classes: ["tox-fancymenuitem"]
        },
        autofocus: !0,
        components: [JT.widget({
          dom: {
            tag: "div",
            classes: ["tox-insert-table-picker"]
          },
          components: uZ(y).concat(E.asSpec()),
          behaviours: Jt([
            jo("insert-table-picker", [
              qr((O) => {
                Po.set(E.get(O), [w]);
              }),
              rw(u6, (O, F, L) => {
                const { row: q, col: ne } = L.event;
                cZ(y, q, ne, 10, 10), Po.set(E.get(O), [f6(q + 1, ne + 1)]);
              }),
              rw(d6, (O, F, L) => {
                const { row: q, col: ne } = L.event;
                t.onAction({
                  numRows: q + 1,
                  numColumns: ne + 1
                }), Xo(O, Kb());
              })
            ]),
            so.config({
              initSize: {
                numRows: 10,
                numColumns: 10
              },
              mode: "flatgrid",
              selector: '[role="button"]'
            })
          ])
        })]
      };
    },
    colorswatch: sZ
  }, m6 = (t, r) => qt(dZ, t.fancytype).map((l) => l(t, r)), fZ = (t, r, l, d = !0, h = !1) => {
    const y = h ? _L(l.icons) : OW(l.icons), w = (O) => ({
      isEnabled: () => !_o.isDisabled(O),
      setEnabled: (F) => _o.set(O, !F),
      setIconFill: (F, L) => {
        or(O.element, `svg path[class="${F}"], rect[class="${F}"]`).each((q) => {
          sn(q, "fill", L);
        });
      },
      setTooltip: (F) => {
        const L = l.translate(F);
        sn(O.element, "aria-label", L);
      }
    }), E = gh({
      presets: "normal",
      iconContent: t.icon,
      textContent: t.text,
      htmlContent: B.none(),
      ariaLabel: t.text,
      caret: B.some(y),
      checkMark: B.none(),
      shortcutContent: t.shortcut
    }, l, d);
    return t0({
      data: Mx(t),
      getApi: w,
      enabled: t.enabled,
      onAction: U,
      onSetup: t.onSetup,
      triggersSubmenu: !0,
      itemBehaviours: []
    }, E, r, l);
  }, p6 = (t, r, l, d = !0) => {
    const h = (w) => ({
      isEnabled: () => !_o.isDisabled(w),
      setEnabled: (E) => _o.set(w, !E)
    }), y = gh({
      presets: "normal",
      iconContent: t.icon,
      textContent: t.text,
      htmlContent: B.none(),
      ariaLabel: t.text,
      caret: B.none(),
      checkMark: B.none(),
      shortcutContent: t.shortcut
    }, l, d);
    return t0({
      data: Mx(t),
      getApi: h,
      enabled: t.enabled,
      onAction: t.onAction,
      onSetup: t.onSetup,
      triggersSubmenu: !1,
      itemBehaviours: []
    }, y, r, l);
  }, mZ = (t) => ({
    type: "separator",
    dom: {
      tag: "div",
      classes: [
        NT,
        KR
      ]
    },
    components: t.text.map(Aa).toArray()
  }), pZ = (t, r, l, d = !0) => {
    const h = (w) => ({
      setActive: (E) => {
        ns.set(w, E);
      },
      isActive: () => ns.isOn(w),
      isEnabled: () => !_o.isDisabled(w),
      setEnabled: (E) => _o.set(w, !E)
    }), y = gh({
      iconContent: t.icon,
      textContent: t.text,
      htmlContent: B.none(),
      ariaLabel: t.text,
      checkMark: B.some(kL(l.icons)),
      caret: B.none(),
      shortcutContent: t.shortcut,
      presets: "normal",
      meta: t.meta
    }, l, d);
    return Pr(t0({
      data: Mx(t),
      enabled: t.enabled,
      getApi: h,
      onAction: t.onAction,
      onSetup: t.onSetup,
      triggersSubmenu: !1,
      itemBehaviours: []
    }, y, r, l), {
      toggling: {
        toggleClass: PT,
        toggleOnExecute: !1,
        selected: t.active
      },
      role: t.role.getOrUndefined()
    });
  }, hZ = RL, FN = mZ, gZ = p6, vZ = fZ, bZ = pZ, yZ = m6, h6 = kN;
  var wZ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getCoupled: (t, r, l, d) => l.getOrCreate(t, r, d),
    getExistingCoupled: (t, r, l, d) => l.getExisting(t, r, d)
  }), g6 = [Ls("others", Hu(Ho.value, pu()))], CZ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = {}, r = (y, w) => {
        if (os(y.others).length === 0)
          throw new Error("Cannot find any known coupled components");
        return qt(t, w);
      }, l = (y, w, E) => r(w, E).getOrThunk(() => {
        const F = qt(w.others, E).getOrDie("No information found for coupled component: " + E)(y), L = y.getSystem().build(F);
        return t[E] = L, L;
      }), d = (y, w, E) => r(w, E).orThunk(() => (qt(w.others, E).getOrDie("No information found for coupled component: " + E), B.none())), h = ee({});
      return qc({
        readState: h,
        getExisting: d,
        getOrCreate: l
      });
    }
  });
  const Ia = Xi({
    fields: g6,
    name: "coupling",
    apis: wZ,
    state: CZ
  }), BN = (t) => {
    let r = B.none(), l = [];
    const d = (F) => BN((L) => {
      h((q) => {
        L(F(q));
      });
    }), h = (F) => {
      w() ? O(F) : l.push(F);
    }, y = (F) => {
      w() || (r = B.some(F), E(l), l = []);
    }, w = () => r.isSome(), E = (F) => {
      xt(F, O);
    }, O = (F) => {
      r.each((L) => {
        setTimeout(() => {
          F(L);
        }, 0);
      });
    };
    return t(y), {
      get: h,
      map: d,
      isReady: w
    };
  }, SZ = {
    nu: BN,
    pure: (t) => BN((r) => {
      r(t);
    })
  }, kZ = (t) => {
    setTimeout(() => {
      throw t;
    }, 0);
  }, Bx = (t) => {
    const r = (O) => {
      t().then(O, kZ);
    };
    return {
      map: (O) => Bx(() => t().then(O)),
      bind: (O) => Bx(() => t().then((F) => O(F).toPromise())),
      anonBind: (O) => Bx(() => t().then(() => O.toPromise())),
      toLazy: () => SZ.nu(r),
      toCached: () => {
        let O = null;
        return Bx(() => (O === null && (O = t()), O));
      },
      toPromise: t,
      get: r
    };
  }, Zl = {
    nu: (t) => Bx(() => new Promise(t)),
    pure: (t) => Bx(() => Promise.resolve(t))
  }, v6 = ee("sink"), b6 = ee(Su({
    name: v6(),
    overrides: ee({
      dom: { tag: "div" },
      behaviours: Jt([tl.config({ useFixed: ot })]),
      events: zr([
        lf(Ed()),
        lf(sc()),
        lf(tg())
      ])
    })
  })), LN = (t, r) => {
    const l = t.getHotspot(r).getOr(r), d = "hotspot", h = t.getAnchorOverrides();
    return t.layouts.fold(() => ({
      type: d,
      hotspot: l,
      overrides: h
    }), (y) => ({
      type: d,
      hotspot: l,
      overrides: h,
      layouts: y
    }));
  }, _Z = (t, r, l) => {
    const d = t.fetch;
    return d(l).map(r);
  }, EZ = (t, r, l, d, h, y, w) => {
    const E = _Z(t, r, d), O = y6(d, t);
    return E.map((F) => F.bind((L) => {
      const q = L.menus[L.primary];
      return B.from(q).each((ne) => {
        t.listRole.each((ae) => {
          ne.role = ae;
        });
      }), B.from(U1.sketch({
        ...y.menu(),
        uid: hg(""),
        data: L,
        highlightOnOpen: w,
        onOpenMenu: (ne, ae) => {
          const de = O().getOrDie();
          tl.position(de, ae, { anchor: l }), Ns.decloak(h);
        },
        onOpenSubmenu: (ne, ae, de) => {
          const _e = O().getOrDie();
          tl.position(_e, de, {
            anchor: {
              type: "submenu",
              item: ae
            }
          }), Ns.decloak(h);
        },
        onRepositionMenu: (ne, ae, de) => {
          const _e = O().getOrDie();
          tl.position(_e, ae, { anchor: l }), xt(de, (st) => {
            tl.position(_e, st.triggeredMenu, {
              anchor: {
                type: "submenu",
                item: st.triggeringItem
              }
            });
          });
        },
        onEscape: () => (To.focus(d), Ns.close(h), B.some(!0))
      }));
    }));
  }, cA = (t, r, l, d, h, y, w) => {
    const E = LN(t, l);
    return EZ(t, r, E, l, d, h, w).map((F) => (F.fold(() => {
      Ns.isOpen(d) && Ns.close(d);
    }, (L) => {
      Ns.cloak(d), Ns.open(d, L), y(d);
    }), d));
  }, TZ = (t, r, l, d, h, y, w) => (Ns.close(d), Zl.pure(d)), $N = (t, r, l, d, h, y) => {
    const w = Ia.getCoupled(l, "sandbox");
    return (Ns.isOpen(w) ? TZ : cA)(t, r, l, w, d, h, y);
  }, HN = (t, r, l) => {
    const d = Ds.getCurrent(r).getOr(r), h = Ri(t.element);
    l ? Ln(d.element, "min-width", h + "px") : fs(d.element, h);
  }, y6 = (t, r) => t.getSystem().getByUid(r.uid + "-" + v6()).map((l) => () => Ho.value(l)).getOrThunk(() => r.lazySink.fold(() => () => Ho.error(new Error("No internal sink is specified, nor could an external sink be found")), (l) => () => l(t))), x6 = (t) => {
    Ns.getState(t).each((r) => {
      U1.repositionMenus(r);
    });
  }, zN = (t, r, l) => {
    const d = Sy(), h = (E, O) => {
      const F = LN(t, r);
      d.link(r.element), t.matchWidth && HN(F.hotspot, O, t.useMinWidth), t.onOpen(F, E, O), l !== void 0 && l.onOpen !== void 0 && l.onOpen(E, O);
    }, y = (E, O) => {
      d.unlink(r.element), w().getOr(O).element.dom.dispatchEvent(new window.FocusEvent("focusout")), l !== void 0 && l.onClose !== void 0 && l.onClose(E, O);
    }, w = y6(r, t);
    return {
      dom: {
        tag: "div",
        classes: t.sandboxClasses,
        attributes: { id: d.id }
      },
      behaviours: Yu.augment(t.sandboxBehaviours, [
        In.config({
          store: {
            mode: "memory",
            initialValue: r
          }
        }),
        Ns.config({
          onOpen: h,
          onClose: y,
          isPartOf: (E, O, F) => qp(O, F) || qp(r, F),
          getAttachPoint: () => w().getOrDie()
        }),
        Ds.config({
          find: (E) => Ns.getState(E).bind((O) => Ds.getCurrent(O))
        }),
        Rc.config({
          channels: {
            ...qm({ isExtraPart: _t }),
            ...nx({ doReposition: x6 })
          }
        })
      ])
    };
  }, VN = (t) => {
    const r = Ia.getCoupled(t, "sandbox");
    x6(r);
  }, uA = () => [
    Xe("sandboxClasses", []),
    Yu.field("sandboxBehaviours", [
      Ds,
      Rc,
      Ns,
      In
    ])
  ], AZ = ee([
    Mt("dom"),
    Mt("fetch"),
    Os("onOpen"),
    ic("onExecute"),
    Xe("getHotspot", B.some),
    Xe("getAnchorOverrides", ee({})),
    nh(),
    $i("dropdownBehaviours", [
      ns,
      Ia,
      so,
      To
    ]),
    Mt("toggleClass"),
    Xe("eventOrder", {}),
    $s("lazySink"),
    Xe("matchWidth", !1),
    Xe("useMinWidth", !1),
    $s("role"),
    $s("listRole")
  ].concat(uA())), OZ = ee([
    Xu({
      schema: [
        pg(),
        Xe("fakeFocus", !1)
      ],
      name: "menu",
      defaults: (t) => ({ onExecute: t.onExecute })
    }),
    b6()
  ]), w6 = (t, r, l, d) => {
    const h = (L) => qt(t.dom, "attributes").bind((q) => qt(q, L)), y = (L) => {
      Ns.getState(L).each((q) => {
        U1.highlightPrimary(q);
      });
    }, w = (L, q, ne) => $N(t, lt, L, d, q, ne), E = (L) => {
      w(L, y, Pc.HighlightMenuAndItem).get(U);
    }, O = {
      expand: (L) => {
        ns.isOn(L) || w(L, U, Pc.HighlightNone).get(U);
      },
      open: (L) => {
        ns.isOn(L) || w(L, U, Pc.HighlightMenuAndItem).get(U);
      },
      refetch: (L) => Ia.getExistingCoupled(L, "sandbox").fold(() => w(L, U, Pc.HighlightMenuAndItem).map(U), (ne) => cA(t, lt, L, ne, d, U, Pc.HighlightMenuAndItem).map(U)),
      isOpen: ns.isOn,
      close: (L) => {
        ns.isOn(L) && w(L, U, Pc.HighlightMenuAndItem).get(U);
      },
      repositionMenus: (L) => {
        ns.isOn(L) && VN(L);
      }
    }, F = (L, q) => (Hp(L), B.some(!0));
    return {
      uid: t.uid,
      dom: t.dom,
      components: r,
      behaviours: Hi(t.dropdownBehaviours, [
        ns.config({
          toggleClass: t.toggleClass,
          aria: { mode: "expanded" }
        }),
        Ia.config({
          others: {
            sandbox: (L) => zN(t, L, {
              onOpen: () => ns.on(L),
              onClose: () => ns.off(L)
            })
          }
        }),
        so.config({
          mode: "special",
          onSpace: F,
          onEnter: F,
          onDown: (L, q) => {
            if (wf.isOpen(L)) {
              const ne = Ia.getCoupled(L, "sandbox");
              y(ne);
            } else
              wf.open(L);
            return B.some(!0);
          },
          onEscape: (L, q) => wf.isOpen(L) ? (wf.close(L), B.some(!0)) : B.none()
        }),
        To.config({})
      ]),
      events: aT(B.some(E)),
      eventOrder: {
        ...t.eventOrder,
        [Wu()]: [
          "disabling",
          "toggling",
          "alloy.base.behaviour"
        ]
      },
      apis: O,
      domModification: {
        attributes: {
          "aria-haspopup": t.listRole.getOr("true"),
          ...t.role.fold(() => ({}), (L) => ({ role: L })),
          ...t.dom.tag === "button" ? { type: h("type").getOr("button") } : {}
        }
      }
    };
  }, wf = Wl({
    name: "Dropdown",
    configFields: AZ(),
    partFields: OZ(),
    factory: w6,
    apis: {
      open: (t, r) => t.open(r),
      refetch: (t, r) => t.refetch(r),
      expand: (t, r) => t.expand(r),
      close: (t, r) => t.close(r),
      isOpen: (t, r) => t.isOpen(r),
      repositionMenus: (t, r) => t.repositionMenus(r)
    }
  }), DZ = (t) => {
    switch (t.searchMode) {
      case "no-search":
        return { menuType: "normal" };
      default:
        return {
          menuType: "searchable",
          searchMode: t
        };
    }
  }, RZ = (t) => {
    const r = In.getValue(t), l = hb(t).map(nL);
    wf.refetch(r).get(() => {
      const d = Ia.getCoupled(r, "sandbox");
      l.each((h) => hb(d).each((y) => nW(y, h)));
    });
  }, NZ = (t, r) => {
    PZ(t).each((l) => {
      ow(t, l.element, r.event.eventType, r.event.interactionEvent);
    });
  }, PZ = (t) => Ns.getState(t).bind(yn.getHighlighted).bind(yn.getHighlighted), MZ = (t) => Kc(t.element, FT) ? B.some(t.element) : or(t.element, "." + FT), OS = (t, r, l) => {
    rN(t).each((d) => {
      oW(d, l), MZ(r).each((y) => {
        Y(y, "id").each((w) => sn(d.element, "aria-controls", w));
      });
    }), sn(l.element, "aria-selected", "true");
  }, IZ = (t, r, l) => {
    sn(l.element, "aria-selected", "false");
  }, dA = (t) => {
    rN(t).each((r) => To.focus(r));
  }, FZ = (t) => Ia.getExistingCoupled(t, "sandbox").bind(hb).map(nL).map((l) => l.fetchPattern).getOr("");
  var fA;
  (function(t) {
    t[t.ContentFocus = 0] = "ContentFocus", t[t.UiFocus = 1] = "UiFocus";
  })(fA || (fA = {}));
  const BZ = (t, r, l, d, h) => {
    const y = l.shared.providers, w = (E) => h ? {
      ...E,
      shortcut: B.none(),
      icon: E.text.isSome() ? B.none() : E.icon
    } : E;
    switch (t.type) {
      case "menuitem":
        return xW(t).fold(Hg, (E) => B.some(gZ(w(E), r, y, d)));
      case "nestedmenuitem":
        return CW(t).fold(Hg, (E) => B.some(vZ(w(E), r, y, d, h)));
      case "togglemenuitem":
        return kW(t).fold(Hg, (E) => B.some(bZ(w(E), r, y, d)));
      case "separator":
        return mL(t).fold(Hg, (E) => B.some(FN(E)));
      case "fancymenuitem":
        return yL(t).fold(Hg, (E) => yZ(E, l));
      default:
        return console.error("Unknown item in general menu", t), B.none();
    }
  }, LZ = (t, r, l, d, h, y, w) => {
    const E = d === 1, O = !E || gS(t);
    return na(et(t, (F) => {
      switch (F.type) {
        case "separator":
          return fW(F).fold(Hg, (L) => B.some(FN(L)));
        case "cardmenuitem":
          return vN(F).fold(Hg, (L) => B.some(h6({
            ...L,
            onAction: (q) => {
              L.onAction(q), l(L.value, L.meta);
            }
          }, h, y, {
            itemBehaviours: OL(L.meta, y, B.none()),
            cardText: {
              matchText: r,
              highlightOn: w
            }
          })));
        case "autocompleteitem":
        default:
          return mW(F).fold(Hg, (L) => B.some(hZ(L, r, E, "normal", l, h, y, O)));
      }
    }));
  }, $Z = (t, r, l, d, h, y) => {
    const w = gS(r), E = na(et(r, (L) => {
      const q = (ae) => h ? !Ko(ae, "text") : w, ne = (ae) => BZ(ae, l, d, q(ae), h);
      return L.type === "nestedmenuitem" && L.getSubmenuItems().length <= 0 ? ne({
        ...L,
        enabled: !1
      }) : ne(L);
    })), O = DZ(y);
    return (h ? aW : lN)(t, w, E, 1, O);
  }, Lx = (t) => U1.singleData(t.value, t), $x = (t, r, l, d) => {
    const h = lA(r, d), y = pb(d);
    return {
      data: Lx({
        ...t,
        movement: h,
        menuBehaviours: Px.unnamedEvents(r !== "auto" ? [] : [qr((w, E) => {
          qT(w, 4, y.item).each(({ numColumns: O, numRows: F }) => {
            so.setGridSize(w, F, O);
          });
        })])
      }),
      menu: {
        markers: pb(d),
        fakeFocus: l === fA.ContentFocus
      }
    };
  }, C6 = (t) => Wv.create($e.fromDom(t.startContainer), t.startOffset, $e.fromDom(t.endContainer), t.endOffset), zZ = { register: (t, r) => {
    const l = Mn("autocompleter"), d = to(!1), h = to(!1), y = cr(), w = Ol(aa.sketch({
      dom: {
        tag: "div",
        classes: ["tox-autocompleter"],
        attributes: { id: l }
      },
      components: [],
      fireDismissalEventInstead: {},
      inlineBehaviours: Jt([jo("dismissAutocompleter", [
        Ft(Lp(), () => q()),
        Ft($p(), (Re, Qe) => {
          Y(Qe.event.target, "id").each((qe) => sn($e.fromDom(t.getBody()), "aria-activedescendant", qe));
        })
      ])]),
      lazySink: r.getSink
    })), E = () => aa.isOpen(w), O = h.get, F = () => {
      if (E()) {
        aa.hide(w), t.dom.remove(l, !1);
        const Re = $e.fromDom(t.getBody());
        Y(Re, "aria-owns").filter((Qe) => Qe === l).each(() => {
          Ee(Re, "aria-owns"), Ee(Re, "aria-activedescendant");
        });
      }
    }, L = () => aa.getContent(w).bind((Re) => Dn(Re.components(), 0)), q = () => t.execCommand("mceAutocompleterClose"), ne = (Re) => {
      const Qe = Qo(Re, (qe) => B.from(qe.columns)).getOr(1);
      return je(Re, (qe) => {
        const Bt = qe.items;
        return LZ(Bt, qe.matchText, (pt, en) => {
          const bn = {
            hide: () => q(),
            reload: (It) => {
              F(), t.execCommand("mceAutocompleterReload", !1, { fetchOptions: It });
            }
          };
          t.execCommand("mceAutocompleterRefreshActiveRange"), y.get().each((It) => {
            d.set(!0), qe.onAction(bn, It, pt, en), d.set(!1);
          });
        }, Qe, im.BUBBLE_TO_SANDBOX, r, qe.highlightOn);
      });
    }, ae = (Re, Qe) => {
      const qe = Qo(Re, (Bt) => B.from(Bt.columns)).getOr(1);
      aa.showMenuAt(w, {
        anchor: {
          type: "selection",
          getSelection: () => y.get().map(C6),
          root: $e.fromDom(t.getBody())
        }
      }, $x(lN("autocompleter-value", !0, Qe, qe, { menuType: "normal" }), qe, fA.ContentFocus, "normal")), L().each(yn.highlightFirst);
    }, de = (Re) => {
      const Qe = ne(Re);
      Qe.length > 0 ? (ae(Re, Qe), sn($e.fromDom(t.getBody()), "aria-owns", l), t.inline || _e()) : F();
    }, _e = () => {
      t.dom.get(l) && t.dom.remove(l, !1);
      const Re = t.getDoc().documentElement, Qe = t.selection.getNode(), qe = yO(w.element);
      Or(qe, {
        border: "0",
        clip: "rect(0 0 0 0)",
        height: "1px",
        margin: "-1px",
        overflow: "hidden",
        padding: "0",
        position: "absolute",
        width: "1px",
        top: `${Qe.offsetTop}px`,
        left: `${Qe.offsetLeft}px`
      }), t.dom.add(Re, qe.dom), or(qe, '[role="menu"]').each((Bt) => {
        gs(Bt, "position"), gs(Bt, "max-height");
      });
    };
    t.on("AutocompleterStart", ({ lookupData: Re }) => {
      h.set(!0), d.set(!1), de(Re);
    }), t.on("AutocompleterUpdate", ({ lookupData: Re }) => de(Re)), t.on("AutocompleterUpdateActiveRange", ({ range: Re }) => y.set(Re)), t.on("AutocompleterEnd", () => {
      F(), h.set(!1), d.set(!1), y.clear();
    });
    const st = {
      cancelIfNecessary: q,
      isMenuOpen: E,
      isActive: O,
      isProcessingAction: d.get,
      getMenu: L
    };
    ZB.setup(st, t);
  } }, DS = (t, r, l) => pf(t, r, l).isSome(), S6 = (t, r) => {
    let l = null;
    return {
      cancel: () => {
        l !== null && (clearTimeout(l), l = null);
      },
      schedule: (...y) => {
        l = setTimeout(() => {
          t.apply(null, y), l = null;
        }, r);
      }
    };
  }, k6 = 5, VZ = 400, _6 = (t) => {
    const r = t.raw;
    return r.touches === void 0 || r.touches.length !== 1 ? B.none() : B.some(r.touches[0]);
  }, UZ = (t, r) => {
    const l = Math.abs(t.clientX - r.x), d = Math.abs(t.clientY - r.y);
    return l > k6 || d > k6;
  }, jZ = (t) => {
    const r = cr(), l = to(!1), d = S6((F) => {
      t.triggerEvent(Tl(), F), l.set(!0);
    }, VZ), h = (F) => (_6(F).each((L) => {
      d.cancel();
      const q = {
        x: L.clientX,
        y: L.clientY,
        target: F.target
      };
      d.schedule(F), l.set(!1), r.set(q);
    }), B.none()), y = (F) => (d.cancel(), _6(F).each((L) => {
      r.on((q) => {
        UZ(L, q) && r.clear();
      });
    }), B.none()), w = (F) => {
      d.cancel();
      const L = (q) => Is(q.target, F.target);
      return r.get().filter(L).map((q) => l.get() ? (F.prevent(), !1) : t.triggerEvent(rf(), F));
    }, E = Us([
      {
        key: vs(),
        value: h
      },
      {
        key: Gr(),
        value: y
      },
      {
        key: Ja(),
        value: w
      }
    ]);
    return { fireIfReady: (F, L) => qt(E, L).bind((q) => q(F)) };
  }, WZ = (t) => t.raw.which === Ks[0] && !pn([
    "input",
    "textarea"
  ], Gs(t.target)) && !DS(t.target, '[contenteditable="true"]'), ZZ = (t, r) => {
    const l = {
      stopBackspace: !0,
      ...r
    }, d = [
      "touchstart",
      "touchmove",
      "touchend",
      "touchcancel",
      "gesturestart",
      "mousedown",
      "mouseup",
      "mouseover",
      "mousemove",
      "mouseout",
      "click"
    ], h = jZ(l), y = et(d.concat([
      "selectstart",
      "input",
      "contextmenu",
      "change",
      "transitionend",
      "transitioncancel",
      "drag",
      "dragstart",
      "dragend",
      "dragenter",
      "dragleave",
      "dragover",
      "drop",
      "keyup"
    ]), (ae) => uc(t, ae, (de) => {
      h.fireIfReady(de, ae).each((st) => {
        st && de.kill();
      }), l.triggerEvent(ae, de) && de.kill();
    })), w = cr(), E = uc(t, "paste", (ae) => {
      h.fireIfReady(ae, "paste").each((_e) => {
        _e && ae.kill();
      }), l.triggerEvent("paste", ae) && ae.kill(), w.set(setTimeout(() => {
        l.triggerEvent(Bm(), ae);
      }, 0));
    }), O = uc(t, "keydown", (ae) => {
      l.triggerEvent("keydown", ae) ? ae.kill() : l.stopBackspace && WZ(ae) && ae.prevent();
    }), F = uc(t, "focusin", (ae) => {
      l.triggerEvent("focusin", ae) && ae.kill();
    }), L = cr(), q = uc(t, "focusout", (ae) => {
      l.triggerEvent("focusout", ae) && ae.kill(), L.set(setTimeout(() => {
        l.triggerEvent(Bp(), ae);
      }, 0));
    });
    return { unbind: () => {
      xt(y, (ae) => {
        ae.unbind();
      }), O.unbind(), F.unbind(), q.unbind(), E.unbind(), w.on(clearTimeout), L.on(clearTimeout);
    } };
  }, E6 = (t, r) => {
    const l = qt(t, "target").getOr(r);
    return to(l);
  }, T6 = (t, r) => {
    const l = to(!1), d = to(!1);
    return {
      stop: () => {
        l.set(!0);
      },
      cut: () => {
        d.set(!0);
      },
      isStopped: l.get,
      isCut: d.get,
      event: t,
      setSource: r.set,
      getSource: r.get
    };
  }, Hx = (t) => {
    const r = to(!1);
    return {
      stop: () => {
        r.set(!0);
      },
      cut: U,
      isStopped: r.get,
      isCut: _t,
      event: t,
      setSource: Ce("Cannot set source of a broadcasted event"),
      getSource: Ce("Cannot get source of a broadcasted event")
    };
  }, np = Be.generate([
    { stopped: [] },
    { resume: ["element"] },
    { complete: [] }
  ]), A6 = (t, r, l, d, h, y) => {
    const w = t(r, d), E = T6(l, h);
    return w.fold(() => (y.logEventNoHandlers(r, d), np.complete()), (O) => {
      const F = O.descHandler;
      return Zp(F)(E), E.isStopped() ? (y.logEventStopped(r, O.element, F.purpose), np.stopped()) : E.isCut() ? (y.logEventCut(r, O.element, F.purpose), np.complete()) : Za(O.element).fold(() => (y.logNoParent(r, O.element, F.purpose), np.complete()), (q) => (y.logEventResponse(r, O.element, F.purpose), np.resume(q)));
    });
  }, UN = (t, r, l, d, h, y) => A6(t, r, l, d, h, y).fold(ot, (w) => UN(t, r, l, w, h, y), _t), O6 = (t, r, l, d, h) => {
    const y = E6(l, d);
    return A6(t, r, l, d, y, h);
  }, mA = (t, r, l) => {
    const d = Hx(r);
    return xt(t, (h) => {
      const y = h.descHandler;
      Zp(y)(d);
    }), d.isStopped();
  }, GZ = (t, r, l, d) => zx(t, r, l, l.target, d), zx = (t, r, l, d, h) => {
    const y = E6(l, d);
    return UN(t, r, l, d, y, h);
  }, RS = (t, r) => ({
    element: t,
    descHandler: r
  }), qZ = (t, r) => ({
    id: t,
    descHandler: r
  }), KZ = () => {
    const t = {}, r = (w, E, O) => {
      it(O, (F, L) => {
        const q = t[L] !== void 0 ? t[L] : {};
        q[E] = u1(F, w), t[L] = q;
      });
    }, l = (w, E) => c1(E).bind((O) => qt(w, O)).map((O) => RS(E, O));
    return {
      registerId: r,
      unregisterId: (w) => {
        it(t, (E, O) => {
          Ko(E, w) && delete E[w];
        });
      },
      filterByType: (w) => qt(t, w).map((E) => ta(E, (O, F) => qZ(F, O))).getOr([]),
      find: (w, E, O) => qt(t, E).bind((F) => Uf(O, (L) => l(F, L), w))
    };
  }, YZ = () => {
    const t = KZ(), r = {}, l = (F) => {
      const L = F.element;
      return c1(L).getOrThunk(() => _O("uid-", F.element));
    }, d = (F, L) => {
      const q = r[L];
      if (q === F)
        y(F);
      else
        throw new Error('The tagId "' + L + '" is already used by: ' + Xc(q.element) + `
Cannot use it for: ` + Xc(F.element) + `
The conflicting element is` + (hs(q.element) ? " " : " not ") + "already in the DOM");
    }, h = (F) => {
      const L = l(F);
      Lr(r, L) && d(F, L);
      const q = [F];
      t.registerId(q, L, F.events), r[L] = F;
    }, y = (F) => {
      c1(F.element).each((L) => {
        delete r[L], t.unregisterId(L);
      });
    };
    return {
      find: (F, L, q) => t.find(F, L, q),
      filter: (F) => t.filterByType(F),
      register: h,
      unregister: y,
      getById: (F) => qt(r, F)
    };
  }, op = Nc({
    name: "Container",
    factory: (t) => {
      const { attributes: r, ...l } = t.dom;
      return {
        uid: t.uid,
        dom: {
          tag: "div",
          attributes: {
            role: "presentation",
            ...r
          },
          ...l
        },
        components: t.components,
        behaviours: A1(t.containerBehaviours),
        events: t.events,
        domModification: t.domModification,
        eventOrder: t.eventOrder
      };
    },
    configFields: [
      Xe("components", []),
      $i("containerBehaviours", []),
      Xe("events", {}),
      Xe("domModification", {}),
      Xe("eventOrder", {})
    ]
  }), jN = (t) => {
    const r = (Re) => Za(t.element).fold(ot, (Qe) => Is(Re, Qe)), l = YZ(), d = (Re, Qe) => l.find(r, Re, Qe), h = ZZ(t.element, {
      triggerEvent: (Re, Qe) => ff(Re, Qe.target, (qe) => GZ(d, Re, Qe, qe))
    }), y = {
      debugInfo: ee("real"),
      triggerEvent: (Re, Qe, qe) => {
        ff(Re, Qe, (Bt) => zx(d, Re, qe, Qe, Bt));
      },
      triggerFocus: (Re, Qe) => {
        c1(Re).fold(() => {
          vu(Re);
        }, (qe) => {
          ff(sf(), Re, (Bt) => (O6(d, sf(), {
            originator: Qe,
            kill: U,
            prevent: U,
            target: Re
          }, Re, Bt), !1));
        });
      },
      triggerEscape: (Re, Qe) => {
        y.triggerEvent("keydown", Re.element, Qe.event);
      },
      getByUid: (Re) => _e(Re),
      getByDom: (Re) => st(Re),
      build: Ol,
      buildOrPatch: wy,
      addToGui: (Re) => {
        O(Re);
      },
      removeFromGui: (Re) => {
        F(Re);
      },
      addToWorld: (Re) => {
        w(Re);
      },
      removeFromWorld: (Re) => {
        E(Re);
      },
      broadcast: (Re) => {
        ne(Re);
      },
      broadcastOn: (Re, Qe) => {
        ae(Re, Qe);
      },
      broadcastEvent: (Re, Qe) => {
        de(Re, Qe);
      },
      isConnected: ot
    }, w = (Re) => {
      Re.connect(y), Zo(Re.element) || (l.register(Re), xt(Re.components(), w), y.triggerEvent(Yb(), Re.element, { target: Re.element }));
    }, E = (Re) => {
      Zo(Re.element) || (xt(Re.components(), E), l.unregister(Re)), Re.disconnect();
    }, O = (Re) => {
      em(t, Re);
    }, F = (Re) => {
      Gm(Re);
    }, L = () => {
      h.unbind(), _c(t.element);
    }, q = (Re) => {
      const Qe = l.filter(ju());
      xt(Qe, (qe) => {
        const Bt = qe.descHandler;
        Zp(Bt)(Re);
      });
    }, ne = (Re) => {
      q({
        universal: !0,
        data: Re
      });
    }, ae = (Re, Qe) => {
      q({
        universal: !1,
        channels: Re,
        data: Qe
      });
    }, de = (Re, Qe) => {
      const qe = l.filter(Re);
      return mA(qe, Qe);
    }, _e = (Re) => l.getById(Re).fold(() => Ho.error(new Error('Could not find component with uid: "' + Re + '" in system.')), Ho.value), st = (Re) => {
      const Qe = c1(Re).getOr("not found");
      return _e(Qe);
    };
    return w(t), {
      root: t,
      element: t.element,
      destroy: L,
      add: O,
      remove: F,
      getByUid: _e,
      getByDom: st,
      addToWorld: w,
      removeFromWorld: E,
      broadcast: ne,
      broadcastOn: ae,
      broadcastEvent: de
    };
  }, pA = (t, r) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-bar",
        "tox-form__controls-h-stack"
      ]
    },
    components: et(t.items, r.interpreter)
  }), XZ = ee([
    Xe("prefix", "form-field"),
    $i("fieldBehaviours", [
      Ds,
      In
    ])
  ]), WN = ee([
    Su({
      schema: [Mt("dom")],
      name: "label"
    }),
    Su({
      factory: {
        sketch: (t) => ({
          uid: t.uid,
          dom: {
            tag: "span",
            styles: { display: "none" },
            attributes: { "aria-hidden": "true" },
            innerHtml: t.text
          }
        })
      },
      schema: [Mt("text")],
      name: "aria-descriptor"
    }),
    hl({
      factory: {
        sketch: (t) => {
          const r = ts(t, ["factory"]);
          return t.factory.sketch(r);
        }
      },
      schema: [Mt("factory")],
      name: "field"
    })
  ]), QZ = (t, r, l, d) => {
    const h = Hi(t.fieldBehaviours, [
      Ds.config({
        find: (E) => Qt(E, t, "field")
      }),
      In.config({
        store: {
          mode: "manual",
          getValue: (E) => Ds.getCurrent(E).bind(In.getValue),
          setValue: (E, O) => {
            Ds.getCurrent(E).each((F) => {
              In.setValue(F, O);
            });
          }
        }
      })
    ]), y = zr([qr((E, O) => {
      const F = VE(E, t, [
        "label",
        "field",
        "aria-descriptor"
      ]);
      F.field().each((L) => {
        const q = Mn(t.prefix);
        F.label().each((ne) => {
          sn(ne.element, "for", q), sn(L.element, "id", q);
        }), F["aria-descriptor"]().each((ne) => {
          const ae = Mn(t.prefix);
          sn(ne.element, "id", ae), sn(L.element, "aria-describedby", ae);
        });
      });
    })]), w = {
      getField: (E) => Qt(E, t, "field"),
      getLabel: (E) => Qt(E, t, "label")
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: r,
      behaviours: h,
      events: y,
      apis: w
    };
  }, fr = Wl({
    name: "FormField",
    configFields: XZ(),
    partFields: WN(),
    factory: QZ,
    apis: {
      getField: (t, r) => t.getField(r),
      getLabel: (t, r) => t.getLabel(r)
    }
  });
  var JZ = tinymce.util.Tools.resolve("tinymce.html.Entities");
  const Vx = (t, r, l, d) => {
    const h = tG(t, r, l, d);
    return fr.sketch(h);
  }, eG = (t, r) => Vx(t, r, [], []), tG = (t, r, l, d) => ({
    dom: ZN(l),
    components: t.toArray().concat([r]),
    fieldBehaviours: Jt(d)
  }), nG = () => ZN([]), ZN = (t) => ({
    tag: "div",
    classes: ["tox-form__group"].concat(t)
  }), bb = (t, r) => fr.parts.label({
    dom: {
      tag: "label",
      classes: ["tox-label"]
    },
    components: [Aa(r.translate(t))]
  }), _u = Mn("form-component-change"), NS = Mn("form-close"), yb = Mn("form-cancel"), yh = Mn("form-action"), Ux = Mn("form-submit"), hA = Mn("form-block"), GN = Mn("form-unblock"), D6 = Mn("form-tabchange"), R6 = Mn("form-resize"), oG = (t, r, l) => {
    const d = t.label.map((ae) => bb(ae, r)), h = r.icons(), y = (ae) => {
      var de;
      return (de = h[ae]) !== null && de !== void 0 ? de : ae;
    }, w = (ae) => (de, _e) => {
      pf(_e.event.target, "[data-collection-item-value]").each((st) => {
        ae(de, _e, st, tr(st, "data-collection-item-value"));
      });
    }, E = (ae, de) => {
      const _e = et(de, (Qe) => {
        const qe = Pd.translate(Qe.text), Bt = t.columns === 1 ? `<div class="tox-collection__item-label">${qe}</div>` : "", pt = `<div class="tox-collection__item-icon">${y(Qe.icon)}</div>`, en = {
          _: " ",
          " - ": " ",
          "-": " "
        }, bn = qe.replace(/\_| \- |\-/g, (Yn) => en[Yn]), It = r.isDisabled() ? " tox-collection__item--state-disabled" : "";
        return `<div data-mce-tooltip="${bn}" class="tox-collection__item${It}" tabindex="-1" data-collection-item-value="${JZ.encodeAllRaw(Qe.value)}" aria-label="${bn}">${pt}${Bt}</div>`;
      }), st = t.columns !== "auto" && t.columns > 1 ? Cn(_e, t.columns) : [_e], Re = et(st, (Qe) => `<div class="tox-collection__group">${Qe.join("")}</div>`);
      Iv(ae.element, Re.join(""));
    }, O = w((ae, de, _e, st) => {
      de.stop(), r.isDisabled() || po(ae, yh, {
        name: t.name,
        value: st
      });
    }), F = [
      Ft(jf(), w((ae, de, _e) => {
        vu(_e);
      })),
      Ft(tg(), O),
      Ft(rf(), O),
      Ft(nf(), w((ae, de, _e) => {
        or(ae.element, "." + K1).each((st) => {
          ba(st, K1);
        }), Vr(_e, K1);
      })),
      Ft(Wf(), w((ae) => {
        or(ae.element, "." + K1).each((de) => {
          ba(de, K1), h1(de);
        });
      })),
      Td(w((ae, de, _e, st) => {
        po(ae, yh, {
          name: t.name,
          value: st
        });
      }))
    ], L = (ae, de) => et(Rl(ae.element, ".tox-collection__item"), de), q = fr.parts.field({
      dom: {
        tag: "div",
        classes: ["tox-collection"].concat(t.columns !== 1 ? ["tox-collection--grid"] : ["tox-collection--list"])
      },
      components: [],
      factory: { sketch: lt },
      behaviours: Jt([
        _o.config({
          disabled: r.isDisabled,
          onDisabled: (ae) => {
            L(ae, (de) => {
              Vr(de, "tox-collection__item--state-disabled"), sn(de, "aria-disabled", !0);
            });
          },
          onEnabled: (ae) => {
            L(ae, (de) => {
              ba(de, "tox-collection__item--state-disabled"), Ee(de, "aria-disabled");
            });
          }
        }),
        ki(),
        Po.config({}),
        gl.config({
          ...r.tooltips.getConfig({
            tooltipText: "",
            onShow: (ae) => {
              or(ae.element, "." + K1 + "[data-mce-tooltip]").each((de) => {
                Y(de, "data-mce-tooltip").each((_e) => {
                  gl.setComponents(ae, r.tooltips.getComponents({ tooltipText: _e }));
                });
              });
            }
          }),
          mode: "children-keyboard-focus",
          anchor: (ae) => ({
            type: "node",
            node: or(ae.element, "." + K1).orThunk(() => Cy(".tox-collection__item")),
            root: ae.element,
            layouts: {
              onLtr: ee([
                ti,
                Si,
                fi,
                mi,
                ei,
                br
              ]),
              onRtl: ee([
                ti,
                Si,
                fi,
                mi,
                ei,
                br
              ])
            },
            bubble: Od(0, -2, {})
          })
        }),
        In.config({
          store: {
            mode: "memory",
            initialValue: l.getOr([])
          },
          onSetValue: (ae, de) => {
            E(ae, de), t.columns === "auto" && qT(ae, 5, "tox-collection__item").each(({ numRows: _e, numColumns: st }) => {
              so.setGridSize(ae, _e, st);
            }), Xo(ae, R6);
          }
        }),
        jr.config({}),
        so.config(oZ(t.columns, "normal")),
        jo("collection-events", F)
      ]),
      eventOrder: {
        [Wu()]: [
          "disabling",
          "alloy.base.behaviour",
          "collection-events"
        ],
        [nf()]: [
          "collection-events",
          "tooltipping"
        ]
      }
    });
    return Vx(d, q, ["tox-form__group--collection"], []);
  }, sG = [
    "input",
    "textarea"
  ], qN = (t) => {
    const r = Gs(t);
    return pn(sG, r);
  }, a0 = (t, r) => {
    const l = r.getRoot(t).getOr(t.element);
    ba(l, r.invalidClass), r.notify.each((d) => {
      qN(t.element) && sn(t.element, "aria-invalid", !1), d.getContainer(t).each((h) => {
        Iv(h, d.validHtml);
      }), d.onValid(t);
    });
  }, N6 = (t, r, l, d) => {
    const h = r.getRoot(t).getOr(t.element);
    Vr(h, r.invalidClass), r.notify.each((y) => {
      qN(t.element) && sn(t.element, "aria-invalid", !0), y.getContainer(t).each((w) => {
        Iv(w, d);
      }), y.onInvalid(t, d);
    });
  }, P6 = (t, r, l) => r.validator.fold(() => Zl.pure(Ho.value(!0)), (d) => d.validate(t)), KN = (t, r, l) => (r.notify.each((d) => {
    d.onValidate(t);
  }), P6(t, r).map((d) => t.getSystem().isConnected() ? d.fold((h) => (N6(t, r, l, h), Ho.error(h)), (h) => (a0(t, r), Ho.value(h))) : Ho.error("No longer in system")));
  var Cf = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    markValid: a0,
    markInvalid: N6,
    query: P6,
    run: KN,
    isInvalid: (t, r) => {
      const l = r.getRoot(t).getOr(t.element);
      return Kc(l, r.invalidClass);
    }
  }), I6 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, r) => t.validator.map((l) => zr([Ft(l.onEvent, (d) => {
      KN(d, t, r).get(lt);
    })].concat(l.validateOnLoad ? [qr((d) => {
      KN(d, t, r).get(U);
    })] : []))).getOr({})
  }), rG = [
    Mt("invalidClass"),
    Xe("getRoot", B.none),
    kr("notify", [
      Xe("aria", "alert"),
      Xe("getContainer", B.none),
      Xe("validHtml", ""),
      Os("onValid"),
      Os("onInvalid"),
      Os("onValidate")
    ]),
    kr("validator", [
      Mt("validate"),
      Xe("onEvent", "input"),
      Xe("validateOnLoad", !0)
    ])
  ];
  const xh = Xi({
    fields: rG,
    name: "invalidating",
    active: I6,
    apis: Cf,
    extra: {
      validation: (t) => (r) => {
        const l = In.getValue(r);
        return Zl.pure(t(l));
      }
    }
  });
  var F6 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: () => zr([i_(Q2(), ot)]),
    exhibit: () => Gc({
      styles: {
        "-webkit-user-select": "none",
        "user-select": "none",
        "-ms-user-select": "none",
        "-moz-user-select": "-moz-none"
      },
      attributes: { unselectable: "on" }
    })
  });
  const jx = Xi({
    fields: [],
    name: "unselecting",
    active: F6
  }), aG = (t, r) => wf.sketch({
    dom: t.dom,
    components: t.components,
    toggleClass: "mce-active",
    dropdownBehaviours: Jt([
      dm.button(r.providers.isDisabled),
      ki(),
      jx.config({}),
      jr.config({})
    ]),
    layouts: t.layouts,
    sandboxClasses: ["tox-dialog__popups"],
    lazySink: r.getSink,
    fetch: (l) => Zl.nu((d) => t.fetch(d)).map((d) => B.from(Lx(Pr(IN(Mn("menu-value"), d, (h) => {
      t.onItemAction(l, h);
    }, t.columns, t.presets, im.CLOSE_ON_EXECUTE, _t, r.providers), { movement: lA(t.columns, t.presets) })))),
    parts: { menu: pS(!1, 1, t.presets) }
  }), B6 = Mn("color-input-change"), XN = Mn("color-swatch-change"), L6 = Mn("color-picker-cancel"), $6 = (t, r, l, d) => {
    const h = fr.parts.field({
      factory: Y1,
      inputClasses: ["tox-textfield"],
      data: d,
      onSetValue: (F) => xh.run(F).get(U),
      inputBehaviours: Jt([
        _o.config({ disabled: r.providers.isDisabled }),
        ki(),
        jr.config({}),
        xh.config({
          invalidClass: "tox-textbox-field-invalid",
          getRoot: (F) => ji(F.element),
          notify: {
            onValid: (F) => {
              const L = In.getValue(F);
              po(F, B6, { color: L });
            }
          },
          validator: {
            validateOnLoad: !1,
            validate: (F) => {
              const L = In.getValue(F);
              if (L.length === 0)
                return Zl.pure(Ho.value(!0));
              {
                const q = $e.fromTag("span");
                Ln(q, "background-color", L);
                const ne = Cr(q, "background-color").fold(() => Ho.error("blah"), (ae) => Ho.value(L));
                return Zl.pure(ne);
              }
            }
          }
        })
      ]),
      selectOnFocus: !1
    }), y = t.label.map((F) => bb(F, r.providers)), w = (F, L) => {
      po(F, XN, { value: L });
    }, E = (F, L) => {
      O.getOpt(F).each((q) => {
        L === "custom" ? l.colorPicker((ne) => {
          ne.fold(() => Xo(q, L6), (ae) => {
            w(q, ae), rA(t.storageKey, ae);
          });
        }, "#ffffff") : L === "remove" ? w(q, "") : w(q, L);
      });
    }, O = rr(aG({
      dom: {
        tag: "span",
        attributes: { "aria-label": r.providers.translate("Color swatch") }
      },
      layouts: {
        onRtl: () => [
          ei,
          fi,
          ti
        ],
        onLtr: () => [
          fi,
          ei,
          ti
        ]
      },
      components: [],
      fetch: s6(l.getColors(t.storageKey), t.storageKey, l.hasCustomColors()),
      columns: l.getColorCols(t.storageKey),
      presets: "color",
      onItemAction: E
    }, r));
    return fr.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: y.toArray().concat([{
        dom: {
          tag: "div",
          classes: ["tox-color-input"]
        },
        components: [
          h,
          O.asSpec()
        ]
      }]),
      fieldBehaviours: Jt([jo("form-field-events", [
        Ft(B6, (F, L) => {
          O.getOpt(F).each((q) => {
            Ln(q.element, "background-color", L.event.color);
          }), po(F, _u, { name: t.name });
        }),
        Ft(XN, (F, L) => {
          fr.getField(F).each((q) => {
            In.setValue(q, L.event.value), Ds.getCurrent(F).each(To.focus);
          });
        }),
        Ft(L6, (F, L) => {
          fr.getField(F).each((q) => {
            Ds.getCurrent(F).each(To.focus);
          });
        })
      ])])
    });
  }, H6 = Su({
    schema: [Mt("dom")],
    name: "label"
  }), Ug = (t) => Su({
    name: "" + t + "-edge",
    overrides: (r) => r.model.manager.edgeActions[t].fold(() => ({}), (d) => ({
      events: zr([
        rg(vs(), (h, y, w) => d(h, w), [r]),
        rg(sc(), (h, y, w) => d(h, w), [r]),
        rg(Sv(), (h, y, w) => {
          w.mouseIsDown.get() && d(h, w);
        }, [r])
      ])
    }))
  }), iG = Ug("top-left"), lG = Ug("top"), cG = Ug("top-right"), uG = Ug("right"), dG = Ug("bottom-right"), fG = Ug("bottom"), QN = Ug("bottom-left"), mG = Ug("left"), pG = hl({
    name: "thumb",
    defaults: ee({ dom: { styles: { position: "absolute" } } }),
    overrides: (t) => ({
      events: zr([
        ag(vs(), t, "spectrum"),
        ag(Gr(), t, "spectrum"),
        ag(Ja(), t, "spectrum"),
        ag(sc(), t, "spectrum"),
        ag(Sv(), t, "spectrum"),
        ag(Fm(), t, "spectrum")
      ])
    })
  }), PS = (t) => rm(t.event), hG = hl({
    schema: [Vs("mouseIsDown", () => to(!1))],
    name: "spectrum",
    overrides: (t) => {
      const l = t.model.manager, d = (h, y) => l.getValueFromEvent(y).map((w) => l.setValueFrom(h, t, w));
      return {
        behaviours: Jt([
          so.config({
            mode: "special",
            onLeft: (h, y) => l.onLeft(h, t, PS(y)),
            onRight: (h, y) => l.onRight(h, t, PS(y)),
            onUp: (h, y) => l.onUp(h, t, PS(y)),
            onDown: (h, y) => l.onDown(h, t, PS(y))
          }),
          jr.config({}),
          To.config({})
        ]),
        events: zr([
          Ft(vs(), d),
          Ft(Gr(), d),
          Ft(sc(), d),
          Ft(Sv(), (h, y) => {
            t.mouseIsDown.get() && d(h, y);
          })
        ])
      };
    }
  });
  var gG = [
    H6,
    mG,
    uG,
    lG,
    fG,
    iG,
    cG,
    QN,
    dG,
    pG,
    hG
  ];
  const MS = ee("slider.change.value"), vG = (t) => t.type.indexOf("touch") !== -1, JN = (t) => {
    const r = t.event.raw;
    if (vG(r)) {
      const l = r;
      return l.touches !== void 0 && l.touches.length === 1 ? B.some(l.touches[0]).map((d) => $r(d.clientX, d.clientY)) : B.none();
    } else {
      const l = r;
      return l.clientX !== void 0 ? B.some(l).map((d) => $r(d.clientX, d.clientY)) : B.none();
    }
  }, z6 = "top", bG = "right", V6 = "bottom", U6 = "left", i0 = (t) => t.model.minX, l0 = (t) => t.model.minY, gA = (t) => t.model.minX - 1, vA = (t) => t.model.minY - 1, c0 = (t) => t.model.maxX, u0 = (t) => t.model.maxY, IS = (t) => t.model.maxX + 1, d0 = (t) => t.model.maxY + 1, eP = (t, r, l) => r(t) - l(t), FS = (t) => eP(t, c0, i0), tP = (t) => eP(t, u0, l0), nP = (t) => FS(t) / 2, j6 = (t) => tP(t) / 2, Wx = (t, r) => r ? t.stepSize * t.speedMultiplier : t.stepSize, W6 = (t) => t.snapToGrid, Z6 = (t) => t.snapStart, bA = (t) => t.rounded, fm = (t, r) => t[r + "-edge"] !== void 0, G6 = (t) => fm(t, U6), Zx = (t) => fm(t, bG), q6 = (t) => fm(t, z6), yA = (t) => fm(t, V6), jg = (t) => t.model.value.get(), xb = (t, r) => ({
    x: t,
    y: r
  }), mm = (t, r) => {
    po(t, MS(), { value: r });
  }, K6 = (t, r) => {
    mm(t, xb(gA(r), vA(r)));
  }, yG = (t, r) => {
    mm(t, vA(r));
  }, oP = (t, r) => {
    mm(t, xb(nP(r), vA(r)));
  }, sP = (t, r) => {
    mm(t, xb(IS(r), vA(r)));
  }, rP = (t, r) => {
    mm(t, IS(r));
  }, xG = (t, r) => {
    mm(t, xb(IS(r), j6(r)));
  }, Md = (t, r) => {
    mm(t, xb(IS(r), d0(r)));
  }, wG = (t, r) => {
    mm(t, d0(r));
  }, CG = (t, r) => {
    mm(t, xb(nP(r), d0(r)));
  }, Y6 = (t, r) => {
    mm(t, xb(gA(r), d0(r)));
  }, X6 = (t, r) => {
    mm(t, gA(r));
  }, SG = (t, r) => {
    mm(t, xb(gA(r), j6(r)));
  }, aP = (t, r, l, d) => t < r ? t : t > l ? l : t === r ? r - 1 : Math.max(r, t - d), iP = (t, r, l, d) => t > l ? t : t < r ? r : t === l ? l + 1 : Math.min(l, t + d), Q6 = (t, r, l) => Math.max(r, Math.min(l, t)), kG = (t, r, l, d, h) => h.fold(() => {
    const y = t - r, w = Math.round(y / d) * d;
    return Q6(r + w, r - 1, l + 1);
  }, (y) => {
    const w = (t - y) % d, E = Math.round(w / d), O = Math.floor((t - y) / d), F = Math.floor((l - y) / d), L = Math.min(F, O + E), q = y + L * d;
    return Math.max(y, q);
  }), _G = (t, r, l) => Math.min(l, Math.max(t, r)) - r, J6 = (t) => {
    const { min: r, max: l, range: d, value: h, step: y, snap: w, snapStart: E, rounded: O, hasMinEdge: F, hasMaxEdge: L, minBound: q, maxBound: ne, screenRange: ae } = t, de = F ? r - 1 : r, _e = L ? l + 1 : l;
    if (h < q)
      return de;
    if (h > ne)
      return _e;
    {
      const st = _G(h, q, ne), Re = Q6(st / ae * d + r, de, _e);
      return w && Re >= r && Re <= l ? kG(Re, r, l, y, E) : O ? Math.round(Re) : Re;
    }
  }, lP = (t) => {
    const { min: r, max: l, range: d, value: h, hasMinEdge: y, hasMaxEdge: w, maxBound: E, maxOffset: O, centerMinEdge: F, centerMaxEdge: L } = t;
    return h < r ? y ? 0 : F : h > l ? w ? E : L : (h - r) / d * O;
  }, cP = "top", e$ = "right", t$ = "bottom", xA = "left", uP = "width", n$ = "height", sp = (t) => t.element.dom.getBoundingClientRect(), Sf = (t, r) => t[r], BS = (t) => {
    const r = sp(t);
    return Sf(r, xA);
  }, wA = (t) => {
    const r = sp(t);
    return Sf(r, e$);
  }, CA = (t) => {
    const r = sp(t);
    return Sf(r, cP);
  }, SA = (t) => {
    const r = sp(t);
    return Sf(r, t$);
  }, f0 = (t) => {
    const r = sp(t);
    return Sf(r, uP);
  }, dP = (t) => {
    const r = sp(t);
    return Sf(r, n$);
  }, fP = (t, r, l) => (t + r) / 2 - l, mP = (t, r) => {
    const l = sp(t), d = sp(r), h = Sf(l, xA), y = Sf(l, e$), w = Sf(d, xA);
    return fP(h, y, w);
  }, o$ = (t, r) => {
    const l = sp(t), d = sp(r), h = Sf(l, cP), y = Sf(l, t$), w = Sf(d, cP);
    return fP(h, y, w);
  }, kA = (t, r) => {
    po(t, MS(), { value: r });
  }, Gx = (t, r, l) => {
    const d = {
      min: i0(r),
      max: c0(r),
      range: FS(r),
      value: l,
      step: Wx(r),
      snap: W6(r),
      snapStart: Z6(r),
      rounded: bA(r),
      hasMinEdge: G6(r),
      hasMaxEdge: Zx(r),
      minBound: BS(t),
      maxBound: wA(t),
      screenRange: f0(t)
    };
    return J6(d);
  }, EG = (t, r, l) => {
    const d = Gx(t, r, l);
    return kA(t, d), d;
  }, TG = (t, r) => {
    const l = i0(r);
    kA(t, l);
  }, s$ = (t, r) => {
    const l = c0(r);
    kA(t, l);
  }, r$ = (t, r, l, d) => {
    const y = (t > 0 ? iP : aP)(jg(l), i0(l), c0(l), Wx(l, d));
    return kA(r, y), B.some(y);
  }, _A = (t) => (r, l, d) => r$(t, r, l, d).map(ot), a$ = (t) => JN(t).map((l) => l.left), su = (t, r, l, d, h) => {
    const w = f0(t), E = d.bind((L) => B.some(mP(L, t))).getOr(0), O = h.bind((L) => B.some(mP(L, t))).getOr(w), F = {
      min: i0(r),
      max: c0(r),
      range: FS(r),
      value: l,
      hasMinEdge: G6(r),
      hasMaxEdge: Zx(r),
      minBound: BS(t),
      minOffset: 0,
      maxBound: wA(t),
      maxOffset: w,
      centerMinEdge: E,
      centerMaxEdge: O
    };
    return lP(F);
  }, EA = (t, r, l, d, h, y) => {
    const w = su(r, y, l, d, h);
    return BS(r) - BS(t) + w;
  }, AG = (t, r, l, d) => {
    const h = jg(l), y = EA(t, d.getSpectrum(t), h, d.getLeftEdge(t), d.getRightEdge(t), l), w = Ri(r.element) / 2;
    Ln(r.element, "left", y - w + "px");
  }, OG = _A(-1), i$ = _A(1), DG = B.none, RG = B.none, NG = {
    "top-left": B.none(),
    top: B.none(),
    "top-right": B.none(),
    right: B.some(rP),
    "bottom-right": B.none(),
    bottom: B.none(),
    "bottom-left": B.none(),
    left: B.some(X6)
  };
  var l$ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setValueFrom: EG,
    setToMin: TG,
    setToMax: s$,
    findValueOfOffset: Gx,
    getValueFromEvent: a$,
    findPositionOfValue: EA,
    setPositionFromValue: AG,
    onLeft: OG,
    onRight: i$,
    onUp: DG,
    onDown: RG,
    edgeActions: NG
  });
  const kf = (t, r) => {
    po(t, MS(), { value: r });
  }, LS = (t, r, l) => {
    const d = {
      min: l0(r),
      max: u0(r),
      range: tP(r),
      value: l,
      step: Wx(r),
      snap: W6(r),
      snapStart: Z6(r),
      rounded: bA(r),
      hasMinEdge: q6(r),
      hasMaxEdge: yA(r),
      minBound: CA(t),
      maxBound: SA(t),
      screenRange: dP(t)
    };
    return J6(d);
  }, c$ = (t, r, l) => {
    const d = LS(t, r, l);
    return kf(t, d), d;
  }, TA = (t, r) => {
    const l = l0(r);
    kf(t, l);
  }, pP = (t, r) => {
    const l = u0(r);
    kf(t, l);
  }, PG = (t, r, l, d) => {
    const y = (t > 0 ? iP : aP)(jg(l), l0(l), u0(l), Wx(l, d));
    return kf(r, y), B.some(y);
  }, u$ = (t) => (r, l, d) => PG(t, r, l, d).map(ot), MG = (t) => JN(t).map((l) => l.top), IG = (t, r, l, d, h) => {
    const w = dP(t), E = d.bind((L) => B.some(o$(L, t))).getOr(0), O = h.bind((L) => B.some(o$(L, t))).getOr(w), F = {
      min: l0(r),
      max: u0(r),
      range: tP(r),
      value: l,
      hasMinEdge: q6(r),
      hasMaxEdge: yA(r),
      minBound: CA(t),
      minOffset: 0,
      maxBound: SA(t),
      maxOffset: w,
      centerMinEdge: E,
      centerMaxEdge: O
    };
    return lP(F);
  }, hP = (t, r, l, d, h, y) => {
    const w = IG(r, y, l, d, h);
    return CA(r) - CA(t) + w;
  }, FG = (t, r, l, d) => {
    const h = jg(l), y = hP(t, d.getSpectrum(t), h, d.getTopEdge(t), d.getBottomEdge(t), l), w = Mr(r.element) / 2;
    Ln(r.element, "top", y - w + "px");
  }, BG = B.none, d$ = B.none, LG = u$(-1), wh = u$(1), AA = {
    "top-left": B.none(),
    top: B.some(yG),
    "top-right": B.none(),
    right: B.none(),
    "bottom-right": B.none(),
    bottom: B.some(wG),
    "bottom-left": B.none(),
    left: B.none()
  };
  var $G = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setValueFrom: c$,
    setToMin: TA,
    setToMax: pP,
    findValueOfOffset: LS,
    getValueFromEvent: MG,
    findPositionOfValue: hP,
    setPositionFromValue: FG,
    onLeft: BG,
    onRight: d$,
    onUp: LG,
    onDown: wh,
    edgeActions: AA
  });
  const OA = (t, r) => {
    po(t, MS(), { value: r });
  }, $S = (t, r) => ({
    x: t,
    y: r
  }), f$ = (t, r, l) => {
    const d = Gx(t, r, l.left), h = LS(t, r, l.top), y = $S(d, h);
    return OA(t, y), y;
  }, gP = (t, r, l, d, h) => {
    const y = t > 0 ? iP : aP, w = r ? jg(d).x : y(jg(d).x, i0(d), c0(d), Wx(d, h)), E = r ? y(jg(d).y, l0(d), u0(d), Wx(d, h)) : jg(d).y;
    return OA(l, $S(w, E)), B.some(w);
  }, m0 = (t, r) => (l, d, h) => gP(t, r, l, d, h).map(ot), HS = (t, r) => {
    const l = i0(r), d = l0(r);
    OA(t, $S(l, d));
  }, zS = (t, r) => {
    const l = c0(r), d = u0(r);
    OA(t, $S(l, d));
  }, m$ = (t) => JN(t), p$ = (t, r, l, d) => {
    const h = jg(l), y = EA(t, d.getSpectrum(t), h.x, d.getLeftEdge(t), d.getRightEdge(t), l), w = hP(t, d.getSpectrum(t), h.y, d.getTopEdge(t), d.getBottomEdge(t), l), E = Ri(r.element) / 2, O = Mr(r.element) / 2;
    Ln(r.element, "left", y - E + "px"), Ln(r.element, "top", w - O + "px");
  }, h$ = m0(-1, !1), g$ = m0(1, !1), HG = m0(-1, !0), zG = m0(1, !0), VG = {
    "top-left": B.some(K6),
    top: B.some(oP),
    "top-right": B.some(sP),
    right: B.some(xG),
    "bottom-right": B.some(Md),
    bottom: B.some(CG),
    "bottom-left": B.some(Y6),
    left: B.some(SG)
  };
  var UG = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setValueFrom: f$,
    setToMin: HS,
    setToMax: zS,
    getValueFromEvent: m$,
    setPositionFromValue: p$,
    onLeft: h$,
    onRight: g$,
    onUp: HG,
    onDown: zG,
    edgeActions: VG
  });
  const jG = [
    Xe("stepSize", 1),
    Xe("speedMultiplier", 10),
    Xe("onChange", U),
    Xe("onChoose", U),
    Xe("onInit", U),
    Xe("onDragStart", U),
    Xe("onDragEnd", U),
    Xe("snapToGrid", !1),
    Xe("rounded", !0),
    $s("snapStart"),
    Ls("model", ui("mode", {
      x: [
        Xe("minX", 0),
        Xe("maxX", 100),
        Vs("value", (t) => to(t.mode.minX)),
        Mt("getInitialValue"),
        Ur("manager", l$)
      ],
      y: [
        Xe("minY", 0),
        Xe("maxY", 100),
        Vs("value", (t) => to(t.mode.minY)),
        Mt("getInitialValue"),
        Ur("manager", $G)
      ],
      xy: [
        Xe("minX", 0),
        Xe("maxX", 100),
        Xe("minY", 0),
        Xe("maxY", 100),
        Vs("value", (t) => to({
          x: t.mode.minX,
          y: t.mode.minY
        })),
        Mt("getInitialValue"),
        Ur("manager", UG)
      ]
    })),
    $i("sliderBehaviours", [
      so,
      In
    ]),
    Vs("mouseIsDown", () => to(!1))
  ], _f = Wl({
    name: "Slider",
    configFields: jG,
    partFields: gG,
    factory: (t, r, l, d) => {
      const h = (pt) => fc(pt, t, "thumb"), y = (pt) => fc(pt, t, "spectrum"), w = (pt) => Qt(pt, t, "left-edge"), E = (pt) => Qt(pt, t, "right-edge"), O = (pt) => Qt(pt, t, "top-edge"), F = (pt) => Qt(pt, t, "bottom-edge"), L = t.model, q = L.manager, ne = (pt, en) => {
        q.setPositionFromValue(pt, en, t, {
          getLeftEdge: w,
          getRightEdge: E,
          getTopEdge: O,
          getBottomEdge: F,
          getSpectrum: y
        });
      }, ae = (pt, en) => {
        L.value.set(en);
        const bn = h(pt);
        ne(pt, bn);
      }, de = (pt, en) => {
        ae(pt, en);
        const bn = h(pt);
        return t.onChange(pt, bn, en), B.some(!0);
      }, _e = (pt) => {
        q.setToMin(pt, t);
      }, st = (pt) => {
        q.setToMax(pt, t);
      }, Re = (pt) => {
        const en = () => {
          Qt(pt, t, "thumb").each((It) => {
            const Yn = L.value.get();
            t.onChoose(pt, It, Yn);
          });
        }, bn = t.mouseIsDown.get();
        t.mouseIsDown.set(!1), bn && en();
      }, Qe = (pt, en) => {
        en.stop(), t.mouseIsDown.set(!0), t.onDragStart(pt, h(pt));
      }, qe = (pt, en) => {
        en.stop(), t.onDragEnd(pt, h(pt)), Re(pt);
      }, Bt = (pt) => {
        Qt(pt, t, "spectrum").map(so.focusIn);
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: r,
        behaviours: Hi(t.sliderBehaviours, [
          so.config({
            mode: "special",
            focusIn: Bt
          }),
          In.config({
            store: {
              mode: "manual",
              getValue: (pt) => L.value.get(),
              setValue: ae
            }
          }),
          Rc.config({ channels: { [_1()]: { onReceive: Re } } })
        ]),
        events: zr([
          Ft(MS(), (pt, en) => {
            de(pt, en.event.value);
          }),
          qr((pt, en) => {
            const bn = L.getInitialValue();
            L.value.set(bn);
            const It = h(pt);
            ne(pt, It);
            const Yn = y(pt);
            t.onInit(pt, It, Yn, L.value.get());
          }),
          Ft(vs(), Qe),
          Ft(Ja(), qe),
          Ft(sc(), (pt, en) => {
            Bt(pt), Qe(pt, en);
          }),
          Ft(Fm(), qe)
        ]),
        apis: {
          resetToMin: _e,
          resetToMax: st,
          setValue: ae,
          refresh: ne
        },
        domModification: { styles: { position: "relative" } }
      };
    },
    apis: {
      setValue: (t, r, l) => {
        t.setValue(r, l);
      },
      resetToMin: (t, r) => {
        t.resetToMin(r);
      },
      resetToMax: (t, r) => {
        t.resetToMax(r);
      },
      refresh: (t, r) => {
        t.refresh(r);
      }
    }
  }), vP = Mn("rgb-hex-update"), bP = Mn("slider-update"), v$ = Mn("palette-update"), b$ = (t, r) => {
    const l = _f.parts.spectrum({
      dom: {
        tag: "div",
        classes: [r("hue-slider-spectrum")],
        attributes: { role: "presentation" }
      }
    }), d = _f.parts.thumb({
      dom: {
        tag: "div",
        classes: [r("hue-slider-thumb")],
        attributes: { role: "presentation" }
      }
    });
    return _f.sketch({
      dom: {
        tag: "div",
        classes: [r("hue-slider")],
        attributes: {
          role: "slider",
          "aria-valuemin": 0,
          "aria-valuemax": 360,
          "aria-valuenow": 120
        }
      },
      rounded: !1,
      model: {
        mode: "y",
        getInitialValue: ee(0)
      },
      components: [
        l,
        d
      ],
      sliderBehaviours: Jt([To.config({})]),
      onChange: (h, y, w) => {
        sn(h.element, "aria-valuenow", Math.floor(360 - w * 3.6)), po(h, bP, { value: w });
      }
    });
  }, qx = "form", ZG = [$i("formBehaviours", [In])], yP = (t) => "<alloy.field." + t + ">", GG = (t) => {
    const r = (() => {
      const y = [];
      return {
        field: (E, O) => (y.push(E), zE(qx, yP(E), O)),
        record: ee(y)
      };
    })(), l = t(r), d = r.record(), h = et(d, (y) => hl({
      name: y,
      pname: yP(y)
    }));
    return Ym(qx, ZG, h, KG, l);
  }, qG = (t, r) => t.fold(() => Ho.error(r), Ho.value), KG = (t, r) => ({
    uid: t.uid,
    dom: t.dom,
    components: r,
    behaviours: Hi(t.formBehaviours, [In.config({
      store: {
        mode: "manual",
        getValue: (l) => {
          const d = BC(l, t);
          return kt(d, (h, y) => h().bind((w) => {
            const E = Ds.getCurrent(w);
            return qG(E, new Error(`Cannot find a current component to extract the value from for form part '${y}': ` + Xc(w.element)));
          }).map(In.getValue));
        },
        setValue: (l, d) => {
          it(d, (h, y) => {
            Qt(l, t, y).each((w) => {
              Ds.getCurrent(w).each((E) => {
                In.setValue(E, h);
              });
            });
          });
        }
      }
    })]),
    apis: {
      getField: (l, d) => Qt(l, t, d).bind(Ds.getCurrent)
    }
  }), Kx = {
    getField: $v((t, r, l) => t.getField(r, l)),
    sketch: GG
  }, xP = Mn("valid-input"), y$ = Mn("invalid-input"), wP = Mn("validating-input"), VS = "colorcustom.rgb.", Wg = (t, r, l, d) => {
    const h = (ne, ae) => xh.config({
      invalidClass: r("invalid"),
      notify: {
        onValidate: (de) => {
          po(de, wP, { type: ne });
        },
        onValid: (de) => {
          po(de, xP, {
            type: ne,
            value: In.getValue(de)
          });
        },
        onInvalid: (de) => {
          po(de, y$, {
            type: ne,
            value: In.getValue(de)
          });
        }
      },
      validator: {
        validate: (de) => {
          const _e = In.getValue(de), st = ae(_e) ? Ho.value(!0) : Ho.error(t("aria.input.invalid"));
          return Zl.pure(st);
        },
        validateOnLoad: !1
      }
    }), y = (ne, ae, de, _e, st) => {
      const Re = t(VS + "range"), Qe = fr.parts.label({
        dom: {
          tag: "label",
          attributes: { "aria-label": _e }
        },
        components: [Aa(de)]
      }), qe = fr.parts.field({
        data: st,
        factory: Y1,
        inputAttributes: {
          type: "text",
          ...ae === "hex" ? { "aria-live": "polite" } : {}
        },
        inputClasses: [r("textfield")],
        inputBehaviours: Jt([
          h(ae, ne),
          jr.config({})
        ]),
        onSetValue: (bn) => {
          xh.isInvalid(bn) && xh.run(bn).get(U);
        }
      }), Bt = [
        Qe,
        qe
      ], pt = ae !== "hex" ? [fr.parts["aria-descriptor"]({ text: Re })] : [], en = Bt.concat(pt);
      return {
        dom: {
          tag: "div",
          attributes: { role: "presentation" }
        },
        components: en
      };
    }, w = (ne, ae) => {
      const de = kS(ae);
      return Kx.getField(ne, "hex").each((_e) => {
        To.isFocused(_e) || In.setValue(ne, { hex: de.value });
      }), de;
    }, E = (ne, ae) => {
      const de = ae.red, _e = ae.green, st = ae.blue;
      In.setValue(ne, {
        red: de,
        green: _e,
        blue: st
      });
    }, O = rr({
      dom: {
        tag: "div",
        classes: [r("rgba-preview")],
        styles: { "background-color": "white" },
        attributes: { role: "presentation" }
      }
    }), F = (ne, ae) => {
      O.getOpt(ne).each((de) => {
        Ln(de.element, "background-color", "#" + ae.value);
      });
    };
    return Nc({
      factory: () => {
        const ne = {
          red: to(B.some(255)),
          green: to(B.some(255)),
          blue: to(B.some(255)),
          hex: to(B.some("ffffff"))
        }, ae = (mo, js) => {
          const Fs = _S(js);
          E(mo, Fs), Re(Fs);
        }, de = (mo) => ne[mo].get(), _e = (mo, js) => {
          ne[mo].set(js);
        }, st = () => de("red").bind((mo) => de("green").bind((js) => de("blue").map((Fs) => n0(mo, js, Fs, 1)))), Re = (mo) => {
          const js = mo.red, Fs = mo.green, ms = mo.blue;
          _e("red", B.some(js)), _e("green", B.some(Fs)), _e("blue", B.some(ms));
        }, Qe = (mo, js) => {
          const Fs = js.event;
          Fs.type !== "hex" ? _e(Fs.type, B.none()) : d(mo);
        }, qe = (mo, js) => {
          l(mo);
          const Fs = EN(js);
          _e("hex", B.some(Fs.value));
          const ms = _S(Fs);
          E(mo, ms), Re(ms), po(mo, vP, { hex: Fs }), F(mo, Fs);
        }, Bt = (mo, js, Fs) => {
          const ms = parseInt(Fs, 10);
          _e(js, B.some(ms)), st().each((cn) => {
            const Un = w(mo, cn);
            po(mo, vP, { hex: Un }), F(mo, Un);
          });
        }, pt = (mo) => mo.type === "hex", en = (mo, js) => {
          const Fs = js.event;
          pt(Fs) ? qe(mo, Fs.value) : Bt(mo, Fs.type, Fs.value);
        }, bn = (mo) => ({
          label: t(VS + mo + ".label"),
          description: t(VS + mo + ".description")
        }), It = bn("red"), Yn = bn("green"), Fn = bn("blue"), yo = bn("hex");
        return Pr(Kx.sketch((mo) => ({
          dom: {
            tag: "form",
            classes: [r("rgb-form")],
            attributes: { "aria-label": t("aria.color.picker") }
          },
          components: [
            mo.field("red", fr.sketch(y(AN, "red", It.label, It.description, 255))),
            mo.field("green", fr.sketch(y(AN, "green", Yn.label, Yn.description, 255))),
            mo.field("blue", fr.sketch(y(AN, "blue", Fn.label, Fn.description, 255))),
            mo.field("hex", fr.sketch(y(PL, "hex", yo.label, yo.description, "ffffff"))),
            O.asSpec()
          ],
          formBehaviours: Jt([
            xh.config({ invalidClass: r("form-invalid") }),
            jo("rgb-form-events", [
              Ft(xP, en),
              Ft(y$, Qe),
              Ft(wP, Qe)
            ])
          ])
        })), {
          apis: {
            updateHex: (mo, js) => {
              In.setValue(mo, { hex: js.value }), ae(mo, js), F(mo, js);
            }
          }
        });
      },
      name: "RgbForm",
      configFields: [],
      apis: {
        updateHex: (ne, ae, de) => {
          ne.updateHex(ae, de);
        }
      },
      extraApis: {}
    });
  }, CP = (t, r) => {
    const l = _f.parts.spectrum({
      dom: {
        tag: "canvas",
        attributes: { role: "presentation" },
        classes: [r("sv-palette-spectrum")]
      }
    }), d = _f.parts.thumb({
      dom: {
        tag: "div",
        attributes: { role: "presentation" },
        classes: [r("sv-palette-thumb")],
        innerHtml: `<div class=${r("sv-palette-inner-thumb")} role="presentation"></div>`
      }
    }), h = (F, L) => {
      const { width: q, height: ne } = F, ae = F.getContext("2d");
      if (ae === null)
        return;
      ae.fillStyle = L, ae.fillRect(0, 0, q, ne);
      const de = ae.createLinearGradient(0, 0, q, 0);
      de.addColorStop(0, "rgba(255,255,255,1)"), de.addColorStop(1, "rgba(255,255,255,0)"), ae.fillStyle = de, ae.fillRect(0, 0, q, ne);
      const _e = ae.createLinearGradient(0, 0, 0, ne);
      _e.addColorStop(0, "rgba(0,0,0,0)"), _e.addColorStop(1, "rgba(0,0,0,1)"), ae.fillStyle = _e, ae.fillRect(0, 0, q, ne);
    }, y = (F, L) => {
      const q = F.components()[0].element.dom, ne = r0(L, 100, 100), ae = $L(ne);
      h(q, zL(ae));
    }, w = (F, L) => {
      const q = aA(_S(L));
      _f.setValue(F, {
        x: q.saturation,
        y: 100 - q.value
      }), sn(F.element, "aria-valuetext", t([
        "Saturation {0}%, Brightness {1}%",
        q.saturation,
        q.value
      ]));
    };
    return Nc({
      factory: (F) => {
        const L = ee({
          x: 0,
          y: 0
        }), q = (de, _e, st) => {
          re(st) || sn(de.element, "aria-valuetext", t([
            "Saturation {0}%, Brightness {1}%",
            Math.floor(st.x),
            Math.floor(100 - st.y)
          ])), po(de, v$, { value: st });
        }, ne = (de, _e, st, Re) => {
          h(st.element.dom, zL(VL));
        }, ae = Jt([
          Ds.config({ find: B.some }),
          To.config({})
        ]);
        return _f.sketch({
          dom: {
            tag: "div",
            attributes: {
              role: "slider",
              "aria-valuetext": t([
                "Saturation {0}%, Brightness {1}%",
                0,
                0
              ])
            },
            classes: [r("sv-palette")]
          },
          model: {
            mode: "xy",
            getInitialValue: L
          },
          rounded: !1,
          components: [
            l,
            d
          ],
          onChange: q,
          onInit: ne,
          sliderBehaviours: ae
        });
      },
      name: "SaturationBrightnessPalette",
      configFields: [],
      apis: {
        setHue: (F, L, q) => {
          y(L, q);
        },
        setThumb: (F, L, q) => {
          w(L, q);
        }
      },
      extraApis: {}
    });
  }, x$ = (t, r) => {
    const l = (h) => {
      const y = Wg(t, r, h.onValidHex, h.onInvalidHex), w = CP(t, r), E = (en) => (100 - en) / 100 * 360, O = (en) => 100 - en / 360 * 100, F = {
        paletteRgba: to(VL),
        paletteHue: to(0)
      }, L = rr(b$(t, r)), q = rr(w.sketch({})), ne = rr(y.sketch({})), ae = (en, bn, It) => {
        q.getOpt(en).each((Yn) => {
          w.setHue(Yn, It);
        });
      }, de = (en, bn) => {
        ne.getOpt(en).each((It) => {
          y.updateHex(It, bn);
        });
      }, _e = (en, bn, It) => {
        L.getOpt(en).each((Yn) => {
          _f.setValue(Yn, O(It));
        });
      }, st = (en, bn) => {
        q.getOpt(en).each((It) => {
          w.setThumb(It, bn);
        });
      }, Re = (en, bn) => {
        const It = _S(en);
        F.paletteRgba.set(It), F.paletteHue.set(bn);
      }, Qe = (en, bn, It, Yn) => {
        Re(bn, It), xt(Yn, (Fn) => {
          Fn(en, bn, It);
        });
      }, qe = () => {
        const en = [de];
        return (bn, It) => {
          const Yn = It.event.value, Fn = F.paletteHue.get(), yo = r0(Fn, Yn.x, 100 - Yn.y), mo = YL(yo);
          Qe(bn, mo, Fn, en);
        };
      }, Bt = () => {
        const en = [
          ae,
          de
        ];
        return (bn, It) => {
          const Yn = E(It.event.value), Fn = F.paletteRgba.get(), yo = aA(Fn), mo = r0(Yn, yo.saturation, yo.value), js = YL(mo);
          Qe(bn, js, Yn, en);
        };
      }, pt = () => {
        const en = [
          ae,
          _e,
          st
        ];
        return (bn, It) => {
          const Yn = It.event.hex, Fn = ZW(Yn);
          Qe(bn, Yn, Fn.hue, en);
        };
      };
      return {
        uid: h.uid,
        dom: h.dom,
        components: [
          q.asSpec(),
          L.asSpec(),
          ne.asSpec()
        ],
        behaviours: Jt([
          jo("colour-picker-events", [
            Ft(vP, pt()),
            Ft(v$, qe()),
            Ft(bP, Bt())
          ]),
          Ds.config({ find: (en) => ne.getOpt(en) }),
          so.config({ mode: "acyclic" })
        ])
      };
    };
    return Nc({
      name: "ColourPicker",
      configFields: [
        Mt("dom"),
        Xe("onValidHex", U),
        Xe("onInvalidHex", U)
      ],
      factory: l
    });
  }, sd = {
    self: () => Ds.config({ find: B.some }),
    memento: (t) => Ds.config({ find: t.getOpt }),
    childAt: (t) => Ds.config({ find: (r) => Wi(r.element, t).bind((l) => r.getSystem().getByDom(l).toOptional()) })
  }, C$ = xo([
    Xe("preprocess", lt),
    Xe("postprocess", lt)
  ]), S$ = (t, r) => {
    const l = El("RepresentingConfigs.memento processors", C$, r);
    return In.config({
      store: {
        mode: "manual",
        getValue: (d) => {
          const h = t.get(d), y = In.getValue(h);
          return l.postprocess(y);
        },
        setValue: (d, h) => {
          const y = l.preprocess(h), w = t.get(d);
          In.setValue(w, y);
        }
      }
    });
  }, p0 = (t, r, l) => In.config({
    store: {
      mode: "manual",
      ...t.map((d) => ({ initialValue: d })).getOr({}),
      getValue: r,
      setValue: l
    }
  }), k$ = (t, r, l) => p0(t, (d) => r(d.element), (d, h) => l(d.element, h)), QG = (t) => k$(t, Dc, Iv), DA = (t) => In.config({
    store: {
      mode: "memory",
      initialValue: t
    }
  }), JG = {
    "colorcustom.rgb.red.label": "R",
    "colorcustom.rgb.red.description": "Red component",
    "colorcustom.rgb.green.label": "G",
    "colorcustom.rgb.green.description": "Green component",
    "colorcustom.rgb.blue.label": "B",
    "colorcustom.rgb.blue.description": "Blue component",
    "colorcustom.rgb.hex.label": "#",
    "colorcustom.rgb.hex.description": "Hex color code",
    "colorcustom.rgb.range": "Range 0 to 255",
    "aria.color.picker": "Color Picker",
    "aria.input.invalid": "Invalid input"
  }, _$ = (t) => (r) => A(r) ? t.translate(JG[r]) : t.translate(r), E$ = (t, r, l) => {
    const d = (O) => "tox-" + O, h = x$(_$(r), d), y = (O) => {
      po(O, yh, {
        name: "hex-valid",
        value: !0
      });
    }, w = (O) => {
      po(O, yh, {
        name: "hex-valid",
        value: !1
      });
    }, E = rr(h.sketch({
      dom: {
        tag: "div",
        classes: [d("color-picker-container")],
        attributes: { role: "presentation" }
      },
      onValidHex: y,
      onInvalidHex: w
    }));
    return {
      dom: { tag: "div" },
      components: [E.asSpec()],
      behaviours: Jt([
        p0(l, (O) => {
          const F = E.get(O);
          return Ds.getCurrent(F).bind((ne) => In.getValue(ne).hex).map((ne) => "#" + gn(ne, "#")).getOr("");
        }, (O, F) => {
          const L = /^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/, q = B.from(L.exec(F)).bind((de) => Dn(de, 1)), ne = E.get(O);
          Ds.getCurrent(ne).fold(() => {
            console.log("Can not find form");
          }, (de) => {
            In.setValue(de, { hex: q.getOr("") }), Kx.getField(de, "hex").each((_e) => {
              Xo(_e, Zf());
            });
          });
        }),
        sd.self()
      ])
    };
  };
  var eq = tinymce.util.Tools.resolve("tinymce.Resource");
  const T$ = (t) => Ko(t, "init"), tq = (t) => {
    const r = cr(), l = rr({ dom: { tag: t.tag } }), d = cr(), h = !T$(t) && t.onFocus.isSome() ? [
      To.config({
        onFocus: (y) => {
          t.onFocus.each((w) => {
            w(y.element.dom);
          });
        }
      }),
      jr.config({})
    ] : [];
    return {
      dom: {
        tag: "div",
        classes: ["tox-custom-editor"]
      },
      behaviours: Jt([
        jo("custom-editor-events", [qr((y) => {
          l.getOpt(y).each((w) => {
            (T$(t) ? t.init(w.element.dom) : eq.load(t.scriptId, t.scriptUrl).then((E) => E(w.element.dom, t.settings))).then((E) => {
              d.on((O) => {
                E.setValue(O);
              }), d.clear(), r.set(E);
            });
          });
        })]),
        p0(B.none(), () => r.get().fold(() => d.get().getOr(""), (y) => y.getValue()), (y, w) => {
          r.get().fold(() => d.set(w), (E) => E.setValue(w));
        }),
        sd.self()
      ].concat(h)),
      components: [l.asSpec()]
    };
  };
  var pm = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const nq = (t, r) => {
    const l = pm.explode(r.getOption("images_file_types")), d = (h) => Ro(l, (y) => Yr(h.name.toLowerCase(), `.${y.toLowerCase()}`));
    return So(rs(t), d);
  }, oq = (t, r, l) => {
    const d = (ne, ae) => {
      ae.stop();
    }, h = (ne) => (ae, de) => {
      xt(ne, (_e) => {
        _e(ae, de);
      });
    }, y = (ne, ae) => {
      var de;
      if (!_o.isDisabled(ne)) {
        const _e = ae.event.raw;
        E(ne, (de = _e.dataTransfer) === null || de === void 0 ? void 0 : de.files);
      }
    }, w = (ne, ae) => {
      const de = ae.event.raw.target;
      E(ne, de.files);
    }, E = (ne, ae) => {
      ae && (In.setValue(ne, nq(ae, r)), po(ne, _u, { name: t.name }));
    }, O = rr({
      dom: {
        tag: "input",
        attributes: {
          type: "file",
          accept: "image/*"
        },
        styles: { display: "none" }
      },
      behaviours: Jt([jo("input-file-events", [
        lf(tg()),
        lf(rf())
      ])])
    }), F = (ne) => ({
      uid: ne.uid,
      dom: {
        tag: "div",
        classes: ["tox-dropzone-container"]
      },
      behaviours: Jt([
        DA(l.getOr([])),
        sd.self(),
        _o.config({}),
        ns.config({
          toggleClass: "dragenter",
          toggleOnExecute: !1
        }),
        jo("dropzone-events", [
          Ft("dragenter", h([
            d,
            ns.toggle
          ])),
          Ft("dragleave", h([
            d,
            ns.toggle
          ])),
          Ft("dragover", d),
          Ft("drop", h([
            d,
            y
          ])),
          Ft(kv(), w)
        ])
      ]),
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-dropzone"],
          styles: {}
        },
        components: [
          {
            dom: { tag: "p" },
            components: [Aa(r.translate("Drop an image here"))]
          },
          Nl.sketch({
            dom: {
              tag: "button",
              styles: { position: "relative" },
              classes: [
                "tox-button",
                "tox-button--secondary"
              ]
            },
            components: [
              Aa(r.translate("Browse for an image")),
              O.asSpec()
            ],
            action: (ae) => {
              O.get(ae).element.dom.click();
            },
            buttonBehaviours: Jt([
              jr.config({}),
              dm.button(r.isDisabled),
              ki()
            ])
          })
        ]
      }]
    }), L = t.label.map((ne) => bb(ne, r)), q = fr.parts.field({ factory: { sketch: F } });
    return Vx(L, q, ["tox-form__group--stretched"], []);
  }, A$ = (t, r) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-form__grid",
        `tox-form__grid--${t.columns}col`
      ]
    },
    components: et(t.items, r.interpreter)
  }), O$ = (t, r) => {
    let l = null, d = null;
    return {
      cancel: () => {
        K(l) || (clearTimeout(l), l = null, d = null);
      },
      throttle: (...w) => {
        d = w, K(l) && (l = setTimeout(() => {
          const E = d;
          l = null, d = null, t.apply(null, E);
        }, r));
      }
    };
  }, sq = (t, r) => {
    let l = null;
    return {
      cancel: () => {
        K(l) || (clearTimeout(l), l = null);
      },
      throttle: (...y) => {
        K(l) && (l = setTimeout(() => {
          l = null, t.apply(null, y);
        }, r));
      }
    };
  }, SP = (t, r) => {
    let l = null;
    const d = () => {
      K(l) || (clearTimeout(l), l = null);
    };
    return {
      cancel: d,
      throttle: (...y) => {
        d(), l = setTimeout(() => {
          l = null, t.apply(null, y);
        }, r);
      }
    };
  }, US = Mn("alloy-fake-before-tabstop"), kP = Mn("alloy-fake-after-tabstop"), _P = (t) => ({
    dom: {
      tag: "div",
      styles: {
        width: "1px",
        height: "1px",
        outline: "none"
      },
      attributes: { tabindex: "0" },
      classes: t
    },
    behaviours: Jt([
      To.config({ ignore: !0 }),
      jr.config({})
    ])
  }), D$ = (t, r) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-navobj",
        ...t.getOr([])
      ]
    },
    components: [
      _P([US]),
      r,
      _P([kP])
    ],
    behaviours: Jt([sd.childAt(1)])
  }), R$ = (t, r) => {
    po(t, Ed(), {
      raw: {
        which: 9,
        shiftKey: r
      }
    });
  }, rq = (t, r) => {
    const l = r.element;
    Kc(l, US) ? R$(t, !0) : Kc(l, kP) && R$(t, !1);
  }, Yx = (t) => DS(t, [
    "." + US,
    "." + kP
  ].join(","), _t), jS = Mn("update-dialog"), N$ = Mn("update-title"), P$ = Mn("update-body"), M$ = Mn("update-footer"), I$ = Mn("body-send-message"), WS = Mn("dialog-focus-shifted"), EP = $l().browser, Xx = EP.isSafari(), aq = EP.isFirefox(), F$ = Xx || aq, iq = EP.isChromium(), lq = ({ scrollTop: t, scrollHeight: r, clientHeight: l }) => Math.ceil(t) + l >= r, B$ = (t, r) => t.scrollTo(0, r === "bottom" ? 99999999 : r), cq = (t, r) => {
    const l = t.body;
    return B.from(!/^<!DOCTYPE (html|HTML)/.test(r) && (!iq && !Xx || be(l) && (l.scrollTop !== 0 || Math.abs(l.scrollHeight - l.clientHeight) > 1)) ? l : t.documentElement);
  }, L$ = (t, r, l) => {
    const d = t.dom;
    B.from(d.contentDocument).fold(l, (h) => {
      let y = 0;
      const w = cq(h, r).map((O) => (y = O.scrollTop, O)).forall(lq), E = () => {
        const O = d.contentWindow;
        be(O) && (w ? B$(O, "bottom") : !w && F$ && y !== 0 && B$(O, y));
      };
      Xx && d.addEventListener("load", E, { once: !0 }), h.open(), h.write(r), h.close(), Xx || E();
    });
  }, uq = Xn(F$, Xx ? 500 : 200).map((t) => O$(L$, t)), TP = (t, r) => {
    const l = to(t.getOr(""));
    return {
      getValue: (d) => l.get(),
      setValue: (d, h) => {
        if (l.get() !== h) {
          const y = d.element, w = () => sn(y, "srcdoc", h);
          r ? uq.fold(ee(L$), (E) => E.throttle)(y, h, w) : w();
        }
        l.set(h);
      }
    };
  }, dq = (t, r, l) => {
    const d = "tox-dialog__iframe", h = t.transparent ? [] : [`${d}--opaque`], y = t.border ? ["tox-navobj-bordered"] : [], w = {
      ...t.label.map((q) => ({ title: q })).getOr({}),
      ...l.map((q) => ({ srcdoc: q })).getOr({}),
      ...t.sandboxed ? { sandbox: "allow-scripts allow-same-origin" } : {}
    }, E = TP(l, t.streamContent), O = t.label.map((q) => bb(q, r)), F = (q) => D$(B.from(y), {
      uid: q.uid,
      dom: {
        tag: "iframe",
        attributes: w,
        classes: [
          d,
          ...h
        ]
      },
      behaviours: Jt([
        jr.config({}),
        To.config({}),
        p0(l, E.getValue, E.setValue),
        Rc.config({
          channels: {
            [WS]: {
              onReceive: (ne, ae) => {
                ae.newFocus.each((de) => {
                  ji(ne.element).each((_e) => {
                    (Is(ne.element, de) ? Vr : ba)(_e, "tox-navobj-bordered-focus");
                  });
                });
              }
            }
          }
        })
      ])
    }), L = fr.parts.field({ factory: { sketch: F } });
    return Vx(O, L, ["tox-form__group--stretched"], []);
  }, fq = (t) => new Promise((r, l) => {
    const d = () => {
      y(), r(t);
    }, h = [
      uc(t, "load", d),
      uc(t, "error", () => {
        y(), l("Unable to load data from image: " + t.dom.src);
      })
    ], y = () => xt(h, (w) => w.unbind());
    t.dom.complete && d();
  }), mq = (t, r, l, d, h) => {
    const y = l * h, w = d * h, E = Math.max(0, t / 2 - y / 2), O = Math.max(0, r / 2 - w / 2);
    return {
      left: E.toString() + "px",
      top: O.toString() + "px",
      width: y.toString() + "px",
      height: w.toString() + "px"
    };
  }, ZS = (t, r, l) => {
    const d = Ri(t), h = Mr(t);
    return Math.min(d / r, h / l, 1);
  }, AP = (t, r) => {
    const l = to(r.getOr({ url: "" })), d = rr({
      dom: {
        tag: "img",
        classes: ["tox-imagepreview__image"],
        attributes: r.map((O) => ({ src: O.url })).getOr({})
      }
    }), h = rr({
      dom: {
        tag: "div",
        classes: ["tox-imagepreview__container"],
        attributes: { role: "presentation" }
      },
      components: [d.asSpec()]
    }), y = (O, F) => {
      const L = { url: F.url };
      F.zoom.each((ne) => L.zoom = ne), F.cachedWidth.each((ne) => L.cachedWidth = ne), F.cachedHeight.each((ne) => L.cachedHeight = ne), l.set(L);
      const q = () => {
        const { cachedWidth: ne, cachedHeight: ae, zoom: de } = L;
        if (!pe(ne) && !pe(ae)) {
          if (pe(de)) {
            const st = ZS(O.element, ne, ae);
            L.zoom = st;
          }
          const _e = mq(Ri(O.element), Mr(O.element), ne, ae, L.zoom);
          h.getOpt(O).each((st) => {
            Or(st.element, _e);
          });
        }
      };
      d.getOpt(O).each((ne) => {
        const ae = ne.element;
        F.url !== tr(ae, "src") && (sn(ae, "src", F.url), ba(O.element, "tox-imagepreview__loaded")), q(), fq(ae).then((de) => {
          O.getSystem().isConnected() && (Vr(O.element, "tox-imagepreview__loaded"), L.cachedWidth = de.dom.naturalWidth, L.cachedHeight = de.dom.naturalHeight, q());
        });
      });
    }, w = {};
    t.height.each((O) => w.height = O);
    const E = r.map((O) => ({
      url: O.url,
      zoom: B.from(O.zoom),
      cachedWidth: B.from(O.cachedWidth),
      cachedHeight: B.from(O.cachedHeight)
    }));
    return {
      dom: {
        tag: "div",
        classes: ["tox-imagepreview"],
        styles: w,
        attributes: { role: "presentation" }
      },
      components: [h.asSpec()],
      behaviours: Jt([
        sd.self(),
        p0(E, () => l.get(), y)
      ])
    };
  }, pq = (t, r, l) => {
    const d = "tox-label", h = t.align === "center" ? [`${d}--center`] : [], y = t.align === "end" ? [`${d}--end`] : [], w = rr({
      dom: {
        tag: "label",
        classes: [
          d,
          ...h,
          ...y
        ]
      },
      components: [Aa(r.providers.translate(t.label))]
    }), E = et(t.items, r.interpreter);
    return {
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: [
        w.asSpec(),
        ...E
      ],
      behaviours: Jt([
        sd.self(),
        Po.config({}),
        QG(B.none()),
        so.config({ mode: "acyclic" }),
        jo("label", [qr((O) => {
          t.for.each((F) => {
            l(F).each((L) => {
              w.getOpt(O).each((q) => {
                var ne;
                const ae = (ne = tr(L.element, "id")) !== null && ne !== void 0 ? ne : Mn("form-field");
                sn(L.element, "id", ae), sn(q.element, "for", ae);
              });
            });
          });
        })])
      ])
    };
  }, $$ = Mn("toolbar.button.execute"), OP = (t) => Td((r, l) => {
    YT(t, r)((d) => {
      po(r, $$, { buttonApi: d }), t.onAction(d);
    });
  }), h0 = Mn("common-button-display-events"), RA = {
    [Wu()]: [
      "disabling",
      "alloy.base.behaviour",
      "toggling",
      "toolbar-button-events",
      "tooltipping"
    ],
    [rc()]: [
      "toolbar-button-events",
      h0
    ],
    [Zu()]: [
      "toolbar-button-events",
      "dropdown-events",
      "tooltipping"
    ],
    [sc()]: [
      "focusing",
      "alloy.base.behaviour",
      h0
    ]
  }, NA = (t) => Ln(t.element, "width", lr(t.element, "width")), H$ = (t, r, l) => ku(t, {
    tag: "span",
    classes: [
      "tox-icon",
      "tox-tbtn__icon-wrap"
    ],
    behaviours: l
  }, r), DP = (t, r) => H$(t, r, []), Zg = (t, r) => H$(t, r, [Po.config({})]), RP = (t, r, l) => ({
    dom: {
      tag: "span",
      classes: [`${r}__select-label`]
    },
    components: [Aa(l.translate(t))],
    behaviours: Jt([Po.config({})])
  }), Ef = Mn("update-menu-text"), wb = Mn("update-menu-icon"), PA = (t, r, l, d) => {
    const h = to(U), y = t.text.map((_e) => rr(RP(_e, r, l.providers))), w = t.icon.map((_e) => rr(Zg(_e, l.providers.icons))), E = (_e, st) => {
      const Re = In.getValue(_e);
      return To.focus(Re), po(Re, "keydown", { raw: st.event.raw }), wf.close(Re), B.some(!0);
    }, O = t.role.fold(() => ({}), (_e) => ({ role: _e })), F = B.from(t.listRole).map((_e) => ({ listRole: _e })).getOr({}), L = t.ariaLabel.fold(() => ({}), (_e) => ({ "aria-label": l.providers.translate(_e) })), q = ku("chevron-down", {
      tag: "div",
      classes: [`${r}__select-chevron`]
    }, l.providers.icons), ne = Mn("common-button-display-events"), ae = "dropdown-events";
    return rr(wf.sketch({
      ...t.uid ? { uid: t.uid } : {},
      ...O,
      ...F,
      dom: {
        tag: "button",
        classes: [
          r,
          `${r}--select`
        ].concat(et(t.classes, (_e) => `${r}--${_e}`)),
        attributes: {
          ...L,
          ...be(d) ? { "data-mce-name": d } : {}
        }
      },
      components: e0([
        w.map((_e) => _e.asSpec()),
        y.map((_e) => _e.asSpec()),
        B.some(q)
      ]),
      matchWidth: !0,
      useMinWidth: !0,
      onOpen: (_e, st, Re) => {
        t.searchable && dA(Re);
      },
      dropdownBehaviours: Jt([
        ...t.dropdownBehaviours,
        dm.button(() => t.disabled || l.providers.isDisabled()),
        ki(),
        jx.config({}),
        Po.config({}),
        ...t.tooltip.map((_e) => gl.config(l.providers.tooltips.getConfig({ tooltipText: l.providers.translate(_e) }))).toArray(),
        jo(ae, [
          Vg(t, h),
          hc(t, h)
        ]),
        jo(ne, [qr((_e, st) => NA(_e))]),
        jo("menubutton-update-display-text", [
          Ft(Ef, (_e, st) => {
            y.bind((Re) => Re.getOpt(_e)).each((Re) => {
              Po.set(Re, [Aa(l.providers.translate(st.event.text))]);
            });
          }),
          Ft(wb, (_e, st) => {
            w.bind((Re) => Re.getOpt(_e)).each((Re) => {
              Po.set(Re, [Zg(st.event.icon, l.providers.icons)]);
            });
          })
        ])
      ]),
      eventOrder: Pr(RA, {
        [sc()]: [
          "focusing",
          "alloy.base.behaviour",
          "item-type-events",
          "normal-dropdown-events"
        ],
        [rc()]: [
          "toolbar-button-events",
          gl.name(),
          ae,
          ne
        ]
      }),
      sandboxBehaviours: Jt([
        so.config({
          mode: "special",
          onLeft: E,
          onRight: E
        }),
        jo("dropdown-sandbox-events", [
          Ft(eL, (_e, st) => {
            RZ(_e), st.stop();
          }),
          Ft(tL, (_e, st) => {
            NZ(_e, st), st.stop();
          })
        ])
      ]),
      lazySink: l.getSink,
      toggleClass: `${r}--active`,
      parts: {
        menu: {
          ...pS(!1, t.columns, t.presets),
          fakeFocus: t.searchable,
          ...t.listRole === "listbox" ? {} : {
            onHighlightItem: OS,
            onCollapseMenu: (_e, st, Re) => {
              yn.getHighlighted(Re).each((Qe) => {
                OS(_e, Re, Qe);
              });
            },
            onDehighlightItem: IZ
          }
        }
      },
      getAnchorOverrides: () => ({
        maxHeightFunction: (_e, st) => {
          Py()(_e, st - 10);
        }
      }),
      fetch: (_e) => Zl.nu(Vt(t.fetch, _e))
    })).asSpec();
  }, hq = (t) => A(t), NP = (t) => t.type === "separator", z$ = (t) => Ko(t, "getSubmenuItems"), V$ = { type: "separator" }, gq = (t, r) => {
    const l = Pt(t, (d, h) => hq(h) ? h === "" ? d : h === "|" ? d.length > 0 && !NP(d[d.length - 1]) ? d.concat([V$]) : d : Ko(r, h.toLowerCase()) ? d.concat([r[h.toLowerCase()]]) : d : d.concat([h]), []);
    return l.length > 0 && NP(l[l.length - 1]) && l.pop(), l;
  }, vq = (t, r) => {
    const l = t.getSubmenuItems(), d = PP(l, r), h = Pr(d.menus, { [t.value]: d.items }), y = Pr(d.expansions, { [t.value]: t.value });
    return {
      item: t,
      menus: h,
      expansions: y
    };
  }, bq = (t) => {
    const r = qt(t, "value").getOrThunk(() => Mn("generated-menu-item"));
    return Pr({ value: r }, t);
  }, PP = (t, r) => {
    const l = gq(A(t) ? t.split(" ") : t, r);
    return At(l, (d, h) => {
      if (z$(h)) {
        const y = bq(h), w = vq(y, r);
        return {
          menus: Pr(d.menus, w.menus),
          items: [
            w.item,
            ...d.items
          ],
          expansions: Pr(d.expansions, w.expansions)
        };
      } else
        return {
          ...d,
          items: [
            h,
            ...d.items
          ]
        };
    }, {
      menus: {},
      expansions: {},
      items: []
    });
  }, yq = (t) => t.search.fold(() => ({ searchMode: "no-search" }), (r) => ({
    searchMode: "search-with-field",
    placeholder: r.placeholder
  })), U$ = (t) => t.search.fold(() => ({ searchMode: "no-search" }), (r) => ({ searchMode: "search-with-results" })), Qx = (t, r, l, d) => {
    const h = Mn("primary-menu"), y = PP(t, l.shared.providers.menuItems());
    if (y.items.length === 0)
      return B.none();
    const w = yq(d), E = $Z(h, y.items, r, l, d.isHorizontalMenu, w), O = U$(d), F = kt(y.menus, (q, ne) => $Z(ne, q, r, l, !1, O)), L = Pr(F, nr(h, E));
    return B.from(U1.tieredData(h, L, y.expansions));
  }, MA = (t) => !Ko(t, "items"), IA = "data-value", j$ = (t, r, l, d, h) => et(l, (y) => MA(y) ? {
    type: "togglemenuitem",
    ...h ? {} : { role: "option" },
    text: y.text,
    value: y.value,
    active: y.value === d,
    onAction: () => {
      In.setValue(t, y.value), po(t, _u, { name: r }), To.focus(t);
    }
  } : {
    type: "nestedmenuitem",
    text: y.text,
    getSubmenuItems: () => j$(t, r, y.items, d, h)
  }), MP = (t, r) => Qo(t, (l) => MA(l) ? Xn(l.value === r, l) : MP(l.items, r)), xq = (t, r, l) => {
    const d = Ro(t.items, (F) => !MA(F)), h = r.shared.providers, y = l.bind((F) => MP(t.items, F)).orThunk(() => ao(t.items).filter(MA)), w = t.label.map((F) => bb(F, h)), E = fr.parts.field({
      dom: {},
      factory: {
        sketch: (F) => PA({
          uid: F.uid,
          text: y.map((L) => L.text),
          icon: B.none(),
          tooltip: B.none(),
          role: Xn(!d, "combobox"),
          ...d ? {} : { listRole: "listbox" },
          ariaLabel: t.label,
          fetch: (L, q) => {
            const ne = j$(L, t.name, t.items, In.getValue(L), d);
            q(Qx(ne, im.CLOSE_ON_EXECUTE, r, {
              isHorizontalMenu: !1,
              search: B.none()
            }));
          },
          onSetup: ee(U),
          getApi: ee({}),
          columns: 1,
          presets: "normal",
          classes: [],
          dropdownBehaviours: [
            jr.config({}),
            p0(y.map((L) => L.value), (L) => tr(L.element, IA), (L, q) => {
              MP(t.items, q).each((ne) => {
                sn(L.element, IA, ne.value), po(L, Ef, { text: ne.text });
              });
            })
          ]
        }, "tox-listbox", r.shared)
      }
    }), O = {
      dom: {
        tag: "div",
        classes: ["tox-listboxfield"]
      },
      components: [E]
    };
    return fr.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: tn([
        w.toArray(),
        [O]
      ]),
      fieldBehaviours: Jt([_o.config({
        disabled: ee(!t.enabled),
        onDisabled: (F) => {
          fr.getField(F).each(_o.disable);
        },
        onEnabled: (F) => {
          fr.getField(F).each(_o.enable);
        }
      })])
    });
  }, IP = (t, r) => ({
    dom: {
      tag: "div",
      classes: t.classes
    },
    components: et(t.items, r.shared.interpreter)
  }), wq = (t, r) => {
    const l = et(t.options, (h) => ({
      dom: {
        tag: "option",
        value: h.value,
        innerHtml: h.text
      }
    })), d = t.data.map((h) => nr("initialValue", h)).getOr({});
    return {
      uid: t.uid,
      dom: {
        tag: "select",
        classes: t.selectClasses,
        attributes: t.selectAttributes
      },
      components: l,
      behaviours: Hi(t.selectBehaviours, [
        To.config({}),
        In.config({
          store: {
            mode: "manual",
            getValue: (h) => gt(h.element),
            setValue: (h, y) => {
              const w = ao(t.options);
              Nt(t.options, (O) => O.value === y).isSome() ? Jf(h.element, y) : h.element.dom.selectedIndex === -1 && y === "" && w.each((O) => Jf(h.element, O.value));
            },
            ...d
          }
        })
      ])
    };
  }, W$ = Nc({
    name: "HtmlSelect",
    configFields: [
      Mt("options"),
      $i("selectBehaviours", [
        To,
        In
      ]),
      Xe("selectClasses", []),
      Xe("selectAttributes", {}),
      $s("data")
    ],
    factory: wq
  }), Cq = (t, r, l) => {
    const d = et(t.items, (O) => ({
      text: r.translate(O.text),
      value: O.value
    })), h = t.label.map((O) => bb(O, r)), y = fr.parts.field({
      dom: {},
      ...l.map((O) => ({ data: O })).getOr({}),
      selectAttributes: { size: t.size },
      options: d,
      factory: W$,
      selectBehaviours: Jt([
        _o.config({ disabled: () => !t.enabled || r.isDisabled() }),
        jr.config({}),
        jo("selectbox-change", [Ft(kv(), (O, F) => {
          po(O, _u, { name: t.name });
        })])
      ])
    }), w = t.size > 1 ? B.none() : B.some(ku("chevron-down", {
      tag: "div",
      classes: ["tox-selectfield__icon-js"]
    }, r.icons)), E = {
      dom: {
        tag: "div",
        classes: ["tox-selectfield"]
      },
      components: tn([
        [y],
        w.toArray()
      ])
    };
    return fr.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: tn([
        h.toArray(),
        [E]
      ]),
      fieldBehaviours: Jt([
        _o.config({
          disabled: () => !t.enabled || r.isDisabled(),
          onDisabled: (O) => {
            fr.getField(O).each(_o.disable);
          },
          onEnabled: (O) => {
            fr.getField(O).each(_o.enable);
          }
        }),
        ki()
      ])
    });
  }, Z$ = ee([
    Xe("field1Name", "field1"),
    Xe("field2Name", "field2"),
    Gu("onLockedChange"),
    Xf(["lockClass"]),
    Xe("locked", !1),
    Yu.field("coupledFieldBehaviours", [
      Ds,
      In
    ])
  ]), Sq = (t, r, l) => Qt(t, r, l).bind(Ds.getCurrent), G$ = (t, r) => hl({
    factory: fr,
    name: t,
    overrides: (l) => ({
      fieldBehaviours: Jt([jo("coupled-input-behaviour", [Ft(Zf(), (d) => {
        Sq(d, l, r).each((h) => {
          Qt(d, l, "lock").each((y) => {
            ns.isOn(y) && l.onLockedChange(d, h, y);
          });
        });
      })])])
    })
  }), kq = ee([
    G$("field1", "field2"),
    G$("field2", "field1"),
    hl({
      factory: Nl,
      schema: [Mt("dom")],
      name: "lock",
      overrides: (t) => ({
        buttonBehaviours: Jt([ns.config({
          selected: t.locked,
          toggleClass: t.markers.lockClass,
          aria: { mode: "pressed" }
        })])
      })
    })
  ]), _q = (t, r, l, d) => ({
    uid: t.uid,
    dom: t.dom,
    components: r,
    behaviours: Yu.augment(t.coupledFieldBehaviours, [
      Ds.config({ find: B.some }),
      In.config({
        store: {
          mode: "manual",
          getValue: (h) => {
            const y = P1(h, t, [
              "field1",
              "field2"
            ]);
            return {
              [t.field1Name]: In.getValue(y.field1()),
              [t.field2Name]: In.getValue(y.field2())
            };
          },
          setValue: (h, y) => {
            const w = P1(h, t, [
              "field1",
              "field2"
            ]);
            Lr(y, t.field1Name) && In.setValue(w.field1(), y[t.field1Name]), Lr(y, t.field2Name) && In.setValue(w.field2(), y[t.field2Name]);
          }
        }
      })
    ]),
    apis: {
      getField1: (h) => Qt(h, t, "field1"),
      getField2: (h) => Qt(h, t, "field2"),
      getLock: (h) => Qt(h, t, "lock")
    }
  }), Id = Wl({
    name: "FormCoupledInputs",
    configFields: Z$(),
    partFields: kq(),
    factory: _q,
    apis: {
      getField1: (t, r) => t.getField1(r),
      getField2: (t, r) => t.getField2(r),
      getLock: (t, r) => t.getLock(r)
    }
  }), q$ = (t) => {
    const r = {
      "": 0,
      px: 0,
      pt: 1,
      mm: 1,
      pc: 2,
      ex: 2,
      em: 2,
      ch: 2,
      rem: 2,
      cm: 3,
      in: 4,
      "%": 4
    }, l = (h) => h in r ? r[h] : 1;
    let d = t.value.toFixed(l(t.unit));
    return d.indexOf(".") !== -1 && (d = d.replace(/\.?0*$/, "")), d + t.unit;
  }, FP = (t) => {
    const l = /^\s*(\d+(?:\.\d+)?)\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\s*$/.exec(t);
    if (l !== null) {
      const d = parseFloat(l[1]), h = l[2];
      return Ho.value({
        value: d,
        unit: h
      });
    } else
      return Ho.error(t);
  }, K$ = (t, r) => {
    const l = {
      "": 96,
      px: 96,
      pt: 72,
      cm: 2.54,
      pc: 12,
      mm: 25.4,
      in: 1
    }, d = (h) => Ko(l, h);
    return t.unit === r ? B.some(t.value) : d(t.unit) && d(r) ? l[t.unit] === l[r] ? B.some(t.value) : B.some(t.value / l[t.unit] * l[r]) : B.none();
  }, FA = (t) => B.none(), Eq = (t, r) => (l) => K$(l, r).map((d) => ({
    value: d * t,
    unit: r
  })), Tq = (t, r) => {
    const l = FP(t).toOptional(), d = FP(r).toOptional();
    return xa(l, d, (h, y) => K$(h, y.unit).map((w) => y.value / w).map((w) => Eq(w, y.unit)).getOr(FA)).getOr(FA);
  }, Aq = (t, r) => {
    let l = FA;
    const d = Mn("ratio-event"), h = (ae) => ku(ae, {
      tag: "span",
      classes: [
        "tox-icon",
        "tox-lock-icon__" + ae
      ]
    }, r.icons), y = t.label.getOr("Constrain proportions"), w = r.translate(y), E = Id.parts.lock({
      dom: {
        tag: "button",
        classes: [
          "tox-lock",
          "tox-button",
          "tox-button--naked",
          "tox-button--icon"
        ],
        attributes: {
          "aria-label": w,
          "data-mce-name": y
        }
      },
      components: [
        h("lock"),
        h("unlock")
      ],
      buttonBehaviours: Jt([
        _o.config({ disabled: () => !t.enabled || r.isDisabled() }),
        ki(),
        jr.config({}),
        gl.config(r.tooltips.getConfig({ tooltipText: w }))
      ])
    }), O = (ae) => ({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: ae
    }), F = (ae) => fr.parts.field({
      factory: Y1,
      inputClasses: ["tox-textfield"],
      inputBehaviours: Jt([
        _o.config({ disabled: () => !t.enabled || r.isDisabled() }),
        ki(),
        jr.config({}),
        jo("size-input-events", [
          Ft(nf(), (de, _e) => {
            po(de, d, { isField1: ae });
          }),
          Ft(kv(), (de, _e) => {
            po(de, _u, { name: t.name });
          })
        ])
      ]),
      selectOnFocus: !1
    }), L = (ae) => ({
      dom: {
        tag: "label",
        classes: ["tox-label"]
      },
      components: [Aa(r.translate(ae))]
    }), q = Id.parts.field1(O([
      fr.parts.label(L("Width")),
      F(!0)
    ])), ne = Id.parts.field2(O([
      fr.parts.label(L("Height")),
      F(!1)
    ]));
    return Id.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-form__controls-h-stack"]
        },
        components: [
          q,
          ne,
          O([
            L(oh),
            E
          ])
        ]
      }],
      field1Name: "width",
      field2Name: "height",
      locked: !0,
      markers: { lockClass: "tox-locked" },
      onLockedChange: (ae, de, _e) => {
        FP(In.getValue(ae)).each((st) => {
          l(st).each((Re) => {
            In.setValue(de, q$(Re));
          });
        });
      },
      coupledFieldBehaviours: Jt([
        _o.config({
          disabled: () => !t.enabled || r.isDisabled(),
          onDisabled: (ae) => {
            Id.getField1(ae).bind(fr.getField).each(_o.disable), Id.getField2(ae).bind(fr.getField).each(_o.disable), Id.getLock(ae).each(_o.disable);
          },
          onEnabled: (ae) => {
            Id.getField1(ae).bind(fr.getField).each(_o.enable), Id.getField2(ae).bind(fr.getField).each(_o.enable), Id.getLock(ae).each(_o.enable);
          }
        }),
        ki(),
        jo("size-input-events2", [Ft(d, (ae, de) => {
          const _e = de.event.isField1, st = _e ? Id.getField1(ae) : Id.getField2(ae), Re = _e ? Id.getField2(ae) : Id.getField1(ae), Qe = st.map(In.getValue).getOr(""), qe = Re.map(In.getValue).getOr("");
          l = Tq(Qe, qe);
        })])
      ])
    });
  }, Y$ = (t, r, l) => {
    const d = _f.parts.label({
      dom: {
        tag: "label",
        classes: ["tox-label"]
      },
      components: [Aa(r.translate(t.label))]
    }), h = _f.parts.spectrum({
      dom: {
        tag: "div",
        classes: ["tox-slider__rail"],
        attributes: { role: "presentation" }
      }
    }), y = _f.parts.thumb({
      dom: {
        tag: "div",
        classes: ["tox-slider__handle"],
        attributes: { role: "presentation" }
      }
    });
    return _f.sketch({
      dom: {
        tag: "div",
        classes: ["tox-slider"],
        attributes: { role: "presentation" }
      },
      model: {
        mode: "x",
        minX: t.min,
        maxX: t.max,
        getInitialValue: ee(l.getOrThunk(() => (Math.abs(t.max) - Math.abs(t.min)) / 2))
      },
      components: [
        d,
        h,
        y
      ],
      sliderBehaviours: Jt([
        sd.self(),
        To.config({})
      ]),
      onChoose: (w, E, O) => {
        po(w, _u, {
          name: t.name,
          value: O
        });
      },
      onChange: (w, E, O) => {
        po(w, _u, {
          name: t.name,
          value: O
        });
      }
    });
  }, Oq = (t, r) => {
    const l = (E) => ({
      dom: {
        tag: "th",
        innerHtml: r.translate(E)
      }
    }), d = (E) => ({
      dom: { tag: "thead" },
      components: [{
        dom: { tag: "tr" },
        components: et(E, l)
      }]
    }), h = (E) => ({
      dom: {
        tag: "td",
        innerHtml: r.translate(E)
      }
    }), y = (E) => ({
      dom: { tag: "tr" },
      components: et(E, h)
    }), w = (E) => ({
      dom: { tag: "tbody" },
      components: et(E, y)
    });
    return {
      dom: {
        tag: "table",
        classes: ["tox-dialog__table"]
      },
      components: [
        d(t.header),
        w(t.cells)
      ],
      behaviours: Jt([
        jr.config({}),
        To.config({})
      ])
    };
  }, X$ = (t, r) => {
    const l = t.label.map((ae) => bb(ae, r)), d = [
      _o.config({ disabled: () => t.disabled || r.isDisabled() }),
      ki(),
      so.config({
        mode: "execution",
        useEnter: t.multiline !== !0,
        useControlEnter: t.multiline === !0,
        execute: (ae) => (Xo(ae, Ux), B.some(!0))
      }),
      jo("textfield-change", [
        Ft(Zf(), (ae, de) => {
          po(ae, _u, { name: t.name });
        }),
        Ft(Bm(), (ae, de) => {
          po(ae, _u, { name: t.name });
        })
      ]),
      jr.config({})
    ], h = t.validation.map((ae) => xh.config({
      getRoot: (de) => ji(de.element),
      invalidClass: "tox-invalid",
      validator: {
        validate: (de) => {
          const _e = In.getValue(de), st = ae.validator(_e);
          return Zl.pure(st === !0 ? Ho.value(_e) : Ho.error(st));
        },
        validateOnLoad: ae.validateOnLoad
      }
    })).toArray(), y = t.placeholder.fold(ee({}), (ae) => ({ placeholder: r.translate(ae) })), w = t.inputMode.fold(ee({}), (ae) => ({ inputmode: ae })), E = {
      ...y,
      ...w
    }, O = fr.parts.field({
      tag: t.multiline === !0 ? "textarea" : "input",
      ...t.data.map((ae) => ({ data: ae })).getOr({}),
      inputAttributes: E,
      inputClasses: [t.classname],
      inputBehaviours: Jt(tn([
        d,
        h
      ])),
      selectOnFocus: !1,
      factory: Y1
    }), F = t.multiline ? {
      dom: {
        tag: "div",
        classes: ["tox-textarea-wrap"]
      },
      components: [O]
    } : O, q = (t.flex ? ["tox-form__group--stretched"] : []).concat(t.maximized ? ["tox-form-group--maximize"] : []), ne = [
      _o.config({
        disabled: () => t.disabled || r.isDisabled(),
        onDisabled: (ae) => {
          fr.getField(ae).each(_o.disable);
        },
        onEnabled: (ae) => {
          fr.getField(ae).each(_o.enable);
        }
      }),
      ki()
    ];
    return Vx(l, F, q, ne);
  }, Dq = (t, r, l) => X$({
    name: t.name,
    multiline: !1,
    label: t.label,
    inputMode: t.inputMode,
    placeholder: t.placeholder,
    flex: !1,
    disabled: !t.enabled,
    classname: "tox-textfield",
    validation: B.none(),
    maximized: t.maximized,
    data: l
  }, r), Q$ = (t, r, l) => X$({
    name: t.name,
    multiline: !0,
    label: t.label,
    inputMode: B.none(),
    placeholder: t.placeholder,
    flex: !0,
    disabled: !t.enabled,
    classname: "tox-textarea",
    validation: B.none(),
    maximized: t.maximized,
    data: l
  }, r), Jx = (t, r) => r.getAnimationRoot.fold(() => t.element, (l) => l(t)), Ch = (t) => t.dimension.property, Sh = (t, r) => t.dimension.getDimension(r), BA = (t, r) => {
    const l = Jx(t, r);
    Yc(l, [
      r.shrinkingClass,
      r.growingClass
    ]);
  }, BP = (t, r) => {
    ba(t.element, r.openClass), Vr(t.element, r.closedClass), Ln(t.element, Ch(r), "0px"), xi(t.element);
  }, LP = (t, r) => {
    ba(t.element, r.closedClass), Vr(t.element, r.openClass), gs(t.element, Ch(r));
  }, J$ = (t, r, l, d) => {
    l.setCollapsed(), Ln(t.element, Ch(r), Sh(r, t.element)), BA(t, r), BP(t, r), r.onStartShrink(t), r.onShrunk(t);
  }, e8 = (t, r, l, d) => {
    const h = d.getOrThunk(() => Sh(r, t.element));
    l.setCollapsed(), Ln(t.element, Ch(r), h), xi(t.element);
    const y = Jx(t, r);
    ba(y, r.growingClass), Vr(y, r.shrinkingClass), BP(t, r), r.onStartShrink(t);
  }, t8 = (t, r, l) => {
    const d = Sh(r, t.element);
    (d === "0px" ? J$ : e8)(t, r, l, B.some(d));
  }, n8 = (t, r, l) => {
    const d = Jx(t, r), h = Kc(d, r.shrinkingClass), y = Sh(r, t.element);
    LP(t, r);
    const w = Sh(r, t.element);
    (h ? () => {
      Ln(t.element, Ch(r), y), xi(t.element);
    } : () => {
      BP(t, r);
    })(), ba(d, r.shrinkingClass), Vr(d, r.growingClass), LP(t, r), Ln(t.element, Ch(r), w), l.setExpanded(), r.onStartGrow(t);
  }, Rq = (t, r, l) => {
    if (l.isExpanded()) {
      gs(t.element, Ch(r));
      const d = Sh(r, t.element);
      Ln(t.element, Ch(r), d);
    }
  }, o8 = (t, r, l) => {
    l.isExpanded() || n8(t, r, l);
  }, s8 = (t, r, l) => {
    l.isExpanded() && t8(t, r, l);
  }, Nq = (t, r, l) => {
    l.isExpanded() && J$(t, r, l);
  }, Pq = (t, r, l) => l.isExpanded(), r8 = (t, r, l) => l.isCollapsed(), a8 = (t, r, l) => {
    const d = Jx(t, r);
    return Kc(d, r.growingClass) === !0;
  }, i8 = (t, r, l) => {
    const d = Jx(t, r);
    return Kc(d, r.shrinkingClass) === !0;
  };
  var l8 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    refresh: Rq,
    grow: o8,
    shrink: s8,
    immediateShrink: Nq,
    hasGrown: Pq,
    hasShrunk: r8,
    isGrowing: a8,
    isShrinking: i8,
    isTransitioning: (t, r, l) => a8(t, r) || i8(t, r),
    toggleGrow: (t, r, l) => {
      (l.isExpanded() ? t8 : n8)(t, r, l);
    },
    disableTransitions: BA,
    immediateGrow: (t, r, l) => {
      l.isExpanded() || (LP(t, r), Ln(t.element, Ch(r), Sh(r, t.element)), BA(t, r), l.setExpanded(), r.onStartGrow(t), r.onGrown(t));
    }
  }), c8 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, r, l) => {
      const d = r.expanded;
      return Gc(d ? {
        classes: [r.openClass],
        styles: {}
      } : {
        classes: [r.closedClass],
        styles: nr(r.dimension.property, "0px")
      });
    },
    events: (t, r) => zr([_v(of(), (l, d) => {
      d.event.raw.propertyName === t.dimension.property && (BA(l, t), r.isExpanded() && gs(l.element, t.dimension.property), (r.isExpanded() ? t.onGrown : t.onShrunk)(l));
    })])
  }), Kre = [
    Mt("closedClass"),
    Mt("openClass"),
    Mt("shrinkingClass"),
    Mt("growingClass"),
    $s("getAnimationRoot"),
    Os("onShrunk"),
    Os("onStartShrink"),
    Os("onGrown"),
    Os("onStartGrow"),
    Xe("expanded", !1),
    Ls("dimension", ui("property", {
      width: [
        Ur("property", "width"),
        Ur("getDimension", (t) => Ri(t) + "px")
      ],
      height: [
        Ur("property", "height"),
        Ur("getDimension", (t) => Mr(t) + "px")
      ]
    }))
  ], Bq = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: (t) => {
      const r = to(t.expanded), l = () => "expanded: " + r.get();
      return qc({
        isExpanded: () => r.get() === !0,
        isCollapsed: () => r.get() === !1,
        setCollapsed: Vt(r.set, !1),
        setExpanded: Vt(r.set, !0),
        readState: l
      });
    }
  });
  const ru = Xi({
    fields: Kre,
    name: "sliding",
    active: c8,
    apis: l8,
    state: Bq
  }), u8 = (t) => ({
    isEnabled: () => !_o.isDisabled(t),
    setEnabled: (r) => _o.set(t, !r),
    setActive: (r) => {
      const l = t.element;
      r ? (Vr(l, "tox-tbtn--enabled"), sn(l, "aria-pressed", !0)) : (ba(l, "tox-tbtn--enabled"), Ee(l, "aria-pressed"));
    },
    isActive: () => Kc(t.element, "tox-tbtn--enabled"),
    setText: (r) => {
      po(t, Ef, { text: r });
    },
    setIcon: (r) => po(t, wb, { icon: r })
  }), GS = (t, r, l, d, h = !0, y) => PA({
    text: t.text,
    icon: t.icon,
    tooltip: t.tooltip,
    ariaLabel: t.tooltip,
    searchable: t.search.isSome(),
    role: d,
    fetch: (w, E) => {
      const O = { pattern: t.search.isSome() ? FZ(w) : "" };
      t.fetch((F) => {
        E(Qx(F, im.CLOSE_ON_EXECUTE, l, {
          isHorizontalMenu: !1,
          search: t.search
        }));
      }, O, u8(w));
    },
    onSetup: t.onSetup,
    getApi: u8,
    columns: 1,
    presets: "normal",
    classes: [],
    dropdownBehaviours: [...h ? [jr.config({})] : []]
  }, r, l.shared, y), Lq = (t, r, l) => {
    const d = (y) => (w) => {
      const E = !w.isActive();
      w.setActive(E), y.storage.set(E), l.shared.getSink().each((O) => {
        r().getOpt(O).each((F) => {
          vu(F.element), po(F, yh, {
            name: y.name,
            value: y.storage.get()
          });
        });
      });
    }, h = (y) => (w) => {
      w.setActive(y.storage.get());
    };
    return (y) => {
      y(et(t, (w) => {
        const E = w.text.fold(() => ({}), (O) => ({ text: O }));
        return {
          type: w.type,
          active: !1,
          ...E,
          onAction: d(w),
          onSetup: h(w)
        };
      }));
    };
  }, $P = (t) => ({
    dom: {
      tag: "span",
      classes: ["tox-tree__label"],
      attributes: { "aria-label": t }
    },
    components: [Aa(t)]
  }), HA = Mn("leaf-label-event-id"), zA = ({ leaf: t, onLeafAction: r, visible: l, treeId: d, selectedId: h, backstage: y }) => {
    const w = t.menu.map((O) => GS(O, "tox-mbtn", y, B.none(), l)), E = [$P(t.title)];
    return w.each((O) => E.push(O)), Nl.sketch({
      dom: {
        tag: "div",
        classes: [
          "tox-tree--leaf__label",
          "tox-trbtn"
        ].concat(l ? ["tox-tree--leaf__label--visible"] : [])
      },
      components: E,
      role: "treeitem",
      action: (O) => {
        r(t.id), O.getSystem().broadcastOn([`update-active-item-${d}`], { value: t.id });
      },
      eventOrder: {
        [Ed()]: [
          HA,
          "keying"
        ]
      },
      buttonBehaviours: Jt([
        ...l ? [jr.config({})] : [],
        ns.config({
          toggleClass: "tox-trbtn--enabled",
          toggleOnExecute: !1,
          aria: { mode: "selected" }
        }),
        Rc.config({
          channels: {
            [`update-active-item-${d}`]: {
              onReceive: (O, F) => {
                (F.value === t.id ? ns.on : ns.off)(O);
              }
            }
          }
        }),
        jo(HA, [
          qr((O, F) => {
            h.each((L) => {
              (L === t.id ? ns.on : ns.off)(O);
            });
          }),
          Ft(Ed(), (O, F) => {
            const L = F.event.raw.code === "ArrowLeft", q = F.event.raw.code === "ArrowRight";
            L ? (Vm(O.element, ".tox-tree--directory").each((ne) => {
              O.getSystem().getByDom(ne).each((ae) => {
                Iw(ne, ".tox-tree--directory__label").each((de) => {
                  ae.getSystem().getByDom(de).each(To.focus);
                });
              });
            }), F.stop()) : q && F.stop();
          })
        ])
      ])
    });
  }, $q = (t, r, l) => ku(t, {
    tag: "span",
    classes: [
      "tox-tree__icon-wrap",
      "tox-icon"
    ],
    behaviours: l
  }, r), Hq = (t, r) => $q(t, r, []), d8 = Mn("directory-label-event-id"), zq = ({ directory: t, visible: r, noChildren: l, backstage: d }) => {
    const h = t.menu.map((E) => GS(E, "tox-mbtn", d, B.none())), y = [
      {
        dom: {
          tag: "div",
          classes: ["tox-chevron"]
        },
        components: [Hq("chevron-right", d.shared.providers.icons)]
      },
      $P(t.title)
    ];
    h.each((E) => {
      y.push(E);
    });
    const w = (E) => {
      Vm(E.element, ".tox-tree--directory").each((O) => {
        E.getSystem().getByDom(O).each((F) => {
          const L = !ns.isOn(F);
          ns.toggle(F), po(E, "expand-tree-node", {
            expanded: L,
            node: t.id
          });
        });
      });
    };
    return Nl.sketch({
      dom: {
        tag: "div",
        classes: [
          "tox-tree--directory__label",
          "tox-trbtn"
        ].concat(r ? ["tox-tree--directory__label--visible"] : [])
      },
      components: y,
      action: w,
      eventOrder: {
        [Ed()]: [
          d8,
          "keying"
        ]
      },
      buttonBehaviours: Jt([
        ...r ? [jr.config({})] : [],
        jo(d8, [Ft(Ed(), (E, O) => {
          const F = O.event.raw.code === "ArrowRight", L = O.event.raw.code === "ArrowLeft";
          F && l && O.stop(), (F || L) && Vm(E.element, ".tox-tree--directory").each((q) => {
            E.getSystem().getByDom(q).each((ne) => {
              !ns.isOn(ne) && F || ns.isOn(ne) && L ? (w(E), O.stop()) : L && !ns.isOn(ne) && (Vm(ne.element, ".tox-tree--directory").each((ae) => {
                Iw(ae, ".tox-tree--directory__label").each((de) => {
                  ne.getSystem().getByDom(de).each(To.focus);
                });
              }), O.stop());
            });
          });
        })])
      ])
    });
  }, Vq = ({ children: t, onLeafAction: r, visible: l, treeId: d, expandedIds: h, selectedId: y, backstage: w }) => ({
    dom: {
      tag: "div",
      classes: ["tox-tree--directory__children"]
    },
    components: t.map((E) => E.type === "leaf" ? zA({
      leaf: E,
      selectedId: y,
      onLeafAction: r,
      visible: l,
      treeId: d,
      backstage: w
    }) : HP({
      directory: E,
      expandedIds: h,
      selectedId: y,
      onLeafAction: r,
      labelTabstopping: l,
      treeId: d,
      backstage: w
    })),
    behaviours: Jt([
      ru.config({
        dimension: { property: "height" },
        closedClass: "tox-tree--directory__children--closed",
        openClass: "tox-tree--directory__children--open",
        growingClass: "tox-tree--directory__children--growing",
        shrinkingClass: "tox-tree--directory__children--shrinking",
        expanded: l
      }),
      Po.config({})
    ])
  }), Uq = Mn("directory-event-id"), HP = ({ directory: t, onLeafAction: r, labelTabstopping: l, treeId: d, backstage: h, expandedIds: y, selectedId: w }) => {
    const { children: E } = t, O = to(y), F = (q) => E.map((ne) => ne.type === "leaf" ? zA({
      leaf: ne,
      selectedId: w,
      onLeafAction: r,
      visible: q,
      treeId: d,
      backstage: h
    }) : HP({
      directory: ne,
      expandedIds: O.get(),
      selectedId: w,
      onLeafAction: r,
      labelTabstopping: q,
      treeId: d,
      backstage: h
    })), L = y.includes(t.id);
    return {
      dom: {
        tag: "div",
        classes: ["tox-tree--directory"],
        attributes: { role: "treeitem" }
      },
      components: [
        zq({
          directory: t,
          visible: l,
          noChildren: t.children.length === 0,
          backstage: h
        }),
        Vq({
          children: E,
          expandedIds: y,
          selectedId: w,
          onLeafAction: r,
          visible: L,
          treeId: d,
          backstage: h
        })
      ],
      behaviours: Jt([
        jo(Uq, [
          qr((q, ne) => {
            ns.set(q, L);
          }),
          Ft("expand-tree-node", (q, ne) => {
            const { expanded: ae, node: de } = ne.event;
            O.set(ae ? [
              ...O.get(),
              de
            ] : O.get().filter((_e) => _e !== de));
          })
        ]),
        ns.config({
          ...t.children.length > 0 ? { aria: { mode: "expanded" } } : {},
          toggleClass: "tox-tree--directory--expanded",
          onToggled: (q, ne) => {
            const ae = q.components()[1], de = F(ne);
            ne ? ru.grow(ae) : ru.shrink(ae), Po.set(ae, de);
          }
        })
      ])
    };
  }, jq = Mn("tree-event-id"), Wq = (t, r) => {
    const l = t.onLeafAction.getOr(U), d = t.onToggleExpand.getOr(U), h = t.defaultExpandedIds, y = to(h), w = to(t.defaultSelectedId), E = Mn("tree-id"), O = (F, L) => t.items.map((q) => q.type === "leaf" ? zA({
      leaf: q,
      selectedId: F,
      onLeafAction: l,
      visible: !0,
      treeId: E,
      backstage: r
    }) : HP({
      directory: q,
      selectedId: F,
      onLeafAction: l,
      expandedIds: L,
      labelTabstopping: !0,
      treeId: E,
      backstage: r
    }));
    return {
      dom: {
        tag: "div",
        classes: ["tox-tree"],
        attributes: { role: "tree" }
      },
      components: O(w.get(), y.get()),
      behaviours: Jt([
        so.config({
          mode: "flow",
          selector: ".tox-tree--leaf__label--visible, .tox-tree--directory__label--visible",
          cycles: !1
        }),
        jo(jq, [Ft("expand-tree-node", (F, L) => {
          const { expanded: q, node: ne } = L.event;
          y.set(q ? [
            ...y.get(),
            ne
          ] : y.get().filter((ae) => ae !== ne)), d(y.get(), {
            expanded: q,
            node: ne
          });
        })]),
        Rc.config({
          channels: {
            [`update-active-item-${E}`]: {
              onReceive: (F, L) => {
                w.set(B.some(L.value)), Po.set(F, O(B.some(L.value), y.get()));
              }
            }
          }
        }),
        Po.config({})
      ])
    };
  };
  var f8 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, r) => {
      const d = t.stream.streams.setup(t, r);
      return zr([
        Ft(t.event, d),
        qf(() => r.cancel())
      ].concat(t.cancelEvent.map((h) => [Ft(h, () => r.cancel())]).getOr([])));
    }
  });
  const m8 = (t) => {
    const r = to(null);
    return qc({
      readState: () => ({ timer: r.get() !== null ? "set" : "unset" }),
      setTimer: (y) => {
        r.set(y);
      },
      cancel: () => {
        const y = r.get();
        y !== null && y.cancel();
      }
    });
  };
  var Zq = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    throttle: m8,
    init: (t) => t.stream.streams.state(t)
  });
  const Gq = (t, r) => {
    const l = t.stream, d = SP(t.onStream, l.delay);
    return r.setTimer(d), (h, y) => {
      d.throttle(h, y), l.stopEvent && y.stop();
    };
  };
  var qq = [
    Ls("stream", ui("mode", {
      throttle: [
        Mt("delay"),
        Xe("stopEvent", !0),
        Ur("streams", {
          setup: Gq,
          state: m8
        })
      ]
    })),
    Xe("event", "input"),
    $s("cancelEvent"),
    Gu("onStream")
  ];
  const zP = Xi({
    fields: qq,
    name: "streaming",
    active: f8,
    state: Zq
  }), VA = (t, r, l) => {
    const d = In.getValue(l);
    In.setValue(r, d), h8(r);
  }, p8 = (t, r) => {
    const l = t.element, d = gt(l), h = l.dom;
    tr(l, "type") !== "number" && r(h, d);
  }, h8 = (t) => {
    p8(t, (r, l) => r.setSelectionRange(l.length, l.length));
  }, Kq = (t, r) => {
    p8(t, (l, d) => l.setSelectionRange(r, d.length));
  }, Yq = (t, r, l) => {
    if (t.selectsOver) {
      const d = In.getValue(r), h = t.getDisplayText(d), y = In.getValue(l);
      return t.getDisplayText(y).indexOf(h) === 0 ? B.some(() => {
        VA(t, r, l), Kq(r, h.length);
      }) : B.none();
    } else
      return B.none();
  }, UA = ee("alloy.typeahead.itemexecute"), Xq = (t, r, l, d) => {
    const h = (q, ne, ae) => {
      t.previewing.set(!1);
      const de = Ia.getCoupled(q, "sandbox");
      if (Ns.isOpen(de))
        Ds.getCurrent(de).each((_e) => {
          yn.getHighlighted(_e).fold(() => {
            ae(_e);
          }, () => {
            Gf(de, _e.element, "keydown", ne);
          });
        });
      else {
        const _e = (st) => {
          Ds.getCurrent(st).each(ae);
        };
        cA(t, w(q), q, de, d, _e, Pc.HighlightMenuAndItem).get(U);
      }
    }, y = nN(t), w = (q) => (ne) => ne.map((ae) => {
      const de = hr(ae.menus), _e = je(de, (Re) => So(Re.items, (Qe) => Qe.type === "item"));
      return In.getState(q).update(et(_e, (Re) => Re.data)), ae;
    }), E = (q) => Ds.getCurrent(q), O = "typeaheadevents", F = [
      To.config({}),
      In.config({
        onSetValue: t.onSetValue,
        store: {
          mode: "dataset",
          getDataKey: (q) => gt(q.element),
          getFallbackEntry: (q) => ({
            value: q,
            meta: {}
          }),
          setValue: (q, ne) => {
            Jf(q.element, t.model.getDisplayText(ne));
          },
          ...t.initialData.map((q) => nr("initialValue", q)).getOr({})
        }
      }),
      zP.config({
        stream: {
          mode: "throttle",
          delay: t.responseTime,
          stopEvent: !1
        },
        onStream: (q, ne) => {
          const ae = Ia.getCoupled(q, "sandbox");
          if (To.isFocused(q) && gt(q.element).length >= t.minChars) {
            const _e = E(ae).bind((Re) => yn.getHighlighted(Re).map(In.getValue));
            t.previewing.set(!0);
            const st = (Re) => {
              E(ae).each((Qe) => {
                _e.fold(() => {
                  t.model.selectsOver && yn.highlightFirst(Qe);
                }, (qe) => {
                  yn.highlightBy(Qe, (Bt) => In.getValue(Bt).value === qe.value), yn.getHighlighted(Qe).orThunk(() => (yn.highlightFirst(Qe), B.none()));
                });
              });
            };
            cA(t, w(q), q, ae, d, st, Pc.HighlightJustMenu).get(U);
          }
        },
        cancelEvent: J2()
      }),
      so.config({
        mode: "special",
        onDown: (q, ne) => (h(q, ne, yn.highlightFirst), B.some(!0)),
        onEscape: (q) => {
          const ne = Ia.getCoupled(q, "sandbox");
          return Ns.isOpen(ne) ? (Ns.close(ne), B.some(!0)) : B.none();
        },
        onUp: (q, ne) => (h(q, ne, yn.highlightLast), B.some(!0)),
        onEnter: (q) => {
          const ne = Ia.getCoupled(q, "sandbox"), ae = Ns.isOpen(ne);
          if (ae && !t.previewing.get())
            return E(ne).bind((de) => yn.getHighlighted(de)).map((de) => (po(q, UA(), { item: de }), !0));
          {
            const de = In.getValue(q);
            return Xo(q, J2()), t.onExecute(ne, q, de), ae && Ns.close(ne), B.some(!0);
          }
        }
      }),
      ns.config({
        toggleClass: t.markers.openClass,
        aria: { mode: "expanded" }
      }),
      Ia.config({
        others: {
          sandbox: (q) => zN(t, q, {
            onOpen: () => ns.on(q),
            onClose: () => {
              t.lazyTypeaheadComp.get().each((ne) => Ee(ne.element, "aria-activedescendant")), ns.off(q);
            }
          })
        }
      }),
      jo(O, [
        qr((q) => {
          t.lazyTypeaheadComp.set(B.some(q));
        }),
        qf((q) => {
          t.lazyTypeaheadComp.set(B.none());
        }),
        Td((q) => {
          const ne = U;
          $N(t, w(q), q, d, ne, Pc.HighlightMenuAndItem).get(U);
        }),
        Ft(UA(), (q, ne) => {
          const ae = Ia.getCoupled(q, "sandbox");
          VA(t.model, q, ne.event.item), Xo(q, J2()), t.onItemExecute(q, ae, ne.event.item, In.getValue(q)), Ns.close(ae), h8(q);
        })
      ].concat(t.dismissOnBlur ? [Ft(Bp(), (q) => {
        const ne = Ia.getCoupled(q, "sandbox");
        cc(ne.element).isNone() && Ns.close(ne);
      })] : []))
    ], L = {
      [Zu()]: [
        In.name(),
        zP.name(),
        O
      ],
      ...t.eventOrder
    };
    return {
      uid: t.uid,
      dom: oN(Pr(t, {
        inputAttributes: {
          role: "combobox",
          "aria-autocomplete": "list",
          "aria-haspopup": "true"
        }
      })),
      behaviours: {
        ...y,
        ...Hi(t.typeaheadBehaviours, F)
      },
      eventOrder: L
    };
  }, Qq = ee([
    $s("lazySink"),
    Mt("fetch"),
    Xe("minChars", 5),
    Xe("responseTime", 1e3),
    Os("onOpen"),
    Xe("getHotspot", B.some),
    Xe("getAnchorOverrides", ee({})),
    Xe("layouts", B.none()),
    Xe("eventOrder", {}),
    te("model", {}, [
      Xe("getDisplayText", (t) => t.meta !== void 0 && t.meta.text !== void 0 ? t.meta.text : t.value),
      Xe("selectsOver", !0),
      Xe("populateFromBrowse", !0)
    ]),
    Os("onSetValue"),
    ic("onExecute"),
    Os("onItemExecute"),
    Xe("inputClasses", []),
    Xe("inputAttributes", {}),
    Xe("inputStyles", {}),
    Xe("matchWidth", !0),
    Xe("useMinWidth", !1),
    Xe("dismissOnBlur", !0),
    Xf(["openClass"]),
    $s("initialData"),
    $s("listRole"),
    $i("typeaheadBehaviours", [
      To,
      In,
      zP,
      so,
      ns,
      Ia
    ]),
    Vs("lazyTypeaheadComp", () => to(B.none)),
    Vs("previewing", () => to(!0))
  ].concat(tN()).concat(uA())), Jq = ee([Xu({
    schema: [pg()],
    name: "menu",
    overrides: (t) => ({
      fakeFocus: !0,
      onHighlightItem: (r, l, d) => {
        t.previewing.get() ? t.lazyTypeaheadComp.get().each((h) => {
          Yq(t.model, h, d).fold(() => {
            t.model.selectsOver ? (yn.dehighlight(l, d), t.previewing.set(!0)) : t.previewing.set(!1);
          }, (y) => {
            y(), t.previewing.set(!1);
          });
        }) : t.lazyTypeaheadComp.get().each((h) => {
          t.model.populateFromBrowse && VA(t.model, h, d), Y(d.element, "id").each((y) => sn(h.element, "aria-activedescendant", y));
        });
      },
      onExecute: (r, l) => t.lazyTypeaheadComp.get().map((d) => (po(d, UA(), { item: l }), !0)),
      onHover: (r, l) => {
        t.previewing.set(!1), t.lazyTypeaheadComp.get().each((d) => {
          t.model.populateFromBrowse && VA(t.model, d, l);
        });
      }
    })
  })]), eK = Wl({
    name: "Typeahead",
    configFields: Qq(),
    partFields: Jq(),
    factory: Xq
  }), hm = (t) => ({
    ...t,
    toCached: () => hm(t.toCached()),
    bindFuture: (O) => hm(t.bind((F) => F.fold((L) => Zl.pure(Ho.error(L)), (L) => O(L)))),
    bindResult: (O) => hm(t.map((F) => F.bind(O))),
    mapResult: (O) => hm(t.map((F) => F.map(O))),
    mapError: (O) => hm(t.map((F) => F.mapError(O))),
    foldResult: (O, F) => t.map((L) => L.fold(O, F)),
    withTimeout: (O, F) => hm(Zl.nu((L) => {
      let q = !1;
      const ne = setTimeout(() => {
        q = !0, L(Ho.error(F()));
      }, O);
      t.get((ae) => {
        q || (clearTimeout(ne), L(ae));
      });
    }))
  }), g8 = (t) => hm(Zl.nu(t)), VP = (t) => hm(Zl.pure(Ho.value(t))), v8 = {
    nu: g8,
    wrap: hm,
    pure: VP,
    value: VP,
    error: (t) => hm(Zl.pure(Ho.error(t))),
    fromResult: (t) => hm(Zl.pure(t)),
    fromFuture: (t) => hm(t.map(Ho.value)),
    fromPromise: (t) => g8((r) => {
      t.then((l) => {
        r(Ho.value(l));
      }, (l) => {
        r(Ho.error(l));
      });
    })
  }, e2 = (t, r, l = [], d, h, y, w) => {
    const E = r.fold(() => ({}), (L) => ({ action: L })), O = {
      buttonBehaviours: Jt([
        dm.button(() => !t.enabled || w.isDisabled()),
        ki(),
        jr.config({}),
        ...y.map((L) => gl.config(w.tooltips.getConfig({ tooltipText: w.translate(L) }))).toArray(),
        jo("button press", [
          ey("click"),
          ey("mousedown")
        ])
      ].concat(l)),
      eventOrder: {
        click: [
          "button press",
          "alloy.base.behaviour"
        ],
        mousedown: [
          "button press",
          "alloy.base.behaviour"
        ]
      },
      ...E
    }, F = Pr(O, { dom: d });
    return Pr(F, { components: h });
  }, oK = (t, r, l, d = [], h) => {
    const y = t.tooltip.map((F) => ({ "aria-label": l.translate(F) })).getOr({}), w = {
      tag: "button",
      classes: ["tox-tbtn"],
      attributes: {
        ...y,
        "data-mce-name": h
      }
    }, E = t.icon.map((F) => DP(F, l.icons)), O = e0([E]);
    return e2(t, r, d, w, O, t.tooltip, l);
  }, jA = (t) => {
    switch (t) {
      case "primary":
        return ["tox-button"];
      case "toolbar":
        return ["tox-tbtn"];
      case "secondary":
      default:
        return [
          "tox-button",
          "tox-button--secondary"
        ];
    }
  }, UP = (t, r, l, d = [], h = []) => {
    const y = l.translate(t.text), w = t.icon.map((ae) => DP(ae, l.icons)), E = [w.getOrThunk(() => Aa(y))], O = t.buttonType.getOr(!t.primary && !t.borderless ? "secondary" : "primary"), q = {
      tag: "button",
      classes: [
        ...jA(O),
        ...w.isSome() ? ["tox-button--icon"] : [],
        ...t.borderless ? ["tox-button--naked"] : [],
        ...h
      ],
      attributes: {
        "aria-label": y,
        "data-mce-name": t.text
      }
    }, ne = t.icon.map(ee(y));
    return e2(t, r, d, q, E, ne, l);
  }, b8 = (t, r, l, d = [], h = []) => {
    const y = UP(t, B.some(r), l, d, h);
    return Nl.sketch(y);
  }, jP = (t, r) => (l) => {
    r === "custom" ? po(l, yh, {
      name: t,
      value: {}
    }) : r === "submit" ? Xo(l, Ux) : r === "cancel" ? Xo(l, yb) : console.error("Unknown button type: ", r);
  }, sK = (t, r) => r === "menu", rK = (t, r) => r === "custom" || r === "cancel" || r === "submit", rp = (t, r) => r === "togglebutton", WA = (t, r, l) => {
    var d, h;
    const y = t.icon.map((qe) => Zg(qe, r.icons)).map(rr), w = (qe) => {
      po(qe, yh, {
        name: t.name,
        value: {
          setIcon: (Bt) => {
            y.map((pt) => pt.getOpt(qe).each((en) => {
              Po.set(en, [Zg(Bt, r.icons)]);
            }));
          }
        }
      });
    }, E = t.buttonType.getOr(t.primary ? "primary" : "secondary"), O = {
      ...t,
      name: (d = t.name) !== null && d !== void 0 ? d : "",
      primary: E === "primary",
      tooltip: t.tooltip,
      enabled: (h = t.enabled) !== null && h !== void 0 ? h : !1,
      borderless: !1
    }, F = O.tooltip.or(t.text).map((qe) => ({ "aria-label": r.translate(qe) })).getOr({}), L = jA(E ?? "secondary"), q = t.icon.isSome() && t.text.isSome(), ne = {
      tag: "button",
      classes: [
        ...L.concat(t.icon.isSome() ? ["tox-button--icon"] : []),
        ...t.active ? ["tox-button--enabled"] : [],
        ...q ? ["tox-button--icon-and-text"] : []
      ],
      attributes: {
        ...F,
        ...be(l) ? { "data-mce-name": l } : {}
      }
    }, ae = [], de = r.translate(t.text.getOr("")), _e = Aa(de), Re = [
      ...e0([y.map((qe) => qe.asSpec())]),
      ...t.text.isSome() ? [_e] : []
    ], Qe = e2(O, B.some(w), ae, ne, Re, t.tooltip, r);
    return Nl.sketch(Qe);
  }, g0 = (t, r, l) => {
    if (sK(t, r)) {
      const d = () => w, h = t, y = {
        ...t,
        type: "menubutton",
        search: B.none(),
        onSetup: (E) => (E.setEnabled(t.enabled), U),
        fetch: Lq(h.items, d, l)
      }, w = rr(GS(y, "tox-tbtn", l, B.none(), !0, t.text.or(t.tooltip).getOrUndefined()));
      return w.asSpec();
    } else if (rK(t, r)) {
      const d = jP(t.name, r), h = {
        ...t,
        borderless: !1
      };
      return b8(h, d, l.shared.providers, []);
    } else {
      if (rp(t, r))
        return WA(t, l.shared.providers, t.text.or(t.tooltip).getOrUndefined());
      throw console.error("Unknown footer button type: ", r), new Error("Unknown footer button type");
    }
  }, aK = (t, r) => {
    const l = jP(t.name, "custom");
    return eG(B.none(), fr.parts.field({
      factory: Nl,
      ...UP(t, B.some(l), r, [
        DA(""),
        sd.self()
      ])
    }));
  }, WP = { type: "separator" }, iK = (t) => ({
    type: "menuitem",
    value: t.url,
    text: t.title,
    meta: { attach: t.attach },
    onAction: U
  }), qS = (t, r) => ({
    type: "menuitem",
    value: r,
    text: t,
    meta: { attach: void 0 },
    onAction: U
  }), y8 = (t) => et(t, iK), ZP = (t, r) => So(r, (l) => l.type === t), x8 = (t, r) => y8(ZP(t, r)), lK = (t) => x8("header", t.targets), w8 = (t) => x8("anchor", t.targets), cK = (t) => B.from(t.anchorTop).map((r) => qS("<top>", r)).toArray(), uK = (t) => B.from(t.anchorBottom).map((r) => qS("<bottom>", r)).toArray(), GP = (t) => et(t, (r) => qS(r, r)), dK = (t) => Pt(t, (r, l) => r.length === 0 || l.length === 0 ? r.concat(l) : r.concat(WP, l), []), qP = (t, r) => {
    const l = t.toLowerCase();
    return So(r, (d) => {
      var h;
      const y = d.meta !== void 0 && d.meta.text !== void 0 ? d.meta.text : d.text, w = (h = d.value) !== null && h !== void 0 ? h : "";
      return Ao(y.toLowerCase(), l) || Ao(w.toLowerCase(), l);
    });
  }, C8 = (t, r, l) => {
    var d, h;
    const y = In.getValue(r), w = (h = (d = y == null ? void 0 : y.meta) === null || d === void 0 ? void 0 : d.text) !== null && h !== void 0 ? h : y.value;
    return l.getLinkInformation().fold(() => [], (O) => {
      const F = qP(w, GP(l.getHistory(t)));
      return t === "file" ? dK([
        F,
        qP(w, lK(O)),
        qP(w, tn([
          cK(O),
          w8(O),
          uK(O)
        ]))
      ]) : F;
    });
  }, KP = Mn("aria-invalid"), fK = (t, r, l, d) => {
    const h = r.shared.providers, y = (Qe) => {
      const qe = In.getValue(Qe);
      l.addToHistory(qe.value, t.filetype);
    }, w = {
      ...d.map((Qe) => ({ initialData: Qe })).getOr({}),
      dismissOnBlur: !0,
      inputClasses: ["tox-textfield"],
      sandboxClasses: ["tox-dialog__popups"],
      inputAttributes: {
        "aria-errormessage": KP,
        type: "url"
      },
      minChars: 0,
      responseTime: 0,
      fetch: (Qe) => {
        const qe = C8(t.filetype, Qe, l), Bt = Qx(qe, im.BUBBLE_TO_SANDBOX, r, {
          isHorizontalMenu: !1,
          search: B.none()
        });
        return Zl.pure(Bt);
      },
      getHotspot: (Qe) => de.getOpt(Qe),
      onSetValue: (Qe, qe) => {
        Qe.hasConfigured(xh) && xh.run(Qe).get(U);
      },
      typeaheadBehaviours: Jt([
        ...l.getValidationHandler().map((Qe) => xh.config({
          getRoot: (qe) => ji(qe.element),
          invalidClass: "tox-control-wrap--status-invalid",
          notify: {
            onInvalid: (qe, Bt) => {
              L.getOpt(qe).each((pt) => {
                sn(pt.element, "title", h.translate(Bt));
              });
            }
          },
          validator: {
            validate: (qe) => {
              const Bt = In.getValue(qe);
              return v8.nu((pt) => {
                Qe({
                  type: t.filetype,
                  url: Bt.value
                }, (en) => {
                  if (en.status === "invalid") {
                    const bn = Ho.error(en.message);
                    pt(bn);
                  } else {
                    const bn = Ho.value(en.message);
                    pt(bn);
                  }
                });
              });
            },
            validateOnLoad: !1
          }
        })).toArray(),
        _o.config({ disabled: () => !t.enabled || h.isDisabled() }),
        jr.config({}),
        jo("urlinput-events", [
          Ft(Zf(), (Qe) => {
            const qe = gt(Qe.element), Bt = qe.trim();
            Bt !== qe && Jf(Qe.element, Bt), t.filetype === "file" && po(Qe, _u, { name: t.name });
          }),
          Ft(kv(), (Qe) => {
            po(Qe, _u, { name: t.name }), y(Qe);
          }),
          Ft(Bm(), (Qe) => {
            po(Qe, _u, { name: t.name }), y(Qe);
          })
        ])
      ]),
      eventOrder: {
        [Zf()]: [
          "streaming",
          "urlinput-events",
          "invalidating"
        ]
      },
      model: {
        getDisplayText: (Qe) => Qe.value,
        selectsOver: !1,
        populateFromBrowse: !1
      },
      markers: { openClass: "tox-textfield--popup-open" },
      lazySink: r.shared.getSink,
      parts: { menu: pS(!1, 1, "normal") },
      onExecute: (Qe, qe, Bt) => {
        po(qe, Ux, {});
      },
      onItemExecute: (Qe, qe, Bt, pt) => {
        y(Qe), po(Qe, _u, { name: t.name });
      }
    }, E = fr.parts.field({
      ...w,
      factory: eK
    }), O = t.label.map((Qe) => bb(Qe, h)), L = rr(((Qe, qe, Bt = Qe, pt = Qe) => ku(Bt, {
      tag: "div",
      classes: [
        "tox-icon",
        "tox-control-wrap__status-icon-" + Qe
      ],
      attributes: {
        title: h.translate(pt),
        "aria-live": "polite",
        ...qe.fold(() => ({}), (en) => ({ id: en }))
      }
    }, h.icons))("invalid", B.some(KP), "warning")), q = rr({
      dom: {
        tag: "div",
        classes: ["tox-control-wrap__status-icon-wrap"]
      },
      components: [L.asSpec()]
    }), ne = l.getUrlPicker(t.filetype), ae = Mn("browser.url.event"), de = rr({
      dom: {
        tag: "div",
        classes: ["tox-control-wrap"]
      },
      components: [
        E,
        q.asSpec()
      ],
      behaviours: Jt([_o.config({ disabled: () => !t.enabled || h.isDisabled() })])
    }), _e = rr(b8({
      name: t.name,
      icon: B.some("browse"),
      text: t.picker_text.or(t.label).getOr(""),
      enabled: t.enabled,
      primary: !1,
      buttonType: B.none(),
      borderless: !0
    }, (Qe) => Xo(Qe, ae), h, [], ["tox-browse-url"])), st = () => ({
      dom: {
        tag: "div",
        classes: ["tox-form__controls-h-stack"]
      },
      components: tn([
        [de.asSpec()],
        ne.map(() => _e.asSpec()).toArray()
      ])
    }), Re = (Qe) => {
      Ds.getCurrent(Qe).each((qe) => {
        const Bt = In.getValue(qe), pt = {
          fieldname: t.name,
          ...Bt
        };
        ne.each((en) => {
          en(pt).get((bn) => {
            In.setValue(qe, bn), po(Qe, _u, { name: t.name });
          });
        });
      });
    };
    return fr.sketch({
      dom: nG(),
      components: O.toArray().concat([st()]),
      fieldBehaviours: Jt([
        _o.config({
          disabled: () => !t.enabled || h.isDisabled(),
          onDisabled: (Qe) => {
            fr.getField(Qe).each(_o.disable), _e.getOpt(Qe).each(_o.disable);
          },
          onEnabled: (Qe) => {
            fr.getField(Qe).each(_o.enable), _e.getOpt(Qe).each(_o.enable);
          }
        }),
        ki(),
        jo("url-input-events", [Ft(ae, Re)])
      ])
    });
  }, mK = (t, r) => {
    const l = VB(t.icon, r.icons);
    return op.sketch({
      dom: {
        tag: "div",
        attributes: { role: "alert" },
        classes: [
          "tox-notification",
          "tox-notification--in",
          `tox-notification--${t.level}`
        ]
      },
      components: [
        {
          dom: {
            tag: "div",
            classes: ["tox-notification__icon"],
            innerHtml: t.url ? void 0 : l
          },
          components: t.url ? [Nl.sketch({
            dom: {
              tag: "button",
              classes: [
                "tox-button",
                "tox-button--naked",
                "tox-button--icon"
              ],
              innerHtml: l,
              attributes: { title: r.translate(t.iconTooltip) }
            },
            action: (d) => po(d, yh, {
              name: "alert-banner",
              value: t.url
            }),
            buttonBehaviours: Jt([ZR()])
          })] : void 0
        },
        {
          dom: {
            tag: "div",
            classes: ["tox-notification__body"],
            innerHtml: r.translate(t.text)
          }
        }
      ]
    });
  }, pK = (t, r) => {
    t.dom.checked = r;
  }, hK = (t) => t.dom.checked, S8 = (t, r, l) => {
    const d = (O) => (O.element.dom.click(), B.some(!0)), h = fr.parts.field({
      factory: { sketch: lt },
      dom: {
        tag: "input",
        classes: ["tox-checkbox__input"],
        attributes: { type: "checkbox" }
      },
      behaviours: Jt([
        sd.self(),
        _o.config({
          disabled: () => !t.enabled || r.isDisabled(),
          onDisabled: (O) => {
            ji(O.element).each((F) => Vr(F, "tox-checkbox--disabled"));
          },
          onEnabled: (O) => {
            ji(O.element).each((F) => ba(F, "tox-checkbox--disabled"));
          }
        }),
        jr.config({}),
        To.config({}),
        k$(l, hK, pK),
        so.config({
          mode: "special",
          onEnter: d,
          onSpace: d,
          stopSpaceKeyup: !0
        }),
        jo("checkbox-events", [Ft(kv(), (O, F) => {
          po(O, _u, { name: t.name });
        })])
      ])
    }), y = fr.parts.label({
      dom: {
        tag: "span",
        classes: ["tox-checkbox__label"]
      },
      components: [Aa(r.translate(t.label))],
      behaviours: Jt([jx.config({})])
    }), w = (O) => ku(O === "checked" ? "selected" : "unselected", {
      tag: "span",
      classes: [
        "tox-icon",
        "tox-checkbox-icon__" + O
      ]
    }, r.icons), E = rr({
      dom: {
        tag: "div",
        classes: ["tox-checkbox__icons"]
      },
      components: [
        w("checked"),
        w("unchecked")
      ]
    });
    return fr.sketch({
      dom: {
        tag: "label",
        classes: ["tox-checkbox"]
      },
      components: [
        h,
        E.asSpec(),
        y
      ],
      fieldBehaviours: Jt([
        _o.config({ disabled: () => !t.enabled || r.isDisabled() }),
        ki()
      ])
    });
  }, ap = (t, r) => {
    const l = [
      "tox-form__group",
      ...t.stretched ? ["tox-form__group--stretched"] : []
    ], d = jo("htmlpanel", [qr((h) => {
      t.onInit(h.element.dom);
    })]);
    return t.presets === "presentation" ? op.sketch({
      dom: {
        tag: "div",
        classes: l,
        innerHtml: t.html
      },
      containerBehaviours: Jt([
        gl.config({
          ...r.tooltips.getConfig({
            tooltipText: "",
            onShow: (h) => {
              or(h.element, "[data-mce-tooltip]:hover").orThunk(() => cc(h.element)).each((y) => {
                Y(y, "data-mce-tooltip").each((w) => {
                  gl.setComponents(h, r.tooltips.getComponents({ tooltipText: w }));
                });
              });
            }
          }),
          mode: "children-normal",
          anchor: (h) => ({
            type: "node",
            node: or(h.element, "[data-mce-tooltip]:hover").orThunk(() => cc(h.element).filter((y) => Y(y, "data-mce-tooltip").isSome())),
            root: h.element,
            layouts: {
              onLtr: ee([
                ti,
                Si,
                fi,
                mi,
                ei,
                br
              ]),
              onRtl: ee([
                ti,
                Si,
                fi,
                mi,
                ei,
                br
              ])
            },
            bubble: Od(0, -2, {})
          })
        }),
        d
      ])
    }) : op.sketch({
      dom: {
        tag: "div",
        classes: l,
        innerHtml: t.html,
        attributes: { role: "document" }
      },
      containerBehaviours: Jt([
        jr.config({}),
        To.config({}),
        d
      ])
    });
  }, pi = (t) => (r, l, d, h, y) => qt(l, "name").fold(() => t(l, h, B.none(), y), (w) => r.field(w, t(l, h, qt(d, w), y))), gK = (t) => (r, l, d, h, y) => {
    const w = Pr(l, { source: "dynamic" });
    return pi(t)(r, w, d, h, y);
  }, vK = {
    bar: pi((t, r) => pA(t, r.shared)),
    collection: pi((t, r, l) => oG(t, r.shared.providers, l)),
    alertbanner: pi((t, r) => mK(t, r.shared.providers)),
    input: pi((t, r, l) => Dq(t, r.shared.providers, l)),
    textarea: pi((t, r, l) => Q$(t, r.shared.providers, l)),
    label: pi((t, r, l, d) => pq(t, r.shared, d)),
    iframe: gK((t, r, l) => dq(t, r.shared.providers, l)),
    button: pi((t, r) => aK(t, r.shared.providers)),
    checkbox: pi((t, r, l) => S8(t, r.shared.providers, l)),
    colorinput: pi((t, r, l) => $6(t, r.shared, r.colorinput, l)),
    colorpicker: pi((t, r, l) => E$(t, r.shared.providers, l)),
    dropzone: pi((t, r, l) => oq(t, r.shared.providers, l)),
    grid: pi((t, r) => A$(t, r.shared)),
    listbox: pi((t, r, l) => xq(t, r, l)),
    selectbox: pi((t, r, l) => Cq(t, r.shared.providers, l)),
    sizeinput: pi((t, r) => Aq(t, r.shared.providers)),
    slider: pi((t, r, l) => Y$(t, r.shared.providers, l)),
    urlinput: pi((t, r, l) => fK(t, r, r.urlinput, l)),
    customeditor: pi(tq),
    htmlpanel: pi((t, r) => ap(t, r.shared.providers)),
    imagepreview: pi((t, r, l) => AP(t, l)),
    table: pi((t, r) => Oq(t, r.shared.providers)),
    tree: pi((t, r) => Wq(t, r)),
    panel: pi((t, r) => IP(t, r))
  }, bK = {
    field: (t, r) => r,
    record: ee([])
  }, k8 = (t, r, l, d, h) => {
    const y = Pr(d, { shared: { interpreter: (w) => YP(t, w, l, y, h) } });
    return YP(t, r, l, y, h);
  }, YP = (t, r, l, d, h) => qt(vK, r.type).fold(() => (console.error(`Unknown factory type "${r.type}", defaulting to container: `, r), r), (y) => y(t, r, l, d, h)), XP = (t, r, l, d) => YP(bK, t, r, l, d), Gg = "layout-inset", _8 = (t) => t.x, yK = (t, r) => t.x + t.width / 2 - r.width / 2, vl = (t, r) => t.x + t.width - r.width, KS = (t) => t.y, QP = (t, r) => t.y + t.height - r.height, YS = (t, r) => t.y + t.height / 2 - r.height / 2, ZA = (t, r, l) => Ji(vl(t, r), QP(t, r), l.insetSouthwest(), $w(), "southwest", el(t, {
    right: 0,
    bottom: 3
  }), Gg), GA = (t, r, l) => Ji(_8(t), QP(t, r), l.insetSoutheast(), Lw(), "southeast", el(t, {
    left: 1,
    bottom: 3
  }), Gg), XS = (t, r, l) => Ji(vl(t, r), KS(t), l.insetNorthwest(), Bw(), "northwest", el(t, {
    right: 0,
    top: 2
  }), Gg), QS = (t, r, l) => Ji(_8(t), KS(t), l.insetNortheast(), Vv(), "northeast", el(t, {
    left: 1,
    top: 2
  }), Gg), gm = (t, r, l) => Ji(yK(t, r), KS(t), l.insetNorth(), Hw(), "north", el(t, { top: 2 }), Gg), JS = (t, r, l) => Ji(yK(t, r), QP(t, r), l.insetSouth(), Bn(), "south", el(t, { bottom: 3 }), Gg), E8 = (t, r, l) => Ji(vl(t, r), YS(t, r), l.insetEast(), zw(), "east", el(t, { right: 0 }), Gg), T8 = (t, r, l) => Ji(_8(t), YS(t, r), l.insetWest(), p1(), "west", el(t, { left: 1 }), Gg), A8 = (t) => {
    switch (t) {
      case "north":
        return gm;
      case "northeast":
        return QS;
      case "northwest":
        return XS;
      case "south":
        return JS;
      case "southeast":
        return GA;
      case "southwest":
        return ZA;
      case "east":
        return E8;
      case "west":
        return T8;
    }
  }, ek = (t, r, l, d, h) => X_(d).map(A8).getOr(gm)(t, r, l, d, h), O8 = (t) => {
    switch (t) {
      case "north":
        return JS;
      case "northeast":
        return GA;
      case "northwest":
        return ZA;
      case "south":
        return gm;
      case "southeast":
        return QS;
      case "southwest":
        return XS;
      case "east":
        return T8;
      case "west":
        return E8;
    }
  }, D8 = (t, r, l, d, h) => X_(d).map(O8).getOr(gm)(t, r, l, d, h), tk = {
    valignCentre: [],
    alignCentre: [],
    alignLeft: [],
    alignRight: [],
    right: [],
    left: [],
    bottom: [],
    top: []
  }, R8 = (t, r, l) => {
    const h = { maxHeightFunction: jv() }, y = () => ({
      type: "node",
      root: Oe(ie(t())),
      node: B.from(t()),
      bubble: Od(12, 12, tk),
      layouts: {
        onRtl: () => [QS],
        onLtr: () => [XS]
      },
      overrides: h
    }), w = () => ({
      type: "hotspot",
      hotspot: r(),
      bubble: Od(-12, 12, tk),
      layouts: {
        onRtl: () => [
          fi,
          ei,
          ti
        ],
        onLtr: () => [
          ei,
          fi,
          ti
        ]
      },
      overrides: h
    });
    return () => l() ? y() : w();
  }, xK = (t, r, l, d) => {
    const y = { maxHeightFunction: jv() }, w = () => ({
      type: "node",
      root: Oe(ie(r())),
      node: B.from(r()),
      bubble: Od(12, 12, tk),
      layouts: {
        onRtl: () => [gm],
        onLtr: () => [gm]
      },
      overrides: y
    }), E = () => t ? {
      type: "node",
      root: Oe(ie(r())),
      node: B.from(r()),
      bubble: Od(0, -pd(r()), tk),
      layouts: {
        onRtl: () => [Si],
        onLtr: () => [Si]
      },
      overrides: y
    } : {
      type: "hotspot",
      hotspot: l(),
      bubble: Od(0, 0, tk),
      layouts: {
        onRtl: () => [Si],
        onLtr: () => [Si]
      },
      overrides: y
    };
    return () => d() ? w() : E();
  }, wK = (t, r, l) => {
    const d = () => ({
      type: "node",
      root: Oe(ie(t())),
      node: B.from(t()),
      layouts: {
        onRtl: () => [gm],
        onLtr: () => [gm]
      }
    }), h = () => ({
      type: "hotspot",
      hotspot: r(),
      layouts: {
        onRtl: () => [ti],
        onLtr: () => [ti]
      }
    });
    return () => l() ? d() : h();
  }, N8 = (t, r) => () => ({
    type: "selection",
    root: r(),
    getSelection: () => {
      const l = t.selection.getRng(), d = t.model.table.getSelectedCells();
      if (d.length > 1) {
        const h = d[0], y = d[d.length - 1], w = {
          firstCell: $e.fromDom(h),
          lastCell: $e.fromDom(y)
        };
        return B.some(w);
      }
      return B.some(qv.range($e.fromDom(l.startContainer), l.startOffset, $e.fromDom(l.endContainer), l.endOffset));
    }
  }), eae = (t) => (r) => ({
    type: "node",
    root: t(),
    node: r
  }), tae = (t, r, l, d) => {
    const h = Ax(t), y = () => $e.fromDom(t.getBody()), w = () => $e.fromDom(t.getContentAreaContainer()), E = () => h || !d();
    return {
      inlineDialog: R8(w, r, E),
      inlineBottomDialog: xK(t.inline, w, l, E),
      banner: wK(w, r, E),
      cursor: N8(t, y),
      node: eae(y)
    };
  }, CK = (t) => (r, l) => {
    c6(t)(r, l);
  }, SK = (t) => () => e6(t), kK = (t) => (r) => iA(t, r), P8 = (t) => (r) => JL(t, r), JP = (t) => ({
    colorPicker: CK(t),
    hasCustomColors: SK(t),
    getColors: kK(t),
    getColorCols: P8(t)
  }), _K = (t) => () => SB(t), EK = (t) => ({ isDraggableModal: _K(t) }), M8 = (t) => {
    const r = to(Lg(t) ? "bottom" : "top");
    return {
      isPositionedAtTop: () => r.get() === "top",
      getDockingMode: r.get,
      setDockingMode: r.set
    };
  }, I8 = (t) => Lr(t, "items"), F8 = (t) => Lr(t, "format"), B8 = [
    {
      title: "Headings",
      items: [
        {
          title: "Heading 1",
          format: "h1"
        },
        {
          title: "Heading 2",
          format: "h2"
        },
        {
          title: "Heading 3",
          format: "h3"
        },
        {
          title: "Heading 4",
          format: "h4"
        },
        {
          title: "Heading 5",
          format: "h5"
        },
        {
          title: "Heading 6",
          format: "h6"
        }
      ]
    },
    {
      title: "Inline",
      items: [
        {
          title: "Bold",
          format: "bold"
        },
        {
          title: "Italic",
          format: "italic"
        },
        {
          title: "Underline",
          format: "underline"
        },
        {
          title: "Strikethrough",
          format: "strikethrough"
        },
        {
          title: "Superscript",
          format: "superscript"
        },
        {
          title: "Subscript",
          format: "subscript"
        },
        {
          title: "Code",
          format: "code"
        }
      ]
    },
    {
      title: "Blocks",
      items: [
        {
          title: "Paragraph",
          format: "p"
        },
        {
          title: "Blockquote",
          format: "blockquote"
        },
        {
          title: "Div",
          format: "div"
        },
        {
          title: "Pre",
          format: "pre"
        }
      ]
    },
    {
      title: "Align",
      items: [
        {
          title: "Left",
          format: "alignleft"
        },
        {
          title: "Center",
          format: "aligncenter"
        },
        {
          title: "Right",
          format: "alignright"
        },
        {
          title: "Justify",
          format: "alignjustify"
        }
      ]
    }
  ], TK = (t) => Ko(t, "items"), eM = (t) => Ko(t, "block"), L8 = (t) => Ko(t, "inline"), AK = (t) => Ko(t, "selector"), $8 = (t) => Pt(t, (r, l) => {
    if (TK(l)) {
      const d = $8(l.items);
      return {
        customFormats: r.customFormats.concat(d.customFormats),
        formats: r.formats.concat([{
          title: l.title,
          items: d.formats
        }])
      };
    } else if (L8(l) || eM(l) || AK(l)) {
      const h = `custom-${A(l.name) ? l.name : l.title.toLowerCase()}`;
      return {
        customFormats: r.customFormats.concat([{
          name: h,
          format: l
        }]),
        formats: r.formats.concat([{
          title: l.title,
          format: h,
          icon: l.icon
        }])
      };
    } else
      return {
        ...r,
        formats: r.formats.concat(l)
      };
  }, {
    customFormats: [],
    formats: []
  }), OK = (t, r) => {
    const l = $8(r), d = (h) => {
      xt(h, (y) => {
        t.formatter.has(y.name) || t.formatter.register(y.name, y.format);
      });
    };
    return t.formatter ? d(l.customFormats) : t.on("init", () => {
      d(l.customFormats);
    }), l.formats;
  }, H8 = (t) => pB(t).map((r) => {
    const l = OK(t, r);
    return hB(t) ? B8.concat(l) : l;
  }).getOr(B8), z8 = (t) => {
    const r = os(t);
    return r.length === 1 && pn(r, "title");
  }, V8 = (t, r, l) => ({
    ...t,
    type: "formatter",
    isSelected: r(t.format),
    getStylePreview: l(t.format)
  }), nk = (t, r, l, d) => {
    const h = (O) => V8(O, l, d), y = (O) => {
      const F = E(O.items);
      return {
        ...O,
        type: "submenu",
        getStyleItems: ee(F)
      };
    }, w = (O) => {
      const F = A(O.name) ? O.name : Mn(O.title), L = `custom-${F}`, q = {
        ...O,
        type: "formatter",
        format: L,
        isSelected: l(L),
        getStylePreview: d(L)
      };
      return t.formatter.register(F, q), q;
    }, E = (O) => et(O, (F) => I8(F) ? y(F) : F8(F) ? h(F) : z8(F) ? {
      ...F,
      type: "separator"
    } : w(F));
    return E(r);
  }, DK = (t) => {
    const r = (E) => () => t.formatter.match(E), l = (E) => () => {
      const O = t.formatter.get(E);
      return O !== void 0 ? B.some({
        tag: O.length > 0 && (O[0].inline || O[0].block) || "div",
        styles: t.dom.parseStyle(t.formatter.getCssText(E))
      }) : B.none();
    }, d = to([]), h = to([]), y = to(!1);
    return t.on("PreInit", (E) => {
      const O = H8(t), F = nk(t, O, r, l);
      d.set(F);
    }), t.on("addStyleModifications", (E) => {
      const O = nk(t, E.items, r, l);
      h.set(O), y.set(E.replace);
    }), { getData: () => {
      const E = y.get() ? [] : d.get(), O = h.get();
      return E.concat(O);
    } };
  }, qA = (t) => {
    let d = 0;
    const h = () => d > 0, y = (E) => [{
      dom: {
        tag: "div",
        classes: ["tox-tooltip__body"]
      },
      components: [Aa(E.tooltipText)]
    }];
    return {
      getConfig: (E) => ({
        delayForShow: () => h() ? 60 : 300,
        delayForHide: ee(300),
        exclusive: !0,
        lazySink: t,
        tooltipDom: {
          tag: "div",
          classes: [
            "tox-tooltip",
            "tox-tooltip--up"
          ]
        },
        tooltipComponents: y(E),
        onShow: (O, F) => {
          d++, E.onShow && E.onShow(O, F);
        },
        onHide: (O, F) => {
          d--, E.onHide && E.onHide(O, F);
        }
      }),
      getComponents: y
    };
  }, RK = (t) => be(t) && t.nodeType === 1, tM = pm.trim, t2 = (t) => (r) => !!(RK(r) && (r.contentEditable === t || r.getAttribute("data-mce-contenteditable") === t)), U8 = t2("true"), NK = t2("false"), nM = (t, r, l, d, h) => ({
    type: t,
    title: r,
    url: l,
    level: d,
    attach: h
  }), j8 = (t) => {
    let r = t;
    for (; r = r.parentNode; ) {
      const l = r.contentEditable;
      if (l && l !== "inherit")
        return U8(r);
    }
    return !1;
  }, W8 = (t, r) => et(Rl($e.fromDom(r), t), (l) => l.dom), Z8 = (t) => t.innerText || t.textContent, oM = (t) => t.id ? t.id : Mn("h"), KA = (t) => t && t.nodeName === "A" && (t.id || t.name) !== void 0, PK = (t) => KA(t) && v0(t), G8 = (t) => t && /^(H[1-6])$/.test(t.nodeName), v0 = (t) => j8(t) && !NK(t), q8 = (t) => G8(t) && v0(t), MK = (t) => G8(t) ? parseInt(t.nodeName.substr(1), 10) : 0, K8 = (t) => {
    var r;
    const l = oM(t), d = () => {
      t.id = l;
    };
    return nM("header", (r = Z8(t)) !== null && r !== void 0 ? r : "", "#" + l, MK(t), d);
  }, sM = (t) => {
    const r = t.id || t.name, l = Z8(t);
    return nM("anchor", l || "#" + r, "#" + r, 0, U);
  }, rM = (t) => et(So(t, q8), K8), IK = (t) => et(So(t, PK), sM), FK = (t) => W8("h1,h2,h3,h4,h5,h6,a:not([href])", t), BK = (t) => tM(t.title).length > 0, LK = { find: (t) => {
    const r = FK(t);
    return So(rM(r).concat(IK(r)), BK);
  } }, YA = "tinymce-url-history", X8 = 5, Q8 = (t) => A(t) && /^https?/.test(t), $K = (t) => Z(t) && t.length <= X8 && An(t, Q8), J8 = (t) => N(t) && Ms(t, (r) => !$K(r)).isNone(), e7 = () => {
    const t = s0.getItem(YA);
    if (t === null)
      return {};
    let r;
    try {
      r = JSON.parse(t);
    } catch (l) {
      if (l instanceof SyntaxError)
        return console.log("Local storage " + YA + " was not valid JSON", l), {};
      throw l;
    }
    return J8(r) ? r : (console.log("Local storage " + YA + " was not valid format", r), {});
  }, t7 = (t) => {
    if (!J8(t))
      throw new Error(`Bad format for history:
` + JSON.stringify(t));
    s0.setItem(YA, JSON.stringify(t));
  }, HK = (t) => {
    const r = e7();
    return qt(r, t).getOr([]);
  }, ok = (t, r) => {
    if (!Q8(t))
      return;
    const l = e7(), d = qt(l, r).getOr([]), h = So(d, (y) => y !== t);
    l[r] = [t].concat(h).slice(0, X8), t7(l);
  }, n7 = (t) => !!t, zK = (t) => kt(pm.makeMap(t, /[, ]/), n7), sk = (t) => B.from(xB(t)), o7 = (t) => {
    const r = B.from(CR(t)).filter(n7).map(zK);
    return sk(t).fold(_t, (l) => r.fold(ot, (d) => os(d).length > 0 ? d : !1));
  }, VK = (t, r) => {
    const l = o7(t);
    return J(l) ? l ? sk(t) : B.none() : l[r] ? sk(t) : B.none();
  }, UK = (t, r) => VK(t, r).map((l) => (d) => Zl.nu((h) => {
    const y = (E, O) => {
      if (!A(E))
        throw new Error("Expected value to be string");
      if (O !== void 0 && !N(O))
        throw new Error("Expected meta to be a object");
      h({
        value: E,
        meta: O
      });
    }, w = {
      filetype: r,
      fieldname: d.fieldname,
      ...B.from(d.meta).getOr({})
    };
    l.call(t, y, d.value, w);
  })), s7 = (t) => B.from(t).filter(A).getOrUndefined(), jK = (t) => wB(t) ? B.some({
    targets: LK.find(t.getBody()),
    anchorTop: s7(hT(t)),
    anchorBottom: s7(CB(t))
  }) : B.none(), WK = (t) => B.from(pT(t)), ZK = (t) => ({
    getHistory: HK,
    addToHistory: ok,
    getLinkInformation: () => jK(t),
    getValidationHandler: () => WK(t),
    getUrlPicker: (r) => UK(t, r)
  }), GK = (t, r, l, d) => {
    const h = to(!1), y = M8(r), w = {
      icons: () => r.ui.registry.getAll().icons,
      menuItems: () => r.ui.registry.getAll().menuItems,
      translate: Pd.translate,
      isDisabled: () => r.mode.isReadOnly() || !r.ui.isEnabled(),
      getOption: r.options.get,
      tooltips: qA(t.dialog)
    }, E = ZK(r), O = DK(r), F = JP(r), L = EK(r), q = () => h.get(), ne = (Re) => h.set(Re), ae = {
      shared: {
        providers: w,
        anchors: tae(r, l, d, y.isPositionedAtTop),
        header: y
      },
      urlinput: E,
      styles: O,
      colorinput: F,
      dialog: L,
      isContextMenuOpen: q,
      setContextMenuState: ne
    }, de = (Re) => B.none(), _e = {
      ...ae,
      shared: {
        ...ae.shared,
        interpreter: (Re) => XP(Re, {}, _e, de),
        getSink: t.popup
      }
    }, st = {
      ...ae,
      shared: {
        ...ae.shared,
        interpreter: (Re) => XP(Re, {}, st, de),
        getSink: t.dialog
      }
    };
    return {
      popup: _e,
      dialog: st
    };
  }, qK = (t, r, l) => {
    const d = (It, Yn) => {
      xt([
        r,
        ...l
      ], (Fn) => {
        Fn.broadcastEvent(It, Yn);
      });
    }, h = (It, Yn) => {
      xt([
        r,
        ...l
      ], (Fn) => {
        Fn.broadcastOn([It], Yn);
      });
    }, y = (It) => h(nm(), { target: It.target }), w = ec(), E = uc(w, "touchstart", y), O = uc(w, "touchmove", (It) => d(Xb(), It)), F = uc(w, "touchend", (It) => d(ew(), It)), L = uc(w, "mousedown", y), q = uc(w, "mouseup", (It) => {
      It.raw.button === 0 && h(_1(), { target: It.target });
    }), ne = (It) => h(nm(), { target: $e.fromDom(It.target) }), ae = (It) => {
      It.button === 0 && h(_1(), { target: $e.fromDom(It.target) });
    }, de = () => {
      xt(t.editorManager.get(), (It) => {
        t !== It && It.dispatch("DismissPopups", { relatedTarget: t });
      });
    }, _e = (It) => d(ng(), Qw(It)), st = (It) => {
      h(Dg(), {}), d(af(), Qw(It));
    }, Re = ie($e.fromDom(t.getElement())), Qe = Xw(Re, "scroll", (It) => {
      requestAnimationFrame(() => {
        const Yn = t.getContainer();
        if (Yn != null) {
          const yo = $g(t, r.element).map((mo) => [
            mo.element,
            ...mo.others
          ]).getOr([]);
          Ro(yo, (mo) => Is(mo, It.target)) && (t.dispatch("ElementScroll", { target: It.target.dom }), d(s_(), It));
        }
      });
    }), qe = () => h(Dg(), {}), Bt = (It) => {
      It.state && h(nm(), { target: $e.fromDom(t.getContainer()) });
    }, pt = (It) => {
      h(nm(), { target: $e.fromDom(It.relatedTarget.getContainer()) });
    }, en = (It) => t.dispatch("focusin", It), bn = (It) => t.dispatch("focusout", It);
    t.on("PostRender", () => {
      t.on("click", ne), t.on("tap", ne), t.on("mouseup", ae), t.on("mousedown", de), t.on("ScrollWindow", _e), t.on("ResizeWindow", st), t.on("ResizeEditor", qe), t.on("AfterProgressState", Bt), t.on("DismissPopups", pt), xt([
        r,
        ...l
      ], (It) => {
        It.element.dom.addEventListener("focusin", en), It.element.dom.addEventListener("focusout", bn);
      });
    }), t.on("remove", () => {
      t.off("click", ne), t.off("tap", ne), t.off("mouseup", ae), t.off("mousedown", de), t.off("ScrollWindow", _e), t.off("ResizeWindow", st), t.off("ResizeEditor", qe), t.off("AfterProgressState", Bt), t.off("DismissPopups", pt), xt([
        r,
        ...l
      ], (It) => {
        It.element.dom.removeEventListener("focusin", en), It.element.dom.removeEventListener("focusout", bn);
      }), L.unbind(), E.unbind(), O.unbind(), F.unbind(), q.unbind(), Qe.unbind();
    }), t.on("detach", () => {
      xt([
        r,
        ...l
      ], SC), xt([
        r,
        ...l
      ], (It) => It.destroy());
    });
  }, ol = UE, qg = LE, KK = ee([
    Xe("shell", !1),
    Mt("makeItem"),
    Xe("setupItem", U),
    Yu.field("listBehaviours", [Po])
  ]), r7 = Su({
    name: "items",
    overrides: () => ({ behaviours: Jt([Po.config({})]) })
  }), XA = ee([r7]), a7 = ee("CustomList"), XK = (t, r, l, d) => {
    const h = (E, O) => {
      w(E).fold(() => {
        throw console.error("Custom List was defined to not be a shell, but no item container was specified in components"), new Error("Custom List was defined to not be a shell, but no item container was specified in components");
      }, (F) => {
        const L = Po.contents(F), q = O.length, ne = q - L.length, ae = ne > 0 ? Rt(ne, () => t.makeItem()) : [], de = L.slice(q);
        xt(de, (st) => Po.remove(F, st)), xt(ae, (st) => Po.append(F, st));
        const _e = Po.contents(F);
        xt(_e, (st, Re) => {
          t.setupItem(E, st, O[Re], Re);
        });
      });
    }, y = t.shell ? {
      behaviours: [Po.config({})],
      components: []
    } : {
      behaviours: [],
      components: r
    }, w = (E) => t.shell ? B.some(E) : Qt(E, t, "items");
    return {
      uid: t.uid,
      dom: t.dom,
      components: y.components,
      behaviours: Hi(t.listBehaviours, y.behaviours),
      apis: { setItems: h }
    };
  }, i7 = Wl({
    name: a7(),
    configFields: KK(),
    partFields: XA(),
    factory: XK,
    apis: {
      setItems: (t, r, l) => {
        t.setItems(r, l);
      }
    }
  }), n2 = ee([
    Mt("dom"),
    Xe("shell", !0),
    $i("toolbarBehaviours", [Po])
  ]), QK = ee([Su({
    name: "groups",
    overrides: () => ({ behaviours: Jt([Po.config({})]) })
  })]), JK = (t, r, l, d) => {
    const h = (E, O) => {
      y(E).fold(() => {
        throw console.error("Toolbar was defined to not be a shell, but no groups container was specified in components"), new Error("Toolbar was defined to not be a shell, but no groups container was specified in components");
      }, (F) => {
        Po.set(F, O);
      });
    }, y = (E) => t.shell ? B.some(E) : Qt(E, t, "groups"), w = t.shell ? {
      behaviours: [Po.config({})],
      components: []
    } : {
      behaviours: [],
      components: r
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: w.components,
      behaviours: Hi(t.toolbarBehaviours, w.behaviours),
      apis: {
        setGroups: h,
        refresh: U
      },
      domModification: { attributes: { role: "group" } }
    };
  }, ip = Wl({
    name: "Toolbar",
    configFields: n2(),
    partFields: QK(),
    factory: JK,
    apis: {
      setGroups: (t, r, l) => {
        t.setGroups(r, l);
      }
    }
  }), l7 = U, c7 = _t, u7 = ee([]);
  var d7 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setup: l7,
    isDocked: c7,
    getBehaviours: u7
  });
  const aM = ee(Mn("toolbar-height-change")), kh = {
    fadeInClass: "tox-editor-dock-fadein",
    fadeOutClass: "tox-editor-dock-fadeout",
    transitionClass: "tox-editor-dock-transition"
  }, f7 = "tox-tinymce--toolbar-sticky-on", Cb = "tox-tinymce--toolbar-sticky-off", m7 = (t, r) => {
    const l = li(r), h = cl(r).dom.innerHeight, y = Ci(l), w = $e.fromDom(t.elm), E = Cl(w), O = Mr(w), F = E.y, L = F + O, q = Ga(r), ne = Mr(r), ae = q.top, de = ae + ne, _e = Math.abs(ae - y.top) < 2, st = Math.abs(de - (y.top + h)) < 2;
    if (_e && F < de)
      Cp(y.left, F - ne, l);
    else if (st && L > ae) {
      const Re = F - h + O + ne;
      Cp(y.left, Re, l);
    }
  }, Sb = (t, r) => pn(ma.getModes(t), r), o2 = (t) => {
    const r = (d) => pd(d) + (parseInt(lr(d, "margin-top"), 10) || 0) + (parseInt(lr(d, "margin-bottom"), 10) || 0), l = t.element;
    ji(l).each((d) => {
      const h = "padding-" + ma.getModes(t)[0];
      if (ma.isDocked(t)) {
        const y = Ri(d);
        Ln(l, "width", y + "px"), Ln(d, h, r(l) + "px");
      } else
        gs(l, "width"), gs(d, h);
    });
  }, iM = (t, r) => {
    r ? (ba(t, kh.fadeOutClass), Av(t, [
      kh.transitionClass,
      kh.fadeInClass
    ])) : (ba(t, kh.fadeInClass), Av(t, [
      kh.fadeOutClass,
      kh.transitionClass
    ]));
  }, lM = (t, r) => {
    const l = $e.fromDom(t.getContainer());
    r ? (Vr(l, f7), ba(l, Cb)) : (Vr(l, Cb), ba(l, f7));
  }, p7 = (t, r) => {
    const l = li(r);
    hf(l).filter((d) => !Is(r, d)).filter((d) => Is(d, $e.fromDom(l.dom.body)) || ka(t, d)).each(() => vu(r));
  }, oae = (t, r) => cc(t).orThunk(() => r().toOptional().bind((l) => cc(l.element))), eY = (t, r, l) => {
    t.inline || (r.header.isPositionedAtTop() || t.on("ResizeEditor", () => {
      l().each(ma.reset);
    }), t.on("ResizeWindow ResizeEditor", () => {
      l().each(o2);
    }), t.on("SkinLoaded", () => {
      l().each((d) => {
        ma.isDocked(d) ? ma.reset(d) : ma.refresh(d);
      });
    }), t.on("FullscreenStateChanged", () => {
      l().each(ma.reset);
    })), t.on("AfterScrollIntoView", (d) => {
      l().each((h) => {
        ma.refresh(h);
        const y = h.element;
        cF(y) && m7(d, y);
      });
    }), t.on("PostRender", () => {
      lM(t, !1);
    });
  }, tY = (t) => t().map(ma.isDocked).getOr(!1), nY = () => [Rc.config({ channels: { [aM()]: { onReceive: o2 } } })], h7 = (t, r) => {
    const l = cr(), d = r.getSink, h = (E) => {
      d().each((O) => E(O.element));
    }, y = (E) => {
      t.inline || o2(E), lM(t, ma.isDocked(E)), E.getSystem().broadcastOn([Dg()], {}), d().each((O) => O.getSystem().broadcastOn([Dg()], {}));
    }, w = t.inline ? [] : nY();
    return [
      To.config({}),
      ma.config({
        contextual: {
          lazyContext: (E) => {
            const O = pd(E.element), F = t.inline ? t.getContentAreaContainer() : t.getContainer();
            return B.from(F).map((L) => {
              const q = sa($e.fromDom(L));
              return $g(t, E.element).fold(() => {
                const ae = q.height - O, de = q.y + (Sb(E, "top") ? 0 : O);
                return Nr(q.x, de, q.width, ae);
              }, (ae) => {
                const de = qh(q, q1(ae)), _e = Sb(E, "top") ? de.y : de.y + O;
                return Nr(de.x, _e, de.width, de.height - O);
              });
            });
          },
          onShow: () => {
            h((E) => iM(E, !0));
          },
          onShown: (E) => {
            h((O) => Yc(O, [
              kh.transitionClass,
              kh.fadeInClass
            ])), l.get().each((O) => {
              p7(E.element, O), l.clear();
            });
          },
          onHide: (E) => {
            oae(E.element, d).fold(l.clear, l.set), h((O) => iM(O, !1));
          },
          onHidden: () => {
            h((E) => Yc(E, [kh.transitionClass]));
          },
          ...kh
        },
        lazyViewport: (E) => $g(t, E.element).fold(() => {
          const F = Na(), L = yB(t), q = F.y + (Sb(E, "top") ? L : 0), ne = F.height - (Sb(E, "bottom") ? L : 0);
          return {
            bounds: Nr(F.x, q, F.width, ne),
            optScrollEnv: B.none()
          };
        }, (F) => ({
          bounds: q1(F),
          optScrollEnv: B.some({
            currentScrollTop: F.element.dom.scrollTop,
            scrollElmTop: Ga(F.element).top
          })
        })),
        modes: [r.header.getDockingMode()],
        onDocked: y,
        onUndocked: y
      }),
      ...w
    ];
  };
  var oY = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setup: eY,
    isDocked: tY,
    getBehaviours: h7
  });
  const s2 = (t) => {
    const r = t.editor, l = t.sticky ? h7 : u7;
    return {
      uid: t.uid,
      dom: t.dom,
      components: t.components,
      behaviours: Jt(l(r, t.sharedBackstage))
    };
  }, rk = xo([
    oi,
    Ls("items", Rp([
      jb([
        LT,
        Ac("items", Tn)
      ]),
      Tn
    ]))
  ].concat(xS)), cM = (t) => ra("GroupToolbarButton", rk, t), sY = [
    Ua("text"),
    Ua("tooltip"),
    Ua("icon"),
    Wc("search", !1, Rp([
      Ec,
      xo([Ua("placeholder")])
    ], (t) => J(t) ? t ? B.some({ placeholder: B.none() }) : B.none() : B.some(t))),
    Tc("fetch"),
    Ca("onSetup", () => U)
  ], g7 = xo([
    oi,
    ...sY
  ]), QA = (t) => ra("menubutton", g7, t), rY = xo([
    oi,
    bS,
    yf,
    vb,
    dL,
    iW,
    gb,
    gu("presets", "normal", [
      "normal",
      "color",
      "listpreview"
    ]),
    UT(1),
    Nx,
    cN
  ]), ak = (t) => ra("SplitButton", rY, t);
  var uM = Nc({
    factory: (t, r) => {
      const l = (h, y) => {
        const w = et(y, (E) => {
          const O = {
            type: "menubutton",
            text: E.text,
            fetch: (L) => {
              L(E.getItems());
            }
          }, F = QA(O).mapError((L) => zu(L)).getOrDie();
          return GS(F, "tox-mbtn", r.backstage, B.some("menuitem"));
        });
        Po.set(h, w);
      }, d = {
        focus: so.focusIn,
        setMenus: l
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: [],
        behaviours: Jt([
          Po.config({}),
          jo("menubar-events", [
            qr((h) => {
              t.onSetup(h);
            }),
            Ft(jf(), (h, y) => {
              or(h.element, ".tox-mbtn--active").each((w) => {
                pf(y.event.target, ".tox-mbtn").each((E) => {
                  Is(w, E) || h.getSystem().getByDom(w).each((O) => {
                    h.getSystem().getByDom(E).each((F) => {
                      wf.expand(F), wf.close(O), To.focus(F);
                    });
                  });
                });
              });
            }),
            Ft(og(), (h, y) => {
              y.event.prevFocus.bind((w) => h.getSystem().getByDom(w).toOptional()).each((w) => {
                y.event.newFocus.bind((E) => h.getSystem().getByDom(E).toOptional()).each((E) => {
                  wf.isOpen(w) && (wf.expand(E), wf.close(w));
                });
              });
            })
          ]),
          so.config({
            mode: "flow",
            selector: ".tox-mbtn",
            onEscape: (h) => (t.onEscape(h), B.some(!0))
          }),
          jr.config({})
        ]),
        apis: d,
        domModification: { attributes: { role: "menubar" } }
      };
    },
    name: "silver.Menubar",
    configFields: [
      Mt("dom"),
      Mt("uid"),
      Mt("onEscape"),
      Mt("backstage"),
      Xe("onSetup", U)
    ],
    apis: {
      focus: (t, r) => {
        t.focus(r);
      },
      setMenus: (t, r, l) => {
        t.setMenus(r, l);
      }
    }
  });
  const iY = "⚡️Upgrade", lY = "https://www.tiny.cloud/tinymce-self-hosted-premium-features/?utm_campaign=self_hosted_upgrade_promo&utm_source=tiny&utm_medium=referral", cY = (t) => ({
    uid: t.uid,
    dom: t.dom,
    components: [{
      dom: {
        tag: "a",
        attributes: {
          href: lY,
          rel: "noopener",
          target: "_blank",
          "aria-hidden": "true"
        },
        classes: ["tox-promotion-link"],
        innerHtml: iY
      }
    }]
  }), v7 = "container", uY = [$i("slotBehaviours", [])], dM = (t) => "<alloy.field." + t + ">", b7 = (t) => {
    const r = (() => {
      const y = [];
      return {
        slot: (E, O) => (y.push(E), zE(v7, dM(E), O)),
        record: ee(y)
      };
    })(), l = t(r), d = r.record(), h = et(d, (y) => hl({
      name: y,
      pname: dM(y)
    }));
    return Ym(v7, uY, h, fM, l);
  }, fM = (t, r) => {
    const l = (_e) => N1(t), d = (_e, st) => Qt(_e, t, st), h = (_e, st) => (Re, Qe) => Qt(Re, t, Qe).map((qe) => _e(qe, Qe)).getOr(st), y = (_e) => (st, Re) => {
      xt(Re, (Qe) => _e(st, Qe));
    }, w = (_e, st) => tr(_e.element, "aria-hidden") !== "true", E = (_e, st) => {
      if (!w(_e)) {
        const Re = _e.element;
        gs(Re, "display"), Ee(Re, "aria-hidden"), po(_e, nw(), {
          name: st,
          visible: !0
        });
      }
    }, O = (_e, st) => {
      if (w(_e)) {
        const Re = _e.element;
        Ln(Re, "display", "none"), sn(Re, "aria-hidden", "true"), po(_e, nw(), {
          name: st,
          visible: !1
        });
      }
    }, F = h(w, !1), L = h(O), q = y(L), ne = (_e) => q(_e, l()), ae = h(E), de = {
      getSlotNames: l,
      getSlot: d,
      isShowing: F,
      hideSlot: L,
      hideAllSlots: ne,
      showSlot: ae
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: r,
      behaviours: A1(t.slotBehaviours),
      apis: de
    };
  }, bl = {
    ...kt({
      getSlotNames: (t, r) => t.getSlotNames(r),
      getSlot: (t, r, l) => t.getSlot(r, l),
      isShowing: (t, r, l) => t.isShowing(r, l),
      hideSlot: (t, r, l) => t.hideSlot(r, l),
      hideAllSlots: (t, r) => t.hideAllSlots(r),
      showSlot: (t, r, l) => t.showSlot(r, l)
    }, (t) => $v(t)),
    sketch: b7
  }, JA = xo([
    yf,
    bS,
    Ca("onShow", U),
    Ca("onHide", U),
    gb
  ]), y7 = (t) => ra("sidebar", JA, t), dY = (t) => {
    const { sidebars: r } = t.ui.registry.getAll();
    xt(os(r), (l) => {
      const d = r[l], h = () => ha(B.from(t.queryCommandValue("ToggleSidebar")), l);
      t.ui.registry.addToggleButton(l, {
        icon: d.icon,
        tooltip: d.tooltip,
        onAction: (y) => {
          t.execCommand("ToggleSidebar", !1, l), y.setActive(h());
        },
        onSetup: (y) => {
          y.setActive(h());
          const w = () => y.setActive(h());
          return t.on("ToggleSidebar", w), () => {
            t.off("ToggleSidebar", w);
          };
        }
      });
    });
  }, fY = (t) => ({ element: () => t.element.dom }), mY = (t, r) => {
    const l = et(os(r), (d) => {
      const h = r[d], y = Gt(y7(h));
      return {
        name: d,
        getApi: fY,
        onSetup: y.onSetup,
        onShow: y.onShow,
        onHide: y.onHide
      };
    });
    return et(l, (d) => {
      const h = to(U);
      return t.slot(d.name, {
        dom: {
          tag: "div",
          classes: ["tox-sidebar__pane"]
        },
        behaviours: Px.unnamedEvents([
          Vg(d, h),
          hc(d, h),
          Ft(nw(), (y, w) => {
            const E = w.event;
            Nt(l, (F) => F.name === E.name).each((F) => {
              (E.visible ? F.onShow : F.onHide)(F.getApi(y));
            });
          })
        ])
      });
    });
  }, pY = (t) => bl.sketch((r) => ({
    dom: {
      tag: "div",
      classes: ["tox-sidebar__pane-container"]
    },
    components: mY(r, t),
    slotBehaviours: Px.unnamedEvents([qr((l) => bl.hideAllSlots(l))])
  })), mM = (t, r, l) => {
    Ds.getCurrent(t).each((h) => {
      Po.set(h, [pY(r)]);
      const y = l == null ? void 0 : l.toLowerCase();
      A(y) && Ko(r, y) && Ds.getCurrent(h).each((w) => {
        bl.showSlot(w, y), ru.immediateGrow(h), gs(h.element, "width"), r2(t.element, "region");
      });
    });
  }, r2 = (t, r) => {
    sn(t, "role", r);
  }, hY = (t, r) => {
    Ds.getCurrent(t).each((d) => {
      Ds.getCurrent(d).each((y) => {
        ru.hasGrown(d) ? bl.isShowing(y, r) ? (ru.shrink(d), r2(t.element, "presentation")) : (bl.hideAllSlots(y), bl.showSlot(y, r), r2(t.element, "region")) : (bl.hideAllSlots(y), bl.showSlot(y, r), ru.grow(d), r2(t.element, "region"));
      });
    });
  }, pM = (t) => Ds.getCurrent(t).bind((l) => ru.isGrowing(l) || ru.hasGrown(l) ? Ds.getCurrent(l).bind((y) => Nt(bl.getSlotNames(y), (w) => bl.isShowing(y, w))) : B.none()), hM = Mn("FixSizeEvent"), gM = Mn("AutoSizeEvent"), gY = (t) => ({
    uid: t.uid,
    dom: {
      tag: "div",
      classes: ["tox-sidebar"],
      attributes: { role: "presentation" }
    },
    components: [{
      dom: {
        tag: "div",
        classes: ["tox-sidebar__slider"]
      },
      components: [],
      behaviours: Jt([
        jr.config({}),
        To.config({}),
        ru.config({
          dimension: { property: "width" },
          closedClass: "tox-sidebar--sliding-closed",
          openClass: "tox-sidebar--sliding-open",
          shrinkingClass: "tox-sidebar--sliding-shrinking",
          growingClass: "tox-sidebar--sliding-growing",
          onShrunk: (r) => {
            Ds.getCurrent(r).each(bl.hideAllSlots), Xo(r, gM);
          },
          onGrown: (r) => {
            Xo(r, gM);
          },
          onStartGrow: (r) => {
            po(r, hM, { width: Cr(r.element, "width").getOr("") });
          },
          onStartShrink: (r) => {
            po(r, hM, { width: Ri(r.element) + "px" });
          }
        }),
        Po.config({}),
        Ds.config({
          find: (r) => {
            const l = Po.contents(r);
            return ao(l);
          }
        })
      ])
    }],
    behaviours: Jt([
      sd.childAt(0),
      jo("sidebar-sliding-events", [
        Ft(hM, (r, l) => {
          Ln(r.element, "width", l.event.width);
        }),
        Ft(gM, (r, l) => {
          gs(r.element, "width");
        })
      ])
    ])
  });
  var iae = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    block: (t, r, l, d) => {
      sn(t.element, "aria-busy", !0);
      const h = r.getRoot(t).getOr(t), y = Jt([
        so.config({
          mode: "special",
          onTab: () => B.some(!0),
          onShiftTab: () => B.some(!0)
        }),
        To.config({})
      ]), w = d(h, y), E = h.getSystem().build(w);
      Po.append(h, Vl(E)), E.hasConfigured(so) && r.focus && so.focusIn(E), l.isBlocked() || r.onBlock(t), l.blockWith(() => Po.remove(h, E));
    },
    unblock: (t, r, l) => {
      Ee(t.element, "aria-busy"), l.isBlocked() && r.onUnblock(t), l.clear();
    },
    isBlocked: (t, r, l) => l.isBlocked()
  }), x7 = [
    Ca("getRoot", B.none),
    Ea("focus", !0),
    Os("onBlock"),
    Os("onUnblock")
  ], w7 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = mv(), r = (l) => {
        t.set({ destroy: l });
      };
      return qc({
        readState: t.isSet,
        blockWith: r,
        clear: t.clear,
        isBlocked: t.isSet
      });
    }
  });
  const lp = Xi({
    fields: x7,
    name: "blocking",
    apis: iae,
    state: w7
  }), vY = (t) => (r, l) => ({
    dom: {
      tag: "div",
      attributes: {
        "aria-label": t.translate("Loading..."),
        tabindex: "0"
      },
      classes: ["tox-throbber__busy-spinner"]
    },
    components: [{ dom: Qm('<div class="tox-spinner"><div></div><div></div><div></div></div>') }]
  }), C7 = (t) => Ds.getCurrent(t).each((r) => vu(r.element, !0)), bY = (t, r) => {
    const l = "tabindex", d = `data-mce-${l}`;
    B.from(t.iframeElement).map($e.fromDom).each((h) => {
      r ? (Y(h, l).each((y) => sn(h, d, y)), sn(h, l, -1)) : (Ee(h, l), Y(h, d).each((y) => {
        sn(h, l, y), Ee(h, d);
      }));
    });
  }, yY = (t, r, l, d) => {
    const h = r.element;
    if (bY(t, l), l)
      lp.block(r, vY(d)), gs(h, "display"), Ee(h, "aria-hidden"), t.hasFocus() && C7(r);
    else {
      const y = Ds.getCurrent(r).exists((w) => g1(w.element));
      lp.unblock(r), Ln(h, "display", "none"), sn(h, "aria-hidden", "true"), y && t.focus();
    }
  }, S7 = (t) => ({
    uid: t.uid,
    dom: {
      tag: "div",
      attributes: { "aria-hidden": "true" },
      classes: ["tox-throbber"],
      styles: { display: "none" }
    },
    behaviours: Jt([
      Po.config({}),
      lp.config({ focus: !1 }),
      Ds.config({ find: (r) => ao(r.components()) })
    ]),
    components: []
  }), xY = (t) => t.type === "focusin", wY = (t) => xY(t) ? (t.composed ? ao(t.composedPath()) : B.from(t.target)).map($e.fromDom).filter(ko).exists((l) => Kc(l, "mce-pastebin")) : !1, CY = (t, r, l) => {
    const d = to(!1), h = cr(), y = (E) => {
      d.get() && !wY(E) && (E.preventDefault(), C7(r()), t.editorManager.setActive(t));
    };
    t.inline || t.on("PreInit", () => {
      t.dom.bind(t.getWin(), "focusin", y), t.on("BeforeExecCommand", (E) => {
        E.command.toLowerCase() === "mcefocus" && E.value !== !0 && y(E);
      });
    });
    const w = (E) => {
      E !== d.get() && (d.set(E), yY(t, r(), E, l.providers), LW(t, E));
    };
    t.on("ProgressState", (E) => {
      if (h.on(clearTimeout), re(E.time)) {
        const O = JC.setEditorTimeout(t, () => w(E.state), E.time);
        h.set(O);
      } else
        w(E.state), h.clear();
    });
  }, cae = (t, r) => Pt(t, (h, y) => r(y, h.len).fold(ee(h), (E) => ({
    len: E.finish,
    list: h.list.concat([E])
  })), {
    len: 0,
    list: []
  }).list, k7 = (t, r, l) => ({
    within: t,
    extra: r,
    withinWidth: l
  }), vM = (t, r, l) => {
    const d = cae(t, (E, O) => {
      const F = l(E);
      return B.some({
        element: E,
        start: O,
        finish: O + F,
        width: F
      });
    }), h = So(d, (E) => E.finish <= r), y = At(h, (E, O) => E + O.width, 0), w = d.slice(h.length);
    return {
      within: h,
      extra: w,
      withinWidth: y
    };
  }, ik = (t) => et(t, (r) => r.element), SY = (t, r, l) => {
    const d = ik(t.concat(r));
    return k7(d, [], l);
  }, kY = (t, r, l, d) => {
    const h = ik(t).concat([l]);
    return k7(h, ik(r), d);
  }, Fd = (t, r, l) => k7(ik(t), [], l), _Y = (t, r, l) => {
    const d = vM(r, t, l);
    return d.extra.length === 0 ? B.some(d) : B.none();
  }, _7 = (t, r, l, d) => {
    const h = _Y(t, r, l).getOrThunk(() => vM(r, t - l(d), l)), y = h.within, w = h.extra, E = h.withinWidth;
    return w.length === 1 && w[0].width <= l(d) ? SY(y, w, E) : w.length >= 1 ? kY(y, w, d, E) : Fd(y, w, E);
  }, bM = (t, r) => {
    const l = et(r, (d) => Vl(d));
    ip.setGroups(t, l);
  }, EY = (t) => Qo(t, (r) => cc(r.element).bind((l) => r.getSystem().getByDom(l).toOptional())), a2 = (t, r, l) => {
    const d = r.builtGroups.get();
    if (d.length === 0)
      return;
    const h = fc(t, r, "primary"), y = Ia.getCoupled(t, "overflowGroup");
    Ln(h.element, "visibility", "hidden");
    const w = d.concat([y]), E = EY(w);
    l([]), bM(h, w);
    const O = Ri(h.element), F = _7(O, r.builtGroups.get(), (L) => Math.ceil(L.element.dom.getBoundingClientRect().width), y);
    F.extra.length === 0 ? (Po.remove(h, y), l([])) : (bM(h, F.within), l(F.extra)), gs(h.element, "visibility"), xi(h.element), E.each(To.focus);
  }, E7 = ee([
    $i("splitToolbarBehaviours", [Ia]),
    Vs("builtGroups", () => to([]))
  ]), e3 = ee([
    Xf(["overflowToggledClass"]),
    Cd("getOverflowBounds"),
    Mt("lazySink"),
    Vs("overflowGroups", () => to([])),
    Os("onOpened"),
    Os("onClosed")
  ].concat(E7())), TY = ee([
    hl({
      factory: ip,
      schema: n2(),
      name: "primary"
    }),
    Xu({
      schema: n2(),
      name: "overflow"
    }),
    Xu({ name: "overflow-button" }),
    Xu({ name: "overflow-group" })
  ]), i2 = ee((t, r) => {
    me(t, Math.floor(r));
  }), AY = ee([
    Xf(["toggledClass"]),
    Mt("lazySink"),
    Tc("fetch"),
    Cd("getBounds"),
    kr("fireDismissalEventInstead", [Xe("event", Lp())]),
    nh(),
    Os("onToggled")
  ]), OY = ee([
    Xu({
      name: "button",
      overrides: (t) => ({
        dom: { attributes: { "aria-haspopup": "true" } },
        buttonBehaviours: Jt([ns.config({
          toggleClass: t.markers.toggledClass,
          aria: { mode: "expanded" },
          toggleOnExecute: !1,
          onToggled: t.onToggled
        })])
      })
    }),
    Xu({
      factory: ip,
      schema: n2(),
      name: "toolbar",
      overrides: (t) => ({
        toolbarBehaviours: Jt([so.config({
          mode: "cyclic",
          onEscape: (r) => (Qt(r, t, "button").each(To.focus), B.none())
        })])
      })
    })
  ]), Eu = cr(), DY = (t, r) => {
    Eu.set(!0), l2(t, r), Eu.clear();
  }, l2 = (t, r) => {
    const l = Ia.getCoupled(t, "toolbarSandbox");
    Ns.isOpen(l) ? Ns.close(l) : Ns.open(l, r.toolbar());
  }, t3 = (t, r, l, d) => {
    const h = l.getBounds.map((w) => w()), y = l.lazySink(t).getOrDie();
    tl.positionWithinBounds(y, r, {
      anchor: {
        type: "hotspot",
        hotspot: t,
        layouts: d,
        overrides: { maxWidthFunction: i2() }
      }
    }, h);
  }, yM = (t, r, l, d, h) => {
    ip.setGroups(r, h), t3(t, r, l, d), ns.on(t);
  }, RY = (t, r, l) => {
    const d = Sy(), h = (w, E) => {
      const O = Eu.get().getOr(!1);
      l.fetch().get((F) => {
        yM(t, E, l, r.layouts, F), d.link(t.element), O || so.focusIn(E);
      });
    }, y = () => {
      ns.off(t), Eu.get().getOr(!1) || To.focus(t), d.unlink(t.element);
    };
    return {
      dom: {
        tag: "div",
        attributes: { id: d.id }
      },
      behaviours: Jt([
        so.config({
          mode: "special",
          onEscape: (w) => (Ns.close(w), B.some(!0))
        }),
        Ns.config({
          onOpen: h,
          onClose: y,
          isPartOf: (w, E, O) => qp(E, O) || qp(t, O),
          getAttachPoint: () => l.lazySink(t).getOrDie()
        }),
        Rc.config({
          channels: {
            ...qm({
              isExtraPart: _t,
              ...l.fireDismissalEventInstead.map((w) => ({ fireEventInstead: { event: w.event } })).getOr({})
            }),
            ...nx({
              doReposition: () => {
                Ns.getState(Ia.getCoupled(t, "toolbarSandbox")).each((w) => {
                  t3(t, w, l, r.layouts);
                });
              }
            })
          }
        })
      ])
    };
  }, kb = Wl({
    name: "FloatingToolbarButton",
    factory: (t, r, l, d) => ({
      ...Nl.sketch({
        ...d.button(),
        action: (h) => {
          l2(h, d);
        },
        buttonBehaviours: Yu.augment({ dump: d.button().buttonBehaviours }, [Ia.config({
          others: {
            toolbarSandbox: (h) => RY(h, l, t)
          }
        })])
      }),
      apis: {
        setGroups: (h, y) => {
          Ns.getState(Ia.getCoupled(h, "toolbarSandbox")).each((w) => {
            yM(h, w, t, l.layouts, y);
          });
        },
        reposition: (h) => {
          Ns.getState(Ia.getCoupled(h, "toolbarSandbox")).each((y) => {
            t3(h, y, t, l.layouts);
          });
        },
        toggle: (h) => {
          l2(h, d);
        },
        toggleWithoutFocusing: (h) => {
          DY(h, d);
        },
        getToolbar: (h) => Ns.getState(Ia.getCoupled(h, "toolbarSandbox")),
        isOpen: (h) => Ns.isOpen(Ia.getCoupled(h, "toolbarSandbox"))
      }
    }),
    configFields: AY(),
    partFields: OY(),
    apis: {
      setGroups: (t, r, l) => {
        t.setGroups(r, l);
      },
      reposition: (t, r) => {
        t.reposition(r);
      },
      toggle: (t, r) => {
        t.toggle(r);
      },
      toggleWithoutFocusing: (t, r) => {
        t.toggleWithoutFocusing(r);
      },
      getToolbar: (t, r) => t.getToolbar(r),
      isOpen: (t, r) => t.isOpen(r)
    }
  }), PY = ee([
    Mt("items"),
    Xf(["itemSelector"]),
    $i("tgroupBehaviours", [so])
  ]), MY = ee([mx({
    name: "items",
    unit: "item"
  })]), IY = (t, r, l, d) => ({
    uid: t.uid,
    dom: t.dom,
    components: r,
    behaviours: Hi(t.tgroupBehaviours, [so.config({
      mode: "flow",
      selector: t.markers.itemSelector
    })]),
    domModification: { attributes: { role: "toolbar" } }
  }), n3 = Wl({
    name: "ToolbarGroup",
    configFields: PY(),
    partFields: MY(),
    factory: IY
  }), T7 = (t) => et(t, (r) => Vl(r)), A7 = (t, r, l) => {
    a2(t, l, (d) => {
      l.overflowGroups.set(d), r.getOpt(t).each((h) => {
        kb.setGroups(h, T7(d));
      });
    });
  }, O7 = (t, r, l, d) => {
    const h = rr(kb.sketch({
      fetch: () => Zl.nu((y) => {
        y(T7(t.overflowGroups.get()));
      }),
      layouts: {
        onLtr: () => [
          ei,
          fi
        ],
        onRtl: () => [
          fi,
          ei
        ],
        onBottomLtr: () => [
          br,
          mi
        ],
        onBottomRtl: () => [
          mi,
          br
        ]
      },
      getBounds: l.getOverflowBounds,
      lazySink: t.lazySink,
      fireDismissalEventInstead: {},
      markers: { toggledClass: t.markers.overflowToggledClass },
      parts: {
        button: d["overflow-button"](),
        toolbar: d.overflow()
      },
      onToggled: (y, w) => t[w ? "onOpened" : "onClosed"](y)
    }));
    return {
      uid: t.uid,
      dom: t.dom,
      components: r,
      behaviours: Hi(t.splitToolbarBehaviours, [Ia.config({
        others: {
          overflowGroup: () => n3.sketch({
            ...d["overflow-group"](),
            items: [h.asSpec()]
          })
        }
      })]),
      apis: {
        setGroups: (y, w) => {
          t.builtGroups.set(et(w, y.getSystem().build)), A7(y, h, t);
        },
        refresh: (y) => A7(y, h, t),
        toggle: (y) => {
          h.getOpt(y).each((w) => {
            kb.toggle(w);
          });
        },
        toggleWithoutFocusing: (y) => {
          h.getOpt(y).each(kb.toggleWithoutFocusing);
        },
        isOpen: (y) => h.getOpt(y).map(kb.isOpen).getOr(!1),
        reposition: (y) => {
          h.getOpt(y).each((w) => {
            kb.reposition(w);
          });
        },
        getOverflow: (y) => h.getOpt(y).bind(kb.getToolbar)
      },
      domModification: { attributes: { role: "group" } }
    };
  }, xM = Wl({
    name: "SplitFloatingToolbar",
    configFields: e3(),
    partFields: TY(),
    factory: O7,
    apis: {
      setGroups: (t, r, l) => {
        t.setGroups(r, l);
      },
      refresh: (t, r) => {
        t.refresh(r);
      },
      reposition: (t, r) => {
        t.reposition(r);
      },
      toggle: (t, r) => {
        t.toggle(r);
      },
      toggleWithoutFocusing: (t, r) => {
        t.toggle(r);
      },
      isOpen: (t, r) => t.isOpen(r),
      getOverflow: (t, r) => t.getOverflow(r)
    }
  }), D7 = ee([
    Xf([
      "closedClass",
      "openClass",
      "shrinkingClass",
      "growingClass",
      "overflowToggledClass"
    ]),
    Os("onOpened"),
    Os("onClosed")
  ].concat(E7())), FY = ee([
    hl({
      factory: ip,
      schema: n2(),
      name: "primary"
    }),
    hl({
      factory: ip,
      schema: n2(),
      name: "overflow",
      overrides: (t) => ({
        toolbarBehaviours: Jt([
          ru.config({
            dimension: { property: "height" },
            closedClass: t.markers.closedClass,
            openClass: t.markers.openClass,
            shrinkingClass: t.markers.shrinkingClass,
            growingClass: t.markers.growingClass,
            onShrunk: (r) => {
              Qt(r, t, "overflow-button").each((l) => {
                ns.off(l);
              }), t.onClosed(r);
            },
            onGrown: (r) => {
              t.onOpened(r);
            },
            onStartGrow: (r) => {
              Qt(r, t, "overflow-button").each(ns.on);
            }
          }),
          so.config({
            mode: "acyclic",
            onEscape: (r) => (Qt(r, t, "overflow-button").each(To.focus), B.some(!0))
          })
        ])
      })
    }),
    Xu({
      name: "overflow-button",
      overrides: (t) => ({
        buttonBehaviours: Jt([ns.config({
          toggleClass: t.markers.overflowToggledClass,
          aria: { mode: "expanded" },
          toggleOnExecute: !1
        })])
      })
    }),
    Xu({ name: "overflow-group" })
  ]), BY = (t, r) => Qt(t, r, "overflow").map(ru.hasGrown).getOr(!1), o3 = (t, r, l) => {
    Qt(t, r, "overflow-button").each((d) => {
      Qt(t, r, "overflow").each((h) => {
        if (s3(t, r), ru.hasShrunk(h)) {
          const y = r.onOpened;
          r.onOpened = (w) => {
            l || so.focusIn(h), y(w), r.onOpened = y;
          };
        } else {
          const y = r.onClosed;
          r.onClosed = (w) => {
            l || To.focus(d), y(w), r.onClosed = y;
          };
        }
        ru.toggleGrow(h);
      });
    });
  }, s3 = (t, r) => {
    Qt(t, r, "overflow").each((l) => {
      a2(t, r, (d) => {
        const h = et(d, (y) => Vl(y));
        ip.setGroups(l, h);
      }), Qt(t, r, "overflow-button").each((d) => {
        ru.hasGrown(l) && ns.on(d);
      }), ru.refresh(l);
    });
  }, R7 = (t, r, l, d) => {
    const h = "alloy.toolbar.toggle", y = (w, E) => {
      const O = et(E, w.getSystem().build);
      t.builtGroups.set(O);
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: r,
      behaviours: Hi(t.splitToolbarBehaviours, [
        Ia.config({
          others: {
            overflowGroup: (w) => n3.sketch({
              ...d["overflow-group"](),
              items: [Nl.sketch({
                ...d["overflow-button"](),
                action: (E) => {
                  Xo(w, h);
                }
              })]
            })
          }
        }),
        jo("toolbar-toggle-events", [Ft(h, (w) => {
          o3(w, t, !1);
        })])
      ]),
      apis: {
        setGroups: (w, E) => {
          y(w, E), s3(w, t);
        },
        refresh: (w) => s3(w, t),
        toggle: (w) => {
          o3(w, t, !1);
        },
        toggleWithoutFocusing: (w) => {
          o3(w, t, !0);
        },
        isOpen: (w) => BY(w, t)
      },
      domModification: { attributes: { role: "group" } }
    };
  }, wM = Wl({
    name: "SplitSlidingToolbar",
    configFields: D7(),
    partFields: FY(),
    factory: R7,
    apis: {
      setGroups: (t, r, l) => {
        t.setGroups(r, l);
      },
      refresh: (t, r) => {
        t.refresh(r);
      },
      toggle: (t, r) => {
        t.toggle(r);
      },
      isOpen: (t, r) => t.isOpen(r)
    }
  }), N7 = (t) => {
    const r = t.title.fold(() => ({}), (l) => ({ attributes: { title: l } }));
    return {
      dom: {
        tag: "div",
        classes: ["tox-toolbar__group"],
        ...r
      },
      components: [n3.parts.items({})],
      items: t.items,
      markers: { itemSelector: "*:not(.tox-split-button) > .tox-tbtn:not([disabled]), .tox-split-button:not([disabled]), .tox-toolbar-nav-js:not([disabled]), .tox-number-input:not([disabled])" },
      tgroupBehaviours: Jt([
        jr.config({}),
        To.config({})
      ])
    };
  }, r3 = (t) => n3.sketch(N7(t)), CM = (t, r) => {
    const l = qr((d) => {
      const h = et(t.initGroups, r3);
      ip.setGroups(d, h);
    });
    return Jt([
      dm.toolbarButton(t.providers.isDisabled),
      ki(),
      so.config({
        mode: r,
        onEscape: t.onEscape,
        selector: ".tox-toolbar__group"
      }),
      jo("toolbar-events", [l])
    ]);
  }, P7 = (t) => {
    const r = t.cyclicKeying ? "cyclic" : "acyclic";
    return {
      uid: t.uid,
      dom: {
        tag: "div",
        classes: ["tox-toolbar-overlord"]
      },
      parts: {
        "overflow-group": N7({
          title: B.none(),
          items: []
        }),
        "overflow-button": oK({
          name: "more",
          icon: B.some("more-drawer"),
          enabled: !0,
          tooltip: B.some("Reveal or hide additional toolbar items"),
          primary: !1,
          buttonType: B.none(),
          borderless: !1
        }, B.none(), t.providers, [], "overflow-button")
      },
      splitToolbarBehaviours: CM(t, r)
    };
  }, LY = (t) => {
    const r = P7(t), l = 4, d = xM.parts.primary({
      dom: {
        tag: "div",
        classes: ["tox-toolbar__primary"]
      }
    });
    return xM.sketch({
      ...r,
      lazySink: t.getSink,
      getOverflowBounds: () => {
        const h = t.moreDrawerData.lazyHeader().element, y = Cl(h), w = Oi(h), E = Cl(w), O = Math.max(w.dom.scrollHeight, E.height);
        return Nr(y.x + l, E.y, y.width - l * 2, O);
      },
      parts: {
        ...r.parts,
        overflow: {
          dom: {
            tag: "div",
            classes: ["tox-toolbar__overflow"],
            attributes: t.attributes
          }
        }
      },
      components: [d],
      markers: { overflowToggledClass: "tox-tbtn--enabled" },
      onOpened: (h) => t.onToggled(h, !0),
      onClosed: (h) => t.onToggled(h, !1)
    });
  }, $Y = (t) => {
    const r = wM.parts.primary({
      dom: {
        tag: "div",
        classes: ["tox-toolbar__primary"]
      }
    }), l = wM.parts.overflow({
      dom: {
        tag: "div",
        classes: ["tox-toolbar__overflow"]
      }
    }), d = P7(t);
    return wM.sketch({
      ...d,
      components: [
        r,
        l
      ],
      markers: {
        openClass: "tox-toolbar__overflow--open",
        closedClass: "tox-toolbar__overflow--closed",
        growingClass: "tox-toolbar__overflow--growing",
        shrinkingClass: "tox-toolbar__overflow--shrinking",
        overflowToggledClass: "tox-tbtn--enabled"
      },
      onOpened: (h) => {
        h.getSystem().broadcastOn([aM()], { type: "opened" }), t.onToggled(h, !0);
      },
      onClosed: (h) => {
        h.getSystem().broadcastOn([aM()], { type: "closed" }), t.onToggled(h, !1);
      }
    });
  }, a3 = (t) => {
    const r = t.cyclicKeying ? "cyclic" : "acyclic";
    return ip.sketch({
      uid: t.uid,
      dom: {
        tag: "div",
        classes: ["tox-toolbar"].concat(t.type === ed.scrolling ? ["tox-toolbar--scrolling"] : [])
      },
      components: [ip.parts.groups({})],
      toolbarBehaviours: CM(t, r)
    });
  }, M7 = [
    vb,
    yf,
    Ua("tooltip"),
    gu("buttonType", "secondary", [
      "primary",
      "secondary"
    ]),
    Ea("borderless", !1),
    Tc("onAction")
  ], HY = [
    ...M7,
    zg,
    Yi("type", ["button"])
  ], zY = [
    ...M7,
    Ea("active", !1),
    Yi("type", ["togglebutton"])
  ], I7 = {
    button: HY,
    togglebutton: zY
  }, VY = [
    Yi("type", ["group"]),
    I("buttons", [], ui("type", I7))
  ], UY = ui("type", {
    ...I7,
    group: VY
  }), F7 = xo([
    I("buttons", [], UY),
    Tc("onShow"),
    Tc("onHide")
  ]), jY = (t) => ra("view", F7, t), WY = (t, r) => {
    var l, d;
    const h = t.type === "togglebutton", y = t.icon.map((qe) => Zg(qe, r.icons)).map(rr), E = (qe) => {
      const Bt = (bn) => {
        y.map((It) => It.getOpt(qe).each((Yn) => {
          Po.set(Yn, [Zg(bn, r.icons)]);
        }));
      }, pt = (bn) => {
        const It = qe.element;
        bn ? (Vr(It, "tox-button--enabled"), sn(It, "aria-pressed", !0)) : (ba(It, "tox-button--enabled"), Ee(It, "aria-pressed"));
      }, en = () => Kc(qe.element, "tox-button--enabled");
      if (h)
        return t.onAction({
          setIcon: Bt,
          setActive: pt,
          isActive: en
        });
      if (t.type === "button")
        return t.onAction({ setIcon: Bt });
    }, O = {
      ...t,
      name: h ? t.text.getOr(t.icon.getOr("")) : (l = t.text) !== null && l !== void 0 ? l : t.icon.getOr(""),
      primary: t.buttonType === "primary",
      buttonType: B.from(t.buttonType),
      tooltip: t.tooltip,
      icon: t.icon,
      enabled: !0,
      borderless: t.borderless
    }, F = jA((d = t.buttonType) !== null && d !== void 0 ? d : "secondary"), L = h ? t.text.map(r.translate) : B.some(r.translate(t.text)), q = L.map(Aa), ne = O.tooltip.or(L).map((qe) => ({ "aria-label": r.translate(qe) })).getOr({}), ae = y.map((qe) => qe.asSpec()), de = e0([
      ae,
      q
    ]), _e = t.icon.isSome() && q.isSome(), st = {
      tag: "button",
      classes: F.concat(...t.icon.isSome() && !_e ? ["tox-button--icon"] : []).concat(..._e ? ["tox-button--icon-and-text"] : []).concat(...t.borderless ? ["tox-button--naked"] : []).concat(...t.type === "togglebutton" && t.active ? ["tox-button--enabled"] : []),
      attributes: ne
    }, Re = [], Qe = e2(O, B.some(E), Re, st, de, t.tooltip, r);
    return Nl.sketch(Qe);
  }, i3 = (t, r) => WY(t, r), ZY = (t, r) => ({
    dom: {
      tag: "div",
      classes: ["tox-view__toolbar__group"]
    },
    components: et(t.buttons, (l) => i3(l, r))
  }), lk = $l().deviceType, GY = lk.isPhone(), B7 = lk.isTablet(), qY = (t) => {
    let r = !1;
    const l = et(t.buttons, (d) => d.type === "group" ? (r = !0, ZY(d, t.providers)) : i3(d, t.providers));
    return {
      uid: t.uid,
      dom: {
        tag: "div",
        classes: [
          r ? "tox-view__toolbar" : "tox-view__header",
          ...GY || B7 ? [
            "tox-view--mobile",
            "tox-view--scrolling"
          ] : []
        ]
      },
      behaviours: Jt([
        To.config({}),
        so.config({
          mode: "flow",
          selector: "button, .tox-button",
          focusInside: Mg.OnEnterOrSpaceMode
        })
      ]),
      components: r ? l : [
        op.sketch({
          dom: {
            tag: "div",
            classes: ["tox-view__header-start"]
          },
          components: []
        }),
        op.sketch({
          dom: {
            tag: "div",
            classes: ["tox-view__header-end"]
          },
          components: l
        })
      ]
    };
  }, KY = (t) => ({
    uid: t.uid,
    behaviours: Jt([
      To.config({}),
      jr.config({})
    ]),
    dom: {
      tag: "div",
      classes: ["tox-view__pane"]
    }
  }), uae = (t, r, l, d) => {
    const h = {
      getPane: (y) => ol.getPart(y, t, "pane"),
      getOnShow: (y) => t.viewConfig.onShow,
      getOnHide: (y) => t.viewConfig.onHide
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: r,
      behaviours: Jt([
        To.config({}),
        so.config({
          mode: "cyclic",
          focusInside: Mg.OnEnterOrSpaceMode
        })
      ]),
      apis: h
    };
  };
  var c2 = Wl({
    name: "silver.View",
    configFields: [Mt("viewConfig")],
    partFields: [
      Su({
        factory: { sketch: qY },
        schema: [
          Mt("buttons"),
          Mt("providers")
        ],
        name: "header"
      }),
      Su({
        factory: { sketch: KY },
        schema: [],
        name: "pane"
      })
    ],
    factory: uae,
    apis: {
      getPane: (t, r) => t.getPane(r),
      getOnShow: (t, r) => t.getOnShow(r),
      getOnHide: (t, r) => t.getOnHide(r)
    }
  });
  const YY = (t, r, l) => ta(r, (d, h) => {
    const y = Gt(jY(d));
    return t.slot(h, c2.sketch({
      dom: {
        tag: "div",
        classes: ["tox-view"]
      },
      viewConfig: y,
      components: [
        ...y.buttons.length > 0 ? [c2.parts.header({
          buttons: y.buttons,
          providers: l
        })] : [],
        c2.parts.pane({})
      ]
    }));
  }), SM = (t, r) => bl.sketch((l) => ({
    dom: {
      tag: "div",
      classes: ["tox-view-wrap__slot-container"]
    },
    components: YY(l, t, r),
    slotBehaviours: Px.unnamedEvents([qr((d) => bl.hideAllSlots(d))])
  })), L7 = (t) => Nt(bl.getSlotNames(t), (r) => bl.isShowing(t, r)), l3 = (t) => {
    const r = t.element;
    Ln(r, "display", "none"), sn(r, "aria-hidden", "true");
  }, $7 = (t) => {
    const r = t.element;
    gs(r, "display"), Ee(r, "aria-hidden");
  }, H7 = (t) => ({ getContainer: ee(t) }), c3 = (t, r, l) => {
    bl.getSlot(t, r).each((d) => {
      c2.getPane(d).each((h) => {
        l(d)(H7(h.element.dom));
      });
    });
  }, XY = (t, r) => c3(t, r, c2.getOnShow), z7 = (t, r) => c3(t, r, c2.getOnHide);
  var uk = Nc({
    factory: (t, r) => {
      const y = {
        setViews: (w, E) => {
          Po.set(w, [SM(E, r.backstage.shared.providers)]);
        },
        whichView: (w) => Ds.getCurrent(w).bind(L7),
        toggleView: (w, E, O, F) => Ds.getCurrent(w).exists((L) => {
          const q = L7(L), ne = q.exists((de) => F === de), ae = bl.getSlot(L, F).isSome();
          return ae && (bl.hideAllSlots(L), ne ? (l3(w), E()) : (O(), $7(w), bl.showSlot(L, F), XY(L, F)), q.each((de) => z7(L, de))), ae;
        })
      };
      return {
        uid: t.uid,
        dom: {
          tag: "div",
          classes: ["tox-view-wrap"],
          attributes: { "aria-hidden": "true" },
          styles: { display: "none" }
        },
        components: [],
        behaviours: Jt([
          Po.config({}),
          Ds.config({
            find: (w) => {
              const E = Po.contents(w);
              return ao(E);
            }
          })
        ]),
        apis: y
      };
    },
    name: "silver.ViewWrapper",
    configFields: [Mt("backstage")],
    apis: {
      setViews: (t, r, l) => t.setViews(r, l),
      toggleView: (t, r, l, d, h) => t.toggleView(r, l, d, h),
      whichView: (t, r) => t.whichView(r)
    }
  });
  const QY = (t, r, l) => {
    let d = !1;
    const h = (w) => {
      lc(w, ".tox-statusbar").each((E) => {
        lr(E, "display") === "none" && tr(E, "aria-hidden") === "true" ? (gs(E, "display"), Ee(E, "aria-hidden")) : (Ln(E, "display", "none"), sn(E, "aria-hidden", "true"));
      });
    }, y = {
      getSocket: (w) => ol.getPart(w, t, "socket"),
      setSidebar: (w, E, O) => {
        ol.getPart(w, t, "sidebar").each((F) => mM(F, E, O));
      },
      toggleSidebar: (w, E) => {
        ol.getPart(w, t, "sidebar").each((O) => hY(O, E));
      },
      whichSidebar: (w) => ol.getPart(w, t, "sidebar").bind(pM).getOrNull(),
      getHeader: (w) => ol.getPart(w, t, "header"),
      getToolbar: (w) => ol.getPart(w, t, "toolbar"),
      setToolbar: (w, E) => {
        ol.getPart(w, t, "toolbar").each((O) => {
          const F = et(E, r3);
          O.getApis().setGroups(O, F);
        });
      },
      setToolbars: (w, E) => {
        ol.getPart(w, t, "multiple-toolbar").each((O) => {
          const F = et(E, (L) => et(L, r3));
          i7.setItems(O, F);
        });
      },
      refreshToolbar: (w) => {
        ol.getPart(w, t, "toolbar").each((O) => O.getApis().refresh(O));
      },
      toggleToolbarDrawer: (w) => {
        ol.getPart(w, t, "toolbar").each((E) => {
          _s(E.getApis().toggle, (O) => O(E));
        });
      },
      toggleToolbarDrawerWithoutFocusing: (w) => {
        ol.getPart(w, t, "toolbar").each((E) => {
          _s(E.getApis().toggleWithoutFocusing, (O) => O(E));
        });
      },
      isToolbarDrawerToggled: (w) => ol.getPart(w, t, "toolbar").bind((E) => B.from(E.getApis().isOpen).map((O) => O(E))).getOr(!1),
      getThrobber: (w) => ol.getPart(w, t, "throbber"),
      focusToolbar: (w) => {
        ol.getPart(w, t, "toolbar").orThunk(() => ol.getPart(w, t, "multiple-toolbar")).each((O) => {
          so.focusIn(O);
        });
      },
      setMenubar: (w, E) => {
        ol.getPart(w, t, "menubar").each((O) => {
          uM.setMenus(O, E);
        });
      },
      focusMenubar: (w) => {
        ol.getPart(w, t, "menubar").each((E) => {
          uM.focus(E);
        });
      },
      setViews: (w, E) => {
        ol.getPart(w, t, "viewWrapper").each((O) => {
          uk.setViews(O, E);
        });
      },
      toggleView: (w, E) => ol.getPart(w, t, "viewWrapper").exists((O) => uk.toggleView(O, () => y.showMainView(w), () => y.hideMainView(w), E)),
      whichView: (w) => ol.getPart(w, t, "viewWrapper").bind(uk.whichView).getOrNull(),
      hideMainView: (w) => {
        d = y.isToolbarDrawerToggled(w), d && y.toggleToolbarDrawer(w), ol.getPart(w, t, "editorContainer").each((E) => {
          const O = E.element;
          h(O), Ln(O, "display", "none"), sn(O, "aria-hidden", "true");
        });
      },
      showMainView: (w) => {
        d && y.toggleToolbarDrawer(w), ol.getPart(w, t, "editorContainer").each((E) => {
          const O = E.element;
          h(O), gs(O, "display"), Ee(O, "aria-hidden");
        });
      }
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: r,
      apis: y,
      behaviours: t.behaviours
    };
  }, JY = qg.optional({
    factory: uM,
    name: "menubar",
    schema: [Mt("backstage")]
  }), eX = (t) => t.type === ed.sliding ? $Y : t.type === ed.floating ? LY : a3, kM = qg.optional({
    factory: {
      sketch: (t) => i7.sketch({
        uid: t.uid,
        dom: t.dom,
        listBehaviours: Jt([so.config({
          mode: "acyclic",
          selector: ".tox-toolbar"
        })]),
        makeItem: () => a3({
          type: t.type,
          uid: Mn("multiple-toolbar-item"),
          cyclicKeying: !1,
          initGroups: [],
          providers: t.providers,
          onEscape: () => (t.onEscape(), B.some(!0))
        }),
        setupItem: (r, l, d, h) => {
          ip.setGroups(l, d);
        },
        shell: !0
      })
    },
    name: "multiple-toolbar",
    schema: [
      Mt("dom"),
      Mt("onEscape")
    ]
  }), tX = qg.optional({
    factory: {
      sketch: (t) => {
        const r = eX(t), l = {
          type: t.type,
          uid: t.uid,
          onEscape: () => (t.onEscape(), B.some(!0)),
          onToggled: (d, h) => t.onToolbarToggled(h),
          cyclicKeying: !1,
          initGroups: [],
          getSink: t.getSink,
          providers: t.providers,
          moreDrawerData: {
            lazyToolbar: t.lazyToolbar,
            lazyMoreButton: t.lazyMoreButton,
            lazyHeader: t.lazyHeader
          },
          attributes: t.attributes
        };
        return r(l);
      }
    },
    name: "toolbar",
    schema: [
      Mt("dom"),
      Mt("onEscape"),
      Mt("getSink")
    ]
  }), nX = qg.optional({
    factory: { sketch: s2 },
    name: "header",
    schema: [Mt("dom")]
  }), V7 = qg.optional({
    factory: { sketch: cY },
    name: "promotion",
    schema: [Mt("dom")]
  }), U7 = qg.optional({
    name: "socket",
    schema: [Mt("dom")]
  }), u3 = qg.optional({
    factory: { sketch: gY },
    name: "sidebar",
    schema: [Mt("dom")]
  }), _M = qg.optional({
    factory: { sketch: S7 },
    name: "throbber",
    schema: [Mt("dom")]
  }), oX = qg.optional({
    factory: uk,
    name: "viewWrapper",
    schema: [Mt("backstage")]
  }), sX = (t) => ({
    uid: t.uid,
    dom: {
      tag: "div",
      classes: ["tox-editor-container"]
    },
    components: t.components
  }), j7 = qg.optional({
    factory: { sketch: sX },
    name: "editorContainer",
    schema: []
  });
  var Wr = Wl({
    name: "OuterContainer",
    factory: QY,
    configFields: [
      Mt("dom"),
      Mt("behaviours")
    ],
    partFields: [
      nX,
      JY,
      tX,
      kM,
      U7,
      u3,
      V7,
      _M,
      oX,
      j7
    ],
    apis: {
      getSocket: (t, r) => t.getSocket(r),
      setSidebar: (t, r, l, d) => {
        t.setSidebar(r, l, d);
      },
      toggleSidebar: (t, r, l) => {
        t.toggleSidebar(r, l);
      },
      whichSidebar: (t, r) => t.whichSidebar(r),
      getHeader: (t, r) => t.getHeader(r),
      getToolbar: (t, r) => t.getToolbar(r),
      setToolbar: (t, r, l) => {
        t.setToolbar(r, l);
      },
      setToolbars: (t, r, l) => {
        t.setToolbars(r, l);
      },
      refreshToolbar: (t, r) => t.refreshToolbar(r),
      toggleToolbarDrawer: (t, r) => {
        t.toggleToolbarDrawer(r);
      },
      toggleToolbarDrawerWithoutFocusing: (t, r) => {
        t.toggleToolbarDrawerWithoutFocusing(r);
      },
      isToolbarDrawerToggled: (t, r) => t.isToolbarDrawerToggled(r),
      getThrobber: (t, r) => t.getThrobber(r),
      setMenubar: (t, r, l) => {
        t.setMenubar(r, l);
      },
      focusMenubar: (t, r) => {
        t.focusMenubar(r);
      },
      focusToolbar: (t, r) => {
        t.focusToolbar(r);
      },
      setViews: (t, r, l) => {
        t.setViews(r, l);
      },
      toggleView: (t, r, l) => t.toggleView(r, l),
      whichView: (t, r) => t.whichView(r)
    }
  });
  const rX = "file edit view insert format tools table help", W7 = {
    file: {
      title: "File",
      items: "newdocument restoredraft | preview | importword exportpdf exportword | export print | deleteallconversations"
    },
    edit: {
      title: "Edit",
      items: "undo redo | cut copy paste pastetext | selectall | searchreplace"
    },
    view: {
      title: "View",
      items: "code revisionhistory | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments"
    },
    insert: {
      title: "Insert",
      items: "image link media addcomment pageembed inserttemplate codesample inserttable accordion math | charmap emoticons hr | pagebreak nonbreaking anchor tableofcontents footnotes | mergetags | insertdatetime"
    },
    format: {
      title: "Format",
      items: "bold italic underline strikethrough superscript subscript codeformat | styles blocks fontfamily fontsize align lineheight | forecolor backcolor | language | removeformat"
    },
    tools: {
      title: "Tools",
      items: "aidialog aishortcuts | spellchecker spellcheckerlanguage | autocorrect capitalization | a11ycheck code typography wordcount addtemplate"
    },
    table: {
      title: "Table",
      items: "inserttable | cell row column | advtablesort | tableprops deletetable"
    },
    help: {
      title: "Help",
      items: "help"
    }
  }, Z7 = (t, r, l) => {
    const d = bR(l).split(/[ ,]/);
    return {
      text: t.title,
      getItems: () => je(t.items, (h) => {
        const y = h.toLowerCase();
        return y.trim().length === 0 ? [] : Ro(d, (w) => w === y) ? [] : y === "separator" || y === "|" ? [{ type: "separator" }] : r.menuItems[y] ? [r.menuItems[y]] : [];
      })
    };
  }, EM = (t) => t.split(" "), G7 = (t, r) => {
    const l = {
      ...W7,
      ...r.menus
    }, d = os(r.menus).length > 0, h = r.menubar === void 0 || r.menubar === !0 ? EM(rX) : EM(r.menubar === !1 ? "" : r.menubar), y = So(h, (E) => {
      const O = Ko(W7, E);
      return d ? O || qt(r.menus, E).exists((F) => Ko(F, "items")) : O;
    }), w = et(y, (E) => {
      const O = l[E];
      return Z7({
        title: O.title,
        items: EM(O.items)
      }, r, t);
    });
    return So(w, (E) => {
      const O = (F) => A(F) || F.type !== "separator";
      return E.getItems().length > 0 && Ro(E.getItems(), O);
    });
  }, TM = (t) => {
    const r = () => {
      t._skinLoaded = !0, IW(t);
    };
    return () => {
      t.initialized ? r() : t.on("init", r);
    };
  }, aX = (t, r) => () => FW(t, { message: r }), q7 = (t, r, l) => (t.on("remove", () => l.unload(r)), l.load(r)), d3 = (t, r, l, d) => (t.on("remove", () => d.unloadRawCss(r)), d.loadRawCss(r, l)), iX = async (t, r) => {
    const d = "ui/" + bT(t).getOr("default") + "/skin.css", h = tinymce.Resource.get(d);
    if (A(h))
      d3(t, d, h, t.ui.styleSheetLoader);
    else {
      const y = t.editorManager.suffix, w = r + `/skin${y}.css`;
      return q7(t, w, t.ui.styleSheetLoader);
    }
  }, K7 = async (t, r) => {
    if (Ge($e.fromDom(t.getElement()))) {
      const h = "ui/" + bT(t).getOr("default") + "/skin.shadowdom.css", y = tinymce.Resource.get(h);
      if (A(y))
        d3(t, h, y, j1.DOM.styleSheetLoader);
      else {
        const w = t.editorManager.suffix, E = r + `/skin.shadowdom${w}.css`;
        return q7(t, E, j1.DOM.styleSheetLoader);
      }
    }
  }, lX = async (t, r) => {
    const l = () => {
      const h = ER(r), y = r.editorManager.suffix;
      h && r.contentCSS.push(h + (t ? "/content.inline" : "/content") + `${y}.css`);
    };
    bT(r).fold(l, (h) => {
      const y = "ui/" + h + (t ? "/content.inline" : "/content") + ".css", w = tinymce.Resource.get(y);
      A(w) ? d3(r, y, w, r.ui.styleSheetLoader) : l();
    });
    const d = ER(r);
    if (!_R(r) && A(d))
      return Promise.all([
        iX(r, d),
        K7(r, d)
      ]).then();
  }, AM = (t, r) => lX(t, r).then(TM(r), aX(r, "Skin could not be loaded")), cX = Vt(AM, !1), uX = Vt(AM, !0), u2 = (t, r, l) => Ae(l) ? t.translate(r) : t.translate([
    r,
    t.translate(l)
  ]), Y7 = (t, r) => {
    const l = (w, E, O, F) => {
      const L = t.shared.providers.translate(w.title);
      if (w.type === "separator")
        return B.some({
          type: "separator",
          text: L
        });
      if (w.type === "submenu") {
        const q = je(w.getStyleItems(), (ne) => d(ne, E, F));
        return E === 0 && q.length <= 0 ? B.none() : B.some({
          type: "nestedmenuitem",
          text: L,
          enabled: q.length > 0,
          getSubmenuItems: () => je(w.getStyleItems(), (ne) => d(ne, E, F))
        });
      } else
        return B.some({
          type: "togglemenuitem",
          text: L,
          icon: w.icon,
          active: w.isSelected(F),
          enabled: !O,
          onAction: r.onAction(w),
          ...w.getStylePreview().fold(() => ({}), (q) => ({ meta: { style: q } }))
        });
    }, d = (w, E, O) => {
      const F = w.type === "formatter" && r.isInvalid(w);
      return E === 0 ? F ? [] : l(w, E, !1, O).toArray() : l(w, E, F, O).toArray();
    }, h = (w) => {
      const E = r.getCurrentValue(), O = r.shouldHide ? 0 : 1;
      return je(w, (F) => d(F, O, E));
    };
    return {
      validateItems: h,
      getFetch: (w, E) => (O, F) => {
        const L = E(), q = h(L), ne = Qx(q, im.CLOSE_ON_EXECUTE, w, {
          isHorizontalMenu: !1,
          search: B.none()
        });
        F(ne);
      }
    };
  }, d2 = (t, r) => {
    const l = r.dataset, d = l.type === "basic" ? () => et(l.data, (h) => V8(h, r.isSelectedFor, r.getPreviewFor)) : l.getData;
    return {
      items: Y7(t, r),
      getStyleItems: d
    };
  }, dk = (t, r, l, d, h, y) => {
    const { items: w, getStyleItems: E } = d2(r, l), O = to(l.tooltip), F = (q) => ({
      getComponent: ee(q),
      setTooltip: (ne) => {
        const ae = r.shared.providers.translate(ne);
        sn(q.element, "aria-label", ae), O.set(ne);
      }
    }), L = (q) => {
      const ne = (ae) => q.setTooltip(u2(t, d(ae.value), ae.value));
      return t.on(h, ne), ES(o0(t, "NodeChange", (ae) => {
        const de = ae.getComponent();
        l.updateText(de), _o.set(ae.getComponent(), !t.selection.isEditable());
      })(q), () => t.off(h, ne));
    };
    return PA({
      text: l.icon.isSome() ? B.none() : l.text,
      icon: l.icon,
      ariaLabel: B.some(l.tooltip),
      tooltip: B.none(),
      role: B.none(),
      fetch: w.getFetch(r, E),
      onSetup: L,
      getApi: F,
      columns: 1,
      presets: "normal",
      classes: l.icon.isSome() ? [] : ["bespoke"],
      dropdownBehaviours: [gl.config({
        ...r.shared.providers.tooltips.getConfig({
          tooltipText: r.shared.providers.translate(l.tooltip),
          onShow: (q) => {
            if (l.tooltip !== O.get()) {
              const ne = r.shared.providers.translate(O.get());
              gl.setComponents(q, r.shared.providers.tooltips.getComponents({ tooltipText: ne }));
            }
          }
        })
      })]
    }, "tox-tbtn", r.shared, y);
  }, dX = (t) => et(t, (r) => {
    let l = r, d = r;
    const h = r.split("=");
    return h.length > 1 && (l = h[0], d = h[1]), {
      title: l,
      format: d
    };
  }), OM = (t) => ({
    type: "basic",
    data: t
  });
  var _b;
  (function(t) {
    t[t.SemiColon = 0] = "SemiColon", t[t.Space = 1] = "Space";
  })(_b || (_b = {}));
  const fX = (t, r) => r === _b.SemiColon ? t.replace(/;$/, "").split(";") : t.split(" "), DM = (t, r, l) => {
    const d = t.options.get(r);
    return {
      type: "basic",
      data: dX(fX(d, l))
    };
  }, mX = "Align", X7 = ee("Alignment {0}"), Q7 = "left", RM = [
    {
      title: "Left",
      icon: "align-left",
      format: "alignleft",
      command: "JustifyLeft"
    },
    {
      title: "Center",
      icon: "align-center",
      format: "aligncenter",
      command: "JustifyCenter"
    },
    {
      title: "Right",
      icon: "align-right",
      format: "alignright",
      command: "JustifyRight"
    },
    {
      title: "Justify",
      icon: "align-justify",
      format: "alignjustify",
      command: "JustifyFull"
    }
  ], J7 = (t) => {
    const r = () => Nt(RM, (E) => t.formatter.match(E.format)), l = (E) => () => t.formatter.match(E), d = (E) => B.none, h = (E) => {
      const F = r().fold(ee(Q7), (L) => L.title.toLowerCase());
      po(E, wb, { icon: `align-${F}` }), VW(t, { value: F });
    }, y = OM(RM), w = (E) => () => Nt(RM, (O) => O.format === E.format).each((O) => t.execCommand(O.command));
    return {
      tooltip: u2(t, X7(), Q7),
      text: B.none(),
      icon: B.some("align-left"),
      isSelectedFor: l,
      getCurrentValue: B.none,
      getPreviewFor: d,
      onAction: w,
      updateText: h,
      dataset: y,
      shouldHide: !1,
      isInvalid: (E) => !t.formatter.canApply(E.format)
    };
  }, pX = (t, r) => dk(t, r, J7(t), X7, "AlignTextUpdate", "align"), hX = (t, r) => {
    const l = d2(r, J7(t));
    t.ui.registry.addNestedMenuItem("align", {
      text: r.shared.providers.translate(mX),
      onSetup: Mc(t),
      getSubmenuItems: () => l.items.validateItems(l.getStyleItems())
    });
  }, NM = (t, r) => {
    const l = r(), d = et(l, (h) => h.format);
    return B.from(t.formatter.closest(d)).bind((h) => Nt(l, (y) => y.format === h));
  }, f3 = "Blocks", m3 = ee("Block {0}"), p3 = "Paragraph", Kg = (t) => {
    const r = (y) => () => t.formatter.match(y), l = (y) => () => {
      const w = t.formatter.get(y);
      return w ? B.some({
        tag: w.length > 0 && (w[0].inline || w[0].block) || "div",
        styles: t.dom.parseStyle(t.formatter.getCssText(y))
      }) : B.none();
    }, d = (y) => {
      const E = NM(t, () => h.data).fold(ee(p3), (O) => O.title);
      po(y, Ef, { text: E }), ZL(t, { value: E });
    }, h = DM(t, "block_formats", _b.SemiColon);
    return {
      tooltip: u2(t, m3(), p3),
      text: B.some(p3),
      icon: B.none(),
      isSelectedFor: r,
      getCurrentValue: B.none,
      getPreviewFor: l,
      onAction: GL(t),
      updateText: d,
      dataset: h,
      shouldHide: !1,
      isInvalid: (y) => !t.formatter.canApply(y.format)
    };
  }, eH = (t, r) => dk(t, r, Kg(t), m3, "BlocksTextUpdate", "blocks"), gX = (t, r) => {
    const l = d2(r, Kg(t));
    t.ui.registry.addNestedMenuItem("blocks", {
      text: f3,
      onSetup: Mc(t),
      getSubmenuItems: () => l.items.validateItems(l.getStyleItems())
    });
  }, vX = "Fonts", tH = ee("Font {0}"), PM = "System Font", bX = [
    "-apple-system",
    "Segoe UI",
    "Roboto",
    "Helvetica Neue",
    "sans-serif"
  ], nH = (t) => {
    const r = t.split(/\s*,\s*/);
    return et(r, (l) => l.replace(/^['"]+|['"]+$/g, ""));
  }, oH = (t, r) => r.length > 0 && An(r, (l) => t.indexOf(l.toLowerCase()) > -1), sH = (t, r) => {
    if (t.indexOf("-apple-system") === 0 || r.length > 0) {
      const l = nH(t.toLowerCase());
      return oH(l, bX) || oH(l, r);
    } else
      return !1;
  }, rH = (t) => {
    const r = () => {
      const O = (de) => de ? nH(de)[0] : "", F = t.queryCommandValue("FontName"), L = E.data, q = F ? F.toLowerCase() : "", ne = AB(t);
      return {
        matchOpt: Nt(L, (de) => {
          const _e = de.format;
          return _e.toLowerCase() === q || O(_e).toLowerCase() === O(q).toLowerCase();
        }).orThunk(() => Xn(sH(q, ne), {
          title: PM,
          format: q
        })),
        font: F
      };
    }, l = (O) => (F) => F.exists((L) => L.format === O), d = () => {
      const { matchOpt: O } = r();
      return O;
    }, h = (O) => () => B.some({
      tag: "div",
      styles: O.indexOf("dings") === -1 ? { "font-family": O } : {}
    }), y = (O) => () => {
      t.undoManager.transact(() => {
        t.focus(), t.execCommand("FontName", !1, O.format);
      });
    }, w = (O) => {
      const { matchOpt: F, font: L } = r(), q = F.fold(ee(L), (ne) => ne.title);
      po(O, Ef, { text: q }), UW(t, { value: q });
    }, E = DM(t, "font_family_formats", _b.SemiColon);
    return {
      tooltip: u2(t, tH(), PM),
      text: B.some(PM),
      icon: B.none(),
      isSelectedFor: l,
      getCurrentValue: d,
      getPreviewFor: h,
      onAction: y,
      updateText: w,
      dataset: E,
      shouldHide: !1,
      isInvalid: _t
    };
  }, yX = (t, r) => dk(t, r, rH(t), tH, "FontFamilyTextUpdate", "fontfamily"), MM = (t, r) => {
    const l = d2(r, rH(t));
    t.ui.registry.addNestedMenuItem("fontfamily", {
      text: r.shared.providers.translate(vX),
      onSetup: Mc(t),
      getSubmenuItems: () => l.items.validateItems(l.getStyleItems())
    });
  }, xX = {
    unsupportedLength: [
      "em",
      "ex",
      "cap",
      "ch",
      "ic",
      "rem",
      "lh",
      "rlh",
      "vw",
      "vh",
      "vi",
      "vb",
      "vmin",
      "vmax",
      "cm",
      "mm",
      "Q",
      "in",
      "pc",
      "pt",
      "px"
    ],
    fixed: [
      "px",
      "pt"
    ],
    relative: ["%"],
    empty: [""]
  }, wX = (() => {
    const t = "[0-9]+", l = "[eE]" + ("[+-]?" + t), d = "\\.", h = (E) => `(?:${E})?`, w = `[+-]?(?:${[
      "Infinity",
      t + d + h(t) + h(l),
      d + t + h(l),
      t + h(l)
    ].join("|")})`;
    return new RegExp(`^(${w})(.*)$`);
  })(), CX = (t, r) => Ro(r, (l) => Ro(xX[l], (d) => t === d)), h3 = (t, r) => B.from(wX.exec(t)).bind((d) => {
    const h = Number(d[1]), y = d[2];
    return CX(y, r) ? B.some({
      value: h,
      unit: y
    }) : B.none();
  }), SX = (t, r) => h3(t, r).map(({ value: l, unit: d }) => l + d), aH = {
    tab: ee(9),
    escape: ee(27),
    enter: ee(13),
    backspace: ee(8),
    delete: ee(46),
    left: ee(37),
    up: ee(38),
    right: ee(39),
    down: ee(40),
    space: ee(32),
    home: ee(36),
    end: ee(35),
    pageUp: ee(33),
    pageDown: ee(34)
  }, iH = (t, r, l, d) => {
    let h = B.none();
    const y = (qe) => qe.map((Bt) => In.getValue(Bt)).getOr(""), w = o0(t, "NodeChange SwitchMode", (qe) => {
      const Bt = qe.getComponent();
      h = B.some(Bt), l.updateInputValue(Bt), _o.set(Bt, !t.selection.isEditable());
    }), E = (qe) => ({ getComponent: ee(qe) }), O = to(U), F = Mn("custom-number-input-events"), L = (qe, Bt, pt) => {
      const en = y(h), bn = l.getNewValue(en, qe), It = en.length - `${bn}`.length, Yn = h.map((yo) => yo.element.dom.selectionStart - It), Fn = h.map((yo) => yo.element.dom.selectionEnd - It);
      l.onAction(bn, pt), h.each((yo) => {
        In.setValue(yo, bn), Bt && (Yn.each((mo) => yo.element.dom.selectionStart = mo), Fn.each((mo) => yo.element.dom.selectionEnd = mo));
      });
    }, q = (qe, Bt) => L((pt, en) => pt - en, qe, Bt), ne = (qe, Bt) => L((pt, en) => pt + en, qe, Bt), ae = (qe) => ji(qe.element).fold(B.none, (Bt) => (vu(Bt), B.some(!0))), de = (qe) => g1(qe.element) ? (Xl(qe.element).each((Bt) => vu(Bt)), B.some(!0)) : B.none(), _e = (qe, Bt, pt, en) => {
      const bn = to(U), It = r.shared.providers.translate(pt), Yn = Mn("altExecuting"), Fn = o0(t, "NodeChange SwitchMode", (mo) => {
        _o.set(mo.getComponent(), !t.selection.isEditable());
      }), yo = (mo) => {
        _o.isDisabled(mo) || qe(!0);
      };
      return Nl.sketch({
        dom: {
          tag: "button",
          attributes: {
            "aria-label": It,
            "data-mce-name": Bt
          },
          classes: en.concat(Bt)
        },
        components: [DP(Bt, r.shared.providers.icons)],
        buttonBehaviours: Jt([
          _o.config({}),
          gl.config(r.shared.providers.tooltips.getConfig({ tooltipText: It })),
          jo(Yn, [
            Vg({
              onSetup: Fn,
              getApi: E
            }, bn),
            hc({ getApi: E }, bn),
            Ft(Ed(), (mo, js) => {
              (js.event.raw.keyCode === aH.space() || js.event.raw.keyCode === aH.enter()) && (_o.isDisabled(mo) || qe(!1));
            }),
            Ft(tg(), yo),
            Ft(Ja(), yo)
          ])
        ]),
        eventOrder: {
          [Ed()]: [
            Yn,
            "keying"
          ],
          [tg()]: [
            Yn,
            "alloy.base.behaviour"
          ],
          [Ja()]: [
            Yn,
            "alloy.base.behaviour"
          ],
          [rc()]: [
            "alloy.base.behaviour",
            Yn,
            "tooltipping"
          ],
          [Zu()]: [
            Yn,
            "tooltipping"
          ]
        }
      });
    }, st = rr(_e((qe) => q(!1, qe), "minus", "Decrease font size", [])), Re = rr(_e((qe) => ne(!1, qe), "plus", "Increase font size", [])), Qe = rr({
      dom: {
        tag: "div",
        classes: ["tox-input-wrapper"]
      },
      components: [Y1.sketch({
        inputBehaviours: Jt([
          _o.config({}),
          jo(F, [
            Vg({
              onSetup: w,
              getApi: E
            }, O),
            hc({ getApi: E }, O)
          ]),
          jo("input-update-display-text", [
            Ft(Ef, (qe, Bt) => {
              In.setValue(qe, Bt.event.text);
            }),
            Ft(Wf(), (qe) => {
              l.onAction(In.getValue(qe));
            }),
            Ft(kv(), (qe) => {
              l.onAction(In.getValue(qe));
            })
          ]),
          so.config({
            mode: "special",
            onEnter: (qe) => (L(lt, !0, !0), B.some(!0)),
            onEscape: ae,
            onUp: (qe) => (ne(!0, !1), B.some(!0)),
            onDown: (qe) => (q(!0, !1), B.some(!0)),
            onLeft: (qe, Bt) => (Bt.cut(), B.none()),
            onRight: (qe, Bt) => (Bt.cut(), B.none())
          })
        ])
      })],
      behaviours: Jt([
        To.config({}),
        so.config({
          mode: "special",
          onEnter: de,
          onSpace: de,
          onEscape: ae
        }),
        jo("input-wrapper-events", [Ft(jf(), (qe) => {
          xt([
            st,
            Re
          ], (Bt) => {
            const pt = $e.fromDom(Bt.get(qe).element.dom);
            g1(pt) && h1(pt);
          });
        })])
      ])
    });
    return {
      dom: {
        tag: "div",
        classes: ["tox-number-input"],
        attributes: { ...be(d) ? { "data-mce-name": d } : {} }
      },
      components: [
        st.asSpec(),
        Qe.asSpec(),
        Re.asSpec()
      ],
      behaviours: Jt([
        To.config({}),
        so.config({
          mode: "flow",
          focusInside: Mg.OnEnterOrSpaceMode,
          cycles: !1,
          selector: "button, .tox-input-wrapper",
          onEscape: (qe) => g1(qe.element) ? B.none() : (vu(qe.element), B.some(!0))
        })
      ])
    };
  }, lH = "Font sizes", IM = ee("Font size {0}"), cH = "12pt", uH = {
    "8pt": "1",
    "10pt": "2",
    "12pt": "3",
    "14pt": "4",
    "18pt": "5",
    "24pt": "6",
    "36pt": "7"
  }, kX = {
    "xx-small": "7pt",
    "x-small": "8pt",
    small: "10pt",
    medium: "12pt",
    large: "14pt",
    "x-large": "18pt",
    "xx-large": "24pt"
  }, _X = (t, r) => {
    const l = Math.pow(10, r);
    return Math.round(t * l) / l;
  }, EX = (t, r) => /[0-9.]+px$/.test(t) ? _X(parseInt(t, 10) * 72 / 96, r || 0) + "pt" : qt(kX, t).getOr(t), dH = (t) => qt(uH, t).getOr(""), fH = (t) => {
    const r = () => {
      let O = B.none();
      const F = E.data, L = t.queryCommandValue("FontSize");
      if (L)
        for (let q = 3; O.isNone() && q >= 0; q--) {
          const ne = EX(L, q), ae = dH(ne);
          O = Nt(F, (de) => de.format === L || de.format === ne || de.format === ae);
        }
      return {
        matchOpt: O,
        size: L
      };
    }, l = (O) => (F) => F.exists((L) => L.format === O), d = () => {
      const { matchOpt: O } = r();
      return O;
    }, h = ee(B.none), y = (O) => () => {
      t.undoManager.transact(() => {
        t.focus(), t.execCommand("FontSize", !1, O.format);
      });
    }, w = (O) => {
      const { matchOpt: F, size: L } = r(), q = F.fold(ee(L), (ne) => ne.title);
      po(O, Ef, { text: q }), ON(t, { value: q });
    }, E = DM(t, "font_size_formats", _b.Space);
    return {
      tooltip: u2(t, IM(), cH),
      text: B.some(cH),
      icon: B.none(),
      isSelectedFor: l,
      getPreviewFor: h,
      getCurrentValue: d,
      onAction: y,
      updateText: w,
      dataset: E,
      shouldHide: !1,
      isInvalid: _t
    };
  }, mH = (t, r) => dk(t, r, fH(t), IM, "FontSizeTextUpdate", "fontsize"), TX = (t) => {
    var r;
    const l = { step: 1 };
    return (r = {
      em: { step: 0.1 },
      cm: { step: 0.1 },
      in: { step: 0.1 },
      pc: { step: 0.1 },
      ch: { step: 0.1 },
      rem: { step: 0.1 }
    }[t]) !== null && r !== void 0 ? r : l;
  }, AX = 16, OX = (t) => t >= 0, DX = (t) => {
    const r = () => t.queryCommandValue("FontSize");
    return {
      updateInputValue: (d) => po(d, Ef, { text: r() }),
      onAction: (d, h) => t.execCommand("FontSize", !1, d, { skip_focus: !h }),
      getNewValue: (d, h) => {
        h3(d, [
          "unsupportedLength",
          "empty"
        ]);
        const y = r(), w = h3(d, [
          "unsupportedLength",
          "empty"
        ]).or(h3(y, [
          "unsupportedLength",
          "empty"
        ])), E = w.map((ne) => ne.value).getOr(AX), O = wR(t), F = w.map((ne) => ne.unit).filter((ne) => ne !== "").getOr(O), L = h(E, TX(F).step), q = `${OX(L) ? L : E}${F}`;
        return q !== y && WL(t, { value: q }), q;
      }
    };
  }, RX = (t, r) => iH(t, r, DX(t), "fontsizeinput"), NX = (t, r) => {
    const l = d2(r, fH(t));
    t.ui.registry.addNestedMenuItem("fontsize", {
      text: lH,
      onSetup: Mc(t),
      getSubmenuItems: () => l.items.validateItems(l.getStyleItems())
    });
  }, PX = "Formats", FM = (t) => Ae(t) ? "Formats" : "Format {0}", pH = (t, r) => {
    const l = "Formats", d = (w) => () => t.formatter.match(w), h = (w) => () => {
      const E = t.formatter.get(w);
      return E !== void 0 ? B.some({
        tag: E.length > 0 && (E[0].inline || E[0].block) || "div",
        styles: t.dom.parseStyle(t.formatter.getCssText(w))
      }) : B.none();
    }, y = (w) => {
      const E = (q) => I8(q) ? je(q.items, E) : F8(q) ? [{
        title: q.title,
        format: q.format
      }] : [], O = je(H8(t), E), L = NM(t, ee(O)).fold(ee({
        title: l,
        tooltipLabel: ""
      }), (q) => ({
        title: q.title,
        tooltipLabel: q.title
      }));
      po(w, Ef, { text: L.title }), zW(t, { value: L.tooltipLabel });
    };
    return {
      tooltip: u2(t, FM(""), ""),
      text: B.some(l),
      icon: B.none(),
      isSelectedFor: d,
      getCurrentValue: B.none,
      getPreviewFor: h,
      onAction: GL(t),
      updateText: y,
      shouldHide: gB(t),
      isInvalid: (w) => !t.formatter.canApply(w.format),
      dataset: r
    };
  }, MX = (t, r) => {
    const l = {
      type: "advanced",
      ...r.styles
    };
    return dk(t, r, pH(t, l), FM, "StylesTextUpdate", "styles");
  }, IX = (t, r) => {
    const l = {
      type: "advanced",
      ...r.styles
    }, d = d2(r, pH(t, l));
    t.ui.registry.addNestedMenuItem("styles", {
      text: PX,
      onSetup: Mc(t),
      getSubmenuItems: () => d.items.validateItems(d.getStyleItems())
    });
  }, FX = ee([
    Mt("toggleClass"),
    Mt("fetch"),
    Gu("onExecute"),
    Xe("getHotspot", B.some),
    Xe("getAnchorOverrides", ee({})),
    nh(),
    Gu("onItemExecute"),
    $s("lazySink"),
    Mt("dom"),
    Os("onOpen"),
    $i("splitDropdownBehaviours", [
      Ia,
      so,
      To
    ]),
    Xe("matchWidth", !1),
    Xe("useMinWidth", !1),
    Xe("eventOrder", {}),
    $s("role"),
    $s("listRole")
  ].concat(uA())), BX = hl({
    factory: Nl,
    schema: [Mt("dom")],
    name: "arrow",
    defaults: () => ({ buttonBehaviours: Jt([To.revoke()]) }),
    overrides: (t) => ({
      dom: {
        tag: "span",
        attributes: { role: "presentation" }
      },
      action: (r) => {
        r.getSystem().getByUid(t.uid).each(Hp);
      },
      buttonBehaviours: Jt([ns.config({
        toggleOnExecute: !1,
        toggleClass: t.toggleClass
      })])
    })
  }), LX = hl({
    factory: Nl,
    schema: [Mt("dom")],
    name: "button",
    defaults: () => ({ buttonBehaviours: Jt([To.revoke()]) }),
    overrides: (t) => ({
      dom: {
        tag: "span",
        attributes: { role: "presentation" }
      },
      action: (r) => {
        r.getSystem().getByUid(t.uid).each((l) => {
          t.onExecute(l, r);
        });
      }
    })
  }), $X = ee([
    BX,
    LX,
    Su({
      factory: {
        sketch: (t) => ({
          uid: t.uid,
          dom: {
            tag: "span",
            styles: { display: "none" },
            attributes: { "aria-hidden": "true" },
            innerHtml: t.text
          }
        })
      },
      schema: [Mt("text")],
      name: "aria-descriptor"
    }),
    Xu({
      schema: [pg()],
      name: "menu",
      defaults: (t) => ({
        onExecute: (r, l) => {
          r.getSystem().getByUid(t.uid).each((d) => {
            t.onItemExecute(d, r, l);
          });
        }
      })
    }),
    b6()
  ]), hH = (t, r, l, d) => {
    const h = (L) => {
      Ds.getCurrent(L).each((q) => {
        yn.highlightFirst(q), so.focusIn(q);
      });
    }, y = (L) => {
      $N(t, lt, L, d, h, Pc.HighlightMenuAndItem).get(U);
    }, w = (L) => (y(L), B.some(!0)), E = (L) => {
      const q = fc(L, t, "button");
      return Hp(q), B.some(!0);
    }, O = {
      ...zr([qr((L, q) => {
        Qt(L, t, "aria-descriptor").each((ae) => {
          const de = Mn("aria");
          sn(ae.element, "id", de), sn(L.element, "aria-describedby", de);
        });
      })]),
      ...aT(B.some(y))
    }, F = {
      repositionMenus: (L) => {
        ns.isOn(L) && VN(L);
      }
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: r,
      apis: F,
      eventOrder: {
        ...t.eventOrder,
        [Wu()]: [
          "disabling",
          "toggling",
          "alloy.base.behaviour"
        ]
      },
      events: O,
      behaviours: Hi(t.splitDropdownBehaviours, [
        Ia.config({
          others: {
            sandbox: (L) => {
              const q = fc(L, t, "arrow");
              return zN(t, L, {
                onOpen: () => {
                  ns.on(q), ns.on(L);
                },
                onClose: () => {
                  ns.off(q), ns.off(L);
                }
              });
            }
          }
        }),
        so.config({
          mode: "special",
          onSpace: E,
          onEnter: E,
          onDown: w
        }),
        To.config({}),
        ns.config({
          toggleOnExecute: !1,
          aria: { mode: "expanded" }
        })
      ]),
      domModification: {
        attributes: {
          role: t.role.getOr("button"),
          "aria-haspopup": !0
        }
      }
    };
  }, g3 = Wl({
    name: "SplitDropdown",
    configFields: FX(),
    partFields: $X(),
    factory: hH,
    apis: { repositionMenus: (t, r) => t.repositionMenus(r) }
  }), gH = (t) => ({
    isEnabled: () => !_o.isDisabled(t),
    setEnabled: (r) => _o.set(t, !r),
    setText: (r) => po(t, Ef, { text: r }),
    setIcon: (r) => po(t, wb, { icon: r })
  }), vH = (t) => ({
    setActive: (r) => {
      ns.set(t, r);
    },
    isActive: () => ns.isOn(t),
    isEnabled: () => !_o.isDisabled(t),
    setEnabled: (r) => _o.set(t, !r),
    setText: (r) => po(t, Ef, { text: r }),
    setIcon: (r) => po(t, wb, { icon: r })
  }), bH = (t, r) => t.map((l) => ({ "aria-label": r.translate(l) })).getOr({}), BM = Mn("focus-button"), v3 = (t, r, l, d, h, y) => {
    const w = r.map((O) => rr(RP(O, "tox-tbtn", h))), E = t.map((O) => rr(Zg(O, h.icons)));
    return {
      dom: {
        tag: "button",
        classes: ["tox-tbtn"].concat(r.isSome() ? ["tox-tbtn--select"] : []),
        attributes: {
          ...bH(l, h),
          ...be(y) ? { "data-mce-name": y } : {}
        }
      },
      components: e0([
        E.map((O) => O.asSpec()),
        w.map((O) => O.asSpec())
      ]),
      eventOrder: {
        [sc()]: [
          "focusing",
          "alloy.base.behaviour",
          h0
        ],
        [rc()]: [
          h0,
          "toolbar-group-button-events"
        ]
      },
      buttonBehaviours: Jt([
        dm.toolbarButton(h.isDisabled),
        ki(),
        jo(h0, [
          qr((O, F) => NA(O)),
          Ft(Ef, (O, F) => {
            w.bind((L) => L.getOpt(O)).each((L) => {
              Po.set(L, [Aa(h.translate(F.event.text))]);
            });
          }),
          Ft(wb, (O, F) => {
            E.bind((L) => L.getOpt(O)).each((L) => {
              Po.set(L, [Zg(F.event.icon, h.icons)]);
            });
          }),
          Ft(sc(), (O, F) => {
            F.event.prevent(), Xo(O, BM);
          })
        ])
      ].concat(d.getOr([])))
    };
  }, HX = (t, r, l, d, h) => {
    const y = r.shared, w = to(U), E = {
      toolbarButtonBehaviours: [],
      getApi: gH,
      onSetup: t.onSetup
    }, O = [jo("toolbar-group-button-events", [
      Vg(E, w),
      hc(E, w)
    ])];
    return kb.sketch({
      lazySink: y.getSink,
      fetch: () => Zl.nu((F) => {
        F(et(l(t.items), r3));
      }),
      markers: { toggledClass: "tox-tbtn--enabled" },
      parts: {
        button: v3(t.icon, t.text, t.tooltip, B.some(O), y.providers, h),
        toolbar: {
          dom: {
            tag: "div",
            classes: ["tox-toolbar__overflow"],
            attributes: d
          }
        }
      }
    });
  }, yH = (t, r, l, d) => {
    var h;
    const y = to(U), w = v3(t.icon, t.text, t.tooltip, B.none(), l, d);
    return Nl.sketch({
      dom: w.dom,
      components: w.components,
      eventOrder: RA,
      buttonBehaviours: {
        ...Jt([
          jo("toolbar-button-events", [
            OP({
              onAction: t.onAction,
              getApi: r.getApi
            }),
            Vg(r, y),
            hc(r, y)
          ]),
          ...t.tooltip.map((E) => gl.config(l.tooltips.getConfig({ tooltipText: l.translate(E) + t.shortcut.map((O) => ` (${XT(O)})`).getOr("") }))).toArray(),
          dm.toolbarButton(() => !t.enabled || l.isDisabled()),
          ki()
        ].concat(r.toolbarButtonBehaviours)),
        [h0]: (h = w.buttonBehaviours) === null || h === void 0 ? void 0 : h[h0]
      }
    });
  }, zX = (t, r, l) => b0(t, r, [], l), b0 = (t, r, l, d) => yH(t, {
    toolbarButtonBehaviours: l.length > 0 ? [jo("toolbarButtonWith", l)] : [],
    getApi: gH,
    onSetup: t.onSetup
  }, r, d), VX = (t, r, l) => xH(t, r, [], l), xH = (t, r, l, d) => yH(t, {
    toolbarButtonBehaviours: [
      Po.config({}),
      ns.config({
        toggleClass: "tox-tbtn--enabled",
        aria: { mode: "pressed" },
        toggleOnExecute: !1
      })
    ].concat(l.length > 0 ? [jo("toolbarToggleButtonWith", l)] : []),
    getApi: vH,
    onSetup: t.onSetup
  }, r, d), UX = (t, r, l) => (d) => Zl.nu((h) => r.fetch(h)).map((h) => B.from(Lx(Pr(IN(Mn("menu-value"), h, (y) => {
    r.onItemAction(t(d), y);
  }, r.columns, r.presets, im.CLOSE_ON_EXECUTE, r.select.getOr(_t), l), {
    movement: lA(r.columns, r.presets),
    menuBehaviours: Px.unnamedEvents(r.columns !== "auto" ? [] : [qr((y, w) => {
      qT(y, 4, eN(r.presets)).each(({ numRows: E, numColumns: O }) => {
        so.setGridSize(y, E, O);
      });
    })])
  })))), jX = (t, r, l) => {
    const d = to(t.tooltip.getOr("")), h = (E) => ({
      isEnabled: () => !_o.isDisabled(E),
      setEnabled: (O) => _o.set(E, !O),
      setIconFill: (O, F) => {
        or(E.element, `svg path[class="${O}"], rect[class="${O}"]`).each((L) => {
          sn(L, "fill", F);
        });
      },
      setActive: (O) => {
        sn(E.element, "aria-pressed", O), or(E.element, "span").each((F) => {
          E.getSystem().getByDom(F).each((L) => ns.set(L, O));
        });
      },
      isActive: () => or(E.element, "span").exists((O) => E.getSystem().getByDom(O).exists(ns.isOn)),
      setText: (O) => or(E.element, "span").each((F) => E.getSystem().getByDom(F).each((L) => po(L, Ef, { text: O }))),
      setIcon: (O) => or(E.element, "span").each((F) => E.getSystem().getByDom(F).each((L) => po(L, wb, { icon: O }))),
      setTooltip: (O) => {
        const F = r.providers.translate(O);
        sn(E.element, "aria-label", F), d.set(O);
      }
    }), y = to(U), w = {
      getApi: h,
      onSetup: t.onSetup
    };
    return g3.sketch({
      dom: {
        tag: "div",
        classes: ["tox-split-button"],
        attributes: {
          "aria-pressed": !1,
          ...bH(t.tooltip, r.providers),
          ...be(l) ? { "data-mce-name": l } : {}
        }
      },
      onExecute: (E) => {
        const O = h(E);
        O.isEnabled() && t.onAction(O);
      },
      onItemExecute: (E, O, F) => {
      },
      splitDropdownBehaviours: Jt([
        dm.splitButton(r.providers.isDisabled),
        ki(),
        jo("split-dropdown-events", [
          qr((E, O) => NA(E)),
          Ft(BM, To.focus),
          Vg(w, y),
          hc(w, y)
        ]),
        jx.config({}),
        ...t.tooltip.map((E) => gl.config({
          ...r.providers.tooltips.getConfig({
            tooltipText: r.providers.translate(E),
            onShow: (O) => {
              if (d.get() !== E) {
                const F = r.providers.translate(d.get());
                gl.setComponents(O, r.providers.tooltips.getComponents({ tooltipText: F }));
              }
            }
          })
        })).toArray()
      ]),
      eventOrder: {
        [rc()]: [
          "alloy.base.behaviour",
          "split-dropdown-events",
          "tooltipping"
        ],
        [Zu()]: [
          "split-dropdown-events",
          "tooltipping"
        ]
      },
      toggleClass: "tox-tbtn--enabled",
      lazySink: r.getSink,
      fetch: UX(h, t, r.providers),
      parts: { menu: pS(!1, t.columns, t.presets) },
      components: [
        g3.parts.button(v3(t.icon, t.text, B.none(), B.some([ns.config({
          toggleClass: "tox-tbtn--enabled",
          toggleOnExecute: !1
        })]), r.providers)),
        g3.parts.arrow({
          dom: {
            tag: "button",
            classes: [
              "tox-tbtn",
              "tox-split-button__chevron"
            ],
            innerHtml: VB("chevron-down", r.providers.icons)
          },
          buttonBehaviours: Jt([
            dm.splitButton(r.providers.isDisabled),
            ki(),
            ZR()
          ])
        }),
        g3.parts["aria-descriptor"]({ text: r.providers.translate("To open the popup, press Shift+Enter") })
      ]
    });
  }, WX = [
    {
      name: "history",
      items: [
        "undo",
        "redo"
      ]
    },
    {
      name: "ai",
      items: [
        "aidialog",
        "aishortcuts"
      ]
    },
    {
      name: "styles",
      items: ["styles"]
    },
    {
      name: "formatting",
      items: [
        "bold",
        "italic"
      ]
    },
    {
      name: "alignment",
      items: [
        "alignleft",
        "aligncenter",
        "alignright",
        "alignjustify"
      ]
    },
    {
      name: "indentation",
      items: [
        "outdent",
        "indent"
      ]
    },
    {
      name: "permanent pen",
      items: ["permanentpen"]
    },
    {
      name: "comments",
      items: ["addcomment"]
    }
  ], fk = (t, r) => (l, d, h, y) => {
    const w = t(l).mapError((E) => zu(E)).getOrDie();
    return r(w, d, h, y);
  }, ZX = {
    button: fk(cm, (t, r, l, d) => zX(t, r.shared.providers, d)),
    togglebutton: fk(jT, (t, r, l, d) => VX(t, r.shared.providers, d)),
    menubutton: fk(QA, (t, r, l, d) => GS(t, "tox-tbtn", r, B.none(), !1, d)),
    splitbutton: fk(ak, (t, r, l, d) => jX(t, r.shared, d)),
    grouptoolbarbutton: fk(cM, (t, r, l, d) => {
      const h = l.ui.registry.getAll().buttons, y = (E) => y3(l, {
        buttons: h,
        toolbar: E,
        allowToolbarGroups: !1
      }, r, B.none()), w = { [th]: r.shared.header.isPositionedAtTop() ? eh.TopToBottom : eh.BottomToTop };
      switch (Z1(l)) {
        case ed.floating:
          return HX(t, r, y, w, d);
        default:
          throw new Error("Toolbar groups are only supported when using floating toolbar mode");
      }
    })
  }, GX = (t, r, l, d) => qt(ZX, t.type).fold(() => (console.error("skipping button defined by", t), B.none()), (h) => B.some(h(t, r, l, d))), b3 = {
    styles: MX,
    fontsize: mH,
    fontsizeinput: RX,
    fontfamily: yX,
    blocks: eH,
    align: pX
  }, qX = (t) => {
    const r = et(WX, (l) => {
      const d = So(l.items, (h) => Ko(t, h) || Ko(b3, h));
      return {
        name: l.name,
        items: d
      };
    });
    return So(r, (l) => l.items.length > 0);
  }, KX = (t) => {
    const r = t.split("|");
    return et(r, (l) => ({ items: l.trim().split(" ") }));
  }, wH = (t) => oe(t, (r) => Ko(r, "name") && Ko(r, "items")), CH = (t) => {
    const r = t.toolbar, l = t.buttons;
    return r === !1 ? [] : r === void 0 || r === !0 ? qX(l) : A(r) ? KX(r) : wH(r) ? r : (console.error("Toolbar type should be string, string[], boolean or ToolbarGroup[]"), []);
  }, YX = (t, r, l, d, h, y) => qt(r, l.toLowerCase()).orThunk(() => y.bind((w) => Qo(w, (E) => qt(r, E + l.toLowerCase())))).fold(() => qt(b3, l.toLowerCase()).map((w) => w(t, h)), (w) => w.type === "grouptoolbarbutton" && !d ? (console.warn(`Ignoring the '${l}' toolbar button. Group toolbar buttons are only supported when using floating toolbar mode and cannot be nested.`), B.none()) : GX(w, h, t, l.toLowerCase())), y3 = (t, r, l, d) => {
    const h = CH(r), y = et(h, (w) => {
      const E = je(w.items, (O) => O.trim().length === 0 ? [] : YX(t, r.buttons, O, r.allowToolbarGroups, l, d).toArray());
      return {
        title: B.from(t.translate(w.name)),
        items: E
      };
    });
    return So(y, (w) => w.items.length > 0);
  }, SH = (t, r, l, d) => {
    const h = r.mainUi.outerContainer, y = l.toolbar, w = l.buttons;
    if (oe(y, A)) {
      const E = y.map((O) => {
        const F = {
          toolbar: O,
          buttons: w,
          allowToolbarGroups: l.allowToolbarGroups
        };
        return y3(t, F, d, B.none());
      });
      Wr.setToolbars(h, E);
    } else
      Wr.setToolbar(h, y3(t, l, d, B.none()));
  }, kH = $l(), XX = kH.os.isiOS() && kH.os.version.major <= 12, QX = (t, r) => {
    const { uiMotherships: l } = r, d = t.dom;
    let h = t.getWin();
    const y = t.getDoc().documentElement, w = to($r(h.innerWidth, h.innerHeight)), E = to($r(y.offsetWidth, y.offsetHeight)), O = () => {
      const ne = w.get();
      (ne.left !== h.innerWidth || ne.top !== h.innerHeight) && (w.set($r(h.innerWidth, h.innerHeight)), Ix(t));
    }, F = () => {
      const ne = t.getDoc().documentElement, ae = E.get();
      (ae.left !== ne.offsetWidth || ae.top !== ne.offsetHeight) && (E.set($r(ne.offsetWidth, ne.offsetHeight)), Ix(t));
    }, L = (ne) => {
      UL(t, ne);
    };
    d.bind(h, "resize", O), d.bind(h, "scroll", L);
    const q = Xw($e.fromDom(t.getBody()), "load", F);
    t.on("hide", () => {
      xt(l, (ne) => {
        Ln(ne.element, "display", "none");
      });
    }), t.on("show", () => {
      xt(l, (ne) => {
        gs(ne.element, "display");
      });
    }), t.on("NodeChange", F), t.on("remove", () => {
      q.unbind(), d.unbind(h, "resize", O), d.unbind(h, "scroll", L), h = null;
    });
  }, _H = (t, r, l) => {
    fb(t) && tm(l.mainUi.mothership.element, l.popupUi.mothership), TE(r, l.dialogUi.mothership);
  };
  var JX = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    render: (t, r, l, d, h) => {
      const { mainUi: y, uiMotherships: w } = r, E = to(0), O = y.outerContainer;
      cX(t);
      const F = $e.fromDom(h.targetNode), L = Oe(ie(F));
      tm(F, y.mothership), _H(t, L, r), t.on("SkinLoaded", () => {
        Wr.setSidebar(O, l.sidebar, EB(t)), SH(t, r, l, d), E.set(t.getWin().innerWidth), Wr.setMenubar(O, G7(t, l)), Wr.setViews(O, l.views), QX(t, r);
      });
      const q = Wr.getSocket(O).getOrDie("Could not find expected socket element");
      if (XX) {
        Or(q.element, {
          overflow: "scroll",
          "-webkit-overflow-scrolling": "touch"
        });
        const _e = sq(() => {
          t.dispatch("ScrollContent");
        }, 20), st = uc(q.element, "scroll", _e.throttle);
        t.on("remove", st.unbind);
      }
      KT(t, r), t.addCommand("ToggleSidebar", (_e, st) => {
        Wr.toggleSidebar(O, st), t.dispatch("ToggleSidebar");
      }), t.addQueryValueHandler("ToggleSidebar", () => {
        var _e;
        return (_e = Wr.whichSidebar(O)) !== null && _e !== void 0 ? _e : "";
      }), t.addCommand("ToggleView", (_e, st) => {
        if (Wr.toggleView(O, st)) {
          const Re = O.element;
          y.mothership.broadcastOn([nm()], { target: Re }), xt(w, (Qe) => {
            Qe.broadcastOn([nm()], { target: Re });
          }), K(Wr.whichView(O)) && (t.focus(), t.nodeChanged(), Wr.refreshToolbar(O));
        }
      }), t.addQueryValueHandler("ToggleView", () => {
        var _e;
        return (_e = Wr.whichView(O)) !== null && _e !== void 0 ? _e : "";
      });
      const ne = Z1(t), ae = () => {
        Wr.refreshToolbar(r.mainUi.outerContainer);
      };
      (ne === ed.sliding || ne === ed.floating) && t.on("ResizeWindow ResizeEditor ResizeContent", () => {
        const _e = t.getWin().innerWidth;
        _e !== E.get() && (ae(), E.set(_e));
      });
      const de = {
        setEnabled: (_e) => {
          SS(r, !_e);
        },
        isEnabled: () => !_o.isDisabled(O)
      };
      return {
        iframeContainer: q.element.dom,
        editorContainer: O.element.dom,
        api: de
      };
    }
  });
  const EH = (t) => /^[0-9\.]+(|px)$/i.test("" + t) ? B.some(parseInt("" + t, 10)) : B.none(), LM = (t) => re(t) ? t + "px" : t, y0 = (t, r, l) => {
    const d = r.filter((y) => t < y), h = l.filter((y) => t > y);
    return d.or(h).getOr(t);
  }, eQ = (t) => {
    const r = gR(t), l = uT(t), d = vR(t);
    return EH(r).map((h) => y0(h, l, d));
  }, x3 = (t) => eQ(t).getOr(gR(t)), mk = (t) => {
    const r = W1(t), l = Tx(t), d = tS(t);
    return EH(r).map((h) => y0(h, l, d));
  }, TH = (t) => mk(t).getOr(W1(t)), { ToolbarLocation: $M, ToolbarMode: AH } = _j, tQ = 40, nQ = (t, r, l, d, h) => {
    const { mainUi: y, uiMotherships: w } = l, E = j1.DOM, O = Ax(t), F = Ox(t), L = tS(t).or(mk(t)), q = d.shared.header, ne = q.isPositionedAtTop, ae = 150, de = Z1(t), _e = de === AH.sliding || de === AH.floating, st = to(!1), Re = () => st.get() && !t.removed, Qe = (ms) => _e ? ms.fold(ee(0), (cn) => cn.components().length > 1 ? Mr(cn.components()[1].element) : 0) : 0, qe = (ms) => {
      switch (yR(t)) {
        case $M.auto:
          const cn = Wr.getToolbar(y.outerContainer), Un = Qe(cn), Vo = Mr(ms.element) - Un, Co = sa(r);
          if (Co.y > Vo)
            return "top";
          {
            const $o = Oi(r), Er = Math.max($o.dom.scrollHeight, Mr($o));
            return Co.bottom < Er - Vo || Na().bottom < Co.bottom - Vo ? "bottom" : "top";
          }
        case $M.bottom:
          return "bottom";
        case $M.top:
        default:
          return "top";
      }
    }, Bt = (ms) => {
      h.on((cn) => {
        ma.setModes(cn, [ms]), q.setDockingMode(ms);
        const Un = ne() ? eh.TopToBottom : eh.BottomToTop;
        sn(cn.element, th, Un);
      });
    }, pt = () => {
      h.on((ms) => {
        const cn = L.getOrThunk(() => Om().width - wi(r).left - 10);
        Ln(ms.element, "max-width", cn + "px");
      });
    }, en = (ms, cn) => {
      h.on((Un) => {
        const Vo = Wr.getToolbar(y.outerContainer), Co = Qe(Vo), ho = sa(r), $o = bn(t, y.outerContainer.element), Er = () => $o.fold(() => ho.x, (ql) => {
          const zd = sa(ql);
          return Is(ql, Uo()) ? ho.x : ho.x - zd.x;
        }), Ys = () => $o.fold(() => ne() ? Math.max(ho.y - Mr(Un.element) + Co, 0) : ho.bottom, (ql) => {
          var zd;
          const Df = sa(ql), Du = (zd = ql.dom.scrollTop) !== null && zd !== void 0 ? zd : 0, T0 = Is(ql, Uo()) ? Math.max(ho.y - Mr(Un.element) + Co, 0) : ho.y - Df.y + Du - Mr(Un.element) + Co;
          return ne() ? T0 : ho.bottom;
        }), bc = Er(), Hd = Xn(ms, Math.ceil(y.outerContainer.element.dom.getBoundingClientRect().width)).filter((ql) => ql > ae).map((ql) => {
          const zd = cn.getOr(Ci()), Df = window.innerWidth - (bc - zd.left), Du = Math.max(Math.min(ql, Df), ae);
          return Df < ql && Ln(y.outerContainer.element, "width", Du + "px"), { width: Du + "px" };
        }).getOr({ width: "max-content" }), cp = {
          position: "absolute",
          left: Math.round(bc) + "px",
          top: Ys() + "px"
        };
        Or(y.outerContainer.element, {
          ...cp,
          ...Hd
        });
      });
    }, bn = (ms, cn) => fb(ms) ? Up(cn) : B.none(), It = () => {
      xt(w, (ms) => {
        ms.broadcastOn([Dg()], {});
      });
    }, Yn = () => !O && (Ga(y.outerContainer.element).left + ci(y.outerContainer.element) >= window.innerWidth - tQ || Cr(y.outerContainer.element, "width").isSome()) ? (Ln(y.outerContainer.element, "position", "absolute"), Ln(y.outerContainer.element, "left", "0px"), gs(y.outerContainer.element, "width"), !0) : !1, Fn = (ms) => {
      if (!Re())
        return;
      O || pt();
      const cn = Ci(), Un = O ? !1 : Yn();
      if (_e && Wr.refreshToolbar(y.outerContainer), !O) {
        const Vo = Ci(), Co = Xn(cn.left !== Vo.left, cn);
        en(Un, Co), Co.each((ho) => {
          Cp(ho.left, Vo.top);
        });
      }
      F && h.on(ms), It();
    }, yo = () => O || !F || !Re() ? !1 : h.get().exists((ms) => {
      const cn = q.getDockingMode(), Un = qe(ms);
      return Un !== cn ? (Bt(Un), !0) : !1;
    });
    return {
      isVisible: Re,
      isPositionedAtTop: ne,
      show: () => {
        st.set(!0), Ln(y.outerContainer.element, "display", "flex"), E.addClass(t.getBody(), "mce-edit-focus"), xt(w, (ms) => {
          gs(ms.element, "display");
        }), yo(), fb(t) ? Fn((ms) => ma.isDocked(ms) ? ma.reset(ms) : ma.refresh(ms)) : Fn(ma.refresh);
      },
      hide: () => {
        st.set(!1), Ln(y.outerContainer.element, "display", "none"), E.removeClass(t.getBody(), "mce-edit-focus"), xt(w, (ms) => {
          Ln(ms.element, "display", "none");
        });
      },
      update: Fn,
      updateMode: () => {
        yo() && Fn(ma.reset);
      },
      repositionPopups: It
    };
  }, OH = (t, r) => {
    const l = sa(t);
    return {
      pos: r ? l.y : l.bottom,
      bounds: l
    };
  }, w3 = (t, r, l, d) => {
    const h = to(OH(r, l.isPositionedAtTop())), y = (F) => {
      const { pos: L, bounds: q } = OH(r, l.isPositionedAtTop()), {
        pos: ne,
        bounds: ae
      } = h.get(), de = q.height !== ae.height || q.width !== ae.width;
      h.set({
        pos: L,
        bounds: q
      }), de && Ix(t, F), l.isVisible() && (ne !== L ? l.update(ma.reset) : de && (l.updateMode(), l.repositionPopups()));
    };
    d || (t.on("activate", l.show), t.on("deactivate", l.hide)), t.on("SkinLoaded ResizeWindow", () => l.update(ma.reset)), t.on("NodeChange keydown", (F) => {
      requestAnimationFrame(() => y(F));
    });
    let w = 0;
    const E = SP(() => l.update(ma.refresh), 33);
    t.on("ScrollWindow", () => {
      const F = Ci().left;
      F !== w && (w = F, E.throttle()), l.updateMode();
    }), fb(t) && t.on("ElementScroll", (F) => {
      l.update(ma.refresh);
    });
    const O = za();
    O.set(Xw($e.fromDom(t.getBody()), "load", (F) => y(F.raw))), t.on("remove", () => {
      O.clear();
    });
  };
  var DH = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    render: (t, r, l, d, h) => {
      const { mainUi: y } = r, w = cr(), E = $e.fromDom(h.targetNode), O = nQ(t, E, r, d, w), F = bB(t);
      uX(t);
      const L = () => {
        if (w.isSet()) {
          O.show();
          return;
        }
        w.set(Wr.getHeader(y.outerContainer).getOrDie());
        const ne = oS(t);
        fb(t) ? (tm(E, y.mothership), tm(E, r.popupUi.mothership)) : TE(ne, y.mothership), TE(ne, r.dialogUi.mothership);
        const ae = () => {
          SH(t, r, l, d), Wr.setMenubar(y.outerContainer, G7(t, l)), O.show(), w3(t, E, O, F), t.nodeChanged();
        };
        F ? t.once("SkinLoaded", ae) : ae();
      };
      t.on("show", L), t.on("hide", O.hide), F || (t.on("focus", L), t.on("blur", O.hide)), t.on("init", () => {
        (t.hasFocus() || F) && L();
      }), KT(t, r);
      const q = {
        show: L,
        hide: O.hide,
        setEnabled: (ne) => {
          SS(r, !ne);
        },
        isEnabled: () => !_o.isDisabled(y.outerContainer)
      };
      return {
        editorContainer: y.outerContainer.element.dom,
        api: q
      };
    }
  });
  const RH = () => {
    const t = cr(), r = cr(), l = cr();
    return {
      dialogUi: t,
      popupUi: r,
      mainUi: l,
      getUiMotherships: () => {
        const y = t.get().map((E) => E.mothership), w = r.get().map((E) => E.mothership);
        return y.fold(() => w.toArray(), (E) => w.fold(() => [E], (O) => Is(E.element, O.element) ? [E] : [
          E,
          O
        ]));
      },
      lazyGetInOuterOrDie: (y, w) => () => l.get().bind((E) => w(E.outerContainer)).getOrDie(`Could not find ${y} element in OuterContainer`)
    };
  }, NH = "contexttoolbar-show", PH = "contexttoolbar-hide", MH = (t) => ({
    hide: () => Xo(t, Kb()),
    getValue: () => In.getValue(t)
  }), IH = (t, r) => Ft($$, (l, d) => {
    const h = t.get(l), y = MH(h);
    r.onAction(y, d.event.buttonApi);
  }), sQ = (t, r, l) => {
    const { primary: d, ...h } = r.original, y = Gt(cm({
      ...h,
      type: "button",
      onAction: U
    }));
    return b0(y, l, [IH(t, r)]);
  }, rQ = (t, r, l) => {
    const { primary: d, ...h } = r.original, y = Gt(jT({
      ...h,
      type: "togglebutton",
      onAction: U
    }));
    return xH(y, l, [IH(t, r)]);
  }, aQ = (t) => t.type === "contextformtogglebutton", iQ = (t, r, l) => aQ(r) ? rQ(t, r, l) : sQ(t, r, l), pk = (t, r, l) => {
    const d = et(r, (w) => rr(iQ(t, w, l)));
    return {
      asSpecs: () => et(d, (w) => w.asSpec()),
      findPrimary: (w) => Qo(r, (E, O) => E.primary ? B.from(d[O]).bind((F) => F.getOpt(w)).filter(Ue(_o.isDisabled)) : B.none())
    };
  }, FH = (t, r) => {
    const l = t.label.fold(() => ({}), (y) => ({ "aria-label": y })), d = rr(Y1.sketch({
      inputClasses: [
        "tox-toolbar-textfield",
        "tox-toolbar-nav-js"
      ],
      data: t.initValue(),
      inputAttributes: l,
      selectOnFocus: !0,
      inputBehaviours: Jt([so.config({
        mode: "special",
        onEnter: (y) => h.findPrimary(y).map((w) => (Hp(w), !0)),
        onLeft: (y, w) => (w.cut(), B.none()),
        onRight: (y, w) => (w.cut(), B.none())
      })])
    })), h = pk(d, t.commands, r);
    return [
      {
        title: B.none(),
        items: [d.asSpec()]
      },
      {
        title: B.none(),
        items: h.asSpecs()
      }
    ];
  }, lQ = {
    renderContextForm: (t, r, l) => a3({
      type: t,
      uid: Mn("context-toolbar"),
      initGroups: FH(r, l),
      onEscape: B.none,
      cyclicKeying: !0,
      providers: l
    }),
    buildInitGroups: FH
  }, HM = (t, r, l) => r.bottom - t.y >= l && t.bottom - r.y >= l, cQ = (t) => {
    const r = t.getBoundingClientRect();
    if (r.height <= 0 && r.width <= 0) {
      const l = fd($e.fromDom(t.startContainer), t.startOffset).element;
      return (Zo(l) ? Za(l) : B.some(l)).filter(ko).map((h) => h.dom.getBoundingClientRect()).getOr(r);
    } else
      return r;
  }, C3 = (t) => {
    const r = t.selection.getRng(), l = cQ(r);
    if (t.inline) {
      const d = Ci();
      return Nr(d.left + l.left, d.top + l.top, l.width, l.height);
    } else {
      const d = Cl($e.fromDom(t.getBody()));
      return Nr(d.x + l.left, d.y + l.top, l.width, l.height);
    }
  }, uQ = (t, r) => r.filter((l) => hs(l) && Ai(l)).map(Cl).getOrThunk(() => C3(t)), dQ = (t, r, l) => {
    const d = Math.max(t.x + l, r.x), h = Math.min(t.right - l, r.right);
    return {
      x: d,
      width: h - d
    };
  }, fQ = (t, r, l, d, h, y) => {
    const w = $e.fromDom(t.getContainer()), E = or(w, ".tox-editor-header").getOr(w), O = sa(E), F = O.y >= r.bottom, L = d && !F;
    if (t.inline && L)
      return {
        y: Math.max(O.bottom + y, l.y),
        bottom: l.bottom
      };
    if (t.inline && !L)
      return {
        y: l.y,
        bottom: Math.min(O.y - y, l.bottom)
      };
    const q = h === "line" ? sa(w) : r;
    return L ? {
      y: Math.max(O.bottom + y, l.y),
      bottom: Math.min(q.bottom - y, l.bottom)
    } : {
      y: Math.max(q.y + y, l.y),
      bottom: Math.min(O.y - y, l.bottom)
    };
  }, BH = (t, r, l, d = 0) => {
    const h = Om(window), y = sa($e.fromDom(t.getContentAreaContainer())), w = vT(t) || yT(t) || G1(t), { x: E, width: O } = dQ(y, h, d);
    if (t.inline && !w)
      return Nr(E, h.y, O, h.height);
    {
      const F = r.header.isPositionedAtTop(), { y: L, bottom: q } = fQ(t, y, h, F, l, d);
      return Nr(E, L, O, q - L);
    }
  }, S3 = 12, f2 = {
    valignCentre: [],
    alignCentre: [],
    alignLeft: ["tox-pop--align-left"],
    alignRight: ["tox-pop--align-right"],
    right: ["tox-pop--right"],
    left: ["tox-pop--left"],
    bottom: ["tox-pop--bottom"],
    top: ["tox-pop--top"],
    inset: ["tox-pop--inset"]
  }, zM = {
    maxHeightFunction: jv(),
    maxWidthFunction: i2()
  }, mQ = (t, r) => {
    const l = t.selection.getRng(), d = fd($e.fromDom(l.startContainer), l.startOffset);
    return l.startContainer === l.endContainer && l.startOffset === l.endOffset - 1 && Is(d.element, r);
  }, pQ = (t, r, l) => {
    const d = Cr(t, "position");
    Ln(t, "position", r);
    const h = l(t);
    return d.each((y) => Ln(t, "position", y)), h;
  }, VM = (t) => t === "node", UM = (t, r, l, d, h) => {
    const y = C3(t), w = d.lastElement().exists((E) => Is(l, E));
    if (mQ(t, l))
      return w ? ek : gm;
    if (w)
      return pQ(r, d.getMode(), () => HM(y, sa(r), -20) && !d.isReposition() ? D8 : ek);
    {
      const E = d.getMode() === "fixed" ? h.y + Ci().top : h.y, O = Mr(r) + S3;
      return E + O <= y.y ? gm : JS;
    }
  }, LH = (t, r, l, d) => {
    const h = (O) => (F, L, q, ne, ae) => {
      const de = UM(t, ne, O, l, ae), _e = {
        ...F,
        y: ae.y,
        height: ae.height
      };
      return {
        ...de(_e, L, q, ne, ae),
        alwaysFit: !0
      };
    }, y = (O) => VM(d) ? [h(O)] : [];
    return r ? {
      onLtr: (O) => [
        ti,
        fi,
        ei,
        mi,
        br,
        Si
      ].concat(y(O)),
      onRtl: (O) => [
        ti,
        ei,
        fi,
        br,
        mi,
        Si
      ].concat(y(O))
    } : {
      onLtr: (O) => [
        Si,
        ti,
        mi,
        fi,
        br,
        ei
      ].concat(y(O)),
      onRtl: (O) => [
        Si,
        ti,
        br,
        ei,
        mi,
        fi
      ].concat(y(O))
    };
  }, $H = (t, r, l, d) => r === "line" ? {
    bubble: Od(S3, 0, f2),
    layouts: {
      onLtr: () => [Uw],
      onRtl: () => [Ey]
    },
    overrides: zM
  } : {
    bubble: Od(0, S3, f2, 1 / S3),
    layouts: LH(t, l, d, r),
    overrides: zM
  }, jM = (t, r) => {
    const l = So(r, (y) => y.predicate(t.dom)), { pass: d, fail: h } = ds(l, (y) => y.type === "contexttoolbar");
    return {
      contextToolbars: d,
      contextForms: h
    };
  }, m2 = (t) => {
    if (t.length <= 1)
      return t;
    {
      const r = (y) => Ro(t, (w) => w.position === y), l = (y) => So(t, (w) => w.position === y), d = r("selection"), h = r("node");
      if (d || h)
        if (h && d) {
          const y = l("node"), w = et(l("selection"), (E) => ({
            ...E,
            position: "node"
          }));
          return y.concat(w);
        } else
          return l(d ? "selection" : "node");
      else
        return l("line");
    }
  }, k3 = (t) => {
    if (t.length <= 1)
      return t;
    {
      const r = (d) => Nt(t, (h) => h.position === d);
      return r("selection").orThunk(() => r("node")).orThunk(() => r("line")).map((d) => d.position).fold(() => [], (d) => So(t, (h) => h.position === d));
    }
  }, _3 = (t, r, l) => {
    const d = jM(t, r);
    if (d.contextForms.length > 0)
      return B.some({
        elem: t,
        toolbars: [d.contextForms[0]]
      });
    {
      const h = jM(t, l);
      if (h.contextForms.length > 0)
        return B.some({
          elem: t,
          toolbars: [h.contextForms[0]]
        });
      if (d.contextToolbars.length > 0 || h.contextToolbars.length > 0) {
        const y = m2(d.contextToolbars.concat(h.contextToolbars));
        return B.some({
          elem: t,
          toolbars: y
        });
      } else
        return B.none();
    }
  }, WM = (t, r, l) => t(r) ? B.none() : kd(r, (d) => {
    if (ko(d)) {
      const { contextToolbars: h, contextForms: y } = jM(d, l.inNodeScope), w = y.length > 0 ? y : k3(h);
      return w.length > 0 ? B.some({
        elem: d,
        toolbars: w
      }) : B.none();
    } else
      return B.none();
  }, t), ZM = (t, r) => {
    const l = $e.fromDom(r.getBody()), d = (w) => Is(w, l), h = (w) => !d(w) && !ka(l, w), y = $e.fromDom(r.selection.getNode());
    return h(y) ? B.none() : _3(y, t.inNodeScope, t.inEditorScope).orThunk(() => WM(d, y, t));
  }, HH = (t, r) => {
    const l = {}, d = [], h = [], y = {}, w = {}, E = (L, q) => {
      const ne = Gt(gW(q));
      l[L] = ne, ne.launch.map((ae) => {
        y["form:" + L] = {
          ...q.launch,
          type: ae.type === "contextformtogglebutton" ? "togglebutton" : "button",
          onAction: () => {
            r(ne);
          }
        };
      }), ne.scope === "editor" ? h.push(ne) : d.push(ne), w[L] = ne;
    }, O = (L, q) => {
      xf(q).each((ne) => {
        q.scope === "editor" ? h.push(ne) : d.push(ne), w[L] = ne;
      });
    }, F = os(t);
    return xt(F, (L) => {
      const q = t[L];
      q.type === "contextform" ? E(L, q) : q.type === "contexttoolbar" && O(L, q);
    }), {
      forms: l,
      inNodeScope: d,
      inEditorScope: h,
      lookupTable: w,
      formNavigators: y
    };
  }, hk = Mn("forward-slide"), GM = Mn("backward-slide"), E3 = Mn("change-slide-event"), gk = "tox-pop--resizing", hQ = (t) => {
    const r = to([]);
    return aa.sketch({
      dom: {
        tag: "div",
        classes: ["tox-pop"]
      },
      fireDismissalEventInstead: { event: "doNotDismissYet" },
      onShow: (l) => {
        r.set([]), aa.getContent(l).each((d) => {
          gs(d.element, "visibility");
        }), ba(l.element, gk), gs(l.element, "width");
      },
      inlineBehaviours: Jt([
        jo("context-toolbar-events", [
          _v(of(), (l, d) => {
            d.event.raw.propertyName === "width" && (ba(l.element, gk), gs(l.element, "width"));
          }),
          Ft(E3, (l, d) => {
            const h = l.element;
            gs(h, "width");
            const y = Ri(h);
            aa.setContent(l, d.event.contents), Vr(h, gk);
            const w = Ri(h);
            Ln(h, "width", y + "px"), aa.getContent(l).each((E) => {
              d.event.focus.bind((O) => (vu(O), cc(h))).orThunk(() => (so.focusIn(E), hf(ie(h))));
            }), setTimeout(() => {
              Ln(l.element, "width", w + "px");
            }, 0);
          }),
          Ft(hk, (l, d) => {
            aa.getContent(l).each((h) => {
              r.set(r.get().concat([{
                bar: h,
                focus: hf(ie(l.element))
              }]));
            }), po(l, E3, {
              contents: d.event.forwardContents,
              focus: B.none()
            });
          }),
          Ft(GM, (l, d) => {
            xs(r.get()).each((h) => {
              r.set(r.get().slice(0, r.get().length - 1)), po(l, E3, {
                contents: Vl(h.bar),
                focus: h.focus
              });
            });
          })
        ]),
        so.config({
          mode: "special",
          onEscape: (l) => xs(r.get()).fold(() => t.onEscape(), (d) => (Xo(l, GM), B.some(!0)))
        })
      ]),
      lazySink: () => Ho.value(t.sink)
    });
  }, T3 = "tox-pop--transition", gQ = (t, r, l, d) => {
    const h = d.backstage, y = h.shared, w = $l().deviceType.isTouch, E = cr(), O = cr(), F = cr(), L = Ol(hQ({
      sink: l,
      onEscape: () => (t.focus(), B.some(!0))
    })), q = () => {
      const Fn = F.get().getOr("node"), yo = VM(Fn) ? 1 : 0;
      return BH(t, y, Fn, yo);
    }, ne = () => !t.removed && !(w() && h.isContextMenuOpen()), ae = (Fn) => ha(xa(Fn, E.get(), Is), !0), de = () => {
      if (ne()) {
        const Fn = q(), yo = ha(F.get(), "node") ? uQ(t, E.get()) : C3(t);
        return Fn.height <= 0 || !HM(yo, Fn, 0.01);
      } else
        return !0;
    }, _e = () => {
      E.clear(), O.clear(), F.clear(), aa.hide(L);
    }, st = () => {
      if (aa.isOpen(L)) {
        const Fn = L.element;
        gs(Fn, "display"), de() ? Ln(Fn, "display", "none") : (O.set(0), aa.reposition(L));
      }
    }, Re = (Fn) => ({
      dom: {
        tag: "div",
        classes: ["tox-pop__dialog"]
      },
      components: [Fn],
      behaviours: Jt([
        so.config({ mode: "acyclic" }),
        jo("pop-dialog-wrap-events", [
          qr((yo) => {
            t.shortcuts.add("ctrl+F9", "focus statusbar", () => so.focusIn(yo));
          }),
          qf((yo) => {
            t.shortcuts.remove("ctrl+F9");
          })
        ])
      ])
    }), Qe = Te(() => HH(r, (Fn) => {
      const yo = pt([Fn]);
      po(L, hk, { forwardContents: Re(yo) });
    })), qe = (Fn, yo) => y3(t, {
      buttons: Fn,
      toolbar: yo.items,
      allowToolbarGroups: !1
    }, d.backstage, B.some(["form:"])), Bt = (Fn, yo) => lQ.buildInitGroups(Fn, yo), pt = (Fn) => {
      const { buttons: yo } = t.ui.registry.getAll(), mo = Qe(), js = {
        ...yo,
        ...mo.formNavigators
      }, Fs = Z1(t) === ed.scrolling ? ed.scrolling : ed.default, ms = tn(et(Fn, (cn) => cn.type === "contexttoolbar" ? qe(js, cn) : Bt(cn, y.providers)));
      return a3({
        type: Fs,
        uid: Mn("context-toolbar"),
        initGroups: ms,
        onEscape: B.none,
        cyclicKeying: !0,
        providers: y.providers
      });
    }, en = (Fn, yo) => {
      const mo = Fn === "node" ? y.anchors.node(yo) : y.anchors.cursor(), js = $H(t, Fn, w(), {
        lastElement: E.get,
        isReposition: () => ha(O.get(), 0),
        getMode: () => tl.getMode(l)
      });
      return Pr(mo, js);
    }, bn = (Fn, yo) => {
      if (Yn.cancel(), !ne())
        return;
      const mo = pt(Fn), js = Fn[0].position, Fs = en(js, yo);
      F.set(js), O.set(1);
      const ms = L.element;
      gs(ms, "display"), ae(yo) || (ba(ms, T3), tl.reset(l, L)), aa.showWithinBounds(L, Re(mo), {
        anchor: Fs,
        transition: {
          classes: [T3],
          mode: "placement"
        }
      }, () => B.some(q())), yo.fold(E.clear, E.set), de() && Ln(ms, "display", "none");
    };
    let It = !1;
    const Yn = SP(() => {
      if (!(!t.hasFocus() || t.removed || It))
        if (Kc(L.element, T3))
          Yn.throttle();
        else {
          const Fn = Qe();
          ZM(Fn, t).fold(_e, (yo) => {
            bn(yo.toolbars, B.some(yo.elem));
          });
        }
    }, 17);
    t.on("init", () => {
      t.on("remove", _e), t.on("ScrollContent ScrollWindow ObjectResized ResizeEditor longpress", st), t.on("click keyup focus SetContent", Yn.throttle), t.on(PH, _e), t.on(NH, (Fn) => {
        const yo = Qe();
        qt(yo.lookupTable, Fn.toolbarKey).each((mo) => {
          bn([mo], Xn(Fn.target !== t, Fn.target)), aa.getContent(L).each(so.focusIn);
        });
      }), t.on("focusout", (Fn) => {
        JC.setEditorTimeout(t, () => {
          cc(l.element).isNone() && cc(L.element).isNone() && _e();
        }, 0);
      }), t.on("SwitchMode", () => {
        t.mode.isReadOnly() && _e();
      }), t.on("ExecCommand", ({ command: Fn }) => {
        Fn.toLowerCase() === "toggleview" && _e();
      }), t.on("AfterProgressState", (Fn) => {
        Fn.state ? _e() : t.hasFocus() && Yn.throttle();
      }), t.on("dragstart", () => {
        It = !0;
      }), t.on("dragend drop", () => {
        It = !1;
      }), t.on("NodeChange", (Fn) => {
        cc(L.element).fold(Yn.throttle, U);
      });
    });
  }, vQ = (t) => {
    xt([
      {
        name: "alignleft",
        text: "Align left",
        cmd: "JustifyLeft",
        icon: "align-left"
      },
      {
        name: "aligncenter",
        text: "Align center",
        cmd: "JustifyCenter",
        icon: "align-center"
      },
      {
        name: "alignright",
        text: "Align right",
        cmd: "JustifyRight",
        icon: "align-right"
      },
      {
        name: "alignjustify",
        text: "Justify",
        cmd: "JustifyFull",
        icon: "align-justify"
      }
    ], (l) => {
      t.ui.registry.addToggleButton(l.name, {
        tooltip: l.text,
        icon: l.icon,
        onAction: od(t, l.cmd),
        onSetup: oA(t, l.name)
      });
    }), t.ui.registry.addButton("alignnone", {
      tooltip: "No alignment",
      icon: "align-none",
      onSetup: Mc(t),
      onAction: od(t, "JustifyNone")
    });
  }, vk = (t, r) => {
    const l = () => {
      const d = r.getOptions(t), h = r.getCurrent(t).map(r.hash), y = cr();
      return et(d, (w) => ({
        type: "togglemenuitem",
        text: r.display(w),
        onSetup: (E) => {
          const O = (L) => {
            L && (y.on((q) => q.setActive(!1)), y.set(E)), E.setActive(L);
          };
          O(ha(h, r.hash(w)));
          const F = r.watcher(t, w, O);
          return () => {
            y.clear(), F();
          };
        },
        onAction: () => r.setCurrent(t, w)
      }));
    };
    t.ui.registry.addMenuButton(r.name, {
      tooltip: r.text,
      icon: r.icon,
      fetch: (d) => d(l()),
      onSetup: r.onToolbarSetup
    }), t.ui.registry.addNestedMenuItem(r.name, {
      type: "nestedmenuitem",
      text: r.text,
      getSubmenuItems: l,
      onSetup: r.onMenuSetup
    });
  }, zH = (t) => ({
    name: "lineheight",
    text: "Line height",
    icon: "line-height",
    getOptions: TR,
    hash: (r) => SX(r, [
      "fixed",
      "relative",
      "empty"
    ]).getOr(r),
    display: lt,
    watcher: (r, l, d) => r.formatter.formatChanged("lineheight", d, !1, { value: l }).unbind,
    getCurrent: (r) => B.from(r.queryCommandValue("LineHeight")),
    setCurrent: (r, l) => r.execCommand("LineHeight", !1, l),
    onToolbarSetup: Mc(t),
    onMenuSetup: Mc(t)
  }), bQ = (t) => B.from(dT(t)).map((l) => ({
    name: "language",
    text: "Language",
    icon: "language",
    getOptions: ee(l),
    hash: (d) => pe(d.customCode) ? d.code : `${d.code}/${d.customCode}`,
    display: (d) => d.title,
    watcher: (d, h, y) => {
      var w;
      return d.formatter.formatChanged("lang", y, !1, {
        value: h.code,
        customValue: (w = h.customCode) !== null && w !== void 0 ? w : null
      }).unbind;
    },
    getCurrent: (d) => {
      const h = $e.fromDom(d.selection.getNode());
      return Uf(h, (y) => B.some(y).filter(ko).bind((w) => Y(w, "lang").map((O) => {
        const F = Y(w, "data-mce-lang").getOrUndefined();
        return {
          code: O,
          customCode: F,
          title: ""
        };
      })));
    },
    setCurrent: (d, h) => d.execCommand("Lang", !1, h),
    onToolbarSetup: (d) => {
      const h = za();
      return d.setActive(t.formatter.match("lang", {}, void 0, !0)), h.set(t.formatter.formatChanged("lang", d.setActive, !0)), ES(h.clear, Mc(t)(d));
    },
    onMenuSetup: Mc(t)
  })), yQ = (t) => {
    vk(t, zH(t)), bQ(t).each((r) => vk(t, r));
  }, xQ = (t, r) => {
    hX(t, r), MM(t, r), IX(t, r), gX(t, r), NX(t, r);
  }, wQ = (t) => o0(t, "NodeChange", (r) => {
    r.setEnabled(t.queryCommandState("outdent") && t.selection.isEditable());
  }), CQ = (t) => {
    t.ui.registry.addButton("outdent", {
      tooltip: "Decrease indent",
      icon: "outdent",
      onSetup: wQ(t),
      onAction: od(t, "outdent")
    }), t.ui.registry.addButton("indent", {
      tooltip: "Increase indent",
      icon: "indent",
      onSetup: Mc(t),
      onAction: od(t, "indent")
    });
  }, VH = (t) => {
    CQ(t);
  }, qM = (t, r) => (l) => {
    l.setActive(r.get());
    const d = (h) => {
      r.set(h.state), l.setActive(h.state);
    };
    return t.on("PastePlainTextToggle", d), ES(() => t.off("PastePlainTextToggle", d), Mc(t)(l));
  }, UH = (t) => {
    const r = to(gT(t)), l = () => t.execCommand("mceTogglePlainTextPaste");
    t.ui.registry.addToggleButton("pastetext", {
      active: !1,
      icon: "paste-text",
      tooltip: "Paste as text",
      onAction: l,
      onSetup: qM(t, r)
    }), t.ui.registry.addToggleMenuItem("pastetext", {
      text: "Paste as text",
      icon: "paste-text",
      onAction: l,
      onSetup: qM(t, r)
    });
  }, A3 = (t, r) => () => {
    t.execCommand("mceToggleFormat", !1, r);
  }, SQ = (t) => {
    pm.each([
      {
        name: "bold",
        text: "Bold",
        icon: "bold",
        shortcut: "Meta+B"
      },
      {
        name: "italic",
        text: "Italic",
        icon: "italic",
        shortcut: "Meta+I"
      },
      {
        name: "underline",
        text: "Underline",
        icon: "underline",
        shortcut: "Meta+U"
      },
      {
        name: "strikethrough",
        text: "Strikethrough",
        icon: "strike-through"
      },
      {
        name: "subscript",
        text: "Subscript",
        icon: "subscript"
      },
      {
        name: "superscript",
        text: "Superscript",
        icon: "superscript"
      }
    ], (r, l) => {
      t.ui.registry.addToggleButton(r.name, {
        tooltip: r.text,
        icon: r.icon,
        onSetup: oA(t, r.name),
        onAction: A3(t, r.name),
        shortcut: r.shortcut
      });
    });
    for (let r = 1; r <= 6; r++) {
      const l = "h" + r, d = `Access+${r}`;
      t.ui.registry.addToggleButton(l, {
        text: l.toUpperCase(),
        tooltip: "Heading " + r,
        onSetup: oA(t, l),
        onAction: A3(t, l),
        shortcut: d
      });
    }
  }, jH = (t) => {
    pm.each([
      {
        name: "copy",
        text: "Copy",
        action: "Copy",
        icon: "copy"
      },
      {
        name: "help",
        text: "Help",
        action: "mceHelp",
        icon: "help",
        shortcut: "Alt+0"
      },
      {
        name: "selectall",
        text: "Select all",
        action: "SelectAll",
        icon: "select-all",
        shortcut: "Meta+A"
      },
      {
        name: "newdocument",
        text: "New document",
        action: "mceNewDocument",
        icon: "new-document"
      },
      {
        name: "print",
        text: "Print",
        action: "mcePrint",
        icon: "print",
        shortcut: "Meta+P"
      }
    ], (r) => {
      t.ui.registry.addButton(r.name, {
        tooltip: r.text,
        icon: r.icon,
        onAction: od(t, r.action),
        shortcut: r.shortcut
      });
    }), pm.each([
      {
        name: "cut",
        text: "Cut",
        action: "Cut",
        icon: "cut"
      },
      {
        name: "paste",
        text: "Paste",
        action: "Paste",
        icon: "paste"
      },
      {
        name: "removeformat",
        text: "Clear formatting",
        action: "RemoveFormat",
        icon: "remove-formatting"
      },
      {
        name: "remove",
        text: "Remove",
        action: "Delete",
        icon: "remove"
      },
      {
        name: "hr",
        text: "Horizontal line",
        action: "InsertHorizontalRule",
        icon: "horizontal-rule"
      }
    ], (r) => {
      t.ui.registry.addButton(r.name, {
        tooltip: r.text,
        icon: r.icon,
        onSetup: Mc(t),
        onAction: od(t, r.action)
      });
    });
  }, WH = (t) => {
    pm.each([{
      name: "blockquote",
      text: "Blockquote",
      action: "mceBlockQuote",
      icon: "quote"
    }], (r) => {
      t.ui.registry.addToggleButton(r.name, {
        tooltip: r.text,
        icon: r.icon,
        onAction: od(t, r.action),
        onSetup: oA(t, r.name)
      });
    });
  }, kQ = (t) => {
    SQ(t), jH(t), WH(t);
  }, mae = (t) => {
    pm.each([
      {
        name: "newdocument",
        text: "New document",
        action: "mceNewDocument",
        icon: "new-document"
      },
      {
        name: "copy",
        text: "Copy",
        action: "Copy",
        icon: "copy",
        shortcut: "Meta+C"
      },
      {
        name: "selectall",
        text: "Select all",
        action: "SelectAll",
        icon: "select-all",
        shortcut: "Meta+A"
      },
      {
        name: "print",
        text: "Print...",
        action: "mcePrint",
        icon: "print",
        shortcut: "Meta+P"
      }
    ], (r) => {
      t.ui.registry.addMenuItem(r.name, {
        text: r.text,
        icon: r.icon,
        shortcut: r.shortcut,
        onAction: od(t, r.action)
      });
    }), pm.each([
      {
        name: "bold",
        text: "Bold",
        action: "Bold",
        icon: "bold",
        shortcut: "Meta+B"
      },
      {
        name: "italic",
        text: "Italic",
        action: "Italic",
        icon: "italic",
        shortcut: "Meta+I"
      },
      {
        name: "underline",
        text: "Underline",
        action: "Underline",
        icon: "underline",
        shortcut: "Meta+U"
      },
      {
        name: "strikethrough",
        text: "Strikethrough",
        action: "Strikethrough",
        icon: "strike-through"
      },
      {
        name: "subscript",
        text: "Subscript",
        action: "Subscript",
        icon: "subscript"
      },
      {
        name: "superscript",
        text: "Superscript",
        action: "Superscript",
        icon: "superscript"
      },
      {
        name: "removeformat",
        text: "Clear formatting",
        action: "RemoveFormat",
        icon: "remove-formatting"
      },
      {
        name: "cut",
        text: "Cut",
        action: "Cut",
        icon: "cut",
        shortcut: "Meta+X"
      },
      {
        name: "paste",
        text: "Paste",
        action: "Paste",
        icon: "paste",
        shortcut: "Meta+V"
      },
      {
        name: "hr",
        text: "Horizontal line",
        action: "InsertHorizontalRule",
        icon: "horizontal-rule"
      }
    ], (r) => {
      t.ui.registry.addMenuItem(r.name, {
        text: r.text,
        icon: r.icon,
        shortcut: r.shortcut,
        onSetup: Mc(t),
        onAction: od(t, r.action)
      });
    }), t.ui.registry.addMenuItem("codeformat", {
      text: "Code",
      icon: "sourcecode",
      onSetup: Mc(t),
      onAction: A3(t, "code")
    });
  }, _Q = (t) => {
    kQ(t), mae(t);
  }, O3 = (t, r) => o0(t, "Undo Redo AddUndo TypingUndo ClearUndos SwitchMode", (l) => {
    l.setEnabled(!t.mode.isReadOnly() && t.undoManager[r]());
  }), EQ = (t) => {
    t.ui.registry.addMenuItem("undo", {
      text: "Undo",
      icon: "undo",
      shortcut: "Meta+Z",
      onSetup: O3(t, "hasUndo"),
      onAction: od(t, "undo")
    }), t.ui.registry.addMenuItem("redo", {
      text: "Redo",
      icon: "redo",
      shortcut: "Meta+Y",
      onSetup: O3(t, "hasRedo"),
      onAction: od(t, "redo")
    });
  }, TQ = (t) => {
    t.ui.registry.addButton("undo", {
      tooltip: "Undo",
      icon: "undo",
      enabled: !1,
      onSetup: O3(t, "hasUndo"),
      onAction: od(t, "undo"),
      shortcut: "Meta+Z"
    }), t.ui.registry.addButton("redo", {
      tooltip: "Redo",
      icon: "redo",
      enabled: !1,
      onSetup: O3(t, "hasRedo"),
      onAction: od(t, "redo"),
      shortcut: "Meta+Y"
    });
  }, AQ = (t) => {
    EQ(t), TQ(t);
  }, OQ = (t) => o0(t, "VisualAid", (r) => {
    r.setActive(t.hasVisual);
  }), DQ = (t) => {
    t.ui.registry.addToggleMenuItem("visualaid", {
      text: "Visual aids",
      onSetup: OQ(t),
      onAction: od(t, "mceToggleVisualAid")
    });
  }, RQ = (t) => {
    t.ui.registry.addButton("visualaid", {
      tooltip: "Visual aids",
      text: "Visual aids",
      onAction: od(t, "mceToggleVisualAid")
    });
  }, NQ = (t) => {
    RQ(t), DQ(t);
  }, PQ = (t, r) => {
    vQ(t), _Q(t), xQ(t, r), AQ(t), tZ(t), NQ(t), VH(t), yQ(t), UH(t);
  }, MQ = (t) => A(t) ? t.split(/[ ,]/) : t, ZH = (t) => (r) => r.options.get(t), IQ = (t) => {
    const r = t.options.register;
    r("contextmenu_avoid_overlap", {
      processor: "string",
      default: ""
    }), r("contextmenu_never_use_native", {
      processor: "boolean",
      default: !1
    }), r("contextmenu", {
      processor: (l) => l === !1 ? {
        value: [],
        valid: !0
      } : A(l) || oe(l, A) ? {
        value: MQ(l),
        valid: !0
      } : {
        valid: !1,
        message: "Must be false or a string."
      },
      default: "link linkchecker image editimage table spellchecker configurepermanentpen"
    });
  }, KM = ZH("contextmenu_never_use_native"), FQ = ZH("contextmenu_avoid_overlap"), BQ = (t) => GH(t).length === 0, GH = (t) => {
    const r = t.ui.registry.getAll().contextMenus, l = t.options.get("contextmenu");
    return t.options.isSet("contextmenu") ? l : So(l, (d) => Ko(r, d));
  }, bk = (t, r) => ({
    type: "makeshift",
    x: t,
    y: r
  }), LQ = (t, r, l) => bk(t.x + r, t.y + l), qH = (t) => t.type === "longpress" || t.type.indexOf("touch") === 0, $Q = (t) => {
    if (qH(t)) {
      const r = t.touches[0];
      return bk(r.pageX, r.pageY);
    } else
      return bk(t.pageX, t.pageY);
  }, HQ = (t) => {
    if (qH(t)) {
      const r = t.touches[0];
      return bk(r.clientX, r.clientY);
    } else
      return bk(t.clientX, t.clientY);
  }, zQ = (t, r) => {
    const l = j1.DOM.getPos(t);
    return LQ(r, l.x, l.y);
  }, YM = (t, r) => r.type === "contextmenu" || r.type === "longpress" ? t.inline ? $Q(r) : zQ(t.getContentAreaContainer(), HQ(r)) : KH(t), KH = (t) => ({
    type: "selection",
    root: $e.fromDom(t.selection.getNode())
  }), VQ = (t) => ({
    type: "node",
    node: B.some($e.fromDom(t.selection.getNode())),
    root: $e.fromDom(t.getBody())
  }), D3 = (t, r, l) => {
    switch (l) {
      case "node":
        return VQ(t);
      case "point":
        return YM(t, r);
      case "selection":
        return KH(t);
    }
  }, YH = (t, r, l, d, h, y) => {
    const w = l(), E = D3(t, r, y);
    Qx(w, im.CLOSE_ON_EXECUTE, d, {
      isHorizontalMenu: !1,
      search: B.none()
    }).map((O) => {
      r.preventDefault(), aa.showMenuAt(h, { anchor: E }, {
        menu: { markers: pb("normal") },
        data: O
      });
    });
  }, XH = {
    onLtr: () => [
      ti,
      fi,
      ei,
      mi,
      br,
      Si,
      gm,
      JS,
      QS,
      GA,
      XS,
      ZA
    ],
    onRtl: () => [
      ti,
      ei,
      fi,
      br,
      mi,
      Si,
      gm,
      JS,
      XS,
      ZA,
      QS,
      GA
    ]
  }, UQ = 12, jQ = {
    valignCentre: [],
    alignCentre: [],
    alignLeft: ["tox-pop--align-left"],
    alignRight: ["tox-pop--align-right"],
    right: ["tox-pop--right"],
    left: ["tox-pop--left"],
    bottom: ["tox-pop--bottom"],
    top: ["tox-pop--top"]
  }, WQ = (t, r) => {
    const l = t.selection;
    if (l.isCollapsed() || r.touches.length < 1)
      return !1;
    {
      const d = r.touches[0], h = l.getRng();
      return Bi(t.getWin(), qv.domRange(h)).exists((w) => w.left <= d.clientX && w.right >= d.clientX && w.top <= d.clientY && w.bottom >= d.clientY);
    }
  }, ZQ = (t) => {
    const r = t.selection.getRng(), l = () => {
      JC.setEditorTimeout(t, () => {
        t.selection.setRng(r);
      }, 10), y();
    };
    t.once("touchend", l);
    const d = (w) => {
      w.preventDefault(), w.stopImmediatePropagation();
    };
    t.on("mousedown", d, !0);
    const h = () => y();
    t.once("longpresscancel", h);
    const y = () => {
      t.off("touchend", l), t.off("longpresscancel", h), t.off("mousedown", d);
    };
  }, GQ = (t, r, l) => {
    const d = D3(t, r, l);
    return {
      bubble: Od(0, l === "point" ? UQ : 0, jQ),
      layouts: XH,
      overrides: {
        maxWidthFunction: i2(),
        maxHeightFunction: jv()
      },
      ...d
    };
  }, XM = (t, r, l, d, h, y, w) => {
    const E = GQ(t, r, y);
    Qx(l, im.CLOSE_ON_EXECUTE, d, {
      isHorizontalMenu: !0,
      search: B.none()
    }).map((O) => {
      r.preventDefault();
      const F = w ? Pc.HighlightMenuAndItem : Pc.HighlightNone;
      aa.showMenuWithinBounds(h, { anchor: E }, {
        menu: {
          markers: pb("normal"),
          highlightOnOpen: F
        },
        data: O,
        type: "horizontal"
      }, () => B.some(BH(t, d.shared, y === "node" ? "node" : "selection"))), t.dispatch(PH);
    });
  }, qQ = (t, r, l, d, h, y) => {
    const w = $l(), E = w.os.isiOS(), O = w.os.isMacOS(), F = w.os.isAndroid(), L = w.deviceType.isTouch(), q = () => !(F || E || O && L), ne = () => {
      const ae = l();
      XM(t, r, ae, d, h, y, q());
    };
    if ((O || E) && y !== "node") {
      const ae = () => {
        ZQ(t), ne();
      };
      WQ(t, r) ? ae() : (t.once("selectionchange", ae), t.once("touchend", () => t.off("selectionchange", ae)));
    } else
      ne();
  }, QM = (t) => A(t) ? t === "|" : t.type === "separator", JM = { type: "separator" }, QH = (t) => {
    const r = (l) => ({
      text: l.text,
      icon: l.icon,
      enabled: l.enabled,
      shortcut: l.shortcut
    });
    if (A(t))
      return t;
    switch (t.type) {
      case "separator":
        return JM;
      case "submenu":
        return {
          type: "nestedmenuitem",
          ...r(t),
          getSubmenuItems: () => {
            const d = t.getSubmenuItems();
            return A(d) ? d : et(d, QH);
          }
        };
      default:
        const l = t;
        return {
          type: "menuitem",
          ...r(l),
          onAction: ve(l.onAction)
        };
    }
  }, R3 = (t, r) => {
    if (r.length === 0)
      return t;
    const d = xs(t).filter((h) => !QM(h)).fold(() => [], (h) => [JM]);
    return t.concat(d).concat(r).concat([JM]);
  }, KQ = (t, r, l) => {
    const d = Pt(r, (h, y) => qt(t, y.toLowerCase()).map((w) => {
      const E = w.update(l);
      if (A(E) && Ne(Tr(E)))
        return R3(h, E.split(" "));
      if (Z(E) && E.length > 0) {
        const O = et(E, QH);
        return R3(h, O);
      } else
        return h;
    }).getOrThunk(() => h.concat([y])), []);
    return d.length > 0 && QM(d[d.length - 1]) && d.pop(), d;
  }, JH = (t, r) => r.ctrlKey && !KM(t), YQ = (t) => t.type === "longpress" || Ko(t, "touches"), ez = (t, r) => !YQ(r) && (r.button !== 2 || r.target === t.getBody() && r.pointerType === ""), N3 = (t, r) => ez(t, r) ? t.selection.getStart(!0) : r.target, XQ = (t, r) => {
    const l = FQ(t), d = ez(t, r) ? "selection" : "point";
    if (Ne(l)) {
      const h = N3(t, r);
      return DS($e.fromDom(h), l) ? "node" : d;
    } else
      return d;
  }, QQ = (t, r, l) => {
    const h = $l().deviceType.isTouch, y = Ol(aa.sketch({
      dom: { tag: "div" },
      lazySink: r,
      onEscape: () => t.focus(),
      onShow: () => l.setContextMenuState(!0),
      onHide: () => l.setContextMenuState(!1),
      fireDismissalEventInstead: {},
      inlineBehaviours: Jt([jo("dismissContextMenu", [Ft(Lp(), (O, F) => {
        Ns.close(O), t.focus();
      })])])
    })), w = () => aa.hide(y), E = (O) => {
      if (KM(t) && O.preventDefault(), JH(t, O) || BQ(t))
        return;
      const F = XQ(t, O), L = () => {
        const ne = N3(t, O), ae = t.ui.registry.getAll(), de = GH(t);
        return KQ(ae.contextMenus, de, ne);
      };
      (h() ? qQ : YH)(t, O, L, l, y, F);
    };
    t.on("init", () => {
      const O = "ResizeEditor ScrollContent ScrollWindow longpresscancel" + (h() ? "" : " ResizeWindow");
      t.on(O, w), t.on("longpress contextmenu", E);
    });
  }, e5 = Be.generate([
    {
      offset: [
        "x",
        "y"
      ]
    },
    {
      absolute: [
        "x",
        "y"
      ]
    },
    {
      fixed: [
        "x",
        "y"
      ]
    }
  ]), P3 = (t) => (r) => r.translate(-t.left, -t.top), M3 = (t) => (r) => r.translate(t.left, t.top), _h = (t) => (r, l) => Pt(t, (d, h) => h(d), $r(r, l)), I3 = (t, r, l) => t.fold(_h([
    M3(l),
    P3(r)
  ]), _h([P3(r)]), _h([])), p2 = (t, r, l) => t.fold(_h([M3(l)]), _h([]), _h([M3(r)])), tz = (t, r, l) => t.fold(_h([]), _h([P3(l)]), _h([
    M3(r),
    P3(l)
  ])), JQ = (t, r, l, d, h, y) => {
    const w = p2(t, h, y), E = p2(r, h, y);
    return Math.abs(w.left - E.left) <= l && Math.abs(w.top - E.top) <= d;
  }, eJ = (t, r, l, d, h, y) => {
    const w = p2(t, h, y), E = p2(r, h, y), O = Math.abs(w.left - E.left), F = Math.abs(w.top - E.top);
    return $r(O, F);
  }, nz = (t, r, l) => {
    const d = t.fold((h, y) => ({
      position: B.some("absolute"),
      left: B.some(h + "px"),
      top: B.some(y + "px")
    }), (h, y) => ({
      position: B.some("absolute"),
      left: B.some(h - l.left + "px"),
      top: B.some(y - l.top + "px")
    }), (h, y) => ({
      position: B.some("fixed"),
      left: B.some(h + "px"),
      top: B.some(y + "px")
    }));
    return {
      right: B.none(),
      bottom: B.none(),
      ...d
    };
  }, tJ = (t, r, l) => t.fold((d, h) => yk(d + r, h + l), (d, h) => Eb(d + r, h + l), (d, h) => Tb(d + r, h + l)), t5 = (t, r, l, d) => {
    const h = (y, w) => (E, O) => {
      const F = y(r, l, d);
      return w(E.getOr(F.left), O.getOr(F.top));
    };
    return t.fold(h(tz, yk), h(p2, Eb), h(I3, Tb));
  }, yk = e5.offset, Eb = e5.absolute, Tb = e5.fixed, oz = (t, r) => {
    const l = tr(t, r);
    return pe(l) ? NaN : parseInt(l, 10);
  }, nJ = (t, r) => {
    const l = t.element, d = oz(l, r.leftAttr), h = oz(l, r.topAttr);
    return isNaN(d) || isNaN(h) ? B.none() : B.some($r(d, h));
  }, oJ = (t, r, l) => {
    const d = t.element;
    sn(d, r.leftAttr, l.left + "px"), sn(d, r.topAttr, l.top + "px");
  }, x0 = (t, r) => {
    const l = t.element;
    Ee(l, r.leftAttr), Ee(l, r.topAttr);
  }, sz = (t, r, l, d) => nJ(t, r).fold(() => l, (h) => Tb(h.left + d.left, h.top + d.top)), sJ = (t, r, l, d, h, y) => {
    const w = sz(t, r, l, d), E = r.mustSnap ? aJ(t, r, w, h, y) : az(t, r, w, h, y), O = I3(w, h, y);
    return oJ(t, r, O), E.fold(() => ({
      coord: Tb(O.left, O.top),
      extra: B.none()
    }), (F) => ({
      coord: F.output,
      extra: F.extra
    }));
  }, rJ = (t, r) => {
    x0(t, r);
  }, rz = (t, r, l, d) => Qo(t, (h) => {
    const y = h.sensor;
    return JQ(r, y, h.range.left, h.range.top, l, d) ? B.some({
      output: t5(h.output, r, l, d),
      extra: h.extra
    }) : B.none();
  }), aJ = (t, r, l, d, h) => {
    const y = r.getSnapPoints(t);
    return rz(y, l, d, h).orThunk(() => Pt(y, (O, F) => {
      const L = F.sensor, q = eJ(l, L, F.range.left, F.range.top, d, h);
      return O.deltas.fold(() => ({
        deltas: B.some(q),
        snap: B.some(F)
      }), (ne) => {
        const ae = (q.left + q.top) / 2, de = (ne.left + ne.top) / 2;
        return ae <= de ? {
          deltas: B.some(q),
          snap: B.some(F)
        } : O;
      });
    }, {
      deltas: B.none(),
      snap: B.none()
    }).snap.map((O) => ({
      output: t5(O.output, l, d, h),
      extra: O.extra
    })));
  }, az = (t, r, l, d, h) => {
    const y = r.getSnapPoints(t);
    return rz(y, l, d, h);
  }, iJ = (t, r, l) => ({
    coord: t5(t.output, t.output, r, l),
    extra: t.extra
  });
  var lJ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    snapTo: (t, r, l, d) => {
      const h = r.getTarget(t.element);
      if (r.repositionTarget) {
        const y = li(t.element), w = Ci(y), E = fw(h), O = iJ(d, w, E), F = nz(O.coord, w, E);
        Kt(h, F);
      }
    }
  });
  const n5 = "data-initial-z-index", cJ = (t) => {
    Za(t.element).filter(ko).each((r) => {
      Y(r, n5).fold(() => gs(r, "z-index"), (l) => Ln(r, "z-index", l)), Ee(r, n5);
    });
  }, uJ = (t) => {
    Za(t.element).filter(ko).each((r) => {
      Cr(r, "z-index").each((l) => {
        sn(r, n5, l);
      }), Ln(r, "z-index", lr(t.element, "z-index"));
    });
  }, iz = (t, r) => {
    t.getSystem().addToGui(r), uJ(r);
  }, dJ = (t) => {
    cJ(t), t.getSystem().removeFromGui(t);
  }, lz = (t, r, l) => t.getSystem().build(op.sketch({
    dom: {
      styles: {
        left: "0px",
        top: "0px",
        width: "100%",
        height: "100%",
        position: "fixed",
        "z-index": "1000000000000000"
      },
      classes: [r]
    },
    events: l
  }));
  var fJ = kr("snaps", [
    Mt("getSnapPoints"),
    Os("onSensor"),
    Mt("leftAttr"),
    Mt("topAttr"),
    Xe("lazyViewport", Na),
    Xe("mustSnap", !1)
  ]);
  const F3 = [
    Xe("useFixed", _t),
    Mt("blockerClass"),
    Xe("getTarget", lt),
    Xe("onDrag", U),
    Xe("repositionTarget", !0),
    Xe("onDrop", U),
    Ca("getBounds", Na),
    fJ
  ], cz = (t) => la(Cr(t, "left"), Cr(t, "top"), Cr(t, "position"), (r, l, d) => (d === "fixed" ? Tb : yk)(parseInt(r, 10), parseInt(l, 10))).getOrThunk(() => {
    const r = Ga(t);
    return Eb(r.left, r.top);
  }), mJ = (t, r, l, d, h) => {
    const y = h.bounds, w = p2(r, l, d), E = Ad(w.left, y.x, y.x + y.width - h.width), O = Ad(w.top, y.y, y.y + y.height - h.height), F = Eb(E, O);
    return r.fold(() => {
      const L = tz(F, l, d);
      return yk(L.left, L.top);
    }, ee(F), () => {
      const L = I3(F, l, d);
      return Tb(L.left, L.top);
    });
  }, xk = (t, r, l, d, h, y, w) => {
    const E = r.fold(() => {
      const O = tJ(l, y.left, y.top), F = I3(O, d, h);
      return Tb(F.left, F.top);
    }, (O) => {
      const F = sJ(t, O, l, y, d, h);
      return F.extra.each((L) => {
        O.onSensor(t, L);
      }), F.coord;
    });
    return mJ(t, E, d, h, w);
  }, pJ = (t, r, l, d) => {
    const h = r.getTarget(t.element);
    if (r.repositionTarget) {
      const y = li(t.element), w = Ci(y), E = fw(h), O = cz(h), F = xk(t, r.snaps, O, w, E, d, l), L = nz(F, w, E);
      Kt(h, L);
    }
    r.onDrag(t, h, d);
  }, uz = (t, r) => ({
    bounds: t.getBounds(),
    height: pd(r.element),
    width: ci(r.element)
  }), wk = (t, r, l, d, h) => {
    const y = l.update(d, h), w = l.getStartData().getOrThunk(() => uz(r, t));
    y.each((E) => {
      pJ(t, r, w, E);
    });
  }, dz = (t, r, l, d) => {
    r.each(dJ), l.snaps.each((y) => {
      rJ(t, y);
    });
    const h = l.getTarget(t.element);
    d.reset(), l.onDrop(t, h);
  }, o5 = (t) => (r, l) => {
    const d = (h) => {
      l.setStartData(uz(r, h));
    };
    return zr([
      Ft(ng(), (h) => {
        l.getStartData().each(() => d(h));
      }),
      ...t(r, l, d)
    ]);
  }, hJ = (t) => zr([
    Ft(sc(), t.forceDrop),
    Ft(Fm(), t.drop),
    Ft(Sv(), (r, l) => {
      t.move(l.event);
    }),
    Ft(_d(), t.delayDrop)
  ]);
  var gJ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getData: (t) => B.from($r(t.x, t.y)),
    getDelta: (t, r) => $r(r.left - t.left, r.top - t.top)
  });
  const fz = (t, r, l) => [Ft(sc(), (d, h) => {
    if (h.event.raw.button !== 0)
      return;
    h.stop();
    const w = () => dz(d, B.some(F), t, r), E = S6(w, 200), O = {
      drop: w,
      delayDrop: E.schedule,
      forceDrop: w,
      move: (q) => {
        E.cancel(), wk(d, t, r, gJ, q);
      }
    }, F = lz(d, t.blockerClass, hJ(O));
    (() => {
      l(d), iz(d, F);
    })();
  })], vJ = [
    ...F3,
    Ur("dragger", { handlers: o5(fz) })
  ], bJ = (t) => zr([
    Ft(vs(), t.forceDrop),
    Ft(Ja(), t.drop),
    Ft(Oc(), t.drop),
    Ft(Gr(), (r, l) => {
      t.move(l.event);
    })
  ]), yJ = (t) => {
    const r = t[0];
    return B.some($r(r.clientX, r.clientY));
  };
  var mz = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getData: (t) => {
      const l = t.raw.touches;
      return l.length === 1 ? yJ(l) : B.none();
    },
    getDelta: (t, r) => $r(r.left - t.left, r.top - t.top)
  });
  const pz = (t, r, l) => {
    const d = cr(), h = (y) => {
      dz(y, d.get(), t, r), d.clear();
    };
    return [
      Ft(vs(), (y, w) => {
        w.stop();
        const E = () => h(y), O = {
          drop: E,
          delayDrop: U,
          forceDrop: E,
          move: (q) => {
            wk(y, t, r, mz, q);
          }
        }, F = lz(y, t.blockerClass, bJ(O));
        d.set(F), (() => {
          l(y), iz(y, F);
        })();
      }),
      Ft(Gr(), (y, w) => {
        w.stop(), wk(y, t, r, mz, w.event);
      }),
      Ft(Ja(), (y, w) => {
        w.stop(), h(y);
      }),
      Ft(Oc(), h)
    ];
  }, xJ = [
    ...F3,
    Ur("dragger", { handlers: o5(pz) })
  ], wJ = (t, r, l) => [
    ...fz(t, r, l),
    ...pz(t, r, l)
  ], CJ = [
    ...F3,
    Ur("dragger", { handlers: o5(wJ) })
  ];
  var SJ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    mouse: vJ,
    touch: xJ,
    mouseOrTouch: CJ
  }), kJ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      let t = B.none(), r = B.none();
      const l = () => {
        t = B.none(), r = B.none();
      }, d = (O, F) => {
        const L = t.map((q) => O.getDelta(q, F));
        return t = B.some(F), L;
      }, h = (O, F) => O.getData(F).bind((L) => d(O, L)), y = (O) => {
        r = B.some(O);
      }, w = () => r, E = ee({});
      return qc({
        readState: E,
        reset: l,
        update: h,
        getStartData: w,
        setStartData: y
      });
    }
  });
  const w0 = f_({
    branchKey: "mode",
    branches: SJ,
    name: "dragging",
    active: {
      events: (t, r) => t.dragger.handlers(t, r)
    },
    extra: {
      snap: (t) => ({
        sensor: t.sensor,
        range: t.range,
        output: t.output,
        extra: B.from(t.extra)
      })
    },
    state: kJ,
    apis: lJ
  }), B3 = 40, L3 = B3 / 2, hz = (t, r, l, d, h, y) => t.fold(() => w0.snap({
    sensor: Eb(l - L3, d - L3),
    range: $r(h, y),
    output: Eb(B.some(l), B.some(d)),
    extra: { td: r }
  }), (w) => {
    const E = l - L3, O = d - L3, F = B3, L = B3, q = w.element.dom.getBoundingClientRect();
    return w0.snap({
      sensor: Eb(E, O),
      range: $r(F, L),
      output: Eb(B.some(l - q.width / 2), B.some(d - q.height / 2)),
      extra: { td: r }
    });
  }), gz = (t, r, l) => {
    const d = (h, y) => h.exists((w) => Is(w, y));
    return {
      getSnapPoints: t,
      leftAttr: "data-drag-left",
      topAttr: "data-drag-top",
      onSensor: (h, y) => {
        const w = y.td;
        d(r.get(), w) || (r.set(w), l(w));
      },
      mustSnap: !0
    };
  }, vz = (t) => rr(Nl.sketch({
    dom: {
      tag: "div",
      classes: ["tox-selector"]
    },
    buttonBehaviours: Jt([
      w0.config({
        mode: "mouseOrTouch",
        blockerClass: "blocker",
        snaps: t
      }),
      jx.config({})
    ]),
    eventOrder: {
      mousedown: [
        "dragging",
        "alloy.base.behaviour"
      ],
      touchstart: [
        "dragging",
        "alloy.base.behaviour"
      ]
    }
  })), _J = (t, r) => {
    const l = to([]), d = to([]), h = to(!1), y = cr(), w = cr(), E = (bn) => {
      const It = Cl(bn);
      return hz(ae.getOpt(r), bn, It.x, It.y, It.width, It.height);
    }, O = () => et(l.get(), (bn) => E(bn)), F = (bn) => {
      const It = Cl(bn);
      return hz(de.getOpt(r), bn, It.right, It.bottom, It.width, It.height);
    }, L = () => et(d.get(), (bn) => F(bn)), q = gz(O, y, (bn) => {
      w.get().each((It) => {
        t.dispatch("TableSelectorChange", {
          start: bn,
          finish: It
        });
      });
    }), ne = gz(L, w, (bn) => {
      y.get().each((It) => {
        t.dispatch("TableSelectorChange", {
          start: It,
          finish: bn
        });
      });
    }), ae = vz(q), de = vz(ne), _e = Ol(ae.asSpec()), st = Ol(de.asSpec()), Re = (bn, It, Yn, Fn) => {
      const yo = It.dom.getBoundingClientRect();
      gs(bn.element, "display");
      const mo = cl($e.fromDom(t.getBody())).dom.innerHeight, js = Yn(yo), Fs = Fn(yo, mo);
      (js || Fs) && Ln(bn.element, "display", "none");
    }, Qe = (bn, It, Yn, Fn) => {
      const yo = Yn(It);
      w0.snapTo(bn, yo), Re(bn, It, (Fs) => Fs[Fn] < 0, (Fs, ms) => Fs[Fn] > ms);
    }, qe = (bn) => Qe(_e, bn, E, "top"), Bt = () => y.get().each(qe), pt = (bn) => Qe(st, bn, F, "bottom"), en = () => w.get().each(pt);
    if ($l().deviceType.isTouch()) {
      const bn = (It) => et(It, $e.fromDom);
      t.on("TableSelectionChange", (It) => {
        h.get() || (em(r, _e), em(r, st), h.set(!0));
        const Yn = $e.fromDom(It.start), Fn = $e.fromDom(It.finish);
        y.set(Yn), w.set(Fn), B.from(It.otherCells).each((yo) => {
          l.set(bn(yo.upOrLeftCells)), d.set(bn(yo.downOrRightCells)), qe(Yn), pt(Fn);
        });
      }), t.on("ResizeEditor ResizeWindow ScrollContent", () => {
        Bt(), en();
      }), t.on("TableSelectionClear", () => {
        h.get() && (Gm(_e), Gm(st), h.set(!1)), y.clear(), w.clear();
      });
    }
  };
  var r5 = `<svg height="16" viewBox="0 0 80 16" width="80" xmlns="http://www.w3.org/2000/svg"><g opacity=".8"><path d="m80 3.537v-2.202h-7.976v11.585h7.976v-2.25h-5.474v-2.621h4.812v-2.069h-4.812v-2.443zm-10.647 6.929c-.493.217-1.13.337-1.864.337s-1.276-.156-1.805-.47a3.732 3.732 0 0 1 -1.3-1.298c-.324-.554-.48-1.191-.48-1.877s.156-1.335.48-1.877a3.635 3.635 0 0 1 1.3-1.299 3.466 3.466 0 0 1 1.805-.481c.65 0 .914.06 1.263.18.36.12.698.277.986.47.289.192.578.384.842.6l.12.085v-2.586l-.023-.024c-.385-.35-.855-.614-1.384-.818-.53-.205-1.155-.313-1.877-.313-.721 0-1.6.144-2.333.445a5.773 5.773 0 0 0 -1.937 1.251 5.929 5.929 0 0 0 -1.324 1.9c-.324.735-.48 1.565-.48 2.455s.156 1.72.48 2.454c.325.734.758 1.383 1.324 1.913.553.53 1.215.938 1.937 1.25a6.286 6.286 0 0 0 2.333.434c.819 0 1.384-.108 1.961-.313.59-.216 1.083-.505 1.468-.866l.024-.024v-2.49l-.12.096c-.41.337-.878.626-1.396.866zm-14.869-4.15-4.8-5.04-.024-.025h-.902v11.67h2.502v-6.847l2.827 3.08.385.409.397-.41 2.791-3.067v6.845h2.502v-11.679h-.902l-4.788 5.052z"/><path clip-rule="evenodd" d="m15.543 5.137c0-3.032-2.466-5.113-4.957-5.137-.36 0-.745.024-1.094.096-.157.024-3.85.758-3.85.758-3.032.602-4.62 2.466-4.704 4.788-.024.89-.024 4.27-.024 4.27.036 3.165 2.406 5.138 5.017 5.126.337 0 1.119-.109 1.287-.145.144-.024.385-.084.746-.144.661-.12 1.684-.325 3.067-.602 2.37-.409 4.103-2.009 4.44-4.33.156-1.023.084-4.692.084-4.692zm-3.213 3.308-2.346.457v2.31l-5.859 1.143v-5.75l2.346-.458v3.441l3.513-.686v-3.44l-3.513.685v-2.297l5.859-1.143v5.75zm20.09-3.296-.083-1.023h-2.13v8.794h2.346v-4.884c0-1.107.95-1.985 2.057-1.997 1.095 0 1.901.89 1.901 1.997v4.884h2.346v-5.245c-.012-2.105-1.588-3.777-3.67-3.765a3.764 3.764 0 0 0 -2.778 1.25l.012-.011zm-6.014-4.102 2.346-.458v2.298l-2.346.457z" fill-rule="evenodd"/><path d="m28.752 4.126h-2.346v8.794h2.346z"/><path clip-rule="evenodd" d="m43.777 15.483 4.043-11.357h-2.418l-1.54 4.355-.445 1.324-.36-1.324-1.54-4.355h-2.418l3.151 8.794-1.083 3.08zm-21.028-5.51c0 .722.541 1.034.878 1.034s.638-.048.95-.144l.518 1.708c-.217.145-.879.518-2.13.518a2.565 2.565 0 0 1 -2.562-2.587c-.024-1.082-.024-2.49 0-4.21h-1.54v-2.142h1.54v-1.912l2.346-.458v2.37h2.201v2.142h-2.2v3.693-.012z" fill-rule="evenodd"/></g></svg>
`;
  const bz = (t, r) => {
    const l = B.from(tr(t, "id")).getOrThunk(() => {
      const d = Mn("aria");
      return sn(r, "id", d), d;
    });
    sn(t, "aria-describedby", l);
  }, EJ = (t) => {
    Ee(t, "aria-describedby");
  }, TJ = (t) => t.nodeName === "BR" || !!t.getAttribute("data-mce-bogus") || t.getAttribute("data-mce-type") === "bookmark", AJ = (t, r, l) => {
    var d;
    const h = (d = r.delimiter) !== null && d !== void 0 ? d : "›", y = (F, L, q) => Nl.sketch({
      dom: {
        tag: "div",
        classes: ["tox-statusbar__path-item"],
        attributes: { "data-index": q }
      },
      components: [Aa(F)],
      action: (ne) => {
        t.focus(), t.selection.select(L), t.nodeChanged();
      },
      buttonBehaviours: Jt([
        gl.config({
          ...l.tooltips.getConfig({
            tooltipText: l.translate([
              "Select the {0} element",
              L.nodeName.toLowerCase()
            ]),
            onShow: (ne, ae) => {
              bz(ne.element, ae.element);
            },
            onHide: (ne) => {
              EJ(ne.element);
            }
          })
        }),
        dm.button(l.isDisabled),
        ki()
      ])
    }), w = () => ({
      dom: {
        tag: "div",
        classes: ["tox-statusbar__path-divider"],
        attributes: { "aria-hidden": !0 }
      },
      components: [Aa(` ${h} `)]
    }), E = (F) => Pt(F, (L, q, ne) => {
      const ae = y(q.name, q.element, ne);
      return ne === 0 ? L.concat([ae]) : L.concat([
        w(),
        ae
      ]);
    }, []), O = (F) => {
      const L = [];
      let q = F.length;
      for (; q-- > 0; ) {
        const ne = F[q];
        if (ne.nodeType === 1 && !TJ(ne)) {
          const ae = $W(t, ne);
          if (ae.isDefaultPrevented() || L.push({
            name: ae.name,
            element: ne
          }), ae.isPropagationStopped())
            break;
        }
      }
      return L;
    };
    return {
      dom: {
        tag: "div",
        classes: ["tox-statusbar__path"],
        attributes: { role: "navigation" }
      },
      behaviours: Jt([
        so.config({
          mode: "flow",
          selector: "div[role=button]"
        }),
        _o.config({ disabled: l.isDisabled }),
        ki(),
        jr.config({}),
        Po.config({}),
        jo("elementPathEvents", [qr((F, L) => {
          t.shortcuts.add("alt+F11", "focus statusbar elementpath", () => so.focusIn(F)), t.on("NodeChange", (q) => {
            const ne = O(q.parents), ae = ne.length > 0 ? E(ne) : [];
            Po.set(F, ae);
          });
        })])
      ]),
      components: []
    };
  };
  var Ab;
  (function(t) {
    t[t.None = 0] = "None", t[t.Both = 1] = "Both", t[t.Vertical = 2] = "Vertical";
  })(Ab || (Ab = {}));
  const OJ = (t, r, l, d, h) => {
    const y = { height: y0(d + r.top, uT(t), vR(t)) };
    return l === Ab.Both && (y.width = y0(h + r.left, Tx(t), tS(t))), y;
  }, yz = (t, r, l) => {
    const d = $e.fromDom(t.getContainer()), h = OJ(t, r, l, Mr(d), Ri(d));
    it(h, (y, w) => {
      re(y) && Ln(d, w, LM(y));
    }), BW(t);
  }, DJ = (t) => {
    const r = kR(t);
    return r === !1 ? Ab.None : r === "both" ? Ab.Both : Ab.Vertical;
  }, $3 = (t, r, l, d) => {
    const y = $r(l * 20, d * 20);
    return yz(t, y, r), B.some(!0);
  }, RJ = (t, r) => {
    const l = DJ(t);
    if (l === Ab.None)
      return B.none();
    const d = l === Ab.Both ? "Press the arrow keys to resize the editor." : "Press the Up and Down arrow keys to resize the editor.";
    return B.some(ku("resize-handle", {
      tag: "div",
      classes: ["tox-statusbar__resize-handle"],
      attributes: {
        "aria-label": r.translate(d),
        "data-mce-name": "resize-handle"
      },
      behaviours: [
        w0.config({
          mode: "mouse",
          repositionTarget: !1,
          onDrag: (h, y, w) => yz(t, w, l),
          blockerClass: "tox-blocker"
        }),
        so.config({
          mode: "special",
          onLeft: () => $3(t, l, -1, 0),
          onRight: () => $3(t, l, 1, 0),
          onUp: () => $3(t, l, 0, -1),
          onDown: () => $3(t, l, 0, 1)
        }),
        jr.config({}),
        To.config({}),
        gl.config(r.tooltips.getConfig({ tooltipText: r.translate("Resize") }))
      ]
    }, r.icons));
  }, NJ = (t, r) => {
    const l = (d, h, y) => Po.set(d, [Aa(r.translate([
      "{0} " + y,
      h[y]
    ]))]);
    return Nl.sketch({
      dom: {
        tag: "button",
        classes: ["tox-statusbar__wordcount"]
      },
      components: [],
      buttonBehaviours: Jt([
        dm.button(r.isDisabled),
        ki(),
        jr.config({}),
        Po.config({}),
        In.config({
          store: {
            mode: "memory",
            initialValue: {
              mode: "words",
              count: {
                words: 0,
                characters: 0
              }
            }
          }
        }),
        jo("wordcount-events", [
          Td((d) => {
            const h = In.getValue(d), y = h.mode === "words" ? "characters" : "words";
            In.setValue(d, {
              mode: y,
              count: h.count
            }), l(d, h.count, y);
          }),
          qr((d) => {
            t.on("wordCountUpdate", (h) => {
              const { mode: y } = In.getValue(d);
              In.setValue(d, {
                mode: y,
                count: h.wordCount
              }), l(d, h.wordCount, y);
            });
          })
        ])
      ]),
      eventOrder: {
        [Wu()]: [
          "disabling",
          "alloy.base.behaviour",
          "wordcount-events"
        ]
      }
    });
  }, PJ = (t, r) => {
    const l = () => ({
      dom: {
        tag: "span",
        classes: ["tox-statusbar__branding"]
      },
      components: [{
        dom: {
          tag: "a",
          attributes: {
            href: "https://www.tiny.cloud/powered-by-tiny?utm_campaign=poweredby&utm_source=tiny&utm_medium=referral&utm_content=v7",
            rel: "noopener",
            target: "_blank",
            "aria-label": t.translate([
              "Build with {0}",
              "TinyMCE"
            ])
          },
          innerHtml: t.translate([
            "Build with {0}",
            r5.trim()
          ])
        },
        behaviours: Jt([To.config({})])
      }]
    }), d = () => {
      const E = XT("Alt+0");
      return {
        dom: {
          tag: "div",
          classes: ["tox-statusbar__help-text"]
        },
        components: [Aa(Pd.translate([
          "Press {0} for help",
          E
        ]))]
      };
    }, h = () => {
      const E = [];
      return t.hasPlugin("wordcount") && E.push(NJ(t, r)), SR(t) && E.push(l()), {
        dom: {
          tag: "div",
          classes: ["tox-statusbar__right-container"]
        },
        components: E
      };
    }, y = () => {
      const E = [], O = TB(t), F = _B(t), L = SR(t) || t.hasPlugin("wordcount"), q = () => {
        const ne = "tox-statusbar__text-container--flex-start", ae = "tox-statusbar__text-container--flex-end", de = "tox-statusbar__text-container--space-around";
        if (O) {
          const _e = "tox-statusbar__text-container-3-cols";
          return !L && !F ? [
            _e,
            de
          ] : L && !F ? [
            _e,
            ae
          ] : [
            _e,
            ne
          ];
        }
        return [L && !F ? ae : ne];
      };
      return F && E.push(AJ(t, {}, r)), O && E.push(d()), L && E.push(h()), E.length > 0 ? [{
        dom: {
          tag: "div",
          classes: [
            "tox-statusbar__text-container",
            ...q()
          ]
        },
        components: E
      }] : [];
    };
    return {
      dom: {
        tag: "div",
        classes: ["tox-statusbar"]
      },
      components: (() => {
        const E = y(), O = RJ(t, r);
        return E.concat(O.toArray());
      })()
    };
  }, xz = (t, r) => r.get().getOrDie(`UI for ${t} has not been rendered`), MJ = (t, r) => {
    const l = t.inline, d = l ? DH : JX, h = Ox(t) ? oY : d7, y = RH(), w = cr(), E = cr(), O = cr(), ne = $l().deviceType.isTouch() ? ["tox-platform-touch"] : [], ae = Lg(t), de = Z1(t), _e = rr({
      dom: {
        tag: "div",
        classes: ["tox-anchorbar"]
      }
    }), st = rr({
      dom: {
        tag: "div",
        classes: ["tox-bottom-anchorbar"]
      }
    }), Re = () => y.mainUi.get().map((ho) => ho.outerContainer).bind(Wr.getHeader), Qe = () => Ho.fromOption(y.dialogUi.get().map((ho) => ho.sink), "UI has not been rendered"), qe = () => Ho.fromOption(y.popupUi.get().map((ho) => ho.sink), "(popup) UI has not been rendered"), Bt = y.lazyGetInOuterOrDie("anchor bar", _e.getOpt), pt = y.lazyGetInOuterOrDie("bottom anchor bar", st.getOpt), en = y.lazyGetInOuterOrDie("toolbar", Wr.getToolbar), bn = y.lazyGetInOuterOrDie("throbber", Wr.getThrobber), It = GK({
      popup: qe,
      dialog: Qe
    }, t, Bt, pt), Yn = () => {
      const ho = { attributes: { [th]: ae ? eh.BottomToTop : eh.TopToBottom } }, $o = Wr.parts.menubar({
        dom: {
          tag: "div",
          classes: ["tox-menubar"]
        },
        backstage: It.popup,
        onEscape: () => {
          t.focus();
        }
      }), Er = Wr.parts.toolbar({
        dom: {
          tag: "div",
          classes: ["tox-toolbar"]
        },
        getSink: It.popup.shared.getSink,
        providers: It.popup.shared.providers,
        onEscape: () => {
          t.focus();
        },
        onToolbarToggled: (T0) => {
          HW(t, T0);
        },
        type: de,
        lazyToolbar: en,
        lazyHeader: () => Re().getOrDie("Could not find header element"),
        ...ho
      }), Ys = Wr.parts["multiple-toolbar"]({
        dom: {
          tag: "div",
          classes: ["tox-toolbar-overlord"]
        },
        providers: It.popup.shared.providers,
        onEscape: () => {
          t.focus();
        },
        type: de
      }), bc = G1(t), Hd = yT(t), cp = vT(t), ql = nS(t), zd = Fn(), Df = bc || Hd || cp, Du = () => bc ? [Ys] : Hd ? [Er] : [], Ah = ql ? [
        zd,
        $o
      ] : [$o];
      return Wr.parts.header({
        dom: {
          tag: "div",
          classes: ["tox-editor-header"].concat(Df ? [] : ["tox-editor-header--empty"]),
          ...ho
        },
        components: tn([
          cp ? Ah : [],
          Du(),
          Ax(t) ? [] : [_e.asSpec()]
        ]),
        sticky: Ox(t),
        editor: t,
        sharedBackstage: It.popup.shared
      });
    }, Fn = () => Wr.parts.promotion({
      dom: {
        tag: "div",
        classes: ["tox-promotion"]
      }
    }), yo = () => {
      const ho = Wr.parts.socket({
        dom: {
          tag: "div",
          classes: ["tox-edit-area"]
        }
      }), $o = Wr.parts.sidebar({
        dom: {
          tag: "div",
          classes: ["tox-sidebar"]
        }
      });
      return {
        dom: {
          tag: "div",
          classes: ["tox-sidebar-wrap"]
        },
        components: [
          ho,
          $o
        ]
      };
    }, mo = () => {
      const ho = oS(t), $o = Is(Uo(), ho) && lr(ho, "display") === "grid", Er = {
        dom: {
          tag: "div",
          classes: [
            "tox",
            "tox-silver-sink",
            "tox-tinymce-aux"
          ].concat(ne),
          attributes: { ...Pd.isRtl() ? { dir: "rtl" } : {} }
        },
        behaviours: Jt([tl.config({ useFixed: () => h.isDocked(Re) })])
      }, Ys = {
        dom: { styles: { width: document.body.clientWidth + "px" } },
        events: zr([Ft(af(), (cp) => {
          Ln(cp.element, "width", document.body.clientWidth + "px");
        })])
      }, bc = Ol(Pr(Er, $o ? Ys : {})), Hd = jN(bc);
      return E.set(Hd), {
        sink: bc,
        mothership: Hd
      };
    }, js = () => {
      const ho = {
        dom: {
          tag: "div",
          classes: [
            "tox",
            "tox-silver-sink",
            "tox-silver-popup-sink",
            "tox-tinymce-aux"
          ].concat(ne),
          attributes: { ...Pd.isRtl() ? { dir: "rtl" } : {} }
        },
        behaviours: Jt([tl.config({
          useFixed: () => h.isDocked(Re),
          getBounds: () => r.getPopupSinkBounds()
        })])
      }, $o = Ol(ho), Er = jN($o);
      return O.set(Er), {
        sink: $o,
        mothership: Er
      };
    }, Fs = () => {
      const ho = Yn(), $o = yo(), Er = Wr.parts.throbber({
        dom: {
          tag: "div",
          classes: ["tox-throbber"]
        },
        backstage: It.popup
      }), Ys = Wr.parts.viewWrapper({ backstage: It.popup }), bc = kB(t) && !l ? B.some(PJ(t, It.popup.shared.providers)) : B.none(), Hd = tn([
        ae ? [] : [ho],
        l ? [] : [$o],
        ae ? [ho] : []
      ]), cp = Wr.parts.editorContainer({
        components: tn([
          Hd,
          l ? [] : [st.asSpec()]
        ])
      }), ql = xT(t), zd = {
        role: "application",
        ...Pd.isRtl() ? { dir: "rtl" } : {},
        ...ql ? { "aria-hidden": "true" } : {}
      }, Df = Ol(Wr.sketch({
        dom: {
          tag: "div",
          classes: [
            "tox",
            "tox-tinymce"
          ].concat(l ? ["tox-tinymce-inline"] : []).concat(ae ? ["tox-tinymce--toolbar-bottom"] : []).concat(ne),
          styles: {
            visibility: "hidden",
            ...ql ? {
              opacity: "0",
              border: "0"
            } : {}
          },
          attributes: zd
        },
        components: [
          cp,
          ...l ? [] : [
            Ys,
            ...bc.toArray()
          ],
          Er
        ],
        behaviours: Jt([
          ki(),
          _o.config({ disableClass: "tox-tinymce--disabled" }),
          so.config({
            mode: "cyclic",
            selector: ".tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a, .tox-statusbar__resize-handle"
          })
        ])
      })), Du = jN(Df);
      return w.set(Du), {
        mothership: Du,
        outerContainer: Df
      };
    }, ms = (ho) => {
      const $o = LM(x3(t)), Er = LM(TH(t));
      return t.inline || (Ll("div", "width", Er) && Ln(ho.element, "width", Er), Ll("div", "height", $o) ? Ln(ho.element, "height", $o) : Ln(ho.element, "height", "400px")), $o;
    }, cn = (ho) => {
      t.addShortcut("alt+F9", "focus menubar", () => {
        Wr.focusMenubar(ho);
      }), t.addShortcut("alt+F10", "focus toolbar", () => {
        Wr.focusToolbar(ho);
      }), t.addCommand("ToggleToolbarDrawer", ($o, Er) => {
        Er != null && Er.skipFocus ? Wr.toggleToolbarDrawerWithoutFocusing(ho) : Wr.toggleToolbarDrawer(ho);
      }), t.addQueryStateHandler("ToggleToolbarDrawer", () => Wr.isToolbarDrawerToggled(ho));
    }, Un = (ho) => {
      const { mainUi: $o, popupUi: Er, uiMotherships: Ys } = ho;
      kt(fT(t), (y2, t4) => {
        t.ui.registry.addGroupToolbarButton(t4, y2);
      });
      const { buttons: bc, menuItems: Hd, contextToolbars: cp, sidebars: ql, views: zd } = t.ui.registry.getAll(), Df = AR(t), Du = {
        menuItems: Hd,
        menus: OR(t),
        menubar: xR(t),
        toolbar: Df.getOrThunk(() => mT(t)),
        allowToolbarGroups: de === ed.floating,
        buttons: bc,
        sidebar: ql,
        views: zd
      };
      cn($o.outerContainer), qK(t, $o.mothership, Ys), h.setup(t, It.popup.shared, Re), PQ(t, It.popup), QQ(t, It.popup.shared.getSink, It.popup), dY(t), CY(t, bn, It.popup.shared), gQ(t, cp, Er.sink, { backstage: It.popup }), _J(t, Er.sink);
      const Ah = t.getElement(), T0 = ms($o.outerContainer), x5 = {
        targetNode: Ah,
        height: T0
      };
      return d.render(t, ho, Du, It.popup, x5);
    }, Vo = (ho) => (O.set(ho.mothership), ho), Co = () => {
      const ho = Fs(), $o = mo(), Er = fb(t) ? js() : Vo($o);
      y.dialogUi.set($o), y.popupUi.set(Er), y.mainUi.set(ho);
      const Ys = {
        popupUi: Er,
        dialogUi: $o,
        mainUi: ho,
        uiMotherships: y.getUiMotherships()
      };
      return Un(Ys);
    };
    return {
      popups: {
        backstage: It.popup,
        getMothership: () => xz("popups", O)
      },
      dialogs: {
        backstage: It.dialog,
        getMothership: () => xz("dialogs", E)
      },
      renderUI: Co
    };
  }, IJ = (t) => t.dom.textContent, wz = (t, r) => {
    const l = Y(t, "id").fold(() => {
      const d = Mn("dialog-label");
      return sn(r, "id", d), d;
    }, lt);
    sn(t, "aria-labelledby", l);
  }, FJ = ee([
    Mt("lazySink"),
    $s("dragBlockClass"),
    Ca("getBounds", Na),
    Xe("useTabstopAt", ot),
    Xe("firstTabstop", 0),
    Xe("eventOrder", {}),
    $i("modalBehaviours", [so]),
    ic("onExecute"),
    Hm("onEscape")
  ]), a5 = { sketch: lt }, BJ = ee([
    Su({
      name: "draghandle",
      overrides: (t, r) => ({
        behaviours: Jt([w0.config({
          mode: "mouse",
          getTarget: (l) => Vm(l, '[role="dialog"]').getOr(l),
          blockerClass: t.dragBlockClass.getOrDie(new Error(`The drag blocker class was not specified for a dialog with a drag handle: 
` + JSON.stringify(r, null, 2)).message),
          getBounds: t.getDragBounds
        })])
      })
    }),
    hl({
      schema: [Mt("dom")],
      name: "title"
    }),
    hl({
      factory: a5,
      schema: [Mt("dom")],
      name: "close"
    }),
    hl({
      factory: a5,
      schema: [Mt("dom")],
      name: "body"
    }),
    Su({
      factory: a5,
      schema: [Mt("dom")],
      name: "footer"
    }),
    Xu({
      factory: {
        sketch: (t, r) => ({
          ...t,
          dom: r.dom,
          components: r.components
        })
      },
      schema: [
        Xe("dom", {
          tag: "div",
          styles: {
            position: "fixed",
            left: "0px",
            top: "0px",
            right: "0px",
            bottom: "0px"
          }
        }),
        Xe("components", [])
      ],
      name: "blocker"
    })
  ]), LJ = (t, r, l, d) => {
    const h = cr(), y = (de) => {
      h.set(de);
      const _e = t.lazySink(de).getOrDie(), st = d.blocker(), Re = _e.getSystem().build({
        ...st,
        components: st.components.concat([Vl(de)]),
        behaviours: Jt([
          To.config({}),
          jo("dialog-blocker-events", [_v(nf(), () => {
            lp.isBlocked(de) ? U() : so.focusIn(de);
          })])
        ])
      });
      em(_e, Re), so.focusIn(de);
    }, w = (de) => {
      h.clear(), Za(de.element).each((_e) => {
        de.getSystem().getByDom(_e).each((st) => {
          Gm(st);
        });
      });
    }, E = (de) => fc(de, t, "body"), O = (de) => Qt(de, t, "footer"), F = (de, _e) => {
      lp.block(de, _e);
    }, L = (de) => {
      lp.unblock(de);
    }, q = Mn("modal-events"), ne = {
      ...t.eventOrder,
      [rc()]: [q].concat(t.eventOrder["alloy.system.attached"] || [])
    }, ae = $l();
    return {
      uid: t.uid,
      dom: t.dom,
      components: r,
      apis: {
        show: y,
        hide: w,
        getBody: E,
        getFooter: O,
        setIdle: L,
        setBusy: F
      },
      eventOrder: ne,
      domModification: {
        attributes: {
          role: "dialog",
          "aria-modal": "true"
        }
      },
      behaviours: Hi(t.modalBehaviours, [
        Po.config({}),
        so.config({
          mode: "cyclic",
          onEnter: t.onExecute,
          onEscape: t.onEscape,
          useTabstopAt: t.useTabstopAt,
          firstTabstop: t.firstTabstop
        }),
        lp.config({ getRoot: h.get }),
        jo(q, [qr((de) => {
          const _e = fc(de, t, "title").element, st = IJ(_e);
          ae.os.isMacOS() && be(st) ? sn(de.element, "aria-label", st) : wz(de.element, _e);
        })])
      ])
    };
  }, zi = Wl({
    name: "ModalDialog",
    configFields: FJ(),
    partFields: BJ(),
    factory: LJ,
    apis: {
      show: (t, r) => {
        t.show(r);
      },
      hide: (t, r) => {
        t.hide(r);
      },
      getBody: (t, r) => t.getBody(r),
      getFooter: (t, r) => t.getFooter(r),
      setBusy: (t, r, l) => {
        t.setBusy(r, l);
      },
      setIdle: (t, r) => {
        t.setIdle(r);
      }
    }
  }), $J = xo([
    oi,
    LT
  ].concat(J1)), HJ = Ec, i5 = [
    fN("button"),
    yf,
    gu("align", "end", [
      "start",
      "end"
    ]),
    yS,
    lm,
    Zb("buttonType", [
      "primary",
      "secondary"
    ])
  ], l5 = [
    ...i5,
    zg
  ], H3 = [
    Yi("type", [
      "submit",
      "cancel",
      "custom"
    ]),
    ...l5
  ], C0 = [
    Yi("type", ["menu"]),
    vb,
    bS,
    yf,
    Ac("items", $J),
    ...i5
  ], zJ = [
    ...i5,
    Yi("type", ["togglebutton"]),
    bS,
    yf,
    vb,
    Ea("active", !1)
  ], c5 = ui("type", {
    submit: H3,
    cancel: H3,
    custom: H3,
    menu: C0,
    togglebutton: zJ
  }), z3 = [
    oi,
    zg,
    Yi("level", [
      "info",
      "warn",
      "error",
      "success"
    ]),
    cL,
    Xe("url", "")
  ], VJ = xo(z3), UJ = (t) => [
    oi,
    t
  ], jJ = [
    oi,
    zg,
    lm,
    fN("button"),
    yf,
    uW,
    Zb("buttonType", [
      "primary",
      "secondary",
      "toolbar"
    ]),
    yS
  ], WJ = xo(jJ), h2 = [
    oi,
    LT
  ], au = h2.concat([HT]), Cz = h2.concat([
    $T,
    lm
  ]), ZJ = xo(Cz), GJ = Ec, qJ = au.concat([UT("auto")]), KJ = xo(qJ), YJ = jb([
    vS,
    zg,
    cL
  ]), XJ = au.concat([Ii("storageKey", "default")]), QJ = xo(XJ), JJ = Tn, Ck = xo(au), u5 = Tn, V3 = h2.concat([
    Ii("tag", "textarea"),
    Va("scriptId"),
    Va("scriptUrl"),
    Cd("onFocus"),
    D("settings", void 0)
  ]), S0 = h2.concat([
    Ii("tag", "textarea"),
    Tc("init")
  ]), U3 = Jh((t) => ra("customeditor.old", Mi(S0), t).orThunk(() => ra("customeditor.new", Mi(V3), t))), eee = Tn, kz = xo(au), _z = Mm(), nee = (t) => [
    oi,
    yv("columns"),
    t
  ], oee = [
    oi,
    Va("html"),
    gu("presets", "presentation", [
      "presentation",
      "document"
    ]),
    Ca("onInit", U),
    Ea("stretched", !1)
  ], see = xo(oee), Ez = au.concat([
    Ea("border", !1),
    Ea("sandboxed", !0),
    Ea("streamContent", !1),
    Ea("transparent", !0)
  ]), Tz = xo(Ez), d5 = Tn, ree = xo(h2.concat([Ua("height")])), aee = xo([
    Va("url"),
    Im("zoom"),
    Im("cachedWidth"),
    Im("cachedHeight")
  ]), iee = au.concat([
    Ua("inputMode"),
    Ua("placeholder"),
    Ea("maximized", !1),
    lm
  ]), Az = xo(iee), lee = Tn, cee = (t) => [
    oi,
    $T,
    t,
    gu("align", "start", [
      "start",
      "center",
      "end"
    ]),
    Ua("for")
  ], uee = [
    zg,
    vS
  ], f5 = [
    zg,
    Ac("items", Pp("items", () => j3))
  ], j3 = Rp([
    xo(uee),
    xo(f5)
  ]), dee = au.concat([
    Ac("items", j3),
    lm
  ]), Oz = xo(dee), fee = Tn, mee = au.concat([
    X0("items", [
      zg,
      vS
    ]),
    Ip("size", 1),
    lm
  ]), Dz = xo(mee), pee = Tn, hee = au.concat([
    Ea("constrain", !0),
    lm
  ]), k0 = xo(hee), m5 = xo([
    Va("width"),
    Va("height")
  ]), gee = h2.concat([
    $T,
    Ip("min", 0),
    Ip("max", 0)
  ]), W3 = xo(gee), g2 = zf, Z3 = [
    oi,
    Ac("header", Tn),
    Ac("cells", jc(Tn))
  ], Rz = xo(Z3), G3 = au.concat([
    Ua("placeholder"),
    Ea("maximized", !1),
    lm
  ]), Tu = xo(G3), q3 = Tn, p5 = [
    Yi("type", [
      "directory",
      "leaf"
    ]),
    lL,
    Va("id"),
    wd("menu", g7)
  ], Nz = xo(p5), bee = p5.concat([Ac("children", Pp("children", () => Vf("type", {
    directory: Yg,
    leaf: Nz
  })))]), Yg = xo(bee), Cae = Vf("type", {
    directory: Yg,
    leaf: Nz
  }), yee = [
    oi,
    Ac("items", Cae),
    Cd("onLeafAction"),
    Cd("onToggleExpand"),
    I("defaultExpandedIds", [], Tn),
    Ua("defaultSelectedId")
  ], Pz = xo(yee), v2 = au.concat([
    gu("filetype", "file", [
      "image",
      "media",
      "file"
    ]),
    lm,
    Ua("picker_text")
  ]), K3 = xo(v2), Mz = xo([
    vS,
    uN
  ]), h5 = (t) => Qa("items", "items", nc(), jc(Jh((r) => ra(`Checking item of ${t}`, g5, r).fold((l) => Ho.error(zu(l)), (l) => Ho.value(l))))), g5 = Xa(() => Vf("type", {
    alertbanner: VJ,
    bar: xo(UJ(h5("bar"))),
    button: WJ,
    checkbox: ZJ,
    colorinput: QJ,
    colorpicker: Ck,
    dropzone: kz,
    grid: xo(nee(h5("grid"))),
    iframe: Tz,
    input: Az,
    listbox: Oz,
    selectbox: Dz,
    sizeinput: k0,
    slider: W3,
    textarea: Tu,
    urlinput: K3,
    customeditor: U3,
    htmlpanel: see,
    imagepreview: ree,
    collection: KJ,
    label: xo(cee(h5("label"))),
    table: Rz,
    tree: Pz,
    panel: Iz
  })), xee = [
    oi,
    Xe("classes", []),
    Ac("items", g5)
  ], Iz = xo(xee), b2 = [
    fN("tab"),
    lL,
    Ac("items", g5)
  ], Sae = [
    oi,
    X0("tabs", b2)
  ], wee = xo(Sae), Cee = l5, kae = c5, See = xo([
    Va("title"),
    Ls("body", Vf("type", {
      panel: Iz,
      tabpanel: wee
    })),
    Ii("size", "normal"),
    I("buttons", [], kae),
    Xe("initialData", {}),
    Ca("onAction", U),
    Ca("onChange", U),
    Ca("onSubmit", U),
    Ca("onClose", U),
    Ca("onCancel", U),
    Ca("onTabChange", U)
  ]), kee = (t) => ra("dialog", See, t), Sk = xo([
    Yi("type", [
      "cancel",
      "custom"
    ]),
    ...Cee
  ]), _ee = xo([
    Va("title"),
    Va("url"),
    Im("height"),
    Im("width"),
    Vu("buttons", Sk),
    Ca("onAction", U),
    Ca("onCancel", U),
    Ca("onClose", U),
    Ca("onMessage", U)
  ]), Eee = (t) => ra("dialog", _ee, t), Y3 = (t) => N(t) ? [t].concat(je(hr(t), Y3)) : Z(t) ? je(t, Y3) : [], Tee = (t) => A(t.type) && A(t.name), _ae = {
    checkbox: GJ,
    colorinput: JJ,
    colorpicker: u5,
    dropzone: _z,
    input: lee,
    iframe: d5,
    imagepreview: aee,
    selectbox: pee,
    sizeinput: m5,
    slider: g2,
    listbox: fee,
    size: m5,
    textarea: q3,
    urlinput: Mz,
    customeditor: eee,
    collection: YJ,
    togglemenuitem: HJ
  }, e = (t) => B.from(_ae[t.type]), n = (t) => So(Y3(t), Tee), s = (t) => {
    const r = n(t), l = je(r, (d) => e(d).fold(() => [], (h) => [Ls(d.name, h)]));
    return xo(l);
  }, i = (t) => {
    var r;
    const l = Gt(kee(t)), d = s(t), h = (r = t.initialData) !== null && r !== void 0 ? r : {};
    return {
      internalDialog: l,
      dataValidator: d,
      initialData: h
    };
  }, u = {
    open: (t, r) => {
      const l = i(r);
      return t(l.internalDialog, l.initialData, l.dataValidator);
    },
    openUrl: (t, r) => {
      const l = Gt(Eee(r));
      return t(l);
    },
    redial: (t) => i(t)
  };
  var b = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, r) => {
      const l = (d, h) => {
        t.updateState.each((y) => {
          const w = y(d, h);
          r.set(w);
        }), t.renderComponents.each((y) => {
          const w = y(h, r.get());
          (t.reuseDom ? aR : Sx)(d, w);
        });
      };
      return zr([
        Ft(ju(), (d, h) => {
          const y = h;
          if (!y.universal) {
            const w = t.channel;
            pn(y.channels, w) && l(d, y.data);
          }
        }),
        qr((d, h) => {
          t.initialData.each((y) => {
            l(d, y);
          });
        })
      ]);
    }
  }), T = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getState: (t, r, l) => l
  }), M = [
    Mt("channel"),
    $s("renderComponents"),
    $s("updateState"),
    $s("initialData"),
    Ea("reuseDom", !0)
  ], W = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = to(B.none()), r = () => t.set(B.none());
      return {
        readState: () => t.get().getOr("none"),
        get: t.get,
        set: t.set,
        clear: r
      };
    }
  });
  const G = Xi({
    fields: M,
    name: "reflecting",
    active: b,
    apis: T,
    state: W
  }), ue = (t) => {
    const r = [], l = {};
    return it(t, (d, h) => {
      d.fold(() => {
        r.push(h);
      }, (y) => {
        l[h] = y;
      });
    }), r.length > 0 ? Ho.error(r) : Ho.value(l);
  }, we = (t, r, l, d) => {
    const h = rr(Kx.sketch((y) => ({
      dom: {
        tag: "div",
        classes: ["tox-form"].concat(t.classes)
      },
      components: et(t.items, (w) => k8(y, w, r, l, d))
    })));
    return {
      dom: {
        tag: "div",
        classes: ["tox-dialog__body"]
      },
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-dialog__body-content"]
        },
        components: [h.asSpec()]
      }],
      behaviours: Jt([
        so.config({
          mode: "acyclic",
          useTabstopAt: Ue(Yx)
        }),
        sd.memento(h),
        S$(h, {
          postprocess: (y) => ue(y).fold((w) => (console.error(w), {}), lt)
        }),
        jo("dialog-body-panel", [Ft(nf(), (y, w) => {
          y.getSystem().broadcastOn([WS], { newFocus: B.some(w.event.target) });
        })])
      ])
    };
  }, fe = (t, r) => ({
    uid: t.uid,
    dom: t.dom,
    components: t.components,
    events: aT(t.action),
    behaviours: Hi(t.tabButtonBehaviours, [
      To.config({}),
      so.config({
        mode: "execution",
        useSpace: !0,
        useEnter: !0
      }),
      In.config({
        store: {
          mode: "memory",
          initialValue: t.value
        }
      })
    ]),
    domModification: t.domModification
  }), ke = Nc({
    name: "TabButton",
    configFields: [
      Xe("uid", void 0),
      Mt("value"),
      Qa("dom", "dom", Op(() => ({
        attributes: {
          role: "tab",
          id: Mn("aria"),
          "aria-selected": "false"
        }
      })), pu()),
      $s("action"),
      Xe("domModification", {}),
      $i("tabButtonBehaviours", [
        To,
        so,
        In
      ]),
      Mt("view")
    ],
    factory: fe
  }), He = ee([
    Mt("tabs"),
    Mt("dom"),
    Xe("clickToDismiss", !1),
    $i("tabbarBehaviours", [
      yn,
      so
    ]),
    Xf([
      "tabClass",
      "selectedClass"
    ])
  ]), Ye = mx({
    factory: ke,
    name: "tabs",
    unit: "tab",
    overrides: (t) => {
      const r = (d, h) => {
        yn.dehighlight(d, h), po(d, a_(), {
          tabbar: d,
          button: h
        });
      }, l = (d, h) => {
        yn.highlight(d, h), po(d, r_(), {
          tabbar: d,
          button: h
        });
      };
      return {
        action: (d) => {
          const h = d.getSystem().getByUid(t.uid).getOrDie(), y = yn.isHighlighted(h, d);
          (y && t.clickToDismiss ? r : y ? U : l)(h, d);
        },
        domModification: { classes: [t.markers.tabClass] }
      };
    }
  }), We = ee([Ye]), ut = (t, r, l, d) => ({
    uid: t.uid,
    dom: t.dom,
    components: r,
    "debug.sketcher": "Tabbar",
    domModification: { attributes: { role: "tablist" } },
    behaviours: Hi(t.tabbarBehaviours, [
      yn.config({
        highlightClass: t.markers.selectedClass,
        itemClass: t.markers.tabClass,
        onHighlight: (h, y) => {
          sn(y.element, "aria-selected", "true");
        },
        onDehighlight: (h, y) => {
          sn(y.element, "aria-selected", "false");
        }
      }),
      so.config({
        mode: "flow",
        getInitial: (h) => yn.getHighlighted(h).map((y) => y.element),
        selector: "." + t.markers.tabClass,
        executeOnMove: !0
      })
    ])
  }), Ut = Wl({
    name: "Tabbar",
    configFields: He(),
    partFields: We(),
    factory: ut
  }), an = (t, r) => ({
    uid: t.uid,
    dom: t.dom,
    behaviours: Hi(t.tabviewBehaviours, [Po.config({})]),
    domModification: { attributes: { role: "tabpanel" } }
  }), Nn = Nc({
    name: "Tabview",
    configFields: [$i("tabviewBehaviours", [Po])],
    factory: an
  }), Et = ee([
    Xe("selectFirst", !0),
    Os("onChangeTab"),
    Os("onDismissTab"),
    Xe("tabs", []),
    $i("tabSectionBehaviours", [])
  ]), bt = hl({
    factory: Ut,
    schema: [
      Mt("dom"),
      tf("markers", [
        Mt("tabClass"),
        Mt("selectedClass")
      ])
    ],
    name: "tabbar",
    defaults: (t) => ({ tabs: t.tabs })
  }), Ht = hl({
    factory: Nn,
    name: "tabview"
  }), zn = ee([
    bt,
    Ht
  ]), uo = (t, r, l, d) => {
    const h = (w) => {
      const E = In.getValue(w);
      Qt(w, t, "tabview").each((O) => {
        Nt(t.tabs, (L) => L.value === E).each((L) => {
          const q = L.view();
          Y(w.element, "id").each((ne) => {
            sn(O.element, "aria-labelledby", ne);
          }), Po.set(O, q), t.onChangeTab(O, w, q);
        });
      });
    }, y = (w, E) => {
      Qt(w, t, "tabbar").each((O) => {
        E(O).each(Hp);
      });
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: r,
      behaviours: A1(t.tabSectionBehaviours),
      events: zr(tn([
        t.selectFirst ? [qr((w, E) => {
          y(w, yn.getFirst);
        })] : [],
        [
          Ft(r_(), (w, E) => {
            const O = E.event.button;
            h(O);
          }),
          Ft(a_(), (w, E) => {
            const O = E.event.button;
            t.onDismissTab(w, O);
          })
        ]
      ])),
      apis: {
        getViewItems: (w) => Qt(w, t, "tabview").map((E) => Po.contents(E)).getOr([]),
        showTab: (w, E) => {
          y(w, (F) => {
            const L = yn.getCandidates(F);
            return Nt(L, (ne) => In.getValue(ne) === E).filter((ne) => !yn.isHighlighted(F, ne));
          });
        }
      }
    };
  }, Go = Wl({
    name: "TabSection",
    configFields: Et(),
    partFields: zn(),
    factory: uo,
    apis: {
      getViewItems: (t, r) => t.getViewItems(r),
      showTab: (t, r, l) => {
        t.showTab(r, l);
      }
    }
  }), ys = (t, r, l) => et(t, (d, h) => {
    Po.set(l, t[h].view());
    const y = r.dom.getBoundingClientRect();
    return Po.set(l, []), y.height;
  }), Js = (t) => ao(oo(t, (r, l) => r > l ? -1 : r < l ? 1 : 0)), xr = (t, r, l) => {
    const d = Oi(t).dom, h = Vm(t, ".tox-dialog-wrap").getOr(t), y = lr(h, "position") === "fixed";
    let w;
    y ? w = Math.max(d.clientHeight, window.innerHeight) : w = Math.max(d.offsetHeight, d.scrollHeight);
    const E = Mr(r), F = r.dom.offsetLeft >= l.dom.offsetLeft + Ri(l) ? Math.max(Mr(l), E) : E, L = parseInt(lr(t, "margin-top"), 10) || 0, q = parseInt(lr(t, "margin-bottom"), 10) || 0, ae = Mr(t) + L + q - F;
    return w - ae;
  }, Da = (t, r) => {
    ao(t).each((l) => Go.showTab(r, l.value));
  }, yl = (t, r) => {
    Ln(t, "height", r + "px"), Ln(t, "flex-basis", r + "px");
  }, mr = (t, r, l) => {
    Vm(t, '[role="dialog"]').each((d) => {
      or(d, '[role="tablist"]').each((h) => {
        l.get().map((y) => (Ln(r, "height", "0"), Ln(r, "flex-basis", "0"), Math.min(y, xr(d, r, h)))).each((y) => {
          yl(r, y);
        });
      });
    });
  }, mn = (t) => or(t, '[role="tabpanel"]'), ro = (t) => {
    const r = cr();
    return {
      extraEvents: [
        qr((h) => {
          const y = h.element;
          mn(y).each((w) => {
            Ln(w, "visibility", "hidden"), h.getSystem().getByDom(w).toOptional().each((E) => {
              const O = ys(t, w, E);
              Js(O).fold(r.clear, r.set);
            }), mr(y, w, r), gs(w, "visibility"), Da(t, h), requestAnimationFrame(() => {
              mr(y, w, r);
            });
          });
        }),
        Ft(af(), (h) => {
          const y = h.element;
          mn(y).each((w) => {
            mr(y, w, r);
          });
        }),
        Ft(R6, (h, y) => {
          const w = h.element;
          mn(w).each((E) => {
            const O = hf(ie(E));
            Ln(E, "visibility", "hidden");
            const F = Cr(E, "height").map((ne) => parseInt(ne, 10));
            gs(E, "height"), gs(E, "flex-basis");
            const L = E.dom.getBoundingClientRect().height;
            F.forall((ne) => L > ne) ? (r.set(L), mr(w, E, r)) : F.each((ne) => {
              yl(E, ne);
            }), gs(E, "visibility"), O.each(vu);
          });
        })
      ],
      selectFirst: !1
    };
  }, Hs = "send-data-to-section", Sn = "send-data-to-view", bo = (t, r, l, d) => {
    const h = to({}), y = (L) => {
      const q = In.getValue(L), ne = ue(q).getOr({}), ae = h.get(), de = Pr(ae, ne);
      h.set(de);
    }, w = (L) => {
      const q = h.get();
      In.setValue(L, q);
    }, E = to(null), O = et(t.tabs, (L) => ({
      value: L.name,
      dom: {
        tag: "div",
        classes: ["tox-dialog__body-nav-item"]
      },
      components: [Aa(l.shared.providers.translate(L.title))],
      view: () => [Kx.sketch((q) => ({
        dom: {
          tag: "div",
          classes: ["tox-form"]
        },
        components: et(L.items, (ne) => k8(q, ne, r, l, d)),
        formBehaviours: Jt([
          so.config({
            mode: "acyclic",
            useTabstopAt: Ue(Yx)
          }),
          jo("TabView.form.events", [
            qr(w),
            qf(y)
          ]),
          Rc.config({
            channels: Us([
              {
                key: Hs,
                value: { onReceive: y }
              },
              {
                key: Sn,
                value: { onReceive: w }
              }
            ])
          })
        ])
      }))]
    })), F = ro(O);
    return Go.sketch({
      dom: {
        tag: "div",
        classes: ["tox-dialog__body"]
      },
      onChangeTab: (L, q, ne) => {
        const ae = In.getValue(q);
        po(L, D6, {
          name: ae,
          oldName: E.get()
        }), E.set(ae);
      },
      tabs: O,
      components: [
        Go.parts.tabbar({
          dom: {
            tag: "div",
            classes: ["tox-dialog__body-nav"]
          },
          components: [Ut.parts.tabs({})],
          markers: {
            tabClass: "tox-tab",
            selectedClass: "tox-dialog__body-nav-item--active"
          },
          tabbarBehaviours: Jt([jr.config({})])
        }),
        Go.parts.tabview({
          dom: {
            tag: "div",
            classes: ["tox-dialog__body-content"]
          }
        })
      ],
      selectFirst: F.selectFirst,
      tabSectionBehaviours: Jt([
        jo("tabpanel", F.extraEvents),
        so.config({ mode: "acyclic" }),
        Ds.config({ find: (L) => ao(Go.getViewItems(L)) }),
        p0(B.none(), (L) => (L.getSystem().broadcastOn([Hs], {}), h.get()), (L, q) => {
          h.set(q), L.getSystem().broadcastOn([Sn], {});
        })
      ])
    });
  }, cs = (t, r, l, d, h, y) => {
    const w = (F) => {
      const L = F.body;
      switch (L.type) {
        case "tabpanel":
          return [bo(L, F.initialData, d, y)];
        default:
          return [we(L, F.initialData, d, y)];
      }
    }, E = (F, L) => B.some({ isTabPanel: () => L.body.type === "tabpanel" }), O = { "aria-live": "polite" };
    return {
      dom: {
        tag: "div",
        classes: ["tox-dialog__content-js"],
        attributes: {
          ...l.map((F) => ({ id: F })).getOr({}),
          ...h ? O : {}
        }
      },
      components: [],
      behaviours: Jt([
        sd.childAt(0),
        G.config({
          channel: `${P$}-${r}`,
          updateState: E,
          renderComponents: w,
          initialData: t
        })
      ])
    };
  }, On = (t, r, l, d, h, y) => cs(t, r, B.some(l), d, h, y), us = (t, r, l, d) => {
    const h = cs(t, r, B.none(), l, !1, d);
    return zi.parts.body(h);
  }, ws = (t) => {
    const r = {
      dom: {
        tag: "div",
        classes: ["tox-dialog__content-js"]
      },
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-dialog__body-iframe"]
        },
        components: [D$(B.none(), {
          dom: {
            tag: "iframe",
            attributes: { src: t.url }
          },
          behaviours: Jt([
            jr.config({}),
            To.config({})
          ])
        })]
      }],
      behaviours: Jt([so.config({
        mode: "acyclic",
        useTabstopAt: Ue(Yx)
      })])
    };
    return zi.parts.body(r);
  }, Vi = _x.deviceType.isTouch(), ar = (t, r) => ({
    dom: {
      tag: "div",
      styles: { display: "none" },
      classes: ["tox-dialog__header"]
    },
    components: [
      t,
      r
    ]
  }), hi = (t, r) => zi.parts.close(Nl.sketch({
    dom: {
      tag: "button",
      classes: [
        "tox-button",
        "tox-button--icon",
        "tox-button--naked"
      ],
      attributes: {
        type: "button",
        "aria-label": r.translate("Close")
      }
    },
    action: t,
    buttonBehaviours: Jt([jr.config({})])
  })), Bd = () => zi.parts.title({
    dom: {
      tag: "div",
      classes: ["tox-dialog__title"],
      innerHtml: "",
      styles: { display: "none" }
    }
  }), vm = (t, r) => zi.parts.body({
    dom: {
      tag: "div",
      classes: ["tox-dialog__body"]
    },
    components: [{
      dom: {
        tag: "div",
        classes: ["tox-dialog__body-content"]
      },
      components: [{ dom: Qm(`<p>${UR(r.translate(t))}</p>`) }]
    }]
  }), gc = (t) => zi.parts.footer({
    dom: {
      tag: "div",
      classes: ["tox-dialog__footer"]
    },
    components: t
  }), Au = (t, r) => [
    op.sketch({
      dom: {
        tag: "div",
        classes: ["tox-dialog__footer-start"]
      },
      components: t
    }),
    op.sketch({
      dom: {
        tag: "div",
        classes: ["tox-dialog__footer-end"]
      },
      components: r
    })
  ], rd = (t) => {
    const r = "tox-dialog", l = r + "-wrap", d = l + "__backdrop", h = r + "__disable-scroll";
    return zi.sketch({
      lazySink: t.lazySink,
      onEscape: (y) => (t.onEscape(y), B.some(!0)),
      useTabstopAt: (y) => !Yx(y),
      firstTabstop: t.firstTabstop,
      dom: {
        tag: "div",
        classes: [r].concat(t.extraClasses),
        styles: {
          position: "relative",
          ...t.extraStyles
        }
      },
      components: [
        t.header,
        t.body,
        ...t.footer.toArray()
      ],
      parts: {
        blocker: {
          dom: Qm(`<div class="${l}"></div>`),
          components: [{
            dom: {
              tag: "div",
              classes: Vi ? [
                d,
                d + "--opaque"
              ] : [d]
            }
          }]
        }
      },
      dragBlockClass: l,
      modalBehaviours: Jt([
        To.config({}),
        jo("dialog-events", t.dialogEvents.concat([
          _v(nf(), (y, w) => {
            lp.isBlocked(y) ? U() : so.focusIn(y);
          }),
          Ft(og(), (y, w) => {
            y.getSystem().broadcastOn([WS], { newFocus: w.event.newFocus });
          })
        ])),
        jo("scroll-lock", [
          qr(() => {
            Vr(Uo(), h);
          }),
          qf(() => {
            ba(Uo(), h);
          })
        ]),
        ...t.extraBehaviours
      ]),
      eventOrder: {
        [Wu()]: ["dialog-events"],
        [rc()]: [
          "scroll-lock",
          "dialog-events",
          "alloy.base.behaviour"
        ],
        [Zu()]: [
          "alloy.base.behaviour",
          "dialog-events",
          "scroll-lock"
        ],
        ...t.eventOrder
      }
    });
  }, Ou = (t) => Nl.sketch({
    dom: {
      tag: "button",
      classes: [
        "tox-button",
        "tox-button--icon",
        "tox-button--naked"
      ],
      attributes: {
        type: "button",
        "aria-label": t.translate("Close"),
        "data-mce-name": "close"
      }
    },
    buttonBehaviours: Jt([
      jr.config({}),
      gl.config(t.tooltips.getConfig({ tooltipText: t.translate("Close") }))
    ]),
    components: [ku("close", {
      tag: "span",
      classes: ["tox-icon"]
    }, t.icons)],
    action: (r) => {
      Xo(r, yb);
    }
  }), Ld = (t, r, l, d) => {
    const h = (y) => [Aa(d.translate(y.title))];
    return {
      dom: {
        tag: "h1",
        classes: ["tox-dialog__title"],
        attributes: { ...l.map((y) => ({ id: y })).getOr({}) }
      },
      components: [],
      behaviours: Jt([G.config({
        channel: `${N$}-${r}`,
        initialData: t,
        renderComponents: h
      })])
    };
  }, fo = () => ({ dom: Qm('<div class="tox-dialog__draghandle"></div>') }), Ps = (t, r, l, d) => op.sketch({
    dom: Qm('<div class="tox-dialog__header"></div>'),
    components: [
      Ld(t, r, B.some(l), d),
      fo(),
      Ou(d)
    ],
    containerBehaviours: Jt([w0.config({
      mode: "mouse",
      blockerClass: "blocker",
      getTarget: (h) => pf(h, '[role="dialog"]').getOrDie(),
      snaps: {
        getSnapPoints: () => [],
        leftAttr: "data-drag-left",
        topAttr: "data-drag-top"
      }
    })])
  }), ya = (t, r, l) => {
    const d = zi.parts.title(Ld(t, r, B.none(), l)), h = zi.parts.draghandle(fo()), y = zi.parts.close(Ou(l)), w = [d].concat(t.draggable ? [h] : []).concat([y]);
    return op.sketch({
      dom: Qm('<div class="tox-dialog__header"></div>'),
      components: w
    });
  }, Ra = (t, r, l) => ya({
    title: l.shared.providers.translate(t),
    draggable: l.dialog.isDraggableModal()
  }, r, l.shared.providers), si = (t, r, l, d) => ({
    dom: {
      tag: "div",
      classes: ["tox-dialog__busy-spinner"],
      attributes: { "aria-label": l.translate(t) },
      styles: {
        left: "0px",
        right: "0px",
        bottom: "0px",
        top: `${d.getOr(0)}px`,
        position: "absolute"
      }
    },
    behaviours: r,
    components: [{ dom: Qm('<div class="tox-spinner"><div></div><div></div><div></div></div>') }]
  }), sl = (t, r, l) => ({
    onClose: () => l.closeWindow(),
    onBlock: (d) => {
      const h = or(t().element, ".tox-dialog__header").map((y) => Mr(y));
      zi.setBusy(t(), (y, w) => si(d.message, w, r, h));
    },
    onUnblock: () => {
      zi.setIdle(t());
    }
  }), ja = "tox-dialog--fullscreen", Fa = "tox-dialog--width-lg", Gl = "tox-dialog--width-md", ad = (t) => {
    switch (t) {
      case "large":
        return B.some(Fa);
      case "medium":
        return B.some(Gl);
      default:
        return B.none();
    }
  }, Tf = (t, r) => {
    const l = $e.fromDom(r.element.dom);
    Kc(l, ja) || (Yc(l, [
      Fa,
      Gl
    ]), ad(t).each((d) => Vr(l, d)));
  }, Af = (t, r) => {
    const l = $e.fromDom(t.element.dom), d = mO(l), h = Nt(d, (y) => y === Fa || y === Gl).or(ad(r));
    uO(l, [
      ja,
      ...h.toArray()
    ]);
  }, $d = (t, r, l) => Ol(rd({
    ...t,
    firstTabstop: 1,
    lazySink: l.shared.getSink,
    extraBehaviours: [
      DA({}),
      ...t.extraBehaviours
    ],
    onEscape: (d) => {
      Xo(d, yb);
    },
    dialogEvents: r,
    eventOrder: {
      [ju()]: [
        G.name(),
        Rc.name()
      ],
      [rc()]: [
        "scroll-lock",
        G.name(),
        "messages",
        "dialog-events",
        "alloy.base.behaviour"
      ],
      [Zu()]: [
        "alloy.base.behaviour",
        "dialog-events",
        "messages",
        G.name(),
        "scroll-lock"
      ]
    }
  })), Eh = (t, r = {}) => {
    const l = (d) => {
      const h = et(d.items, (y) => {
        const w = qt(r, y.name).getOr(to(!1));
        return {
          ...y,
          storage: w
        };
      });
      return {
        ...d,
        items: h
      };
    };
    return et(t, (d) => d.type === "menu" ? l(d) : d);
  }, _0 = (t) => Pt(t, (r, l) => l.type === "menu" ? Pt(l.items, (h, y) => (h[y.name] = y.storage, h), r) : r, {}), E0 = (t, r) => [
    rw(nf(), rq),
    t(NS, (l, d, h, y) => {
      hf(ie(y.element)).fold(U, h1), r.onClose(), d.onClose();
    }),
    t(yb, (l, d, h, y) => {
      d.onCancel(l), Xo(y, NS);
    }),
    Ft(GN, (l, d) => r.onUnblock()),
    Ft(hA, (l, d) => r.onBlock(d.event))
  ], v5 = (t, r) => {
    const l = (h, y) => Ft(h, (w, E) => {
      d(w, (O, F) => {
        y(t(), O, E.event, w);
      });
    }), d = (h, y) => {
      G.getState(h).get().each((w) => {
        y(w, h);
      });
    };
    return [
      ...E0(l, r),
      l(yh, (h, y, w) => {
        y.onAction(h, { name: w.name });
      })
    ];
  }, Th = (t, r, l) => {
    const d = (y, w) => Ft(y, (E, O) => {
      h(E, (F, L) => {
        w(t(), F, O.event, E);
      });
    }), h = (y, w) => {
      G.getState(y).get().each((E) => {
        w(E.internalDialog, y);
      });
    };
    return [
      ...E0(d, r),
      d(Ux, (y, w) => w.onSubmit(y)),
      d(_u, (y, w, E) => {
        w.onChange(y, { name: E.name });
      }),
      d(yh, (y, w, E, O) => {
        const F = () => O.getSystem().isConnected() ? so.focusIn(O) : void 0, L = (ae) => ge(ae, "disabled") || Y(ae, "aria-disabled").exists((de) => de === "true"), q = ie(O.element), ne = hf(q);
        w.onAction(y, {
          name: E.name,
          value: E.value
        }), hf(q).fold(F, (ae) => {
          L(ae) || ne.exists((de) => ka(ae, de) && L(de)) ? F() : l().toOptional().filter((de) => !ka(de.element, ae)).each(F);
        });
      }),
      d(D6, (y, w, E) => {
        w.onTabChange(y, {
          newTabName: E.name,
          oldTabName: E.oldName
        });
      }),
      qf((y) => {
        const w = t();
        In.setValue(y, w.getData());
      })
    ];
  }, X3 = (t, r) => g0(t, t.type, r), Fz = (t, r, l) => Nt(r, (d) => d.name === l).bind((d) => d.memento.getOpt(t)), vc = (t, r) => {
    const l = r.map((E) => E.footerButtons).getOr([]), d = ds(l, (E) => E.align === "start"), h = (E, O) => op.sketch({
      dom: {
        tag: "div",
        classes: [`tox-dialog__footer-${E}`]
      },
      components: et(O, (F) => F.memento.asSpec())
    }), y = h("start", d.pass), w = h("end", d.fail);
    return [
      y,
      w
    ];
  }, Ob = (t, r, l) => {
    const d = (h, y) => {
      const w = et(y.buttons, (O) => {
        const F = rr(X3(O, l));
        return {
          name: O.name,
          align: O.align,
          memento: F
        };
      }), E = (O) => Fz(h, w, O);
      return B.some({
        lookupByName: E,
        footerButtons: w
      });
    };
    return {
      dom: Qm('<div class="tox-dialog__footer"></div>'),
      components: [],
      behaviours: Jt([G.config({
        channel: `${M$}-${r}`,
        initialData: t,
        updateState: d,
        renderComponents: vc
      })])
    };
  }, Bz = (t, r, l) => Ob(t, r, l), Q3 = (t, r, l) => zi.parts.footer(Ob(t, r, l)), Of = (t, r) => {
    if (t.getRoot().getSystem().isConnected()) {
      const d = Ds.getCurrent(t.getFormWrapper()).getOr(t.getFormWrapper());
      return Kx.getField(d, r).orThunk(() => t.getFooter().bind((w) => G.getState(w).get()).bind((w) => w.lookupByName(r)));
    } else
      return B.none();
  }, kk = (t, r) => {
    const l = t.getRoot();
    return G.getState(l).get().map((d) => Gt(ra("data", d.dataValidator, r))).getOr(r);
  }, mt = (t, r, l) => {
    const d = (de) => {
      const _e = t.getRoot();
      _e.getSystem().isConnected() && de(_e);
    }, ae = {
      getData: () => {
        const de = t.getRoot(), _e = de.getSystem().isConnected() ? t.getFormWrapper() : de, st = In.getValue(_e), Re = kt(l, (Qe) => Qe.get());
        return {
          ...st,
          ...Re
        };
      },
      setData: (de) => {
        d((_e) => {
          const st = ae.getData(), Re = Pr(st, de), Qe = kk(t, Re), qe = t.getFormWrapper();
          In.setValue(qe, Qe), it(l, (Bt, pt) => {
            Ko(Re, pt) && Bt.set(Re[pt]);
          });
        });
      },
      setEnabled: (de, _e) => {
        Of(t, de).each(_e ? _o.enable : _o.disable);
      },
      focus: (de) => {
        Of(t, de).each(To.focus);
      },
      block: (de) => {
        if (!A(de))
          throw new Error("The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
        d((_e) => {
          po(_e, hA, { message: de });
        });
      },
      unblock: () => {
        d((de) => {
          Xo(de, GN);
        });
      },
      showTab: (de) => {
        d((_e) => {
          const st = t.getBody();
          G.getState(st).get().exists((Qe) => Qe.isTabPanel()) && Ds.getCurrent(st).each((Qe) => {
            Go.showTab(Qe, de);
          });
        });
      },
      redial: (de) => {
        d((_e) => {
          const st = t.getId(), Re = r(de), Qe = Eh(Re.internalDialog.buttons, l);
          _e.getSystem().broadcastOn([`${jS}-${st}`], Re), _e.getSystem().broadcastOn([`${N$}-${st}`], Re.internalDialog), _e.getSystem().broadcastOn([`${P$}-${st}`], Re.internalDialog), _e.getSystem().broadcastOn([`${M$}-${st}`], {
            ...Re.internalDialog,
            buttons: Qe
          }), ae.setData(Re.initialData);
        });
      },
      close: () => {
        d((de) => {
          Xo(de, NS);
        });
      },
      toggleFullscreen: t.toggleFullscreen
    };
    return ae;
  }, yt = (t, r, l) => {
    const d = Mn("dialog"), h = t.internalDialog, y = Ra(h.title, d, l), w = to(h.size), E = (qe) => Of(Re, qe), O = ad(w.get()).toArray(), F = (qe, Bt) => (w.set(Bt.internalDialog.size), Tf(Bt.internalDialog.size, qe), B.some(Bt)), L = us({
      body: h.body,
      initialData: h.initialData
    }, d, l, E), q = Eh(h.buttons), ne = _0(q), ae = Xn(q.length !== 0, Q3({ buttons: q }, d, l)), de = Th(() => Qe, sl(() => st, l.shared.providers, r), l.shared.getSink), _e = {
      id: d,
      header: y,
      body: L,
      footer: ae,
      extraClasses: O,
      extraBehaviours: [G.config({
        channel: `${jS}-${d}`,
        updateState: F,
        initialData: t
      })],
      extraStyles: {}
    }, st = $d(_e, de, l), Re = (() => {
      const qe = () => {
        const pt = zi.getBody(st);
        return Ds.getCurrent(pt).getOr(pt);
      }, Bt = () => {
        Af(st, w.get());
      };
      return {
        getId: ee(d),
        getRoot: ee(st),
        getBody: () => zi.getBody(st),
        getFooter: () => zi.getFooter(st),
        getFormWrapper: qe,
        toggleFullscreen: Bt
      };
    })(), Qe = mt(Re, r.redial, ne);
    return {
      dialog: st,
      instanceApi: Qe
    };
  }, dn = (t, r, l, d = !1, h) => {
    const y = Mn("dialog"), w = Mn("dialog-label"), E = Mn("dialog-content"), O = t.internalDialog, F = (Yn) => Of(bn, Yn), L = to(O.size), q = ad(L.get()).toArray(), ne = (Yn, Fn) => (L.set(Fn.internalDialog.size), Tf(Fn.internalDialog.size, Yn), h(), B.some(Fn)), ae = rr(Ps({
      title: O.title,
      draggable: !0
    }, y, w, l.shared.providers)), de = rr(On({
      body: O.body,
      initialData: O.initialData
    }, y, E, l, d, F)), _e = Eh(O.buttons), st = _0(_e), Re = Xn(_e.length !== 0, rr(Bz({ buttons: _e }, y, l))), Qe = Th(() => It, {
      onBlock: (Yn) => {
        lp.block(pt, (Fn, yo) => {
          const mo = ae.getOpt(pt).map((js) => Mr(js.element));
          return si(Yn.message, yo, l.shared.providers, mo);
        });
      },
      onUnblock: () => {
        lp.unblock(pt);
      },
      onClose: () => r.closeWindow()
    }, l.shared.getSink), qe = "tox-dialog-inline", Bt = $l().os, pt = Ol({
      dom: {
        tag: "div",
        classes: [
          "tox-dialog",
          qe,
          ...q
        ],
        attributes: {
          role: "dialog",
          ...Bt.isMacOS() ? { "aria-label": O.title } : { "aria-labelledby": w }
        }
      },
      eventOrder: {
        [ju()]: [
          G.name(),
          Rc.name()
        ],
        [Wu()]: ["execute-on-form"],
        [rc()]: [
          "reflecting",
          "execute-on-form"
        ]
      },
      behaviours: Jt([
        so.config({
          mode: "cyclic",
          onEscape: (Yn) => (Xo(Yn, NS), B.some(!0)),
          useTabstopAt: (Yn) => !Yx(Yn) && (Gs(Yn) !== "button" || tr(Yn, "disabled") !== "disabled"),
          firstTabstop: 1
        }),
        G.config({
          channel: `${jS}-${y}`,
          updateState: ne,
          initialData: t
        }),
        To.config({}),
        jo("execute-on-form", Qe.concat([
          _v(nf(), (Yn, Fn) => {
            so.focusIn(Yn);
          }),
          Ft(og(), (Yn, Fn) => {
            Yn.getSystem().broadcastOn([WS], { newFocus: Fn.event.newFocus });
          })
        ])),
        lp.config({ getRoot: () => B.some(pt) }),
        Po.config({}),
        DA({})
      ]),
      components: [
        ae.asSpec(),
        de.asSpec(),
        ...Re.map((Yn) => Yn.asSpec()).toArray()
      ]
    }), en = () => {
      Af(pt, L.get());
    }, bn = {
      getId: ee(y),
      getRoot: ee(pt),
      getFooter: () => Re.map((Yn) => Yn.get(pt)),
      getBody: () => de.get(pt),
      getFormWrapper: () => {
        const Yn = de.get(pt);
        return Ds.getCurrent(Yn).getOr(Yn);
      },
      toggleFullscreen: en
    }, It = mt(bn, r.redial, st);
    return {
      dialog: pt,
      instanceApi: It
    };
  };
  var nn = tinymce.util.Tools.resolve("tinymce.util.URI");
  const Eo = (t) => {
    const r = (w) => {
      t.getSystem().isConnected() && w(t);
    };
    return {
      block: (w) => {
        if (!A(w))
          throw new Error("The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
        r((E) => {
          po(E, hA, { message: w });
        });
      },
      unblock: () => {
        r((w) => {
          Xo(w, GN);
        });
      },
      close: () => {
        r((w) => {
          Xo(w, NS);
        });
      },
      sendMessage: (w) => {
        r((E) => {
          E.getSystem().broadcastOn([I$], w);
        });
      }
    };
  }, Es = [
    "insertContent",
    "setContent",
    "execCommand",
    "close",
    "block",
    "unblock"
  ], pa = (t) => N(t) && Es.indexOf(t.mceAction) !== -1, bm = (t) => !pa(t) && N(t) && Ko(t, "mceAction"), J3 = (t, r, l) => {
    switch (l.mceAction) {
      case "insertContent":
        t.insertContent(l.content);
        break;
      case "setContent":
        t.setContent(l.content);
        break;
      case "execCommand":
        const d = J(l.ui) ? l.ui : !1;
        t.execCommand(l.cmd, d, l.value);
        break;
      case "close":
        r.close();
        break;
      case "block":
        r.block(l.message);
        break;
      case "unblock":
        r.unblock();
        break;
    }
  }, Aee = (t, r, l, d) => {
    const h = Mn("dialog"), y = Ra(t.title, h, d), w = ws(t), E = t.buttons.bind((qe) => qe.length === 0 ? B.none() : B.some(Q3({ buttons: qe }, h, d))), O = v5(() => Qe, sl(() => Re, d.shared.providers, r)), F = {
      ...t.height.fold(() => ({}), (qe) => ({
        height: qe + "px",
        "max-height": qe + "px"
      })),
      ...t.width.fold(() => ({}), (qe) => ({
        width: qe + "px",
        "max-width": qe + "px"
      }))
    }, L = t.width.isNone() && t.height.isNone() ? ["tox-dialog--width-lg"] : [], q = new nn(t.url, { base_uri: new nn(window.location.href) }), ne = `${q.protocol}://${q.host}${q.port ? ":" + q.port : ""}`, ae = za(), de = (qe, Bt) => B.some(Bt), _e = [
      G.config({
        channel: `${jS}-${h}`,
        updateState: de,
        initialData: t
      }),
      jo("messages", [
        qr(() => {
          const qe = uc($e.fromDom(window), "message", (Bt) => {
            if (q.isSameOrigin(new nn(Bt.raw.origin))) {
              const pt = Bt.raw.data;
              pa(pt) ? J3(l, Qe, pt) : bm(pt) && t.onMessage(Qe, pt);
            }
          });
          ae.set(qe);
        }),
        qf(ae.clear)
      ]),
      Rc.config({
        channels: {
          [I$]: {
            onReceive: (qe, Bt) => {
              or(qe.element, "iframe").each((pt) => {
                const en = pt.dom.contentWindow;
                be(en) && en.postMessage(Bt, ne);
              });
            }
          }
        }
      })
    ], Re = $d({
      id: h,
      header: y,
      body: w,
      footer: E,
      extraClasses: L,
      extraBehaviours: _e,
      extraStyles: F
    }, O, d), Qe = Eo(Re);
    return {
      dialog: Re,
      instanceApi: Qe
    };
  }, e4 = (t) => {
    const r = t.shared;
    return { open: (d, h) => {
      const y = () => {
        zi.hide(F), h();
      }, w = rr(g0({
        name: "close-alert",
        text: "OK",
        primary: !0,
        buttonType: B.some("primary"),
        align: "end",
        enabled: !0,
        icon: B.none()
      }, "cancel", t)), E = Bd(), O = hi(y, r.providers), F = Ol(rd({
        lazySink: () => r.getSink(),
        header: ar(E, O),
        body: vm(d, r.providers),
        footer: B.some(gc(Au([], [w.asSpec()]))),
        onEscape: y,
        extraClasses: ["tox-alert-dialog"],
        extraBehaviours: [],
        extraStyles: {},
        dialogEvents: [Ft(yb, y)],
        eventOrder: {}
      }));
      zi.show(F);
      const L = w.get(F);
      To.focus(L);
    } };
  }, Xg = (t) => {
    const r = t.shared;
    return { open: (d, h) => {
      const y = (ne) => {
        zi.hide(L), h(ne);
      }, w = rr(g0({
        name: "yes",
        text: "Yes",
        primary: !0,
        buttonType: B.some("primary"),
        align: "end",
        enabled: !0,
        icon: B.none()
      }, "submit", t)), E = g0({
        name: "no",
        text: "No",
        primary: !1,
        buttonType: B.some("secondary"),
        align: "end",
        enabled: !0,
        icon: B.none()
      }, "cancel", t), O = Bd(), F = hi(() => y(!1), r.providers), L = Ol(rd({
        lazySink: () => r.getSink(),
        header: ar(O, F),
        body: vm(d, r.providers),
        footer: B.some(gc(Au([], [
          E,
          w.asSpec()
        ]))),
        onEscape: () => y(!1),
        extraClasses: ["tox-confirm-dialog"],
        extraBehaviours: [],
        extraStyles: {},
        dialogEvents: [
          Ft(yb, () => y(!1)),
          Ft(Ux, () => y(!0))
        ],
        eventOrder: {}
      }));
      zi.show(L);
      const q = w.get(L);
      To.focus(q);
    } };
  }, b5 = (t, r) => Gt(ra("data", r, t)), y5 = (t) => DS(t, ".tox-alert-dialog") || DS(t, ".tox-confirm-dialog"), Lz = (t, r, l) => r && l ? [] : [ma.config({
    contextual: {
      lazyContext: () => B.some(sa($e.fromDom(t.getContentAreaContainer()))),
      fadeInClass: "tox-dialog-dock-fadein",
      fadeOutClass: "tox-dialog-dock-fadeout",
      transitionClass: "tox-dialog-dock-transition"
    },
    modes: ["top"],
    lazyViewport: (d) => $g(t, d.element).map((y) => ({
      bounds: q1(y),
      optScrollEnv: B.some({
        currentScrollTop: y.element.dom.scrollTop,
        scrollElmTop: Ga(y.element).top
      })
    })).getOrThunk(() => ({
      bounds: Na(),
      optScrollEnv: B.none()
    }))
  })], $z = (t) => {
    const r = t.editor, l = Ox(r), d = e4(t.backstages.dialog), h = Xg(t.backstages.dialog), y = (de, _e, st) => {
      if (!pe(_e)) {
        if (_e.inline === "toolbar")
          return F(de, t.backstages.popup.shared.anchors.inlineDialog(), st, _e);
        if (_e.inline === "bottom")
          return L(de, t.backstages.popup.shared.anchors.inlineBottomDialog(), st, _e);
        if (_e.inline === "cursor")
          return F(de, t.backstages.popup.shared.anchors.cursor(), st, _e);
      }
      return O(de, st);
    }, w = (de, _e) => E(de, _e), E = (de, _e) => {
      const st = (Re) => {
        const Qe = Aee(Re, {
          closeWindow: () => {
            zi.hide(Qe.dialog), _e(Qe.instanceApi);
          }
        }, r, t.backstages.dialog);
        return zi.show(Qe.dialog), Qe.instanceApi;
      };
      return u.openUrl(st, de);
    }, O = (de, _e) => {
      const st = (Re, Qe, qe) => {
        const Bt = Qe, en = yt({
          dataValidator: qe,
          initialData: Bt,
          internalDialog: Re
        }, {
          redial: u.redial,
          closeWindow: () => {
            zi.hide(en.dialog), _e(en.instanceApi);
          }
        }, t.backstages.dialog);
        return zi.show(en.dialog), en.instanceApi.setData(Bt), en.instanceApi;
      };
      return u.open(st, de);
    }, F = (de, _e, st, Re) => {
      const Qe = (qe, Bt, pt) => {
        const en = b5(Bt, pt), bn = cr(), It = t.backstages.popup.shared.header.isPositionedAtTop(), Yn = {
          dataValidator: pt,
          initialData: en,
          internalDialog: qe
        }, Fn = () => bn.on((Fs) => {
          aa.reposition(Fs), (!l || !It) && ma.refresh(Fs);
        }), yo = dn(Yn, {
          redial: u.redial,
          closeWindow: () => {
            bn.on(aa.hide), r.off("ResizeEditor", Fn), bn.clear(), st(yo.instanceApi);
          }
        }, t.backstages.popup, Re.ariaAttrs, Fn), mo = Ol(aa.sketch({
          lazySink: t.backstages.popup.shared.getSink,
          dom: {
            tag: "div",
            classes: []
          },
          fireDismissalEventInstead: Re.persistent ? { event: "doNotDismissYet" } : {},
          ...It ? {} : { fireRepositionEventInstead: {} },
          inlineBehaviours: Jt([
            jo("window-manager-inline-events", [Ft(Lp(), (Fs, ms) => {
              Xo(yo.dialog, yb);
            })]),
            ...Lz(r, l, It)
          ]),
          isExtraPart: (Fs, ms) => y5(ms)
        }));
        bn.set(mo);
        const js = () => {
          const Fs = r.inline ? Uo() : $e.fromDom(r.getContainer()), ms = sa(Fs);
          return B.some(ms);
        };
        return aa.showWithinBounds(mo, Vl(yo.dialog), { anchor: _e }, js), (!l || !It) && (ma.refresh(mo), r.on("ResizeEditor", Fn)), yo.instanceApi.setData(en), so.focusIn(yo.dialog), yo.instanceApi;
      };
      return u.open(Qe, de);
    }, L = (de, _e, st, Re) => {
      const Qe = (qe, Bt, pt) => {
        const en = b5(Bt, pt), bn = cr(), It = t.backstages.popup.shared.header.isPositionedAtTop(), Yn = {
          dataValidator: pt,
          initialData: en,
          internalDialog: qe
        }, Fn = () => bn.on((Fs) => {
          aa.reposition(Fs), ma.refresh(Fs);
        }), yo = dn(Yn, {
          redial: u.redial,
          closeWindow: () => {
            bn.on(aa.hide), r.off("ResizeEditor ScrollWindow ElementScroll", Fn), bn.clear(), st(yo.instanceApi);
          }
        }, t.backstages.popup, Re.ariaAttrs, Fn), mo = Ol(aa.sketch({
          lazySink: t.backstages.popup.shared.getSink,
          dom: {
            tag: "div",
            classes: []
          },
          fireDismissalEventInstead: Re.persistent ? { event: "doNotDismissYet" } : {},
          ...It ? {} : { fireRepositionEventInstead: {} },
          inlineBehaviours: Jt([
            jo("window-manager-inline-events", [Ft(Lp(), (Fs, ms) => {
              Xo(yo.dialog, yb);
            })]),
            ma.config({
              contextual: {
                lazyContext: () => B.some(sa($e.fromDom(r.getContentAreaContainer()))),
                fadeInClass: "tox-dialog-dock-fadein",
                fadeOutClass: "tox-dialog-dock-fadeout",
                transitionClass: "tox-dialog-dock-transition"
              },
              modes: [
                "top",
                "bottom"
              ],
              lazyViewport: (Fs) => $g(r, Fs.element).map((cn) => ({
                bounds: q1(cn),
                optScrollEnv: B.some({
                  currentScrollTop: cn.element.dom.scrollTop,
                  scrollElmTop: Ga(cn.element).top
                })
              })).getOrThunk(() => ({
                bounds: Na(),
                optScrollEnv: B.none()
              }))
            })
          ]),
          isExtraPart: (Fs, ms) => y5(ms)
        }));
        bn.set(mo);
        const js = () => t.backstages.popup.shared.getSink().toOptional().bind((Fs) => {
          const ms = $g(r, Fs.element), cn = 15, Un = ms.map((ho) => q1(ho)).getOr(Na()), Vo = sa($e.fromDom(r.getContentAreaContainer())), Co = qh(Vo, Un);
          return B.some(Nr(Co.x, Co.y, Co.width, Co.height - cn));
        });
        return aa.showWithinBounds(mo, Vl(yo.dialog), { anchor: _e }, js), ma.refresh(mo), r.on("ResizeEditor ScrollWindow ElementScroll ResizeWindow", Fn), yo.instanceApi.setData(en), so.focusIn(yo.dialog), yo.instanceApi;
      };
      return u.open(Qe, de);
    };
    return {
      open: y,
      openUrl: w,
      alert: (de, _e) => {
        d.open(de, _e);
      },
      close: (de) => {
        de.close();
      },
      confirm: (de, _e) => {
        h.open(de, _e);
      }
    };
  }, Oee = (t) => {
    mB(t), qW(t), IQ(t);
  };
  var Cs = () => {
    Jd.add("silver", (t) => {
      Oee(t);
      let r = () => Na();
      const {
        dialogs: l,
        popups: d,
        renderUI: h
      } = MJ(t, { getPopupSinkBounds: () => r() }), y = () => {
        const F = h();
        return $g(t, d.getMothership().element).each((q) => {
          r = () => q1(q);
        }), F;
      };
      zZ.register(t, d.backstage.shared);
      const w = $z({
        editor: t,
        backstages: {
          popup: d.backstage,
          dialog: l.backstage
        }
      }), E = cr(), O = () => Yj(t, { backstage: d.backstage }, d.getMothership(), E);
      return {
        renderUI: y,
        getWindowManagerImpl: ee(w),
        getNotificationManagerImpl: O
      };
    });
  };
  Cs();
})();
tinymce.IconManager.add("default", {
  icons: {
    "accessibility-check": '<svg width="24" height="24"><path d="M12 2a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2c0-1.1.9-2 2-2Zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5c0-.6-.4-1-1-1a1 1 0 0 0-1 1v5c0 .6-.4 1-1 1a1 1 0 0 1-1-1V9H4a1 1 0 1 1 0-2h16c.6 0 1 .4 1 1s-.4 1-1 1Z" fill-rule="nonzero"/></svg>',
    "accordion-toggle": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 15c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1h-6a1 1 0 0 1-1-1Z"/><path opacity=".2" fill-rule="evenodd" clip-rule="evenodd" d="M4 15c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1-1-1Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12 19c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1h-6a1 1 0 0 1-1-1Z"/><path opacity=".2" fill-rule="evenodd" clip-rule="evenodd" d="M4 19c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1-1-1Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3 7.3a1 1 0 0 1 1.4 0L16 9.6l2.3-2.3a1 1 0 1 1 1.4 1.4L16 12.4l-3.7-3.7a1 1 0 0 1 0-1.4ZM4.3 11.7a1 1 0 0 1 0-1.4L6.6 8 4.3 5.7a1 1 0 0 1 1.4-1.4L9.4 8l-3.7 3.7a1 1 0 0 1-1.4 0Z"/></svg>',
    accordion: '<svg width="24" height="24"><rect x="12" y="7" width="10" height="2" rx="1"/><rect x="12" y="11" width="10" height="2" rx="1"/><rect x="12" y="15" width="6" height="2" rx="1"/><path fill-rule="evenodd" clip-rule="evenodd" d="M2.3 7.3a1 1 0 0 1 1.4 0L6 9.6l2.3-2.3a1 1 0 0 1 1.4 1.4L6 12.4 2.3 8.7a1 1 0 0 1 0-1.4Z"/></svg>',
    "action-next": '<svg width="24" height="24"><path fill-rule="nonzero" d="M5.7 7.3a1 1 0 0 0-1.4 1.4l7.7 7.7 7.7-7.7a1 1 0 1 0-1.4-1.4L12 13.6 5.7 7.3Z"/></svg>',
    "action-prev": '<svg width="24" height="24"><path fill-rule="nonzero" d="M18.3 15.7a1 1 0 0 0 1.4-1.4L12 6.6l-7.7 7.7a1 1 0 0 0 1.4 1.4L12 9.4l6.3 6.3Z"/></svg>',
    addtag: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 5a2 2 0 0 1 1.6.8L21 12l-4.4 6.2a2 2 0 0 1-1.6.8h-3v-2h3l3.5-5L15 7H5v3H3V7c0-1.1.9-2 2-2h10Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6 12a1 1 0 0 0-1 1v2H3a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2H7v-2c0-.6-.4-1-1-1Z"/></svg>',
    "ai-prompt": '<svg width="24" height="24"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 6.7a1 1 0 0 0-1.4 0l-9.9 10a1 1 0 0 0 0 1.3l2.1 2.1c.4.4 1 .4 1.4 0l10-9.9c.3-.3.3-1 0-1.4l-2.2-2Zm1.4 2.8-2-2-3 2.7 2.2 2.2 2.8-2.9Z"/><path d="m18.5 7.3-.7-1.5-1.5-.8 1.5-.7.7-1.5.7 1.5 1.5.7-1.5.8-.7 1.5ZM18.5 16.5l-.7-1.6-1.5-.7 1.5-.7.7-1.6.7 1.6 1.5.7-1.5.7-.7 1.6ZM9.7 7.3 9 5.8 7.5 5 9 4.3l.7-1.5.7 1.5L12 5l-1.5.8-.7 1.5Z"/></g><defs><clipPath id="a"><path d="M0 0h24v24H0z"/></clipPath></defs></svg>',
    ai: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M5 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3H5Zm6.8 11.5.5 1.2a68.3 68.3 0 0 0 .7 1.1l.4.1c.3 0 .5 0 .7-.3.2-.1.3-.3.3-.6l-.3-1-2.6-6.2a20.4 20.4 0 0 0-.5-1.3l-.5-.4-.7-.2c-.2 0-.5 0-.6.2-.2 0-.4.2-.5.4l-.3.6-.3.7L5.7 15l-.2.6-.1.4c0 .3 0 .5.3.7l.6.2c.3 0 .5 0 .7-.2l.4-1 .5-1.2h3.9ZM9.8 9l1.5 4h-3l1.5-4Zm5.6-.9v7.6c0 .4 0 .7.2 1l.7.2c.3 0 .6 0 .8-.3l.2-.9V8.1c0-.4 0-.7-.2-.9a1 1 0 0 0-.8-.3c-.2 0-.5.1-.7.3l-.2 1Z"/></svg>',
    "align-center": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "align-justify": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "align-left": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "align-none": '<svg width="24" height="24"><path d="M14.2 5 13 7H5a1 1 0 1 1 0-2h9.2Zm4 0h.8a1 1 0 0 1 0 2h-2l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h6.8Zm4 0H19a1 1 0 0 1 0 2h-4.4l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h4.4Zm4 0H19a1 1 0 0 1 0 2h-6.8l1.2-2ZM7 17l-1.2 2H5a1 1 0 0 1 0-2h2Zm4 0h8a1 1 0 0 1 0 2H9.8l1.2-2Zm5.2-13.5 1.3.7-9.7 16.3-1.3-.7 9.7-16.3Z" fill-rule="evenodd"/></svg>',
    "align-right": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "arrow-left": '<svg width="24" height="24"><path d="m5.6 13 12 6a1 1 0 0 0 1.4-1V6a1 1 0 0 0-1.4-.9l-12 6a1 1 0 0 0 0 1.8Z" fill-rule="evenodd"/></svg>',
    "arrow-right": '<svg width="24" height="24"><path d="m18.5 13-12 6A1 1 0 0 1 5 18V6a1 1 0 0 1 1.4-.9l12 6a1 1 0 0 1 0 1.8Z" fill-rule="evenodd"/></svg>',
    bold: '<svg width="24" height="24"><path d="M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 0 1-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8Zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4Zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4Z" fill-rule="evenodd"/></svg>',
    bookmark: '<svg width="24" height="24"><path d="M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 0 0-1 1Z" fill-rule="nonzero"/></svg>',
    "border-style": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="2" x="3" y="6" rx="1"/><rect width="2.8" height="2" x="3" y="16" rx="1"/><rect width="2.8" height="2" x="6.8" y="16" rx="1"/><rect width="2.8" height="2" x="10.6" y="16" rx="1"/><rect width="2.8" height="2" x="14.4" y="16" rx="1"/><rect width="2.8" height="2" x="18.2" y="16" rx="1"/><rect width="8" height="2" x="3" y="11" rx="1"/><rect width="8" height="2" x="13" y="11" rx="1"/></g></svg>',
    "border-width": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="5" x="3" y="5" rx="1"/><rect width="18" height="3.5" x="3" y="11.5" rx="1"/><rect width="18" height="2" x="3" y="17" rx="1"/></g></svg>',
    brightness: '<svg width="24" height="24"><path d="M12 17c.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7v-1c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3Zm0-10a1 1 0 0 1-.7-.3A1 1 0 0 1 11 6V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3Zm7 4c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-1a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1ZM7 12c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H5a1 1 0 0 1-.7-.3A1 1 0 0 1 4 12c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1c.3 0 .5.1.7.3.2.2.3.4.3.7Zm10 3.5.7.8c.2.1.3.4.3.6 0 .3-.1.6-.3.8a1 1 0 0 1-.8.3 1 1 0 0 1-.6-.3l-.8-.7a1 1 0 0 1-.3-.8c0-.2.1-.5.3-.7a1 1 0 0 1 1.4 0Zm-10-7-.7-.8a1 1 0 0 1-.3-.6c0-.3.1-.6.3-.8.2-.2.5-.3.8-.3.2 0 .5.1.7.3l.7.7c.2.2.3.5.3.8 0 .2-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.8-.3Zm10 0a1 1 0 0 1-.8.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.6.3-.8l.8-.7c.1-.2.4-.3.6-.3.3 0 .6.1.8.3.2.2.3.5.3.8 0 .2-.1.5-.3.7l-.7.7Zm-10 7c.2-.2.5-.3.8-.3.2 0 .5.1.7.3a1 1 0 0 1 0 1.4l-.8.8a1 1 0 0 1-.6.3 1 1 0 0 1-.8-.3 1 1 0 0 1-.3-.8c0-.2.1-.5.3-.6l.7-.8ZM12 8a4 4 0 0 1 3.7 2.4 4 4 0 0 1 0 3.2A4 4 0 0 1 12 16a4 4 0 0 1-3.7-2.4 4 4 0 0 1 0-3.2A4 4 0 0 1 12 8Zm0 6.5c.7 0 1.3-.2 1.8-.7.5-.5.7-1.1.7-1.8s-.2-1.3-.7-1.8c-.5-.5-1.1-.7-1.8-.7s-1.3.2-1.8.7c-.5.5-.7 1.1-.7 1.8s.2 1.3.7 1.8c.5.5 1.1.7 1.8.7Z" fill-rule="evenodd"/></svg>',
    browse: '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9.4-2.3 2.3a1 1 0 1 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1-1.4 1.4L13 13.4V20a1 1 0 0 1-2 0v-6.6Z" fill-rule="nonzero"/></svg>',
    cancel: '<svg width="24" height="24"><path d="M12 4.6a7.4 7.4 0 1 1 0 14.8 7.4 7.4 0 0 1 0-14.8ZM12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7Z" fill-rule="nonzero"/></svg>',
    "cell-background-color": '<svg width="24" height="24"><path d="m15.7 2 1.6 1.6-2.7 2.6 5.9 5.8c.7.7.7 1.7 0 2.4l-6.3 6.1a1.7 1.7 0 0 1-2.4 0l-6.3-6.1c-.7-.7-.7-1.7 0-2.4L15.7 2ZM18 12l-4.5-4L9 12h9ZM4 16s2 2.4 2 3.8C6 21 5.1 22 4 22s-2-1-2-2.2C2 18.4 4 16 4 16Z"/></svg>',
    "cell-border-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M5 13v5h2v2H5a2 2 0 0 1-2-2v-5h2zm8-7V4h6a2 2 0 0 1 2 2h-8z" opacity=".2"/><path fill-rule="nonzero" d="M13 4v2H5v7H3V6c0-1.1.9-2 2-2h8zm-2.6 14.1.1-.1.1.1.2.3.2.2.2.2c.4.6.8 1.2.8 1.7 0 .8-.7 1.5-1.5 1.5S9 21.3 9 20.5c0-.5.4-1.1.8-1.7l.2-.2.2-.2.2-.3z"/><path d="m13 11-2 2H5v-2h6V6h2z"/><path fill-rule="nonzero" d="m18.4 8 1 1-1.8 1.9 4 4c.5.4.5 1.1 0 1.6l-4.3 4.2a1.2 1.2 0 0 1-1.6 0l-4.4-4.2c-.4-.5-.4-1.2 0-1.7l7-6.8Zm1.6 7-3-3-3 3h6Z"/></g></svg>',
    "change-case": '<svg width="24" height="24"><path d="M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 0 1-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 0 1-1 .7h-.2a.7.7 0 0 1-.7-1l4-12a1 1 0 0 1 2 0l4 12a.7.7 0 0 1-.8 1h-.2a1 1 0 0 1-1-.7l-.8-2.6zm-.3-1.5-2-6.5-1.9 6.5h3.9z" fill-rule="evenodd"/></svg>',
    "character-count": '<svg width="24" height="24"><path d="M4 11.5h16v1H4v-1Zm4.8-6.8V10H7.7V5.8h-1v-1h2ZM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1Zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1ZM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2V18.7l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 0 1-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 0 0-.5-.1 1 1 0 0 0-.4 0l-.3.4h-1Zm2.3.8h-.2l-.2.1-.4.1a1 1 0 0 0-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6Zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4Zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 0 0 1.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 0 0-.6-.3l-.6.3-.2.8Zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 0 0-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 0 1-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 0 1-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1Z" fill-rule="evenodd"/></svg>',
    "checklist-rtl": '<svg width="24" height="24"><path d="M5 17h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm14.2 11c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 8c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>',
    checklist: '<svg width="24" height="24"><path d="M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2h-8a1 1 0 0 1 0-2ZM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Z" fill-rule="evenodd"/></svg>',
    checkmark: '<svg width="24" height="24"><path d="M18.2 5.4a1 1 0 0 1 1.6 1.2l-8 12a1 1 0 0 1-1.5.1l-5-5a1 1 0 1 1 1.4-1.4l4.1 4.1 7.4-11Z" fill-rule="nonzero"/></svg>',
    "chevron-down": '<svg width="10" height="10"><path d="M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 0 1 0-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8Z" fill-rule="nonzero"/></svg>',
    "chevron-left": '<svg width="10" height="10"><path d="M7.8 1.3 4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 0 1 0-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1Z" fill-rule="nonzero"/></svg>',
    "chevron-right": '<svg width="10" height="10"><path d="M2.2 1.3a.8.8 0 0 1 0-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 0 1 0-1.1L6 5 2.2 1.3Z" fill-rule="nonzero"/></svg>',
    "chevron-up": '<svg width="10" height="10"><path d="M8.7 7.8 5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 0 1 0-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0Z" fill-rule="nonzero"/></svg>',
    close: '<svg width="24" height="24"><path d="M17.3 8.2 13.4 12l3.9 3.8a1 1 0 0 1-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 0 1-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 0 1 1.5-1.5l3.8 3.9 3.8-3.9a1 1 0 0 1 1.5 1.5Z" fill-rule="evenodd"/></svg>',
    "code-sample": '<svg width="24" height="26"><path d="M7.1 11a2.8 2.8 0 0 1-.8 2 2.8 2.8 0 0 1 .8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11Zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 0 1-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 0 1 .8-2 2.8 2.8 0 0 1-.8-2Zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2ZM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 0 1-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 0 1-.5-.5V17a3 3 0 0 0 1-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5Z" fill-rule="evenodd"/></svg>',
    "color-levels": '<svg width="24" height="24"><path d="M17.5 11.4A9 9 0 0 1 18 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 0 1-3.7 3 5.7 5.7 0 0 1-3.2 0A5.9 5.9 0 0 1 7.6 18a6.2 6.2 0 0 1-1.4-2.6 6.7 6.7 0 0 1 0-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 0 1 2.3-4A20 20 0 0 1 12 4a26.4 26.4 0 0 1 3.2 3.4 18.2 18.2 0 0 1 2.3 4Zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 0 0-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 0 1-1.3 3 5.3 5.3 0 0 1-2.3 1.5 4.9 4.9 0 0 1-2 .1 4.3 4.3 0 0 0 2.4.8 4 4 0 0 0 2-.6 4 4 0 0 0 1.5-1.5Z" fill-rule="evenodd"/></svg>',
    "color-picker": '<svg width="24" height="24"><path d="M12 3a9 9 0 0 0 0 18 1.5 1.5 0 0 0 1.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 0 0 5-5c0-4.4-4-8-9-8Zm-5.5 9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3-4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3 4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Z" fill-rule="nonzero"/></svg>',
    "color-swatch-remove-color": '<svg width="24" height="24"><path stroke="#000" stroke-width="2" d="M21 3 3 21" fill-rule="evenodd"/></svg>',
    "color-swatch": '<svg width="24" height="24"><rect x="3" y="3" width="18" height="18" rx="1" fill-rule="evenodd"/></svg>',
    "comment-add": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/><path d="M13 10h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 0v-2H9a1 1 0 0 1 0-2h2V8a1 1 0 0 1 2 0v2Z"/></g></svg>',
    comment: '<svg width="24" height="24"><path fill-rule="nonzero" d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/></svg>',
    contrast: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-6 8a6 6 0 0 0 6 6V6a6 6 0 0 0-6 6Z" fill-rule="evenodd"/></svg>',
    copy: '<svg width="24" height="24"><path d="M16 3H6a2 2 0 0 0-2 2v11h2V5h10V3Zm1 4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7Zm0 12V9h-7v10h7Z" fill-rule="nonzero"/></svg>',
    crop: '<svg width="24" height="24"><path d="M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-2H7V9H5a1 1 0 1 1 0-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3ZM9 9v5l5-5H9Zm1 6h5v-5l-5 5Z" fill-rule="evenodd"/></svg>',
    "cut-column": '<svg width="24" height="24"><path fill-rule="evenodd" d="M7.2 4.5c.9 0 1.6.4 2.2 1A3.7 3.7 0 0 1 10.5 8v.5l1 1 4-4 1-.5a3.3 3.3 0 0 1 2 0c.4 0 .7.3 1 .5L17 8h4v13h-6V10l-1.5 1.5.5.5v4l-2.5-2.5-1 1v.5c0 .4 0 .8-.3 1.2-.2.5-.4.9-.8 1.2-.6.7-1.3 1-2.2 1-.8.2-1.5 0-2-.6l-.5-.8-.2-1c0-.4 0-.8.3-1.2A3.9 3.9 0 0 1 7 12.7c.5-.2 1-.3 1.5-.2l1-1-1-1c-.5 0-1 0-1.5-.2-.5-.1-1-.4-1.4-.9-.4-.3-.6-.7-.8-1.2L4.5 7c0-.4 0-.7.2-1 0-.3.3-.6.5-.8.5-.5 1.2-.8 2-.7Zm12.3 5h-3v10h3v-10ZM8 13.8h-.3l-.4.2a2.8 2.8 0 0 0-.7.4v.1a2.8 2.8 0 0 0-.6.8l-.1.4v.7l.2.5.5.2h.7a2.6 2.6 0 0 0 .8-.3 2.4 2.4 0 0 0 .7-.7 2.5 2.5 0 0 0 .3-.8 1.5 1.5 0 0 0 0-.8 1 1 0 0 0-.2-.4 1 1 0 0 0-.5-.2H8Zm3.5-3.7c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4ZM7 5.8h-.4a1 1 0 0 0-.5.3 1 1 0 0 0-.2.5v.7a2.5 2.5 0 0 0 .3.8l.2.3h.1l.4.4.4.2.4.1h.7L9 9l.2-.4a1.6 1.6 0 0 0 0-.8 2.6 2.6 0 0 0-.3-.8A2.5 2.5 0 0 0 7.7 6l-.4-.1H7Z"/></svg>',
    "cut-row": '<svg width="24" height="24"><path fill-rule="evenodd" d="M22 3v5H9l3 3 2-2h4l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8.7.6 1 1.3 1 2.2.2.8 0 1.5-.6 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l2 2V3h14ZM8.5 15.3h-.3a2.6 2.6 0 0 0-.8.4 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3L9 18V18l.4-.4.2-.4.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2h-.5Zm7 0H15a1 1 0 0 0-.4.3 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4a2.8 2.8 0 0 0 .5.7h.1a2.8 2.8 0 0 0 .8.6l.4.1h.7l.5-.2.2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3h-.3ZM12 11.6c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4Zm8.5-7.1h-11v2h11v-2Z"/></svg>',
    cut: '<svg width="24" height="24"><path d="M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 0 1 0 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8Zm-8.5 2.2.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2 1.6 1.6 0 0 0-.8 0 2.6 2.6 0 0 0-.8.3 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3 2.8 2.8 0 0 0 1-1Zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4Zm5.4 4 .2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3 1.5 1.5 0 0 0-.8 0 1 1 0 0 0-.4.2 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4l.3.4.3.4a2.8 2.8 0 0 0 .8.5l.4.1h.7l.5-.2Z" fill-rule="evenodd"/></svg>',
    "document-properties": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>',
    drag: '<svg width="24" height="24"><path d="M13 5h2v2h-2V5Zm0 4h2v2h-2V9ZM9 9h2v2H9V9Zm4 4h2v2h-2v-2Zm-4 0h2v2H9v-2Zm0 4h2v2H9v-2Zm4 0h2v2h-2v-2ZM9 5h2v2H9V5Z" fill-rule="evenodd"/></svg>',
    "duplicate-column": '<svg width="24" height="24"><path d="M17 6v16h-7V6h7Zm-2 2h-3v12h3V8Zm-2-6v2H8v15H6V2h7Z"/></svg>',
    "duplicate-row": '<svg width="24" height="24"><path d="M22 11v7H6v-7h16Zm-2 2H8v3h12v-3Zm-1-6v2H4v5H2V7h17Z"/></svg>',
    duplicate: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10Zm3 8h-2V9h-7v10h9a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7a2 2 0 0 1 2 2v2Z"/><path d="M17 14h1a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1h-1a1 1 0 0 1 0-2h1v-1a1 1 0 0 1 2 0v1Z"/></g></svg>',
    "edit-block": '<svg width="24" height="24"><path fill-rule="nonzero" d="m19.8 8.8-9.4 9.4c-.2.2-.5.4-.9.4l-5.4 1.2 1.2-5.4.5-.8 9.4-9.4c.7-.7 1.8-.7 2.5 0l2.1 2.1c.7.7.7 1.8 0 2.5Zm-2-.2 1-.9v-.3l-2.2-2.2a.3.3 0 0 0-.3 0l-1 1L18 8.5Zm-1 1-2.5-2.4-6 6 2.5 2.5 6-6Zm-7 7.1-2.6-2.4-.3.3-.1.2-.7 3 3.1-.6h.1l.4-.5Z"/></svg>',
    "edit-image": '<svg width="24" height="24"><path d="M18 16h2V7a2 2 0 0 0-2-2H7v2h11v9ZM6 17h15a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1H6a2 2 0 0 1-2-2V7H3a1 1 0 1 1 0-2h1V4a1 1 0 1 1 2 0v13Zm3-5.3 1.3 2 3-4.7 3.7 6H7l2-3.3Z" fill-rule="nonzero"/></svg>',
    "embed-page": '<svg width="24" height="24"><path d="M19 6V5H5v14h2A13 13 0 0 1 19 6Zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4Zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6Zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3Zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 0 0 8 19h3ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 0 0-4 4.5h2.2Zm-3.4 0a12 12 0 0 1 2.8-4 12 12 0 0 0-5 4h2.2Z" fill-rule="nonzero"/></svg>',
    embed: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm4.8 2.6 5.6 4a.5.5 0 0 1 0 .8l-5.6 4A.5.5 0 0 1 9 16V8a.5.5 0 0 1 .8-.4Z" fill-rule="nonzero"/></svg>',
    emoji: '<svg width="24" height="24"><path d="M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5ZM12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16Zm0 14.5a6.5 6.5 0 1 1 0-13 6.5 6.5 0 0 1 0 13Z" fill-rule="nonzero"/></svg>',
    export: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M14.4 3 18 7v1h-5V5H7v14h9a1 1 0 0 1 2 0c0 1-.8 2-1.9 2H7c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2h7.5Z"/><path d="M18.1 12c.5 0 .9.4.9 1 0 .5-.3 1-.8 1h-7.3c-.5 0-.9-.4-.9-1 0-.5.3-1 .8-1h7.3Z"/><path d="M16.4 9.2a1 1 0 0 1 1.4.2l2.4 3.6-2.4 3.6a1 1 0 0 1-1.7-1v-.2l1.7-2.4-1.6-2.4a1 1 0 0 1 .2-1.4Z"/></g></svg>',
    fill: '<svg width="24" height="26"><path d="m16.6 12-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 0 0 2.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2ZM5.2 13 10 8.2l4.8 4.8H5.2ZM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.3-2-3.5-2-3.5Z" fill-rule="nonzero"/></svg>',
    "flip-horizontally": '<svg width="24" height="24"><path d="M14 19h2v-2h-2v2Zm4-8h2V9h-2v2ZM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 0 0-2 2Zm14-2v2h2a2 2 0 0 0-2-2Zm-7 16h2V3h-2v18Zm7-6h2v-2h-2v2Zm-4-8h2V5h-2v2Zm4 12a2 2 0 0 0 2-2h-2v2Z" fill-rule="nonzero"/></svg>',
    "flip-vertically": '<svg width="24" height="24"><path d="M5 14v2h2v-2H5Zm8 4v2h2v-2h-2Zm4-14H7a2 2 0 0 0-2 2v3h2V6h10v3h2V6a2 2 0 0 0-2-2Zm2 14h-2v2a2 2 0 0 0 2-2ZM3 11v2h18v-2H3Zm6 7v2h2v-2H9Zm8-4v2h2v-2h-2ZM5 18c0 1.1.9 2 2 2v-2H5Z" fill-rule="nonzero"/></svg>',
    footnote: '<svg width="24" height="24"><path d="M19 13c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h14Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M19 4v6h-1V5h-1.5V4h2.6Z"/><path d="M12 18c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h7ZM14 8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2h9Z"/></svg>',
    "format-painter": '<svg width="24" height="24"><path d="M18 5V4c0-.5-.4-1-1-1H5a1 1 0 0 0-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3Z" fill-rule="nonzero"/></svg>',
    format: '<svg width="24" height="24"><path fill-rule="evenodd" d="M17 5a1 1 0 0 1 0 2h-4v11a1 1 0 0 1-2 0V7H7a1 1 0 1 1 0-2h10Z"/></svg>',
    fullscreen: '<svg width="24" height="24"><path d="m15.3 10-1.2-1.3 2.9-3h-2.3a.9.9 0 1 1 0-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 1 1-1.8 0V7l-2.9 3Zm0 4 3 3v-2.3a.9.9 0 1 1 1.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 1 1 0-1.8H17l-3-2.9 1.3-1.2ZM10 15.4l-2.9 3h2.3a.9.9 0 1 1 0 1.7H5a.9.9 0 0 1-.9-.9v-4.4a.9.9 0 1 1 1.8 0V17l2.9-3 1.2 1.3ZM8.7 10 5.7 7v2.3a.9.9 0 0 1-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 0 1 0 1.8H7l3 2.9-1.3 1.2Z" fill-rule="nonzero"/></svg>',
    gallery: '<svg width="24" height="24"><path fill-rule="nonzero" d="m5 15.7 2.3-2.2c.3-.3.7-.3 1 0L11 16l5.1-5c.3-.4.8-.4 1 0l2 1.9V8H5v7.7ZM5 18V19h3l1.8-1.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 6h16c.6 0 1 .4 1 1v13c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V7c0-.6.4-1 1-1Zm6 7a2 2 0 1 1 0-4 2 2 0 0 1 0 4ZM4.5 4h15a.5.5 0 1 1 0 1h-15a.5.5 0 0 1 0-1Zm2-2h11a.5.5 0 1 1 0 1h-11a.5.5 0 0 1 0-1Z"/></svg>',
    gamma: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm6.5 11.8V14L9.2 8.7a5.1 5.1 0 0 0-.4-.8l-.1-.2H8v-1l.3-.1.3-.1h.7a1 1 0 0 1 .6.5l.1.3a8.5 8.5 0 0 1 .3.6l1.9 4.6 2-5.2a1 1 0 0 1 1-.6.5.5 0 0 1 .5.6L13 14v2.8a.7.7 0 0 1-1.4 0Z" fill-rule="nonzero"/></svg>',
    help: '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M12 5.5a6.5 6.5 0 0 0-6 9 6.3 6.3 0 0 0 1.4 2l1 1a6.3 6.3 0 0 0 3.6 1 6.5 6.5 0 0 0 6-9 6.3 6.3 0 0 0-1.4-2l-1-1a6.3 6.3 0 0 0-3.6-1ZM12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Z"/><path d="M9.6 9.7a.7.7 0 0 1-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 0 0-.8.8.8.8 0 0 1-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8Z" fill-rule="nonzero"/><circle cx="12" cy="16" r="1"/></g></svg>',
    "highlight-bg-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path class="tox-icon-highlight-bg-color__color" d="M3 18h18v3H3z"/><path fill-rule="nonzero" d="M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 0 1 2.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6"/></g></svg>',
    home: '<svg width="24" height="24"><path fill-rule="nonzero" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>',
    "horizontal-rule": '<svg width="24" height="24"><path d="M4 11h16v2H4z" fill-rule="evenodd"/></svg>',
    "image-options": '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>',
    image: '<svg width="24" height="24"><path d="m5 15.7 3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7ZM5 18V19h3l2.8-2.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm6 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z" fill-rule="nonzero"/></svg>',
    indent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>',
    info: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-1 3v2h2V7h-2Zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4Z" fill-rule="evenodd"/></svg>',
    "insert-character": '<svg width="24" height="24"><path d="M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 0 0 1.8-2.9 6.3 6.3 0 0 0-.1-4.1 5.8 5.8 0 0 0-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 0 0-3.9 1.8 6.3 6.3 0 0 0-1.3 6 6.2 6.2 0 0 0 1.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 0 1 4 11c0-1 .2-1.9.6-2.7A7 7 0 0 1 6.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 0 1 5.7 2 7 7 0 0 1 1.7 2.3 6 6 0 0 1 .2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 0 1-3.6 2.5v.5Z" fill-rule="evenodd"/></svg>',
    "insert-time": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M12 19a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm0 2a9 9 0 1 1 0-18 9 9 0 0 1 0 18Z"/><path d="M16 12h-3V7c0-.6-.4-1-1-1a1 1 0 0 0-1 1v7h5c.6 0 1-.4 1-1s-.4-1-1-1Z"/></g></svg>',
    invert: '<svg width="24" height="24"><path d="M18 19.3 16.5 18a5.8 5.8 0 0 1-3.1 1.9 6.1 6.1 0 0 1-5.5-1.6A5.8 5.8 0 0 1 6 14v-.3l.1-1.2A13.9 13.9 0 0 1 7.7 9l-3-3 .7-.8 2.8 2.9 9 8.9 1.5 1.6-.7.6Zm0-5.5v.3l-.1 1.1-.4 1-1.2-1.2a4.3 4.3 0 0 0 .2-1v-.2c0-.4 0-.8-.2-1.3l-.5-1.4a14.8 14.8 0 0 0-3-4.2L12 6a26.1 26.1 0 0 0-2.2 2.5l-1-1a20.9 20.9 0 0 1 2.9-3.3L12 4l1 .8a22.2 22.2 0 0 1 4 5.4c.6 1.2 1 2.4 1 3.6Z" fill-rule="evenodd"/></svg>',
    italic: '<svg width="24" height="24"><path d="m16.7 4.7-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8Z" fill-rule="evenodd"/></svg>',
    language: '<svg width="24" height="24"><path d="M12 3a9 9 0 1 1 0 18 9 9 0 0 1 0-18Zm4.3 13.3c-.5 1-1.2 2-2 2.9a7.5 7.5 0 0 0 3.2-2.1l-.2-.2a6 6 0 0 0-1-.6Zm-8.6 0c-.5.2-.9.5-1.2.8.9 1 2 1.7 3.2 2a10 10 0 0 1-2-2.8Zm3.6-.8c-.8 0-1.6.1-2.2.3.5 1 1.2 1.9 2.1 2.7Zm1.5 0v3c.9-.8 1.6-1.7 2.1-2.7-.6-.2-1.4-.3-2.1-.3Zm-6-2.7H4.5c.2 1 .5 2.1 1 3h.3l1.3-1a10 10 0 0 1-.3-2Zm12.7 0h-2.3c0 .7-.1 1.4-.3 2l1.6 1.1c.5-1 .9-2 1-3.1Zm-3.8 0h-3V14c1 0 2 .1 2.7.4.2-.5.3-1 .3-1.6Zm-4.4 0h-3l.3 1.6c.8-.3 1.7-.4 2.7-.4v-1.3Zm-5.5-5c-.7 1-1.1 2.2-1.3 3.5h2.3c0-1 .2-1.8.5-2.6l-1.5-1Zm2.9 1.4v.1c-.2.6-.4 1.3-.4 2h3V9.4c-1 0-1.8-.1-2.6-.3Zm6.6 0h-.1l-2.4.3v1.8h3l-.5-2.1Zm3-1.4-.3.1-1.3.8c.3.8.5 1.6.5 2.6h2.3a7.5 7.5 0 0 0-1.3-3.5Zm-9 0 2 .2V5.5a9 9 0 0 0-2 2.2Zm3.5-2.3V8c.6 0 1.3 0 1.9-.2a9 9 0 0 0-2-2.3Zm-3-.7h-.1c-1.1.4-2.1 1-3 1.8l1.2.7a10 10 0 0 1 1.9-2.5Zm4.4 0 .1.1a10 10 0 0 1 1.8 2.4l1.1-.7a7.5 7.5 0 0 0-3-1.8Z"/></svg>',
    "line-height": '<svg width="24" height="24"><path d="M21 5a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zM7 3.6l3.7 3.7a1 1 0 0 1-1.3 1.5h-.1L8 7.3v9.2l1.3-1.3a1 1 0 0 1 1.3 0h.1c.4.4.4 1 0 1.3v.1L7 20.4l-3.7-3.7a1 1 0 0 1 1.3-1.5h.1L6 16.7V7.4L4.7 8.7a1 1 0 0 1-1.3 0h-.1a1 1 0 0 1 0-1.3v-.1L7 3.6z"/></svg>',
    line: '<svg width="24" height="24"><path d="m15 9-8 8H4v-3l8-8 3 3Zm1-1-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1ZM4 18h16v2H4v-2Z" fill-rule="evenodd"/></svg>',
    link: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2-2a2 2 0 1 0-2.6-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2Z" fill-rule="nonzero"/></svg>',
    "list-bull-circle": '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M11 16a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 26a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 36a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6Z" fill-rule="nonzero"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
    "list-bull-default": '<svg width="48" height="48"><g fill-rule="evenodd"><circle cx="11" cy="14" r="3"/><circle cx="11" cy="24" r="3"/><circle cx="11" cy="34" r="3"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
    "list-bull-square": '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M8 11h6v6H8zM8 21h6v6H8zM8 31h6v6H8z"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
    "list-num-default-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 17v-4.8h-.1l-1.5 1v-1.1l1.6-1.1h1.2v6zM33.3 17.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm1.7 5.7c0-1.2 1-2 2.2-2 1.3 0 2.1.8 2.1 1.8 0 .7-.3 1.2-1.3 2.2l-1.2 1v.2h2.6v1h-4.3v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H35zm-1.7 4.3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm3.2 7.3v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H35c0-1.1 1-1.8 2.2-1.8 1.2 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.7.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .6 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm-3.3 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>',
    "list-num-default": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2Zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5Zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7Zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Z"/></g></svg>',
    "list-num-lower-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M36.5 16c-.9 0-1.5-.5-1.5-1.3s.6-1.3 1.8-1.4h1v-.4c0-.4-.2-.6-.7-.6-.4 0-.7.1-.8.4h-1.1c0-.8.8-1.4 2-1.4S39 12 39 13V16h-1.2v-.6c-.3.4-.8.7-1.4.7Zm.4-.8c.6 0 1-.4 1-.9V14h-1c-.5.1-.7.3-.7.6 0 .4.3.6.7.6ZM33.1 16.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7ZM37.7 26c-.7 0-1.2-.2-1.5-.7v.7H35v-6.3h1.2v2.5c.3-.5.8-.9 1.5-.9 1.1 0 1.8 1 1.8 2.4 0 1.5-.7 2.4-1.8 2.4Zm-.5-3.6c-.6 0-1 .5-1 1.3s.4 1.4 1 1.4c.7 0 1-.6 1-1.4 0-.8-.3-1.3-1-1.3ZM33.2 26.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm6 7h-1c-.1-.5-.4-.8-1-.8s-1 .5-1 1.4c0 1 .4 1.4 1 1.4.5 0 .9-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm-6.1 3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
    "list-num-lower-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6Zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7Zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4Zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3Zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7Zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-lower-greek-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 16c-1.2 0-2-.8-2-2.3 0-1.5.8-2.4 2-2.4.6 0 1 .4 1.3 1v-.9H40v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1-.7h-.2c-.2.4-.7.8-1.3.8Zm.3-1c.6 0 1-.5 1-1.3s-.4-1.3-1-1.3-1 .5-1 1.3.4 1.4 1 1.4ZM33.3 16.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM36 21.9c0-1.5.8-2.3 2.1-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.9 1.3.9.3 1.3.8 1.3 1.7 0 1.2-.7 1.9-1.8 1.9-.6 0-1.1-.3-1.4-.8v2.2H36V22Zm1.8 1.2v-1h.3c.5 0 .9-.2.9-.7 0-.5-.3-.8-.9-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1 1.3s1-.4 1-1-.4-1-1.2-1h-.3ZM33.3 26.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM37.1 34.6 34.8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.2.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1ZM33.3 36.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-lower-greek": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4Zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8Zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3ZM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22Zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1Zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-lower-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M32.9 16v-1.2h-1.3V16H33Zm0 10v-1.2h-1.3V26H33Zm0 10v-1.2h-1.3V36H33Z"/><path fill-rule="nonzero" d="M36 21h-1.5v5H36zM36 31h-1.5v5H36zM39 21h-1.5v5H39zM39 31h-1.5v5H39zM42 31h-1.5v5H42zM36 11h-1.5v5H36zM36 19h-1.5v1H36zM36 29h-1.5v1H36zM39 19h-1.5v1H39zM39 29h-1.5v1H39zM42 29h-1.5v1H42zM36 9h-1.5v1H36z"/></g></svg>',
    "list-num-lower-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 16v-1.2h1.3V16H15Zm0 10v-1.2h1.3V26H15Zm0 10v-1.2h1.3V36H15Z"/><path fill-rule="nonzero" d="M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z"/></g></svg>',
    "list-num-upper-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="m39.3 17-.5-1.4h-2l-.5 1.4H35l2-6h1.6l2 6h-1.3Zm-1.6-4.7-.7 2.3h1.6l-.8-2.3ZM33.4 17c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm4.7 9.9h-2.7v-6H38c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7Zm-1.4-5v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4h1.1c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9h-1.1V26ZM33 27.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm4.9 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm-4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-upper-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="m12.6 17-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3ZM11 12.3l-.7 2.3h1.6l-.8-2.3Zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7ZM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7ZM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26Zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-upper-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M31.6 17v-1.2H33V17h-1.3Zm0 10v-1.2H33V27h-1.3Zm0 10v-1.2H33V37h-1.3Z"/><path fill-rule="nonzero" d="M34.5 20H36v7h-1.5zM34.5 30H36v7h-1.5zM37.5 20H39v7h-1.5zM37.5 30H39v7h-1.5zM40.5 30H42v7h-1.5zM34.5 10H36v7h-1.5z"/></g></svg>',
    "list-num-upper-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 17v-1.2h1.3V17H15Zm0 10v-1.2h1.3V27H15Zm0 10v-1.2h1.3V37H15Z"/><path fill-rule="nonzero" d="M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z"/></g></svg>',
    lock: '<svg width="24" height="24"><path d="M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3ZM10 8v3h4V8a1 1 0 0 0-.3-.7A1 1 0 0 0 13 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7Z" fill-rule="evenodd"/></svg>',
    ltr: '<svg width="24" height="24"><path d="M11 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 7.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L11 5ZM4.4 16.2 6.2 15l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>',
    "math-equation": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 4.8c.1-.5.5-.8 1-.8h10a1 1 0 1 1 0 2h-9.2L8.3 19.2a1 1 0 0 1-1.7.4l-3.4-4.2a1 1 0 0 1 1.6-1.2l2 2.5L9 4.8Zm9.7 5.5c.4.4.4 1 0 1.4L17 13.5l1.8 1.8a1 1 0 1 1-1.4 1.4L15.5 15l-1.8 1.8a1 1 0 0 1-1.4-1.4l1.8-1.8-1.8-1.8a1 1 0 0 1 1.4-1.4l1.8 1.8 1.8-1.8a1 1 0 0 1 1.4 0Z"/></svg>',
    minus: '<svg width="24" height="24"><path d="M19 11a1 1 0 0 1 .1 2H5a1 1 0 0 1-.1-2H19Z"/></svg>',
    "more-drawer": '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>',
    "new-document": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>',
    "new-tab": '<svg width="24" height="24"><path d="m15 13 2-2v8H5V7h8l-2 2H7v8h8v-4Zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19Z" fill-rule="evenodd"/></svg>',
    "non-breaking": '<svg width="24" height="24"><path d="M11 11H8a1 1 0 1 1 0-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-3Zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1Z" fill-rule="evenodd"/></svg>',
    notice: '<svg width="24" height="24"><path d="M15.5 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7ZM13 17v-2h-2v2h2Zm0-4V7h-2v6h2Z" fill-rule="evenodd" clip-rule="evenodd"/></svg>',
    "ordered-list-rtl": '<svg width="24" height="24"><path d="M6 17h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 1 1 0-2Zm13-1v3.5a.5.5 0 1 1-1 0V5h-.5a.5.5 0 1 1 0-1H19Zm-1 8.8.2.2h1.3a.5.5 0 1 1 0 1h-1.6a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2h-1.3a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3Zm2 4.2v2c0 .6-.4 1-1 1h-1.5a.5.5 0 0 1 0-1h1.2a.3.3 0 1 0 0-.6h-1.3a.4.4 0 1 1 0-.8h1.3a.3.3 0 0 0 0-.6h-1.2a.5.5 0 1 1 0-1H19c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>',
    "ordered-list": '<svg width="24" height="24"><path d="M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 1 1 0-2ZM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 0 1-.5-.5V5h-.5a.5.5 0 0 1 0-1H6Zm-1 8.8.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2H4.5a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3ZM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 0 1 0-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 1 1 0-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 1 1 0-1H6c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>',
    orientation: '<svg width="24" height="24"><path d="M7.3 6.4 1 13l6.4 6.5 6.5-6.5-6.5-6.5ZM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7ZM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 0 1 0-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 1 1-4.3 16.9l1.5-1.5A7 7 0 1 0 13 6h-1Z" fill-rule="nonzero"/></svg>',
    outdent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm1.6-3.8a1 1 0 0 1-1.2 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 0 1 1.2 1.6L6.8 12l1.8 1.2Z" fill-rule="evenodd"/></svg>',
    "page-break": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2ZM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1ZM6 22a1 1 0 0 1-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5H7v5c0 .6-.4 1-1 1Z"/></g></svg>',
    paragraph: '<svg width="24" height="24"><path fill-rule="evenodd" d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z"/></svg>',
    "paste-column-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h7v2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm8 7v12h-6V8h6Zm-1.5 1.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-column-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V18c0 1-.8 2-1.9 2H11v-2h7V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v2H4V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm-2 7v12H4V8h6ZM8.5 9.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-row-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V11h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h14c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 11v5H8v-5h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-row-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h12v-4h2v4c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 7v5H8V8h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-text": '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2Z" fill-rule="nonzero"/></svg>',
    paste: '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Z" fill-rule="nonzero"/></svg>',
    "permanent-pen": '<svg width="24" height="24"><path d="M10.5 17.5 8 20H3v-3l3.5-3.5a2 2 0 0 1 0-3L14 3l1 1-7.3 7.3a1 1 0 0 0 0 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 0 1-2.8 0l-.1-.1Z" fill-rule="nonzero"/></svg>',
    plus: '<svg width="24" height="24"><path d="M12 4c.5 0 1 .4 1 .9V11h6a1 1 0 0 1 .1 2H13v6a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H11V5c0-.6.4-1 1-1Z"/></svg>',
    preferences: '<svg width="24" height="24"><path d="m20.1 13.5-1.9.2a5.8 5.8 0 0 1-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 0 1-1.4 0l-1.5-1.2a6.2 6.2 0 0 1-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 0 1-1-.9l-.2-1.9a5.8 5.8 0 0 1-1.5-.6l-1.5 1.2a1 1 0 0 1-1.4 0l-.7-.7a1 1 0 0 1 0-1.4l1.2-1.5a6.2 6.2 0 0 1-.6-1.5l-1.9-.2a1 1 0 0 1-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 0 1 .6-1.5L5.2 7.3a1 1 0 0 1 0-1.4l.7-.7a1 1 0 0 1 1.4 0l1.5 1.2a6.2 6.2 0 0 1 1.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 0 1 1.5.6l1.5-1.2a1 1 0 0 1 1.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 0 1 .6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1ZM12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" fill-rule="evenodd"/></svg>',
    preview: '<svg width="24" height="24"><path d="M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 0 0 2.1-2.8 15.7 15.7 0 0 0-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 0 0-6.7 3.2A16.2 16.2 0 0 0 3.2 12c0 .2.2.3.3.5Zm-2.4-1 .7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 0 1 2.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 0 1-2.8-3.7 1 1 0 0 1 0-1Zm12-3.3a2 2 0 1 0 2.7 2.6 4 4 0 1 1-2.6-2.6Z" fill-rule="nonzero"/></svg>',
    print: '<svg width="24" height="24"><path d="M18 8H6a3 3 0 0 0-3 3v6h2v3h14v-3h2v-6a3 3 0 0 0-3-3Zm-1 10H7v-4h10v4Zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5Zm.5-8H6v2h12V5Z" fill-rule="nonzero"/></svg>',
    quote: '<svg width="24" height="24"><path d="M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Z" fill-rule="nonzero"/></svg>',
    redo: '<svg width="24" height="24"><path d="M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 1 1-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 1 1 1.4-1.4l5 5a1 1 0 0 1 0 1.4l-5 5a1 1 0 0 1-1.4-1.4l3.3-3.3Z" fill-rule="nonzero"/></svg>',
    reload: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m5 22.1-1.2-4.7v-.2a1 1 0 0 1 1-1l5 .4a1 1 0 1 1-.2 2l-2.2-.2a7.8 7.8 0 0 0 8.4.2 7.5 7.5 0 0 0 3.5-6.4 1 1 0 1 1 2 0 9.5 9.5 0 0 1-4.5 8 9.9 9.9 0 0 1-10.2 0l.4 1.4a1 1 0 1 1-2 .5ZM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 0 0-9.5-1 7.5 7.5 0 0 0-3.6 7 1 1 0 0 1-2 0 9.5 9.5 0 0 1 4.5-8.6 10 10 0 0 1 10.9.3l-.3-1a1 1 0 0 1 2-.5l1.1 4.8a1 1 0 0 1-1 1.2l-5-.4a1 1 0 0 1-.9-1Z"/></g></svg>',
    "remove-formatting": '<svg width="24" height="24"><path d="M13.2 6a1 1 0 0 1 0 .2l-2.6 10a1 1 0 0 1-1 .8h-.2a.8.8 0 0 1-.8-1l2.6-10H8a1 1 0 1 1 0-2h9a1 1 0 0 1 0 2h-3.8ZM5 18h7a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Zm13 1.5L16.5 18 15 19.5a.7.7 0 0 1-1-1l1.5-1.5-1.5-1.5a.7.7 0 0 1 1-1l1.5 1.5 1.5-1.5a.7.7 0 0 1 1 1L17.5 17l1.5 1.5a.7.7 0 0 1-1 1Z" fill-rule="evenodd"/></svg>',
    remove: '<svg width="24" height="24"><path d="M16 7h3a1 1 0 0 1 0 2h-1v9a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V9H5a1 1 0 1 1 0-2h3V6a3 3 0 0 1 3-3h2a3 3 0 0 1 3 3v1Zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 0 0-1 1v1h4Zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9Zm-7 3a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Zm4 0a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Z" fill-rule="nonzero"/></svg>',
    "resize-handle": '<svg width="10" height="10"><g fill-rule="nonzero"><path d="M8.1 1.1A.5.5 0 1 1 9 2l-7 7A.5.5 0 1 1 1 8l7-7ZM8.1 5.1A.5.5 0 1 1 9 6l-3 3A.5.5 0 1 1 5 8l3-3Z"/></g></svg>',
    resize: '<svg width="24" height="24"><path d="M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-6a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3A1 1 0 0 1 4 11V5Z" fill-rule="evenodd"/></svg>',
    "restore-draft": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1Z"/><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></g></svg>',
    "revision-history": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1Z"/><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></g></svg>',
    "rotate-left": '<svg width="24" height="24"><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></svg>',
    "rotate-right": '<svg width="24" height="24"><path d="M20 8V5a1 1 0 0 1 2 0v6c0 .6-.4 1-1 1h-6a1 1 0 0 1 0-2h4.3L16 7A7.2 7.2 0 0 0 7.7 6a7 7 0 0 0 3 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 0 1 1.4 1.5A9.2 9.2 0 0 1 2.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8Z" fill-rule="nonzero"/></svg>',
    rtl: '<svg width="24" height="24"><path d="M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 4.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L8 5Zm12 11.2a1 1 0 1 1-1 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 1 1 1 1.6L18.4 15l1.8 1.2Z" fill-rule="evenodd"/></svg>',
    save: '<svg width="24" height="24"><path d="M5 16h14a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2c0-1.1.9-2 2-2Zm0 2v2h14v-2H5Zm10 0h2v2h-2v-2Zm-4-6.4L8.7 9.3a1 1 0 1 0-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 1 0-1.4-1.4L13 11.6V4a1 1 0 0 0-2 0v7.6Z" fill-rule="nonzero"/></svg>',
    search: '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z" fill-rule="nonzero"/></svg>',
    "select-all": '<svg width="24" height="24"><path d="M3 5h2V3a2 2 0 0 0-2 2Zm0 8h2v-2H3v2Zm4 8h2v-2H7v2ZM3 9h2V7H3v2Zm10-6h-2v2h2V3Zm6 0v2h2a2 2 0 0 0-2-2ZM5 21v-2H3c0 1.1.9 2 2 2Zm-2-4h2v-2H3v2ZM9 3H7v2h2V3Zm2 18h2v-2h-2v2Zm8-8h2v-2h-2v2Zm0 8a2 2 0 0 0 2-2h-2v2Zm0-12h2V7h-2v2Zm0 8h2v-2h-2v2Zm-4 4h2v-2h-2v2Zm0-16h2V3h-2v2ZM7 17h10V7H7v10Zm2-8h6v6H9V9Z" fill-rule="nonzero"/></svg>',
    selected: '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm3.6 10.9L7 12.3a.7.7 0 0 0-1 1L9.6 17 18 8.6a.7.7 0 0 0 0-1 .7.7 0 0 0-1 0l-7.4 7.3Z"/></svg>',
    send: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="m13.3 22 7-18.3-18.3 7L9 15l4.3 7ZM18 6.8l-.7-.7L9.4 14l.7.7L18 6.8Z"/></svg>',
    settings: '<svg width="24" height="24"><path d="M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V8H5a1 1 0 1 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6ZM8 8h2V6H8v2Zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V13H5a1 1 0 0 1 0-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6ZM14 13h2v-2h-2v2Zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V18H5a1 1 0 0 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6ZM8 18h2v-2H8v2Z" fill-rule="evenodd"/></svg>',
    sharpen: '<svg width="24" height="24"><path d="m16 6 4 4-8 9-8-9 4-4h8Zm-4 10.2 5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2Z" fill-rule="evenodd"/></svg>',
    sourcecode: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 0 1 0-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7ZM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 0 0-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7Z"/></g></svg>',
    "spell-check": '<svg width="24" height="24"><path d="M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6Zm0-3v2h2V5H6Zm13 0h-3v5h3v1h-3a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1Zm-5 1.5-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5ZM13 10V8h-2v2h2Zm0-3V5h-2v2h2Zm3 5 1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12Z" fill-rule="evenodd"/></svg>',
    "strike-through": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 0 1 7 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1Z"/><path d="M5 11h14a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Z" fill-rule="nonzero"/></g></svg>',
    subscript: '<svg width="24" height="24"><path d="m10.4 10 4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10ZM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 0 0-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 0 1-1.3 1.3l-.6.6h2.6V19Z" fill-rule="nonzero"/></svg>',
    superscript: '<svg width="24" height="24"><path d="M15 9.4 10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4Zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11Z" fill-rule="nonzero"/></svg>',
    "table-caption": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="12" height="2" x="3" y="4" rx="1"/><path d="M19 8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-8c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></g></svg>',
    "table-cell-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M13 4v9H3V6c0-1.1.9-2 2-2h8Zm-2 2H5v5h6V6Z"/><path fill-rule="nonzero" d="M13 4h6a2 2 0 0 1 2 2v7h-8v-2h6V6h-6V4Z" opacity=".2"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/><path fill-rule="nonzero" d="M3 13v5c0 1.1.9 2 2 2h8v-7h-2v5H5v-5H3Z" opacity=".2"/></g></svg>',
    "table-cell-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8 0h-6v5h6v-5Zm-8-7H5v5h6V6Z"/></svg>',
    "table-cell-select-all": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z" opacity=".2"/></g></svg>',
    "table-cell-select-inner": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z" opacity=".2"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z"/></g></svg>',
    "table-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v7h-8v7H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8-7h-6v5h6V6Zm-8 0H5v5h6V6Z"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/></g></svg>',
    "table-delete-column": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-4 4h-2V6h-2v2H9V6H5v12h4v-2h2v2h2v-2h2v2h4V6h-4v2Zm.3.5 1 1.2-3 2.3 3 2.3-1 1.2L12 13l-3.3 2.6-1-1.2 3-2.3-3-2.3 1-1.2L12 11l3.3-2.5Z"/></svg>',
    "table-delete-row": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v3h2.5v2H5v2h2.5v2H5v3h14v-3h-2.5v-2H19v-2h-2.5V9H19V6Zm-4.7 1.8 1.2 1L13 12l2.6 3.3-1.2 1-2.3-3-2.3 3-1.2-1L11 12 8.5 8.7l1.2-1 2.3 3 2.3-3Z"/></svg>',
    "table-delete-table": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 6v12h14V6H5Z"/><path d="m14.4 8.6 1.1 1-2.4 2.4 2.4 2.4-1.1 1.1-2.4-2.4-2.4 2.4-1-1.1 2.3-2.4-2.3-2.4 1-1 2.4 2.3z"/></g></svg>',
    "table-insert-column-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M20 4c.6 0 1 .4 1 1v2a1 1 0 0 1-2 0V6h-8v12h8v-1a1 1 0 0 1 2 0v2c0 .5-.4 1-.9 1H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h15ZM9 13H5v5h4v-5Zm7-5c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H17v2a1 1 0 0 1-2 .1V13h-2a1 1 0 0 1-.1-2H15V9c0-.6.4-1 1-1ZM9 6H5v5h4V6Z"/></svg>',
    "table-insert-column-before": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a1 1 0 0 1-1-1v-2a1 1 0 0 1 2 0v1h8V6H5v1a1 1 0 1 1-2 0V5c0-.6.4-1 1-1h15Zm0 9h-4v5h4v-5ZM8 8c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H9v2a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H7V9c0-.6.4-1 1-1Zm11-2h-4v5h4V6Z"/></svg>',
    "table-insert-row-above": '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4a1 1 0 1 1 0 2H5v6h14V6h-1a1 1 0 0 1 0-2h2c.6 0 1 .4 1 1v13a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5c0-.6.4-1 1-1h2Zm5 10H5v4h6v-4Zm8 0h-6v4h6v-4ZM12 3c.5 0 1 .4 1 .9V6h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 .1V8H9a1 1 0 0 1 0-2h2V4c0-.6.4-1 1-1Z"/></svg>',
    "table-insert-row-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M12 13c.5 0 1 .4 1 .9V16h2a1 1 0 0 1 .1 2H13v2a1 1 0 0 1-2 .1V18H9a1 1 0 0 1-.1-2H11v-2c0-.6.4-1 1-1Zm6 7a1 1 0 0 1 0-2h1v-6H5v6h1a1 1 0 0 1 0 2H4a1 1 0 0 1-1-1V6c0-1.1.9-2 2-2h14a2 2 0 0 1 2 2v13c0 .5-.4 1-.9 1H18ZM11 6H5v4h6V6Zm8 0h-6v4h6V6Z"/></svg>',
    "table-left-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 9h-4v5h4v-5Zm-6 0H9v5h4v-5Zm0-7H9v5h4V6Zm6 0h-4v5h4V6Z"/></svg>',
    "table-merge-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15.5V18h3v-2.5H5Zm14-5h-9V18h9v-7.5ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Zm-8 7.5h3v-3H5v3Z"/></svg>',
    "table-row-numbering-rtl": '<svg width="24" height="24"><path d="M6 4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H6Zm0 12h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 11h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 6h8v3H6V6Zm11 0c.6 0 1 .4 1 1v1a1 1 0 1 1-2 0V7c0-.6.4-1 1-1Z"/></svg>',
    "table-row-numbering": '<svg width="24" height="24"><path d="M18 4a2 2 0 0 1 2 2v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h12Zm0 12h-8v3h8v-3ZM7 16a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8v-3ZM7 11a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8V6ZM7 6a1 1 0 0 0-1 1v1a1 1 0 1 0 2 0V7c0-.6-.4-1-1-1Z"/></svg>',
    "table-row-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-9h-6v3h6V6ZM5 9h6V6H5v3Z"/></svg>',
    "table-split-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM8 15.5H5V18h3v-2.5Zm11-5h-9V18h9v-7.5Zm-2.5 1 1 1-2 2 2 2-1 1-2-2-2 2-1-1 2-2-2-2 1-1 2 2 2-2Zm-8.5-1H5v3h3v-3ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Z"/></svg>',
    "table-top-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 11H5v3h6v-3Zm8 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></svg>',
    table: '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 14v4h6v-4H5Zm14 0h-6v4h6v-4Zm0-6h-6v4h6V8ZM5 12h6V8H5v4Z"/></svg>',
    "template-add": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 12v4H5a2 2 0 0 0-2 2v3h9.3a6 6 0 0 1-.3-2H5v-1h7a6 6 0 0 1 .8-2H11v-5l-.8-.6a3 3 0 1 1 3.6 0l-.8.6v4.7a6 6 0 0 1 2-1.9V12a5 5 0 1 0-6 0Z"/><path d="M18 15c.5 0 1 .4 1 .9V18h2a1 1 0 0 1 .1 2H19v2a1 1 0 0 1-2 .1V20h-2a1 1 0 0 1-.1-2H17v-2c0-.6.4-1 1-1Z"/></svg>',
    template: '<svg width="24" height="24"><path d="M19 19v-1H5v1h14ZM9 16v-4a5 5 0 1 1 6 0v4h4a2 2 0 0 1 2 2v3H3v-3c0-1.1.9-2 2-2h4Zm4 0v-5l.8-.6a3 3 0 1 0-3.6 0l.8.6v5h2Z" fill-rule="nonzero"/></svg>',
    "temporary-placeholder": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M9 7.6V6h2.5V4.5a.5.5 0 1 1 1 0V6H15v1.6a8 8 0 1 1-6 0Zm-2.6 5.3a.5.5 0 0 0 .3.6c.3 0 .6 0 .6-.3l.1-.2a5 5 0 0 1 3.3-2.8c.3-.1.4-.4.4-.6-.1-.3-.4-.5-.6-.4a6 6 0 0 0-4.1 3.7Z"/><circle cx="14" cy="4" r="1"/><circle cx="12" cy="2" r="1"/><circle cx="10" cy="4" r="1"/></g></svg>',
    "text-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path class="tox-icon-text-color__color" d="M3 18h18v3H3z"/><path d="M8.7 16h-.8a.5.5 0 0 1-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 0 1-.5.6h-.8a.5.5 0 0 1-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4Zm2.6-7.6-.6 2a.5.5 0 0 0 .5.6h1.6a.5.5 0 0 0 .5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4Z"/></g></svg>',
    "text-size-decrease": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM14 12a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-6Z"/></svg>',
    "text-size-increase": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM17 9a1 1 0 0 0-1 1v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2h-2v-2c0-.6-.4-1-1-1Z"/></svg>',
    toc: '<svg width="24" height="24"><path d="M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    translate: '<svg width="24" height="24"><path d="m12.7 14.3-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 0 1 0-1l3.1-3A12.4 12.4 0 0 1 6.7 9H8a10.1 10.1 0 0 0 1.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 1 1 0-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 0 1-1 2.4 13.5 13.5 0 0 1-1.7 2.3l1.9 1.8Zm4.3-3 2.7 7.3a.5.5 0 0 1-.4.7 1 1 0 0 1-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 0 1-1 .7.5.5 0 0 1-.4-.7l2.7-7.4a1 1 0 0 1 2 0Zm-2.2 4.4h2.4L16 12.5l-1.2 3.2Z" fill-rule="evenodd"/></svg>',
    typography: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M17 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H7a1 1 0 0 1 0-2h10Z"/><path d="m17.5 14 .8-1.7 1.7-.8-1.7-.8-.8-1.7-.8 1.7-1.7.8 1.7.8.8 1.7ZM7 14l1 2 2 1-2 1-1 2-1-2-2-1 2-1 1-2Z"/></svg>',
    underline: '<svg width="24" height="24"><path d="M16 5c.6 0 1 .4 1 1v5.5a4 4 0 0 1-.4 1.8l-1 1.4a5.3 5.3 0 0 1-5.5 1 5 5 0 0 1-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 0 1-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 0 0 2.2.8 3.4 3.4 0 0 0 2.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1ZM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    undo: '<svg width="24" height="24"><path d="M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 0 1-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 1 1-1.4 1.4l-5-5a1 1 0 0 1 0-1.4l5-5a1 1 0 0 1 1.4 1.4L6.4 8Z" fill-rule="nonzero"/></svg>',
    unlink: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2.1-2a2 2 0 1 0-2.7-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2ZM7.6 6.3a.8.8 0 0 1-1 1.1L3.3 4.2a.7.7 0 1 1 1-1l3.2 3.1ZM5.1 8.6a.8.8 0 0 1 0 1.5H3a.8.8 0 0 1 0-1.5H5Zm5-3.5a.8.8 0 0 1-1.5 0V3a.8.8 0 0 1 1.5 0V5Zm6 11.8a.8.8 0 0 1 1-1l3.2 3.2a.8.8 0 0 1-1 1L16 17Zm-2.2 2a.8.8 0 0 1 1.5 0V21a.8.8 0 0 1-1.5 0V19Zm5-3.5a.7.7 0 1 1 0-1.5H21a.8.8 0 0 1 0 1.5H19Z" fill-rule="nonzero"/></svg>',
    unlock: '<svg width="24" height="24"><path d="M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 0 0-.3-.7A1 1 0 0 0 16 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2Z" fill-rule="evenodd"/></svg>',
    "unordered-list": '<svg width="24" height="24"><path d="M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2ZM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Z" fill-rule="evenodd"/></svg>',
    unselected: '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm0 1a1 1 0 0 0-1 1v12c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H6Z"/></svg>',
    upload: '<svg width="24" height="24"><path d="M18 19v-2a1 1 0 0 1 2 0v3c0 .6-.4 1-1 1H5a1 1 0 0 1-1-1v-3a1 1 0 0 1 2 0v2h12ZM11 6.4 8.7 8.7a1 1 0 0 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 1 1-1.4 1.4L13 6.4V16a1 1 0 0 1-2 0V6.4Z" fill-rule="nonzero"/></svg>',
    user: '<svg width="24" height="24"><path d="M12 24a12 12 0 1 1 0-24 12 12 0 0 1 0 24Zm-8.7-5.3a11 11 0 0 0 17.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7ZM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13Z" fill-rule="nonzero"/></svg>',
    "vertical-align": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="18" height="2" x="3" y="11" rx="1"/><path d="M12 2c.6 0 1 .4 1 1v4l2-1.3a1 1 0 0 1 1.2 1.5l-.1.1-4.1 3-4-3a1 1 0 0 1 1-1.7l2 1.5V3c0-.6.4-1 1-1zm0 11.8 4 2.9a1 1 0 0 1-1 1.7l-2-1.5V21c0 .5-.4 1-.9 1H12a1 1 0 0 1-1-1v-4l-2 1.3a1 1 0 0 1-1.2-.1l-.1-.1a1 1 0 0 1 .1-1.3l.1-.1 4.1-3z"/></g></svg>',
    visualblocks: '<svg width="24" height="24"><path d="M9 19v2H7v-2h2Zm-4 0v2a2 2 0 0 1-2-2h2Zm8 0v2h-2v-2h2Zm8 0a2 2 0 0 1-2 2v-2h2Zm-4 0v2h-2v-2h2ZM15 7a1 1 0 0 1 0 2v7a1 1 0 0 1-2 0V9h-1v7a1 1 0 0 1-2 0v-4a2.5 2.5 0 0 1-.2-5H15ZM5 15v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 11v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 7v2H3V7h2Zm16 0v2h-2V7h2ZM5 3v2H3c0-1.1.9-2 2-2Zm8 0v2h-2V3h2Zm6 0a2 2 0 0 1 2 2h-2V3ZM9 3v2H7V3h2Zm8 0v2h-2V3h2Z" fill-rule="evenodd"/></svg>',
    visualchars: '<svg width="24" height="24"><path d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z" fill-rule="evenodd"/></svg>',
    warning: '<svg width="24" height="24"><path d="M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6ZM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3Zm.7-3 .3-4a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7l.3 4h1.4Z" fill-rule="evenodd"/></svg>',
    "zoom-in": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-1-9a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0V8Zm-2 4a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>',
    "zoom-out": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-3-5a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>',
    "export-pdf": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 3h7.4L19 7.6V17h-2V9h-4V5H7v3H5V5c0-1.1.9-2 2-2Z"/><path d="M2.6 15.2v-1.9h1c.6 0 1-.2 1.4-.5.3-.3.5-.7.5-1.2s-.2-.9-.5-1.2a2 2 0 0 0-1.3-.4H1v5.2h1.6Zm.4-3h-.4v-1.1h.5l.6.1.2.5c0 .1 0 .3-.2.4l-.7.1Zm5.7 3 1-.1c.3 0 .5-.2.7-.4l.5-.8c.2-.3.2-.7.2-1.3v-1l-.5-.8c-.2-.3-.4-.5-.7-.6L8.7 10H6.3v5.2h2.4Zm-.4-1.1H8v-3h.4c.5 0 .8.2 1 .4l.2 1.1-.1 1-.3.3-.8.2Zm5.3 1.2V13h2v-1h-2v-1H16V10h-4v5.2h1.6Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M15 17a1 1 0 1 0-2 0v3.1l-1.4-1a1 1 0 1 0-1.2 1.7l3.6 2.4 3.6-2.4a1 1 0 0 0-1.2-1.6l-1.4 1V17Z"/></svg>',
    "export-word": '<svg width="24" height="24"><path d="M9.5 7A1.5 1.5 0 0 1 11 8.4v7.1A1.5 1.5 0 0 1 9.6 17H2.5A1.5 1.5 0 0 1 1 15.6V8.5A1.5 1.5 0 0 1 2.4 7h7.1Zm-1 2.8-1 2.6-1-2.5v-.1a.6.6 0 0 0-1 0l-.1.1-.9 2.5-1-2.5v-.1a.6.6 0 0 0-1 .4v.1l1.5 4v.1a.6.6 0 0 0 1 0v-.1l1-2.5.9 2.5v.1a.6.6 0 0 0 1 0H8l1.6-4v-.2a.6.6 0 0 0-1.1-.4Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M7 3h7.4L19 7.6V17h-2V9h-4V5H5c0-1.1.9-2 2-2ZM15 17a1 1 0 1 0-2 0v3.1l-1.4-1a1 1 0 1 0-1.2 1.7l3.6 2.4 3.6-2.4a1 1 0 0 0-1.2-1.6l-1.4 1V17Z"/></svg>',
    "import-word": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 3h7.4L19 7.6V15h-2V9h-4V5H5c0-1.1.9-2 2-2Z"/><path d="M9.5 7A1.5 1.5 0 0 1 11 8.4v7.1A1.5 1.5 0 0 1 9.6 17H2.5A1.5 1.5 0 0 1 1 15.6V8.5A1.5 1.5 0 0 1 2.4 7h7.1Zm-1 2.8-1 2.6-1-2.5v-.1a.6.6 0 0 0-1 0l-.1.1-.9 2.5-1-2.5v-.1a.6.6 0 0 0-1 .4v.1l1.5 4v.1a.6.6 0 0 0 1 0v-.1l1-2.5.9 2.5v.1a.6.6 0 0 0 1 0H8l1.6-4v-.2a.6.6 0 0 0-1.1-.4Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M11.4 18.2a1 1 0 0 0 1.2 1.6l1.4-1V22a1 1 0 1 0 2 0v-3.1l1.4 1a1 1 0 0 0 1.2-1.7L15 15.8l-3.6 2.4Z"/></svg>'
  }
});
tinymce.Resource.add("ui/default/skin.css", `.tox{box-shadow:none;box-sizing:content-box;color:#222f3e;cursor:auto;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:16px;font-style:normal;font-weight:400;line-height:normal;-webkit-tap-highlight-color:transparent;text-decoration:none;text-shadow:none;text-transform:none;vertical-align:initial;white-space:normal}.tox :not(svg):not(rect){box-sizing:inherit;color:inherit;cursor:inherit;direction:inherit;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;line-height:inherit;-webkit-tap-highlight-color:inherit;text-align:inherit;text-decoration:inherit;text-shadow:inherit;text-transform:inherit;vertical-align:inherit;white-space:inherit}.tox :not(svg):not(rect){background:0 0;border:0;box-shadow:none;float:none;height:auto;margin:0;max-width:none;outline:0;padding:0;position:static;width:auto}.tox:not([dir=rtl]){direction:ltr;text-align:left}.tox[dir=rtl]{direction:rtl;text-align:right}.tox-tinymce{border:2px solid #eee;border-radius:10px;box-shadow:none;box-sizing:border-box;display:flex;flex-direction:column;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;overflow:hidden;position:relative;visibility:inherit!important}.tox.tox-tinymce-inline{border:none;box-shadow:none;overflow:initial}.tox.tox-tinymce-inline .tox-editor-container{overflow:initial}.tox.tox-tinymce-inline .tox-editor-header{background-color:#fff;border:2px solid #eee;border-radius:10px;box-shadow:none;overflow:hidden}.tox-tinymce-aux{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;z-index:1300}.tox-tinymce :focus,.tox-tinymce-aux :focus{outline:0}button::-moz-focus-inner{border:0}.tox[dir=rtl] .tox-icon--flip svg{transform:rotateY(180deg)}.tox .accessibility-issue__header{align-items:center;display:flex;margin-bottom:4px}.tox .accessibility-issue__description{align-items:stretch;border-radius:6px;display:flex;justify-content:space-between}.tox .accessibility-issue__description>div{padding-bottom:4px}.tox .accessibility-issue__description>div>div{align-items:center;display:flex;margin-bottom:4px}.tox .accessibility-issue__description>div>div .tox-icon svg{display:block}.tox .accessibility-issue__repair{margin-top:16px}.tox .tox-dialog__body-content .accessibility-issue--info .accessibility-issue__description{background-color:rgba(0,101,216,.1);color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--info .tox-form__group h2{color:#006ce7}.tox .tox-dialog__body-content .accessibility-issue--info .tox-icon svg{fill:#006ce7}.tox .tox-dialog__body-content .accessibility-issue--info a.tox-button--naked.tox-button--icon{background-color:#006ce7;color:#fff}.tox .tox-dialog__body-content .accessibility-issue--info a.tox-button--naked.tox-button--icon:focus,.tox .tox-dialog__body-content .accessibility-issue--info a.tox-button--naked.tox-button--icon:hover{background-color:#0060ce}.tox .tox-dialog__body-content .accessibility-issue--info a.tox-button--naked.tox-button--icon:active{background-color:#0054b4}.tox .tox-dialog__body-content .accessibility-issue--warn .accessibility-issue__description{background-color:rgba(255,165,0,.08);color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--warn .tox-form__group h2{color:#8f5d00}.tox .tox-dialog__body-content .accessibility-issue--warn .tox-icon svg{fill:#8f5d00}.tox .tox-dialog__body-content .accessibility-issue--warn a.tox-button--naked.tox-button--icon{background-color:#ffe89d;color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--warn a.tox-button--naked.tox-button--icon:focus,.tox .tox-dialog__body-content .accessibility-issue--warn a.tox-button--naked.tox-button--icon:hover{background-color:#f2d574;color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--warn a.tox-button--naked.tox-button--icon:active{background-color:#e8c657;color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--error .accessibility-issue__description{background-color:rgba(204,0,0,.1);color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--error .tox-form__group h2{color:#c00}.tox .tox-dialog__body-content .accessibility-issue--error .tox-icon svg{fill:#c00}.tox .tox-dialog__body-content .accessibility-issue--error a.tox-button--naked.tox-button--icon{background-color:#f2bfbf;color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--error a.tox-button--naked.tox-button--icon:focus,.tox .tox-dialog__body-content .accessibility-issue--error a.tox-button--naked.tox-button--icon:hover{background-color:#e9a4a4;color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--error a.tox-button--naked.tox-button--icon:active{background-color:#ee9494;color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--success .accessibility-issue__description{background-color:rgba(120,171,70,.1);color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--success .accessibility-issue__description>:last-child{display:none}.tox .tox-dialog__body-content .accessibility-issue--success .tox-form__group h2{color:#527530}.tox .tox-dialog__body-content .accessibility-issue--success .tox-icon svg{fill:#527530}.tox .tox-dialog__body-content .accessibility-issue__header .tox-form__group h1,.tox .tox-dialog__body-content .tox-form__group .accessibility-issue__description h2{font-size:14px;margin-top:0}.tox:not([dir=rtl]) .tox-dialog__body-content .accessibility-issue__header .tox-button{margin-left:4px}.tox:not([dir=rtl]) .tox-dialog__body-content .accessibility-issue__header>:nth-last-child(2){margin-left:auto}.tox:not([dir=rtl]) .tox-dialog__body-content .accessibility-issue__description{padding:4px 4px 4px 8px}.tox[dir=rtl] .tox-dialog__body-content .accessibility-issue__header .tox-button{margin-right:4px}.tox[dir=rtl] .tox-dialog__body-content .accessibility-issue__header>:nth-last-child(2){margin-right:auto}.tox[dir=rtl] .tox-dialog__body-content .accessibility-issue__description{padding:4px 8px 4px 4px}.tox .mce-codemirror{background:#fff;bottom:0;font-size:13px;left:0;position:absolute;right:0;top:0;z-index:1}.tox .mce-codemirror.tox-inline-codemirror{margin:8px;position:absolute}.tox .tox-advtemplate .tox-form__grid{flex:1}.tox .tox-advtemplate .tox-form__grid>div:first-child{display:flex;flex-direction:column;width:30%}.tox .tox-advtemplate .tox-form__grid>div:first-child>div:nth-child(2){flex-basis:0;flex-grow:1;overflow:auto}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox .tox-advtemplate .tox-form__grid>div:first-child{width:100%}}.tox .tox-advtemplate iframe{border-color:#eee;border-radius:10px;border-style:solid;border-width:1px;margin:0 10px}.tox .tox-anchorbar{display:flex;flex:0 0 auto}.tox .tox-bottom-anchorbar{display:flex;flex:0 0 auto}.tox .tox-bar{display:flex;flex:0 0 auto}.tox .tox-button{background-color:#006ce7;background-image:none;background-position:0 0;background-repeat:repeat;border-color:#006ce7;border-radius:6px;border-style:solid;border-width:1px;box-shadow:none;box-sizing:border-box;color:#fff;cursor:pointer;display:inline-block;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:14px;font-style:normal;font-weight:700;letter-spacing:normal;line-height:24px;margin:0;outline:0;padding:4px 16px;position:relative;text-align:center;text-decoration:none;text-transform:none;white-space:nowrap}.tox .tox-button::before{border-radius:6px;bottom:-1px;box-shadow:inset 0 0 0 1px #fff,0 0 0 2px #006ce7;content:'';left:-1px;opacity:0;pointer-events:none;position:absolute;right:-1px;top:-1px}.tox .tox-button[disabled]{background-color:#006ce7;background-image:none;border-color:#006ce7;box-shadow:none;color:rgba(255,255,255,.5);cursor:not-allowed}.tox .tox-button:focus:not(:disabled){background-color:#0060ce;background-image:none;border-color:#0060ce;box-shadow:none;color:#fff}.tox .tox-button:focus:not(:disabled)::before{opacity:1}.tox .tox-button:hover:not(:disabled){background-color:#0060ce;background-image:none;border-color:#0060ce;box-shadow:none;color:#fff}.tox .tox-button:active:not(:disabled){background-color:#0054b4;background-image:none;border-color:#0054b4;box-shadow:none;color:#fff}.tox .tox-button.tox-button--enabled{background-color:#0054b4;background-image:none;border-color:#0054b4;box-shadow:none;color:#fff}.tox .tox-button.tox-button--enabled[disabled]{background-color:#0054b4;background-image:none;border-color:#0054b4;box-shadow:none;color:rgba(255,255,255,.5);cursor:not-allowed}.tox .tox-button.tox-button--enabled:focus:not(:disabled){background-color:#00489b;background-image:none;border-color:#00489b;box-shadow:none;color:#fff}.tox .tox-button.tox-button--enabled:hover:not(:disabled){background-color:#00489b;background-image:none;border-color:#00489b;box-shadow:none;color:#fff}.tox .tox-button.tox-button--enabled:active:not(:disabled){background-color:#003c81;background-image:none;border-color:#003c81;box-shadow:none;color:#fff}.tox .tox-button--icon-and-text,.tox .tox-button.tox-button--icon-and-text,.tox .tox-button.tox-button--secondary.tox-button--icon-and-text{display:flex;padding:5px 4px}.tox .tox-button--icon-and-text .tox-icon svg,.tox .tox-button.tox-button--icon-and-text .tox-icon svg,.tox .tox-button.tox-button--secondary.tox-button--icon-and-text .tox-icon svg{display:block;fill:currentColor}.tox .tox-button--secondary{background-color:#f0f0f0;background-image:none;background-position:0 0;background-repeat:repeat;border-color:#f0f0f0;border-radius:6px;border-style:solid;border-width:1px;box-shadow:none;color:#222f3e;font-size:14px;font-style:normal;font-weight:700;letter-spacing:normal;outline:0;padding:4px 16px;text-decoration:none;text-transform:none}.tox .tox-button--secondary[disabled]{background-color:#f0f0f0;background-image:none;border-color:#f0f0f0;box-shadow:none;color:rgba(34,47,62,.5)}.tox .tox-button--secondary:focus:not(:disabled){background-color:#e3e3e3;background-image:none;border-color:#e3e3e3;box-shadow:none;color:#222f3e}.tox .tox-button--secondary:hover:not(:disabled){background-color:#e3e3e3;background-image:none;border-color:#e3e3e3;box-shadow:none;color:#222f3e}.tox .tox-button--secondary:active:not(:disabled){background-color:#d6d6d6;background-image:none;border-color:#d6d6d6;box-shadow:none;color:#222f3e}.tox .tox-button--secondary.tox-button--enabled{background-color:#a8c8ed;background-image:none;border-color:#a8c8ed;box-shadow:none;color:#222f3e}.tox .tox-button--secondary.tox-button--enabled[disabled]{background-color:#a8c8ed;background-image:none;border-color:#a8c8ed;box-shadow:none;color:rgba(34,47,62,.5)}.tox .tox-button--secondary.tox-button--enabled:focus:not(:disabled){background-color:#93bbe9;background-image:none;border-color:#93bbe9;box-shadow:none;color:#222f3e}.tox .tox-button--secondary.tox-button--enabled:hover:not(:disabled){background-color:#93bbe9;background-image:none;border-color:#93bbe9;box-shadow:none;color:#222f3e}.tox .tox-button--secondary.tox-button--enabled:active:not(:disabled){background-color:#7daee4;background-image:none;border-color:#7daee4;box-shadow:none;color:#222f3e}.tox .tox-button--icon,.tox .tox-button.tox-button--icon,.tox .tox-button.tox-button--secondary.tox-button--icon{padding:4px}.tox .tox-button--icon .tox-icon svg,.tox .tox-button.tox-button--icon .tox-icon svg,.tox .tox-button.tox-button--secondary.tox-button--icon .tox-icon svg{display:block;fill:currentColor}.tox .tox-button-link{background:0;border:none;box-sizing:border-box;cursor:pointer;display:inline-block;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:16px;font-weight:400;line-height:1.3;margin:0;padding:0;white-space:nowrap}.tox .tox-button-link--sm{font-size:14px}.tox .tox-button--naked{background-color:transparent;border-color:transparent;box-shadow:unset;color:#222f3e}.tox .tox-button--naked[disabled]{background-color:rgba(34,47,62,.12);border-color:transparent;box-shadow:unset;color:rgba(34,47,62,.5)}.tox .tox-button--naked:hover:not(:disabled){background-color:rgba(34,47,62,.12);border-color:transparent;box-shadow:unset;color:#222f3e}.tox .tox-button--naked:focus:not(:disabled){background-color:rgba(34,47,62,.12);border-color:transparent;box-shadow:unset;color:#222f3e}.tox .tox-button--naked:active:not(:disabled){background-color:rgba(34,47,62,.18);border-color:transparent;box-shadow:unset;color:#222f3e}.tox .tox-button--naked .tox-icon svg{fill:currentColor}.tox .tox-button--naked.tox-button--icon:hover:not(:disabled){color:#222f3e}.tox .tox-checkbox{align-items:center;border-radius:6px;cursor:pointer;display:flex;height:36px;min-width:36px}.tox .tox-checkbox__input{height:1px;overflow:hidden;position:absolute;top:auto;width:1px}.tox .tox-checkbox__icons{align-items:center;border-radius:6px;box-shadow:0 0 0 2px transparent;box-sizing:content-box;display:flex;height:24px;justify-content:center;padding:calc(4px - 1px);width:24px}.tox .tox-checkbox__icons .tox-checkbox-icon__unchecked svg{display:block;fill:rgba(34,47,62,.3)}@media (forced-colors:active){.tox .tox-checkbox__icons .tox-checkbox-icon__unchecked svg{fill:currentColor!important}}.tox .tox-checkbox__icons .tox-checkbox-icon__indeterminate svg{display:none;fill:#006ce7}.tox .tox-checkbox__icons .tox-checkbox-icon__checked svg{display:none;fill:#006ce7}.tox .tox-checkbox--disabled{color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-checkbox--disabled .tox-checkbox__icons .tox-checkbox-icon__checked svg{fill:rgba(34,47,62,.5)}.tox .tox-checkbox--disabled .tox-checkbox__icons .tox-checkbox-icon__unchecked svg{fill:rgba(34,47,62,.5)}.tox .tox-checkbox--disabled .tox-checkbox__icons .tox-checkbox-icon__indeterminate svg{fill:rgba(34,47,62,.5)}.tox input.tox-checkbox__input:checked+.tox-checkbox__icons .tox-checkbox-icon__unchecked svg{display:none}.tox input.tox-checkbox__input:checked+.tox-checkbox__icons .tox-checkbox-icon__checked svg{display:block}.tox input.tox-checkbox__input:indeterminate+.tox-checkbox__icons .tox-checkbox-icon__unchecked svg{display:none}.tox input.tox-checkbox__input:indeterminate+.tox-checkbox__icons .tox-checkbox-icon__indeterminate svg{display:block}.tox input.tox-checkbox__input:focus+.tox-checkbox__icons{border-radius:6px;box-shadow:inset 0 0 0 1px #006ce7;padding:calc(4px - 1px)}.tox:not([dir=rtl]) .tox-checkbox__label{margin-left:4px}.tox:not([dir=rtl]) .tox-checkbox__input{left:-10000px}.tox:not([dir=rtl]) .tox-bar .tox-checkbox{margin-left:4px}.tox[dir=rtl] .tox-checkbox__label{margin-right:4px}.tox[dir=rtl] .tox-checkbox__input{right:-10000px}.tox[dir=rtl] .tox-bar .tox-checkbox{margin-right:4px}.tox .tox-collection--toolbar .tox-collection__group{display:flex;padding:0}.tox .tox-collection--grid .tox-collection__group{display:flex;flex-wrap:wrap;max-height:208px;overflow-x:hidden;overflow-y:auto;padding:0}.tox .tox-collection--list .tox-collection__group{border-bottom-width:0;border-color:#e3e3e3;border-left-width:0;border-right-width:0;border-style:solid;border-top-width:1px;padding:4px 0}.tox .tox-collection--list .tox-collection__group:first-child{border-top-width:0}.tox .tox-collection__group-heading{background-color:#fcfcfc;color:rgba(34,47,62,.7);cursor:default;font-size:12px;font-style:normal;font-weight:400;margin-bottom:4px;margin-top:-4px;padding:4px 8px;text-transform:none;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.tox .tox-collection__item{align-items:center;border-radius:3px;color:#222f3e;display:flex;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.tox .tox-collection--list .tox-collection__item{padding:4px 8px}.tox .tox-collection--toolbar .tox-collection__item{border-radius:3px;padding:4px}.tox .tox-collection--grid .tox-collection__item{border-radius:3px;padding:4px}.tox .tox-collection--list .tox-collection__item--enabled{background-color:#fff;color:#222f3e}.tox .tox-collection--list .tox-collection__item--active{background-color:#006ce7}.tox .tox-collection--toolbar .tox-collection__item--enabled,.tox .tox-collection--toolbar .tox-collection__item--enabled.tox-collection__item--active,.tox .tox-collection--toolbar .tox-collection__item--enabled.tox-collection__item--active:hover{background-color:#a6ccf7;color:#222f3e}@media (forced-colors:active){.tox .tox-collection--toolbar .tox-collection__item--enabled,.tox .tox-collection--toolbar .tox-collection__item--enabled.tox-collection__item--active,.tox .tox-collection--toolbar .tox-collection__item--enabled.tox-collection__item--active:hover{border-radius:3px;outline:solid 1px}}.tox .tox-collection--toolbar .tox-collection__item--active{background-color:#fff;position:relative}.tox .tox-collection--toolbar .tox-collection__item--active:hover{background-color:#f0f0f0;color:#222f3e}.tox .tox-collection--toolbar .tox-collection__item--active:focus{background-color:#f0f0f0;color:#222f3e}.tox .tox-collection--toolbar .tox-collection__item--active:focus::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-collection--toolbar .tox-collection__item--active:focus::after{border:2px solid highlight}}.tox .tox-collection--grid .tox-collection__item--enabled{background-color:#a6ccf7;color:#222f3e}.tox .tox-collection--grid .tox-collection__item--active:not(.tox-collection__item--state-disabled){background-color:#f0f0f0;color:#222f3e;position:relative;z-index:1}.tox .tox-collection--grid .tox-collection__item--active:not(.tox-collection__item--state-disabled):focus::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7 inset;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-collection--grid .tox-collection__item--active:not(.tox-collection__item--state-disabled):focus::after{border:2px solid highlight}}.tox .tox-collection--list .tox-collection__item--active:not(.tox-collection__item--state-disabled){color:#fff}@media (forced-colors:active){.tox .tox-collection--list .tox-collection__item--active:not(.tox-collection__item--state-disabled){border:solid 1px}}.tox .tox-collection--toolbar .tox-collection__item--active:not(.tox-collection__item--state-disabled){color:#222f3e}@media (forced-colors:active){.tox .tox-collection--toolbar .tox-collection__item--active:not(.tox-collection__item--state-disabled):hover{border-radius:3px;outline:solid 1px}}.tox .tox-collection__item-checkmark,.tox .tox-collection__item-icon{align-items:center;display:flex;height:24px;justify-content:center;width:24px}.tox .tox-collection__item-checkmark svg,.tox .tox-collection__item-icon svg{fill:currentColor}.tox .tox-collection--toolbar-lg .tox-collection__item-icon{height:48px;width:48px}.tox .tox-collection__item-label{color:currentColor;display:inline-block;flex:1;font-size:14px;font-style:normal;font-weight:400;line-height:24px;max-width:100%;text-transform:none;word-break:break-all}.tox .tox-collection__item-accessory{color:currentColor;display:inline-block;font-size:14px;height:24px;line-height:24px;text-transform:none}.tox .tox-collection__item-caret{align-items:center;display:flex;min-height:24px}.tox .tox-collection__item-caret::after{content:'';font-size:0;min-height:inherit}.tox .tox-collection__item-caret svg{fill:currentColor}.tox .tox-collection__item--state-disabled{background-color:transparent;color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-collection__item--state-disabled .tox-collection__item-caret svg{fill:rgba(34,47,62,.5)}.tox .tox-collection--list .tox-collection__item:not(.tox-collection__item--enabled) .tox-collection__item-checkmark svg{display:none}.tox .tox-collection--list .tox-collection__item:not(.tox-collection__item--enabled) .tox-collection__item-accessory+.tox-collection__item-checkmark{display:none}.tox .tox-collection--horizontal{background-color:#fff;border:1px solid #e3e3e3;border-radius:6px;box-shadow:0 0 2px 0 rgba(34,47,62,.2),0 4px 8px 0 rgba(34,47,62,.15);display:flex;flex:0 0 auto;flex-shrink:0;flex-wrap:nowrap;margin-bottom:0;overflow-x:auto;padding:0}.tox .tox-collection--horizontal .tox-collection__group{align-items:center;display:flex;flex-wrap:nowrap;margin:0;padding:0 4px}.tox .tox-collection--horizontal .tox-collection__item{height:28px;margin:6px 1px 5px 0;padding:0 4px}.tox .tox-collection--horizontal .tox-collection__item-label{white-space:nowrap}.tox .tox-collection--horizontal .tox-collection__item-caret{margin-left:4px}.tox .tox-collection__item-container{display:flex}.tox .tox-collection__item-container--row{align-items:center;flex:1 1 auto;flex-direction:row}.tox .tox-collection__item-container--row.tox-collection__item-container--align-left{margin-right:auto}.tox .tox-collection__item-container--row.tox-collection__item-container--align-right{justify-content:flex-end;margin-left:auto}.tox .tox-collection__item-container--row.tox-collection__item-container--valign-top{align-items:flex-start;margin-bottom:auto}.tox .tox-collection__item-container--row.tox-collection__item-container--valign-middle{align-items:center}.tox .tox-collection__item-container--row.tox-collection__item-container--valign-bottom{align-items:flex-end;margin-top:auto}.tox .tox-collection__item-container--column{align-self:center;flex:1 1 auto;flex-direction:column}.tox .tox-collection__item-container--column.tox-collection__item-container--align-left{align-items:flex-start}.tox .tox-collection__item-container--column.tox-collection__item-container--align-right{align-items:flex-end}.tox .tox-collection__item-container--column.tox-collection__item-container--valign-top{align-self:flex-start}.tox .tox-collection__item-container--column.tox-collection__item-container--valign-middle{align-self:center}.tox .tox-collection__item-container--column.tox-collection__item-container--valign-bottom{align-self:flex-end}.tox:not([dir=rtl]) .tox-collection--horizontal .tox-collection__group:not(:last-of-type){border-right:1px solid transparent}.tox:not([dir=rtl]) .tox-collection--list .tox-collection__item>:not(:first-child){margin-left:8px}.tox:not([dir=rtl]) .tox-collection--list .tox-collection__item>.tox-collection__item-label:first-child{margin-left:4px}.tox:not([dir=rtl]) .tox-collection__item-accessory{margin-left:16px;text-align:right}.tox:not([dir=rtl]) .tox-collection .tox-collection__item-caret{margin-left:16px}.tox[dir=rtl] .tox-collection--horizontal .tox-collection__group:not(:last-of-type){border-left:1px solid transparent}.tox[dir=rtl] .tox-collection--list .tox-collection__item>:not(:first-child){margin-right:8px}.tox[dir=rtl] .tox-collection--list .tox-collection__item>.tox-collection__item-label:first-child{margin-right:4px}.tox[dir=rtl] .tox-collection__item-accessory{margin-right:16px;text-align:left}.tox[dir=rtl] .tox-collection .tox-collection__item-caret{margin-right:16px;transform:rotateY(180deg)}.tox[dir=rtl] .tox-collection--horizontal .tox-collection__item-caret{margin-right:4px}@media (forced-colors:active){.tox .tox-hue-slider,.tox .tox-rgb-form .tox-rgba-preview{background-color:currentColor!important;border:1px solid highlight!important;forced-color-adjust:none}}.tox .tox-color-picker-container{display:flex;flex-direction:row;height:225px;margin:0}.tox .tox-sv-palette{box-sizing:border-box;display:flex;height:100%}.tox .tox-sv-palette-spectrum{height:100%}.tox .tox-sv-palette,.tox .tox-sv-palette-spectrum{width:225px}.tox .tox-sv-palette-thumb{background:0 0;border:1px solid #000;border-radius:50%;box-sizing:content-box;height:12px;position:absolute;width:12px}.tox .tox-sv-palette-inner-thumb{border:1px solid #fff;border-radius:50%;height:10px;position:absolute;width:10px}.tox .tox-hue-slider{box-sizing:border-box;height:100%;width:25px}.tox .tox-hue-slider-spectrum{background:linear-gradient(to bottom,red,#ff0080,#f0f,#8000ff,#00f,#0080ff,#0ff,#00ff80,#0f0,#80ff00,#ff0,#ff8000,red);height:100%;width:100%}.tox .tox-hue-slider,.tox .tox-hue-slider-spectrum{width:20px}.tox .tox-hue-slider-spectrum:focus,.tox .tox-sv-palette-spectrum:focus{outline:#08f solid}.tox .tox-hue-slider-thumb{background:#fff;border:1px solid #000;box-sizing:content-box;height:4px;width:100%}.tox .tox-rgb-form{display:flex;flex-direction:column;justify-content:space-between}.tox .tox-rgb-form div{align-items:center;display:flex;justify-content:space-between;margin-bottom:5px;width:inherit}.tox .tox-rgb-form input{width:6em}.tox .tox-rgb-form input.tox-invalid{border:1px solid red!important}.tox .tox-rgb-form .tox-rgba-preview{border:1px solid #000;flex-grow:2;margin-bottom:0}.tox:not([dir=rtl]) .tox-sv-palette{margin-right:15px}.tox:not([dir=rtl]) .tox-hue-slider{margin-right:15px}.tox:not([dir=rtl]) .tox-hue-slider-thumb{margin-left:-1px}.tox:not([dir=rtl]) .tox-rgb-form label{margin-right:.5em}.tox[dir=rtl] .tox-sv-palette{margin-left:15px}.tox[dir=rtl] .tox-hue-slider{margin-left:15px}.tox[dir=rtl] .tox-hue-slider-thumb{margin-right:-1px}.tox[dir=rtl] .tox-rgb-form label{margin-left:.5em}.tox .tox-toolbar .tox-swatches,.tox .tox-toolbar__overflow .tox-swatches,.tox .tox-toolbar__primary .tox-swatches{margin:5px 0 6px 11px}.tox .tox-collection--list .tox-collection__group .tox-swatches-menu{border:0;margin:-4px -4px}.tox .tox-swatches__row{display:flex}@media (forced-colors:active){.tox .tox-swatches__row{forced-color-adjust:none}}.tox .tox-swatch{height:30px;transition:transform .15s,box-shadow .15s;width:30px}.tox .tox-swatch:focus,.tox .tox-swatch:hover{box-shadow:0 0 0 1px rgba(127,127,127,.3) inset;transform:scale(.8)}.tox .tox-swatch--remove{align-items:center;display:flex;justify-content:center}.tox .tox-swatch--remove svg path{stroke:#e74c3c}.tox .tox-swatches__picker-btn{align-items:center;background-color:transparent;border:0;cursor:pointer;display:flex;height:30px;justify-content:center;outline:0;padding:0;width:30px}.tox .tox-swatches__picker-btn svg{fill:#222f3e;height:24px;width:24px}.tox .tox-swatches__picker-btn:hover{background:#f0f0f0}.tox div.tox-swatch:not(.tox-swatch--remove) svg{display:none;fill:#222f3e;height:24px;margin:calc((30px - 24px)/ 2) calc((30px - 24px)/ 2);width:24px}.tox div.tox-swatch:not(.tox-swatch--remove) svg path{fill:#fff;paint-order:stroke;stroke:#222f3e;stroke-width:2px}.tox div.tox-swatch:not(.tox-swatch--remove).tox-collection__item--enabled svg{display:block}.tox:not([dir=rtl]) .tox-swatches__picker-btn{margin-left:auto}.tox[dir=rtl] .tox-swatches__picker-btn{margin-right:auto}.tox .tox-comment-thread{background:#fff;position:relative}.tox .tox-comment-thread>:not(:first-child){margin-top:8px}.tox .tox-comment{background:#fff;border:1px solid #eee;border-radius:6px;box-shadow:0 4px 8px 0 rgba(34,47,62,.1);padding:8px 8px 16px 8px;position:relative}.tox .tox-comment__header{align-items:center;color:#222f3e;display:flex;justify-content:space-between}.tox .tox-comment__date{color:#222f3e;font-size:12px;line-height:18px}.tox .tox-comment__body{color:#222f3e;font-size:14px;font-style:normal;font-weight:400;line-height:1.3;margin-top:8px;position:relative;text-transform:initial}.tox .tox-comment__body textarea{resize:none;white-space:normal;width:100%}.tox .tox-comment__expander{padding-top:8px}.tox .tox-comment__expander p{color:rgba(34,47,62,.7);font-size:14px;font-style:normal}.tox .tox-comment__body p{margin:0}.tox .tox-comment__buttonspacing{padding-top:16px;text-align:center}.tox .tox-comment-thread__overlay::after{background:#fff;bottom:0;content:"";display:flex;left:0;opacity:.9;position:absolute;right:0;top:0;z-index:5}.tox .tox-comment__reply{display:flex;flex-shrink:0;flex-wrap:wrap;justify-content:flex-end;margin-top:8px}.tox .tox-comment__reply>:first-child{margin-bottom:8px;width:100%}.tox .tox-comment__edit{display:flex;flex-wrap:wrap;justify-content:flex-end;margin-top:16px}.tox .tox-comment__gradient::after{background:linear-gradient(rgba(255,255,255,0),#fff);bottom:0;content:"";display:block;height:5em;margin-top:-40px;position:absolute;width:100%}.tox .tox-comment__overlay{background:#fff;bottom:0;display:flex;flex-direction:column;flex-grow:1;left:0;opacity:.9;position:absolute;right:0;text-align:center;top:0;z-index:5}.tox .tox-comment__loading-text{align-items:center;color:#222f3e;display:flex;flex-direction:column;position:relative}.tox .tox-comment__loading-text>div{padding-bottom:16px}.tox .tox-comment__overlaytext{bottom:0;flex-direction:column;font-size:14px;left:0;padding:1em;position:absolute;right:0;top:0;z-index:10}.tox .tox-comment__overlaytext p{background-color:#fff;box-shadow:0 0 8px 8px #fff;color:#222f3e;text-align:center}.tox .tox-comment__overlaytext div:nth-of-type(2){font-size:.8em}.tox .tox-comment__busy-spinner{align-items:center;background-color:#fff;bottom:0;display:flex;justify-content:center;left:0;position:absolute;right:0;top:0;z-index:20}.tox .tox-comment__scroll{display:flex;flex-direction:column;flex-shrink:1;overflow:auto}.tox .tox-conversations{margin:8px}.tox:not([dir=rtl]) .tox-comment__edit{margin-left:8px}.tox:not([dir=rtl]) .tox-comment__buttonspacing>:last-child,.tox:not([dir=rtl]) .tox-comment__edit>:last-child,.tox:not([dir=rtl]) .tox-comment__reply>:last-child{margin-left:8px}.tox[dir=rtl] .tox-comment__edit{margin-right:8px}.tox[dir=rtl] .tox-comment__buttonspacing>:last-child,.tox[dir=rtl] .tox-comment__edit>:last-child,.tox[dir=rtl] .tox-comment__reply>:last-child{margin-right:8px}.tox .tox-user{align-items:center;display:flex}.tox .tox-user__avatar svg{fill:rgba(34,47,62,.7)}.tox .tox-user__avatar img{border-radius:50%;height:36px;object-fit:cover;vertical-align:middle;width:36px}.tox .tox-user__name{color:#222f3e;font-size:14px;font-style:normal;font-weight:700;line-height:18px;text-transform:none}.tox:not([dir=rtl]) .tox-user__avatar img,.tox:not([dir=rtl]) .tox-user__avatar svg{margin-right:8px}.tox:not([dir=rtl]) .tox-user__avatar+.tox-user__name{margin-left:8px}.tox[dir=rtl] .tox-user__avatar img,.tox[dir=rtl] .tox-user__avatar svg{margin-left:8px}.tox[dir=rtl] .tox-user__avatar+.tox-user__name{margin-right:8px}.tox .tox-dialog-wrap{align-items:center;bottom:0;display:flex;justify-content:center;left:0;position:fixed;right:0;top:0;z-index:1100}.tox .tox-dialog-wrap__backdrop{background-color:rgba(255,255,255,.75);bottom:0;left:0;position:absolute;right:0;top:0;z-index:1}.tox .tox-dialog-wrap__backdrop--opaque{background-color:#fff}.tox .tox-dialog{background-color:#fff;border-color:#eee;border-radius:10px;border-style:solid;border-width:0;box-shadow:0 16px 16px -10px rgba(34,47,62,.15),0 0 40px 1px rgba(34,47,62,.15);display:flex;flex-direction:column;max-height:100%;max-width:480px;overflow:hidden;position:relative;width:95vw;z-index:2}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox .tox-dialog{align-self:flex-start;margin:8px auto;max-height:calc(100vh - 8px * 2);width:calc(100vw - 16px)}}.tox .tox-dialog-inline{z-index:1100}.tox .tox-dialog__header{align-items:center;background-color:#fff;border-bottom:none;color:#222f3e;display:flex;font-size:16px;justify-content:space-between;padding:8px 16px 0 16px;position:relative}.tox .tox-dialog__header .tox-button{z-index:1}.tox .tox-dialog__draghandle{cursor:grab;height:100%;left:0;position:absolute;top:0;width:100%}.tox .tox-dialog__draghandle:active{cursor:grabbing}.tox .tox-dialog__dismiss{margin-left:auto}.tox .tox-dialog__title{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:20px;font-style:normal;font-weight:400;line-height:1.3;margin:0;text-transform:none}.tox .tox-dialog__body{color:#222f3e;display:flex;flex:1;font-size:16px;font-style:normal;font-weight:400;line-height:1.3;min-width:0;text-align:left;text-transform:none}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox .tox-dialog__body{flex-direction:column}}.tox .tox-dialog__body-nav{align-items:flex-start;display:flex;flex-direction:column;flex-shrink:0;padding:16px 16px}@media only screen and (min-width:768px){.tox .tox-dialog__body-nav{max-width:11em}}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox .tox-dialog__body-nav{flex-direction:row;-webkit-overflow-scrolling:touch;overflow-x:auto;padding-bottom:0}}.tox .tox-dialog__body-nav-item{border-bottom:2px solid transparent;color:rgba(34,47,62,.7);display:inline-block;flex-shrink:0;font-size:14px;line-height:1.3;margin-bottom:8px;max-width:13em;text-decoration:none}.tox .tox-dialog__body-nav-item:focus{background-color:rgba(0,108,231,.1)}.tox .tox-dialog__body-nav-item--active{border-bottom:2px solid #006ce7;color:#006ce7}@media (forced-colors:active){.tox .tox-dialog__body-nav-item--active{border-bottom:2px solid highlight;color:highlight}}.tox .tox-dialog__body-content{box-sizing:border-box;display:flex;flex:1;flex-direction:column;max-height:min(650px,calc(100vh - 110px));overflow:auto;-webkit-overflow-scrolling:touch;padding:16px 16px}.tox .tox-dialog__body-content>*{margin-bottom:0;margin-top:16px}.tox .tox-dialog__body-content>:first-child{margin-top:0}.tox .tox-dialog__body-content>:last-child{margin-bottom:0}.tox .tox-dialog__body-content>:only-child{margin-bottom:0;margin-top:0}.tox .tox-dialog__body-content a{color:#006ce7;cursor:pointer;text-decoration:underline}.tox .tox-dialog__body-content a:focus,.tox .tox-dialog__body-content a:hover{color:#003c81;text-decoration:underline}.tox .tox-dialog__body-content a:focus-visible{border-radius:1px;outline:2px solid #006ce7;outline-offset:2px}.tox .tox-dialog__body-content a:active{color:#00244e;text-decoration:underline}.tox .tox-dialog__body-content svg{fill:#222f3e}.tox .tox-dialog__body-content strong{font-weight:700}.tox .tox-dialog__body-content ul{list-style-type:disc}.tox .tox-dialog__body-content dd,.tox .tox-dialog__body-content ol,.tox .tox-dialog__body-content ul{padding-inline-start:2.5rem}.tox .tox-dialog__body-content dl,.tox .tox-dialog__body-content ol,.tox .tox-dialog__body-content ul{margin-bottom:16px}.tox .tox-dialog__body-content dd,.tox .tox-dialog__body-content dl,.tox .tox-dialog__body-content dt,.tox .tox-dialog__body-content ol,.tox .tox-dialog__body-content ul{display:block;margin-inline-end:0;margin-inline-start:0}.tox .tox-dialog__body-content .tox-form__group h1{color:#222f3e;font-size:20px;font-style:normal;font-weight:700;letter-spacing:normal;margin-bottom:16px;margin-top:2rem;text-transform:none}.tox .tox-dialog__body-content .tox-form__group h2{color:#222f3e;font-size:16px;font-style:normal;font-weight:700;letter-spacing:normal;margin-bottom:16px;margin-top:2rem;text-transform:none}.tox .tox-dialog__body-content .tox-form__group p{margin-bottom:16px}.tox .tox-dialog__body-content .tox-form__group h1:first-child,.tox .tox-dialog__body-content .tox-form__group h2:first-child,.tox .tox-dialog__body-content .tox-form__group p:first-child{margin-top:0}.tox .tox-dialog__body-content .tox-form__group h1:last-child,.tox .tox-dialog__body-content .tox-form__group h2:last-child,.tox .tox-dialog__body-content .tox-form__group p:last-child{margin-bottom:0}.tox .tox-dialog__body-content .tox-form__group h1:only-child,.tox .tox-dialog__body-content .tox-form__group h2:only-child,.tox .tox-dialog__body-content .tox-form__group p:only-child{margin-bottom:0;margin-top:0}.tox .tox-dialog__body-content .tox-form__group .tox-label.tox-label--center{text-align:center}.tox .tox-dialog__body-content .tox-form__group .tox-label.tox-label--end{text-align:end}.tox .tox-dialog--width-lg{height:650px;max-width:1200px}.tox .tox-dialog--fullscreen{height:100%;max-width:100%}.tox .tox-dialog--fullscreen .tox-dialog__body-content{max-height:100%}.tox .tox-dialog--width-md{max-width:800px}.tox .tox-dialog--width-md .tox-dialog__body-content{overflow:auto}.tox .tox-dialog__body-content--centered{text-align:center}.tox .tox-dialog__footer{align-items:center;background-color:#fff;border-top:none;display:flex;justify-content:space-between;padding:8px 16px}.tox .tox-dialog__footer-end,.tox .tox-dialog__footer-start{display:flex}.tox .tox-dialog__busy-spinner{align-items:center;background-color:rgba(255,255,255,.75);bottom:0;display:flex;justify-content:center;left:0;position:absolute;right:0;top:0;z-index:3}.tox .tox-dialog__table{border-collapse:collapse;width:100%}.tox .tox-dialog__table thead th{font-weight:700;padding-bottom:8px}.tox .tox-dialog__table thead th:first-child{padding-right:8px}.tox .tox-dialog__table tbody tr{border-bottom:1px solid #626262}.tox .tox-dialog__table tbody tr:last-child{border-bottom:none}.tox .tox-dialog__table td{padding-bottom:8px;padding-top:8px}.tox .tox-dialog__table td:first-child{padding-right:8px}.tox .tox-dialog__iframe{min-height:200px}.tox .tox-dialog__iframe.tox-dialog__iframe--opaque{background:#fff}.tox .tox-navobj-bordered{position:relative}.tox .tox-navobj-bordered::before{border:1px solid #eee;border-radius:6px;content:'';inset:0;opacity:1;pointer-events:none;position:absolute;z-index:1}.tox .tox-navobj-bordered iframe{border-radius:6px}.tox .tox-navobj-bordered-focus.tox-navobj-bordered::before{border-color:#006ce7;box-shadow:0 0 0 1px #006ce7;outline:0}.tox .tox-dialog__popups{position:absolute;width:100%;z-index:1100}.tox .tox-dialog__body-iframe{display:flex;flex:1;flex-direction:column}.tox .tox-dialog__body-iframe .tox-navobj{display:flex;flex:1}.tox .tox-dialog__body-iframe .tox-navobj :nth-child(2){flex:1;height:100%}.tox .tox-dialog-dock-fadeout{opacity:0;visibility:hidden}.tox .tox-dialog-dock-fadein{opacity:1;visibility:visible}.tox .tox-dialog-dock-transition{transition:visibility 0s linear .3s,opacity .3s ease}.tox .tox-dialog-dock-transition.tox-dialog-dock-fadein{transition-delay:0s}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox:not([dir=rtl]) .tox-dialog__body-nav{margin-right:0}}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox:not([dir=rtl]) .tox-dialog__body-nav-item:not(:first-child){margin-left:8px}}.tox:not([dir=rtl]) .tox-dialog__footer .tox-dialog__footer-end>*,.tox:not([dir=rtl]) .tox-dialog__footer .tox-dialog__footer-start>*{margin-left:8px}.tox[dir=rtl] .tox-dialog__body{text-align:right}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox[dir=rtl] .tox-dialog__body-nav{margin-left:0}}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox[dir=rtl] .tox-dialog__body-nav-item:not(:first-child){margin-right:8px}}.tox[dir=rtl] .tox-dialog__footer .tox-dialog__footer-end>*,.tox[dir=rtl] .tox-dialog__footer .tox-dialog__footer-start>*{margin-right:8px}body.tox-dialog__disable-scroll{overflow:hidden}.tox .tox-dropzone-container{display:flex;flex:1}.tox .tox-dropzone{align-items:center;background:#fff;border:2px dashed #eee;box-sizing:border-box;display:flex;flex-direction:column;flex-grow:1;justify-content:center;min-height:100px;padding:10px}.tox .tox-dropzone p{color:rgba(34,47,62,.7);margin:0 0 16px 0}.tox .tox-edit-area{display:flex;flex:1;overflow:hidden;position:relative}.tox .tox-edit-area::before{border:2px solid #006ce7;border-radius:4px;content:'';inset:0;opacity:0;pointer-events:none;position:absolute;transition:opacity .15s;z-index:1}@media (forced-colors:active){.tox .tox-edit-area::before{border:2px solid highlight}}.tox .tox-edit-area__iframe{background-color:#fff;border:0;box-sizing:border-box;flex:1;height:100%;position:absolute;width:100%}.tox.tox-edit-focus .tox-edit-area::before{opacity:1}.tox.tox-inline-edit-area{border:1px dotted #eee}.tox .tox-editor-container{display:flex;flex:1 1 auto;flex-direction:column;overflow:hidden}.tox .tox-editor-header{display:grid;grid-template-columns:1fr min-content;z-index:2}.tox:not(.tox-tinymce-inline) .tox-editor-header{background-color:#fff;border-bottom:none;box-shadow:0 2px 2px -2px rgba(34,47,62,.1),0 8px 8px -4px rgba(34,47,62,.07);padding:4px 0}.tox:not(.tox-tinymce-inline) .tox-editor-header:not(.tox-editor-dock-transition){transition:box-shadow .5s}.tox:not(.tox-tinymce-inline).tox-tinymce--toolbar-bottom .tox-editor-header{border-top:1px solid #e3e3e3;box-shadow:none}.tox:not(.tox-tinymce-inline).tox-tinymce--toolbar-sticky-on .tox-editor-header{background-color:#fff;box-shadow:0 2px 2px -2px rgba(34,47,62,.2),0 8px 8px -4px rgba(34,47,62,.15);padding:4px 0}.tox:not(.tox-tinymce-inline).tox-tinymce--toolbar-sticky-on.tox-tinymce--toolbar-bottom .tox-editor-header{box-shadow:0 2px 2px -2px rgba(34,47,62,.2),0 8px 8px -4px rgba(34,47,62,.15)}.tox.tox:not(.tox-tinymce-inline) .tox-editor-header.tox-editor-header--empty{background:0 0;border:none;box-shadow:none;padding:0}.tox-editor-dock-fadeout{opacity:0;visibility:hidden}.tox-editor-dock-fadein{opacity:1;visibility:visible}.tox-editor-dock-transition{transition:visibility 0s linear .25s,opacity .25s ease}.tox-editor-dock-transition.tox-editor-dock-fadein{transition-delay:0s}.tox .tox-control-wrap{flex:1;position:relative}.tox .tox-control-wrap:not(.tox-control-wrap--status-invalid) .tox-control-wrap__status-icon-invalid,.tox .tox-control-wrap:not(.tox-control-wrap--status-unknown) .tox-control-wrap__status-icon-unknown,.tox .tox-control-wrap:not(.tox-control-wrap--status-valid) .tox-control-wrap__status-icon-valid{display:none}.tox .tox-control-wrap svg{display:block}.tox .tox-control-wrap__status-icon-wrap{position:absolute;top:50%;transform:translateY(-50%)}.tox .tox-control-wrap__status-icon-invalid svg{fill:#c00}.tox .tox-control-wrap__status-icon-unknown svg{fill:orange}.tox .tox-control-wrap__status-icon-valid svg{fill:green}.tox:not([dir=rtl]) .tox-control-wrap--status-invalid .tox-textfield,.tox:not([dir=rtl]) .tox-control-wrap--status-unknown .tox-textfield,.tox:not([dir=rtl]) .tox-control-wrap--status-valid .tox-textfield{padding-right:32px}.tox:not([dir=rtl]) .tox-control-wrap__status-icon-wrap{right:4px}.tox[dir=rtl] .tox-control-wrap--status-invalid .tox-textfield,.tox[dir=rtl] .tox-control-wrap--status-unknown .tox-textfield,.tox[dir=rtl] .tox-control-wrap--status-valid .tox-textfield{padding-left:32px}.tox[dir=rtl] .tox-control-wrap__status-icon-wrap{left:4px}.tox .tox-custom-preview{border-color:#eee;border-radius:6px;border-style:solid;border-width:1px;flex:1;padding:8px}.tox .tox-autocompleter{max-width:25em}.tox .tox-autocompleter .tox-menu{box-sizing:border-box;max-width:25em}.tox .tox-autocompleter .tox-autocompleter-highlight{font-weight:700}.tox .tox-color-input{display:flex;position:relative;z-index:1}.tox .tox-color-input .tox-textfield{z-index:-1}.tox .tox-color-input span{border-color:rgba(34,47,62,.2);border-radius:6px;border-style:solid;border-width:1px;box-shadow:none;box-sizing:border-box;height:24px;position:absolute;top:6px;width:24px}@media (forced-colors:active){.tox .tox-color-input span{border-color:currentColor;border-width:2px!important;forced-color-adjust:none}}.tox .tox-color-input span:focus:not([aria-disabled=true]),.tox .tox-color-input span:hover:not([aria-disabled=true]){border-color:#006ce7;cursor:pointer}.tox .tox-color-input span::before{background-image:linear-gradient(45deg,rgba(0,0,0,.25) 25%,transparent 25%),linear-gradient(-45deg,rgba(0,0,0,.25) 25%,transparent 25%),linear-gradient(45deg,transparent 75%,rgba(0,0,0,.25) 75%),linear-gradient(-45deg,transparent 75%,rgba(0,0,0,.25) 75%);background-position:0 0,0 6px,6px -6px,-6px 0;background-size:12px 12px;border:1px solid #fff;border-radius:6px;box-sizing:border-box;content:'';height:24px;left:-1px;position:absolute;top:-1px;width:24px;z-index:-1}@media (forced-colors:active){.tox .tox-color-input span::before{border:none}}.tox .tox-color-input span[aria-disabled=true]{cursor:not-allowed}.tox:not([dir=rtl]) .tox-color-input .tox-textfield{padding-left:36px}.tox:not([dir=rtl]) .tox-color-input span{left:6px}.tox[dir=rtl] .tox-color-input .tox-textfield{padding-right:36px}.tox[dir=rtl] .tox-color-input span{right:6px}.tox .tox-label,.tox .tox-toolbar-label{color:rgba(34,47,62,.7);display:block;font-size:14px;font-style:normal;font-weight:400;line-height:1.3;padding:0 8px 0 0;text-transform:none;white-space:nowrap}.tox .tox-toolbar-label{padding:0 8px}.tox[dir=rtl] .tox-label{padding:0 0 0 8px}.tox .tox-form{display:flex;flex:1;flex-direction:column}.tox .tox-form__group{box-sizing:border-box;margin-bottom:4px}.tox .tox-form-group--maximize{flex:1}.tox .tox-form__group--error{color:#c00}.tox .tox-form__group--collection{display:flex}.tox .tox-form__grid{display:flex;flex-direction:row;flex-wrap:wrap;justify-content:space-between}.tox .tox-form__grid--2col>.tox-form__group{width:calc(50% - (8px / 2))}.tox .tox-form__grid--3col>.tox-form__group{width:calc(100% / 3 - (8px / 2))}.tox .tox-form__grid--4col>.tox-form__group{width:calc(25% - (8px / 2))}.tox .tox-form__controls-h-stack{align-items:center;display:flex}.tox .tox-form__group--inline{align-items:center;display:flex}.tox .tox-form__group--stretched{display:flex;flex:1;flex-direction:column}.tox .tox-form__group--stretched .tox-textarea{flex:1}.tox .tox-form__group--stretched .tox-navobj{display:flex;flex:1}.tox .tox-form__group--stretched .tox-navobj :nth-child(2){flex:1;height:100%}.tox:not([dir=rtl]) .tox-form__controls-h-stack>:not(:first-child){margin-left:4px}.tox[dir=rtl] .tox-form__controls-h-stack>:not(:first-child){margin-right:4px}.tox .tox-lock.tox-locked .tox-lock-icon__unlock,.tox .tox-lock:not(.tox-locked) .tox-lock-icon__lock{display:none}.tox .tox-listboxfield .tox-listbox--select,.tox .tox-textarea,.tox .tox-textarea-wrap .tox-textarea:focus,.tox .tox-textfield,.tox .tox-toolbar-textfield{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:#fff;border-color:#eee;border-radius:6px;border-style:solid;border-width:1px;box-shadow:none;box-sizing:border-box;color:#222f3e;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:16px;line-height:24px;margin:0;min-height:34px;outline:0;padding:5px 5.5px;resize:none;width:100%}.tox .tox-textarea[disabled],.tox .tox-textfield[disabled]{background-color:#f2f2f2;color:rgba(34,47,62,.85);cursor:not-allowed}.tox .tox-custom-editor:focus-within,.tox .tox-listboxfield .tox-listbox--select:focus,.tox .tox-textarea-wrap:focus-within,.tox .tox-textarea:focus,.tox .tox-textfield:focus{background-color:#fff;border-color:#006ce7;box-shadow:0 0 0 1px #006ce7;outline:0}.tox .tox-toolbar-textfield{border-width:0;margin-bottom:3px;margin-top:2px;max-width:250px}.tox .tox-naked-btn{background-color:transparent;border:0;border-color:transparent;box-shadow:unset;color:#006ce7;cursor:pointer;display:block;margin:0;padding:0}.tox .tox-naked-btn svg{display:block;fill:#222f3e}.tox:not([dir=rtl]) .tox-toolbar-textfield+*{margin-left:4px}.tox[dir=rtl] .tox-toolbar-textfield+*{margin-right:4px}.tox .tox-listboxfield{cursor:pointer;position:relative}.tox .tox-listboxfield .tox-listbox--select[disabled]{background-color:#f2f2f2;color:rgba(34,47,62,.85);cursor:not-allowed}.tox .tox-listbox__select-label{cursor:default;flex:1;margin:0 4px}.tox .tox-listbox__select-chevron{align-items:center;display:flex;justify-content:center;width:16px}.tox .tox-listbox__select-chevron svg{fill:#222f3e}@media (forced-colors:active){.tox .tox-listbox__select-chevron svg{fill:currentColor!important}}.tox .tox-listboxfield .tox-listbox--select{align-items:center;display:flex}.tox:not([dir=rtl]) .tox-listboxfield svg{right:8px}.tox[dir=rtl] .tox-listboxfield svg{left:8px}.tox .tox-selectfield{cursor:pointer;position:relative}.tox .tox-selectfield select{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:#fff;border-color:#eee;border-radius:6px;border-style:solid;border-width:1px;box-shadow:none;box-sizing:border-box;color:#222f3e;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:16px;line-height:24px;margin:0;min-height:34px;outline:0;padding:5px 5.5px;resize:none;width:100%}.tox .tox-selectfield select[disabled]{background-color:#f2f2f2;color:rgba(34,47,62,.85);cursor:not-allowed}.tox .tox-selectfield select::-ms-expand{display:none}.tox .tox-selectfield select:focus{background-color:#fff;border-color:#006ce7;box-shadow:0 0 0 1px #006ce7;outline:0}.tox .tox-selectfield svg{pointer-events:none;position:absolute;top:50%;transform:translateY(-50%)}.tox:not([dir=rtl]) .tox-selectfield select[size="0"],.tox:not([dir=rtl]) .tox-selectfield select[size="1"]{padding-right:24px}.tox:not([dir=rtl]) .tox-selectfield svg{right:8px}.tox[dir=rtl] .tox-selectfield select[size="0"],.tox[dir=rtl] .tox-selectfield select[size="1"]{padding-left:24px}.tox[dir=rtl] .tox-selectfield svg{left:8px}.tox .tox-textarea-wrap{border-color:#eee;border-radius:6px;border-style:solid;border-width:1px;display:flex;flex:1;overflow:hidden}.tox .tox-textarea{-webkit-appearance:textarea;-moz-appearance:textarea;appearance:textarea;white-space:pre-wrap}.tox .tox-textarea-wrap .tox-textarea{border:none}.tox .tox-textarea-wrap .tox-textarea:focus{border:none}.tox-fullscreen{border:0;height:100%;margin:0;overflow:hidden;overscroll-behavior:none;padding:0;touch-action:pinch-zoom;width:100%}.tox.tox-tinymce.tox-fullscreen .tox-statusbar__resize-handle{display:none}.tox-shadowhost.tox-fullscreen,.tox.tox-tinymce.tox-fullscreen{left:0;position:fixed;top:0;z-index:1200}.tox.tox-tinymce.tox-fullscreen{background-color:transparent}.tox-fullscreen .tox.tox-tinymce-aux,.tox-fullscreen~.tox.tox-tinymce-aux{z-index:1201}.tox .tox-help__more-link{list-style:none;margin-top:1em}.tox .tox-imagepreview{background-color:#666;height:380px;overflow:hidden;position:relative;width:100%}.tox .tox-imagepreview.tox-imagepreview__loaded{overflow:auto}.tox .tox-imagepreview__container{display:flex;left:100vw;position:absolute;top:100vw}.tox .tox-imagepreview__image{background:url(data:image/gif;base64,R0lGODdhDAAMAIABAMzMzP///ywAAAAADAAMAAACFoQfqYeabNyDMkBQb81Uat85nxguUAEAOw==)}.tox .tox-image-tools .tox-spacer{flex:1}.tox .tox-image-tools .tox-bar{align-items:center;display:flex;height:60px;justify-content:center}.tox .tox-image-tools .tox-imagepreview,.tox .tox-image-tools .tox-imagepreview+.tox-bar{margin-top:8px}.tox .tox-image-tools .tox-croprect-block{background:#000;opacity:.5;position:absolute;zoom:1}.tox .tox-image-tools .tox-croprect-handle{border:2px solid #fff;height:20px;left:0;position:absolute;top:0;width:20px}.tox .tox-image-tools .tox-croprect-handle-move{border:0;cursor:move;position:absolute}.tox .tox-image-tools .tox-croprect-handle-nw{border-width:2px 0 0 2px;cursor:nw-resize;left:100px;margin:-2px 0 0 -2px;top:100px}.tox .tox-image-tools .tox-croprect-handle-ne{border-width:2px 2px 0 0;cursor:ne-resize;left:200px;margin:-2px 0 0 -20px;top:100px}.tox .tox-image-tools .tox-croprect-handle-sw{border-width:0 0 2px 2px;cursor:sw-resize;left:100px;margin:-20px 2px 0 -2px;top:200px}.tox .tox-image-tools .tox-croprect-handle-se{border-width:0 2px 2px 0;cursor:se-resize;left:200px;margin:-20px 0 0 -20px;top:200px}.tox .tox-insert-table-picker{background-color:#fff;display:flex;flex-wrap:wrap;width:170px}.tox .tox-insert-table-picker>div{border-color:#eee;border-style:solid;border-width:0 1px 1px 0;box-sizing:border-box;height:17px;width:17px}.tox .tox-collection--list .tox-collection__group .tox-insert-table-picker{margin:-4px -4px}.tox .tox-insert-table-picker .tox-insert-table-picker__selected{background-color:#006ce7;border-color:#eee}@media (forced-colors:active){.tox .tox-insert-table-picker .tox-insert-table-picker__selected{border-color:Highlight;filter:contrast(50%)}}.tox .tox-insert-table-picker__label{color:rgba(34,47,62,.7);display:block;font-size:14px;padding:4px;text-align:center;width:100%}.tox:not([dir=rtl]) .tox-insert-table-picker>div:nth-child(10n){border-right:0}.tox[dir=rtl] .tox-insert-table-picker>div:nth-child(10n+1){border-right:0}.tox .tox-menu{background-color:#fff;border:1px solid transparent;border-radius:6px;box-shadow:0 0 2px 0 rgba(34,47,62,.2),0 4px 8px 0 rgba(34,47,62,.15);display:inline-block;overflow:hidden;vertical-align:top;z-index:1150}.tox .tox-menu.tox-collection.tox-collection--list{padding:0 4px}.tox .tox-menu.tox-collection.tox-collection--toolbar{padding:8px}.tox .tox-menu.tox-collection.tox-collection--grid{padding:8px}@media only screen and (min-width:768px){.tox .tox-menu .tox-collection__item-label{overflow-wrap:break-word;word-break:normal}.tox .tox-dialog__popups .tox-menu .tox-collection__item-label{word-break:break-all}}.tox .tox-menu__label blockquote,.tox .tox-menu__label code,.tox .tox-menu__label h1,.tox .tox-menu__label h2,.tox .tox-menu__label h3,.tox .tox-menu__label h4,.tox .tox-menu__label h5,.tox .tox-menu__label h6,.tox .tox-menu__label p{margin:0}.tox .tox-menubar{background:repeating-linear-gradient(transparent 0 1px,transparent 1px 39px) center top 39px/100% calc(100% - 39px) no-repeat;background-color:#fff;display:flex;flex:0 0 auto;flex-shrink:0;flex-wrap:wrap;grid-column:1/-1;grid-row:1;padding:0 11px 0 12px}.tox .tox-promotion+.tox-menubar{grid-column:1}.tox .tox-promotion{background:repeating-linear-gradient(transparent 0 1px,transparent 1px 39px) center top 39px/100% calc(100% - 39px) no-repeat;background-color:#fff;grid-column:2;grid-row:1;padding-inline-end:8px;padding-inline-start:4px;padding-top:5px}.tox .tox-promotion-link{align-items:unsafe center;background-color:#e8f1f8;border-radius:5px;color:#086be6;cursor:pointer;display:flex;font-size:14px;height:26.6px;padding:4px 8px;white-space:nowrap}.tox .tox-promotion-link:hover{background-color:#b4d7ff}.tox .tox-promotion-link:focus{background-color:#d9edf7}.tox .tox-mbtn{align-items:center;background:#fff;border:0;border-radius:3px;box-shadow:none;color:#222f3e;display:flex;flex:0 0 auto;font-size:14px;font-style:normal;font-weight:400;height:28px;justify-content:center;margin:5px 1px 6px 0;outline:0;padding:0 4px;text-transform:none;width:auto}.tox .tox-mbtn[disabled]{background-color:#fff;border:0;box-shadow:none;color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-mbtn:focus:not(:disabled){background:#fff;border:0;box-shadow:none;color:#222f3e;position:relative;z-index:1}.tox .tox-mbtn:focus:not(:disabled)::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-mbtn:focus:not(:disabled)::after{border:2px solid highlight}}.tox .tox-mbtn--active,.tox .tox-mbtn:not(:disabled).tox-mbtn--active:focus{background:#a6ccf7;border:0;box-shadow:none;color:#222f3e}.tox .tox-mbtn:hover:not(:disabled):not(.tox-mbtn--active){background:#f0f0f0;border:0;box-shadow:none;color:#222f3e}.tox .tox-mbtn__select-label{cursor:default;font-weight:400;margin:0 4px}.tox .tox-mbtn[disabled] .tox-mbtn__select-label{cursor:not-allowed}.tox .tox-mbtn__select-chevron{align-items:center;display:flex;justify-content:center;width:16px;display:none}.tox .tox-notification{border-radius:6px;border-style:solid;border-width:1px;box-shadow:none;box-sizing:border-box;display:grid;font-size:14px;font-weight:400;grid-template-columns:minmax(40px,1fr) auto minmax(40px,1fr);margin-left:auto;margin-right:auto;margin-top:4px;opacity:0;padding:4px;transition:transform .1s ease-in,opacity 150ms ease-in;width:-moz-max-content;width:max-content}.tox .tox-notification a{cursor:pointer;text-decoration:underline}.tox .tox-notification p{font-size:14px;font-weight:400}.tox .tox-notification:focus{border-color:#006ce7;box-shadow:0 0 0 1px #006ce7}.tox .tox-notification--in{opacity:1}.tox .tox-notification--success{background-color:#e4eeda;border-color:#d7e6c8;color:#222f3e}.tox .tox-notification--success p{color:#222f3e}.tox .tox-notification--success a{color:#517342}.tox .tox-notification--success a:focus,.tox .tox-notification--success a:hover{color:#24321d;text-decoration:underline}.tox .tox-notification--success a:focus-visible{border-radius:1px;outline:2px solid #517342;outline-offset:2px}.tox .tox-notification--success a:active{color:#0d120a;text-decoration:underline}.tox .tox-notification--success svg{fill:#222f3e}.tox .tox-notification--error{background-color:#f5cccc;border-color:#f0b3b3;color:#222f3e}.tox .tox-notification--error p{color:#222f3e}.tox .tox-notification--error a{color:#77181f}.tox .tox-notification--error a:focus,.tox .tox-notification--error a:hover{color:#220709;text-decoration:underline}.tox .tox-notification--error a:focus-visible{border-radius:1px;outline:2px solid #77181f;outline-offset:2px}.tox .tox-notification--error a:active{color:#000;text-decoration:underline}.tox .tox-notification--error svg{fill:#222f3e}.tox .tox-notification--warn,.tox .tox-notification--warning{background-color:#fff5cc;border-color:#fff0b3;color:#222f3e}.tox .tox-notification--warn p,.tox .tox-notification--warning p{color:#222f3e}.tox .tox-notification--warn a,.tox .tox-notification--warning a{color:#7a6e25}.tox .tox-notification--warn a:focus,.tox .tox-notification--warn a:hover,.tox .tox-notification--warning a:focus,.tox .tox-notification--warning a:hover{color:#2c280d;text-decoration:underline}.tox .tox-notification--warn a:focus-visible,.tox .tox-notification--warning a:focus-visible{border-radius:1px;outline:2px solid #7a6e25;outline-offset:2px}.tox .tox-notification--warn a:active,.tox .tox-notification--warning a:active{color:#050502;text-decoration:underline}.tox .tox-notification--warn svg,.tox .tox-notification--warning svg{fill:#222f3e}.tox .tox-notification--info{background-color:#d6e7fb;border-color:#c1dbf9;color:#222f3e}.tox .tox-notification--info p{color:#222f3e}.tox .tox-notification--info a{color:#2a64a6}.tox .tox-notification--info a:focus,.tox .tox-notification--info a:hover{color:#163355;text-decoration:underline}.tox .tox-notification--info a:focus-visible{border-radius:1px;outline:2px solid #2a64a6;outline-offset:2px}.tox .tox-notification--info a:active{color:#0b1a2c;text-decoration:underline}.tox .tox-notification--info svg{fill:#222f3e}.tox .tox-notification__body{align-self:center;color:#222f3e;font-size:14px;grid-column-end:3;grid-column-start:2;grid-row-end:2;grid-row-start:1;text-align:center;white-space:normal;word-break:break-all;word-break:break-word}.tox .tox-notification__body>*{margin:0}.tox .tox-notification__body>*+*{margin-top:1rem}.tox .tox-notification__icon{align-self:center;grid-column-end:2;grid-column-start:1;grid-row-end:2;grid-row-start:1;justify-self:end}.tox .tox-notification__icon svg{display:block}.tox .tox-notification__dismiss{align-self:start;grid-column-end:4;grid-column-start:3;grid-row-end:2;grid-row-start:1;justify-self:end}.tox .tox-notification .tox-progress-bar{grid-column-end:4;grid-column-start:1;grid-row-end:3;grid-row-start:2;justify-self:center}.tox .tox-notification-container-dock-fadeout{opacity:0;visibility:hidden}.tox .tox-notification-container-dock-fadein{opacity:1;visibility:visible}.tox .tox-notification-container-dock-transition{transition:visibility 0s linear .3s,opacity .3s ease}.tox .tox-notification-container-dock-transition.tox-notification-container-dock-fadein{transition-delay:0s}.tox .tox-pop{display:inline-block;position:relative}.tox .tox-pop--resizing{transition:width .1s ease}.tox .tox-pop--resizing .tox-toolbar,.tox .tox-pop--resizing .tox-toolbar__group{flex-wrap:nowrap}.tox .tox-pop--transition{transition:.15s ease;transition-property:left,right,top,bottom}.tox .tox-pop--transition::after,.tox .tox-pop--transition::before{transition:all .15s,visibility 0s,opacity 75ms ease 75ms}.tox .tox-pop__dialog{background-color:#fff;border:1px solid #eee;border-radius:6px;box-shadow:0 0 2px 0 rgba(34,47,62,.2),0 4px 8px 0 rgba(34,47,62,.15);min-width:0;overflow:hidden}.tox .tox-pop__dialog>:not(.tox-toolbar){margin:4px 4px 4px 8px}.tox .tox-pop__dialog .tox-toolbar{background-color:transparent;margin-bottom:-1px}.tox .tox-pop::after,.tox .tox-pop::before{border-style:solid;content:'';display:block;height:0;opacity:1;position:absolute;width:0}@media (forced-colors:active){.tox .tox-pop::after,.tox .tox-pop::before{content:none}}.tox .tox-pop.tox-pop--inset::after,.tox .tox-pop.tox-pop--inset::before{opacity:0;transition:all 0s .15s,visibility 0s,opacity 75ms ease}.tox .tox-pop.tox-pop--bottom::after,.tox .tox-pop.tox-pop--bottom::before{left:50%;top:100%}.tox .tox-pop.tox-pop--bottom::after{border-color:#fff transparent transparent transparent;border-width:8px;margin-left:-8px;margin-top:-1px}.tox .tox-pop.tox-pop--bottom::before{border-color:#eee transparent transparent transparent;border-width:9px;margin-left:-9px}.tox .tox-pop.tox-pop--top::after,.tox .tox-pop.tox-pop--top::before{left:50%;top:0;transform:translateY(-100%)}.tox .tox-pop.tox-pop--top::after{border-color:transparent transparent #fff transparent;border-width:8px;margin-left:-8px;margin-top:1px}.tox .tox-pop.tox-pop--top::before{border-color:transparent transparent #eee transparent;border-width:9px;margin-left:-9px}.tox .tox-pop.tox-pop--left::after,.tox .tox-pop.tox-pop--left::before{left:0;top:calc(50% - 1px);transform:translateY(-50%)}.tox .tox-pop.tox-pop--left::after{border-color:transparent #fff transparent transparent;border-width:8px;margin-left:-15px}.tox .tox-pop.tox-pop--left::before{border-color:transparent #eee transparent transparent;border-width:10px;margin-left:-19px}.tox .tox-pop.tox-pop--right::after,.tox .tox-pop.tox-pop--right::before{left:100%;top:calc(50% + 1px);transform:translateY(-50%)}.tox .tox-pop.tox-pop--right::after{border-color:transparent transparent transparent #fff;border-width:8px;margin-left:-1px}.tox .tox-pop.tox-pop--right::before{border-color:transparent transparent transparent #eee;border-width:10px;margin-left:-1px}.tox .tox-pop.tox-pop--align-left::after,.tox .tox-pop.tox-pop--align-left::before{left:20px}.tox .tox-pop.tox-pop--align-right::after,.tox .tox-pop.tox-pop--align-right::before{left:calc(100% - 20px)}.tox .tox-sidebar-wrap{display:flex;flex-direction:row;flex-grow:1;min-height:0}.tox .tox-sidebar{background-color:#fff;display:flex;flex-direction:row;justify-content:flex-end}.tox .tox-sidebar__slider{display:flex;overflow:hidden}.tox .tox-sidebar__pane-container{display:flex}.tox .tox-sidebar__pane{display:flex}.tox .tox-sidebar--sliding-closed{opacity:0}.tox .tox-sidebar--sliding-open{opacity:1}.tox .tox-sidebar--sliding-growing,.tox .tox-sidebar--sliding-shrinking{transition:width .5s ease,opacity .5s ease}.tox .tox-selector{background-color:#4099ff;border-color:#4099ff;border-style:solid;border-width:1px;box-sizing:border-box;display:inline-block;height:10px;position:absolute;width:10px}.tox.tox-platform-touch .tox-selector{height:12px;width:12px}.tox .tox-slider{align-items:center;display:flex;flex:1;height:24px;justify-content:center;position:relative}.tox .tox-slider__rail{background-color:transparent;border:1px solid #eee;border-radius:6px;height:10px;min-width:120px;width:100%}.tox .tox-slider__handle{background-color:#006ce7;border:2px solid #0054b4;border-radius:6px;box-shadow:none;height:24px;left:50%;position:absolute;top:50%;transform:translateX(-50%) translateY(-50%);width:14px}.tox .tox-form__controls-h-stack>.tox-slider:not(:first-of-type){margin-inline-start:8px}.tox .tox-form__controls-h-stack>.tox-form__group+.tox-slider{margin-inline-start:32px}.tox .tox-form__controls-h-stack>.tox-slider+.tox-form__group{margin-inline-start:32px}.tox .tox-source-code{overflow:auto}.tox .tox-spinner{display:flex}.tox .tox-spinner>div{animation:tam-bouncing-dots 1.5s ease-in-out 0s infinite both;background-color:rgba(34,47,62,.7);border-radius:100%;height:8px;width:8px}.tox .tox-spinner>div:nth-child(1){animation-delay:-.32s}.tox .tox-spinner>div:nth-child(2){animation-delay:-.16s}@keyframes tam-bouncing-dots{0%,100%,80%{transform:scale(0)}40%{transform:scale(1)}}.tox:not([dir=rtl]) .tox-spinner>div:not(:first-child){margin-left:4px}.tox[dir=rtl] .tox-spinner>div:not(:first-child){margin-right:4px}.tox .tox-statusbar{align-items:center;background-color:#fff;border-top:1px solid #e3e3e3;color:rgba(34,47,62,.7);display:flex;flex:0 0 auto;font-size:14px;font-weight:400;height:25px;overflow:hidden;padding:0 8px;position:relative;text-transform:none}.tox .tox-statusbar__path{display:flex;flex:1 1 auto;text-overflow:ellipsis;white-space:nowrap}.tox .tox-statusbar__right-container{display:flex;justify-content:flex-end;white-space:nowrap}.tox .tox-statusbar__help-text{text-align:center}.tox .tox-statusbar__text-container{align-items:flex-start;display:flex;flex:1 1 auto;height:16px;justify-content:space-between;overflow:hidden}@media only screen and (min-width:768px){.tox .tox-statusbar__text-container.tox-statusbar__text-container-3-cols>.tox-statusbar__help-text,.tox .tox-statusbar__text-container.tox-statusbar__text-container-3-cols>.tox-statusbar__path,.tox .tox-statusbar__text-container.tox-statusbar__text-container-3-cols>.tox-statusbar__right-container{flex:0 0 calc(100% / 3)}}.tox .tox-statusbar__text-container.tox-statusbar__text-container--flex-end{justify-content:flex-end}.tox .tox-statusbar__text-container.tox-statusbar__text-container--flex-start{justify-content:flex-start}.tox .tox-statusbar__text-container.tox-statusbar__text-container--space-around{justify-content:space-around}.tox .tox-statusbar__path>*{display:inline;white-space:nowrap}.tox .tox-statusbar__wordcount{flex:0 0 auto;margin-left:1ch}@media only screen and (max-width:767px){.tox .tox-statusbar__text-container .tox-statusbar__help-text{display:none}.tox .tox-statusbar__text-container .tox-statusbar__help-text:only-child{display:block}}.tox .tox-statusbar a,.tox .tox-statusbar__path-item,.tox .tox-statusbar__wordcount{color:rgba(34,47,62,.7);position:relative;text-decoration:none}.tox .tox-statusbar a:focus:not(:disabled):not([aria-disabled=true]),.tox .tox-statusbar a:hover:not(:disabled):not([aria-disabled=true]),.tox .tox-statusbar__path-item:focus:not(:disabled):not([aria-disabled=true]),.tox .tox-statusbar__path-item:hover:not(:disabled):not([aria-disabled=true]),.tox .tox-statusbar__wordcount:focus:not(:disabled):not([aria-disabled=true]),.tox .tox-statusbar__wordcount:hover:not(:disabled):not([aria-disabled=true]){color:#222f3e;cursor:pointer}.tox .tox-statusbar a:focus-visible::after,.tox .tox-statusbar__path-item:focus-visible::after,.tox .tox-statusbar__wordcount:focus-visible::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-statusbar a:focus-visible::after,.tox .tox-statusbar__path-item:focus-visible::after,.tox .tox-statusbar__wordcount:focus-visible::after{border:2px solid highlight}}.tox .tox-statusbar__branding svg{fill:rgba(34,47,62,.8);height:1em;margin-left:.3em;width:auto}@media (forced-colors:active){.tox .tox-statusbar__branding svg{fill:currentColor}}.tox .tox-statusbar__branding a{align-items:center;display:inline-flex}.tox .tox-statusbar__branding a:focus:not(:disabled):not([aria-disabled=true]) svg,.tox .tox-statusbar__branding a:hover:not(:disabled):not([aria-disabled=true]) svg{fill:#222f3e}.tox .tox-statusbar__resize-handle{align-items:flex-end;align-self:stretch;cursor:nwse-resize;display:flex;flex:0 0 auto;justify-content:flex-end;margin-bottom:3px;margin-left:4px;margin-right:calc(3px - 8px);margin-top:3px;padding-bottom:0;padding-left:0;padding-right:0;position:relative}.tox .tox-statusbar__resize-handle svg{display:block;fill:rgba(34,47,62,.5)}.tox .tox-statusbar__resize-handle:focus svg,.tox .tox-statusbar__resize-handle:hover svg{fill:#222f3e}.tox .tox-statusbar__resize-handle:focus-visible{background-color:transparent;border-radius:1px 1px 5px 1px;box-shadow:0 0 0 2px transparent}.tox .tox-statusbar__resize-handle:focus-visible::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-statusbar__resize-handle:focus-visible::after{border:2px solid highlight}}.tox:not([dir=rtl]) .tox-statusbar__path>*{margin-right:4px}.tox:not([dir=rtl]) .tox-statusbar__branding{margin-left:2ch}.tox[dir=rtl] .tox-statusbar{flex-direction:row-reverse}.tox[dir=rtl] .tox-statusbar__path>*{margin-left:4px}.tox[dir=rtl] .tox-statusbar__branding svg{margin-left:0;margin-right:.3em}.tox .tox-throbber{z-index:1299}.tox .tox-throbber__busy-spinner{align-items:center;background-color:rgba(255,255,255,.6);bottom:0;display:flex;justify-content:center;left:0;position:absolute;right:0;top:0}.tox .tox-tbtn{align-items:center;background:#fff;border:0;border-radius:3px;box-shadow:none;color:#222f3e;display:flex;flex:0 0 auto;font-size:14px;font-style:normal;font-weight:400;height:28px;justify-content:center;margin:6px 1px 5px 0;outline:0;padding:0;text-transform:none;width:34px}@media (forced-colors:active){.tox .tox-tbtn.tox-tbtn:hover,.tox .tox-tbtn:hover{outline:1px dashed currentColor}.tox .tox-tbtn.tox-tbtn--active,.tox .tox-tbtn.tox-tbtn--enabled,.tox .tox-tbtn.tox-tbtn--enabled:focus,.tox .tox-tbtn.tox-tbtn--enabled:hover,.tox .tox-tbtn:focus:not(.tox-tbtn--disabled){outline:1px solid currentColor;position:relative}}.tox .tox-tbtn svg{display:block;fill:#222f3e}@media (forced-colors:active){.tox .tox-tbtn svg{fill:currentColor!important}.tox .tox-tbtn svg.tox-tbtn--enabled,.tox .tox-tbtn svg:focus:not(.tox-tbtn--disabled){fill:currentColor!important}.tox .tox-tbtn svg .tox-tbtn:disabled,.tox .tox-tbtn svg .tox-tbtn:disabled:hover,.tox .tox-tbtn svg.tox-tbtn--disabled,.tox .tox-tbtn svg.tox-tbtn--disabled:hover{filter:contrast(0)}}.tox .tox-tbtn.tox-tbtn-more{padding-left:5px;padding-right:5px;width:inherit}.tox .tox-tbtn:focus{background:#fff;border:0;box-shadow:none;position:relative;z-index:1}.tox .tox-tbtn:focus::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-tbtn:focus::after{border:2px solid highlight}}.tox .tox-tbtn:hover{background:#f0f0f0;border:0;box-shadow:none;color:#222f3e}.tox .tox-tbtn:hover svg{fill:#222f3e}.tox .tox-tbtn:active{background:#a6ccf7;border:0;box-shadow:none;color:#222f3e}.tox .tox-tbtn:active svg{fill:#222f3e}.tox .tox-tbtn--disabled .tox-tbtn--enabled svg{fill:rgba(34,47,62,.5)}.tox .tox-tbtn--disabled,.tox .tox-tbtn--disabled:hover,.tox .tox-tbtn:disabled,.tox .tox-tbtn:disabled:hover{background:#fff;border:0;box-shadow:none;color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-tbtn--disabled svg,.tox .tox-tbtn--disabled:hover svg,.tox .tox-tbtn:disabled svg,.tox .tox-tbtn:disabled:hover svg{fill:rgba(34,47,62,.5)}.tox .tox-tbtn--active,.tox .tox-tbtn--enabled,.tox .tox-tbtn--enabled:focus,.tox .tox-tbtn--enabled:hover{background:#a6ccf7;border:0;box-shadow:none;color:#222f3e;position:relative}.tox .tox-tbtn--active>*,.tox .tox-tbtn--enabled:focus>*,.tox .tox-tbtn--enabled:hover>*,.tox .tox-tbtn--enabled>*{transform:none}.tox .tox-tbtn--active svg,.tox .tox-tbtn--enabled svg,.tox .tox-tbtn--enabled:focus svg,.tox .tox-tbtn--enabled:hover svg{fill:#222f3e}.tox .tox-tbtn--active.tox-tbtn--disabled svg,.tox .tox-tbtn--enabled.tox-tbtn--disabled svg,.tox .tox-tbtn--enabled:focus.tox-tbtn--disabled svg,.tox .tox-tbtn--enabled:hover.tox-tbtn--disabled svg{fill:rgba(34,47,62,.5)}.tox .tox-tbtn--enabled:focus::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-tbtn--enabled:focus::after{border:2px solid highlight}}.tox .tox-tbtn:focus:not(.tox-tbtn--disabled){color:#222f3e}.tox .tox-tbtn:focus:not(.tox-tbtn--disabled) svg{fill:#222f3e}.tox .tox-tbtn:active>*{transform:none}.tox .tox-tbtn--md{height:42px;width:51px}.tox .tox-tbtn--lg{flex-direction:column;height:56px;width:68px}.tox .tox-tbtn--return{align-self:stretch;height:unset;width:16px}.tox .tox-tbtn--labeled{padding:0 4px;width:unset}.tox .tox-tbtn__vlabel{display:block;font-size:10px;font-weight:400;letter-spacing:-.025em;margin-bottom:4px;white-space:nowrap}.tox .tox-number-input{background:#f7f7f7;border-radius:3px;display:flex;margin:6px 1px 5px 0;position:relative;width:auto}.tox .tox-number-input:focus{background:#f7f7f7}.tox .tox-number-input:focus::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-number-input:focus::after{border:2px solid highlight}}.tox .tox-number-input .tox-input-wrapper{display:flex;pointer-events:none;position:relative;text-align:center}.tox .tox-number-input .tox-input-wrapper:focus{background-color:#f7f7f7;z-index:1}.tox .tox-number-input .tox-input-wrapper:focus::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-number-input .tox-input-wrapper:focus::after{border:2px solid highlight}}.tox .tox-number-input .tox-input-wrapper:has(input:focus)::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-number-input .tox-input-wrapper:has(input:focus)::after{border:2px solid highlight}}.tox .tox-number-input input{border-radius:3px;color:#222f3e;font-size:14px;margin:2px 0;pointer-events:all;position:relative;width:60px}.tox .tox-number-input input:hover{background:#f0f0f0;color:#222f3e}.tox .tox-number-input input:focus{background-color:#f7f7f7}.tox .tox-number-input input:disabled{background:#fff;border:0;box-shadow:none;color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-number-input button{color:#222f3e;height:28px;position:relative;text-align:center;width:24px}@media (forced-colors:active){.tox .tox-number-input button:active,.tox .tox-number-input button:focus,.tox .tox-number-input button:hover{outline:1px solid currentColor!important}}.tox .tox-number-input button svg{display:block;fill:#222f3e;margin:0 auto;transform:scale(.67)}@media (forced-colors:active){.tox .tox-number-input button svg,.tox .tox-number-input button svg:active,.tox .tox-number-input button svg:hover{fill:currentColor!important}.tox .tox-number-input button svg:disabled{filter:contrast(0)}}.tox .tox-number-input button:focus{background:#f7f7f7;z-index:1}.tox .tox-number-input button:focus::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-number-input button:focus::after{border:2px solid highlight}}.tox .tox-number-input button:hover{background:#f0f0f0;border:0;box-shadow:none;color:#222f3e}.tox .tox-number-input button:hover svg{fill:#222f3e}.tox .tox-number-input button:active{background:#a6ccf7;border:0;box-shadow:none;color:#222f3e}.tox .tox-number-input button:active svg{fill:#222f3e}.tox .tox-number-input button:disabled{background:#fff;border:0;box-shadow:none;color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-number-input button:disabled svg{fill:rgba(34,47,62,.5)}.tox .tox-number-input button.minus{border-radius:3px 0 0 3px}.tox .tox-number-input button.plus{border-radius:0 3px 3px 0}.tox .tox-number-input:focus:not(:active)>.tox-input-wrapper,.tox .tox-number-input:focus:not(:active)>button{background:#f7f7f7}.tox .tox-tbtn--select{margin:6px 1px 5px 0;padding:0 4px;width:auto}.tox .tox-tbtn__select-label{cursor:default;font-weight:400;height:initial;margin:0 4px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tox .tox-tbtn__select-chevron{align-items:center;display:flex;justify-content:center;width:16px}.tox .tox-tbtn__select-chevron svg{fill:rgba(34,47,62,.5)}@media (forced-colors:active){.tox .tox-tbtn__select-chevron svg{fill:currentColor}}.tox .tox-tbtn--bespoke{background:#f7f7f7}.tox .tox-tbtn--bespoke:focus{background:#f7f7f7}.tox .tox-tbtn--bespoke+.tox-tbtn--bespoke{margin-inline-start:4px}.tox .tox-tbtn--bespoke .tox-tbtn__select-label{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:7em}.tox .tox-tbtn--disabled .tox-tbtn__select-label,.tox .tox-tbtn--select:disabled .tox-tbtn__select-label{cursor:not-allowed}.tox .tox-split-button{border:0;border-radius:3px;box-sizing:border-box;display:flex;margin:6px 1px 5px 0}.tox .tox-split-button:hover{box-shadow:0 0 0 1px #f0f0f0 inset}.tox .tox-split-button:focus{background:#fff;box-shadow:none;color:#222f3e;position:relative;z-index:1}.tox .tox-split-button:focus::after{pointer-events:none;border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-split-button:focus::after{border:2px solid highlight}}.tox .tox-split-button>*{border-radius:0}.tox .tox-split-button>:nth-child(1){border-bottom-left-radius:3px;border-top-left-radius:3px}.tox .tox-split-button>:nth-child(2){border-bottom-right-radius:3px;border-top-right-radius:3px}.tox .tox-split-button__chevron{width:16px}.tox .tox-split-button__chevron svg{fill:rgba(34,47,62,.5)}@media (forced-colors:active){.tox .tox-split-button__chevron svg{fill:currentColor}}.tox .tox-split-button .tox-tbtn{margin:0}.tox .tox-split-button:focus .tox-tbtn{background-color:transparent}.tox .tox-split-button.tox-tbtn--disabled .tox-tbtn:focus,.tox .tox-split-button.tox-tbtn--disabled .tox-tbtn:hover,.tox .tox-split-button.tox-tbtn--disabled:focus,.tox .tox-split-button.tox-tbtn--disabled:hover{background:#fff;box-shadow:none;color:rgba(34,47,62,.5)}.tox.tox-platform-touch .tox-split-button .tox-tbtn--select{padding:0 0}.tox.tox-platform-touch .tox-split-button .tox-tbtn:not(.tox-tbtn--select):first-child{width:30px}.tox.tox-platform-touch .tox-split-button__chevron{width:20px}.tox .tox-split-button.tox-tbtn--disabled svg #tox-icon-highlight-bg-color__color,.tox .tox-split-button.tox-tbtn--disabled svg #tox-icon-text-color__color{opacity:.6}.tox .tox-toolbar-overlord{background-color:#fff}.tox .tox-toolbar,.tox .tox-toolbar__overflow,.tox .tox-toolbar__primary{background-attachment:local;background-color:#fff;background-image:repeating-linear-gradient(#e3e3e3 0 1px,transparent 1px 39px);background-position:center top 40px;background-repeat:no-repeat;background-size:calc(100% - 11px * 2) calc(100% - 41px);display:flex;flex:0 0 auto;flex-shrink:0;flex-wrap:wrap;padding:0 0;transform:perspective(1px)}.tox .tox-toolbar-overlord>.tox-toolbar,.tox .tox-toolbar-overlord>.tox-toolbar__overflow,.tox .tox-toolbar-overlord>.tox-toolbar__primary{background-position:center top 0;background-size:calc(100% - 11px * 2) calc(100% - 0px)}.tox .tox-toolbar__overflow.tox-toolbar__overflow--closed{height:0;opacity:0;padding-bottom:0;padding-top:0;visibility:hidden}.tox .tox-toolbar__overflow--growing{transition:height .3s ease,opacity .2s linear .1s}.tox .tox-toolbar__overflow--shrinking{transition:opacity .3s ease,height .2s linear .1s,visibility 0s linear .3s}.tox .tox-anchorbar,.tox .tox-toolbar-overlord{grid-column:1/-1}.tox .tox-menubar+.tox-toolbar,.tox .tox-menubar+.tox-toolbar-overlord{border-top:1px solid transparent;margin-top:-1px;padding-bottom:1px;padding-top:1px}@media (forced-colors:active){.tox .tox-menubar+.tox-toolbar,.tox .tox-menubar+.tox-toolbar-overlord{outline:1px solid currentColor}}.tox .tox-toolbar--scrolling{flex-wrap:nowrap;overflow-x:auto}.tox .tox-pop .tox-toolbar{border-width:0}.tox .tox-toolbar--no-divider{background-image:none}.tox .tox-toolbar-overlord .tox-toolbar:not(.tox-toolbar--scrolling):first-child,.tox .tox-toolbar-overlord .tox-toolbar__primary{background-position:center top 39px}.tox .tox-editor-header>.tox-toolbar--scrolling,.tox .tox-toolbar-overlord .tox-toolbar--scrolling:first-child{background-image:none}.tox.tox-tinymce-aux .tox-toolbar__overflow{background-color:#fff;background-position:center top 43px;background-size:calc(100% - 8px * 2) calc(100% - 51px);border:none;border-radius:6px;box-shadow:0 0 2px 0 rgba(34,47,62,.2),0 4px 8px 0 rgba(34,47,62,.15);overscroll-behavior:none;padding:4px 0}@media (forced-colors:active){.tox.tox-tinymce-aux .tox-toolbar__overflow{border:solid}}.tox-pop .tox-pop__dialog .tox-toolbar{background-position:center top 43px;background-size:calc(100% - 11px * 2) calc(100% - 51px);padding:4px 0}.tox .tox-toolbar__group{align-items:center;display:flex;flex-wrap:wrap;margin:0 0;padding:0 11px 0 12px}.tox .tox-toolbar__group--pull-right{margin-left:auto}.tox .tox-toolbar--scrolling .tox-toolbar__group{flex-shrink:0;flex-wrap:nowrap}.tox:not([dir=rtl]) .tox-toolbar__group:not(:last-of-type){border-right:1px solid transparent}.tox[dir=rtl] .tox-toolbar__group:not(:last-of-type){border-left:1px solid transparent}.tox .tox-tooltip{display:inline-block;max-width:15em;padding:8px;pointer-events:none;position:relative;width:-moz-max-content;width:max-content;z-index:1150}.tox .tox-tooltip__body{background-color:#222f3e;border-radius:6px;box-shadow:none;color:#fff;font-size:12px;font-style:normal;font-weight:600;overflow-wrap:break-word;padding:4px 6px;text-transform:none}@media (forced-colors:active){.tox .tox-tooltip__body{outline:outset 1px}}.tox .tox-tooltip__arrow{position:absolute}.tox .tox-tooltip--down .tox-tooltip__arrow{border-left:8px solid transparent;border-right:8px solid transparent;border-top:8px solid #222f3e;bottom:0;left:50%;position:absolute;transform:translateX(-50%)}.tox .tox-tooltip--up .tox-tooltip__arrow{border-bottom:8px solid #222f3e;border-left:8px solid transparent;border-right:8px solid transparent;left:50%;position:absolute;top:0;transform:translateX(-50%)}.tox .tox-tooltip--right .tox-tooltip__arrow{border-bottom:8px solid transparent;border-left:8px solid #222f3e;border-top:8px solid transparent;position:absolute;right:0;top:50%;transform:translateY(-50%)}.tox .tox-tooltip--left .tox-tooltip__arrow{border-bottom:8px solid transparent;border-right:8px solid #222f3e;border-top:8px solid transparent;left:0;position:absolute;top:50%;transform:translateY(-50%)}.tox .tox-tree{display:flex;flex-direction:column}.tox .tox-tree .tox-trbtn{align-items:center;background:0 0;border:0;border-radius:4px;box-shadow:none;color:#222f3e;display:flex;flex:0 0 auto;font-size:14px;font-style:normal;font-weight:400;height:28px;margin-bottom:4px;margin-top:4px;outline:0;overflow:hidden;padding:0;padding-left:8px;text-transform:none}.tox .tox-tree .tox-trbtn .tox-tree__label{cursor:default;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tox .tox-tree .tox-trbtn svg{display:block;fill:#222f3e}.tox .tox-tree .tox-trbtn:focus{background:#f0f0f0;border:0;box-shadow:none}.tox .tox-tree .tox-trbtn:hover{background:#f0f0f0;border:0;box-shadow:none;color:#222f3e}.tox .tox-tree .tox-trbtn:hover svg{fill:#222f3e}.tox .tox-tree .tox-trbtn:active{background:#a6ccf7;border:0;box-shadow:none;color:#222f3e}.tox .tox-tree .tox-trbtn:active svg{fill:#222f3e}.tox .tox-tree .tox-trbtn--disabled,.tox .tox-tree .tox-trbtn--disabled:hover,.tox .tox-tree .tox-trbtn:disabled,.tox .tox-tree .tox-trbtn:disabled:hover{background:0 0;border:0;box-shadow:none;color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-tree .tox-trbtn--disabled svg,.tox .tox-tree .tox-trbtn--disabled:hover svg,.tox .tox-tree .tox-trbtn:disabled svg,.tox .tox-tree .tox-trbtn:disabled:hover svg{fill:rgba(34,47,62,.5)}.tox .tox-tree .tox-trbtn--enabled,.tox .tox-tree .tox-trbtn--enabled:hover{background:#a6ccf7;border:0;box-shadow:none;color:#222f3e}.tox .tox-tree .tox-trbtn--enabled:hover>*,.tox .tox-tree .tox-trbtn--enabled>*{transform:none}.tox .tox-tree .tox-trbtn--enabled svg,.tox .tox-tree .tox-trbtn--enabled:hover svg{fill:#222f3e}.tox .tox-tree .tox-trbtn:focus:not(.tox-trbtn--disabled){color:#222f3e}.tox .tox-tree .tox-trbtn:focus:not(.tox-trbtn--disabled) svg{fill:#222f3e}.tox .tox-tree .tox-trbtn:active>*{transform:none}.tox .tox-tree .tox-trbtn--return{align-self:stretch;height:unset;width:16px}.tox .tox-tree .tox-trbtn--labeled{padding:0 4px;width:unset}.tox .tox-tree .tox-trbtn__vlabel{display:block;font-size:10px;font-weight:400;letter-spacing:-.025em;margin-bottom:4px;white-space:nowrap}.tox .tox-tree .tox-tree--directory{display:flex;flex-direction:column}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label{font-weight:700}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label .tox-mbtn{margin-left:auto}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label .tox-mbtn svg{fill:transparent}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label .tox-mbtn.tox-mbtn--active svg,.tox .tox-tree .tox-tree--directory .tox-tree--directory__label .tox-mbtn:focus svg{fill:#222f3e}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:focus .tox-mbtn svg,.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:hover .tox-mbtn svg{fill:#222f3e}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:hover:has(.tox-mbtn:hover){background-color:transparent;color:#222f3e}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:hover:has(.tox-mbtn:hover) .tox-chevron svg{fill:#222f3e}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label .tox-chevron{margin-right:6px}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:has(+.tox-tree--directory__children--growing) .tox-chevron,.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:has(+.tox-tree--directory__children--shrinking) .tox-chevron{transition:transform .5s ease-in-out}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:has(+.tox-tree--directory__children--growing) .tox-chevron,.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:has(+.tox-tree--directory__children--open) .tox-chevron{transform:rotate(90deg)}.tox .tox-tree .tox-tree--leaf__label{font-weight:400}.tox .tox-tree .tox-tree--leaf__label .tox-mbtn{margin-left:auto}.tox .tox-tree .tox-tree--leaf__label .tox-mbtn svg{fill:transparent}.tox .tox-tree .tox-tree--leaf__label .tox-mbtn.tox-mbtn--active svg,.tox .tox-tree .tox-tree--leaf__label .tox-mbtn:focus svg{fill:#222f3e}.tox .tox-tree .tox-tree--leaf__label:hover .tox-mbtn svg{fill:#222f3e}.tox .tox-tree .tox-tree--leaf__label:hover:has(.tox-mbtn:hover){background-color:transparent;color:#222f3e}.tox .tox-tree .tox-tree--leaf__label:hover:has(.tox-mbtn:hover) .tox-chevron svg{fill:#222f3e}.tox .tox-tree .tox-tree--directory__children{overflow:hidden;padding-left:16px}.tox .tox-tree .tox-tree--directory__children.tox-tree--directory__children--growing,.tox .tox-tree .tox-tree--directory__children.tox-tree--directory__children--shrinking{transition:height .5s ease-in-out}.tox .tox-tree .tox-trbtn.tox-tree--leaf__label{display:flex;justify-content:space-between}.tox .tox-revisionhistory__pane{padding:0!important}.tox .tox-revisionhistory__container{display:flex;flex-direction:column;height:100%}.tox .tox-revisionhistory{background-color:#fff;border-radius:4px;border-top:1px solid #eee;display:flex;flex:1;height:100%;margin-top:8px;overflow-x:auto;overflow-y:hidden;position:relative;width:100%}.tox .tox-revisionhistory--align-right{margin-left:auto}.tox .tox-revisionhistory__iframe{flex:1}.tox .tox-revisionhistory__sidebar{border-left:1px solid #eee;height:100%;max-width:360px}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__sidebar-title{border-bottom:1px solid #eee;color:#222f3e;font-size:20px;font-weight:400;height:60px;min-width:192px;padding:16px}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions{flex-direction:column;max-height:calc(100% - 60px);min-width:192px;overflow-y:auto;padding:8px}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions:focus{height:100%;position:relative;z-index:1}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions:focus::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0;border-radius:6px;bottom:1px;left:1px;right:1px;top:1px}@media (forced-colors:active){.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions:focus::after{border:2px solid highlight}}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions .tox-revisionhistory__card{border:1px solid #eee;border-radius:6px;color:#222f3e;cursor:pointer;font-size:14px;margin-bottom:8px;padding:8px;text-overflow:ellipsis;text-wrap:nowrap;width:100%}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions .tox-revisionhistory__card:hover{background-color:#f0f0f0;box-shadow:none;color:#222f3e}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions .tox-revisionhistory__card:focus{position:relative;z-index:1}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions .tox-revisionhistory__card:focus::after{border-radius:6px!important;border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions .tox-revisionhistory__card:focus::after{border:2px solid highlight}}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions .tox-revisionhistory__card.tox-revisionhistory__card--selected{background-color:#a6ccf7;box-shadow:none;color:#222f3e}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions .tox-revisionhistory__norevision{color:rgba(34,47,62,.7);font-size:16px;line-height:24px;padding:5px 5.5px}.tox .tox-view-wrap,.tox .tox-view-wrap__slot-container{background-color:#fff;display:flex;flex:1;flex-direction:column;height:100%}.tox .tox-view{display:flex;flex:1 1 auto;flex-direction:column;overflow:hidden}.tox .tox-view__header{align-items:center;display:flex;font-size:16px;justify-content:space-between;padding:10px 10px 2px 10px;position:relative}.tox .tox-view__label{color:#222f3e;font-weight:700;line-height:24px;padding:4px 16px;text-align:center;white-space:nowrap}.tox .tox-view__label--normal{font-size:16px}.tox .tox-view__label--large{font-size:20px}.tox .tox-view--mobile.tox-view__header,.tox .tox-view--mobile.tox-view__toolbar{padding:8px}.tox .tox-view--scrolling{flex-wrap:nowrap;overflow-x:auto}.tox .tox-view__toolbar{display:flex;flex-direction:row;gap:8px;justify-content:space-between;overflow-x:auto;padding:10px 10px 2px 10px}.tox .tox-view__toolbar__group{display:flex;flex-direction:row;gap:12px}.tox .tox-view__header-end,.tox .tox-view__header-start{display:flex}.tox .tox-view__pane{height:100%;padding:8px;position:relative;width:100%}.tox .tox-view__pane_panel{border:1px solid #eee;border-radius:6px}.tox:not([dir=rtl]) .tox-view__header .tox-view__header-end>*,.tox:not([dir=rtl]) .tox-view__header .tox-view__header-start>*{margin-left:8px}.tox[dir=rtl] .tox-view__header .tox-view__header-end>*,.tox[dir=rtl] .tox-view__header .tox-view__header-start>*{margin-right:8px}.tox .tox-well{border:1px solid #eee;border-radius:6px;padding:8px;width:100%}.tox .tox-well>:first-child{margin-top:0}.tox .tox-well>:last-child{margin-bottom:0}.tox .tox-well>:only-child{margin:0}.tox .tox-custom-editor{border:1px solid #eee;border-radius:6px;display:flex;flex:1;overflow:hidden;position:relative}.tox .tox-dialog-loading::before{background-color:rgba(0,0,0,.5);content:"";height:100%;position:absolute;width:100%;z-index:1000}.tox .tox-tab{cursor:pointer}.tox .tox-dialog__content-js{display:flex;flex:1}.tox .tox-dialog__body-content .tox-collection{display:flex;flex:1}`);
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const a = (_t, ot, B) => {
    const fn = ot === "UL" ? "InsertUnorderedList" : "InsertOrderedList";
    _t.execCommand(fn, !1, B === !1 ? null : { "list-style-type": B });
  }, c = (_t) => {
    _t.addCommand("ApplyUnorderedListStyle", (ot, B) => {
      a(_t, "UL", B["list-style-type"]);
    }), _t.addCommand("ApplyOrderedListStyle", (ot, B) => {
      a(_t, "OL", B["list-style-type"]);
    });
  }, f = (_t) => (ot) => ot.options.get(_t), g = (_t) => {
    const ot = _t.options.register;
    ot("advlist_number_styles", {
      processor: "string[]",
      default: "default,lower-alpha,lower-greek,lower-roman,upper-alpha,upper-roman".split(",")
    }), ot("advlist_bullet_styles", {
      processor: "string[]",
      default: "default,circle,square".split(",")
    });
  }, x = f("advlist_number_styles"), k = f("advlist_bullet_styles"), A = (_t) => _t == null, N = (_t) => !A(_t);
  var H = tinymce.util.Tools.resolve("tinymce.util.Tools");
  class Z {
    constructor(ot, B) {
      this.tag = ot, this.value = B;
    }
    static some(ot) {
      return new Z(!0, ot);
    }
    static none() {
      return Z.singletonNone;
    }
    fold(ot, B) {
      return this.tag ? B(this.value) : ot();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(ot) {
      return this.tag ? Z.some(ot(this.value)) : Z.none();
    }
    bind(ot) {
      return this.tag ? ot(this.value) : Z.none();
    }
    exists(ot) {
      return this.tag && ot(this.value);
    }
    forall(ot) {
      return !this.tag || ot(this.value);
    }
    filter(ot) {
      return !this.tag || ot(this.value) ? this : Z.none();
    }
    getOr(ot) {
      return this.tag ? this.value : ot;
    }
    or(ot) {
      return this.tag ? this : ot;
    }
    getOrThunk(ot) {
      return this.tag ? this.value : ot();
    }
    orThunk(ot) {
      return this.tag ? this : ot();
    }
    getOrDie(ot) {
      if (this.tag)
        return this.value;
      throw new Error(ot ?? "Called getOrDie on None");
    }
    static from(ot) {
      return N(ot) ? Z.some(ot) : Z.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(ot) {
      this.tag && ot(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Z.singletonNone = new Z(!1);
  const K = (_t, ot, B) => {
    for (let fn = 0, ze = _t.length; fn < ze; fn++) {
      const jt = _t[fn];
      if (ot(jt, fn))
        return Z.some(jt);
      if (B(jt, fn))
        break;
    }
    return Z.none();
  }, J = (_t) => /\btox\-/.test(_t.className), pe = (_t, ot) => _t.dom.isChildOf(ot, _t.getBody()), Se = (_t) => (ot) => N(ot) && _t.test(ot.nodeName), be = Se(/^(OL|UL|DL)$/), ye = Se(/^(TH|TD)$/), re = (_t, ot, B) => K(ot, (fn) => be(fn) && !J(fn), ye).exists((fn) => fn.nodeName === B && pe(_t, fn)), oe = (_t) => {
    const ot = _t.dom.getParent(_t.selection.getNode(), "ol,ul"), B = _t.dom.getStyle(ot, "listStyleType");
    return Z.from(B);
  }, U = (_t, ot) => ot !== null && !_t.dom.isEditable(ot), ve = (_t, ot) => {
    const B = _t.dom.getParent(ot, "ol,ul,dl");
    return U(_t, B) && _t.selection.isEditable();
  }, Ze = (_t, ot) => {
    const B = _t.selection.getNode();
    return ot({
      parents: _t.dom.getParents(B),
      element: B
    }), _t.on("NodeChange", ot), () => _t.off("NodeChange", ot);
  }, rt = (_t) => _t.replace(/\-/g, " ").replace(/\b\w/g, (ot) => ot.toUpperCase()), ee = (_t) => A(_t) || _t === "default" ? "" : _t, lt = (_t, ot) => (B) => {
    const fn = (jt, Tt) => {
      const Je = jt.selection.getStart(!0);
      B.setActive(re(jt, Tt, ot)), B.setEnabled(!ve(jt, Je) && jt.selection.isEditable());
    };
    return Ze(_t, (jt) => fn(_t, jt.parents));
  }, wt = (_t, ot, B, fn, ze, jt) => {
    _t.ui.registry.addSplitButton(ot, {
      tooltip: B,
      icon: ze === "OL" ? "ordered-list" : "unordered-list",
      presets: "listpreview",
      columns: 3,
      fetch: (Tt) => {
        const Je = H.map(jt, (pn) => {
          const Ro = ze === "OL" ? "num" : "bull", Rt = pn === "disc" || pn === "decimal" ? "default" : pn, Cn = ee(pn), et = rt(pn);
          return {
            type: "choiceitem",
            value: Cn,
            icon: "list-" + Ro + "-" + Rt,
            text: et
          };
        });
        Tt(Je);
      },
      onAction: () => _t.execCommand(fn),
      onItemAction: (Tt, Je) => {
        a(_t, ze, Je);
      },
      select: (Tt) => oe(_t).map((pn) => Tt === pn).getOr(!1),
      onSetup: lt(_t, ze)
    });
  }, Vt = (_t, ot, B, fn, ze, jt) => {
    _t.ui.registry.addToggleButton(ot, {
      active: !1,
      tooltip: B,
      icon: ze === "OL" ? "ordered-list" : "unordered-list",
      onSetup: lt(_t, ze),
      onAction: () => _t.queryCommandState(fn) || jt === "" ? _t.execCommand(fn) : a(_t, ze, jt)
    });
  }, Ue = (_t, ot, B, fn, ze, jt) => {
    jt.length > 1 ? wt(_t, ot, B, fn, ze, jt) : Vt(_t, ot, B, fn, ze, ee(jt[0]));
  }, Ce = (_t) => {
    Ue(_t, "numlist", "Numbered list", "InsertOrderedList", "OL", x(_t)), Ue(_t, "bullist", "Bullet list", "InsertUnorderedList", "UL", k(_t));
  };
  var Rn = () => {
    o.add("advlist", (_t) => {
      _t.hasPlugin("lists") ? (g(_t), Ce(_t), c(_t)) : console.error("Please use the Lists plugin together with the List Styles plugin.");
    });
  };
  Rn();
})();
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const a = () => /(?:[A-Za-z][A-Za-z\d.+-]{0,14}:\/\/(?:[-.~*+=!&;:'%@?^${}(),\w]+@)?|www\.|[-;:&=+$,.\w]+@)[A-Za-z\d-]+(?:\.[A-Za-z\d-]+)*(?::\d+)?(?:\/(?:[-.~*+=!;:'%@$(),\/\w]*[-~*+=%@$()\/\w])?)?(?:\?(?:[-.~*+=!&;:'%@?^${}(),\/\w]+))?(?:#(?:[-.~*+=!&;:'%@?^${}(),\/\w]+))?/g, c = (Rt) => (Cn) => Cn.options.get(Rt), f = (Rt) => {
    const Cn = Rt.options.register;
    Cn("autolink_pattern", {
      processor: "regexp",
      default: new RegExp("^" + a().source + "$", "i")
    }), Cn("link_default_target", { processor: "string" }), Cn("link_default_protocol", {
      processor: "string",
      default: "https"
    });
  }, g = c("autolink_pattern"), x = c("link_default_target"), k = c("link_default_protocol"), A = c("allow_unsafe_link_target"), N = (Rt, Cn, et) => {
    var xt;
    return et(Rt, Cn.prototype) ? !0 : ((xt = Rt.constructor) === null || xt === void 0 ? void 0 : xt.name) === Cn.name;
  }, H = (Rt) => {
    const Cn = typeof Rt;
    return Rt === null ? "null" : Cn === "object" && Array.isArray(Rt) ? "array" : Cn === "object" && N(Rt, String, (et, xt) => xt.isPrototypeOf(et)) ? "string" : Cn;
  }, Z = (Rt) => (Cn) => H(Cn) === Rt, K = (Rt) => (Cn) => Rt === Cn, J = Z("string"), pe = K(void 0), Se = (Rt) => Rt == null, be = (Rt) => !Se(Rt), ye = (Rt) => (Cn) => !Rt(Cn), re = Object.hasOwnProperty, oe = (Rt, Cn) => re.call(Rt, Cn), U = (Rt, Cn, et) => Rt.length >= Cn.length && Rt.substr(et, et + Cn.length) === Cn, ve = (Rt, Cn, et = 0, xt) => {
    const X = Rt.indexOf(Cn, et);
    return X !== -1 ? pe(xt) ? !0 : X + Cn.length <= xt : !1;
  }, Ze = (Rt, Cn) => U(Rt, Cn, 0), rt = "\uFEFF", ee = (Rt) => Rt === rt, lt = (Rt) => Rt.replace(/\uFEFF/g, "");
  var wt = tinymce.util.Tools.resolve("tinymce.dom.TextSeeker");
  const Vt = (Rt) => Rt.nodeType === 3, Ue = (Rt) => Rt.nodeType === 1, Ce = (Rt) => /^[(\[{ \u00a0]$/.test(Rt), Rn = (Rt) => /^([A-Za-z][A-Za-z\d.+-]*:\/\/)|mailto:/.test(Rt), _t = (Rt) => /[?!,.;:]/.test(Rt), ot = (Rt, Cn, et) => {
    for (let xt = Cn - 1; xt >= 0; xt--) {
      const X = Rt.charAt(xt);
      if (!ee(X) && et(X))
        return xt;
    }
    return -1;
  }, B = (Rt, Cn) => {
    let et = Rt, xt = Cn;
    for (; Ue(et) && et.childNodes[xt]; )
      et = et.childNodes[xt], xt = Vt(et) ? et.data.length : et.childNodes.length;
    return {
      container: et,
      offset: xt
    };
  }, fn = (Rt, Cn) => {
    var et;
    const xt = Rt.schema.getVoidElements(), X = g(Rt), { dom: ds, selection: So } = Rt;
    if (ds.getParent(So.getNode(), "a[href]") !== null)
      return null;
    const At = So.getRng(), Pt = wt(ds, (vt) => ds.isBlock(vt) || oe(xt, vt.nodeName.toLowerCase()) || ds.getContentEditable(vt) === "false"), {
      container: Hn,
      offset: Nt
    } = B(At.endContainer, At.endOffset), Vn = (et = ds.getParent(Hn, ds.isBlock)) !== null && et !== void 0 ? et : ds.getRoot(), tn = Pt.backwards(Hn, Nt + Cn, (vt, oo) => {
      const Dn = vt.data, ao = ot(Dn, oo, ye(Ce));
      return ao === -1 || _t(Dn[ao]) ? ao : ao + 1;
    }, Vn);
    if (!tn)
      return null;
    let je = tn.container;
    const An = Pt.backwards(tn.container, tn.offset, (vt, oo) => {
      je = vt;
      const Dn = ot(vt.data, oo, Ce);
      return Dn === -1 ? Dn : Dn + 1;
    }, Vn), qn = ds.createRng();
    An ? qn.setStart(An.container, An.offset) : qn.setStart(je, 0), qn.setEnd(tn.container, tn.offset);
    const zt = lt(qn.toString()).match(X);
    if (zt) {
      let vt = zt[0];
      return Ze(vt, "www.") ? vt = k(Rt) + "://" + vt : ve(vt, "@") && !Rn(vt) && (vt = "mailto:" + vt), {
        rng: qn,
        url: vt
      };
    } else
      return null;
  }, ze = (Rt, Cn) => {
    const { dom: et, selection: xt } = Rt, { rng: X, url: ds } = Cn, So = xt.getBookmark();
    xt.setRng(X);
    const At = "createlink", Pt = {
      command: At,
      ui: !1,
      value: ds
    };
    if (!Rt.dispatch("BeforeExecCommand", Pt).isDefaultPrevented()) {
      Rt.getDoc().execCommand(At, !1, ds), Rt.dispatch("ExecCommand", Pt);
      const Nt = x(Rt);
      if (J(Nt)) {
        const Vn = xt.getNode();
        et.setAttrib(Vn, "target", Nt), Nt === "_blank" && !A(Rt) && et.setAttrib(Vn, "rel", "noopener");
      }
    }
    xt.moveToBookmark(So), Rt.nodeChanged();
  }, jt = (Rt) => {
    const Cn = fn(Rt, -1);
    be(Cn) && ze(Rt, Cn);
  }, Tt = jt, Je = (Rt) => {
    const Cn = fn(Rt, 0);
    be(Cn) && ze(Rt, Cn);
  }, pn = (Rt) => {
    Rt.on("keydown", (Cn) => {
      Cn.keyCode === 13 && !Cn.isDefaultPrevented() && Je(Rt);
    }), Rt.on("keyup", (Cn) => {
      Cn.keyCode === 32 ? jt(Rt) : (Cn.keyCode === 48 && Cn.shiftKey || Cn.keyCode === 221) && Tt(Rt);
    });
  };
  var Ro = () => {
    o.add("autolink", (Rt) => {
      f(Rt), pn(Rt);
    });
  };
  Ro();
})();
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const a = (A, N) => {
    A.focus(), A.undoManager.transact(() => {
      A.setContent(N);
    }), A.selection.setCursorLocation(), A.nodeChanged();
  }, c = (A) => A.getContent({ source_view: !0 }), f = (A) => {
    const N = c(A);
    A.windowManager.open({
      title: "Source Code",
      size: "large",
      body: {
        type: "panel",
        items: [{
          type: "textarea",
          name: "code"
        }]
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: { code: N },
      onSubmit: (H) => {
        a(A, H.getData().code), H.close();
      }
    });
  }, g = (A) => {
    A.addCommand("mceCodeEditor", () => {
      f(A);
    });
  }, x = (A) => {
    const N = () => A.execCommand("mceCodeEditor");
    A.ui.registry.addButton("code", {
      icon: "sourcecode",
      tooltip: "Source code",
      onAction: N
    }), A.ui.registry.addMenuItem("code", {
      icon: "sourcecode",
      text: "Source code",
      onAction: N
    });
  };
  var k = () => {
    o.add("code", (A) => (g(A), x(A), {}));
  };
  k();
})();
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const a = (it, kt, xn) => {
    var hn;
    return xn(it, kt.prototype) ? !0 : ((hn = it.constructor) === null || hn === void 0 ? void 0 : hn.name) === kt.name;
  }, c = (it) => {
    const kt = typeof it;
    return it === null ? "null" : kt === "object" && Array.isArray(it) ? "array" : kt === "object" && a(it, String, (xn, hn) => hn.isPrototypeOf(xn)) ? "string" : kt;
  }, f = (it) => (kt) => c(kt) === it, g = (it) => (kt) => typeof kt === it, x = f("string"), k = g("boolean"), A = (it) => it == null, N = (it) => !A(it), H = g("function"), Z = g("number"), K = (it, kt) => (xn) => it(kt(xn)), pe = ((it) => () => it)(!1);
  class Se {
    constructor(kt, xn) {
      this.tag = kt, this.value = xn;
    }
    static some(kt) {
      return new Se(!0, kt);
    }
    static none() {
      return Se.singletonNone;
    }
    fold(kt, xn) {
      return this.tag ? xn(this.value) : kt();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(kt) {
      return this.tag ? Se.some(kt(this.value)) : Se.none();
    }
    bind(kt) {
      return this.tag ? kt(this.value) : Se.none();
    }
    exists(kt) {
      return this.tag && kt(this.value);
    }
    forall(kt) {
      return !this.tag || kt(this.value);
    }
    filter(kt) {
      return !this.tag || kt(this.value) ? this : Se.none();
    }
    getOr(kt) {
      return this.tag ? this.value : kt;
    }
    or(kt) {
      return this.tag ? this : kt;
    }
    getOrThunk(kt) {
      return this.tag ? this.value : kt();
    }
    orThunk(kt) {
      return this.tag ? this : kt();
    }
    getOrDie(kt) {
      if (this.tag)
        return this.value;
      throw new Error(kt ?? "Called getOrDie on None");
    }
    static from(kt) {
      return N(kt) ? Se.some(kt) : Se.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(kt) {
      this.tag && kt(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Se.singletonNone = new Se(!1);
  const be = (it, kt) => {
    const xn = it.length, hn = new Array(xn);
    for (let Do = 0; Do < xn; Do++) {
      const Ss = it[Do];
      hn[Do] = kt(Ss, Do);
    }
    return hn;
  }, ye = (it, kt) => {
    for (let xn = 0, hn = it.length; xn < hn; xn++) {
      const Do = it[xn];
      kt(Do, xn);
    }
  }, re = (it, kt) => {
    const xn = [];
    for (let hn = 0, Do = it.length; hn < Do; hn++) {
      const Ss = it[hn];
      kt(Ss, hn) && xn.push(Ss);
    }
    return xn;
  }, oe = 9, U = 11, ve = 1, Ze = 3, rt = (it, kt) => {
    const hn = (kt || document).createElement("div");
    if (hn.innerHTML = it, !hn.hasChildNodes() || hn.childNodes.length > 1) {
      const Do = "HTML does not have a single root node";
      throw console.error(Do, it), new Error(Do);
    }
    return wt(hn.childNodes[0]);
  }, ee = (it, kt) => {
    const hn = (kt || document).createElement(it);
    return wt(hn);
  }, lt = (it, kt) => {
    const hn = (kt || document).createTextNode(it);
    return wt(hn);
  }, wt = (it) => {
    if (it == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: it };
  }, Ue = {
    fromHtml: rt,
    fromTag: ee,
    fromText: lt,
    fromDom: wt,
    fromPoint: (it, kt, xn) => Se.from(it.dom.elementFromPoint(kt, xn)).map(wt)
  }, Ce = (it, kt) => {
    const xn = it.dom;
    if (xn.nodeType !== ve)
      return !1;
    {
      const hn = xn;
      if (hn.matches !== void 0)
        return hn.matches(kt);
      if (hn.msMatchesSelector !== void 0)
        return hn.msMatchesSelector(kt);
      if (hn.webkitMatchesSelector !== void 0)
        return hn.webkitMatchesSelector(kt);
      if (hn.mozMatchesSelector !== void 0)
        return hn.mozMatchesSelector(kt);
      throw new Error("Browser lacks native selectors");
    }
  };
  typeof window < "u" || Function("return this;")();
  const Rn = (it) => it.dom.nodeName.toLowerCase(), _t = (it) => it.dom.nodeType, ot = (it) => (kt) => _t(kt) === it, B = ot(ve), fn = ot(Ze), ze = ot(oe), jt = ot(U), Tt = (it) => (kt) => B(kt) && Rn(kt) === it, Je = (it) => Ue.fromDom(it.dom.ownerDocument), pn = (it) => ze(it) ? it : Je(it), Ro = (it) => Se.from(it.dom.parentNode).map(Ue.fromDom), Rt = (it) => be(it.dom.childNodes, Ue.fromDom), Cn = (it, kt, xn) => {
    if (x(xn) || k(xn) || Z(xn))
      it.setAttribute(kt, xn + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", kt, ":: Value ", xn, ":: Element ", it), new Error("Attribute value was not simple");
  }, et = (it, kt, xn) => {
    Cn(it.dom, kt, xn);
  }, xt = (it, kt) => {
    it.dom.removeAttribute(kt);
  }, X = (it) => jt(it) && N(it.dom.host), So = H(Element.prototype.attachShadow) && H(Node.prototype.getRootNode) ? (it) => Ue.fromDom(it.dom.getRootNode()) : pn, At = (it) => {
    const kt = So(it);
    return X(kt) ? Se.some(kt) : Se.none();
  }, Pt = (it) => Ue.fromDom(it.dom.host), Hn = (it) => {
    const kt = fn(it) ? it.dom.parentNode : it.dom;
    if (kt == null || kt.ownerDocument === null)
      return !1;
    const xn = kt.ownerDocument;
    return At(Ue.fromDom(kt)).fold(() => xn.body.contains(kt), K(Hn, Pt));
  }, Nt = (it, kt, xn) => {
    let hn = it.dom;
    const Do = H(xn) ? xn : pe;
    for (; hn.parentNode; ) {
      hn = hn.parentNode;
      const Ss = Ue.fromDom(hn);
      if (kt(Ss))
        return Se.some(Ss);
      if (Do(Ss))
        break;
    }
    return Se.none();
  }, Vn = (it, kt, xn) => Nt(it, (hn) => Ce(hn, kt), xn), tn = (it) => it.style !== void 0 && H(it.style.getPropertyValue), je = (it, kt) => {
    const xn = it.dom, Do = window.getComputedStyle(xn).getPropertyValue(kt);
    return Do === "" && !Hn(it) ? An(xn, kt) : Do;
  }, An = (it, kt) => tn(it) ? it.style.getPropertyValue(kt) : "", qn = (it) => je(it, "direction") === "rtl" ? "rtl" : "ltr", on = (it, kt) => re(Rt(it), kt), zt = (it, kt) => on(it, (xn) => Ce(xn, kt)), vt = (it) => Ro(it).filter(B), oo = (it, kt) => (kt ? Vn(it, "ol,ul") : Se.some(it)).getOr(it), Dn = Tt("li"), ao = (it, kt, xn) => {
    ye(kt, (hn) => {
      const Do = Ue.fromDom(hn), Ss = Dn(Do), pr = oo(Do, Ss);
      vt(pr).each((Ms) => {
        if (it.setStyle(pr.dom, "direction", null), qn(Ms) === xn ? xt(pr, "dir") : et(pr, "dir", xn), qn(pr) !== xn && it.setStyle(pr.dom, "direction", xn), Ss) {
          const qt = zt(pr, "li[dir],li[style]");
          ye(qt, (Ko) => {
            xt(Ko, "dir"), it.setStyle(Ko.dom, "direction", null);
          });
        }
      });
    });
  }, xs = (it, kt) => {
    it.selection.isEditable() && (ao(it.dom, it.selection.getSelectedBlocks(), kt), it.nodeChanged());
  }, rs = (it) => {
    it.addCommand("mceDirectionLTR", () => {
      xs(it, "ltr");
    }), it.addCommand("mceDirectionRTL", () => {
      xs(it, "rtl");
    });
  }, Qo = (it, kt) => (xn) => {
    const hn = (Do) => {
      const Ss = Ue.fromDom(Do.element);
      xn.setActive(qn(Ss) === kt), xn.setEnabled(it.selection.isEditable());
    };
    return it.on("NodeChange", hn), xn.setEnabled(it.selection.isEditable()), () => it.off("NodeChange", hn);
  }, os = (it) => {
    it.ui.registry.addToggleButton("ltr", {
      tooltip: "Left to right",
      icon: "ltr",
      onAction: () => it.execCommand("mceDirectionLTR"),
      onSetup: Qo(it, "ltr")
    }), it.ui.registry.addToggleButton("rtl", {
      tooltip: "Right to left",
      icon: "rtl",
      onAction: () => it.execCommand("mceDirectionRTL"),
      onSetup: Qo(it, "rtl")
    });
  };
  var zs = () => {
    o.add("directionality", (it) => {
      rs(it), os(it);
    });
  };
  zs();
})();
(function() {
  const o = (me) => {
    let Te = me;
    return {
      get: () => Te,
      set: (eo) => {
        Te = eo;
      }
    };
  };
  var a = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const c = (me) => ({ isFullscreen: () => me.get() !== null }), f = (me, Te, nt) => {
    var ft;
    return nt(me, Te.prototype) ? !0 : ((ft = me.constructor) === null || ft === void 0 ? void 0 : ft.name) === Te.name;
  }, g = (me) => {
    const Te = typeof me;
    return me === null ? "null" : Te === "object" && Array.isArray(me) ? "array" : Te === "object" && f(me, String, (nt, ft) => ft.isPrototypeOf(nt)) ? "string" : Te;
  }, x = (me) => (Te) => g(Te) === me, k = (me) => (Te) => typeof Te === me, A = (me) => (Te) => me === Te, N = x("string"), H = x("object"), Z = x("array"), K = A(null), J = k("boolean"), pe = A(void 0), Se = (me) => me == null, be = (me) => !Se(me), ye = k("function"), re = k("number"), oe = () => {
  }, U = (me, Te) => (...nt) => me(Te.apply(null, nt)), ve = (me, Te) => (nt) => me(Te(nt)), Ze = (me) => () => me;
  function rt(me, ...Te) {
    return (...nt) => {
      const ft = Te.concat(nt);
      return me.apply(null, ft);
    };
  }
  const ee = Ze(!1), lt = Ze(!0);
  class wt {
    constructor(Te, nt) {
      this.tag = Te, this.value = nt;
    }
    static some(Te) {
      return new wt(!0, Te);
    }
    static none() {
      return wt.singletonNone;
    }
    fold(Te, nt) {
      return this.tag ? nt(this.value) : Te();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(Te) {
      return this.tag ? wt.some(Te(this.value)) : wt.none();
    }
    bind(Te) {
      return this.tag ? Te(this.value) : wt.none();
    }
    exists(Te) {
      return this.tag && Te(this.value);
    }
    forall(Te) {
      return !this.tag || Te(this.value);
    }
    filter(Te) {
      return !this.tag || Te(this.value) ? this : wt.none();
    }
    getOr(Te) {
      return this.tag ? this.value : Te;
    }
    or(Te) {
      return this.tag ? this : Te;
    }
    getOrThunk(Te) {
      return this.tag ? this.value : Te();
    }
    orThunk(Te) {
      return this.tag ? this : Te();
    }
    getOrDie(Te) {
      if (this.tag)
        return this.value;
      throw new Error(Te ?? "Called getOrDie on None");
    }
    static from(Te) {
      return be(Te) ? wt.some(Te) : wt.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(Te) {
      this.tag && Te(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  wt.singletonNone = new wt(!1);
  const Vt = Array.prototype.push, Ue = (me, Te) => {
    const nt = me.length, ft = new Array(nt);
    for (let eo = 0; eo < nt; eo++) {
      const es = me[eo];
      ft[eo] = Te(es, eo);
    }
    return ft;
  }, Ce = (me, Te) => {
    for (let nt = 0, ft = me.length; nt < ft; nt++) {
      const eo = me[nt];
      Te(eo, nt);
    }
  }, Rn = (me, Te) => {
    const nt = [];
    for (let ft = 0, eo = me.length; ft < eo; ft++) {
      const es = me[ft];
      Te(es, ft) && nt.push(es);
    }
    return nt;
  }, _t = (me, Te, nt) => {
    for (let ft = 0, eo = me.length; ft < eo; ft++) {
      const es = me[ft];
      if (Te(es, ft))
        return wt.some(es);
      if (nt(es, ft))
        break;
    }
    return wt.none();
  }, ot = (me, Te) => _t(me, Te, ee), B = (me) => {
    const Te = [];
    for (let nt = 0, ft = me.length; nt < ft; ++nt) {
      if (!Z(me[nt]))
        throw new Error("Arr.flatten item " + nt + " was not an array, input: " + me);
      Vt.apply(Te, me[nt]);
    }
    return Te;
  }, fn = (me, Te) => B(Ue(me, Te)), ze = (me, Te) => Te >= 0 && Te < me.length ? wt.some(me[Te]) : wt.none(), jt = (me) => ze(me, 0), Tt = (me, Te) => {
    for (let nt = 0; nt < me.length; nt++) {
      const ft = Te(me[nt], nt);
      if (ft.isSome())
        return ft;
    }
    return wt.none();
  }, Je = (me, Te, nt) => me.isSome() && Te.isSome() ? wt.some(nt(me.getOrDie(), Te.getOrDie())) : wt.none(), pn = (me) => {
    const Te = o(wt.none()), nt = () => Te.get().each(me);
    return {
      clear: () => {
        nt(), Te.set(wt.none());
      },
      isSet: () => Te.get().isSome(),
      get: () => Te.get(),
      set: (Ha) => {
        nt(), Te.set(wt.some(Ha));
      }
    };
  }, Ro = () => pn((me) => me.unbind()), Rt = () => {
    const me = pn(oe);
    return {
      ...me,
      on: (nt) => me.get().each(nt)
    };
  }, Cn = (me, Te) => {
    let nt = null;
    return {
      cancel: () => {
        K(nt) || (clearTimeout(nt), nt = null);
      },
      throttle: (...es) => {
        K(nt) && (nt = setTimeout(() => {
          nt = null, me.apply(null, es);
        }, Te));
      }
    };
  }, et = Object.keys, xt = (me, Te) => {
    const nt = et(me);
    for (let ft = 0, eo = nt.length; ft < eo; ft++) {
      const es = nt[ft], Sr = me[es];
      Te(Sr, es);
    }
  }, X = typeof window < "u" ? window : Function("return this;")(), ds = (me, Te) => {
    let nt = Te ?? X;
    for (let ft = 0; ft < me.length && nt !== void 0 && nt !== null; ++ft)
      nt = nt[me[ft]];
    return nt;
  }, So = (me, Te) => {
    const nt = me.split(".");
    return ds(nt, Te);
  }, At = (me, Te) => So(me, Te), Pt = (me, Te) => {
    const nt = At(me, Te);
    if (nt == null)
      throw new Error(me + " not available on this browser");
    return nt;
  }, Hn = Object.getPrototypeOf, Nt = (me) => Pt("HTMLElement", me), Vn = (me) => {
    const Te = So("ownerDocument.defaultView", me);
    return H(me) && (Nt(Te).prototype.isPrototypeOf(me) || /^HTML\w*Element$/.test(Hn(me).constructor.name));
  }, tn = 9, je = 11, An = 1, qn = 3, on = (me) => me.dom.nodeType, zt = (me) => (Te) => on(Te) === me, vt = (me) => oo(me) && Vn(me.dom), oo = zt(An), Dn = zt(qn), ao = zt(tn), xs = zt(je), rs = (me, Te, nt) => {
    if (N(nt) || J(nt) || re(nt))
      me.setAttribute(Te, nt + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", Te, ":: Value ", nt, ":: Element ", me), new Error("Attribute value was not simple");
  }, Qo = (me, Te, nt) => {
    rs(me.dom, Te, nt);
  }, os = (me, Te) => {
    const nt = me.dom.getAttribute(Te);
    return nt === null ? void 0 : nt;
  }, zs = (me, Te) => {
    me.dom.removeAttribute(Te);
  }, it = (me) => me.dom.classList !== void 0, kt = (me, Te) => it(me) && me.dom.classList.contains(Te), xn = (me, Te, nt = 0, ft) => {
    const eo = me.indexOf(Te, nt);
    return eo !== -1 ? pe(ft) ? !0 : eo + Te.length <= ft : !1;
  }, hn = (me) => me.style !== void 0 && ye(me.style.getPropertyValue), Do = (me, Te) => {
    const ft = (Te || document).createElement("div");
    if (ft.innerHTML = me, !ft.hasChildNodes() || ft.childNodes.length > 1) {
      const eo = "HTML does not have a single root node";
      throw console.error(eo, me), new Error(eo);
    }
    return ta(ft.childNodes[0]);
  }, Ss = (me, Te) => {
    const ft = (Te || document).createElement(me);
    return ta(ft);
  }, pr = (me, Te) => {
    const ft = (Te || document).createTextNode(me);
    return ta(ft);
  }, ta = (me) => {
    if (me == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: me };
  }, hr = {
    fromHtml: Do,
    fromTag: Ss,
    fromText: pr,
    fromDom: ta,
    fromPoint: (me, Te, nt) => wt.from(me.dom.elementFromPoint(Te, nt)).map(ta)
  }, qt = (me, Te) => {
    const nt = me.dom;
    if (nt.nodeType !== An)
      return !1;
    {
      const ft = nt;
      if (ft.matches !== void 0)
        return ft.matches(Te);
      if (ft.msMatchesSelector !== void 0)
        return ft.msMatchesSelector(Te);
      if (ft.webkitMatchesSelector !== void 0)
        return ft.webkitMatchesSelector(Te);
      if (ft.mozMatchesSelector !== void 0)
        return ft.mozMatchesSelector(Te);
      throw new Error("Browser lacks native selectors");
    }
  }, Ko = (me) => me.nodeType !== An && me.nodeType !== tn && me.nodeType !== je || me.childElementCount === 0, Lr = (me, Te) => {
    const nt = document;
    return Ko(nt) ? [] : Ue(nt.querySelectorAll(me), hr.fromDom);
  }, ha = (me, Te) => me.dom === Te.dom, ia = (me) => hr.fromDom(me.dom.ownerDocument), na = (me) => ao(me) ? me : ia(me), ks = (me) => wt.from(me.dom.parentNode).map(hr.fromDom), xa = (me, Te) => {
    const nt = ye(Te) ? Te : ee;
    let ft = me.dom;
    const eo = [];
    for (; ft.parentNode !== null && ft.parentNode !== void 0; ) {
      const es = ft.parentNode, Sr = hr.fromDom(es);
      if (eo.push(Sr), nt(Sr) === !0)
        break;
      ft = es;
    }
    return eo;
  }, la = (me) => {
    const Te = (nt) => Rn(nt, (ft) => !ha(me, ft));
    return ks(me).map(Xn).map(Te).getOr([]);
  }, _s = (me) => wt.from(me.dom.nextSibling).map(hr.fromDom), Xn = (me) => Ue(me.dom.childNodes, hr.fromDom), wr = (me) => xs(me) && be(me.dom.host), Ke = ye(Element.prototype.attachShadow) && ye(Node.prototype.getRootNode), ht = Ze(Ke), gn = Ke ? (me) => hr.fromDom(me.dom.getRootNode()) : na, En = (me) => {
    const Te = gn(me);
    return wr(Te) ? wt.some(Te) : wt.none();
  }, Ao = (me) => hr.fromDom(me.dom.host), as = (me) => {
    if (ht() && be(me.target)) {
      const Te = hr.fromDom(me.target);
      if (oo(Te) && Yr(Te) && me.composed && me.composedPath) {
        const nt = me.composedPath();
        if (nt)
          return jt(nt);
      }
    }
    return wt.from(me.target);
  }, Yr = (me) => be(me.dom.shadowRoot), Xr = (me) => {
    const Te = Dn(me) ? me.dom.parentNode : me.dom;
    if (Te == null || Te.ownerDocument === null)
      return !1;
    const nt = Te.ownerDocument;
    return En(hr.fromDom(Te)).fold(() => nt.body.contains(Te), ve(Xr, Ao));
  }, Tr = (me) => {
    const Te = me.dom.body;
    if (Te == null)
      throw new Error("Body is not available yet");
    return hr.fromDom(Te);
  }, Ne = (me, Te, nt) => {
    if (!N(nt))
      throw console.error("Invalid call to CSS.set. Property ", Te, ":: Value ", nt, ":: Element ", me), new Error("CSS value must be a string: " + nt);
    hn(me) && me.style.setProperty(Te, nt);
  }, Ae = (me, Te, nt) => {
    const ft = me.dom;
    Ne(ft, Te, nt);
  }, ct = (me, Te) => {
    const nt = me.dom;
    xt(Te, (ft, eo) => {
      Ne(nt, eo, ft);
    });
  }, Ct = (me, Te) => {
    const nt = me.dom, eo = window.getComputedStyle(nt).getPropertyValue(Te);
    return eo === "" && !Xr(me) ? Kn(nt, Te) : eo;
  }, Kn = (me, Te) => hn(me) ? me.style.getPropertyValue(Te) : "", lo = (me, Te, nt, ft, eo, es, Sr) => ({
    target: me,
    x: Te,
    y: nt,
    stop: ft,
    prevent: eo,
    kill: es,
    raw: Sr
  }), Bo = (me) => {
    const Te = hr.fromDom(as(me).getOr(me.target)), nt = () => me.stopPropagation(), ft = () => me.preventDefault(), eo = U(ft, nt);
    return lo(Te, me.clientX, me.clientY, nt, ft, eo, me);
  }, Xs = (me, Te) => (nt) => {
    me(nt) && Te(Bo(nt));
  }, $e = (me, Te, nt, ft, eo) => {
    const es = Xs(nt, ft);
    return me.dom.addEventListener(Te, es, eo), { unbind: rt(Pe, me, Te, es, eo) };
  }, Oo = (me, Te, nt, ft) => $e(me, Te, nt, ft, !1), Pe = (me, Te, nt, ft) => {
    me.dom.removeEventListener(Te, nt, ft);
  }, Ie = lt, Lt = (me, Te, nt) => Oo(me, Te, Ie, nt), Zt = (me) => {
    let Te = !1, nt;
    return (...ft) => (Te || (Te = !0, nt = me.apply(null, ft)), nt);
  }, kn = (me, Te, nt, ft) => {
    const eo = me.isiOS() && /ipad/i.test(nt) === !0, es = me.isiOS() && !eo, Sr = me.isiOS() || me.isAndroid(), Ha = Sr || ft("(pointer:coarse)"), is = eo || !es && Sr && ft("(min-device-width:768px)"), _a = es || Sr && !is, Rr = Te.isSafari() && me.isiOS() && /safari/i.test(nt) === !1, ua = !_a && !is && !Rr;
    return {
      isiPad: Ze(eo),
      isiPhone: Ze(es),
      isTablet: Ze(is),
      isPhone: Ze(_a),
      isTouch: Ze(Ha),
      isAndroid: me.isAndroid,
      isiOS: me.isiOS,
      isWebView: Ze(Rr),
      isDesktop: Ze(ua)
    };
  }, Jn = (me, Te) => {
    for (let nt = 0; nt < me.length; nt++) {
      const ft = me[nt];
      if (ft.test(Te))
        return ft;
    }
  }, Zn = (me, Te) => {
    const nt = Jn(me, Te);
    if (!nt)
      return {
        major: 0,
        minor: 0
      };
    const ft = (eo) => Number(Te.replace(nt, "$" + eo));
    return co(ft(1), ft(2));
  }, Gn = (me, Te) => {
    const nt = String(Te).toLowerCase();
    return me.length === 0 ? Qn() : Zn(me, nt);
  }, Qn = () => co(0, 0), co = (me, Te) => ({
    major: me,
    minor: Te
  }), Jo = {
    nu: co,
    detect: Gn,
    unknown: Qn
  }, Gs = (me, Te) => Tt(Te.brands, (nt) => {
    const ft = nt.brand.toLowerCase();
    return ot(me, (eo) => {
      var es;
      return ft === ((es = eo.brand) === null || es === void 0 ? void 0 : es.toLowerCase());
    }).map((eo) => ({
      current: eo.name,
      version: Jo.nu(parseInt(nt.version, 10), 0)
    }));
  }), Wa = (me, Te) => {
    const nt = String(Te).toLowerCase();
    return ot(me, (ft) => ft.search(nt));
  }, Ti = (me, Te) => Wa(me, Te).map((nt) => {
    const ft = Jo.detect(nt.versionRegexes, Te);
    return {
      current: nt.name,
      version: ft
    };
  }), Ai = (me, Te) => Wa(me, Te).map((nt) => {
    const ft = Jo.detect(nt.versionRegexes, Te);
    return {
      current: nt.name,
      version: ft
    };
  }), ko = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, Zo = (me) => (Te) => xn(Te, me), Rs = [
    {
      name: "Edge",
      versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
      search: (me) => xn(me, "edge/") && xn(me, "chrome") && xn(me, "safari") && xn(me, "applewebkit")
    },
    {
      name: "Chromium",
      brand: "Chromium",
      versionRegexes: [
        /.*?chrome\/([0-9]+)\.([0-9]+).*/,
        ko
      ],
      search: (me) => xn(me, "chrome") && !xn(me, "chromeframe")
    },
    {
      name: "IE",
      versionRegexes: [
        /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
        /.*?rv:([0-9]+)\.([0-9]+).*/
      ],
      search: (me) => xn(me, "msie") || xn(me, "trident")
    },
    {
      name: "Opera",
      versionRegexes: [
        ko,
        /.*?opera\/([0-9]+)\.([0-9]+).*/
      ],
      search: Zo("opera")
    },
    {
      name: "Firefox",
      versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
      search: Zo("firefox")
    },
    {
      name: "Safari",
      versionRegexes: [
        ko,
        /.*?cpu os ([0-9]+)_([0-9]+).*/
      ],
      search: (me) => (xn(me, "safari") || xn(me, "mobile/")) && xn(me, "applewebkit")
    }
  ], Ba = [
    {
      name: "Windows",
      search: Zo("win"),
      versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "iOS",
      search: (me) => xn(me, "iphone") || xn(me, "ipad"),
      versionRegexes: [
        /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
        /.*cpu os ([0-9]+)_([0-9]+).*/,
        /.*cpu iphone os ([0-9]+)_([0-9]+).*/
      ]
    },
    {
      name: "Android",
      search: Zo("android"),
      versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "macOS",
      search: Zo("mac os x"),
      versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    },
    {
      name: "Linux",
      search: Zo("linux"),
      versionRegexes: []
    },
    {
      name: "Solaris",
      search: Zo("sunos"),
      versionRegexes: []
    },
    {
      name: "FreeBSD",
      search: Zo("freebsd"),
      versionRegexes: []
    },
    {
      name: "ChromeOS",
      search: Zo("cros"),
      versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }
  ], ca = {
    browsers: Ze(Rs),
    oses: Ze(Ba)
  }, gr = "Edge", Qs = "Chromium", ii = "IE", xc = "Opera", Is = "Firefox", ka = "Safari", li = () => Qr({
    current: void 0,
    version: Jo.unknown()
  }), Qr = (me) => {
    const Te = me.current, nt = me.version, ft = (eo) => () => Te === eo;
    return {
      current: Te,
      version: nt,
      isEdge: ft(gr),
      isChromium: ft(Qs),
      isIE: ft(ii),
      isOpera: ft(xc),
      isFirefox: ft(Is),
      isSafari: ft(ka)
    };
  }, Oi = {
    unknown: li,
    nu: Qr,
    edge: Ze(gr),
    chromium: Ze(Qs),
    ie: Ze(ii),
    opera: Ze(xc),
    firefox: Ze(Is),
    safari: Ze(ka)
  }, cl = "Windows", Za = "iOS", Di = "Android", ji = "Linux", uu = "macOS", vi = "Solaris", Bl = "FreeBSD", La = "ChromeOS", Wi = () => Xl({
    current: void 0,
    version: Jo.unknown()
  }), Xl = (me) => {
    const Te = me.current, nt = me.version, ft = (eo) => () => Te === eo;
    return {
      current: Te,
      version: nt,
      isWindows: ft(cl),
      isiOS: ft(Za),
      isAndroid: ft(Di),
      isMacOS: ft(uu),
      isLinux: ft(ji),
      isSolaris: ft(vi),
      isFreeBSD: ft(Bl),
      isChromeOS: ft(La)
    };
  }, wc = {
    unknown: Wi,
    nu: Xl,
    windows: Ze(cl),
    ios: Ze(Za),
    android: Ze(Di),
    linux: Ze(ji),
    macos: Ze(uu),
    solaris: Ze(vi),
    freebsd: Ze(Bl),
    chromeos: Ze(La)
  }, du = { detect: (me, Te, nt) => {
    const ft = ca.browsers(), eo = ca.oses(), es = Te.bind((is) => Gs(ft, is)).orThunk(() => Ti(ft, me)).fold(Oi.unknown, Oi.nu), Sr = Ai(eo, me).fold(wc.unknown, wc.nu), Ha = kn(Sr, es, me, nt);
    return {
      browser: es,
      os: Sr,
      deviceType: Ha
    };
  } }, bi = (me) => window.matchMedia(me).matches;
  let Fu = Zt(() => du.detect(navigator.userAgent, wt.from(navigator.userAgentData), bi));
  const ie = () => Fu(), Oe = (me, Te) => ({
    left: me,
    top: Te,
    translate: (ft, eo) => Oe(me + ft, Te + eo)
  }), Ge = Oe, Dt = (me) => {
    const Te = me !== void 0 ? me.dom : document, nt = Te.body.scrollLeft || Te.documentElement.scrollLeft, ft = Te.body.scrollTop || Te.documentElement.scrollTop;
    return Ge(nt, ft);
  }, Xt = (me) => {
    const Te = me === void 0 ? window : me;
    return ie().browser.isFirefox() ? wt.none() : wt.from(Te.visualViewport);
  }, jn = (me, Te, nt, ft) => ({
    x: me,
    y: Te,
    width: nt,
    height: ft,
    right: me + nt,
    bottom: Te + ft
  }), ss = (me) => {
    const Te = me === void 0 ? window : me, nt = Te.document, ft = Dt(hr.fromDom(nt));
    return Xt(Te).fold(() => {
      const eo = Te.document.documentElement, es = eo.clientWidth, Sr = eo.clientHeight;
      return jn(ft.left, ft.top, es, Sr);
    }, (eo) => jn(Math.max(eo.pageLeft, ft.left), Math.max(eo.pageTop, ft.top), eo.width, eo.height));
  }, hs = (me, Te, nt) => Xt(nt).map((ft) => {
    const eo = (es) => Te(Bo(es));
    return ft.addEventListener(me, eo), { unbind: () => ft.removeEventListener(me, eo) };
  }).getOrThunk(() => ({ unbind: oe }));
  var Uo = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), qs = tinymce.util.Tools.resolve("tinymce.Env");
  const Ar = (me, Te) => {
    me.dispatch("FullscreenStateChanged", { state: Te }), me.dispatch("ResizeEditor");
  }, sn = (me) => (Te) => Te.options.get(me), md = (me) => {
    const Te = me.options.register;
    Te("fullscreen_native", {
      processor: "boolean",
      default: !1
    });
  }, tr = sn("fullscreen_native"), Y = (me) => {
    const Te = hr.fromDom(me.getElement());
    return En(Te).map(Ao).getOrThunk(() => Tr(ia(Te)));
  }, ge = (me) => me.fullscreenElement !== void 0 ? me.fullscreenElement : me.msFullscreenElement !== void 0 ? me.msFullscreenElement : me.webkitFullscreenElement !== void 0 ? me.webkitFullscreenElement : null, Ee = () => document.fullscreenElement !== void 0 ? "fullscreenchange" : document.msFullscreenElement !== void 0 ? "MSFullscreenChange" : document.webkitFullscreenElement !== void 0 ? "webkitfullscreenchange" : "fullscreenchange", dt = (me) => {
    const Te = me.dom;
    Te.requestFullscreen ? Te.requestFullscreen() : Te.msRequestFullscreen ? Te.msRequestFullscreen() : Te.webkitRequestFullScreen && Te.webkitRequestFullScreen();
  }, wn = (me) => {
    const Te = me.dom;
    Te.exitFullscreen ? Te.exitFullscreen() : Te.msExitFullscreen ? Te.msExitFullscreen() : Te.webkitCancelFullScreen && Te.webkitCancelFullScreen();
  }, Yo = (me) => me.dom === ge(ia(me).dom), Ln = (me, Te, nt) => Rn(xa(me, nt), Te), Or = (me, Te) => Rn(la(me), Te), Kt = (me) => Lr(me), lr = (me, Te, nt) => Ln(me, (ft) => qt(ft, Te), nt), yi = (me, Te) => Or(me, (nt) => qt(nt, Te)), Cr = "data-ephox-mobile-fullscreen-style", ga = "display:none!important;", Ll = "position:absolute!important;", gs = "top:0!important;left:0!important;margin:0!important;padding:0!important;width:100%!important;height:100%!important;overflow:visible!important;", xi = "background-color:rgb(255,255,255)!important;", Dr = qs.os.isAndroid(), Cc = (me) => {
    const Te = Ct(me, "background-color");
    return Te !== void 0 && Te !== "" ? "background-color:" + Te + "!important" : xi;
  }, Mr = (me, Te, nt) => {
    const ft = (_a) => yi(_a, "*:not(.tox-silver-sink)"), eo = (_a) => (Rr) => {
      const ua = os(Rr, "style"), oa = ua === void 0 ? "no-styles" : ua.trim();
      oa !== _a && (Qo(Rr, Cr, oa), ct(Rr, me.parseStyle(_a)));
    }, es = lr(Te, "*"), Sr = fn(es, ft), Ha = Cc(nt);
    Ce(Sr, eo(ga)), Ce(es, eo(Ll + gs + Ha)), eo((Dr === !0 ? "" : Ll) + gs + Ha)(Te);
  }, pd = (me) => {
    const Te = Kt("[" + Cr + "]");
    Ce(Te, (nt) => {
      const ft = os(nt, Cr);
      ft && ft !== "no-styles" ? ct(nt, me.parseStyle(ft)) : zs(nt, "style"), zs(nt, Cr);
    });
  }, Tm = Uo.DOM, zh = () => ss(window), $r = (me) => window.scrollTo(me.x, me.y), Ql = Xt().fold(() => ({
    bind: oe,
    unbind: oe
  }), (me) => {
    const Te = Rt(), nt = Ro(), ft = Ro(), eo = () => {
      document.body.scrollTop = 0, document.documentElement.scrollTop = 0;
    }, es = () => {
      window.requestAnimationFrame(() => {
        Te.on((_a) => ct(_a, {
          top: me.offsetTop + "px",
          left: me.offsetLeft + "px",
          height: me.height + "px",
          width: me.width + "px"
        }));
      });
    }, Sr = Cn(() => {
      eo(), es();
    }, 50);
    return {
      bind: (_a) => {
        Te.set(_a), Sr.throttle(), nt.set(hs("resize", Sr.throttle)), ft.set(hs("scroll", Sr.throttle));
      },
      unbind: () => {
        Te.on(() => {
          nt.clear(), ft.clear();
        }), Te.clear();
      }
    };
  }), $a = (me, Te) => {
    const nt = document.body, ft = document.documentElement, eo = me.getContainer(), es = hr.fromDom(eo), Sr = _s(es).filter((qa) => vt(qa) && kt(qa, "tox-silver-sink")), Ha = Y(me), is = Te.get(), _a = hr.fromDom(me.getBody()), Rr = qs.deviceType.isTouch(), ua = eo.style, oa = me.iframeElement, Jr = oa == null ? void 0 : oa.style, ul = (qa) => {
      qa(nt, "tox-fullscreen"), qa(ft, "tox-fullscreen"), qa(eo, "tox-fullscreen"), En(es).map((dl) => Ao(dl).dom).each((dl) => {
        qa(dl, "tox-fullscreen"), qa(dl, "tox-shadowhost");
      });
    }, Sc = () => {
      Rr && pd(me.dom), ul(Tm.removeClass), Ql.unbind(), wt.from(Te.get()).each((qa) => qa.fullscreenChangeHandler.unbind());
    };
    if (is)
      is.fullscreenChangeHandler.unbind(), tr(me) && Yo(Ha) && wn(ia(Ha)), Jr.width = is.iframeWidth, Jr.height = is.iframeHeight, ua.width = is.containerWidth, ua.height = is.containerHeight, ua.top = is.containerTop, ua.left = is.containerLeft, Je(Sr, is.sinkCssPosition, (qa, dl) => {
        Ae(qa, "position", dl);
      }), Sc(), $r(is.scrollPos), Te.set(null), Ar(me, !1), me.off("remove", Sc);
    else {
      const qa = Lt(ia(Ha), Ee(), (Bc) => {
        tr(me) && !Yo(Ha) && Te.get() !== null && $a(me, Te);
      }), dl = {
        scrollPos: zh(),
        containerWidth: ua.width,
        containerHeight: ua.height,
        containerTop: ua.top,
        containerLeft: ua.left,
        iframeWidth: Jr.width,
        iframeHeight: Jr.height,
        fullscreenChangeHandler: qa,
        sinkCssPosition: Sr.map((Bc) => Ct(Bc, "position"))
      };
      Rr && Mr(me.dom, es, _a), Jr.width = Jr.height = "100%", ua.width = ua.height = "", ul(Tm.addClass), Sr.each((Bc) => {
        Ae(Bc, "position", "fixed");
      }), Ql.bind(es), me.on("remove", Sc), Te.set(dl), tr(me) && dt(Ha), Ar(me, !0);
    }
  }, Ga = (me, Te) => {
    me.addCommand("mceFullScreen", () => {
      $a(me, Te);
    });
  };
  var wi = tinymce.util.Tools.resolve("tinymce.util.VK");
  const If = (me, Te) => {
    me.on("init", () => {
      me.on("keydown", (nt) => {
        nt.keyCode === wi.TAB && !(nt.metaKey || nt.ctrlKey) && Te.get() && nt.preventDefault();
      });
    });
  }, fs = (me, Te) => (nt) => {
    nt.setActive(Te.get() !== null);
    const ft = (eo) => nt.setActive(eo.state);
    return me.on("FullscreenStateChanged", ft), () => me.off("FullscreenStateChanged", ft);
  }, Ri = (me, Te) => {
    const nt = () => me.execCommand("mceFullScreen");
    me.ui.registry.addToggleMenuItem("fullscreen", {
      text: "Fullscreen",
      icon: "fullscreen",
      shortcut: "Meta+Shift+F",
      onAction: nt,
      onSetup: fs(me, Te)
    }), me.ui.registry.addToggleButton("fullscreen", {
      tooltip: "Fullscreen",
      icon: "fullscreen",
      onAction: nt,
      onSetup: fs(me, Te),
      shortcut: "Meta+Shift+F"
    });
  };
  var ci = () => {
    a.add("fullscreen", (me) => {
      const Te = o(null);
      return me.inline || (md(me), Ga(me, Te), Ri(me, Te), If(me, Te), me.addShortcut("Meta+Shift+F", "", "mceFullScreen")), c(Te);
    });
  };
  ci();
})();
(function() {
  const o = (zt) => {
    let vt = zt;
    return {
      get: () => vt,
      set: (ao) => {
        vt = ao;
      }
    };
  };
  var a = tinymce.util.Tools.resolve("tinymce.PluginManager");
  let c = 0;
  const f = (zt) => {
    const oo = (/* @__PURE__ */ new Date()).getTime(), Dn = Math.floor(Math.random() * 1e9);
    return c++, zt + "_" + Dn + c + String(oo);
  }, g = (zt) => ({ addTab: (oo) => {
    var Dn;
    const ao = (Dn = oo.name) !== null && Dn !== void 0 ? Dn : f("tab-name"), xs = zt.get();
    xs[ao] = oo, zt.set(xs);
  } }), x = (zt, vt) => {
    zt.addCommand("mceHelp", vt);
  }, k = (zt) => (vt) => vt.options.get(zt), A = (zt) => {
    const vt = zt.options.register;
    vt("help_tabs", { processor: "array" });
  }, N = k("help_tabs"), H = k("forced_plugins"), Z = (zt, vt) => {
    zt.ui.registry.addButton("help", {
      icon: "help",
      tooltip: "Help",
      onAction: vt
    }), zt.ui.registry.addMenuItem("help", {
      text: "Help",
      icon: "help",
      shortcut: "Alt+0",
      onAction: vt
    });
  }, K = (zt, vt, oo) => {
    var Dn;
    return oo(zt, vt.prototype) ? !0 : ((Dn = zt.constructor) === null || Dn === void 0 ? void 0 : Dn.name) === vt.name;
  }, J = (zt) => {
    const vt = typeof zt;
    return zt === null ? "null" : vt === "object" && Array.isArray(zt) ? "array" : vt === "object" && K(zt, String, (oo, Dn) => Dn.isPrototypeOf(oo)) ? "string" : vt;
  }, pe = (zt) => (vt) => J(vt) === zt, Se = (zt) => (vt) => typeof vt === zt, be = (zt) => (vt) => zt === vt, ye = pe("string"), re = be(void 0), oe = (zt) => zt == null, U = (zt) => !oe(zt), ve = Se("function"), rt = ((zt) => () => zt)(!1);
  class ee {
    constructor(vt, oo) {
      this.tag = vt, this.value = oo;
    }
    static some(vt) {
      return new ee(!0, vt);
    }
    static none() {
      return ee.singletonNone;
    }
    fold(vt, oo) {
      return this.tag ? oo(this.value) : vt();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(vt) {
      return this.tag ? ee.some(vt(this.value)) : ee.none();
    }
    bind(vt) {
      return this.tag ? vt(this.value) : ee.none();
    }
    exists(vt) {
      return this.tag && vt(this.value);
    }
    forall(vt) {
      return !this.tag || vt(this.value);
    }
    filter(vt) {
      return !this.tag || vt(this.value) ? this : ee.none();
    }
    getOr(vt) {
      return this.tag ? this.value : vt;
    }
    or(vt) {
      return this.tag ? this : vt;
    }
    getOrThunk(vt) {
      return this.tag ? this.value : vt();
    }
    orThunk(vt) {
      return this.tag ? this : vt();
    }
    getOrDie(vt) {
      if (this.tag)
        return this.value;
      throw new Error(vt ?? "Called getOrDie on None");
    }
    static from(vt) {
      return U(vt) ? ee.some(vt) : ee.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(vt) {
      this.tag && vt(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  ee.singletonNone = new ee(!1);
  const lt = Array.prototype.slice, wt = Array.prototype.indexOf, Vt = (zt, vt) => wt.call(zt, vt), Ue = (zt, vt) => Vt(zt, vt) > -1, Ce = (zt, vt) => {
    const oo = zt.length, Dn = new Array(oo);
    for (let ao = 0; ao < oo; ao++) {
      const xs = zt[ao];
      Dn[ao] = vt(xs, ao);
    }
    return Dn;
  }, Rn = (zt, vt) => {
    const oo = [];
    for (let Dn = 0, ao = zt.length; Dn < ao; Dn++) {
      const xs = zt[Dn];
      vt(xs, Dn) && oo.push(xs);
    }
    return oo;
  }, _t = (zt, vt, oo) => {
    for (let Dn = 0, ao = zt.length; Dn < ao; Dn++) {
      const xs = zt[Dn];
      if (vt(xs, Dn))
        return ee.some(xs);
      if (oo(xs, Dn))
        break;
    }
    return ee.none();
  }, ot = (zt, vt) => _t(zt, vt, rt), B = (zt, vt) => {
    const oo = lt.call(zt, 0);
    return oo.sort(vt), oo;
  }, fn = Object.keys, ze = Object.hasOwnProperty, jt = (zt, vt) => Tt(zt, vt) ? ee.from(zt[vt]) : ee.none(), Tt = (zt, vt) => ze.call(zt, vt), Je = (zt) => {
    const vt = [], oo = (Dn) => {
      vt.push(Dn);
    };
    for (let Dn = 0; Dn < zt.length; Dn++)
      zt[Dn].each(oo);
    return vt;
  };
  var pn = tinymce.util.Tools.resolve("tinymce.Resource"), Ro = tinymce.util.Tools.resolve("tinymce.util.I18n");
  const Rt = (zt, vt) => pn.load(`tinymce.html-i18n.help-keynav.${vt}`, `${zt}/js/i18n/keynav/${vt}.js`), Cn = (zt) => Rt(zt, Ro.getCode()).catch(() => Rt(zt, "en")), et = (zt, vt) => {
    zt.on("init", () => {
      Cn(vt);
    });
  }, xt = async (zt) => ({
    name: "keyboardnav",
    title: "Keyboard Navigation",
    items: [{
      type: "htmlpanel",
      presets: "document",
      html: await Cn(zt)
    }]
  });
  var X = tinymce.util.Tools.resolve("tinymce.Env");
  const ds = (zt) => {
    const vt = X.os.isMacOS() || X.os.isiOS(), ao = vt ? {
      alt: "&#x2325;",
      ctrl: "&#x2303;",
      shift: "&#x21E7;",
      meta: "&#x2318;",
      access: "&#x2303;&#x2325;"
    } : {
      meta: "Ctrl ",
      access: "Shift + Alt "
    }, xs = zt.split("+"), rs = Ce(xs, (Qo) => {
      const os = Qo.toLowerCase().trim();
      return Tt(ao, os) ? ao[os] : Qo;
    });
    return vt ? rs.join("").replace(/\s/, "") : rs.join("+");
  }, So = [
    {
      shortcuts: ["Meta + B"],
      action: "Bold"
    },
    {
      shortcuts: ["Meta + I"],
      action: "Italic"
    },
    {
      shortcuts: ["Meta + U"],
      action: "Underline"
    },
    {
      shortcuts: ["Meta + A"],
      action: "Select all"
    },
    {
      shortcuts: [
        "Meta + Y",
        "Meta + Shift + Z"
      ],
      action: "Redo"
    },
    {
      shortcuts: ["Meta + Z"],
      action: "Undo"
    },
    {
      shortcuts: ["Access + 1"],
      action: "Heading 1"
    },
    {
      shortcuts: ["Access + 2"],
      action: "Heading 2"
    },
    {
      shortcuts: ["Access + 3"],
      action: "Heading 3"
    },
    {
      shortcuts: ["Access + 4"],
      action: "Heading 4"
    },
    {
      shortcuts: ["Access + 5"],
      action: "Heading 5"
    },
    {
      shortcuts: ["Access + 6"],
      action: "Heading 6"
    },
    {
      shortcuts: ["Access + 7"],
      action: "Paragraph"
    },
    {
      shortcuts: ["Access + 8"],
      action: "Div"
    },
    {
      shortcuts: ["Access + 9"],
      action: "Address"
    },
    {
      shortcuts: ["Alt + 0"],
      action: "Open help dialog"
    },
    {
      shortcuts: ["Alt + F9"],
      action: "Focus to menubar"
    },
    {
      shortcuts: ["Alt + F10"],
      action: "Focus to toolbar"
    },
    {
      shortcuts: ["Alt + F11"],
      action: "Focus to element path"
    },
    {
      shortcuts: ["Alt + F12"],
      action: "Focus to notification"
    },
    {
      shortcuts: ["Ctrl + F9"],
      action: "Focus to contextual toolbar"
    },
    {
      shortcuts: ["Shift + Enter"],
      action: "Open popup menu for split buttons"
    },
    {
      shortcuts: ["Meta + K"],
      action: "Insert link (if link plugin activated)"
    },
    {
      shortcuts: ["Meta + S"],
      action: "Save (if save plugin activated)"
    },
    {
      shortcuts: ["Meta + F"],
      action: "Find (if searchreplace plugin activated)"
    },
    {
      shortcuts: ["Meta + Shift + F"],
      action: "Switch to or from fullscreen mode"
    }
  ], At = () => {
    const zt = Ce(So, (oo) => {
      const Dn = Ce(oo.shortcuts, ds).join(" or ");
      return [
        oo.action,
        Dn
      ];
    });
    return {
      name: "shortcuts",
      title: "Handy Shortcuts",
      items: [{
        type: "table",
        header: [
          "Action",
          "Shortcut"
        ],
        cells: zt
      }]
    };
  }, Pt = Ce([
    {
      key: "accordion",
      name: "Accordion"
    },
    {
      key: "anchor",
      name: "Anchor"
    },
    {
      key: "autolink",
      name: "Autolink"
    },
    {
      key: "autoresize",
      name: "Autoresize"
    },
    {
      key: "autosave",
      name: "Autosave"
    },
    {
      key: "charmap",
      name: "Character Map"
    },
    {
      key: "code",
      name: "Code"
    },
    {
      key: "codesample",
      name: "Code Sample"
    },
    {
      key: "colorpicker",
      name: "Color Picker"
    },
    {
      key: "directionality",
      name: "Directionality"
    },
    {
      key: "emoticons",
      name: "Emoticons"
    },
    {
      key: "fullscreen",
      name: "Full Screen"
    },
    {
      key: "help",
      name: "Help"
    },
    {
      key: "image",
      name: "Image"
    },
    {
      key: "importcss",
      name: "Import CSS"
    },
    {
      key: "insertdatetime",
      name: "Insert Date/Time"
    },
    {
      key: "link",
      name: "Link"
    },
    {
      key: "lists",
      name: "Lists"
    },
    {
      key: "advlist",
      name: "List Styles"
    },
    {
      key: "media",
      name: "Media"
    },
    {
      key: "nonbreaking",
      name: "Nonbreaking"
    },
    {
      key: "pagebreak",
      name: "Page Break"
    },
    {
      key: "preview",
      name: "Preview"
    },
    {
      key: "quickbars",
      name: "Quick Toolbars"
    },
    {
      key: "save",
      name: "Save"
    },
    {
      key: "searchreplace",
      name: "Search and Replace"
    },
    {
      key: "table",
      name: "Table"
    },
    {
      key: "textcolor",
      name: "Text Color"
    },
    {
      key: "visualblocks",
      name: "Visual Blocks"
    },
    {
      key: "visualchars",
      name: "Visual Characters"
    },
    {
      key: "wordcount",
      name: "Word Count"
    },
    {
      key: "a11ychecker",
      name: "Accessibility Checker",
      type: "premium"
    },
    {
      key: "typography",
      name: "Advanced Typography",
      type: "premium",
      slug: "advanced-typography"
    },
    {
      key: "ai",
      name: "AI Assistant",
      type: "premium"
    },
    {
      key: "casechange",
      name: "Case Change",
      type: "premium"
    },
    {
      key: "checklist",
      name: "Checklist",
      type: "premium"
    },
    {
      key: "advcode",
      name: "Enhanced Code Editor",
      type: "premium"
    },
    {
      key: "mediaembed",
      name: "Enhanced Media Embed",
      type: "premium",
      slug: "introduction-to-mediaembed"
    },
    {
      key: "advtable",
      name: "Enhanced Tables",
      type: "premium"
    },
    {
      key: "exportpdf",
      name: "Export to PDF",
      type: "premium"
    },
    {
      key: "exportword",
      name: "Export to Word",
      type: "premium"
    },
    {
      key: "footnotes",
      name: "Footnotes",
      type: "premium"
    },
    {
      key: "formatpainter",
      name: "Format Painter",
      type: "premium"
    },
    {
      key: "editimage",
      name: "Image Editing",
      type: "premium"
    },
    {
      key: "importword",
      name: "Import from Word",
      type: "premium"
    },
    {
      key: "inlinecss",
      name: "Inline CSS",
      type: "premium",
      slug: "inline-css"
    },
    {
      key: "linkchecker",
      name: "Link Checker",
      type: "premium"
    },
    {
      key: "math",
      name: "Math",
      type: "premium"
    },
    {
      key: "markdown",
      name: "Markdown",
      type: "premium"
    },
    {
      key: "mentions",
      name: "Mentions",
      type: "premium"
    },
    {
      key: "mergetags",
      name: "Merge Tags",
      type: "premium"
    },
    {
      key: "pageembed",
      name: "Page Embed",
      type: "premium"
    },
    {
      key: "permanentpen",
      name: "Permanent Pen",
      type: "premium"
    },
    {
      key: "powerpaste",
      name: "PowerPaste",
      type: "premium",
      slug: "introduction-to-powerpaste"
    },
    {
      key: "revisionhistory",
      name: "Revision History",
      type: "premium"
    },
    {
      key: "tinymcespellchecker",
      name: "Spell Checker",
      type: "premium",
      slug: "introduction-to-tiny-spellchecker"
    },
    {
      key: "autocorrect",
      name: "Spelling Autocorrect",
      type: "premium"
    },
    {
      key: "tableofcontents",
      name: "Table of Contents",
      type: "premium"
    },
    {
      key: "advtemplate",
      name: "Templates",
      type: "premium",
      slug: "advanced-templates"
    },
    {
      key: "tinycomments",
      name: "Tiny Comments",
      type: "premium",
      slug: "introduction-to-tiny-comments"
    },
    {
      key: "tinydrive",
      name: "Tiny Drive",
      type: "premium",
      slug: "tinydrive-introduction"
    }
  ], (zt) => ({
    ...zt,
    type: zt.type || "opensource",
    slug: zt.slug || zt.key
  })), Hn = (zt) => {
    const vt = () => {
      const zs = Rn(Pt, ({ type: xn }) => xn === "premium"), it = B(Ce(zs, (xn) => xn.name), (xn, hn) => xn.localeCompare(hn)), kt = Ce(it, (xn) => `<li>${xn}</li>`).join("");
      return "<div><p><b>" + Ro.translate("Premium plugins:") + "</b></p><ul>" + kt + '<li class="tox-help__more-link" "><a href="https://www.tiny.cloud/pricing/?utm_campaign=help_dialog_plugin_tab&utm_source=tiny&utm_medium=referral&utm_term=read_more&utm_content=premium_plugin_heading" rel="noopener" target="_blank" data-alloy-tabstop="true" tabindex="-1">' + Ro.translate("Learn more...") + "</a></li></ul></div>";
    }, oo = (zs) => `<a data-alloy-tabstop="true" tabindex="-1" href="${zs.url}" target="_blank" rel="noopener">${zs.name}</a>`, Dn = (zs, it) => {
      const kt = zs.plugins[it].getMetadata;
      if (ve(kt)) {
        const xn = kt();
        return {
          name: xn.name,
          html: oo(xn)
        };
      } else
        return {
          name: it,
          html: it
        };
    }, ao = (zs, it) => ot(Pt, (kt) => kt.key === it).fold(() => Dn(zs, it), (kt) => {
      const xn = kt.type === "premium" ? `${kt.name}*` : kt.name, hn = oo({
        name: xn,
        url: `https://www.tiny.cloud/docs/tinymce/7/${kt.slug}/`
      });
      return {
        name: xn,
        html: hn
      };
    }), xs = (zs) => {
      const it = fn(zs.plugins), kt = H(zs);
      return re(kt) ? it : Rn(it, (xn) => !Ue(kt, xn));
    }, rs = (zs) => {
      const it = xs(zs), kt = B(Ce(it, (pr) => ao(zs, pr)), (pr, ta) => pr.name.localeCompare(ta.name)), xn = Ce(kt, (pr) => "<li>" + pr.html + "</li>"), hn = xn.length, Do = xn.join("");
      return "<p><b>" + Ro.translate([
        "Plugins installed ({0}):",
        hn
      ]) + "</b></p><ul>" + Do + "</ul>";
    };
    return {
      name: "plugins",
      title: "Plugins",
      items: [{
        type: "htmlpanel",
        presets: "document",
        html: [
          ((zs) => zs == null ? "" : "<div>" + rs(zs) + "</div>")(zt),
          vt()
        ].join("")
      }]
    };
  };
  var Nt = tinymce.util.Tools.resolve("tinymce.EditorManager");
  const Vn = () => {
    const oo = '<a data-alloy-tabstop="true" tabindex="-1" href="https://www.tiny.cloud/docs/tinymce/7/changelog/?utm_campaign=help_dialog_version_tab&utm_source=tiny&utm_medium=referral" rel="noopener" target="_blank">TinyMCE ' + ((ao, xs) => ao.indexOf("@") === 0 ? "X.X.X" : ao + "." + xs)(Nt.majorVersion, Nt.minorVersion) + "</a>";
    return {
      name: "versions",
      title: "Version",
      items: [{
        type: "htmlpanel",
        html: "<p>" + Ro.translate([
          "You are using {0}",
          oo
        ]) + "</p>",
        presets: "document"
      }]
    };
  }, tn = (zt, vt) => {
    const oo = {}, Dn = Ce(zt, (ao) => {
      var xs;
      if (ye(ao))
        return Tt(vt, ao) && (oo[ao] = vt[ao]), ao;
      {
        const rs = (xs = ao.name) !== null && xs !== void 0 ? xs : f("tab-name");
        return oo[rs] = ao, rs;
      }
    });
    return {
      tabs: oo,
      names: Dn
    };
  }, je = (zt) => {
    const vt = fn(zt), oo = vt.indexOf("versions");
    return oo !== -1 && (vt.splice(oo, 1), vt.push("versions")), {
      tabs: zt,
      names: vt
    };
  }, An = async (zt, vt, oo) => {
    const Dn = At(), ao = await xt(oo), xs = Hn(zt), rs = Vn(), Qo = {
      [Dn.name]: Dn,
      [ao.name]: ao,
      [xs.name]: xs,
      [rs.name]: rs,
      ...vt.get()
    };
    return ee.from(N(zt)).fold(() => je(Qo), (os) => tn(os, Qo));
  }, qn = (zt, vt, oo) => () => {
    An(zt, vt, oo).then(({ tabs: Dn, names: ao }) => {
      const xs = Ce(ao, (os) => jt(Dn, os)), Qo = {
        type: "tabpanel",
        tabs: Je(xs)
      };
      zt.windowManager.open({
        title: "Help",
        size: "medium",
        body: Qo,
        buttons: [{
          type: "cancel",
          name: "close",
          text: "Close",
          primary: !0
        }],
        initialData: {}
      });
    });
  };
  var on = () => {
    a.add("help", (zt, vt) => {
      const oo = o({}), Dn = g(oo);
      A(zt);
      const ao = qn(zt, oo, vt);
      return Z(zt, ao), x(zt, ao), zt.shortcuts.add("Alt+0", "Open help dialog", "mceHelp"), et(zt, vt), Dn;
    });
  };
  on();
})();
tinymce.Resource.add(
  "tinymce.html-i18n.help-keynav.en",
  `<h1>Begin keyboard navigation</h1>

<dl>
  <dt>Focus the Menu bar</dt>
  <dd>Windows or Linux: Alt+F9</dd>
  <dd>macOS: &#x2325;F9</dd>
  <dt>Focus the Toolbar</dt>
  <dd>Windows or Linux: Alt+F10</dd>
  <dd>macOS: &#x2325;F10</dd>
  <dt>Focus the footer</dt>
  <dd>Windows or Linux: Alt+F11</dd>
  <dd>macOS: &#x2325;F11</dd>
  <dt>Focus the notification</dt>
  <dd>Windows or Linux: Alt+F12</dd>
  <dd>macOS: &#x2325;F12</dd>
  <dt>Focus a contextual toolbar</dt>
  <dd>Windows, Linux or macOS: Ctrl+F9</dd>
</dl>

<p>Navigation will start at the first UI item, which will be highlighted, or underlined in the case of the first item in
  the Footer element path.</p>

<h1>Navigate between UI sections</h1>

<p>To move from one UI section to the next, press <strong>Tab</strong>.</p>

<p>To move from one UI section to the previous, press <strong>Shift+Tab</strong>.</p>

<p>The <strong>Tab</strong> order of these UI sections is:</p>

<ol>
  <li>Menu bar</li>
  <li>Each toolbar group</li>
  <li>Sidebar</li>
  <li>Element path in the footer</li>
  <li>Word count toggle button in the footer</li>
  <li>Branding link in the footer</li>
  <li>Editor resize handle in the footer</li>
</ol>

<p>If a UI section is not present, it is skipped.</p>

<p>If the footer has keyboard navigation focus, and there is no visible sidebar, pressing <strong>Shift+Tab</strong>
  moves focus to the first toolbar group, not the last.</p>

<h1>Navigate within UI sections</h1>

<p>To move from one UI element to the next, press the appropriate <strong>Arrow</strong> key.</p>

<p>The <strong>Left</strong> and <strong>Right</strong> arrow keys</p>

<ul>
  <li>move between menus in the menu bar.</li>
  <li>open a sub-menu in a menu.</li>
  <li>move between buttons in a toolbar group.</li>
  <li>move between items in the footer’s element path.</li>
</ul>

<p>The <strong>Down</strong> and <strong>Up</strong> arrow keys</p>

<ul>
  <li>move between menu items in a menu.</li>
  <li>move between items in a toolbar pop-up menu.</li>
</ul>

<p><strong>Arrow</strong> keys cycle within the focused UI section.</p>

<p>To close an open menu, an open sub-menu, or an open pop-up menu, press the <strong>Esc</strong> key.</p>

<p>If the current focus is at the ‘top’ of a particular UI section, pressing the <strong>Esc</strong> key also exits
  keyboard navigation entirely.</p>

<h1>Execute a menu item or toolbar button</h1>

<p>When the desired menu item or toolbar button is highlighted, press <strong>Return</strong>, <strong>Enter</strong>,
  or the <strong>Space bar</strong> to execute the item.</p>

<h1>Navigate non-tabbed dialogs</h1>

<p>In non-tabbed dialogs, the first interactive component takes focus when the dialog opens.</p>

<p>Navigate between interactive dialog components by pressing <strong>Tab</strong> or <strong>Shift+Tab</strong>.</p>

<h1>Navigate tabbed dialogs</h1>

<p>In tabbed dialogs, the first button in the tab menu takes focus when the dialog opens.</p>

<p>Navigate between interactive components of this dialog tab by pressing <strong>Tab</strong> or
  <strong>Shift+Tab</strong>.</p>

<p>Switch to another dialog tab by giving the tab menu focus and then pressing the appropriate <strong>Arrow</strong>
  key to cycle through the available tabs.</p>
`
);
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const a = Object.getPrototypeOf, c = (Y, ge, Ee) => {
    var dt;
    return Ee(Y, ge.prototype) ? !0 : ((dt = Y.constructor) === null || dt === void 0 ? void 0 : dt.name) === ge.name;
  }, f = (Y) => {
    const ge = typeof Y;
    return Y === null ? "null" : ge === "object" && Array.isArray(Y) ? "array" : ge === "object" && c(Y, String, (Ee, dt) => dt.isPrototypeOf(Ee)) ? "string" : ge;
  }, g = (Y) => (ge) => f(ge) === Y, x = (Y) => (ge) => typeof ge === Y, k = (Y) => (ge) => Y === ge, A = (Y, ge) => H(Y) && c(Y, ge, (Ee, dt) => a(Ee) === dt), N = g("string"), H = g("object"), Z = (Y) => A(Y, Object), K = g("array"), J = k(null), pe = x("boolean"), Se = (Y) => Y == null, be = (Y) => !Se(Y), ye = x("function"), re = x("number"), oe = (Y, ge) => {
    if (K(Y)) {
      for (let Ee = 0, dt = Y.length; Ee < dt; ++Ee)
        if (!ge(Y[Ee]))
          return !1;
      return !0;
    }
    return !1;
  }, U = () => {
  };
  class ve {
    constructor(ge, Ee) {
      this.tag = ge, this.value = Ee;
    }
    static some(ge) {
      return new ve(!0, ge);
    }
    static none() {
      return ve.singletonNone;
    }
    fold(ge, Ee) {
      return this.tag ? Ee(this.value) : ge();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(ge) {
      return this.tag ? ve.some(ge(this.value)) : ve.none();
    }
    bind(ge) {
      return this.tag ? ge(this.value) : ve.none();
    }
    exists(ge) {
      return this.tag && ge(this.value);
    }
    forall(ge) {
      return !this.tag || ge(this.value);
    }
    filter(ge) {
      return !this.tag || ge(this.value) ? this : ve.none();
    }
    getOr(ge) {
      return this.tag ? this.value : ge;
    }
    or(ge) {
      return this.tag ? this : ge;
    }
    getOrThunk(ge) {
      return this.tag ? this.value : ge();
    }
    orThunk(ge) {
      return this.tag ? this : ge();
    }
    getOrDie(ge) {
      if (this.tag)
        return this.value;
      throw new Error(ge ?? "Called getOrDie on None");
    }
    static from(ge) {
      return be(ge) ? ve.some(ge) : ve.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(ge) {
      this.tag && ge(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  ve.singletonNone = new ve(!1);
  const Ze = Object.keys, rt = Object.hasOwnProperty, ee = (Y, ge) => {
    const Ee = Ze(Y);
    for (let dt = 0, wn = Ee.length; dt < wn; dt++) {
      const Yo = Ee[dt], Ln = Y[Yo];
      ge(Ln, Yo);
    }
  }, lt = (Y) => (ge, Ee) => {
    Y[Ee] = ge;
  }, wt = (Y, ge, Ee, dt) => {
    ee(Y, (wn, Yo) => {
      (ge(wn, Yo) ? Ee : dt)(wn, Yo);
    });
  }, Vt = (Y, ge) => {
    const Ee = {};
    return wt(Y, ge, lt(Ee), U), Ee;
  }, Ue = (Y, ge) => rt.call(Y, ge), Ce = (Y, ge) => Ue(Y, ge) && Y[ge] !== void 0 && Y[ge] !== null, Rn = Array.prototype.push, _t = (Y) => {
    const ge = [];
    for (let Ee = 0, dt = Y.length; Ee < dt; ++Ee) {
      if (!K(Y[Ee]))
        throw new Error("Arr.flatten item " + Ee + " was not an array, input: " + Y);
      Rn.apply(ge, Y[Ee]);
    }
    return ge;
  }, ot = (Y, ge) => ge >= 0 && ge < Y.length ? ve.some(Y[ge]) : ve.none(), B = (Y) => ot(Y, 0), fn = (Y, ge) => {
    for (let Ee = 0; Ee < Y.length; Ee++) {
      const dt = ge(Y[Ee], Ee);
      if (dt.isSome())
        return dt;
    }
    return ve.none();
  };
  typeof window < "u" || Function("return this;")();
  const ze = (Y, ge, Ee) => {
    if (N(Ee) || pe(Ee) || re(Ee))
      Y.setAttribute(ge, Ee + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", ge, ":: Value ", Ee, ":: Element ", Y), new Error("Attribute value was not simple");
  }, jt = (Y, ge, Ee) => {
    ze(Y.dom, ge, Ee);
  }, Tt = (Y, ge) => {
    Y.dom.removeAttribute(ge);
  }, Je = (Y, ge) => {
    const dt = (ge || document).createElement("div");
    if (dt.innerHTML = Y, !dt.hasChildNodes() || dt.childNodes.length > 1) {
      const wn = "HTML does not have a single root node";
      throw console.error(wn, Y), new Error(wn);
    }
    return Rt(dt.childNodes[0]);
  }, pn = (Y, ge) => {
    const dt = (ge || document).createElement(Y);
    return Rt(dt);
  }, Ro = (Y, ge) => {
    const dt = (ge || document).createTextNode(Y);
    return Rt(dt);
  }, Rt = (Y) => {
    if (Y == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: Y };
  }, et = {
    fromHtml: Je,
    fromTag: pn,
    fromText: Ro,
    fromDom: Rt,
    fromPoint: (Y, ge, Ee) => ve.from(Y.dom.elementFromPoint(ge, Ee)).map(Rt)
  };
  var xt = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), X = tinymce.util.Tools.resolve("tinymce.util.URI");
  const ds = (Y) => Y.length > 0, So = (Y) => (ge) => ge.options.get(Y), At = (Y) => {
    const ge = Y.options.register;
    ge("image_dimensions", {
      processor: "boolean",
      default: !0
    }), ge("image_advtab", {
      processor: "boolean",
      default: !1
    }), ge("image_uploadtab", {
      processor: "boolean",
      default: !0
    }), ge("image_prepend_url", {
      processor: "string",
      default: ""
    }), ge("image_class_list", { processor: "object[]" }), ge("image_description", {
      processor: "boolean",
      default: !0
    }), ge("image_title", {
      processor: "boolean",
      default: !1
    }), ge("image_caption", {
      processor: "boolean",
      default: !1
    }), ge("image_list", {
      processor: (Ee) => {
        const dt = Ee === !1 || N(Ee) || oe(Ee, H) || ye(Ee);
        return dt ? {
          value: Ee,
          valid: dt
        } : {
          valid: !1,
          message: "Must be false, a string, an array or a function."
        };
      },
      default: !1
    });
  }, Pt = So("image_dimensions"), Hn = So("image_advtab"), Nt = So("image_uploadtab"), Vn = So("image_prepend_url"), tn = So("image_class_list"), je = So("image_description"), An = So("image_title"), qn = So("image_caption"), on = So("image_list"), zt = So("a11y_advanced_options"), vt = So("automatic_uploads"), oo = (Y) => ds(Y.options.get("images_upload_url")), Dn = (Y) => be(Y.options.get("images_upload_handler")), ao = (Y, ge) => Math.max(parseInt(Y, 10), parseInt(ge, 10)), xs = (Y) => new Promise((ge) => {
    const Ee = document.createElement("img"), dt = (Yo) => {
      Ee.onload = Ee.onerror = null, Ee.parentNode && Ee.parentNode.removeChild(Ee), ge(Yo);
    };
    Ee.onload = () => {
      const Yo = ao(Ee.width, Ee.clientWidth), Ln = ao(Ee.height, Ee.clientHeight), Or = {
        width: Yo,
        height: Ln
      };
      dt(Promise.resolve(Or));
    }, Ee.onerror = () => {
      dt(Promise.reject(`Failed to get image dimensions for: ${Y}`));
    };
    const wn = Ee.style;
    wn.visibility = "hidden", wn.position = "fixed", wn.bottom = wn.left = "0px", wn.width = wn.height = "auto", document.body.appendChild(Ee), Ee.src = Y;
  }), rs = (Y) => (Y && (Y = Y.replace(/px$/, "")), Y), Qo = (Y) => (Y.length > 0 && /^[0-9]+$/.test(Y) && (Y += "px"), Y), os = (Y) => {
    if (Y.margin) {
      const ge = String(Y.margin).split(" ");
      switch (ge.length) {
        case 1:
          Y["margin-top"] = Y["margin-top"] || ge[0], Y["margin-right"] = Y["margin-right"] || ge[0], Y["margin-bottom"] = Y["margin-bottom"] || ge[0], Y["margin-left"] = Y["margin-left"] || ge[0];
          break;
        case 2:
          Y["margin-top"] = Y["margin-top"] || ge[0], Y["margin-right"] = Y["margin-right"] || ge[1], Y["margin-bottom"] = Y["margin-bottom"] || ge[0], Y["margin-left"] = Y["margin-left"] || ge[1];
          break;
        case 3:
          Y["margin-top"] = Y["margin-top"] || ge[0], Y["margin-right"] = Y["margin-right"] || ge[1], Y["margin-bottom"] = Y["margin-bottom"] || ge[2], Y["margin-left"] = Y["margin-left"] || ge[1];
          break;
        case 4:
          Y["margin-top"] = Y["margin-top"] || ge[0], Y["margin-right"] = Y["margin-right"] || ge[1], Y["margin-bottom"] = Y["margin-bottom"] || ge[2], Y["margin-left"] = Y["margin-left"] || ge[3];
      }
      delete Y.margin;
    }
    return Y;
  }, zs = (Y, ge) => {
    const Ee = on(Y);
    N(Ee) ? fetch(Ee).then((dt) => {
      dt.ok && dt.json().then(ge);
    }) : ye(Ee) ? Ee(ge) : ge(Ee);
  }, it = (Y, ge, Ee) => {
    const dt = () => {
      Ee.onload = Ee.onerror = null, Y.selection && (Y.selection.select(Ee), Y.nodeChanged());
    };
    Ee.onload = () => {
      !ge.width && !ge.height && Pt(Y) && Y.dom.setAttribs(Ee, {
        width: String(Ee.clientWidth),
        height: String(Ee.clientHeight)
      }), dt();
    }, Ee.onerror = dt;
  }, kt = (Y) => new Promise((ge, Ee) => {
    const dt = new FileReader();
    dt.onload = () => {
      ge(dt.result);
    }, dt.onerror = () => {
      var wn;
      Ee((wn = dt.error) === null || wn === void 0 ? void 0 : wn.message);
    }, dt.readAsDataURL(Y);
  }), xn = (Y) => Y.nodeName === "IMG" && (Y.hasAttribute("data-mce-object") || Y.hasAttribute("data-mce-placeholder")), hn = (Y, ge) => {
    const Ee = Y.options.get;
    return X.isDomSafe(ge, "img", {
      allow_html_data_urls: Ee("allow_html_data_urls"),
      allow_script_urls: Ee("allow_script_urls"),
      allow_svg_data_urls: Ee("allow_svg_data_urls")
    });
  }, Do = xt.DOM, Ss = (Y) => Y.style.marginLeft && Y.style.marginRight && Y.style.marginLeft === Y.style.marginRight ? rs(Y.style.marginLeft) : "", pr = (Y) => Y.style.marginTop && Y.style.marginBottom && Y.style.marginTop === Y.style.marginBottom ? rs(Y.style.marginTop) : "", ta = (Y) => Y.style.borderWidth ? rs(Y.style.borderWidth) : "", Ms = (Y, ge) => {
    var Ee;
    return Y.hasAttribute(ge) && (Ee = Y.getAttribute(ge)) !== null && Ee !== void 0 ? Ee : "";
  }, hr = (Y) => Y.parentNode !== null && Y.parentNode.nodeName === "FIGURE", qt = (Y, ge, Ee) => {
    Ee === "" || Ee === null ? Y.removeAttribute(ge) : Y.setAttribute(ge, Ee);
  }, Ko = (Y) => {
    const ge = Do.create("figure", { class: "image" });
    Do.insertAfter(ge, Y), ge.appendChild(Y), ge.appendChild(Do.create("figcaption", { contentEditable: "true" }, "Caption")), ge.contentEditable = "false";
  }, Lr = (Y) => {
    const ge = Y.parentNode;
    be(ge) && (Do.insertAfter(Y, ge), Do.remove(ge));
  }, ha = (Y) => {
    hr(Y) ? Lr(Y) : Ko(Y);
  }, ia = (Y, ge) => {
    const Ee = Y.getAttribute("style"), dt = ge(Ee !== null ? Ee : "");
    dt.length > 0 ? (Y.setAttribute("style", dt), Y.setAttribute("data-mce-style", dt)) : Y.removeAttribute("style");
  }, na = (Y, ge) => (Ee, dt, wn) => {
    const Yo = Ee.style;
    Yo[dt] ? (Yo[dt] = Qo(wn), ia(Ee, ge)) : qt(Ee, dt, wn);
  }, ks = (Y, ge) => Y.style[ge] ? rs(Y.style[ge]) : Ms(Y, ge), xa = (Y, ge) => {
    const Ee = Qo(ge);
    Y.style.marginLeft = Ee, Y.style.marginRight = Ee;
  }, la = (Y, ge) => {
    const Ee = Qo(ge);
    Y.style.marginTop = Ee, Y.style.marginBottom = Ee;
  }, _s = (Y, ge) => {
    const Ee = Qo(ge);
    Y.style.borderWidth = Ee;
  }, Xn = (Y, ge) => {
    Y.style.borderStyle = ge;
  }, wr = (Y) => {
    var ge;
    return (ge = Y.style.borderStyle) !== null && ge !== void 0 ? ge : "";
  }, Ke = (Y) => be(Y) && Y.nodeName === "FIGURE", ht = (Y) => Y.nodeName === "IMG", gn = (Y) => Do.getAttrib(Y, "alt").length === 0 && Do.getAttrib(Y, "role") === "presentation", En = (Y) => gn(Y) ? "" : Ms(Y, "alt"), Ao = () => ({
    src: "",
    alt: "",
    title: "",
    width: "",
    height: "",
    class: "",
    style: "",
    caption: !1,
    hspace: "",
    vspace: "",
    border: "",
    borderStyle: "",
    isDecorative: !1
  }), as = (Y, ge) => {
    var Ee;
    const dt = document.createElement("img");
    return qt(dt, "style", ge.style), (Ss(dt) || ge.hspace !== "") && xa(dt, ge.hspace), (pr(dt) || ge.vspace !== "") && la(dt, ge.vspace), (ta(dt) || ge.border !== "") && _s(dt, ge.border), (wr(dt) || ge.borderStyle !== "") && Xn(dt, ge.borderStyle), Y((Ee = dt.getAttribute("style")) !== null && Ee !== void 0 ? Ee : "");
  }, Yr = (Y, ge) => {
    const Ee = document.createElement("img");
    if (Ct(Y, {
      ...ge,
      caption: !1
    }, Ee), Ne(Ee, ge.alt, ge.isDecorative), ge.caption) {
      const dt = Do.create("figure", { class: "image" });
      return dt.appendChild(Ee), dt.appendChild(Do.create("figcaption", { contentEditable: "true" }, "Caption")), dt.contentEditable = "false", dt;
    } else
      return Ee;
  }, Xr = (Y, ge) => ({
    src: Ms(ge, "src"),
    alt: En(ge),
    title: Ms(ge, "title"),
    width: ks(ge, "width"),
    height: ks(ge, "height"),
    class: Ms(ge, "class"),
    style: Y(Ms(ge, "style")),
    caption: hr(ge),
    hspace: Ss(ge),
    vspace: pr(ge),
    border: ta(ge),
    borderStyle: wr(ge),
    isDecorative: gn(ge)
  }), Tr = (Y, ge, Ee, dt, wn) => {
    Ee[dt] !== ge[dt] && wn(Y, dt, String(Ee[dt]));
  }, Ne = (Y, ge, Ee) => {
    if (Ee) {
      Do.setAttrib(Y, "role", "presentation");
      const dt = et.fromDom(Y);
      jt(dt, "alt", "");
    } else {
      if (J(ge)) {
        const dt = et.fromDom(Y);
        Tt(dt, "alt");
      } else {
        const dt = et.fromDom(Y);
        jt(dt, "alt", ge);
      }
      Do.getAttrib(Y, "role") === "presentation" && Do.setAttrib(Y, "role", "");
    }
  }, Ae = (Y, ge, Ee) => {
    (Ee.alt !== ge.alt || Ee.isDecorative !== ge.isDecorative) && Ne(Y, Ee.alt, Ee.isDecorative);
  }, ct = (Y, ge) => (Ee, dt, wn) => {
    Y(Ee, wn), ia(Ee, ge);
  }, Ct = (Y, ge, Ee) => {
    const dt = Xr(Y, Ee);
    Tr(Ee, dt, ge, "caption", (wn, Yo, Ln) => ha(wn)), Tr(Ee, dt, ge, "src", qt), Tr(Ee, dt, ge, "title", qt), Tr(Ee, dt, ge, "width", na("width", Y)), Tr(Ee, dt, ge, "height", na("height", Y)), Tr(Ee, dt, ge, "class", qt), Tr(Ee, dt, ge, "style", ct((wn, Yo) => qt(wn, "style", Yo), Y)), Tr(Ee, dt, ge, "hspace", ct(xa, Y)), Tr(Ee, dt, ge, "vspace", ct(la, Y)), Tr(Ee, dt, ge, "border", ct(_s, Y)), Tr(Ee, dt, ge, "borderStyle", ct(Xn, Y)), Ae(Ee, dt, ge);
  }, Kn = (Y, ge) => {
    const Ee = Y.dom.styles.parse(ge), dt = os(Ee), wn = Y.dom.styles.parse(Y.dom.styles.serialize(dt));
    return Y.dom.styles.serialize(wn);
  }, lo = (Y) => {
    const ge = Y.selection.getNode(), Ee = Y.dom.getParent(ge, "figure.image");
    return Ee ? Y.dom.select("img", Ee)[0] : ge && (ge.nodeName !== "IMG" || xn(ge)) ? null : ge;
  }, Bo = (Y, ge) => {
    var Ee;
    const dt = Y.dom, wn = Vt(Y.schema.getTextBlockElements(), (Ln, Or) => !Y.schema.isValidChild(Or, "figure")), Yo = dt.getParent(ge.parentNode, (Ln) => Ce(wn, Ln.nodeName), Y.getBody());
    return Yo && (Ee = dt.split(Yo, ge)) !== null && Ee !== void 0 ? Ee : ge;
  }, Xs = (Y) => {
    const ge = lo(Y);
    return ge ? Xr((Ee) => Kn(Y, Ee), ge) : Ao();
  }, $e = (Y, ge) => {
    const Ee = Yr((wn) => Kn(Y, wn), ge);
    Y.dom.setAttrib(Ee, "data-mce-id", "__mcenew"), Y.focus(), Y.selection.setContent(Ee.outerHTML);
    const dt = Y.dom.select('*[data-mce-id="__mcenew"]')[0];
    if (Y.dom.setAttrib(dt, "data-mce-id", null), Ke(dt)) {
      const wn = Bo(Y, dt);
      Y.selection.select(wn);
    } else
      Y.selection.select(dt);
  }, Oo = (Y, ge) => {
    Y.dom.setAttrib(ge, "src", ge.getAttribute("src"));
  }, Pe = (Y, ge) => {
    if (ge) {
      const Ee = Y.dom.is(ge.parentNode, "figure.image") ? ge.parentNode : ge;
      Y.dom.remove(Ee), Y.focus(), Y.nodeChanged(), Y.dom.isEmpty(Y.getBody()) && (Y.setContent(""), Y.selection.setCursorLocation());
    }
  }, Ie = (Y, ge) => {
    const Ee = lo(Y);
    if (Ee)
      if (Ct((dt) => Kn(Y, dt), ge, Ee), Oo(Y, Ee), Ke(Ee.parentNode)) {
        const dt = Ee.parentNode;
        Bo(Y, dt), Y.selection.select(Ee.parentNode);
      } else
        Y.selection.select(Ee), it(Y, ge, Ee);
  }, Lt = (Y, ge) => {
    const Ee = ge.src;
    return {
      ...ge,
      src: hn(Y, Ee) ? Ee : ""
    };
  }, Zt = (Y, ge) => {
    const Ee = lo(Y);
    if (Ee) {
      const wn = {
        ...Xr((Ln) => Kn(Y, Ln), Ee),
        ...ge
      }, Yo = Lt(Y, wn);
      wn.src ? Ie(Y, Yo) : Pe(Y, Ee);
    } else ge.src && $e(Y, {
      ...Ao(),
      ...ge
    });
  }, Zn = ((Y) => (...ge) => {
    if (ge.length === 0)
      throw new Error("Can't merge zero objects");
    const Ee = {};
    for (let dt = 0; dt < ge.length; dt++) {
      const wn = ge[dt];
      for (const Yo in wn)
        Ue(wn, Yo) && (Ee[Yo] = Y(Ee[Yo], wn[Yo]));
    }
    return Ee;
  })((Y, ge) => Z(Y) && Z(ge) ? Zn(Y, ge) : ge);
  var Gn = tinymce.util.Tools.resolve("tinymce.util.ImageUploader"), Qn = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const co = (Y) => N(Y.value) ? Y.value : "", Jo = (Y) => N(Y.text) ? Y.text : N(Y.title) ? Y.title : "", Gs = (Y, ge) => {
    const Ee = [];
    return Qn.each(Y, (dt) => {
      const wn = Jo(dt);
      if (dt.menu !== void 0) {
        const Yo = Gs(dt.menu, ge);
        Ee.push({
          text: wn,
          items: Yo
        });
      } else {
        const Yo = ge(dt);
        Ee.push({
          text: wn,
          value: Yo
        });
      }
    }), Ee;
  }, Wa = (Y = co) => (ge) => ge ? ve.from(ge).map((Ee) => Gs(Ee, Y)) : ve.none(), Ti = (Y) => Wa(co)(Y), Ai = (Y) => Ue(Y, "items"), ko = (Y, ge) => fn(Y, (Ee) => Ai(Ee) ? ko(Ee.items, ge) : Ee.value === ge ? ve.some(Ee) : ve.none()), Rs = {
    sanitizer: Wa,
    sanitize: Ti,
    findEntry: (Y, ge) => Y.bind((Ee) => ko(Ee, ge))
  }, ca = { makeTab: (Y) => ({
    title: "Advanced",
    name: "advanced",
    items: [{
      type: "grid",
      columns: 2,
      items: [
        {
          type: "input",
          label: "Vertical space",
          name: "vspace",
          inputMode: "numeric"
        },
        {
          type: "input",
          label: "Horizontal space",
          name: "hspace",
          inputMode: "numeric"
        },
        {
          type: "input",
          label: "Border width",
          name: "border",
          inputMode: "numeric"
        },
        {
          type: "listbox",
          name: "borderstyle",
          label: "Border style",
          items: [
            {
              text: "Select...",
              value: ""
            },
            {
              text: "Solid",
              value: "solid"
            },
            {
              text: "Dotted",
              value: "dotted"
            },
            {
              text: "Dashed",
              value: "dashed"
            },
            {
              text: "Double",
              value: "double"
            },
            {
              text: "Groove",
              value: "groove"
            },
            {
              text: "Ridge",
              value: "ridge"
            },
            {
              text: "Inset",
              value: "inset"
            },
            {
              text: "Outset",
              value: "outset"
            },
            {
              text: "None",
              value: "none"
            },
            {
              text: "Hidden",
              value: "hidden"
            }
          ]
        }
      ]
    }]
  }) }, gr = (Y) => {
    const ge = Rs.sanitizer((Dr) => Y.convertURL(Dr.value || Dr.url || "", "src")), Ee = new Promise((Dr) => {
      zs(Y, (Cc) => {
        Dr(ge(Cc).map((Mr) => _t([
          [{
            text: "None",
            value: ""
          }],
          Mr
        ])));
      });
    }), dt = Rs.sanitize(tn(Y)), wn = Hn(Y), Yo = Nt(Y), Ln = oo(Y), Or = Dn(Y), Kt = Xs(Y), lr = je(Y), yi = An(Y), Cr = Pt(Y), ga = qn(Y), Ll = zt(Y), gs = vt(Y), xi = ve.some(Vn(Y)).filter((Dr) => N(Dr) && Dr.length > 0);
    return Ee.then((Dr) => ({
      image: Kt,
      imageList: Dr,
      classList: dt,
      hasAdvTab: wn,
      hasUploadTab: Yo,
      hasUploadUrl: Ln,
      hasUploadHandler: Or,
      hasDescription: lr,
      hasImageTitle: yi,
      hasDimensions: Cr,
      hasImageCaption: ga,
      prependURL: xi,
      hasAccessibilityOptions: Ll,
      automaticUploads: gs
    }));
  }, Qs = (Y) => {
    const ge = {
      name: "src",
      type: "urlinput",
      filetype: "image",
      label: "Source",
      picker_text: "Browse files"
    }, Ee = Y.imageList.map((yi) => ({
      name: "images",
      type: "listbox",
      label: "Image list",
      items: yi
    })), dt = {
      name: "alt",
      type: "input",
      label: "Alternative description",
      enabled: !(Y.hasAccessibilityOptions && Y.image.isDecorative)
    }, wn = {
      name: "title",
      type: "input",
      label: "Image title"
    }, Yo = {
      name: "dimensions",
      type: "sizeinput"
    }, Ln = {
      type: "label",
      label: "Accessibility",
      items: [{
        name: "isDecorative",
        type: "checkbox",
        label: "Image is decorative"
      }]
    }, Or = Y.classList.map((yi) => ({
      name: "classes",
      type: "listbox",
      label: "Class",
      items: yi
    })), Kt = {
      type: "label",
      label: "Caption",
      items: [{
        type: "checkbox",
        name: "caption",
        label: "Show caption"
      }]
    }, lr = (yi) => yi ? {
      type: "grid",
      columns: 2
    } : { type: "panel" };
    return _t([
      [ge],
      Ee.toArray(),
      Y.hasAccessibilityOptions && Y.hasDescription ? [Ln] : [],
      Y.hasDescription ? [dt] : [],
      Y.hasImageTitle ? [wn] : [],
      Y.hasDimensions ? [Yo] : [],
      [{
        ...lr(Y.classList.isSome() && Y.hasImageCaption),
        items: _t([
          Or.toArray(),
          Y.hasImageCaption ? [Kt] : []
        ])
      }]
    ]);
  }, xc = {
    makeTab: (Y) => ({
      title: "General",
      name: "general",
      items: Qs(Y)
    }),
    makeItems: Qs
  }, ka = { makeTab: (Y) => ({
    title: "Upload",
    name: "upload",
    items: [{
      type: "dropzone",
      name: "fileinput"
    }]
  }) }, li = (Y) => ({
    prevImage: Rs.findEntry(Y.imageList, Y.image.src),
    prevAlt: Y.image.alt,
    open: !0
  }), Qr = (Y) => ({
    src: {
      value: Y.src,
      meta: {}
    },
    images: Y.src,
    alt: Y.alt,
    title: Y.title,
    dimensions: {
      width: Y.width,
      height: Y.height
    },
    classes: Y.class,
    caption: Y.caption,
    style: Y.style,
    vspace: Y.vspace,
    border: Y.border,
    hspace: Y.hspace,
    borderstyle: Y.borderStyle,
    fileinput: [],
    isDecorative: Y.isDecorative
  }), Oi = (Y, ge) => ({
    src: Y.src.value,
    alt: (Y.alt === null || Y.alt.length === 0) && ge ? null : Y.alt,
    title: Y.title,
    width: Y.dimensions.width,
    height: Y.dimensions.height,
    class: Y.classes,
    style: Y.style,
    caption: Y.caption,
    hspace: Y.hspace,
    vspace: Y.vspace,
    border: Y.border,
    borderStyle: Y.borderstyle,
    isDecorative: Y.isDecorative
  }), cl = (Y, ge) => /^(?:[a-zA-Z]+:)?\/\//.test(ge) ? ve.none() : Y.prependURL.bind((Ee) => ge.substring(0, Ee.length) !== Ee ? ve.some(Ee + ge) : ve.none()), Za = (Y, ge) => {
    const Ee = ge.getData();
    cl(Y, Ee.src.value).each((dt) => {
      ge.setData({
        src: {
          value: dt,
          meta: Ee.src.meta
        }
      });
    });
  }, Di = (Y, ge, Ee) => {
    Y.hasDescription && N(Ee.alt) && (ge.alt = Ee.alt), Y.hasAccessibilityOptions && (ge.isDecorative = Ee.isDecorative || ge.isDecorative || !1), Y.hasImageTitle && N(Ee.title) && (ge.title = Ee.title), Y.hasDimensions && (N(Ee.width) && (ge.dimensions.width = Ee.width), N(Ee.height) && (ge.dimensions.height = Ee.height)), N(Ee.class) && Rs.findEntry(Y.classList, Ee.class).each((dt) => {
      ge.classes = dt.value;
    }), Y.hasImageCaption && pe(Ee.caption) && (ge.caption = Ee.caption), Y.hasAdvTab && (N(Ee.style) && (ge.style = Ee.style), N(Ee.vspace) && (ge.vspace = Ee.vspace), N(Ee.border) && (ge.border = Ee.border), N(Ee.hspace) && (ge.hspace = Ee.hspace), N(Ee.borderstyle) && (ge.borderstyle = Ee.borderstyle));
  }, ji = (Y, ge) => {
    const Ee = ge.getData(), dt = Ee.src.meta;
    if (dt !== void 0) {
      const wn = Zn({}, Ee);
      Di(Y, wn, dt), ge.setData(wn);
    }
  }, uu = (Y, ge, Ee, dt) => {
    const wn = dt.getData(), Yo = wn.src.value, Ln = wn.src.meta || {};
    !Ln.width && !Ln.height && ge.hasDimensions && (ds(Yo) ? Y.imageSize(Yo).then((Or) => {
      Ee.open && dt.setData({ dimensions: Or });
    }).catch((Or) => console.error(Or)) : dt.setData({
      dimensions: {
        width: "",
        height: ""
      }
    }));
  }, vi = (Y, ge, Ee) => {
    const dt = Ee.getData(), wn = Rs.findEntry(Y.imageList, dt.src.value);
    ge.prevImage = wn, Ee.setData({ images: wn.map((Yo) => Yo.value).getOr("") });
  }, Bl = (Y, ge, Ee, dt) => {
    Za(ge, dt), ji(ge, dt), uu(Y, ge, Ee, dt), vi(ge, Ee, dt);
  }, La = (Y, ge, Ee, dt) => {
    const wn = dt.getData(), Yo = Rs.findEntry(ge.imageList, wn.images);
    Yo.each((Ln) => {
      wn.alt === "" || Ee.prevImage.map((Kt) => Kt.text === wn.alt).getOr(!1) ? Ln.value === "" ? dt.setData({
        src: Ln,
        alt: Ee.prevAlt
      }) : dt.setData({
        src: Ln,
        alt: Ln.text
      }) : dt.setData({ src: Ln });
    }), Ee.prevImage = Yo, Bl(Y, ge, Ee, dt);
  }, Wi = (Y, ge, Ee, dt) => {
    const wn = dt.getData();
    dt.block("Uploading image"), B(wn.fileinput).fold(() => {
      dt.unblock();
    }, (Yo) => {
      const Ln = URL.createObjectURL(Yo), Or = () => {
        dt.unblock(), URL.revokeObjectURL(Ln);
      }, Kt = (lr) => {
        dt.setData({
          src: {
            value: lr,
            meta: {}
          }
        }), dt.showTab("general"), Bl(Y, ge, Ee, dt), dt.focus("src");
      };
      kt(Yo).then((lr) => {
        const yi = Y.createBlobCache(Yo, Ln, lr);
        ge.automaticUploads ? Y.uploadImage(yi).then((Cr) => {
          Kt(Cr.url), Or();
        }).catch((Cr) => {
          Or(), Y.alertErr(Cr);
        }) : (Y.addToBlobCache(yi), Kt(yi.blobUri()), dt.unblock());
      });
    });
  }, Xl = (Y, ge, Ee) => (dt, wn) => {
    wn.name === "src" ? Bl(Y, ge, Ee, dt) : wn.name === "images" ? La(Y, ge, Ee, dt) : wn.name === "alt" ? Ee.prevAlt = dt.getData().alt : wn.name === "fileinput" ? Wi(Y, ge, Ee, dt) : wn.name === "isDecorative" && dt.setEnabled("alt", !dt.getData().isDecorative);
  }, wc = (Y) => () => {
    Y.open = !1;
  }, fd = (Y) => Y.hasAdvTab || Y.hasUploadUrl || Y.hasUploadHandler ? {
    type: "tabpanel",
    tabs: _t([
      [xc.makeTab(Y)],
      Y.hasAdvTab ? [ca.makeTab(Y)] : [],
      Y.hasUploadTab && (Y.hasUploadUrl || Y.hasUploadHandler) ? [ka.makeTab(Y)] : []
    ])
  } : {
    type: "panel",
    items: xc.makeItems(Y)
  }, du = (Y, ge, Ee) => (dt) => {
    const wn = Zn(Qr(ge.image), dt.getData()), Yo = {
      ...wn,
      style: as(Ee.normalizeCss, Oi(wn, !1))
    };
    Y.execCommand("mceUpdateImage", !1, Oi(Yo, ge.hasAccessibilityOptions)), Y.editorUpload.uploadImagesAuto(), dt.close();
  }, bi = (Y) => (ge) => hn(Y, ge) ? xs(Y.documentBaseURI.toAbsolute(ge)).then((Ee) => ({
    width: String(Ee.width),
    height: String(Ee.height)
  })) : Promise.resolve({
    width: "",
    height: ""
  }), Fu = (Y) => (ge, Ee, dt) => {
    var wn;
    return Y.editorUpload.blobCache.create({
      blob: ge,
      blobUri: Ee,
      name: (wn = ge.name) === null || wn === void 0 ? void 0 : wn.replace(/\.[^\.]+$/, ""),
      filename: ge.name,
      base64: dt.split(",")[1]
    });
  }, ie = (Y) => (ge) => {
    Y.editorUpload.blobCache.add(ge);
  }, Oe = (Y) => (ge) => {
    Y.windowManager.alert(ge);
  }, Ge = (Y) => (ge) => Kn(Y, ge), Dt = (Y) => (ge) => Y.dom.parseStyle(ge), Xt = (Y) => (ge, Ee) => Y.dom.serializeStyle(ge, Ee), jn = (Y) => (ge) => Gn(Y).upload([ge], !1).then((Ee) => {
    var dt;
    return Ee.length === 0 ? Promise.reject("Failed to upload image") : Ee[0].status === !1 ? Promise.reject((dt = Ee[0].error) === null || dt === void 0 ? void 0 : dt.message) : Ee[0];
  }), ss = (Y) => {
    const ge = {
      imageSize: bi(Y),
      addToBlobCache: ie(Y),
      createBlobCache: Fu(Y),
      alertErr: Oe(Y),
      normalizeCss: Ge(Y),
      parseStyle: Dt(Y),
      serializeStyle: Xt(Y),
      uploadImage: jn(Y)
    };
    return { open: () => {
      gr(Y).then((dt) => {
        const wn = li(dt);
        return {
          title: "Insert/Edit Image",
          size: "normal",
          body: fd(dt),
          buttons: [
            {
              type: "cancel",
              name: "cancel",
              text: "Cancel"
            },
            {
              type: "submit",
              name: "save",
              text: "Save",
              primary: !0
            }
          ],
          initialData: Qr(dt.image),
          onSubmit: du(Y, dt, ge),
          onChange: Xl(ge, dt, wn),
          onClose: wc(wn)
        };
      }).then(Y.windowManager.open);
    } };
  }, hs = (Y) => {
    Y.addCommand("mceImage", ss(Y).open), Y.addCommand("mceUpdateImage", (ge, Ee) => {
      Y.undoManager.transact(() => Zt(Y, Ee));
    });
  }, Uo = (Y) => {
    const ge = Y.attr("class");
    return be(ge) && /\bimage\b/.test(ge);
  }, qs = (Y) => (ge) => {
    let Ee = ge.length;
    const dt = (wn) => {
      wn.attr("contenteditable", Y ? "true" : null);
    };
    for (; Ee--; ) {
      const wn = ge[Ee];
      Uo(wn) && (wn.attr("contenteditable", Y ? "false" : null), Qn.each(wn.getAll("figcaption"), dt));
    }
  }, Ar = (Y) => {
    Y.on("PreInit", () => {
      Y.parser.addNodeFilter("figure", qs(!0)), Y.serializer.addNodeFilter("figure", qs(!1));
    });
  }, sn = (Y) => (ge) => {
    const Ee = () => {
      ge.setEnabled(Y.selection.isEditable());
    };
    return Y.on("NodeChange", Ee), Ee(), () => {
      Y.off("NodeChange", Ee);
    };
  }, md = (Y) => {
    Y.ui.registry.addToggleButton("image", {
      icon: "image",
      tooltip: "Insert/edit image",
      onAction: ss(Y).open,
      onSetup: (ge) => {
        ge.setActive(be(lo(Y)));
        const Ee = Y.selection.selectorChangedWithUnbind("img:not([data-mce-object]):not([data-mce-placeholder]),figure.image", ge.setActive).unbind, dt = sn(Y)(ge);
        return () => {
          Ee(), dt();
        };
      }
    }), Y.ui.registry.addMenuItem("image", {
      icon: "image",
      text: "Image...",
      onAction: ss(Y).open,
      onSetup: sn(Y)
    }), Y.ui.registry.addContextMenu("image", { update: (ge) => Y.selection.isEditable() && (Ke(ge) || ht(ge) && !xn(ge)) ? ["image"] : [] });
  };
  var tr = () => {
    o.add("image", (Y) => {
      At(Y), Ar(Y), md(Y), hs(Y);
    });
  };
  tr();
})();
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const a = (ie, Oe, Ge) => {
    var Dt;
    return Ge(ie, Oe.prototype) ? !0 : ((Dt = ie.constructor) === null || Dt === void 0 ? void 0 : Dt.name) === Oe.name;
  }, c = (ie) => {
    const Oe = typeof ie;
    return ie === null ? "null" : Oe === "object" && Array.isArray(ie) ? "array" : Oe === "object" && a(ie, String, (Ge, Dt) => Dt.isPrototypeOf(Ge)) ? "string" : Oe;
  }, f = (ie) => (Oe) => c(Oe) === ie, g = (ie) => (Oe) => typeof Oe === ie, x = (ie) => (Oe) => ie === Oe, k = f("string"), A = f("object"), N = f("array"), H = x(null), Z = g("boolean"), K = (ie) => ie == null, J = (ie) => !K(ie), pe = g("function"), Se = (ie, Oe) => {
    if (N(ie)) {
      for (let Ge = 0, Dt = ie.length; Ge < Dt; ++Ge)
        if (!Oe(ie[Ge]))
          return !1;
      return !0;
    }
    return !1;
  }, be = () => {
  }, ye = (ie) => () => ie, re = (ie, Oe) => ie === Oe;
  class oe {
    constructor(Oe, Ge) {
      this.tag = Oe, this.value = Ge;
    }
    static some(Oe) {
      return new oe(!0, Oe);
    }
    static none() {
      return oe.singletonNone;
    }
    fold(Oe, Ge) {
      return this.tag ? Ge(this.value) : Oe();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(Oe) {
      return this.tag ? oe.some(Oe(this.value)) : oe.none();
    }
    bind(Oe) {
      return this.tag ? Oe(this.value) : oe.none();
    }
    exists(Oe) {
      return this.tag && Oe(this.value);
    }
    forall(Oe) {
      return !this.tag || Oe(this.value);
    }
    filter(Oe) {
      return !this.tag || Oe(this.value) ? this : oe.none();
    }
    getOr(Oe) {
      return this.tag ? this.value : Oe;
    }
    or(Oe) {
      return this.tag ? this : Oe;
    }
    getOrThunk(Oe) {
      return this.tag ? this.value : Oe();
    }
    orThunk(Oe) {
      return this.tag ? this : Oe();
    }
    getOrDie(Oe) {
      if (this.tag)
        return this.value;
      throw new Error(Oe ?? "Called getOrDie on None");
    }
    static from(Oe) {
      return J(Oe) ? oe.some(Oe) : oe.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(Oe) {
      this.tag && Oe(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  oe.singletonNone = new oe(!1);
  const U = Array.prototype.indexOf, ve = Array.prototype.push, Ze = (ie, Oe) => U.call(ie, Oe), rt = (ie, Oe) => Ze(ie, Oe) > -1, ee = (ie, Oe) => {
    const Ge = ie.length, Dt = new Array(Ge);
    for (let Xt = 0; Xt < Ge; Xt++) {
      const jn = ie[Xt];
      Dt[Xt] = Oe(jn, Xt);
    }
    return Dt;
  }, lt = (ie, Oe) => {
    for (let Ge = 0, Dt = ie.length; Ge < Dt; Ge++) {
      const Xt = ie[Ge];
      Oe(Xt, Ge);
    }
  }, wt = (ie, Oe, Ge) => (lt(ie, (Dt, Xt) => {
    Ge = Oe(Ge, Dt, Xt);
  }), Ge), Vt = (ie) => {
    const Oe = [];
    for (let Ge = 0, Dt = ie.length; Ge < Dt; ++Ge) {
      if (!N(ie[Ge]))
        throw new Error("Arr.flatten item " + Ge + " was not an array, input: " + ie);
      ve.apply(Oe, ie[Ge]);
    }
    return Oe;
  }, Ue = (ie, Oe) => Vt(ee(ie, Oe)), Ce = (ie, Oe) => {
    for (let Ge = 0; Ge < ie.length; Ge++) {
      const Dt = Oe(ie[Ge], Ge);
      if (Dt.isSome())
        return Dt;
    }
    return oe.none();
  }, Rn = (ie, Oe, Ge = re) => ie.exists((Dt) => Ge(Dt, Oe)), _t = (ie) => {
    const Oe = [], Ge = (Dt) => {
      Oe.push(Dt);
    };
    for (let Dt = 0; Dt < ie.length; Dt++)
      ie[Dt].each(Ge);
    return Oe;
  }, ot = (ie, Oe) => ie ? oe.some(Oe) : oe.none(), B = (ie) => (Oe) => Oe.options.get(ie), fn = (ie) => {
    const Oe = ie.options.register;
    Oe("link_assume_external_targets", {
      processor: (Ge) => {
        const Dt = k(Ge) || Z(Ge);
        return Dt ? Ge === !0 ? {
          value: 1,
          valid: Dt
        } : Ge === "http" || Ge === "https" ? {
          value: Ge,
          valid: Dt
        } : {
          value: 0,
          valid: Dt
        } : {
          valid: !1,
          message: "Must be a string or a boolean."
        };
      },
      default: !1
    }), Oe("link_context_toolbar", {
      processor: "boolean",
      default: !1
    }), Oe("link_list", { processor: (Ge) => k(Ge) || pe(Ge) || Se(Ge, A) }), Oe("link_default_target", { processor: "string" }), Oe("link_default_protocol", {
      processor: "string",
      default: "https"
    }), Oe("link_target_list", {
      processor: (Ge) => Z(Ge) || Se(Ge, A),
      default: !0
    }), Oe("link_rel_list", {
      processor: "object[]",
      default: []
    }), Oe("link_class_list", {
      processor: "object[]",
      default: []
    }), Oe("link_title", {
      processor: "boolean",
      default: !0
    }), Oe("allow_unsafe_link_target", {
      processor: "boolean",
      default: !1
    }), Oe("link_quicklink", {
      processor: "boolean",
      default: !1
    });
  }, ze = B("link_assume_external_targets"), jt = B("link_context_toolbar"), Tt = B("link_list"), Je = B("link_default_target"), pn = B("link_default_protocol"), Ro = B("link_target_list"), Rt = B("link_rel_list"), Cn = B("link_class_list"), et = B("link_title"), xt = B("allow_unsafe_link_target"), X = B("link_quicklink"), ds = Object.keys, So = Object.hasOwnProperty, At = (ie, Oe) => {
    const Ge = ds(ie);
    for (let Dt = 0, Xt = Ge.length; Dt < Xt; Dt++) {
      const jn = Ge[Dt], ss = ie[jn];
      Oe(ss, jn);
    }
  }, Pt = (ie) => (Oe, Ge) => {
    ie[Ge] = Oe;
  }, Hn = (ie, Oe, Ge, Dt) => {
    At(ie, (Xt, jn) => {
      (Oe(Xt, jn) ? Ge : Dt)(Xt, jn);
    });
  }, Nt = (ie, Oe) => {
    const Ge = {};
    return Hn(ie, Oe, Pt(Ge), be), Ge;
  }, Vn = (ie, Oe) => So.call(ie, Oe), tn = (ie, Oe) => Vn(ie, Oe) && ie[Oe] !== void 0 && ie[Oe] !== null;
  var je = tinymce.util.Tools.resolve("tinymce.util.URI"), An = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker"), qn = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const on = (ie) => J(ie) && ie.nodeName.toLowerCase() === "a", zt = (ie) => on(ie) && !!Dn(ie), vt = (ie, Oe) => {
    if (ie.collapsed)
      return [];
    {
      const Ge = ie.cloneContents(), Dt = Ge.firstChild, Xt = new An(Dt, Ge), jn = [];
      let ss = Dt;
      do
        Oe(ss) && jn.push(ss);
      while (ss = Xt.next());
      return jn;
    }
  }, oo = (ie) => /^\w+:/i.test(ie), Dn = (ie) => {
    var Oe, Ge;
    return (Ge = (Oe = ie.getAttribute("data-mce-href")) !== null && Oe !== void 0 ? Oe : ie.getAttribute("href")) !== null && Ge !== void 0 ? Ge : "";
  }, ao = (ie, Oe) => {
    const Ge = ["noopener"], Dt = ie ? ie.split(/\s+/) : [], Xt = (Uo) => qn.trim(Uo.sort().join(" ")), jn = (Uo) => (Uo = ss(Uo), Uo.length > 0 ? Uo.concat(Ge) : Ge), ss = (Uo) => Uo.filter((qs) => qn.inArray(Ge, qs) === -1), hs = Oe ? jn(Dt) : ss(Dt);
    return hs.length > 0 ? Xt(hs) : "";
  }, xs = (ie) => ie.replace(/\uFEFF/g, ""), rs = (ie, Oe) => (Oe = Oe || zs(ie.selection.getRng())[0] || ie.selection.getNode(), Do(Oe) ? oe.from(ie.dom.select("a[href]", Oe)[0]) : oe.from(ie.dom.getParent(Oe, "a[href]"))), Qo = (ie, Oe) => rs(ie, Oe).isSome(), os = (ie, Oe) => {
    const Ge = Oe.fold(() => ie.getContent({ format: "text" }), (Dt) => Dt.innerText || Dt.textContent || "");
    return xs(Ge);
  }, zs = (ie) => vt(ie, zt), it = (ie) => qn.grep(ie, zt), kt = (ie) => it(ie).length > 0, xn = (ie) => zs(ie).length > 0, hn = (ie) => {
    const Oe = ie.schema.getTextInlineElements(), Ge = (jn) => jn.nodeType === 1 && !on(jn) && !Vn(Oe, jn.nodeName.toLowerCase());
    if (rs(ie).exists((jn) => jn.hasAttribute("data-mce-block")))
      return !1;
    const Xt = ie.selection.getRng();
    return Xt.collapsed ? !0 : vt(Xt, Ge).length === 0;
  }, Do = (ie) => J(ie) && ie.nodeName === "FIGURE" && /\bimage\b/i.test(ie.className), Ss = (ie) => wt([
    "title",
    "rel",
    "class",
    "target"
  ], (Ge, Dt) => (ie[Dt].each((Xt) => {
    Ge[Dt] = Xt.length > 0 ? Xt : null;
  }), Ge), { href: ie.href }), pr = (ie, Oe) => (Oe === "http" || Oe === "https") && !oo(ie) ? Oe + "://" + ie : ie, ta = (ie, Oe) => {
    const Ge = { ...Oe };
    if (Rt(ie).length === 0 && !xt(ie)) {
      const Dt = ao(Ge.rel, Ge.target === "_blank");
      Ge.rel = Dt || null;
    }
    return oe.from(Ge.target).isNone() && Ro(ie) === !1 && (Ge.target = Je(ie)), Ge.href = pr(Ge.href, ze(ie)), Ge;
  }, Ms = (ie, Oe, Ge, Dt) => {
    Ge.each((Xt) => {
      Vn(Oe, "innerText") ? Oe.innerText = Xt : Oe.textContent = Xt;
    }), ie.dom.setAttribs(Oe, Dt), ie.selection.select(Oe);
  }, hr = (ie, Oe, Ge, Dt) => {
    const Xt = ie.dom;
    Do(Oe) ? la(Xt, Oe, Dt) : Ge.fold(() => {
      ie.execCommand("mceInsertLink", !1, Dt);
    }, (jn) => {
      ie.insertContent(Xt.createHTML("a", Dt, Xt.encode(jn)));
    });
  }, qt = (ie, Oe, Ge) => {
    const Dt = ie.selection.getNode(), Xt = rs(ie, Dt), jn = ta(ie, Ss(Ge));
    ie.undoManager.transact(() => {
      Ge.href === Oe.href && Oe.attach(), Xt.fold(() => {
        hr(ie, Dt, Ge.text, jn);
      }, (ss) => {
        ie.focus(), Ms(ie, ss, Ge.text, jn);
      });
    });
  }, Ko = (ie) => {
    const Oe = ie.dom, Ge = ie.selection, Dt = Ge.getBookmark(), Xt = Ge.getRng().cloneRange(), jn = Oe.getParent(Xt.startContainer, "a[href]", ie.getBody()), ss = Oe.getParent(Xt.endContainer, "a[href]", ie.getBody());
    jn && Xt.setStartBefore(jn), ss && Xt.setEndAfter(ss), Ge.setRng(Xt), ie.execCommand("unlink"), Ge.moveToBookmark(Dt);
  }, Lr = (ie) => {
    ie.undoManager.transact(() => {
      const Oe = ie.selection.getNode();
      Do(Oe) ? xa(ie, Oe) : Ko(ie), ie.focus();
    });
  }, ha = (ie) => {
    const {
      class: Oe,
      href: Ge,
      rel: Dt,
      target: Xt,
      text: jn,
      title: ss
    } = ie;
    return Nt({
      class: Oe.getOrNull(),
      href: Ge,
      rel: Dt.getOrNull(),
      target: Xt.getOrNull(),
      text: jn.getOrNull(),
      title: ss.getOrNull()
    }, (hs, Uo) => H(hs) === !1);
  }, ia = (ie, Oe) => {
    const Ge = ie.options.get, Dt = {
      allow_html_data_urls: Ge("allow_html_data_urls"),
      allow_script_urls: Ge("allow_script_urls"),
      allow_svg_data_urls: Ge("allow_svg_data_urls")
    }, Xt = Oe.href;
    return {
      ...Oe,
      href: je.isDomSafe(Xt, "a", Dt) ? Xt : ""
    };
  }, na = (ie, Oe, Ge) => {
    const Dt = ia(ie, Ge);
    ie.hasPlugin("rtc", !0) ? ie.execCommand("createlink", !1, ha(Dt)) : qt(ie, Oe, Dt);
  }, ks = (ie) => {
    ie.hasPlugin("rtc", !0) ? ie.execCommand("unlink") : Lr(ie);
  }, xa = (ie, Oe) => {
    var Ge;
    const Dt = ie.dom.select("img", Oe)[0];
    if (Dt) {
      const Xt = ie.dom.getParents(Dt, "a[href]", Oe)[0];
      Xt && ((Ge = Xt.parentNode) === null || Ge === void 0 || Ge.insertBefore(Dt, Xt), ie.dom.remove(Xt));
    }
  }, la = (ie, Oe, Ge) => {
    var Dt;
    const Xt = ie.select("img", Oe)[0];
    if (Xt) {
      const jn = ie.create("a", Ge);
      (Dt = Xt.parentNode) === null || Dt === void 0 || Dt.insertBefore(jn, Xt), jn.appendChild(Xt);
    }
  }, _s = (ie) => k(ie.value) ? ie.value : "", Xn = (ie) => k(ie.text) ? ie.text : k(ie.title) ? ie.title : "", wr = (ie, Oe) => {
    const Ge = [];
    return qn.each(ie, (Dt) => {
      const Xt = Xn(Dt);
      if (Dt.menu !== void 0) {
        const jn = wr(Dt.menu, Oe);
        Ge.push({
          text: Xt,
          items: jn
        });
      } else {
        const jn = Oe(Dt);
        Ge.push({
          text: Xt,
          value: jn
        });
      }
    }), Ge;
  }, Ke = (ie = _s) => (Oe) => oe.from(Oe).map((Ge) => wr(Ge, ie)), En = {
    sanitize: (ie) => Ke(_s)(ie),
    sanitizeWith: Ke,
    createUi: (ie, Oe) => (Ge) => ({
      name: ie,
      type: "listbox",
      label: Oe,
      items: Ge
    }),
    getValue: _s
  }, Ao = (ie) => tn(ie, "items"), as = (ie, Oe) => Ce(Oe, (Ge) => Ao(Ge) ? as(ie, Ge.items) : ot(Ge.value === ie, Ge)), Yr = (ie, Oe, Ge, Dt) => {
    const Xt = Dt[Oe], jn = ie.length > 0;
    return Xt !== void 0 ? as(Xt, Ge).map((ss) => ({
      url: {
        value: ss.value,
        meta: {
          text: jn ? ie : ss.text,
          attach: be
        }
      },
      text: jn ? ie : ss.text
    })) : oe.none();
  }, Xr = (ie, Oe) => Oe === "link" ? ie.link : Oe === "anchor" ? ie.anchor : oe.none(), Ne = {
    init: (ie, Oe) => {
      const Ge = {
        text: ie.text,
        title: ie.title
      }, Dt = (Uo) => {
        var qs;
        return ot(Ge.title.length <= 0, oe.from((qs = Uo.meta) === null || qs === void 0 ? void 0 : qs.title).getOr(""));
      }, Xt = (Uo) => {
        var qs;
        return ot(Ge.text.length <= 0, oe.from((qs = Uo.meta) === null || qs === void 0 ? void 0 : qs.text).getOr(Uo.value));
      }, jn = (Uo) => {
        const qs = Xt(Uo.url), Ar = Dt(Uo.url);
        return qs.isSome() || Ar.isSome() ? oe.some({
          ...qs.map((sn) => ({ text: sn })).getOr({}),
          ...Ar.map((sn) => ({ title: sn })).getOr({})
        }) : oe.none();
      }, ss = (Uo, qs) => {
        const Ar = Xr(Oe, qs).getOr([]);
        return Yr(Ge.text, qs, Ar, Uo);
      };
      return { onChange: (Uo, qs) => {
        const Ar = qs.name;
        return Ar === "url" ? jn(Uo()) : rt([
          "anchor",
          "link"
        ], Ar) ? ss(Uo(), Ar) : ((Ar === "text" || Ar === "title") && (Ge[Ar] = Uo()[Ar]), oe.none());
      } };
    },
    getDelta: Yr
  };
  var Ae = tinymce.util.Tools.resolve("tinymce.util.Delay");
  const ct = (ie, Oe, Ge) => {
    const Dt = ie.selection.getRng();
    Ae.setEditorTimeout(ie, () => {
      ie.windowManager.confirm(Oe, (Xt) => {
        ie.selection.setRng(Dt), Ge(Xt);
      });
    });
  }, Ct = (ie) => {
    const Oe = ie.href;
    return Oe.indexOf("@") > 0 && Oe.indexOf("/") === -1 && Oe.indexOf("mailto:") === -1 ? oe.some({
      message: "The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?",
      preprocess: (Dt) => ({
        ...Dt,
        href: "mailto:" + Oe
      })
    }) : oe.none();
  }, Kn = (ie, Oe) => (Ge) => {
    const Dt = Ge.href;
    return ie === 1 && !oo(Dt) || ie === 0 && /^\s*www(\.|\d\.)/i.test(Dt) ? oe.some({
      message: `The URL you entered seems to be an external link. Do you want to add the required ${Oe}:// prefix?`,
      preprocess: (jn) => ({
        ...jn,
        href: Oe + "://" + Dt
      })
    }) : oe.none();
  }, Bo = { preprocess: (ie, Oe) => Ce([
    Ct,
    Kn(ze(ie), pn(ie))
  ], (Ge) => Ge(Oe)).fold(() => Promise.resolve(Oe), (Ge) => new Promise((Dt) => {
    ct(ie, Ge.message, (Xt) => {
      Dt(Xt ? Ge.preprocess(Oe) : Oe);
    });
  })) }, $e = { getAnchors: (ie) => {
    const Oe = ie.dom.select("a:not([href])"), Ge = Ue(Oe, (Dt) => {
      const Xt = Dt.name || Dt.id;
      return Xt ? [{
        text: Xt,
        value: "#" + Xt
      }] : [];
    });
    return Ge.length > 0 ? oe.some([{
      text: "None",
      value: ""
    }].concat(Ge)) : oe.none();
  } }, Pe = { getClasses: (ie) => {
    const Oe = Cn(ie);
    return Oe.length > 0 ? En.sanitize(Oe) : oe.none();
  } }, Ie = (ie) => {
    try {
      return oe.some(JSON.parse(ie));
    } catch {
      return oe.none();
    }
  }, Zt = { getLinks: (ie) => {
    const Oe = (Dt) => ie.convertURL(Dt.value || Dt.url || "", "href"), Ge = Tt(ie);
    return new Promise((Dt) => {
      k(Ge) ? fetch(Ge).then((Xt) => Xt.ok ? Xt.text().then(Ie) : Promise.reject()).then(Dt, () => Dt(oe.none())) : pe(Ge) ? Ge((Xt) => Dt(oe.some(Xt))) : Dt(oe.from(Ge));
    }).then((Dt) => Dt.bind(En.sanitizeWith(Oe)).map((Xt) => Xt.length > 0 ? [{
      text: "None",
      value: ""
    }].concat(Xt) : Xt));
  } }, Jn = { getRels: (ie, Oe) => {
    const Ge = Rt(ie);
    if (Ge.length > 0) {
      const Dt = Rn(Oe, "_blank"), Xt = xt(ie) === !1, jn = (hs) => ao(En.getValue(hs), Dt);
      return (Xt ? En.sanitizeWith(jn) : En.sanitize)(Ge);
    }
    return oe.none();
  } }, Zn = [
    {
      text: "Current window",
      value: ""
    },
    {
      text: "New window",
      value: "_blank"
    }
  ], Qn = { getTargets: (ie) => {
    const Oe = Ro(ie);
    return N(Oe) ? En.sanitize(Oe).orThunk(() => oe.some(Zn)) : Oe === !1 ? oe.none() : oe.some(Zn);
  } }, co = (ie, Oe, Ge) => {
    const Dt = ie.getAttrib(Oe, Ge);
    return Dt !== null && Dt.length > 0 ? oe.some(Dt) : oe.none();
  }, Jo = (ie, Oe) => {
    const Ge = ie.dom, Xt = hn(ie) ? oe.some(os(ie.selection, Oe)) : oe.none(), jn = Oe.bind((Ar) => oe.from(Ge.getAttrib(Ar, "href"))), ss = Oe.bind((Ar) => oe.from(Ge.getAttrib(Ar, "target"))), hs = Oe.bind((Ar) => co(Ge, Ar, "rel")), Uo = Oe.bind((Ar) => co(Ge, Ar, "class")), qs = Oe.bind((Ar) => co(Ge, Ar, "title"));
    return {
      url: jn,
      text: Xt,
      title: qs,
      target: ss,
      rel: hs,
      linkClass: Uo
    };
  }, Wa = { collect: (ie, Oe) => Zt.getLinks(ie).then((Ge) => {
    const Dt = Jo(ie, Oe);
    return {
      anchor: Dt,
      catalogs: {
        targets: Qn.getTargets(ie),
        rels: Jn.getRels(ie, Dt.target),
        classes: Pe.getClasses(ie),
        anchor: $e.getAnchors(ie),
        link: Ge
      },
      optNode: Oe,
      flags: { titleEnabled: et(ie) }
    };
  }) }, Ti = (ie, Oe) => (Ge) => {
    const Dt = Ge.getData();
    if (!Dt.url.value) {
      ks(ie), Ge.close();
      return;
    }
    const Xt = (hs) => oe.from(Dt[hs]).filter((Uo) => !Rn(Oe.anchor[hs], Uo)), jn = {
      href: Dt.url.value,
      text: Xt("text"),
      target: Xt("target"),
      rel: Xt("rel"),
      class: Xt("linkClass"),
      title: Xt("title")
    }, ss = {
      href: Dt.url.value,
      attach: Dt.url.meta !== void 0 && Dt.url.meta.attach ? Dt.url.meta.attach : be
    };
    Bo.preprocess(ie, jn).then((hs) => {
      na(ie, ss, hs);
    }), Ge.close();
  }, Ai = (ie) => {
    const Oe = rs(ie);
    return Wa.collect(ie, Oe);
  }, ko = (ie, Oe) => {
    const Ge = ie.anchor, Dt = Ge.url.getOr("");
    return {
      url: {
        value: Dt,
        meta: { original: { value: Dt } }
      },
      text: Ge.text.getOr(""),
      title: Ge.title.getOr(""),
      anchor: Dt,
      link: Dt,
      rel: Ge.rel.getOr(""),
      target: Ge.target.or(Oe).getOr(""),
      linkClass: Ge.linkClass.getOr("")
    };
  }, Zo = (ie, Oe, Ge) => {
    const Dt = [{
      name: "url",
      type: "urlinput",
      filetype: "file",
      label: "URL",
      picker_text: "Browse links"
    }], Xt = ie.anchor.text.map(() => ({
      name: "text",
      type: "input",
      label: "Text to display"
    })).toArray(), jn = ie.flags.titleEnabled ? [{
      name: "title",
      type: "input",
      label: "Title"
    }] : [], ss = oe.from(Je(Ge)), hs = ko(ie, ss), Uo = ie.catalogs, qs = Ne.init(hs, Uo);
    return {
      title: "Insert/Edit Link",
      size: "normal",
      body: {
        type: "panel",
        items: Vt([
          Dt,
          Xt,
          jn,
          _t([
            Uo.anchor.map(En.createUi("anchor", "Anchors")),
            Uo.rels.map(En.createUi("rel", "Rel")),
            Uo.targets.map(En.createUi("target", "Open link in...")),
            Uo.link.map(En.createUi("link", "Link list")),
            Uo.classes.map(En.createUi("linkClass", "Class"))
          ])
        ])
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: hs,
      onChange: (sn, { name: md }) => {
        qs.onChange(sn.getData, { name: md }).each((tr) => {
          sn.setData(tr);
        });
      },
      onSubmit: Oe
    };
  }, Rs = (ie) => {
    Ai(ie).then((Ge) => {
      const Dt = Ti(ie, Ge);
      return Zo(Ge, Dt, ie);
    }).then((Ge) => {
      ie.windowManager.open(Ge);
    });
  }, Ba = (ie) => {
    ie.addCommand("mceLink", (Oe, Ge) => {
      (Ge == null ? void 0 : Ge.dialog) === !0 || !X(ie) ? Rs(ie) : ie.dispatch("contexttoolbar-show", { toolbarKey: "quicklink" });
    });
  }, ca = (ie) => {
    ie.addShortcut("Meta+K", "", () => {
      ie.execCommand("mceLink");
    });
  }, gr = (ie) => {
    let Oe = ie;
    return {
      get: () => Oe,
      set: (Xt) => {
        Oe = Xt;
      }
    };
  }, Qs = (ie) => {
    const Oe = gr(oe.none()), Ge = () => Oe.get().each(ie);
    return {
      clear: () => {
        Ge(), Oe.set(oe.none());
      },
      isSet: () => Oe.get().isSome(),
      get: () => Oe.get(),
      set: (hs) => {
        Ge(), Oe.set(oe.some(hs));
      }
    };
  }, ii = () => {
    const ie = Qs(be);
    return {
      ...ie,
      on: (Ge) => ie.get().each(Ge)
    };
  };
  var xc = tinymce.util.Tools.resolve("tinymce.util.VK");
  const Is = (ie, Oe) => {
    document.body.appendChild(ie), ie.dispatchEvent(Oe), document.body.removeChild(ie);
  }, ka = (ie) => {
    const Oe = document.createElement("a");
    Oe.target = "_blank", Oe.href = ie, Oe.rel = "noreferrer noopener";
    const Ge = new MouseEvent("click", {
      bubbles: !0,
      cancelable: !0,
      view: window
    });
    document.dispatchEvent(Ge), Is(Oe, Ge);
  }, li = (ie) => ie.altKey === !0 && ie.shiftKey === !1 && ie.ctrlKey === !1 && ie.metaKey === !1, Qr = (ie, Oe) => {
    if (Oe) {
      const Ge = Dn(Oe);
      if (/^#/.test(Ge)) {
        const Dt = ie.dom.select(Ge);
        Dt.length && ie.selection.scrollIntoView(Dt[0], !0);
      } else
        ka(Oe.href);
    }
  }, Oi = (ie) => {
    const Oe = ie.selection.getRng(), Ge = Oe.startContainer;
    return zt(Ge) && Oe.startContainer === Oe.endContainer && ie.dom.select("img", Ge).length === 1;
  }, cl = (ie, Oe) => {
    const Ge = it(ie.dom.getParents(Oe));
    return ot(Ge.length === 1, Ge[0]);
  }, Za = (ie) => {
    const Oe = zs(ie.selection.getRng());
    return ot(Oe.length > 0, Oe[0]).or(cl(ie, ie.selection.getNode()));
  }, Di = (ie) => ie.selection.isCollapsed() || Oi(ie) ? cl(ie, ie.selection.getStart()) : Za(ie), ji = (ie) => {
    const Oe = ii(), Ge = () => Oe.get().or(Di(ie)), Dt = () => Ge().each((Xt) => Qr(ie, Xt));
    return ie.on("contextmenu", (Xt) => {
      cl(ie, Xt.target).each(Oe.set);
    }), ie.on("SelectionChange", () => {
      Oe.isSet() || Di(ie).each(Oe.set);
    }), ie.on("click", (Xt) => {
      Oe.clear();
      const jn = it(ie.dom.getParents(Xt.target));
      jn.length === 1 && xc.metaKeyPressed(Xt) && (Xt.preventDefault(), Qr(ie, jn[0]));
    }), ie.on("keydown", (Xt) => {
      Oe.clear(), !Xt.isDefaultPrevented() && Xt.keyCode === 13 && li(Xt) && Ge().each((jn) => {
        Xt.preventDefault(), Qr(ie, jn);
      });
    }), { gotoSelectedLink: Dt };
  }, uu = (ie) => () => {
    ie.execCommand("mceLink", !1, { dialog: !0 });
  }, vi = (ie, Oe) => (ie.on("NodeChange", Oe), () => ie.off("NodeChange", Oe)), Bl = (ie) => (Oe) => {
    const Ge = () => {
      Oe.setActive(!ie.mode.isReadOnly() && Qo(ie, ie.selection.getNode())), Oe.setEnabled(ie.selection.isEditable());
    };
    return Ge(), vi(ie, Ge);
  }, La = (ie) => (Oe) => {
    const Ge = () => {
      Oe.setEnabled(ie.selection.isEditable());
    };
    return Ge(), vi(ie, Ge);
  }, Wi = (ie) => (Oe) => {
    const Ge = (jn) => kt(jn) || xn(ie.selection.getRng()), Dt = ie.dom.getParents(ie.selection.getStart()), Xt = (jn) => {
      Oe.setEnabled(Ge(jn) && ie.selection.isEditable());
    };
    return Xt(Dt), vi(ie, (jn) => Xt(jn.parents));
  }, Xl = (ie, Oe) => {
    ie.ui.registry.addToggleButton("link", {
      icon: "link",
      tooltip: "Insert/edit link",
      shortcut: "Meta+K",
      onAction: uu(ie),
      onSetup: Bl(ie)
    }), ie.ui.registry.addButton("openlink", {
      icon: "new-tab",
      tooltip: "Open link",
      onAction: Oe.gotoSelectedLink,
      onSetup: Wi(ie)
    }), ie.ui.registry.addButton("unlink", {
      icon: "unlink",
      tooltip: "Remove link",
      onAction: () => ks(ie),
      onSetup: Wi(ie)
    });
  }, wc = (ie, Oe) => {
    ie.ui.registry.addMenuItem("openlink", {
      text: "Open link",
      icon: "new-tab",
      onAction: Oe.gotoSelectedLink,
      onSetup: Wi(ie)
    }), ie.ui.registry.addMenuItem("link", {
      icon: "link",
      text: "Link...",
      shortcut: "Meta+K",
      onAction: uu(ie),
      onSetup: La(ie)
    }), ie.ui.registry.addMenuItem("unlink", {
      icon: "unlink",
      text: "Remove link",
      onAction: () => ks(ie),
      onSetup: Wi(ie)
    });
  }, fd = (ie) => {
    const Oe = "link unlink openlink", Ge = "link";
    ie.ui.registry.addContextMenu("link", {
      update: (Dt) => ie.dom.isEditable(Dt) ? kt(ie.dom.getParents(Dt, "a")) ? Oe : Ge : ""
    });
  }, du = (ie, Oe) => {
    const Ge = (jn) => {
      jn.selection.collapse(!1);
    }, Dt = (jn) => {
      const ss = ie.selection.getNode();
      return jn.setEnabled(Qo(ie, ss)), be;
    }, Xt = (jn) => {
      const ss = rs(ie), hs = hn(ie);
      if (ss.isNone() && hs) {
        const Uo = os(ie.selection, ss);
        return ot(Uo.length === 0, jn);
      } else
        return oe.none();
    };
    ie.ui.registry.addContextForm("quicklink", {
      launch: {
        type: "contextformtogglebutton",
        icon: "link",
        tooltip: "Link",
        onSetup: Bl(ie)
      },
      label: "Link",
      predicate: (jn) => jt(ie) && Qo(ie, jn),
      initValue: () => rs(ie).fold(ye(""), Dn),
      commands: [
        {
          type: "contextformtogglebutton",
          icon: "link",
          tooltip: "Link",
          primary: !0,
          onSetup: (jn) => {
            const ss = ie.selection.getNode();
            return jn.setActive(Qo(ie, ss)), Bl(ie)(jn);
          },
          onAction: (jn) => {
            const ss = jn.getValue(), hs = Xt(ss);
            na(ie, {
              href: ss,
              attach: be
            }, {
              href: ss,
              text: hs,
              title: oe.none(),
              rel: oe.none(),
              target: oe.from(Je(ie)),
              class: oe.none()
            }), Ge(ie), jn.hide();
          }
        },
        {
          type: "contextformbutton",
          icon: "unlink",
          tooltip: "Remove link",
          onSetup: Dt,
          onAction: (jn) => {
            ks(ie), jn.hide();
          }
        },
        {
          type: "contextformbutton",
          icon: "new-tab",
          tooltip: "Open link",
          onSetup: Dt,
          onAction: (jn) => {
            Oe.gotoSelectedLink(), jn.hide();
          }
        }
      ]
    });
  }, bi = (ie) => {
    const Oe = ji(ie);
    Xl(ie, Oe), wc(ie, Oe), fd(ie), du(ie, Oe);
  };
  var Fu = () => {
    o.add("link", (ie) => {
      fn(ie), Ba(ie), bi(ie), ca(ie);
    });
  };
  Fu();
})();
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const a = (R, V, se) => {
    var De;
    return se(R, V.prototype) ? !0 : ((De = R.constructor) === null || De === void 0 ? void 0 : De.name) === V.name;
  }, c = (R) => {
    const V = typeof R;
    return R === null ? "null" : V === "object" && Array.isArray(R) ? "array" : V === "object" && a(R, String, (se, De) => De.isPrototypeOf(se)) ? "string" : V;
  }, f = (R) => (V) => c(V) === R, g = (R) => (V) => typeof V === R, x = f("string"), k = f("object"), A = f("array"), N = g("boolean"), H = (R) => R == null, Z = (R) => !H(R), K = g("function"), J = g("number"), pe = () => {
  }, Se = (R, V) => (se) => R(V(se)), be = (R) => () => R, ye = (R, V) => R === V;
  function re(R, ...V) {
    return (...se) => {
      const De = V.concat(se);
      return R.apply(null, De);
    };
  }
  const oe = (R) => (V) => !R(V), U = be(!1);
  class ve {
    constructor(V, se) {
      this.tag = V, this.value = se;
    }
    static some(V) {
      return new ve(!0, V);
    }
    static none() {
      return ve.singletonNone;
    }
    fold(V, se) {
      return this.tag ? se(this.value) : V();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(V) {
      return this.tag ? ve.some(V(this.value)) : ve.none();
    }
    bind(V) {
      return this.tag ? V(this.value) : ve.none();
    }
    exists(V) {
      return this.tag && V(this.value);
    }
    forall(V) {
      return !this.tag || V(this.value);
    }
    filter(V) {
      return !this.tag || V(this.value) ? this : ve.none();
    }
    getOr(V) {
      return this.tag ? this.value : V;
    }
    or(V) {
      return this.tag ? this : V;
    }
    getOrThunk(V) {
      return this.tag ? this.value : V();
    }
    orThunk(V) {
      return this.tag ? this : V();
    }
    getOrDie(V) {
      if (this.tag)
        return this.value;
      throw new Error(V ?? "Called getOrDie on None");
    }
    static from(V) {
      return Z(V) ? ve.some(V) : ve.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(V) {
      this.tag && V(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  ve.singletonNone = new ve(!1);
  const Ze = Array.prototype.slice, rt = Array.prototype.indexOf, ee = Array.prototype.push, lt = (R, V) => rt.call(R, V), wt = (R, V) => lt(R, V) > -1, Vt = (R, V) => {
    for (let se = 0, De = R.length; se < De; se++) {
      const Le = R[se];
      if (V(Le, se))
        return !0;
    }
    return !1;
  }, Ue = (R, V) => {
    const se = R.length, De = new Array(se);
    for (let Le = 0; Le < se; Le++) {
      const $t = R[Le];
      De[Le] = V($t, Le);
    }
    return De;
  }, Ce = (R, V) => {
    for (let se = 0, De = R.length; se < De; se++) {
      const Le = R[se];
      V(Le, se);
    }
  }, Rn = (R, V) => {
    const se = [];
    for (let De = 0, Le = R.length; De < Le; De++) {
      const $t = R[De];
      V($t, De) && se.push($t);
    }
    return se;
  }, _t = (R, V) => {
    if (R.length === 0)
      return [];
    {
      let se = V(R[0]);
      const De = [];
      let Le = [];
      for (let $t = 0, vo = R.length; $t < vo; $t++) {
        const Lo = R[$t], Mo = V(Lo);
        Mo !== se && (De.push(Le), Le = []), se = Mo, Le.push(Lo);
      }
      return Le.length !== 0 && De.push(Le), De;
    }
  }, ot = (R, V, se) => (Ce(R, (De, Le) => {
    se = V(se, De, Le);
  }), se), B = (R, V, se) => {
    for (let De = 0, Le = R.length; De < Le; De++) {
      const $t = R[De];
      if (V($t, De))
        return ve.some($t);
      if (se($t, De))
        break;
    }
    return ve.none();
  }, fn = (R, V) => B(R, V, U), ze = (R) => {
    const V = [];
    for (let se = 0, De = R.length; se < De; ++se) {
      if (!A(R[se]))
        throw new Error("Arr.flatten item " + se + " was not an array, input: " + R);
      ee.apply(V, R[se]);
    }
    return V;
  }, jt = (R, V) => ze(Ue(R, V)), Tt = (R) => {
    const V = Ze.call(R, 0);
    return V.reverse(), V;
  }, Je = (R, V) => V >= 0 && V < R.length ? ve.some(R[V]) : ve.none(), pn = (R) => Je(R, 0), Ro = (R) => Je(R, R.length - 1), Rt = (R, V) => {
    const se = [], De = K(V) ? (Le) => Vt(se, ($t) => V($t, Le)) : (Le) => wt(se, Le);
    for (let Le = 0, $t = R.length; Le < $t; Le++) {
      const vo = R[Le];
      De(vo) || se.push(vo);
    }
    return se;
  }, Cn = (R, V, se = ye) => R.exists((De) => se(De, V)), et = (R, V, se = ye) => xt(R, V, se).getOr(R.isNone() && V.isNone()), xt = (R, V, se) => R.isSome() && V.isSome() ? ve.some(se(R.getOrDie(), V.getOrDie())) : ve.none(), X = 8, ds = 9, So = 11, At = 1, Pt = 3, Hn = (R, V) => {
    const De = (V || document).createElement("div");
    if (De.innerHTML = R, !De.hasChildNodes() || De.childNodes.length > 1) {
      const Le = "HTML does not have a single root node";
      throw console.error(Le, R), new Error(Le);
    }
    return tn(De.childNodes[0]);
  }, Nt = (R, V) => {
    const De = (V || document).createElement(R);
    return tn(De);
  }, Vn = (R, V) => {
    const De = (V || document).createTextNode(R);
    return tn(De);
  }, tn = (R) => {
    if (R == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: R };
  }, An = {
    fromHtml: Hn,
    fromTag: Nt,
    fromText: Vn,
    fromDom: tn,
    fromPoint: (R, V, se) => ve.from(R.dom.elementFromPoint(V, se)).map(tn)
  }, qn = (R, V) => {
    const se = R.dom;
    if (se.nodeType !== At)
      return !1;
    {
      const De = se;
      if (De.matches !== void 0)
        return De.matches(V);
      if (De.msMatchesSelector !== void 0)
        return De.msMatchesSelector(V);
      if (De.webkitMatchesSelector !== void 0)
        return De.webkitMatchesSelector(V);
      if (De.mozMatchesSelector !== void 0)
        return De.mozMatchesSelector(V);
      throw new Error("Browser lacks native selectors");
    }
  }, on = (R, V) => R.dom === V.dom, zt = (R, V) => {
    const se = R.dom, De = V.dom;
    return se === De ? !1 : se.contains(De);
  }, vt = qn, oo = typeof window < "u" ? window : Function("return this;")(), Dn = (R, V) => {
    let se = V ?? oo;
    for (let De = 0; De < R.length && se !== void 0 && se !== null; ++De)
      se = se[R[De]];
    return se;
  }, ao = (R, V) => {
    const se = R.split(".");
    return Dn(se, V);
  }, xs = (R, V) => ao(R, V), rs = (R, V) => {
    const se = xs(R, V);
    if (se == null)
      throw new Error(R + " not available on this browser");
    return se;
  }, Qo = Object.getPrototypeOf, os = (R) => rs("HTMLElement", R), zs = (R) => {
    const V = ao("ownerDocument.defaultView", R);
    return k(R) && (os(V).prototype.isPrototypeOf(R) || /^HTML\w*Element$/.test(Qo(R).constructor.name));
  }, it = (R) => R.dom.nodeName.toLowerCase(), kt = (R) => R.dom.nodeType, xn = (R) => (V) => kt(V) === R, hn = (R) => kt(R) === X || it(R) === "#comment", Do = (R) => Ss(R) && zs(R.dom), Ss = xn(At), pr = xn(Pt), ta = xn(ds), Ms = xn(So), hr = (R) => (V) => Ss(V) && it(V) === R, qt = (R) => An.fromDom(R.dom.ownerDocument), Ko = (R) => ta(R) ? R : qt(R), Lr = (R) => ve.from(R.dom.parentNode).map(An.fromDom), ha = (R) => ve.from(R.dom.parentElement).map(An.fromDom), ia = (R) => ve.from(R.dom.nextSibling).map(An.fromDom), na = (R) => Ue(R.dom.childNodes, An.fromDom), ks = (R, V) => {
    const se = R.dom.childNodes;
    return ve.from(se[V]).map(An.fromDom);
  }, xa = (R) => ks(R, 0), la = (R) => ks(R, R.dom.childNodes.length - 1), _s = (R) => Ms(R) && Z(R.dom.host), wr = K(Element.prototype.attachShadow) && K(Node.prototype.getRootNode) ? (R) => An.fromDom(R.dom.getRootNode()) : Ko, Ke = (R) => {
    const V = wr(R);
    return _s(V) ? ve.some(V) : ve.none();
  }, ht = (R) => An.fromDom(R.dom.host), gn = (R) => {
    const V = pr(R) ? R.dom.parentNode : R.dom;
    if (V == null || V.ownerDocument === null)
      return !1;
    const se = V.ownerDocument;
    return Ke(An.fromDom(V)).fold(() => se.body.contains(V), Se(gn, ht));
  };
  var En = (R, V, se, De, Le) => R(se, De) ? ve.some(se) : K(Le) && Le(se) ? ve.none() : V(se, De, Le);
  const Ao = (R, V, se) => {
    let De = R.dom;
    const Le = K(se) ? se : U;
    for (; De.parentNode; ) {
      De = De.parentNode;
      const $t = An.fromDom(De);
      if (V($t))
        return ve.some($t);
      if (Le($t))
        break;
    }
    return ve.none();
  }, as = (R, V, se) => En((Le, $t) => $t(Le), Ao, R, V, se), Yr = (R, V, se) => Ao(R, (De) => qn(De, V), se), Xr = (R, V, se) => En((Le, $t) => qn(Le, $t), Yr, R, V, se), Tr = (R) => Xr(R, "[contenteditable]"), Ne = (R, V = !1) => gn(R) ? R.dom.isContentEditable : Tr(R).fold(be(V), (se) => Ae(se) === "true"), Ae = (R) => R.dom.contentEditable, ct = (R, V) => {
    Lr(R).each((De) => {
      De.dom.insertBefore(V.dom, R.dom);
    });
  }, Ct = (R, V) => {
    ia(R).fold(() => {
      Lr(R).each((Le) => {
        lo(Le, V);
      });
    }, (De) => {
      ct(De, V);
    });
  }, Kn = (R, V) => {
    xa(R).fold(() => {
      lo(R, V);
    }, (De) => {
      R.dom.insertBefore(V.dom, De.dom);
    });
  }, lo = (R, V) => {
    R.dom.appendChild(V.dom);
  }, Bo = (R, V) => {
    Ce(V, (se) => {
      ct(R, se);
    });
  }, Xs = (R, V) => {
    Ce(V, (se) => {
      lo(R, se);
    });
  }, $e = (R) => {
    R.dom.textContent = "", Ce(na(R), (V) => {
      Oo(V);
    });
  }, Oo = (R) => {
    const V = R.dom;
    V.parentNode !== null && V.parentNode.removeChild(V);
  };
  var Pe = tinymce.util.Tools.resolve("tinymce.dom.RangeUtils"), Ie = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker"), Lt = tinymce.util.Tools.resolve("tinymce.util.VK");
  const Zt = (R) => Ue(R, An.fromDom), kn = Object.keys, Jn = (R, V) => {
    const se = kn(R);
    for (let De = 0, Le = se.length; De < Le; De++) {
      const $t = se[De], vo = R[$t];
      V(vo, $t);
    }
  }, Zn = (R) => (V, se) => {
    R[se] = V;
  }, Gn = (R, V, se, De) => {
    Jn(R, (Le, $t) => {
      (V(Le, $t) ? se : De)(Le, $t);
    });
  }, Qn = (R, V) => {
    const se = {};
    return Gn(R, V, Zn(se), pe), se;
  }, co = (R, V, se) => {
    if (x(se) || N(se) || J(se))
      R.setAttribute(V, se + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", V, ":: Value ", se, ":: Element ", R), new Error("Attribute value was not simple");
  }, Jo = (R, V) => {
    const se = R.dom;
    Jn(V, (De, Le) => {
      co(se, Le, De);
    });
  }, Gs = (R) => ot(R.dom.attributes, (V, se) => (V[se.name] = se.value, V), {}), Wa = (R, V) => An.fromDom(R.dom.cloneNode(V)), Ti = (R) => Wa(R, !0), Ai = (R, V) => {
    const se = An.fromTag(V), De = Gs(R);
    return Jo(se, De), se;
  }, ko = (R, V) => {
    const se = Ai(R, V);
    Ct(R, se);
    const De = na(R);
    return Xs(se, De), Oo(R), se;
  };
  var Zo = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), Rs = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const Ba = (R) => (V) => Z(V) && V.nodeName.toLowerCase() === R, ca = (R) => (V) => Z(V) && R.test(V.nodeName), gr = (R) => Z(R) && R.nodeType === 3, Qs = (R) => Z(R) && R.nodeType === 1, ii = ca(/^(OL|UL|DL)$/), xc = ca(/^(OL|UL)$/), Is = Ba("ol"), ka = ca(/^(LI|DT|DD)$/), li = ca(/^(DT|DD)$/), Qr = ca(/^(TH|TD)$/), Oi = Ba("br"), cl = (R) => {
    var V;
    return ((V = R.parentNode) === null || V === void 0 ? void 0 : V.firstChild) === R;
  }, Za = (R, V) => Z(V) && V.nodeName in R.schema.getTextBlockElements(), Di = (R, V) => Z(R) && R.nodeName in V, ji = (R, V) => Z(V) && V.nodeName in R.schema.getVoidElements(), uu = (R, V) => Oi(V) ? R.isBlock(V.nextSibling) && !Oi(V.previousSibling) : !1, vi = (R, V, se) => {
    const De = R.isEmpty(V);
    return se && R.select("span[data-mce-type=bookmark]", V).length > 0 ? !1 : De;
  }, Bl = (R, V) => R.isChildOf(V, R.getRoot()), La = (R) => (V) => V.options.get(R), Wi = (R) => {
    const V = R.options.register;
    V("lists_indent_on_tab", {
      processor: "boolean",
      default: !0
    });
  }, Xl = La("lists_indent_on_tab"), wc = La("forced_root_block"), fd = La("forced_root_block_attrs"), du = (R, V, se = {}) => {
    const De = R.dom, Le = R.schema.getBlockElements(), $t = De.createFragment(), vo = wc(R), Lo = fd(R);
    let Mo, go, Hr = !1;
    for (go = De.create(vo, {
      ...Lo,
      ...se.style ? { style: se.style } : {}
    }), Di(V.firstChild, Le) || $t.appendChild(go); Mo = V.firstChild; ) {
      const fa = Mo.nodeName;
      !Hr && (fa !== "SPAN" || Mo.getAttribute("data-mce-type") !== "bookmark") && (Hr = !0), Di(Mo, Le) ? ($t.appendChild(Mo), go = null) : (go || (go = De.create(vo, Lo), $t.appendChild(go)), go.appendChild(Mo));
    }
    return !Hr && go && go.appendChild(De.create("br", { "data-mce-bogus": "1" })), $t;
  }, bi = Zo.DOM, Fu = (R, V, se) => {
    const De = (go) => {
      const Hr = go.parentNode;
      Hr && Rs.each(Le, (fa) => {
        Hr.insertBefore(fa, se.parentNode);
      }), bi.remove(go);
    }, Le = bi.select('span[data-mce-type="bookmark"]', V), $t = du(R, se), vo = bi.createRng();
    vo.setStartAfter(se), vo.setEndAfter(V);
    const Lo = vo.extractContents();
    for (let go = Lo.firstChild; go; go = go.firstChild)
      if (go.nodeName === "LI" && R.dom.isEmpty(go)) {
        bi.remove(go);
        break;
      }
    R.dom.isEmpty(Lo) || bi.insertAfter(Lo, V), bi.insertAfter($t, V);
    const Mo = se.parentElement;
    Mo && vi(R.dom, Mo) && De(Mo), bi.remove(se), vi(R.dom, V) && bi.remove(V);
  }, ie = hr("dd"), Oe = hr("dt"), Ge = (R, V) => {
    ie(V) ? ko(V, "dt") : Oe(V) && ha(V).each((se) => Fu(R, se.dom, V.dom));
  }, Dt = (R) => {
    Oe(R) && ko(R, "dd");
  }, Xt = (R, V, se) => {
    V === "Indent" ? Ce(se, Dt) : Ce(se, (De) => Ge(R, De));
  }, jn = (R, V) => {
    if (gr(R))
      return {
        container: R,
        offset: V
      };
    const se = Pe.getNode(R, V);
    return gr(se) ? {
      container: se,
      offset: V >= R.childNodes.length ? se.data.length : 0
    } : se.previousSibling && gr(se.previousSibling) ? {
      container: se.previousSibling,
      offset: se.previousSibling.data.length
    } : se.nextSibling && gr(se.nextSibling) ? {
      container: se.nextSibling,
      offset: 0
    } : {
      container: R,
      offset: V
    };
  }, ss = (R) => {
    const V = R.cloneRange(), se = jn(R.startContainer, R.startOffset);
    V.setStart(se.container, se.offset);
    const De = jn(R.endContainer, R.endOffset);
    return V.setEnd(De.container, De.offset), V;
  }, hs = [
    "OL",
    "UL",
    "DL"
  ], Uo = hs.join(","), qs = (R, V) => {
    const se = V || R.selection.getStart(!0);
    return R.dom.getParent(se, Uo, wn(R, se));
  }, Ar = (R, V) => Z(R) && V.length === 1 && V[0] === R, sn = (R) => Rn(R.querySelectorAll(Uo), ii), md = (R) => {
    const V = qs(R), se = R.selection.getSelectedBlocks();
    return Ar(V, se) ? sn(V) : Rn(se, (De) => ii(De) && V !== De);
  }, tr = (R, V) => {
    const se = Rs.map(V, (De) => {
      const Le = R.dom.getParent(De, "li,dd,dt", wn(R, De));
      return Le || De;
    });
    return Rt(se);
  }, Y = (R) => {
    const V = R.selection.getSelectedBlocks();
    return Rn(tr(R, V), ka);
  }, ge = (R) => Rn(Y(R), li), Ee = (R, V) => {
    const se = R.dom.getParents(V, "TD,TH");
    return se.length > 0 ? se[0] : R.getBody();
  }, dt = (R, V) => !ii(V) && !ka(V) && Vt(hs, (se) => R.isValidChild(V.nodeName, se)), wn = (R, V) => {
    const se = R.dom.getParents(V, R.dom.isBlock), De = ($t) => $t.nodeName.toLowerCase() !== wc(R);
    return fn(se, ($t) => De($t) && dt(R.schema, $t)).getOr(R.getBody());
  }, Yo = (R) => Lr(R).exists((V) => ka(V.dom) && xa(V).exists((se) => !ii(se.dom)) && la(V).exists((se) => !ii(se.dom))), Ln = (R, V) => {
    const se = R.dom.getParents(V, "ol,ul", wn(R, V));
    return Ro(se);
  }, Or = (R) => {
    const V = Ln(R, R.selection.getStart()), se = Rn(R.selection.getSelectedBlocks(), xc);
    return V.toArray().concat(se);
  }, Kt = (R) => {
    const V = R.selection.getStart();
    return R.dom.getParents(V, "ol,ul", wn(R, V));
  }, lr = (R) => {
    const V = Or(R), se = Kt(R);
    return fn(se, (De) => Yo(An.fromDom(De))).fold(() => yi(R, V), (De) => [De]);
  }, yi = (R, V) => {
    const se = Ue(V, (De) => Ln(R, De).getOr(De));
    return Rt(se);
  }, Cr = (R) => /\btox\-/.test(R.className), ga = (R, V) => B(R, ii, Qr).exists((se) => se.nodeName === V && !Cr(se)), Ll = (R, V) => V !== null && !R.dom.isEditable(V), gs = (R) => {
    const V = qs(R);
    return Ll(R, V);
  }, xi = (R, V) => {
    const se = R.dom.getParent(V, "ol,ul,dl");
    return Ll(R, se);
  }, Dr = (R, V) => {
    const se = R.selection.getNode();
    return V({
      parents: R.dom.getParents(se),
      element: se
    }), R.on("NodeChange", V), () => R.off("NodeChange", V);
  }, Cc = (R, V) => {
    const De = document.createDocumentFragment();
    return Ce(R, (Le) => {
      De.appendChild(Le.dom);
    }), An.fromDom(De);
  }, Mr = (R, V, se) => R.dispatch("ListMutation", {
    action: V,
    element: se
  }), Tm = ((R) => (V) => V.replace(R, ""))(/^\s+|\s+$/g), zh = (R) => R.length > 0, $r = (R) => !zh(R), Ql = (R) => R.style !== void 0 && K(R.style.getPropertyValue), $a = (R, V, se) => {
    if (!x(se))
      throw console.error("Invalid call to CSS.set. Property ", V, ":: Value ", se, ":: Element ", R), new Error("CSS value must be a string: " + se);
    Ql(R) && R.style.setProperty(V, se);
  }, Ga = (R, V, se) => {
    const De = R.dom;
    $a(De, V, se);
  }, wi = (R) => vt(R, "OL,UL"), If = (R) => vt(R, "LI"), fs = (R) => xa(R).exists(wi), Ri = (R) => la(R).exists(wi), ci = (R) => "listAttributes" in R, me = (R) => "isComment" in R, Te = (R) => "isFragment" in R, nt = (R) => R.depth > 0, ft = (R) => R.isSelected, eo = (R) => {
    const V = na(R), se = Ri(R) ? V.slice(0, -1) : V;
    return Ue(se, Ti);
  }, es = (R, V, se) => Lr(R).filter(Ss).map((De) => ({
    depth: V,
    dirty: !1,
    isSelected: se,
    content: eo(R),
    itemAttributes: Gs(R),
    listAttributes: Gs(De),
    listType: it(De),
    isInPreviousLi: !1
  })), Sr = (R, V) => {
    lo(R.item, V.list);
  }, Ha = (R) => {
    for (let V = 1; V < R.length; V++)
      Sr(R[V - 1], R[V]);
  }, is = (R, V) => {
    xt(Ro(R), pn(V), Sr);
  }, _a = (R, V) => {
    const se = {
      list: An.fromTag(V, R),
      item: An.fromTag("li", R)
    };
    return lo(se.list, se.item), se;
  }, Rr = (R, V, se) => {
    const De = [];
    for (let Le = 0; Le < se; Le++)
      De.push(_a(R, ci(V) ? V.listType : V.parentListType));
    return De;
  }, ua = (R, V) => {
    for (let se = 0; se < R.length - 1; se++)
      Ga(R[se].item, "list-style-type", "none");
    Ro(R).each((se) => {
      ci(V) && (Jo(se.list, V.listAttributes), Jo(se.item, V.itemAttributes)), Xs(se.item, V.content);
    });
  }, oa = (R, V) => {
    it(R.list) !== V.listType && (R.list = ko(R.list, V.listType)), Jo(R.list, V.listAttributes);
  }, Jr = (R, V, se) => {
    const De = An.fromTag("li", R);
    return Jo(De, V), Xs(De, se), De;
  }, ul = (R, V) => {
    lo(R.list, V), R.item = V;
  }, Sc = (R, V, se) => {
    const De = V.slice(0, se.depth);
    return Ro(De).each((Le) => {
      if (ci(se)) {
        const $t = Jr(R, se.itemAttributes, se.content);
        ul(Le, $t), oa(Le, se);
      } else if (Te(se))
        Xs(Le.item, se.content);
      else {
        const $t = An.fromHtml(`<!--${se.content}-->`);
        lo(Le.list, $t);
      }
    }), De;
  }, qa = (R, V, se) => {
    const De = Rr(R, se, se.depth - V.length);
    return Ha(De), ua(De, se), is(V, De), V.concat(De);
  }, dl = (R, V) => {
    let se = ve.none();
    const De = ot(V, (Le, $t, vo) => me($t) ? vo === 0 ? (se = ve.some($t), Le) : Sc(R, Le, $t) : $t.depth > Le.length ? qa(R, Le, $t) : Sc(R, Le, $t), []);
    return se.each((Le) => {
      const $t = An.fromHtml(`<!--${Le.content}-->`);
      pn(De).each((vo) => {
        Kn(vo.list, $t);
      });
    }), pn(De).map((Le) => Le.list);
  }, Bc = (R, V) => {
    switch (R) {
      case "Indent":
        V.depth++;
        break;
      case "Outdent":
        V.depth--;
        break;
      case "Flatten":
        V.depth = 0;
    }
    V.dirty = !0;
  }, Lc = (R, V) => {
    ci(R) && ci(V) && (R.listType = V.listType, R.listAttributes = { ...V.listAttributes });
  }, xp = (R) => {
    R.listAttributes = Qn(R.listAttributes, (V, se) => se !== "start");
  }, hd = (R, V) => {
    const se = R[V].depth, De = ($t) => $t.depth === se && !$t.dirty, Le = ($t) => $t.depth < se;
    return B(Tt(R.slice(0, V)), De, Le).orThunk(() => B(R.slice(V + 1), De, Le));
  }, kc = (R) => (Ce(R, (V, se) => {
    hd(R, se).fold(() => {
      V.dirty && ci(V) && xp(V);
    }, (De) => Lc(V, De));
  }), R), Zi = (R) => {
    let V = R;
    return {
      get: () => V,
      set: (Le) => {
        V = Le;
      }
    };
  }, gd = (R, V, se, De) => {
    var Le;
    if (hn(De))
      return [{
        depth: R + 1,
        content: (Le = De.dom.nodeValue) !== null && Le !== void 0 ? Le : "",
        dirty: !1,
        isSelected: !1,
        isComment: !0
      }];
    V.each((Lo) => {
      on(Lo.start, De) && se.set(!0);
    });
    const $t = es(De, R, se.get());
    V.each((Lo) => {
      on(Lo.end, De) && se.set(!1);
    });
    const vo = la(De).filter(wi).map((Lo) => fu(R, V, se, Lo)).getOr([]);
    return $t.toArray().concat(vo);
  }, Ff = (R, V, se, De) => xa(De).filter(wi).fold(() => gd(R, V, se, De), (Le) => {
    const $t = ot(na(De), (vo, Lo, Mo) => {
      if (Mo === 0)
        return vo;
      if (If(Lo))
        return vo.concat(gd(R, V, se, Lo));
      {
        const go = {
          isFragment: !0,
          depth: R,
          content: [Lo],
          isSelected: !1,
          dirty: !1,
          parentListType: it(Le)
        };
        return vo.concat(go);
      }
    }, []);
    return fu(R, V, se, Le).concat($t);
  }), fu = (R, V, se, De) => jt(na(De), (Le) => {
    const $t = wi(Le) ? fu : Ff, vo = R + 1;
    return $t(vo, V, se, Le);
  }), Vh = (R, V) => {
    const se = Zi(!1), De = 0;
    return Ue(R, (Le) => ({
      sourceList: Le,
      entries: fu(De, V, se, Le)
    }));
  }, Bf = (R, V) => {
    const se = kc(V);
    return Ue(se, (De) => {
      const Le = me(De) ? Cc([An.fromHtml(`<!--${De.content}-->`)]) : Cc(De.content), $t = ci(De) ? De.itemAttributes : {};
      return An.fromDom(du(R, Le.dom, $t));
    });
  }, Uh = (R, V) => {
    const se = kc(V);
    return dl(R.contentDocument, se).toArray();
  }, Yd = (R, V) => jt(_t(V, nt), (se) => pn(se).exists(nt) ? Uh(R, se) : Bf(R, se)), jh = (R, V) => {
    Ce(Rn(R, ft), (se) => Bc(V, se));
  }, Xd = (R) => {
    const V = Ue(Y(R), An.fromDom);
    return xt(fn(V, oe(fs)), fn(Tt(V), oe(fs)), (se, De) => ({
      start: se,
      end: De
    }));
  }, Hb = (R, V, se) => {
    const De = Vh(V, Xd(R));
    Ce(De, (Le) => {
      jh(Le.entries, se);
      const $t = Yd(R, Le.entries);
      Ce($t, (vo) => {
        Mr(R, se === "Indent" ? "IndentList" : "OutdentList", vo.dom);
      }), Bo(Le.sourceList, $t), Oo(Le.sourceList);
    });
  }, Me = (R, V) => {
    const se = Zt(lr(R)), De = Zt(ge(R));
    let Le = !1;
    if (se.length || De.length) {
      const $t = R.selection.getBookmark();
      Hb(R, se, V), Xt(R, V, De), R.selection.moveToBookmark($t), R.selection.setRng(ss(R.selection.getRng())), R.nodeChanged(), Le = !0;
    }
    return Le;
  }, Am = (R, V) => !gs(R) && Me(R, V), wl = (R) => Am(R, "Indent"), Bu = (R) => Am(R, "Outdent"), Wh = (R) => Am(R, "Flatten"), cv = "\uFEFF", Bs = (R) => R === cv, Gi = (R, V, se) => Ao(R, V, se).isSome(), $l = (R, V) => Gi(R, re(on, V));
  var Ka = tinymce.util.Tools.resolve("tinymce.dom.BookmarkManager");
  const Qd = Zo.DOM, $c = (R) => {
    const V = {}, se = (De) => {
      let Le = R[De ? "startContainer" : "endContainer"], $t = R[De ? "startOffset" : "endOffset"];
      if (Qs(Le)) {
        const vo = Qd.create("span", { "data-mce-type": "bookmark" });
        Le.hasChildNodes() ? ($t = Math.min($t, Le.childNodes.length - 1), De ? Le.insertBefore(vo, Le.childNodes[$t]) : Qd.insertAfter(vo, Le.childNodes[$t])) : Le.appendChild(vo), Le = vo, $t = 0;
      }
      V[De ? "startContainer" : "endContainer"] = Le, V[De ? "startOffset" : "endOffset"] = $t;
    };
    return se(!0), R.collapsed || se(), V;
  }, Ni = (R) => {
    const V = (De) => {
      const Le = (Lo) => {
        var Mo;
        let go = (Mo = Lo.parentNode) === null || Mo === void 0 ? void 0 : Mo.firstChild, Hr = 0;
        for (; go; ) {
          if (go === Lo)
            return Hr;
          (!Qs(go) || go.getAttribute("data-mce-type") !== "bookmark") && Hr++, go = go.nextSibling;
        }
        return -1;
      };
      let $t = R[De ? "startContainer" : "endContainer"], vo = R[De ? "startOffset" : "endOffset"];
      if ($t) {
        if (Qs($t) && $t.parentNode) {
          const Lo = $t;
          vo = Le($t), $t = $t.parentNode, Qd.remove(Lo), !$t.hasChildNodes() && Qd.isBlock($t) && $t.appendChild(Qd.create("br"));
        }
        R[De ? "startContainer" : "endContainer"] = $t, R[De ? "startOffset" : "endOffset"] = vo;
      }
    };
    V(!0), V();
    const se = Qd.createRng();
    return se.setStart(R.startContainer, R.startOffset), R.endContainer && se.setEnd(R.endContainer, R.endOffset), ss(se);
  }, Hc = (R) => {
    switch (R) {
      case "UL":
        return "ToggleUlList";
      case "OL":
        return "ToggleOlList";
      case "DL":
        return "ToggleDLList";
    }
  }, Zh = (R, V, se) => {
    const De = se["list-style-type"] ? se["list-style-type"] : null;
    R.setStyle(V, "list-style-type", De);
  }, uv = (R, V) => {
    Rs.each(V, (se, De) => {
      R.setAttribute(De, se);
    });
  }, Jl = (R, V, se) => {
    uv(V, se["list-attributes"]), Rs.each(R.select("li", V), (De) => {
      uv(De, se["list-item-attributes"]);
    });
  }, zc = (R, V, se) => {
    Zh(R, V, se), Jl(R, V, se);
  }, wp = (R, V, se) => {
    Rs.each(se, (De) => R.setStyle(V, De, ""));
  }, qi = (R, V) => Z(V) && !Di(V, R.schema.getBlockElements()), Ya = (R, V, se, De) => {
    let Le = V[se ? "startContainer" : "endContainer"];
    const $t = V[se ? "startOffset" : "endOffset"];
    Qs(Le) && (Le = Le.childNodes[Math.min($t, Le.childNodes.length - 1)] || Le), !se && Oi(Le.nextSibling) && (Le = Le.nextSibling);
    const vo = (Mo) => {
      for (; !R.dom.isBlock(Mo) && Mo.parentNode && De !== Mo; )
        Mo = Mo.parentNode;
      return Mo;
    }, Lo = (Mo, go) => {
      var Hr;
      const fa = new Ie(Mo, vo(Mo)), _l = go ? "next" : "prev";
      let va;
      for (; va = fa[_l](); )
        if (!(ji(R, va) || Bs(va.textContent) || ((Hr = va.textContent) === null || Hr === void 0 ? void 0 : Hr.length) === 0))
          return ve.some(va);
      return ve.none();
    };
    if (se && gr(Le))
      if (Bs(Le.textContent))
        Le = Lo(Le, !1).getOr(Le);
      else
        for (Le.parentNode !== null && qi(R, Le.parentNode) && (Le = Le.parentNode); Le.previousSibling !== null && (qi(R, Le.previousSibling) || gr(Le.previousSibling)); )
          Le = Le.previousSibling;
    if (!se && gr(Le))
      if (Bs(Le.textContent))
        Le = Lo(Le, !0).getOr(Le);
      else
        for (Le.parentNode !== null && qi(R, Le.parentNode) && (Le = Le.parentNode); Le.nextSibling !== null && (qi(R, Le.nextSibling) || gr(Le.nextSibling)); )
          Le = Le.nextSibling;
    for (; Le.parentNode !== De; ) {
      const Mo = Le.parentNode;
      if (Za(R, Le) || /^(TD|TH)$/.test(Mo.nodeName))
        return Le;
      Le = Mo;
    }
    return Le;
  }, vd = (R, V, se) => {
    const De = [], Le = R.dom, $t = Ya(R, V, !0, se), vo = Ya(R, V, !1, se);
    let Lo;
    const Mo = [];
    for (let go = $t; go && (Mo.push(go), go !== vo); go = go.nextSibling)
      ;
    return Rs.each(Mo, (go) => {
      var Hr;
      if (Za(R, go)) {
        De.push(go), Lo = null;
        return;
      }
      if (Le.isBlock(go) || Oi(go)) {
        Oi(go) && Le.remove(go), Lo = null;
        return;
      }
      const fa = go.nextSibling;
      if (Ka.isBookmarkNode(go) && (ii(fa) || Za(R, fa) || !fa && go.parentNode === se)) {
        Lo = null;
        return;
      }
      Lo || (Lo = Le.create("p"), (Hr = go.parentNode) === null || Hr === void 0 || Hr.insertBefore(Lo, go), De.push(Lo)), Lo.appendChild(go);
    }), De;
  }, Lf = (R, V, se) => {
    const De = R.getStyle(V, "list-style-type");
    let Le = se ? se["list-style-type"] : "";
    return Le = Le === null ? "" : Le, De === Le;
  }, _c = (R, V) => {
    const se = R.selection.getStart(!0), De = Ya(R, V, !0, R.getBody());
    return $l(An.fromDom(De), An.fromDom(V.commonAncestorContainer)) ? V.commonAncestorContainer : se;
  }, Ci = (R, V, se) => {
    const De = R.selection.getRng();
    let Le = "LI";
    const $t = wn(R, _c(R, De)), vo = R.dom;
    if (vo.getContentEditable(R.selection.getNode()) === "false")
      return;
    V = V.toUpperCase(), V === "DL" && (Le = "DT");
    const Lo = $c(De), Mo = Rn(vd(R, De, $t), R.dom.isEditable);
    Rs.each(Mo, (go) => {
      let Hr;
      const fa = go.previousSibling, _l = go.parentNode;
      ka(_l) || (fa && ii(fa) && fa.nodeName === V && Lf(vo, fa, se) ? (Hr = fa, go = vo.rename(go, Le), fa.appendChild(go)) : (Hr = vo.create(V), _l.insertBefore(Hr, go), Hr.appendChild(go), go = vo.rename(go, Le)), wp(vo, go, [
        "margin",
        "margin-right",
        "margin-bottom",
        "margin-left",
        "margin-top",
        "padding",
        "padding-right",
        "padding-bottom",
        "padding-left",
        "padding-top"
      ]), zc(vo, Hr, se), ec(R.dom, Hr));
    }), R.selection.setRng(Ni(Lo));
  }, Cp = (R, V) => ii(R) && R.nodeName === (V == null ? void 0 : V.nodeName), Sp = (R, V, se) => {
    const De = R.getStyle(V, "list-style-type", !0), Le = R.getStyle(se, "list-style-type", !0);
    return De === Le;
  }, kp = (R, V) => R.className === V.className, Om = (R, V, se) => Cp(V, se) && Sp(R, V, se) && kp(V, se), ec = (R, V) => {
    let se, De = V.nextSibling;
    if (Om(R, V, De)) {
      const Le = De;
      for (; se = Le.firstChild; )
        V.appendChild(se);
      R.remove(Le);
    }
    if (De = V.previousSibling, Om(R, V, De)) {
      const Le = De;
      for (; se = Le.lastChild; )
        V.insertBefore(se, V.firstChild);
      R.remove(Le);
    }
  }, _p = (R, V, se, De) => {
    if (V.nodeName !== se) {
      const Le = R.dom.rename(V, se);
      zc(R.dom, Le, De), Mr(R, Hc(se), Le);
    } else
      zc(R.dom, V, De), Mr(R, Hc(se), V);
  }, dv = (R, V, se, De) => {
    if (V.classList.forEach((Le, $t, vo) => {
      Le.startsWith("tox-") && (vo.remove(Le), vo.length === 0 && V.removeAttribute("class"));
    }), V.nodeName !== se) {
      const Le = R.dom.rename(V, se);
      zc(R.dom, Le, De), Mr(R, Hc(se), Le);
    } else
      zc(R.dom, V, De), Mr(R, Hc(se), V);
  }, zb = (R, V, se, De, Le) => {
    const $t = ii(V);
    if ($t && V.nodeName === De && !fv(Le) && !Cr(V))
      Wh(R);
    else {
      Ci(R, De, Le);
      const vo = $c(R.selection.getRng()), Lo = $t ? [
        V,
        ...se
      ] : se, Mo = $t && Cr(V) ? dv : _p;
      Rs.each(Lo, (go) => {
        Mo(R, go, De, Le);
      }), R.selection.setRng(Ni(vo));
    }
  }, fv = (R) => "list-style-type" in R, Ep = (R, V, se, De) => {
    if (V !== R.getBody())
      if (V)
        if (V.nodeName === se && !fv(De) && !Cr(V))
          Wh(R);
        else {
          const Le = $c(R.selection.getRng());
          Cr(V) && V.classList.forEach((vo, Lo, Mo) => {
            vo.startsWith("tox-") && (Mo.remove(vo), Mo.length === 0 && V.removeAttribute("class"));
          }), zc(R.dom, V, De);
          const $t = R.dom.rename(V, se);
          ec(R.dom, $t), R.selection.setRng(Ni(Le)), Ci(R, se, De), Mr(R, Hc(se), $t);
        }
      else
        Ci(R, se, De), Mr(R, Hc(se), V);
  }, Dm = (R, V, se) => {
    const De = qs(R);
    if (xi(R, De))
      return;
    const Le = md(R), $t = k(se) ? se : {};
    Le.length > 0 ? zb(R, De, Le, V, $t) : Ep(R, De, V, $t);
  }, Lu = Zo.DOM, Gh = (R, V) => {
    const se = V.parentElement;
    if (se && se.nodeName === "LI" && se.firstChild === V) {
      const De = se.previousSibling;
      De && De.nodeName === "LI" ? (De.appendChild(V), vi(R, se) && Lu.remove(se)) : Lu.setStyle(se, "listStyleType", "none");
    }
    if (ii(se)) {
      const De = se.previousSibling;
      De && De.nodeName === "LI" && De.appendChild(V);
    }
  }, Nr = (R, V) => {
    const se = Rs.grep(R.select("ol,ul", V));
    Rs.each(se, (De) => {
      Gh(R, De);
    });
  }, sa = (R, V, se, De) => {
    let Le = V.startContainer;
    const $t = V.startOffset;
    if (gr(Le) && (se ? $t < Le.data.length : $t > 0))
      return Le;
    const vo = R.schema.getNonEmptyElements();
    Qs(Le) && (Le = Pe.getNode(Le, $t));
    const Lo = new Ie(Le, De);
    se && uu(R.dom, Le) && Lo.next();
    const Mo = se ? Lo.next.bind(Lo) : Lo.prev2.bind(Lo);
    for (; Le = Mo(); )
      if (Le.nodeName === "LI" && !Le.hasChildNodes() || vo[Le.nodeName] || gr(Le) && Le.data.length > 0)
        return Le;
    return null;
  }, Cl = (R, V) => {
    const se = V.childNodes;
    return se.length === 1 && !ii(se[0]) && R.isBlock(se[0]);
  }, qh = (R) => ve.from(R).map(An.fromDom).filter(Do).exists((V) => Ne(V) && !wt(["details"], it(V))), Kh = (R, V) => {
    Cl(R, V) && qh(V.firstChild) && R.remove(V.firstChild, !0);
  }, Na = (R, V, se) => {
    let De;
    const Le = Cl(R, se) ? se.firstChild : se;
    if (Kh(R, V), !vi(R, V, !0))
      for (; De = V.firstChild; )
        Le.appendChild(De);
  }, to = (R, V, se) => {
    let De;
    const Le = V.parentNode;
    if (!Bl(R, V) || !Bl(R, se))
      return;
    ii(se.lastChild) && (De = se.lastChild), Le === se.lastChild && Oi(Le.previousSibling) && R.remove(Le.previousSibling);
    const $t = se.lastChild;
    $t && Oi($t) && V.hasChildNodes() && R.remove($t), vi(R, se, !0) && $e(An.fromDom(se)), Na(R, V, se), De && se.appendChild(De);
    const Lo = zt(An.fromDom(se), An.fromDom(V)) ? R.getParents(V, ii, se) : [];
    R.remove(V), Ce(Lo, (Mo) => {
      vi(R, Mo) && Mo !== R.getRoot() && R.remove(Mo);
    });
  }, mu = (R, V, se) => {
    $e(An.fromDom(se)), to(R.dom, V, se), R.selection.setCursorLocation(se, 0);
  }, mv = (R, V, se, De) => {
    const Le = R.dom;
    if (Le.isEmpty(De))
      mu(R, se, De);
    else {
      const $t = $c(V);
      to(Le, se, De), R.selection.setRng(Ni($t));
    }
  }, za = (R, V, se, De) => {
    const Le = $c(V);
    to(R.dom, se, De);
    const $t = Ni(Le);
    R.selection.setRng($t);
  }, cr = (R, V) => {
    const se = R.dom, De = R.selection, Le = De.getStart(), $t = Ee(R, Le), vo = se.getParent(De.getStart(), "LI", $t);
    if (vo) {
      const Lo = vo.parentElement;
      if (Lo === R.getBody() && vi(se, Lo))
        return !0;
      const Mo = ss(De.getRng()), go = se.getParent(sa(R, Mo, V, $t), "LI", $t), Hr = go && (V ? se.isChildOf(vo, go) : se.isChildOf(go, vo));
      if (go && go !== vo && !Hr)
        return R.undoManager.transact(() => {
          V ? mv(R, Mo, go, vo) : cl(vo) ? Bu(R) : za(R, Mo, vo, go);
        }), !0;
      if (Hr && !V && go !== vo)
        return R.undoManager.transact(() => {
          if (Mo.commonAncestorContainer.parentElement) {
            const fa = $c(Mo), _l = Mo.commonAncestorContainer.parentElement;
            Na(se, Mo.commonAncestorContainer.parentElement, go), _l.remove();
            const va = Ni(fa);
            R.selection.setRng(va);
          }
        }), !0;
      if (!go && !V && Mo.startOffset === 0 && Mo.endOffset === 0)
        return R.undoManager.transact(() => {
          Wh(R);
        }), !0;
    }
    return !1;
  }, Jd = (R, V, se) => {
    const De = R.getParent(V.parentNode, R.isBlock, se);
    R.remove(V), De && R.isEmpty(De) && R.remove(De);
  }, Yh = (R, V) => {
    const se = R.dom, De = R.selection.getStart(), Le = Ee(R, De), $t = se.getParent(De, se.isBlock, Le);
    if ($t && se.isEmpty($t, void 0, { checkRootAsContent: !0 })) {
      const vo = ss(R.selection.getRng()), Lo = se.getParent(sa(R, vo, V, Le), "LI", Le);
      if (Lo) {
        const Mo = (_l) => wt([
          "td",
          "th",
          "caption"
        ], it(_l)), go = (_l) => _l.dom === Le, Hr = as(An.fromDom(Lo), Mo, go), fa = as(An.fromDom(vo.startContainer), Mo, go);
        return et(Hr, fa, on) ? (R.undoManager.transact(() => {
          const _l = Lo.parentNode;
          Jd(se, $t, Le), ec(se, _l), R.selection.select(Lo, !0), R.selection.collapse(V);
        }), !0) : !1;
      }
    }
    return !1;
  }, Tp = (R, V) => cr(R, V) || Yh(R, V), Ap = (R) => {
    const V = R.selection.getStart(), se = Ee(R, V);
    return R.dom.getParent(V, "LI,DT,DD", se) || Y(R).length > 0;
  }, Ho = (R) => Ap(R) ? (R.undoManager.transact(() => {
    R.execCommand("Delete"), Nr(R.dom, R.getBody());
  }), !0) : !1, da = (R, V) => {
    const se = R.selection;
    return !xi(R, se.getNode()) && (se.isCollapsed() ? Tp(R, V) : Ho(R));
  }, $f = (R) => {
    R.on("ExecCommand", (V) => {
      const se = V.command.toLowerCase();
      (se === "delete" || se === "forwarddelete") && Ap(R) && Nr(R.dom, R.getBody());
    }), R.on("keydown", (V) => {
      V.keyCode === Lt.BACKSPACE ? da(R, !1) && V.preventDefault() : V.keyCode === Lt.DELETE && da(R, !0) && V.preventDefault();
    });
  }, Sl = (R) => ({
    backspaceDelete: (V) => {
      da(R, V);
    }
  }), fl = (R, V) => {
    const se = qs(R);
    se === null || xi(R, se) || R.undoManager.transact(() => {
      k(V.styles) && R.dom.setStyles(se, V.styles), k(V.attrs) && Jn(V.attrs, (De, Le) => R.dom.setAttrib(se, Le, De));
    });
  }, kl = (R) => {
    const V = Tt(Tm(R).split("")), se = Ue(V, (De, Le) => {
      const $t = De.toUpperCase().charCodeAt(0) - 65 + 1;
      return Math.pow(26, Le) * $t;
    });
    return ot(se, (De, Le) => De + Le, 0);
  }, Pa = (R) => {
    if (R--, R < 0)
      return "";
    {
      const V = R % 26, se = Math.floor(R / 26), De = Pa(se), Le = String.fromCharCode(65 + V);
      return De + Le;
    }
  }, Ki = (R) => /^[A-Z]+$/.test(R), tc = (R) => /^[a-z]+$/.test(R), Rm = (R) => /^[0-9]+$/.test(R), Zr = (R) => Rm(R) ? 2 : Ki(R) ? 0 : tc(R) ? 1 : $r(R) ? 3 : 4, Xh = (R) => {
    switch (Zr(R)) {
      case 2:
        return ve.some({
          listStyleType: ve.none(),
          start: R
        });
      case 0:
        return ve.some({
          listStyleType: ve.some("upper-alpha"),
          start: kl(R).toString()
        });
      case 1:
        return ve.some({
          listStyleType: ve.some("lower-alpha"),
          start: kl(R).toString()
        });
      case 3:
        return ve.some({
          listStyleType: ve.none(),
          start: ""
        });
      case 4:
        return ve.none();
    }
  }, wa = (R) => {
    const V = parseInt(R.start, 10);
    return Cn(R.listStyleType, "upper-alpha") ? Pa(V) : Cn(R.listStyleType, "lower-alpha") ? Pa(V).toLowerCase() : R.start;
  }, bd = (R) => {
    const V = qs(R);
    !Is(V) || xi(R, V) || R.windowManager.open({
      title: "List Properties",
      body: {
        type: "panel",
        items: [{
          type: "input",
          name: "start",
          label: "Start list at number",
          inputMode: "numeric"
        }]
      },
      initialData: {
        start: wa({
          start: R.dom.getAttrib(V, "start", "1"),
          listStyleType: ve.from(R.dom.getStyle(V, "list-style-type"))
        })
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      onSubmit: (se) => {
        const De = se.getData();
        Xh(De.start).each((Le) => {
          R.execCommand("mceListUpdate", !1, {
            attrs: { start: Le.start === "1" ? "" : Le.start },
            styles: { "list-style-type": Le.listStyleType.getOr("") }
          });
        }), se.close();
      }
    });
  }, Vc = (R, V) => () => {
    const se = qs(R);
    return Z(se) && se.nodeName === V;
  }, vr = (R) => {
    R.addCommand("mceListProps", () => {
      bd(R);
    });
  }, Uc = (R) => {
    R.on("BeforeExecCommand", (V) => {
      const se = V.command.toLowerCase();
      se === "indent" ? wl(R) : se === "outdent" && Bu(R);
    }), R.addCommand("InsertUnorderedList", (V, se) => {
      Dm(R, "UL", se);
    }), R.addCommand("InsertOrderedList", (V, se) => {
      Dm(R, "OL", se);
    }), R.addCommand("InsertDefinitionList", (V, se) => {
      Dm(R, "DL", se);
    }), R.addCommand("RemoveList", () => {
      Wh(R);
    }), vr(R), R.addCommand("mceListUpdate", (V, se) => {
      k(se) && fl(R, se);
    }), R.addQueryStateHandler("InsertUnorderedList", Vc(R, "UL")), R.addQueryStateHandler("InsertOrderedList", Vc(R, "OL")), R.addQueryStateHandler("InsertDefinitionList", Vc(R, "DL"));
  };
  var Hf = tinymce.util.Tools.resolve("tinymce.html.Node");
  const $u = (R) => R.type === 3, Pr = (R) => R.length === 0, yd = (R) => {
    const V = (Le, $t) => {
      const vo = Hf.create("li");
      Ce(Le, (Lo) => vo.append(Lo)), $t ? R.insert(vo, $t, !0) : R.append(vo);
    }, se = (Le, $t) => $u($t) ? [
      ...Le,
      $t
    ] : !Pr(Le) && !$u($t) ? (V(Le, $t), []) : Le, De = ot(R.children(), se, []);
    Pr(De) || V(De);
  }, nc = (R) => {
    R.on("PreInit", () => {
      const { parser: V } = R;
      V.addNodeFilter("ul,ol", (se) => Ce(se, yd));
    });
  }, ls = (R) => {
    R.on("keydown", (V) => {
      V.keyCode !== Lt.TAB || Lt.metaKeyPressed(V) || R.undoManager.transact(() => {
        (V.shiftKey ? Bu(R) : wl(R)) && V.preventDefault();
      });
    });
  }, ef = (R) => {
    Xl(R) && ls(R), $f(R);
  }, Nm = (R, V) => (se) => {
    const De = (Le) => {
      se.setActive(ga(Le.parents, V)), se.setEnabled(!xi(R, Le.element) && R.selection.isEditable());
    };
    return se.setEnabled(R.selection.isEditable()), Dr(R, De);
  }, Op = (R) => {
    const V = (se) => () => R.execCommand(se);
    R.hasPlugin("advlist") || (R.ui.registry.addToggleButton("numlist", {
      icon: "ordered-list",
      active: !1,
      tooltip: "Numbered list",
      onAction: V("InsertOrderedList"),
      onSetup: Nm(R, "OL")
    }), R.ui.registry.addToggleButton("bullist", {
      icon: "unordered-list",
      active: !1,
      tooltip: "Bullet list",
      onAction: V("InsertUnorderedList"),
      onSetup: Nm(R, "UL")
    }));
  }, pv = (R, V) => (se) => Dr(R, (Le) => se.setEnabled(ga(Le.parents, V) && !xi(R, Le.element))), Dp = (R) => {
    const V = {
      text: "List properties...",
      icon: "ordered-list",
      onAction: () => R.execCommand("mceListProps"),
      onSetup: pv(R, "OL")
    };
    R.ui.registry.addMenuItem("listprops", V), R.ui.registry.addContextMenu("lists", {
      update: (se) => {
        const De = qs(R, se);
        return Is(De) ? ["listprops"] : [];
      }
    });
  };
  var hv = () => {
    o.add("lists", (R) => (Wi(R), nc(R), R.hasPlugin("rtc", !0) ? vr(R) : (ef(R), Uc(R)), Op(R), Dp(R), Sl(R)));
  };
  hv();
})();
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const a = (Ne, Ae, ct) => {
    var Ct;
    return ct(Ne, Ae.prototype) ? !0 : ((Ct = Ne.constructor) === null || Ct === void 0 ? void 0 : Ct.name) === Ae.name;
  }, c = (Ne) => {
    const Ae = typeof Ne;
    return Ne === null ? "null" : Ae === "object" && Array.isArray(Ne) ? "array" : Ae === "object" && a(Ne, String, (ct, Ct) => Ct.isPrototypeOf(ct)) ? "string" : Ae;
  }, f = (Ne) => (Ae) => c(Ae) === Ne, g = f("string"), x = f("object"), k = f("array"), A = (Ne) => Ne == null, N = (Ne) => !A(Ne);
  class H {
    constructor(Ae, ct) {
      this.tag = Ae, this.value = ct;
    }
    static some(Ae) {
      return new H(!0, Ae);
    }
    static none() {
      return H.singletonNone;
    }
    fold(Ae, ct) {
      return this.tag ? ct(this.value) : Ae();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(Ae) {
      return this.tag ? H.some(Ae(this.value)) : H.none();
    }
    bind(Ae) {
      return this.tag ? Ae(this.value) : H.none();
    }
    exists(Ae) {
      return this.tag && Ae(this.value);
    }
    forall(Ae) {
      return !this.tag || Ae(this.value);
    }
    filter(Ae) {
      return !this.tag || Ae(this.value) ? this : H.none();
    }
    getOr(Ae) {
      return this.tag ? this.value : Ae;
    }
    or(Ae) {
      return this.tag ? this : Ae;
    }
    getOrThunk(Ae) {
      return this.tag ? this.value : Ae();
    }
    orThunk(Ae) {
      return this.tag ? this : Ae();
    }
    getOrDie(Ae) {
      if (this.tag)
        return this.value;
      throw new Error(Ae ?? "Called getOrDie on None");
    }
    static from(Ae) {
      return N(Ae) ? H.some(Ae) : H.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(Ae) {
      this.tag && Ae(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  H.singletonNone = new H(!1);
  const Z = Array.prototype.push, K = (Ne, Ae) => {
    for (let ct = 0, Ct = Ne.length; ct < Ct; ct++) {
      const Kn = Ne[ct];
      Ae(Kn, ct);
    }
  }, J = (Ne) => {
    const Ae = [];
    for (let ct = 0, Ct = Ne.length; ct < Ct; ++ct) {
      if (!k(Ne[ct]))
        throw new Error("Arr.flatten item " + ct + " was not an array, input: " + Ne);
      Z.apply(Ae, Ne[ct]);
    }
    return Ae;
  }, pe = (Ne) => {
    let Ae = Ne;
    return {
      get: () => Ae,
      set: (Kn) => {
        Ae = Kn;
      }
    };
  }, Se = Object.keys, be = Object.hasOwnProperty, ye = (Ne, Ae) => {
    const ct = Se(Ne);
    for (let Ct = 0, Kn = ct.length; Ct < Kn; Ct++) {
      const lo = ct[Ct], Bo = Ne[lo];
      Ae(Bo, lo);
    }
  }, re = (Ne, Ae) => oe(Ne, Ae) ? H.from(Ne[Ae]) : H.none(), oe = (Ne, Ae) => be.call(Ne, Ae), U = (Ne) => (Ae) => Ae.options.get(Ne), ve = (Ne) => {
    const Ae = Ne.options.register;
    Ae("audio_template_callback", { processor: "function" }), Ae("video_template_callback", { processor: "function" }), Ae("iframe_template_callback", { processor: "function" }), Ae("media_live_embeds", {
      processor: "boolean",
      default: !0
    }), Ae("media_filter_html", {
      processor: "boolean",
      default: !0
    }), Ae("media_url_resolver", { processor: "function" }), Ae("media_alt_source", {
      processor: "boolean",
      default: !0
    }), Ae("media_poster", {
      processor: "boolean",
      default: !0
    }), Ae("media_dimensions", {
      processor: "boolean",
      default: !0
    });
  }, Ze = U("audio_template_callback"), rt = U("video_template_callback"), ee = U("iframe_template_callback"), lt = U("media_live_embeds"), wt = U("media_filter_html"), Vt = U("media_url_resolver"), Ue = U("media_alt_source"), Ce = U("media_poster"), Rn = U("media_dimensions");
  var _t = tinymce.util.Tools.resolve("tinymce.util.Tools"), ot = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), B = tinymce.util.Tools.resolve("tinymce.html.DomParser");
  const fn = ot.DOM, ze = (Ne) => Ne.replace(/px$/, ""), jt = (Ne) => {
    const Ae = Ne.attr("style"), ct = Ae ? fn.parseStyle(Ae) : {};
    return {
      type: "ephox-embed-iri",
      source: Ne.attr("data-ephox-embed-iri"),
      altsource: "",
      poster: "",
      width: re(ct, "max-width").map(ze).getOr(""),
      height: re(ct, "max-height").map(ze).getOr("")
    };
  }, Tt = (Ne, Ae) => {
    let ct = {};
    const Kn = B({
      validate: !1,
      forced_root_block: !1
    }, Ae).parse(Ne);
    for (let lo = Kn; lo; lo = lo.walk())
      if (lo.type === 1) {
        const Bo = lo.name;
        if (lo.attr("data-ephox-embed-iri")) {
          ct = jt(lo);
          break;
        } else
          !ct.source && Bo === "param" && (ct.source = lo.attr("movie")), (Bo === "iframe" || Bo === "object" || Bo === "embed" || Bo === "video" || Bo === "audio") && (ct.type || (ct.type = Bo), ct = _t.extend(lo.attributes.map, ct)), Bo === "source" && (ct.source ? ct.altsource || (ct.altsource = lo.attr("src")) : ct.source = lo.attr("src")), Bo === "img" && !ct.poster && (ct.poster = lo.attr("src"));
      }
    return ct.source = ct.source || ct.src || "", ct.altsource = ct.altsource || "", ct.poster = ct.poster || "", ct;
  }, Je = (Ne) => {
    var Ae;
    const ct = {
      mp3: "audio/mpeg",
      m4a: "audio/x-m4a",
      wav: "audio/wav",
      mp4: "video/mp4",
      webm: "video/webm",
      ogg: "video/ogg",
      swf: "application/x-shockwave-flash"
    }, Ct = (Ae = Ne.toLowerCase().split(".").pop()) !== null && Ae !== void 0 ? Ae : "";
    return re(ct, Ct).getOr("");
  };
  var pn = tinymce.util.Tools.resolve("tinymce.html.Node"), Ro = tinymce.util.Tools.resolve("tinymce.html.Serializer");
  const Rt = (Ne, Ae = {}) => B({
    forced_root_block: !1,
    validate: !1,
    allow_conditional_comments: !0,
    ...Ae
  }, Ne), Cn = ot.DOM, et = (Ne) => /^[0-9.]+$/.test(Ne) ? Ne + "px" : Ne, xt = (Ne, Ae) => {
    const ct = Ae.attr("style"), Ct = ct ? Cn.parseStyle(ct) : {};
    N(Ne.width) && (Ct["max-width"] = et(Ne.width)), N(Ne.height) && (Ct["max-height"] = et(Ne.height)), Ae.attr("style", Cn.serializeStyle(Ct));
  }, X = [
    "source",
    "altsource"
  ], ds = (Ne, Ae, ct, Ct) => {
    let Kn = 0, lo = 0;
    const Bo = Rt(Ct);
    Bo.addNodeFilter("source", ($e) => Kn = $e.length);
    const Xs = Bo.parse(Ne);
    for (let $e = Xs; $e; $e = $e.walk())
      if ($e.type === 1) {
        const Oo = $e.name;
        if ($e.attr("data-ephox-embed-iri")) {
          xt(Ae, $e);
          break;
        } else {
          switch (Oo) {
            case "video":
            case "object":
            case "embed":
            case "img":
            case "iframe":
              Ae.height !== void 0 && Ae.width !== void 0 && ($e.attr("width", Ae.width), $e.attr("height", Ae.height));
              break;
          }
          if (ct)
            switch (Oo) {
              case "video":
                $e.attr("poster", Ae.poster), $e.attr("src", null);
                for (let Ie = Kn; Ie < 2; Ie++)
                  if (Ae[X[Ie]]) {
                    const Lt = new pn("source", 1);
                    Lt.attr("src", Ae[X[Ie]]), Lt.attr("type", Ae[X[Ie] + "mime"] || null), $e.append(Lt);
                  }
                break;
              case "iframe":
                $e.attr("src", Ae.source);
                break;
              case "object":
                const Pe = $e.getAll("img").length > 0;
                if (Ae.poster && !Pe) {
                  $e.attr("src", Ae.poster);
                  const Ie = new pn("img", 1);
                  Ie.attr("src", Ae.poster), Ie.attr("width", Ae.width), Ie.attr("height", Ae.height), $e.append(Ie);
                }
                break;
              case "source":
                if (lo < 2 && ($e.attr("src", Ae[X[lo]]), $e.attr("type", Ae[X[lo] + "mime"] || null), !Ae[X[lo]])) {
                  $e.remove();
                  continue;
                }
                lo++;
                break;
              case "img":
                Ae.poster || $e.remove();
                break;
            }
        }
      }
    return Ro({}, Ct).serialize(Xs);
  }, So = [
    {
      regex: /youtu\.be\/([\w\-_\?&=.]+)/i,
      type: "iframe",
      w: 560,
      h: 314,
      url: "www.youtube.com/embed/$1",
      allowFullscreen: !0
    },
    {
      regex: /youtube\.com(.+)v=([^&]+)(&([a-z0-9&=\-_]+))?/i,
      type: "iframe",
      w: 560,
      h: 314,
      url: "www.youtube.com/embed/$2?$4",
      allowFullscreen: !0
    },
    {
      regex: /youtube.com\/embed\/([a-z0-9\?&=\-_]+)/i,
      type: "iframe",
      w: 560,
      h: 314,
      url: "www.youtube.com/embed/$1",
      allowFullscreen: !0
    },
    {
      regex: /vimeo\.com\/([0-9]+)\?h=(\w+)/,
      type: "iframe",
      w: 425,
      h: 350,
      url: "player.vimeo.com/video/$1?h=$2&title=0&byline=0&portrait=0&color=8dc7dc",
      allowFullscreen: !0
    },
    {
      regex: /vimeo\.com\/(.*)\/([0-9]+)\?h=(\w+)/,
      type: "iframe",
      w: 425,
      h: 350,
      url: "player.vimeo.com/video/$2?h=$3&title=0&amp;byline=0",
      allowFullscreen: !0
    },
    {
      regex: /vimeo\.com\/([0-9]+)/,
      type: "iframe",
      w: 425,
      h: 350,
      url: "player.vimeo.com/video/$1?title=0&byline=0&portrait=0&color=8dc7dc",
      allowFullscreen: !0
    },
    {
      regex: /vimeo\.com\/(.*)\/([0-9]+)/,
      type: "iframe",
      w: 425,
      h: 350,
      url: "player.vimeo.com/video/$2?title=0&amp;byline=0",
      allowFullscreen: !0
    },
    {
      regex: /maps\.google\.([a-z]{2,3})\/maps\/(.+)msid=(.+)/,
      type: "iframe",
      w: 425,
      h: 350,
      url: 'maps.google.com/maps/ms?msid=$2&output=embed"',
      allowFullscreen: !1
    },
    {
      regex: /dailymotion\.com\/video\/([^_]+)/,
      type: "iframe",
      w: 480,
      h: 270,
      url: "www.dailymotion.com/embed/video/$1",
      allowFullscreen: !0
    },
    {
      regex: /dai\.ly\/([^_]+)/,
      type: "iframe",
      w: 480,
      h: 270,
      url: "www.dailymotion.com/embed/video/$1",
      allowFullscreen: !0
    }
  ], At = (Ne) => {
    const Ae = Ne.match(/^(https?:\/\/|www\.)(.+)$/i);
    return Ae && Ae.length > 1 ? Ae[1] === "www." ? "https://" : Ae[1] : "https://";
  }, Pt = (Ne, Ae) => {
    const ct = At(Ae), Ct = Ne.regex.exec(Ae);
    let Kn = ct + Ne.url;
    if (N(Ct))
      for (let lo = 0; lo < Ct.length; lo++)
        Kn = Kn.replace("$" + lo, () => Ct[lo] ? Ct[lo] : "");
    return Kn.replace(/\?$/, "");
  }, Hn = (Ne) => {
    const Ae = So.filter((ct) => ct.regex.test(Ne));
    return Ae.length > 0 ? _t.extend({}, Ae[0], { url: Pt(Ae[0], Ne) }) : null;
  }, Nt = (Ne, Ae) => {
    if (Ae)
      return Ae(Ne);
    {
      const ct = Ne.allowfullscreen ? ' allowFullscreen="1"' : "";
      return '<iframe src="' + Ne.source + '" width="' + Ne.width + '" height="' + Ne.height + '"' + ct + "></iframe>";
    }
  }, Vn = (Ne) => {
    let Ae = '<object data="' + Ne.source + '" width="' + Ne.width + '" height="' + Ne.height + '" type="application/x-shockwave-flash">';
    return Ne.poster && (Ae += '<img src="' + Ne.poster + '" width="' + Ne.width + '" height="' + Ne.height + '" />'), Ae += "</object>", Ae;
  }, tn = (Ne, Ae) => Ae ? Ae(Ne) : '<audio controls="controls" src="' + Ne.source + '">' + (Ne.altsource ? `
<source src="` + Ne.altsource + '"' + (Ne.altsourcemime ? ' type="' + Ne.altsourcemime + '"' : "") + ` />
` : "") + "</audio>", je = (Ne, Ae) => Ae ? Ae(Ne) : '<video width="' + Ne.width + '" height="' + Ne.height + '"' + (Ne.poster ? ' poster="' + Ne.poster + '"' : "") + ` controls="controls">
<source src="` + Ne.source + '"' + (Ne.sourcemime ? ' type="' + Ne.sourcemime + '"' : "") + ` />
` + (Ne.altsource ? '<source src="' + Ne.altsource + '"' + (Ne.altsourcemime ? ' type="' + Ne.altsourcemime + '"' : "") + ` />
` : "") + "</video>", An = (Ne, Ae) => {
    var ct;
    const Ct = _t.extend({}, Ae);
    if (!Ct.source && (_t.extend(Ct, Tt((ct = Ct.embed) !== null && ct !== void 0 ? ct : "", Ne.schema)), !Ct.source))
      return "";
    Ct.altsource || (Ct.altsource = ""), Ct.poster || (Ct.poster = ""), Ct.source = Ne.convertURL(Ct.source, "source"), Ct.altsource = Ne.convertURL(Ct.altsource, "source"), Ct.sourcemime = Je(Ct.source), Ct.altsourcemime = Je(Ct.altsource), Ct.poster = Ne.convertURL(Ct.poster, "poster");
    const Kn = Hn(Ct.source);
    if (Kn && (Ct.source = Kn.url, Ct.type = Kn.type, Ct.allowfullscreen = Kn.allowFullscreen, Ct.width = Ct.width || String(Kn.w), Ct.height = Ct.height || String(Kn.h)), Ct.embed)
      return ds(Ct.embed, Ct, !0, Ne.schema);
    {
      const lo = Ze(Ne), Bo = rt(Ne), Xs = ee(Ne);
      return Ct.width = Ct.width || "300", Ct.height = Ct.height || "150", _t.each(Ct, ($e, Oo) => {
        Ct[Oo] = Ne.dom.encode("" + $e);
      }), Ct.type === "iframe" ? Nt(Ct, Xs) : Ct.sourcemime === "application/x-shockwave-flash" ? Vn(Ct) : Ct.sourcemime.indexOf("audio") !== -1 ? tn(Ct, lo) : je(Ct, Bo);
    }
  }, qn = (Ne) => Ne.hasAttribute("data-mce-object") || Ne.hasAttribute("data-ephox-embed-iri"), on = (Ne) => {
    Ne.on("mousedown", (Ae) => {
      const ct = Ne.dom.getParent(Ae.target, ".mce-preview-object");
      ct && Ne.dom.getAttrib(ct, "data-mce-selected") === "2" && Ae.stopImmediatePropagation();
    }), Ne.on("click keyup touchend", () => {
      const Ae = Ne.selection.getNode();
      Ae && Ne.dom.hasClass(Ae, "mce-preview-object") && Ne.dom.getAttrib(Ae, "data-mce-selected") && Ae.setAttribute("data-mce-selected", "2");
    }), Ne.on("ObjectResized", (Ae) => {
      const ct = Ae.target;
      if (ct.getAttribute("data-mce-object")) {
        let Ct = ct.getAttribute("data-mce-html");
        Ct && (Ct = unescape(Ct), ct.setAttribute("data-mce-html", escape(ds(Ct, {
          width: String(Ae.width),
          height: String(Ae.height)
        }, !1, Ne.schema))));
      }
    });
  }, zt = {}, vt = (Ne, Ae, ct) => new Promise((Ct, Kn) => {
    const lo = (Bo) => (Bo.html && (zt[Ne.source] = Bo), Ct({
      url: Ne.source,
      html: Bo.html ? Bo.html : Ae(Ne)
    }));
    zt[Ne.source] ? lo(zt[Ne.source]) : ct({ url: Ne.source }).then(lo).catch(Kn);
  }), oo = (Ne, Ae) => Promise.resolve({
    html: Ae(Ne),
    url: Ne.source
  }), Dn = (Ne) => (Ae) => An(Ne, Ae), ao = (Ne, Ae) => {
    const ct = Vt(Ne);
    return ct ? vt(Ae, Dn(Ne), ct) : oo(Ae, Dn(Ne));
  }, xs = (Ne) => oe(zt, Ne), rs = (Ne, Ae) => re(Ae, Ne).bind((ct) => re(ct, "meta")), Qo = (Ne, Ae, ct) => (Ct) => {
    const Kn = () => re(Ne, Ct), lo = () => re(Ae, Ct), Bo = (Oo) => re(Oo, "value").bind((Pe) => Pe.length > 0 ? H.some(Pe) : H.none()), Xs = () => Kn().bind((Oo) => x(Oo) ? Bo(Oo).orThunk(lo) : lo().orThunk(() => H.from(Oo))), $e = () => lo().orThunk(() => Kn().bind((Oo) => x(Oo) ? Bo(Oo) : H.from(Oo)));
    return { [Ct]: (Ct === ct ? Xs() : $e()).getOr("") };
  }, os = (Ne, Ae) => {
    const ct = {};
    return re(Ne, "dimensions").each((Ct) => {
      K([
        "width",
        "height"
      ], (Kn) => {
        re(Ae, Kn).orThunk(() => re(Ct, Kn)).each((lo) => ct[Kn] = lo);
      });
    }), ct;
  }, zs = (Ne, Ae) => {
    const ct = Ae && Ae !== "dimensions" ? rs(Ae, Ne).getOr({}) : {}, Ct = Qo(Ne, ct, Ae);
    return {
      ...Ct("source"),
      ...Ct("altsource"),
      ...Ct("poster"),
      ...Ct("embed"),
      ...os(Ne, ct)
    };
  }, it = (Ne) => {
    const Ae = {
      ...Ne,
      source: { value: re(Ne, "source").getOr("") },
      altsource: { value: re(Ne, "altsource").getOr("") },
      poster: { value: re(Ne, "poster").getOr("") }
    };
    return K([
      "width",
      "height"
    ], (ct) => {
      re(Ne, ct).each((Ct) => {
        const Kn = Ae.dimensions || {};
        Kn[ct] = Ct, Ae.dimensions = Kn;
      });
    }), Ae;
  }, kt = (Ne) => (Ae) => {
    const ct = Ae && Ae.msg ? "Media embed handler error: " + Ae.msg : "Media embed handler threw unknown error.";
    Ne.notificationManager.open({
      type: "error",
      text: ct
    });
  }, xn = (Ne) => {
    const Ae = Ne.selection.getNode(), ct = qn(Ae) ? Ne.serializer.serialize(Ae, { selection: !0 }) : "", Ct = Tt(ct, Ne.schema), lo = (() => {
      if (pr(Ct.source, Ct.type)) {
        const Bo = Ne.dom.getRect(Ae);
        return {
          width: Bo.w.toString().replace(/px$/, ""),
          height: Bo.h.toString().replace(/px$/, "")
        };
      } else
        return {};
    })();
    return {
      embed: ct,
      ...Ct,
      ...lo
    };
  }, hn = (Ne, Ae) => (ct) => {
    if (g(ct.url) && ct.url.trim().length > 0) {
      const Ct = ct.html, lo = {
        ...Tt(Ct, Ae.schema),
        source: ct.url,
        embed: Ct
      };
      Ne.setData(it(lo));
    }
  }, Do = (Ne, Ae) => {
    const ct = Ne.dom.select("*[data-mce-object]");
    for (let Ct = 0; Ct < Ae.length; Ct++)
      for (let Kn = ct.length - 1; Kn >= 0; Kn--)
        Ae[Ct] === ct[Kn] && ct.splice(Kn, 1);
    Ne.selection.select(ct[0]);
  }, Ss = (Ne, Ae) => {
    const ct = Ne.dom.select("*[data-mce-object]");
    Ne.insertContent(Ae), Do(Ne, ct), Ne.nodeChanged();
  }, pr = (Ne, Ae) => N(Ae) && Ae === "ephox-embed-iri" && N(Hn(Ne)), ta = (Ne, Ae) => ((Ct, Kn) => Ct.width !== Kn.width || Ct.height !== Kn.height)(Ne, Ae) && pr(Ae.source, Ne.type), Ms = (Ne, Ae, ct) => {
    var Ct;
    Ae.embed = ta(Ne, Ae) && Rn(ct) ? An(ct, {
      ...Ae,
      embed: ""
    }) : ds((Ct = Ae.embed) !== null && Ct !== void 0 ? Ct : "", Ae, !1, ct.schema), Ae.embed && (Ne.source === Ae.source || xs(Ae.source)) ? Ss(ct, Ae.embed) : ao(ct, Ae).then((Kn) => {
      Ss(ct, Kn.html);
    }).catch(kt(ct));
  }, hr = (Ne) => {
    const Ae = xn(Ne), ct = pe(Ae), Ct = it(Ae), Kn = (Gn, Qn) => {
      const co = zs(Qn.getData(), "source");
      Gn.source !== co.source && (hn(Zn, Ne)({
        url: co.source,
        html: ""
      }), ao(Ne, co).then(hn(Zn, Ne)).catch(kt(Ne)));
    }, lo = (Gn) => {
      var Qn;
      const co = zs(Gn.getData()), Jo = Tt((Qn = co.embed) !== null && Qn !== void 0 ? Qn : "", Ne.schema);
      Gn.setData(it(Jo));
    }, Bo = (Gn, Qn, co) => {
      const Jo = zs(Gn.getData(), Qn), Gs = ta(co, Jo) && Rn(Ne) ? {
        ...Jo,
        embed: ""
      } : Jo, Wa = An(Ne, Gs);
      Gn.setData(it({
        ...Gs,
        embed: Wa
      }));
    }, Xs = [{
      name: "source",
      type: "urlinput",
      filetype: "media",
      label: "Source",
      picker_text: "Browse files"
    }], $e = Rn(Ne) ? [{
      type: "sizeinput",
      name: "dimensions",
      label: "Constrain proportions",
      constrain: !0
    }] : [], Oo = {
      title: "General",
      name: "general",
      items: J([
        Xs,
        $e
      ])
    }, Ie = {
      title: "Embed",
      items: [{
        type: "textarea",
        name: "embed",
        label: "Paste your embed code below:"
      }]
    }, Lt = [];
    Ue(Ne) && Lt.push({
      name: "altsource",
      type: "urlinput",
      filetype: "media",
      label: "Alternative source URL"
    }), Ce(Ne) && Lt.push({
      name: "poster",
      type: "urlinput",
      filetype: "image",
      label: "Media poster (Image URL)"
    });
    const Zt = {
      title: "Advanced",
      name: "advanced",
      items: Lt
    }, kn = [
      Oo,
      Ie
    ];
    Lt.length > 0 && kn.push(Zt);
    const Jn = {
      type: "tabpanel",
      tabs: kn
    }, Zn = Ne.windowManager.open({
      title: "Insert/Edit Media",
      size: "normal",
      body: Jn,
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      onSubmit: (Gn) => {
        const Qn = zs(Gn.getData());
        Ms(ct.get(), Qn, Ne), Gn.close();
      },
      onChange: (Gn, Qn) => {
        switch (Qn.name) {
          case "source":
            Kn(ct.get(), Gn);
            break;
          case "embed":
            lo(Gn);
            break;
          case "dimensions":
          case "altsource":
          case "poster":
            Bo(Gn, Qn.name, ct.get());
            break;
        }
        ct.set(zs(Gn.getData()));
      },
      initialData: Ct
    });
  }, qt = (Ne) => ({ showDialog: () => {
    hr(Ne);
  } }), Ko = (Ne) => {
    const Ae = () => {
      hr(Ne);
    };
    Ne.addCommand("mceMedia", Ae);
  }, Lr = (Ne, Ae, ct) => Ne.length >= Ae.length && Ne.substr(ct, ct + Ae.length) === Ae, ha = (Ne, Ae) => Lr(Ne, Ae, 0);
  var ia = tinymce.util.Tools.resolve("tinymce.Env");
  const na = (Ne) => {
    const Ae = Ne.name;
    return Ae === "iframe" || Ae === "video" || Ae === "audio";
  }, ks = (Ne, Ae, ct, Ct = null) => {
    const Kn = Ne.attr(ct);
    return N(Kn) ? Kn : oe(Ae, ct) ? null : Ct;
  }, xa = (Ne, Ae, ct) => {
    const Ct = Ae.name === "img" || Ne.name === "video", Kn = Ct ? "300" : null, lo = Ne.name === "audio" ? "30" : "150", Bo = Ct ? lo : null;
    Ae.attr({
      width: ks(Ne, ct, "width", Kn),
      height: ks(Ne, ct, "height", Bo)
    });
  }, la = (Ne, Ae, ct, Ct) => {
    const Kn = Rt(Ne.schema).parse(Ct, { context: Ae });
    for (; Kn.firstChild; )
      ct.append(Kn.firstChild);
  }, _s = (Ne, Ae) => {
    const ct = Ae.name, Ct = new pn("img", 1);
    return wr(Ne, Ae, Ct), xa(Ae, Ct, {}), Ct.attr({
      style: Ae.attr("style"),
      src: ia.transparentSrc,
      "data-mce-object": ct,
      class: "mce-object mce-object-" + ct
    }), Ct;
  }, Xn = (Ne, Ae) => {
    var ct;
    const Ct = Ae.name, Kn = new pn("span", 1);
    Kn.attr({
      contentEditable: "false",
      style: Ae.attr("style"),
      "data-mce-object": Ct,
      class: "mce-preview-object mce-object-" + Ct
    }), wr(Ne, Ae, Kn);
    const lo = Ne.dom.parseStyle((ct = Ae.attr("style")) !== null && ct !== void 0 ? ct : ""), Bo = new pn(Ct, 1);
    if (xa(Ae, Bo, lo), Bo.attr({
      src: Ae.attr("src"),
      style: Ae.attr("style"),
      class: Ae.attr("class")
    }), Ct === "iframe")
      Bo.attr({
        allowfullscreen: Ae.attr("allowfullscreen"),
        frameborder: "0",
        sandbox: Ae.attr("sandbox"),
        referrerpolicy: Ae.attr("referrerpolicy")
      });
    else {
      K([
        "controls",
        "crossorigin",
        "currentTime",
        "loop",
        "muted",
        "poster",
        "preload"
      ], (Pe) => {
        Bo.attr(Pe, Ae.attr(Pe));
      });
      const Oo = Kn.attr("data-mce-html");
      N(Oo) && la(Ne, Ct, Bo, unescape(Oo));
    }
    const Xs = new pn("span", 1);
    return Xs.attr("class", "mce-shim"), Kn.append(Bo), Kn.append(Xs), Kn;
  }, wr = (Ne, Ae, ct) => {
    var Ct;
    const Kn = (Ct = Ae.attributes) !== null && Ct !== void 0 ? Ct : [];
    let lo = Kn.length;
    for (; lo--; ) {
      const Oo = Kn[lo].name;
      let Pe = Kn[lo].value;
      Oo !== "width" && Oo !== "height" && Oo !== "style" && !ha(Oo, "data-mce-") && ((Oo === "data" || Oo === "src") && (Pe = Ne.convertURL(Pe, Oo)), ct.attr("data-mce-p-" + Oo, Pe));
    }
    const Bo = Ro({ inner: !0 }, Ne.schema), Xs = new pn("div", 1);
    K(Ae.children(), (Oo) => Xs.append(Oo));
    const $e = Bo.serialize(Xs);
    $e && (ct.attr("data-mce-html", escape($e)), ct.empty());
  }, Ke = (Ne) => {
    const Ae = Ne.attr("class");
    return g(Ae) && /\btiny-pageembed\b/.test(Ae);
  }, ht = (Ne) => {
    let Ae = Ne;
    for (; Ae = Ae.parent; )
      if (Ae.attr("data-ephox-embed-iri") || Ke(Ae))
        return !0;
    return !1;
  }, gn = (Ne) => (Ae) => {
    let ct = Ae.length, Ct;
    for (; ct--; )
      Ct = Ae[ct], Ct.parent && (Ct.parent.attr("data-mce-object") || (na(Ct) && lt(Ne) ? ht(Ct) || Ct.replace(Xn(Ne, Ct)) : ht(Ct) || Ct.replace(_s(Ne, Ct))));
  }, En = (Ne, Ae, ct) => {
    const Ct = Ne.options.get, Kn = Ct("xss_sanitization"), lo = wt(Ne);
    return Rt(Ne.schema, {
      sanitize: Kn,
      validate: lo
    }).parse(ct, { context: Ae });
  }, Ao = (Ne) => {
    Ne.on("PreInit", () => {
      const { schema: Ae, serializer: ct, parser: Ct } = Ne, Kn = Ae.getBoolAttrs();
      K("webkitallowfullscreen mozallowfullscreen".split(" "), (lo) => {
        Kn[lo] = {};
      }), ye({ embed: ["wmode"] }, (lo, Bo) => {
        const Xs = Ae.getElementRule(Bo);
        Xs && K(lo, ($e) => {
          Xs.attributes[$e] = {}, Xs.attributesOrder.push($e);
        });
      }), Ct.addNodeFilter("iframe,video,audio,object,embed", gn(Ne)), ct.addAttributeFilter("data-mce-object", (lo, Bo) => {
        var Xs;
        let $e = lo.length;
        for (; $e--; ) {
          const Oo = lo[$e];
          if (!Oo.parent)
            continue;
          const Pe = Oo.attr(Bo), Ie = new pn(Pe, 1);
          if (Pe !== "audio") {
            const Jn = Oo.attr("class");
            Jn && Jn.indexOf("mce-preview-object") !== -1 && Oo.firstChild ? Ie.attr({
              width: Oo.firstChild.attr("width"),
              height: Oo.firstChild.attr("height")
            }) : Ie.attr({
              width: Oo.attr("width"),
              height: Oo.attr("height")
            });
          }
          Ie.attr({ style: Oo.attr("style") });
          const Lt = (Xs = Oo.attributes) !== null && Xs !== void 0 ? Xs : [];
          let Zt = Lt.length;
          for (; Zt--; ) {
            const Jn = Lt[Zt].name;
            Jn.indexOf("data-mce-p-") === 0 && Ie.attr(Jn.substr(11), Lt[Zt].value);
          }
          const kn = Oo.attr("data-mce-html");
          if (kn) {
            const Jn = En(Ne, Pe, unescape(kn));
            K(Jn.children(), (Zn) => Ie.append(Zn));
          }
          Oo.replace(Ie);
        }
      });
    }), Ne.on("SetContent", () => {
      const Ae = Ne.dom;
      K(Ae.select("span.mce-preview-object"), (ct) => {
        Ae.select("span.mce-shim", ct).length === 0 && Ae.add(ct, "span", { class: "mce-shim" });
      });
    });
  }, as = (Ne) => {
    Ne.on("ResolveName", (Ae) => {
      let ct;
      Ae.target.nodeType === 1 && (ct = Ae.target.getAttribute("data-mce-object")) && (Ae.name = ct);
    });
  }, Yr = (Ne) => (Ae) => {
    const ct = () => {
      Ae.setEnabled(Ne.selection.isEditable());
    };
    return Ne.on("NodeChange", ct), ct(), () => {
      Ne.off("NodeChange", ct);
    };
  }, Xr = (Ne) => {
    const Ae = () => Ne.execCommand("mceMedia");
    Ne.ui.registry.addToggleButton("media", {
      tooltip: "Insert/edit media",
      icon: "embed",
      onAction: Ae,
      onSetup: (ct) => {
        const Ct = Ne.selection;
        ct.setActive(qn(Ct.getNode()));
        const Kn = Ct.selectorChangedWithUnbind("img[data-mce-object],span[data-mce-object],div[data-ephox-embed-iri]", ct.setActive).unbind, lo = Yr(Ne)(ct);
        return () => {
          Kn(), lo();
        };
      }
    }), Ne.ui.registry.addMenuItem("media", {
      icon: "embed",
      text: "Media...",
      onAction: Ae,
      onSetup: Yr(Ne)
    });
  };
  var Tr = () => {
    o.add("media", (Ne) => (ve(Ne), Ko(Ne), Xr(Ne), as(Ne), Ao(Ne), on(Ne), qt(Ne)));
  };
  Tr();
})();
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const a = (re) => (oe) => typeof oe === re, c = a("boolean"), f = a("number"), g = (re) => (oe) => oe.options.get(re), x = (re) => {
    const oe = re.options.register;
    oe("nonbreaking_force_tab", {
      processor: (U) => c(U) ? {
        value: U ? 3 : 0,
        valid: !0
      } : f(U) ? {
        value: U,
        valid: !0
      } : {
        valid: !1,
        message: "Must be a boolean or number."
      },
      default: !1
    }), oe("nonbreaking_wrap", {
      processor: "boolean",
      default: !0
    });
  }, k = g("nonbreaking_force_tab"), A = g("nonbreaking_wrap"), N = (re, oe) => {
    let U = "";
    for (let ve = 0; ve < oe; ve++)
      U += re;
    return U;
  }, H = (re) => re.plugins.visualchars ? re.plugins.visualchars.isEnabled() : !1, Z = (re, oe) => {
    const U = () => H(re) ? "mce-nbsp-wrap mce-nbsp" : "mce-nbsp-wrap", ve = () => `<span class="${U()}" contenteditable="false">${N("&nbsp;", oe)}</span>`, rt = A(re) || re.plugins.visualchars ? ve() : N("&nbsp;", oe);
    re.undoManager.transact(() => re.insertContent(rt));
  }, K = (re) => {
    re.addCommand("mceNonBreaking", () => {
      Z(re, 1);
    });
  };
  var J = tinymce.util.Tools.resolve("tinymce.util.VK");
  const pe = (re) => {
    const oe = k(re);
    oe > 0 && re.on("keydown", (U) => {
      if (U.keyCode === J.TAB && !U.isDefaultPrevented()) {
        if (U.shiftKey)
          return;
        U.preventDefault(), U.stopImmediatePropagation(), Z(re, oe);
      }
    });
  }, Se = (re) => (oe) => {
    const U = () => {
      oe.setEnabled(re.selection.isEditable());
    };
    return re.on("NodeChange", U), U(), () => {
      re.off("NodeChange", U);
    };
  }, be = (re) => {
    const oe = () => re.execCommand("mceNonBreaking");
    re.ui.registry.addButton("nonbreaking", {
      icon: "non-breaking",
      tooltip: "Nonbreaking space",
      onAction: oe,
      onSetup: Se(re)
    }), re.ui.registry.addMenuItem("nonbreaking", {
      icon: "non-breaking",
      text: "Nonbreaking space",
      onAction: oe,
      onSetup: Se(re)
    });
  };
  var ye = () => {
    o.add("nonbreaking", (re) => {
      x(re), K(re), be(re), pe(re);
    });
  };
  ye();
})();
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const a = (At, Pt, Hn) => {
    var Nt;
    return Hn(At, Pt.prototype) ? !0 : ((Nt = At.constructor) === null || Nt === void 0 ? void 0 : Nt.name) === Pt.name;
  }, c = (At) => {
    const Pt = typeof At;
    return At === null ? "null" : Pt === "object" && Array.isArray(At) ? "array" : Pt === "object" && a(At, String, (Hn, Nt) => Nt.isPrototypeOf(Hn)) ? "string" : Pt;
  }, f = (At) => (Pt) => c(Pt) === At, g = (At) => (Pt) => typeof Pt === At, x = f("string"), k = g("boolean"), A = (At) => At == null, N = (At) => !A(At), H = g("function"), Z = (At) => (Pt) => Pt.options.get(At), K = (At) => {
    const Pt = At.options.register, Hn = (je) => (An) => {
      const qn = k(An) || x(An);
      return qn ? k(An) ? {
        value: An ? je : "",
        valid: qn
      } : {
        value: An.trim(),
        valid: qn
      } : {
        valid: !1,
        message: "Must be a boolean or string."
      };
    }, Nt = "bold italic | quicklink h2 h3 blockquote";
    Pt("quickbars_selection_toolbar", {
      processor: Hn(Nt),
      default: Nt
    });
    const Vn = "quickimage quicktable";
    Pt("quickbars_insert_toolbar", {
      processor: Hn(Vn),
      default: Vn
    });
    const tn = "alignleft aligncenter alignright";
    Pt("quickbars_image_toolbar", {
      processor: Hn(tn),
      default: tn
    });
  }, J = Z("quickbars_selection_toolbar"), pe = Z("quickbars_insert_toolbar"), Se = Z("quickbars_image_toolbar");
  let be = 0;
  const ye = (At) => {
    const Hn = (/* @__PURE__ */ new Date()).getTime(), Nt = Math.floor(Math.random() * 1e9);
    return be++, At + "_" + Nt + be + String(Hn);
  }, re = (At, Pt, Hn) => {
    At.execCommand("mceInsertTable", !1, {
      rows: Hn,
      columns: Pt
    });
  }, oe = (At, Pt, Hn) => {
    const Nt = At.editorUpload.blobCache, Vn = Nt.create(ye("mceu"), Hn, Pt);
    Nt.add(Vn), At.insertContent(At.dom.createHTML("img", { src: Vn.blobUri() }));
  }, U = (At) => new Promise((Pt) => {
    const Hn = new FileReader();
    Hn.onloadend = () => {
      Pt(Hn.result.split(",")[1]);
    }, Hn.readAsDataURL(At);
  });
  var ve = tinymce.util.Tools.resolve("tinymce.util.Delay");
  const Ze = (At) => new Promise((Pt) => {
    let Hn = !1;
    const Nt = document.createElement("input");
    Nt.type = "file", Nt.accept = "image/*", Nt.style.position = "fixed", Nt.style.left = "0", Nt.style.top = "0", Nt.style.opacity = "0.001", document.body.appendChild(Nt);
    const Vn = (An) => {
      var qn;
      Hn || ((qn = Nt.parentNode) === null || qn === void 0 || qn.removeChild(Nt), Hn = !0, Pt(An));
    }, tn = (An) => {
      Vn(Array.prototype.slice.call(An.target.files));
    };
    Nt.addEventListener("input", tn), Nt.addEventListener("change", tn);
    const je = (An) => {
      const qn = () => {
        Vn([]);
      };
      Hn || (An.type === "focusin" ? ve.setEditorTimeout(At, qn, 1e3) : qn()), At.off("focusin remove", je);
    };
    At.on("focusin remove", je), Nt.click();
  }), rt = (At) => {
    At.ui.registry.addButton("quickimage", {
      icon: "image",
      tooltip: "Insert image",
      onAction: () => {
        Ze(At).then((Pt) => {
          if (Pt.length > 0) {
            const Hn = Pt[0];
            U(Hn).then((Nt) => {
              oe(At, Nt, Hn);
            });
          }
        });
      }
    }), At.ui.registry.addButton("quicktable", {
      icon: "table",
      tooltip: "Insert table",
      onAction: () => {
        re(At, 2, 2);
      }
    });
  }, lt = ((At) => () => At)(!1);
  class wt {
    constructor(Pt, Hn) {
      this.tag = Pt, this.value = Hn;
    }
    static some(Pt) {
      return new wt(!0, Pt);
    }
    static none() {
      return wt.singletonNone;
    }
    fold(Pt, Hn) {
      return this.tag ? Hn(this.value) : Pt();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(Pt) {
      return this.tag ? wt.some(Pt(this.value)) : wt.none();
    }
    bind(Pt) {
      return this.tag ? Pt(this.value) : wt.none();
    }
    exists(Pt) {
      return this.tag && Pt(this.value);
    }
    forall(Pt) {
      return !this.tag || Pt(this.value);
    }
    filter(Pt) {
      return !this.tag || Pt(this.value) ? this : wt.none();
    }
    getOr(Pt) {
      return this.tag ? this.value : Pt;
    }
    or(Pt) {
      return this.tag ? this : Pt;
    }
    getOrThunk(Pt) {
      return this.tag ? this.value : Pt();
    }
    orThunk(Pt) {
      return this.tag ? this : Pt();
    }
    getOrDie(Pt) {
      if (this.tag)
        return this.value;
      throw new Error(Pt ?? "Called getOrDie on None");
    }
    static from(Pt) {
      return N(Pt) ? wt.some(Pt) : wt.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(Pt) {
      this.tag && Pt(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  wt.singletonNone = new wt(!1), typeof window < "u" || Function("return this;")();
  const Vt = 1, Ue = (At) => At.dom.nodeName.toLowerCase(), Ce = (At, Pt) => {
    const Hn = At.dom;
    return Hn && Hn.hasAttribute ? Hn.hasAttribute(Pt) : !1;
  };
  var Rn = (At, Pt, Hn, Nt, Vn) => At(Hn, Nt) ? wt.some(Hn) : H(Vn) && Vn(Hn) ? wt.none() : Pt(Hn, Nt, Vn);
  const _t = (At, Pt) => {
    const Nt = (Pt || document).createElement("div");
    if (Nt.innerHTML = At, !Nt.hasChildNodes() || Nt.childNodes.length > 1) {
      const Vn = "HTML does not have a single root node";
      throw console.error(Vn, At), new Error(Vn);
    }
    return fn(Nt.childNodes[0]);
  }, ot = (At, Pt) => {
    const Nt = (Pt || document).createElement(At);
    return fn(Nt);
  }, B = (At, Pt) => {
    const Nt = (Pt || document).createTextNode(At);
    return fn(Nt);
  }, fn = (At) => {
    if (At == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: At };
  }, jt = {
    fromHtml: _t,
    fromTag: ot,
    fromText: B,
    fromDom: fn,
    fromPoint: (At, Pt, Hn) => wt.from(At.dom.elementFromPoint(Pt, Hn)).map(fn)
  }, Tt = (At, Pt) => {
    const Hn = At.dom;
    if (Hn.nodeType !== Vt)
      return !1;
    {
      const Nt = Hn;
      if (Nt.matches !== void 0)
        return Nt.matches(Pt);
      if (Nt.msMatchesSelector !== void 0)
        return Nt.msMatchesSelector(Pt);
      if (Nt.webkitMatchesSelector !== void 0)
        return Nt.webkitMatchesSelector(Pt);
      if (Nt.mozMatchesSelector !== void 0)
        return Nt.mozMatchesSelector(Pt);
      throw new Error("Browser lacks native selectors");
    }
  }, Je = (At, Pt, Hn) => {
    let Nt = At.dom;
    const Vn = H(Hn) ? Hn : lt;
    for (; Nt.parentNode; ) {
      Nt = Nt.parentNode;
      const tn = jt.fromDom(Nt);
      if (Pt(tn))
        return wt.some(tn);
      if (Vn(tn))
        break;
    }
    return wt.none();
  }, pn = (At, Pt, Hn) => Rn((Vn, tn) => tn(Vn), Je, At, Pt, Hn), Ro = (At, Pt, Hn) => pn(At, Pt, Hn).isSome(), Rt = (At, Pt, Hn) => Je(At, (Nt) => Tt(Nt, Pt), Hn), Cn = (At, Pt, Hn) => Rn((Vn, tn) => Tt(Vn, tn), Rt, At, Pt, Hn), et = (At) => {
    const Pt = pe(At);
    Pt.length > 0 && At.ui.registry.addContextToolbar("quickblock", {
      predicate: (Hn) => {
        const Nt = jt.fromDom(Hn), Vn = At.schema.getTextBlockElements(), tn = (je) => je.dom === At.getBody();
        return !Ce(Nt, "data-mce-bogus") && Cn(Nt, 'table,[data-mce-bogus="all"]', tn).fold(() => Ro(Nt, (je) => Ue(je) in Vn && At.dom.isEmpty(je.dom), tn), lt);
      },
      items: Pt,
      position: "line",
      scope: "editor"
    });
  }, xt = (At) => At.dom.classList !== void 0, X = (At, Pt) => xt(At) && At.dom.classList.contains(Pt), ds = (At) => {
    const Pt = (je) => At.dom.isEditable(je), Hn = (je) => Pt(je.parentElement), Nt = (je) => {
      const An = je.nodeName === "FIGURE" && /image/i.test(je.className), qn = je.nodeName === "IMG" || An, on = X(jt.fromDom(je), "mce-pagebreak");
      return qn && Hn(je) && !on;
    }, Vn = Se(At);
    Vn.length > 0 && At.ui.registry.addContextToolbar("imageselection", {
      predicate: Nt,
      items: Vn,
      position: "node"
    });
    const tn = J(At);
    tn.length > 0 && At.ui.registry.addContextToolbar("textselection", {
      predicate: (je) => !Nt(je) && !At.selection.isCollapsed() && Pt(je),
      items: tn,
      position: "selection",
      scope: "editor"
    });
  };
  var So = () => {
    o.add("quickbars", (At) => {
      K(At), rt(At), et(At), ds(At);
    });
  };
  So();
})();
(function() {
  const o = (Pe) => {
    let Ie = Pe;
    return {
      get: () => Ie,
      set: (kn) => {
        Ie = kn;
      }
    };
  };
  var a = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const c = (Pe, Ie, Lt) => {
    var Zt;
    return Lt(Pe, Ie.prototype) ? !0 : ((Zt = Pe.constructor) === null || Zt === void 0 ? void 0 : Zt.name) === Ie.name;
  }, f = (Pe) => {
    const Ie = typeof Pe;
    return Pe === null ? "null" : Ie === "object" && Array.isArray(Pe) ? "array" : Ie === "object" && c(Pe, String, (Lt, Zt) => Zt.isPrototypeOf(Lt)) ? "string" : Ie;
  }, g = (Pe) => (Ie) => f(Ie) === Pe, x = (Pe) => (Ie) => typeof Ie === Pe, k = g("string"), A = g("array"), N = x("boolean"), H = (Pe) => Pe == null, Z = (Pe) => !H(Pe), K = x("number"), J = () => {
  }, pe = (Pe) => () => Pe, Se = pe(!0), ye = pe("[~№|!-*+-\\/:;?@\\[-`{}¡«·»¿;·՚-՟։֊־׀׃׆׳״؉؊،؍؛؞؟٪-٭۔܀-܍߷-߹࠰-࠾࡞।॥॰෴๏๚๛༄-༒༺-༽྅࿐-࿔࿙࿚၊-၏჻፡-፨᐀᙭᙮᚛᚜᛫-᛭᜵᜶។-៖៘-៚᠀-᠊᥄᥅᨞᨟᪠-᪦᪨-᪭᭚-᭠᯼-᯿᰻-᰿᱾᱿᳓‐-‧‰-⁃⁅-⁑⁓-⁞⁽⁾₍₎〈〉❨-❵⟅⟆⟦-⟯⦃-⦘⧘-⧛⧼⧽⳹-⳼⳾⳿⵰⸀-⸮⸰⸱、-〃〈-】〔-〟〰〽゠・꓾꓿꘍-꘏꙳꙾꛲-꛷꡴-꡷꣎꣏꣸-꣺꤮꤯꥟꧁-꧍꧞꧟꩜-꩟꫞꫟꯫﴾﴿︐-︙︰-﹒﹔-﹡﹣﹨﹪﹫！-＃％-＊，-／：；？＠［-］＿｛｝｟-･]");
  class re {
    constructor(Ie, Lt) {
      this.tag = Ie, this.value = Lt;
    }
    static some(Ie) {
      return new re(!0, Ie);
    }
    static none() {
      return re.singletonNone;
    }
    fold(Ie, Lt) {
      return this.tag ? Lt(this.value) : Ie();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(Ie) {
      return this.tag ? re.some(Ie(this.value)) : re.none();
    }
    bind(Ie) {
      return this.tag ? Ie(this.value) : re.none();
    }
    exists(Ie) {
      return this.tag && Ie(this.value);
    }
    forall(Ie) {
      return !this.tag || Ie(this.value);
    }
    filter(Ie) {
      return !this.tag || Ie(this.value) ? this : re.none();
    }
    getOr(Ie) {
      return this.tag ? this.value : Ie;
    }
    or(Ie) {
      return this.tag ? this : Ie;
    }
    getOrThunk(Ie) {
      return this.tag ? this.value : Ie();
    }
    orThunk(Ie) {
      return this.tag ? this : Ie();
    }
    getOrDie(Ie) {
      if (this.tag)
        return this.value;
      throw new Error(Ie ?? "Called getOrDie on None");
    }
    static from(Ie) {
      return Z(Ie) ? re.some(Ie) : re.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(Ie) {
      this.tag && Ie(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  re.singletonNone = new re(!1);
  const oe = ye;
  var U = tinymce.util.Tools.resolve("tinymce.Env"), ve = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const Ze = Array.prototype.slice, rt = Array.prototype.push, ee = (Pe, Ie) => {
    const Lt = Pe.length, Zt = new Array(Lt);
    for (let kn = 0; kn < Lt; kn++) {
      const Jn = Pe[kn];
      Zt[kn] = Ie(Jn, kn);
    }
    return Zt;
  }, lt = (Pe, Ie) => {
    for (let Lt = 0, Zt = Pe.length; Lt < Zt; Lt++) {
      const kn = Pe[Lt];
      Ie(kn, Lt);
    }
  }, wt = (Pe, Ie) => {
    for (let Lt = Pe.length - 1; Lt >= 0; Lt--) {
      const Zt = Pe[Lt];
      Ie(Zt, Lt);
    }
  }, Vt = (Pe, Ie) => {
    if (Pe.length === 0)
      return [];
    {
      let Lt = Ie(Pe[0]);
      const Zt = [];
      let kn = [];
      for (let Jn = 0, Zn = Pe.length; Jn < Zn; Jn++) {
        const Gn = Pe[Jn], Qn = Ie(Gn);
        Qn !== Lt && (Zt.push(kn), kn = []), Lt = Qn, kn.push(Gn);
      }
      return kn.length !== 0 && Zt.push(kn), Zt;
    }
  }, Ue = (Pe, Ie, Lt) => (lt(Pe, (Zt, kn) => {
    Lt = Ie(Lt, Zt, kn);
  }), Lt), Ce = (Pe) => {
    const Ie = [];
    for (let Lt = 0, Zt = Pe.length; Lt < Zt; ++Lt) {
      if (!A(Pe[Lt]))
        throw new Error("Arr.flatten item " + Lt + " was not an array, input: " + Pe);
      rt.apply(Ie, Pe[Lt]);
    }
    return Ie;
  }, Rn = (Pe, Ie) => Ce(ee(Pe, Ie)), _t = (Pe, Ie) => {
    const Lt = Ze.call(Pe, 0);
    return Lt.sort(Ie), Lt;
  }, ot = Object.hasOwnProperty, B = (Pe, Ie) => ot.call(Pe, Ie);
  typeof window < "u" || Function("return this;")();
  const fn = 9, ze = 11, jt = 1, Tt = 3, Je = (Pe) => Pe.dom.nodeType, Ro = ((Pe) => (Ie) => Je(Ie) === Pe)(Tt), Rt = (Pe, Ie, Lt) => {
    if (k(Lt) || N(Lt) || K(Lt))
      Pe.setAttribute(Ie, Lt + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", Ie, ":: Value ", Lt, ":: Element ", Pe), new Error("Attribute value was not simple");
  }, Cn = (Pe, Ie, Lt) => {
    Rt(Pe.dom, Ie, Lt);
  }, et = (Pe, Ie) => {
    const Zt = (Ie || document).createElement("div");
    if (Zt.innerHTML = Pe, !Zt.hasChildNodes() || Zt.childNodes.length > 1) {
      const kn = "HTML does not have a single root node";
      throw console.error(kn, Pe), new Error(kn);
    }
    return ds(Zt.childNodes[0]);
  }, xt = (Pe, Ie) => {
    const Zt = (Ie || document).createElement(Pe);
    return ds(Zt);
  }, X = (Pe, Ie) => {
    const Zt = (Ie || document).createTextNode(Pe);
    return ds(Zt);
  }, ds = (Pe) => {
    if (Pe == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: Pe };
  }, At = {
    fromHtml: et,
    fromTag: xt,
    fromText: X,
    fromDom: ds,
    fromPoint: (Pe, Ie, Lt) => re.from(Pe.dom.elementFromPoint(Ie, Lt)).map(ds)
  }, Pt = (Pe) => Pe.nodeType !== jt && Pe.nodeType !== fn && Pe.nodeType !== ze || Pe.childElementCount === 0, Hn = (Pe, Ie) => {
    const Lt = Ie === void 0 ? document : Ie.dom;
    return Pt(Lt) ? [] : ee(Lt.querySelectorAll(Pe), At.fromDom);
  }, Nt = (Pe) => re.from(Pe.dom.parentNode).map(At.fromDom), Vn = (Pe) => ee(Pe.dom.childNodes, At.fromDom), tn = (Pe, Ie) => ({
    element: Pe,
    offset: Ie
  }), je = (Pe, Ie) => {
    const Lt = Vn(Pe);
    return Lt.length > 0 && Ie < Lt.length ? tn(Lt[Ie], 0) : tn(Pe, Ie);
  }, An = (Pe, Ie) => {
    Nt(Pe).each((Zt) => {
      Zt.dom.insertBefore(Ie.dom, Pe.dom);
    });
  }, qn = (Pe, Ie) => {
    Pe.dom.appendChild(Ie.dom);
  }, on = (Pe, Ie) => {
    An(Pe, Ie), qn(Ie, Pe);
  }, vt = ((Pe, Ie) => {
    const Lt = (Jn) => {
      if (!Pe(Jn))
        throw new Error("Can only get " + Ie + " value of a " + Ie + " node");
      return Zt(Jn).getOr("");
    }, Zt = (Jn) => Pe(Jn) ? re.from(Jn.dom.nodeValue) : re.none();
    return {
      get: Lt,
      getOption: Zt,
      set: (Jn, Zn) => {
        if (!Pe(Jn))
          throw new Error("Can only set raw " + Ie + " value of a " + Ie + " node");
        Jn.dom.nodeValue = Zn;
      }
    };
  })(Ro, "text"), oo = (Pe) => vt.get(Pe), Dn = (Pe, Ie, Lt) => (Pe.compareDocumentPosition(Ie) & Lt) !== 0, ao = (Pe, Ie) => Dn(Pe, Ie, Node.DOCUMENT_POSITION_PRECEDING), xs = (Pe, Ie) => Hn(Ie, Pe);
  var rs = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker");
  const Qo = (Pe, Ie) => Pe.isBlock(Ie) || B(Pe.schema.getVoidElements(), Ie.nodeName), os = (Pe, Ie) => !Pe.isEditable(Ie), zs = (Pe, Ie) => Pe.getContentEditable(Ie) === "true" && Ie.parentNode && !Pe.isEditable(Ie.parentNode), it = (Pe, Ie) => !Pe.isBlock(Ie) && B(Pe.schema.getWhitespaceElements(), Ie.nodeName), kt = (Pe, Ie) => Qo(Pe, Ie) || os(Pe, Ie) || it(Pe, Ie) || zs(Pe, Ie), xn = (Pe) => Pe.nodeType === 3, hn = () => ({
    sOffset: 0,
    fOffset: 0,
    elements: []
  }), Do = (Pe, Ie) => je(At.fromDom(Pe), Ie), Ss = (Pe, Ie, Lt, Zt, kn, Jn = !0) => {
    let Zn = Jn ? Ie(!1) : Lt;
    for (; Zn; ) {
      const Gn = os(Pe, Zn);
      if (Gn || it(Pe, Zn)) {
        if (Gn ? Zt.cef(Zn) : Zt.boundary(Zn))
          break;
        Zn = Ie(!0);
        continue;
      } else if (Qo(Pe, Zn)) {
        if (Zt.boundary(Zn))
          break;
      } else xn(Zn) && Zt.text(Zn);
      if (Zn === kn)
        break;
      Zn = Ie(!1);
    }
  }, pr = (Pe, Ie, Lt, Zt, kn) => {
    var Jn;
    if (kt(Pe, Lt))
      return;
    const Zn = (Jn = Pe.getParent(Zt, Pe.isBlock)) !== null && Jn !== void 0 ? Jn : Pe.getRoot(), Gn = new rs(Lt, Zn), Qn = kn ? Gn.next.bind(Gn) : Gn.prev.bind(Gn);
    Ss(Pe, Qn, Lt, {
      boundary: Se,
      cef: Se,
      text: (co) => {
        kn ? Ie.fOffset += co.length : Ie.sOffset += co.length, Ie.elements.push(At.fromDom(co));
      }
    });
  }, ta = (Pe, Ie, Lt, Zt, kn, Jn = !0) => {
    const Zn = new rs(Lt, Ie), Gn = [];
    let Qn = hn();
    pr(Pe, Qn, Lt, Ie, !1);
    const co = () => (Qn.elements.length > 0 && (Gn.push(Qn), Qn = hn()), !1);
    return Ss(Pe, Zn.next.bind(Zn), Lt, {
      boundary: co,
      cef: (Jo) => (co(), kn && Gn.push(...kn.cef(Jo)), !1),
      text: (Jo) => {
        Qn.elements.push(At.fromDom(Jo)), kn && kn.text(Jo, Qn);
      }
    }, Zt, Jn), Zt && pr(Pe, Qn, Zt, Ie, !0), co(), Gn;
  }, Ms = (Pe, Ie) => {
    const Lt = Do(Ie.startContainer, Ie.startOffset), Zt = Lt.element.dom, kn = Do(Ie.endContainer, Ie.endOffset), Jn = kn.element.dom;
    return ta(Pe, Ie.commonAncestorContainer, Zt, Jn, {
      text: (Zn, Gn) => {
        Zn === Jn ? Gn.fOffset += Zn.length - kn.offset : Zn === Zt && (Gn.sOffset += Lt.offset);
      },
      cef: (Zn) => {
        const Gn = Rn(xs(At.fromDom(Zn), "*[contenteditable=true]"), (Qn) => {
          const co = Qn.dom;
          return ta(Pe, co, co);
        });
        return _t(Gn, (Qn, co) => ao(Qn.elements[0].dom, co.elements[0].dom) ? 1 : -1);
      }
    }, !1);
  }, hr = (Pe, Ie) => Ie.collapsed ? [] : Ms(Pe, Ie), qt = (Pe, Ie) => {
    const Lt = Pe.createRng();
    return Lt.selectNode(Ie), hr(Pe, Lt);
  }, Ko = (Pe, Ie) => Rn(Ie, (Lt) => qt(Pe, Lt)), Lr = (Pe, Ie, Lt = 0, Zt = Pe.length) => {
    const kn = Ie.regex;
    kn.lastIndex = Lt;
    const Jn = [];
    let Zn;
    for (; Zn = kn.exec(Pe); ) {
      const Gn = Zn[Ie.matchIndex], Qn = Zn.index + Zn[0].indexOf(Gn), co = Qn + Gn.length;
      if (co > Zt)
        break;
      Jn.push({
        start: Qn,
        finish: co
      }), kn.lastIndex = co;
    }
    return Jn;
  }, ha = (Pe, Ie) => {
    const Lt = Ue(Pe, (Zt, kn) => {
      const Jn = oo(kn), Zn = Zt.last, Gn = Zn + Jn.length, Qn = Rn(Ie, (co, Jo) => co.start < Gn && co.finish > Zn ? [{
        element: kn,
        start: Math.max(Zn, co.start) - Zn,
        finish: Math.min(Gn, co.finish) - Zn,
        matchId: Jo
      }] : []);
      return {
        results: Zt.results.concat(Qn),
        last: Gn
      };
    }, {
      results: [],
      last: 0
    }).results;
    return Vt(Lt, (Zt) => Zt.matchId);
  }, ia = (Pe, Ie) => Rn(Ie, (Lt) => {
    const Zt = Lt.elements, kn = ee(Zt, oo).join(""), Jn = Lr(kn, Pe, Lt.sOffset, kn.length - Lt.fOffset);
    return ha(Zt, Jn);
  }), na = (Pe, Ie) => {
    wt(Pe, (Lt, Zt) => {
      wt(Lt, (kn) => {
        const Jn = At.fromDom(Ie.cloneNode(!1));
        Cn(Jn, "data-mce-index", Zt);
        const Zn = kn.element.dom;
        if (Zn.length === kn.finish && kn.start === 0)
          on(kn.element, Jn);
        else {
          Zn.length !== kn.finish && Zn.splitText(kn.finish);
          const Gn = Zn.splitText(kn.start);
          on(At.fromDom(Gn), Jn);
        }
      });
    });
  }, ks = (Pe, Ie, Lt, Zt) => {
    const kn = qt(Pe, Lt), Jn = ia(Ie, kn);
    return na(Jn, Zt), Jn.length;
  }, xa = (Pe, Ie, Lt, Zt) => {
    const kn = Lt.getBookmark(), Jn = Pe.select("td[data-mce-selected],th[data-mce-selected]"), Zn = Jn.length > 0 ? Ko(Pe, Jn) : hr(Pe, Lt.getRng()), Gn = ia(Ie, Zn);
    return na(Gn, Zt), Lt.moveToBookmark(kn), Gn.length;
  }, la = (Pe) => Pe.getAttribute("data-mce-index"), _s = (Pe, Ie, Lt, Zt) => {
    const kn = Pe.dom.create("span", { "data-mce-bogus": 1 });
    kn.className = "mce-match-marker";
    const Jn = Pe.getBody();
    return Tr(Pe, Ie, !1), Zt ? xa(Pe.dom, Lt, Pe.selection, kn) : ks(Pe.dom, Lt, Jn, kn);
  }, Xn = (Pe) => {
    var Ie;
    const Lt = Pe.parentNode;
    Pe.firstChild && Lt.insertBefore(Pe.firstChild, Pe), (Ie = Pe.parentNode) === null || Ie === void 0 || Ie.removeChild(Pe);
  }, wr = (Pe, Ie) => {
    const Lt = [], Zt = ve.toArray(Pe.getBody().getElementsByTagName("span"));
    if (Zt.length)
      for (let kn = 0; kn < Zt.length; kn++) {
        const Jn = la(Zt[kn]);
        Jn === null || !Jn.length || Jn === Ie.toString() && Lt.push(Zt[kn]);
      }
    return Lt;
  }, Ke = (Pe, Ie, Lt) => {
    const Zt = Ie.get();
    let kn = Zt.index;
    const Jn = Pe.dom;
    Lt ? kn + 1 === Zt.count ? kn = 0 : kn++ : kn - 1 === -1 ? kn = Zt.count - 1 : kn--, Jn.removeClass(wr(Pe, Zt.index), "mce-match-marker-selected");
    const Zn = wr(Pe, kn);
    return Zn.length ? (Jn.addClass(wr(Pe, kn), "mce-match-marker-selected"), Pe.selection.scrollIntoView(Zn[0]), kn) : -1;
  }, ht = (Pe, Ie) => {
    const Lt = Ie.parentNode;
    Pe.remove(Ie), Lt && Pe.isEmpty(Lt) && Pe.remove(Lt);
  }, gn = (Pe, Ie) => {
    const Zt = "(" + Pe.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&").replace(/\s/g, "[^\\S\\r\\n\\uFEFF]") + ")";
    return Ie ? `(?:^|\\s|${oe()})` + Zt + `(?=$|\\s|${oe()})` : Zt;
  }, En = (Pe, Ie, Lt, Zt, kn, Jn) => {
    const Zn = Pe.selection, Gn = gn(Lt, kn), Qn = Zn.isForward(), co = {
      regex: new RegExp(Gn, Zt ? "g" : "gi"),
      matchIndex: 1
    }, Jo = _s(Pe, Ie, co, Jn);
    if (U.browser.isSafari() && Zn.setRng(Zn.getRng(), Qn), Jo) {
      const Gs = Ke(Pe, Ie, !0);
      Ie.set({
        index: Gs,
        count: Jo,
        text: Lt,
        matchCase: Zt,
        wholeWord: kn,
        inSelection: Jn
      });
    }
    return Jo;
  }, Ao = (Pe, Ie) => {
    const Lt = Ke(Pe, Ie, !0);
    Ie.set({
      ...Ie.get(),
      index: Lt
    });
  }, as = (Pe, Ie) => {
    const Lt = Ke(Pe, Ie, !1);
    Ie.set({
      ...Ie.get(),
      index: Lt
    });
  }, Yr = (Pe) => {
    const Ie = la(Pe);
    return Ie !== null && Ie.length > 0;
  }, Xr = (Pe, Ie, Lt, Zt, kn) => {
    const Jn = Ie.get(), Zn = Jn.index;
    let Gn, Qn = Zn;
    Zt = Zt !== !1;
    const co = Pe.getBody(), Jo = ve.grep(ve.toArray(co.getElementsByTagName("span")), Yr);
    for (let Gs = 0; Gs < Jo.length; Gs++) {
      const Wa = la(Jo[Gs]);
      let Ti = Gn = parseInt(Wa, 10);
      if (kn || Ti === Jn.index) {
        for (Lt.length ? (Jo[Gs].innerText = Lt, Xn(Jo[Gs])) : ht(Pe.dom, Jo[Gs]); Jo[++Gs]; )
          if (Ti = parseInt(la(Jo[Gs]), 10), Ti === Gn)
            ht(Pe.dom, Jo[Gs]);
          else {
            Gs--;
            break;
          }
        Zt && Qn--;
      } else Gn > Zn && Jo[Gs].setAttribute("data-mce-index", String(Gn - 1));
    }
    return Ie.set({
      ...Jn,
      count: kn ? 0 : Jn.count - 1,
      index: Qn
    }), Zt ? Ao(Pe, Ie) : as(Pe, Ie), !kn && Ie.get().count > 0;
  }, Tr = (Pe, Ie, Lt) => {
    let Zt, kn;
    const Jn = Ie.get(), Zn = ve.toArray(Pe.getBody().getElementsByTagName("span"));
    for (let Gn = 0; Gn < Zn.length; Gn++) {
      const Qn = la(Zn[Gn]);
      Qn !== null && Qn.length && (Qn === Jn.index.toString() && (Zt || (Zt = Zn[Gn].firstChild), kn = Zn[Gn].firstChild), Xn(Zn[Gn]));
    }
    if (Ie.set({
      ...Jn,
      index: -1,
      count: 0,
      text: ""
    }), Zt && kn) {
      const Gn = Pe.dom.createRng();
      return Gn.setStart(Zt, 0), Gn.setEnd(kn, kn.data.length), Lt !== !1 && Pe.selection.setRng(Gn), Gn;
    } else
      return;
  }, Ne = (Pe, Ie) => Ie.get().count > 1, Ae = (Pe, Ie) => Ie.get().count > 1, ct = (Pe, Ie) => ({
    done: (Gn) => Tr(Pe, Ie, Gn),
    find: (Gn, Qn, co, Jo = !1) => En(Pe, Ie, Gn, Qn, co, Jo),
    next: () => Ao(Pe, Ie),
    prev: () => as(Pe, Ie),
    replace: (Gn, Qn, co) => Xr(Pe, Ie, Gn, Qn, co)
  }), Ct = (Pe) => {
    const Ie = o(re.none()), Lt = () => Ie.get().each(Pe);
    return {
      clear: () => {
        Lt(), Ie.set(re.none());
      },
      isSet: () => Ie.get().isSome(),
      get: () => Ie.get(),
      set: (Gn) => {
        Lt(), Ie.set(re.some(Gn));
      }
    };
  }, Kn = () => {
    const Pe = Ct(J);
    return {
      ...Pe,
      on: (Lt) => Pe.get().each(Lt)
    };
  }, lo = (Pe, Ie) => {
    const Lt = Kn();
    Pe.undoManager.add();
    const Zt = ve.trim(Pe.selection.getContent({ format: "text" })), kn = (ko) => {
      ko.setEnabled("next", Ne(Pe, Ie)), ko.setEnabled("prev", Ae(Pe, Ie));
    }, Jn = (ko) => {
      const Zo = ko.getData(), Rs = Ie.get();
      Ie.set({
        ...Rs,
        matchCase: Zo.matchcase,
        wholeWord: Zo.wholewords,
        inSelection: Zo.inselection
      });
    }, Zn = (ko, Zo) => {
      lt([
        "replace",
        "replaceall",
        "prev",
        "next"
      ], (ca) => ko.setEnabled(ca, !Zo));
    }, Gn = (ko, Zo) => {
      Zo.redial(Ai(ko, Zo.getData()));
    }, Qn = (ko, Zo) => {
      U.browser.isSafari() && U.deviceType.isTouch() && (Zo === "find" || Zo === "replace" || Zo === "replaceall") && ko.focus(Zo);
    }, co = (ko) => {
      Tr(Pe, Ie, !1), Zn(ko, !0), kn(ko);
    }, Jo = (ko) => {
      const Zo = ko.getData(), Rs = Ie.get();
      if (!Zo.findtext.length) {
        co(ko);
        return;
      }
      if (Rs.text === Zo.findtext && Rs.matchCase === Zo.matchcase && Rs.wholeWord === Zo.wholewords)
        Ao(Pe, Ie);
      else {
        const Ba = En(Pe, Ie, Zo.findtext, Zo.matchcase, Zo.wholewords, Zo.inselection);
        Ba <= 0 && Gn(!0, ko), Zn(ko, Ba === 0);
      }
      kn(ko);
    }, Gs = Ie.get(), Wa = {
      findtext: Zt,
      replacetext: "",
      wholewords: Gs.wholeWord,
      matchcase: Gs.matchCase,
      inselection: Gs.inSelection
    }, Ti = (ko) => {
      const Zo = [
        {
          type: "label",
          label: "Find",
          for: "findtext",
          items: [{
            type: "bar",
            items: [
              {
                type: "input",
                name: "findtext",
                maximized: !0,
                inputMode: "search"
              },
              {
                type: "button",
                name: "prev",
                text: "Previous",
                icon: "action-prev",
                enabled: !1,
                borderless: !0
              },
              {
                type: "button",
                name: "next",
                text: "Next",
                icon: "action-next",
                enabled: !1,
                borderless: !0
              }
            ]
          }]
        },
        {
          type: "input",
          name: "replacetext",
          label: "Replace with",
          inputMode: "search"
        }
      ];
      return ko && Zo.push({
        type: "alertbanner",
        level: "error",
        text: "Could not find the specified string.",
        icon: "warning"
      }), Zo;
    }, Ai = (ko, Zo) => ({
      title: "Find and Replace",
      size: "normal",
      body: {
        type: "panel",
        items: Ti(ko)
      },
      buttons: [
        {
          type: "menu",
          name: "options",
          icon: "preferences",
          tooltip: "Preferences",
          align: "start",
          items: [
            {
              type: "togglemenuitem",
              name: "matchcase",
              text: "Match case"
            },
            {
              type: "togglemenuitem",
              name: "wholewords",
              text: "Find whole words only"
            },
            {
              type: "togglemenuitem",
              name: "inselection",
              text: "Find in selection"
            }
          ]
        },
        {
          type: "custom",
          name: "find",
          text: "Find",
          primary: !0
        },
        {
          type: "custom",
          name: "replace",
          text: "Replace",
          enabled: !1
        },
        {
          type: "custom",
          name: "replaceall",
          text: "Replace all",
          enabled: !1
        }
      ],
      initialData: Zo,
      onChange: (Rs, Ba) => {
        ko && Gn(!1, Rs), Ba.name === "findtext" && Ie.get().count > 0 && co(Rs);
      },
      onAction: (Rs, Ba) => {
        const ca = Rs.getData();
        switch (Ba.name) {
          case "find":
            Jo(Rs);
            break;
          case "replace":
            Xr(Pe, Ie, ca.replacetext) ? kn(Rs) : co(Rs);
            break;
          case "replaceall":
            Xr(Pe, Ie, ca.replacetext, !0, !0), co(Rs);
            break;
          case "prev":
            as(Pe, Ie), kn(Rs);
            break;
          case "next":
            Ao(Pe, Ie), kn(Rs);
            break;
          case "matchcase":
          case "wholewords":
          case "inselection":
            Gn(!1, Rs), Jn(Rs), co(Rs);
            break;
        }
        Qn(Rs, Ba.name);
      },
      onSubmit: (Rs) => {
        Jo(Rs), Qn(Rs, "find");
      },
      onClose: () => {
        Pe.focus(), Tr(Pe, Ie), Pe.undoManager.add();
      }
    });
    Lt.set(Pe.windowManager.open(Ai(!1, Wa), { inline: "toolbar" }));
  }, Bo = (Pe, Ie) => {
    Pe.addCommand("SearchReplace", () => {
      lo(Pe, Ie);
    });
  }, Xs = (Pe, Ie) => () => {
    lo(Pe, Ie);
  }, $e = (Pe, Ie) => {
    Pe.ui.registry.addMenuItem("searchreplace", {
      text: "Find and replace...",
      shortcut: "Meta+F",
      onAction: Xs(Pe, Ie),
      icon: "search"
    }), Pe.ui.registry.addButton("searchreplace", {
      tooltip: "Find and replace",
      onAction: Xs(Pe, Ie),
      icon: "search",
      shortcut: "Meta+F"
    }), Pe.shortcuts.add("Meta+F", "", Xs(Pe, Ie));
  };
  var Oo = () => {
    a.add("searchreplace", (Pe) => {
      const Ie = o({
        index: -1,
        count: 0,
        text: "",
        matchCase: !1,
        wholeWord: !1,
        inSelection: !1
      });
      return Bo(Pe, Ie), $e(Pe, Ie), ct(Pe, Ie);
    });
  };
  Oo();
})();
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const a = (D, I, te) => {
    var he;
    return te(D, I.prototype) ? !0 : ((he = D.constructor) === null || he === void 0 ? void 0 : he.name) === I.name;
  }, c = (D) => {
    const I = typeof D;
    return D === null ? "null" : I === "object" && Array.isArray(D) ? "array" : I === "object" && a(D, String, (te, he) => he.isPrototypeOf(te)) ? "string" : I;
  }, f = (D) => (I) => c(I) === D, g = (D) => (I) => typeof I === D, x = (D) => (I) => D === I, k = f("string"), A = f("array"), N = g("boolean"), H = x(void 0), Z = (D) => D == null, K = (D) => !Z(D), J = g("function"), pe = g("number"), Se = () => {
  }, be = (D, I) => (te) => D(I(te)), ye = (D) => () => D, re = (D) => D, oe = (D, I) => D === I;
  function U(D, ...I) {
    return (...te) => {
      const he = I.concat(te);
      return D.apply(null, he);
    };
  }
  const ve = (D) => {
    D();
  }, Ze = ye(!1), rt = ye(!0);
  class ee {
    constructor(I, te) {
      this.tag = I, this.value = te;
    }
    static some(I) {
      return new ee(!0, I);
    }
    static none() {
      return ee.singletonNone;
    }
    fold(I, te) {
      return this.tag ? te(this.value) : I();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(I) {
      return this.tag ? ee.some(I(this.value)) : ee.none();
    }
    bind(I) {
      return this.tag ? I(this.value) : ee.none();
    }
    exists(I) {
      return this.tag && I(this.value);
    }
    forall(I) {
      return !this.tag || I(this.value);
    }
    filter(I) {
      return !this.tag || I(this.value) ? this : ee.none();
    }
    getOr(I) {
      return this.tag ? this.value : I;
    }
    or(I) {
      return this.tag ? this : I;
    }
    getOrThunk(I) {
      return this.tag ? this.value : I();
    }
    orThunk(I) {
      return this.tag ? this : I();
    }
    getOrDie(I) {
      if (this.tag)
        return this.value;
      throw new Error(I ?? "Called getOrDie on None");
    }
    static from(I) {
      return K(I) ? ee.some(I) : ee.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(I) {
      this.tag && I(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  ee.singletonNone = new ee(!1);
  const lt = Object.keys, wt = Object.hasOwnProperty, Vt = (D, I) => {
    const te = lt(D);
    for (let he = 0, Be = te.length; he < Be; he++) {
      const Ot = te[he], rn = D[Ot];
      I(rn, Ot);
    }
  }, Ue = (D) => (I, te) => {
    D[te] = I;
  }, Ce = (D, I, te, he) => {
    Vt(D, (Be, Ot) => {
      (I(Be, Ot) ? te : he)(Be, Ot);
    });
  }, Rn = (D, I) => {
    const te = {};
    return Ce(D, I, Ue(te), Se), te;
  }, _t = (D, I) => {
    const te = [];
    return Vt(D, (he, Be) => {
      te.push(I(he, Be));
    }), te;
  }, ot = (D) => _t(D, re), B = (D) => lt(D).length, fn = (D, I) => ze(D, I) ? ee.from(D[I]) : ee.none(), ze = (D, I) => wt.call(D, I), jt = (D, I) => ze(D, I) && D[I] !== void 0 && D[I] !== null, Tt = (D) => {
    for (const I in D)
      if (wt.call(D, I))
        return !1;
    return !0;
  }, Je = Array.prototype.indexOf, pn = Array.prototype.push, Ro = (D, I) => Je.call(D, I), Rt = (D, I) => Ro(D, I) > -1, Cn = (D, I) => {
    for (let te = 0, he = D.length; te < he; te++) {
      const Be = D[te];
      if (I(Be, te))
        return !0;
    }
    return !1;
  }, et = (D, I) => {
    const te = [];
    for (let he = 0; he < D; he++)
      te.push(I(he));
    return te;
  }, xt = (D, I) => {
    const te = D.length, he = new Array(te);
    for (let Be = 0; Be < te; Be++) {
      const Ot = D[Be];
      he[Be] = I(Ot, Be);
    }
    return he;
  }, X = (D, I) => {
    for (let te = 0, he = D.length; te < he; te++) {
      const Be = D[te];
      I(Be, te);
    }
  }, ds = (D, I) => {
    for (let te = D.length - 1; te >= 0; te--) {
      const he = D[te];
      I(he, te);
    }
  }, So = (D, I) => {
    const te = [], he = [];
    for (let Be = 0, Ot = D.length; Be < Ot; Be++) {
      const rn = D[Be];
      (I(rn, Be) ? te : he).push(rn);
    }
    return {
      pass: te,
      fail: he
    };
  }, At = (D, I) => {
    const te = [];
    for (let he = 0, Be = D.length; he < Be; he++) {
      const Ot = D[he];
      I(Ot, he) && te.push(Ot);
    }
    return te;
  }, Pt = (D, I, te) => (ds(D, (he, Be) => {
    te = I(te, he, Be);
  }), te), Hn = (D, I, te) => (X(D, (he, Be) => {
    te = I(te, he, Be);
  }), te), Nt = (D, I, te) => {
    for (let he = 0, Be = D.length; he < Be; he++) {
      const Ot = D[he];
      if (I(Ot, he))
        return ee.some(Ot);
      if (te(Ot, he))
        break;
    }
    return ee.none();
  }, Vn = (D, I) => Nt(D, I, Ze), tn = (D) => {
    const I = [];
    for (let te = 0, he = D.length; te < he; ++te) {
      if (!A(D[te]))
        throw new Error("Arr.flatten item " + te + " was not an array, input: " + D);
      pn.apply(I, D[te]);
    }
    return I;
  }, je = (D, I) => tn(xt(D, I)), An = (D, I) => {
    for (let te = 0, he = D.length; te < he; ++te) {
      const Be = D[te];
      if (I(Be, te) !== !0)
        return !1;
    }
    return !0;
  }, qn = (D, I) => {
    const te = {};
    for (let he = 0, Be = D.length; he < Be; he++) {
      const Ot = D[he];
      te[String(Ot)] = I(Ot, he);
    }
    return te;
  }, on = (D, I) => I >= 0 && I < D.length ? ee.some(D[I]) : ee.none(), zt = (D) => on(D, 0), vt = (D) => on(D, D.length - 1), oo = (D, I) => {
    for (let te = 0; te < D.length; te++) {
      const he = I(D[te], te);
      if (he.isSome())
        return he;
    }
    return ee.none();
  }, Dn = 8, ao = 9, xs = 11, rs = 1, Qo = 3, os = (D, I) => {
    const he = (I || document).createElement("div");
    if (he.innerHTML = D, !he.hasChildNodes() || he.childNodes.length > 1) {
      const Be = "HTML does not have a single root node";
      throw console.error(Be, D), new Error(Be);
    }
    return kt(he.childNodes[0]);
  }, zs = (D, I) => {
    const he = (I || document).createElement(D);
    return kt(he);
  }, it = (D, I) => {
    const he = (I || document).createTextNode(D);
    return kt(he);
  }, kt = (D) => {
    if (D == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: D };
  }, hn = {
    fromHtml: os,
    fromTag: zs,
    fromText: it,
    fromDom: kt,
    fromPoint: (D, I, te) => ee.from(D.dom.elementFromPoint(I, te)).map(kt)
  }, Do = (D, I) => {
    const te = D.dom;
    if (te.nodeType !== rs)
      return !1;
    {
      const he = te;
      if (he.matches !== void 0)
        return he.matches(I);
      if (he.msMatchesSelector !== void 0)
        return he.msMatchesSelector(I);
      if (he.webkitMatchesSelector !== void 0)
        return he.webkitMatchesSelector(I);
      if (he.mozMatchesSelector !== void 0)
        return he.mozMatchesSelector(I);
      throw new Error("Browser lacks native selectors");
    }
  }, Ss = (D) => D.nodeType !== rs && D.nodeType !== ao && D.nodeType !== xs || D.childElementCount === 0, pr = (D, I) => {
    const te = I === void 0 ? document : I.dom;
    return Ss(te) ? [] : xt(te.querySelectorAll(D), hn.fromDom);
  }, ta = (D, I) => {
    const te = I === void 0 ? document : I.dom;
    return Ss(te) ? ee.none() : ee.from(te.querySelector(D)).map(hn.fromDom);
  }, Ms = (D, I) => D.dom === I.dom, hr = Do;
  typeof window < "u" || Function("return this;")();
  const qt = (D) => D.dom.nodeName.toLowerCase(), Ko = (D) => D.dom.nodeType, Lr = (D) => (I) => Ko(I) === D, ha = (D) => Ko(D) === Dn || qt(D) === "#comment", ia = Lr(rs), na = Lr(Qo), ks = Lr(ao), xa = Lr(xs), la = (D) => (I) => ia(I) && qt(I) === D, _s = (D) => hn.fromDom(D.dom.ownerDocument), Xn = (D) => ks(D) ? D : _s(D), wr = (D) => ee.from(D.dom.parentNode).map(hn.fromDom), Ke = (D, I) => {
    const te = J(I) ? I : Ze;
    let he = D.dom;
    const Be = [];
    for (; he.parentNode !== null && he.parentNode !== void 0; ) {
      const Ot = he.parentNode, rn = hn.fromDom(Ot);
      if (Be.push(rn), te(rn) === !0)
        break;
      he = Ot;
    }
    return Be;
  }, ht = (D) => ee.from(D.dom.previousSibling).map(hn.fromDom), gn = (D) => ee.from(D.dom.nextSibling).map(hn.fromDom), En = (D) => xt(D.dom.childNodes, hn.fromDom), Ao = (D, I) => {
    const te = D.dom.childNodes;
    return ee.from(te[I]).map(hn.fromDom);
  }, as = (D) => Ao(D, 0), Yr = (D) => xa(D) && K(D.dom.host), Tr = J(Element.prototype.attachShadow) && J(Node.prototype.getRootNode) ? (D) => hn.fromDom(D.dom.getRootNode()) : Xn, Ne = (D) => {
    const I = Tr(D);
    return Yr(I) ? ee.some(I) : ee.none();
  }, Ae = (D) => hn.fromDom(D.dom.host), ct = (D) => {
    const I = na(D) ? D.dom.parentNode : D.dom;
    if (I == null || I.ownerDocument === null)
      return !1;
    const te = I.ownerDocument;
    return Ne(hn.fromDom(I)).fold(() => te.body.contains(I), be(ct, Ae));
  };
  var Ct = (D, I, te, he, Be) => D(te, he) ? ee.some(te) : J(Be) && Be(te) ? ee.none() : I(te, he, Be);
  const Kn = (D, I, te) => {
    let he = D.dom;
    const Be = J(te) ? te : Ze;
    for (; he.parentNode; ) {
      he = he.parentNode;
      const Ot = hn.fromDom(he);
      if (I(Ot))
        return ee.some(Ot);
      if (Be(Ot))
        break;
    }
    return ee.none();
  }, lo = (D, I, te) => Ct((Be, Ot) => Ot(Be), Kn, D, I, te), Bo = (D, I) => {
    const te = (Be) => I(hn.fromDom(Be));
    return Vn(D.dom.childNodes, te).map(hn.fromDom);
  }, Xs = (D, I, te) => Kn(D, (he) => Do(he, I), te), $e = (D, I) => Bo(D, (te) => Do(te, I)), Oo = (D, I) => ta(I, D), Pe = (D, I, te) => Ct((Be, Ot) => Do(Be, Ot), Xs, D, I, te), Ie = (D) => Pe(D, "[contenteditable]"), Lt = (D, I = !1) => ct(D) ? D.dom.isContentEditable : Ie(D).fold(ye(I), (te) => Zt(te) === "true"), Zt = (D) => D.dom.contentEditable, kn = (D) => D.nodeName.toLowerCase(), Jn = (D) => hn.fromDom(D.getBody()), Zn = (D) => (I) => Ms(I, Jn(D)), Gn = (D) => D ? D.replace(/px$/, "") : "", Qn = (D) => /^\d+(\.\d+)?$/.test(D) ? D + "px" : D, co = (D) => hn.fromDom(D.selection.getStart()), Jo = (D) => hn.fromDom(D.selection.getEnd()), Gs = (D) => lo(D, la("table")).forall(Lt), Wa = (D, I) => At(En(D), I), Ti = (D, I) => {
    let te = [];
    return X(En(D), (he) => {
      I(he) && (te = te.concat([he])), te = te.concat(Ti(he, I));
    }), te;
  }, Ai = (D, I) => Wa(D, (te) => Do(te, I)), ko = (D, I) => pr(I, D), Zo = (D, I, te) => {
    if (k(te) || N(te) || pe(te))
      D.setAttribute(I, te + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", I, ":: Value ", te, ":: Element ", D), new Error("Attribute value was not simple");
  }, Rs = (D, I, te) => {
    Zo(D.dom, I, te);
  }, Ba = (D, I) => {
    const te = D.dom;
    Vt(I, (he, Be) => {
      Zo(te, Be, he);
    });
  }, ca = (D, I) => {
    const te = D.dom.getAttribute(I);
    return te === null ? void 0 : te;
  }, gr = (D, I) => ee.from(ca(D, I)), Qs = (D, I) => {
    D.dom.removeAttribute(I);
  }, ii = (D) => Hn(D.dom.attributes, (I, te) => (I[te.name] = te.value, I), {}), xc = (D, I, te = oe) => D.exists((he) => te(he, I)), Is = (D) => {
    const I = [], te = (he) => {
      I.push(he);
    };
    for (let he = 0; he < D.length; he++)
      D[he].each(te);
    return I;
  }, ka = (D, I, te) => D.isSome() && I.isSome() ? ee.some(te(D.getOrDie(), I.getOrDie())) : ee.none(), li = (D) => D.bind(re), Qr = (D, I) => D ? ee.some(I) : ee.none(), Oi = (D, I) => D.substring(I), cl = (D, I, te) => I === "" || D.length >= I.length && D.substr(te, te + I.length) === I, Za = (D, I) => Di(D, I) ? Oi(D, I.length) : D, Di = (D, I) => cl(D, I, 0), uu = ((D) => (I) => I.replace(D, ""))(/^\s+|\s+$/g), vi = (D) => D.length > 0, Bl = (D) => !vi(D), La = (D, I = 10) => {
    const te = parseInt(D, I);
    return isNaN(te) ? ee.none() : ee.some(te);
  }, Wi = (D) => {
    const I = parseFloat(D);
    return isNaN(I) ? ee.none() : ee.some(I);
  }, Xl = (D) => D.style !== void 0 && J(D.style.getPropertyValue), wc = (D, I, te) => {
    if (!k(te))
      throw console.error("Invalid call to CSS.set. Property ", I, ":: Value ", te, ":: Element ", D), new Error("CSS value must be a string: " + te);
    Xl(D) && D.style.setProperty(I, te);
  }, fd = (D, I) => {
    Xl(D) && D.style.removeProperty(I);
  }, du = (D, I, te) => {
    const he = D.dom;
    wc(he, I, te);
  }, bi = (D, I) => {
    const te = D.dom, Be = window.getComputedStyle(te).getPropertyValue(I);
    return Be === "" && !ct(D) ? Fu(te, I) : Be;
  }, Fu = (D, I) => Xl(D) ? D.style.getPropertyValue(I) : "", ie = (D, I) => {
    const te = D.dom, he = Fu(te, I);
    return ee.from(he).filter((Be) => Be.length > 0);
  }, Oe = (D, I) => {
    const te = D.dom;
    fd(te, I), xc(gr(D, "style").map(uu), "") && Qs(D, "style");
  }, Ge = (D, I, te = 0) => gr(D, I).map((he) => parseInt(he, 10)).getOr(te), Dt = (D, I) => Xt(D, I, rt), Xt = (D, I, te) => je(En(D), (he) => Do(he, I) ? te(he) ? [he] : [] : Xt(he, I, te)), jn = [
    "tfoot",
    "thead",
    "tbody",
    "colgroup"
  ], ss = (D) => Rt(jn, D), hs = (D, I) => ({
    rows: D,
    columns: I
  }), Uo = (D, I, te) => ({
    element: D,
    rowspan: I,
    colspan: te
  }), qs = (D, I, te, he, Be, Ot) => ({
    element: D,
    rowspan: I,
    colspan: te,
    row: he,
    column: Be,
    isLocked: Ot
  }), Ar = (D, I, te) => ({
    element: D,
    cells: I,
    section: te
  }), sn = (D, I, te, he) => ({
    startRow: D,
    startCol: I,
    finishRow: te,
    finishCol: he
  }), md = (D, I, te) => ({
    element: D,
    colspan: I,
    column: te
  }), tr = (D, I) => ({
    element: D,
    columns: I
  }), Y = (D, I, te = Ze) => {
    if (te(I))
      return ee.none();
    if (Rt(D, qt(I)))
      return ee.some(I);
    const he = (Be) => Do(Be, "table") || te(Be);
    return Xs(I, D.join(","), he);
  }, ge = (D, I) => Y([
    "td",
    "th"
  ], D, I), Ee = (D) => Dt(D, "th,td"), dt = (D) => Do(D, "colgroup") ? Ai(D, "col") : je(Ln(D), (I) => Ai(I, "col")), wn = (D, I) => Pe(D, "table", I), Yo = (D) => Dt(D, "tr"), Ln = (D) => wn(D).fold(ye([]), (I) => Ai(I, "colgroup")), Or = (D, I) => xt(D, (te) => {
    if (qt(te) === "colgroup") {
      const he = xt(dt(te), (Be) => {
        const Ot = Ge(Be, "span", 1);
        return Uo(Be, 1, Ot);
      });
      return Ar(te, he, "colgroup");
    } else {
      const he = xt(Ee(te), (Be) => {
        const Ot = Ge(Be, "rowspan", 1), rn = Ge(Be, "colspan", 1);
        return Uo(Be, Ot, rn);
      });
      return Ar(te, he, I(te));
    }
  }), Kt = (D) => wr(D).map((I) => {
    const te = qt(I);
    return ss(te) ? te : "tbody";
  }).getOr("tbody"), lr = (D) => {
    const I = Yo(D), he = [
      ...Ln(D),
      ...I
    ];
    return Or(he, Kt);
  }, yi = "data-snooker-locked-cols", Cr = (D) => gr(D, yi).bind((I) => ee.from(I.match(/\d+/g))).map((I) => qn(I, rt)), ga = (D, I) => D + "," + I, Ll = (D, I, te) => ee.from(D.access[ga(I, te)]), gs = (D, I, te) => {
    const he = xi(D, (Be) => te(I, Be.element));
    return he.length > 0 ? ee.some(he[0]) : ee.none();
  }, xi = (D, I) => {
    const te = je(D.all, (he) => he.cells);
    return At(te, I);
  }, Dr = (D) => {
    const I = {};
    let te = 0;
    return X(D.cells, (he) => {
      const Be = he.colspan;
      et(Be, (Ot) => {
        const rn = te + Ot;
        I[rn] = md(he.element, Be, rn);
      }), te += Be;
    }), I;
  }, Cc = (D) => {
    const I = {}, te = [], Be = zt(D).map((oc) => oc.element).bind(wn).bind(Cr).getOr({});
    let Ot = 0, rn = 0, $n = 0;
    const {
      pass: No,
      fail: ts
    } = So(D, (oc) => oc.section === "colgroup");
    X(ts, (oc) => {
      const Sd = [];
      X(oc.cells, (ml) => {
        let kd = 0;
        for (; I[ga($n, kd)] !== void 0; )
          kd++;
        const Uf = jt(Be, kd.toString()), Uu = qs(ml.element, ml.rowspan, ml.colspan, $n, kd, Uf);
        for (let Fp = 0; Fp < ml.colspan; Fp++)
          for (let Zc = 0; Zc < ml.rowspan; Zc++) {
            const xv = $n + Zc, eg = kd + Fp, wv = ga(xv, eg);
            I[wv] = Uu, rn = Math.max(rn, eg + 1);
          }
        Sd.push(Uu);
      }), Ot++, te.push(Ar(oc.element, Sd, oc.section)), $n++;
    });
    const { columns: nr, colgroups: Us } = vt(No).map((oc) => {
      const Sd = Dr(oc);
      return {
        colgroups: [tr(oc.element, ot(Sd))],
        columns: Sd
      };
    }).getOrThunk(() => ({
      colgroups: [],
      columns: {}
    }));
    return {
      grid: hs(Ot, rn),
      access: I,
      all: te,
      columns: nr,
      colgroups: Us
    };
  }, Ql = {
    fromTable: (D) => {
      const I = lr(D);
      return Cc(I);
    },
    generate: Cc,
    getAt: Ll,
    findItem: gs,
    filterItems: xi,
    justCells: (D) => je(D.all, (I) => I.cells),
    justColumns: (D) => ot(D.columns),
    hasColumns: (D) => lt(D.columns).length > 0,
    getColumnAt: (D, I) => ee.from(D.columns[I])
  };
  var $a = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const Ga = (D, I, te) => {
    const he = D.select("td,th", I);
    let Be;
    for (let Ot = 0; Ot < he.length; Ot++) {
      const rn = D.getStyle(he[Ot], te);
      if (H(Be) && (Be = rn), Be !== rn)
        return "";
    }
    return Be;
  }, wi = (D, I, te) => {
    $a.each("left center right".split(" "), (he) => {
      he !== te && D.formatter.remove("align" + he, {}, I);
    }), te && D.formatter.apply("align" + te, {}, I);
  }, If = (D, I, te) => {
    $a.each("top middle bottom".split(" "), (he) => {
      he !== te && D.formatter.remove("valign" + he, {}, I);
    }), te && D.formatter.apply("valign" + te, {}, I);
  }, fs = (D, I, te) => {
    D.dispatch("TableModified", {
      ...te,
      table: I
    });
  }, Ri = (D, I) => Wi(D).getOr(I), ci = (D, I, te) => Ri(bi(D, I), te), me = (D, I, te, he) => {
    const Be = ci(D, `padding-${te}`, 0), Ot = ci(D, `padding-${he}`, 0), rn = ci(D, `border-${te}-width`, 0), $n = ci(D, `border-${he}-width`, 0);
    return I - Be - Ot - rn - $n;
  }, Te = (D, I) => {
    const te = D.dom, he = te.getBoundingClientRect().width || te.offsetWidth;
    return I === "border-box" ? he : me(D, he, "left", "right");
  }, ft = (D) => Te(D, "content-box");
  var eo = tinymce.util.Tools.resolve("tinymce.Env");
  const es = "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol", Sr = et(5, (D) => {
    const I = `${D + 1}px`;
    return {
      title: I,
      value: I
    };
  }), Ha = xt([
    "Solid",
    "Dotted",
    "Dashed",
    "Double",
    "Groove",
    "Ridge",
    "Inset",
    "Outset",
    "None",
    "Hidden"
  ], (D) => ({
    title: D,
    value: D.toLowerCase()
  })), is = "100%", _a = (D) => {
    var I;
    const te = D.dom, he = (I = te.getParent(D.selection.getStart(), te.isBlock)) !== null && I !== void 0 ? I : D.getBody();
    return ft(hn.fromDom(he)) + "px";
  }, Rr = (D, I) => Yd(D) || !kc(D) ? I : Uh(D) ? {
    ...I,
    width: _a(D)
  } : {
    ...I,
    width: is
  }, ua = (D, I) => Yd(D) || kc(D) ? I : Uh(D) ? {
    ...I,
    width: _a(D)
  } : {
    ...I,
    width: is
  }, oa = (D) => (I) => I.options.get(D), Jr = (D) => {
    const I = D.options.register;
    I("table_border_widths", {
      processor: "object[]",
      default: Sr
    }), I("table_border_styles", {
      processor: "object[]",
      default: Ha
    }), I("table_cell_advtab", {
      processor: "boolean",
      default: !0
    }), I("table_row_advtab", {
      processor: "boolean",
      default: !0
    }), I("table_advtab", {
      processor: "boolean",
      default: !0
    }), I("table_appearance_options", {
      processor: "boolean",
      default: !0
    }), I("table_grid", {
      processor: "boolean",
      default: !eo.deviceType.isTouch()
    }), I("table_cell_class_list", {
      processor: "object[]",
      default: []
    }), I("table_row_class_list", {
      processor: "object[]",
      default: []
    }), I("table_class_list", {
      processor: "object[]",
      default: []
    }), I("table_toolbar", {
      processor: "string",
      default: es
    }), I("table_background_color_map", {
      processor: "object[]",
      default: []
    }), I("table_border_color_map", {
      processor: "object[]",
      default: []
    });
  }, ul = oa("table_sizing_mode"), Sc = oa("table_border_widths"), qa = oa("table_border_styles"), dl = oa("table_cell_advtab"), Bc = oa("table_row_advtab"), Lc = oa("table_advtab"), xp = oa("table_appearance_options"), hd = oa("table_grid"), kc = oa("table_style_by_css"), Zi = oa("table_cell_class_list"), gd = oa("table_row_class_list"), Ff = oa("table_class_list"), fu = oa("table_toolbar"), Vh = oa("table_background_color_map"), Bf = oa("table_border_color_map"), Uh = (D) => ul(D) === "fixed", Yd = (D) => ul(D) === "responsive", jh = (D) => {
    const I = D.options, te = I.get("table_default_styles");
    return I.isSet("table_default_styles") ? te : Rr(D, te);
  }, Xd = (D) => {
    const I = D.options, te = I.get("table_default_attributes");
    return I.isSet("table_default_attributes") ? te : ua(D, te);
  }, Hb = (D, I) => I.column >= D.startCol && I.column + I.colspan - 1 <= D.finishCol && I.row >= D.startRow && I.row + I.rowspan - 1 <= D.finishRow, Me = (D, I) => {
    let te = !0;
    const he = U(Hb, I);
    for (let Be = I.startRow; Be <= I.finishRow; Be++)
      for (let Ot = I.startCol; Ot <= I.finishCol; Ot++)
        te = te && Ql.getAt(D, Be, Ot).exists(he);
    return te ? ee.some(I) : ee.none();
  }, Am = (D, I) => sn(Math.min(D.row, I.row), Math.min(D.column, I.column), Math.max(D.row + D.rowspan - 1, I.row + I.rowspan - 1), Math.max(D.column + D.colspan - 1, I.column + I.colspan - 1)), wl = (D, I, te) => {
    const he = Ql.findItem(D, I, Ms), Be = Ql.findItem(D, te, Ms);
    return he.bind((Ot) => Be.map((rn) => Am(Ot, rn)));
  }, Bu = (D, I, te) => wl(D, I, te).bind((he) => Me(D, he)), Wh = (D, I, te) => {
    const he = cv(D);
    return Bu(he, I, te);
  }, cv = Ql.fromTable, Bs = (D, I) => {
    wr(D).each((he) => {
      he.dom.insertBefore(I.dom, D.dom);
    });
  }, Gi = (D, I) => {
    gn(D).fold(() => {
      wr(D).each((Be) => {
        Ka(Be, I);
      });
    }, (he) => {
      Bs(he, I);
    });
  }, $l = (D, I) => {
    as(D).fold(() => {
      Ka(D, I);
    }, (he) => {
      D.dom.insertBefore(I.dom, he.dom);
    });
  }, Ka = (D, I) => {
    D.dom.appendChild(I.dom);
  }, Qd = (D, I) => {
    Bs(D, I), Ka(I, D);
  }, $c = (D, I) => {
    X(I, (te, he) => {
      const Be = he === 0 ? D : I[he - 1];
      Gi(Be, te);
    });
  }, Ni = (D, I) => {
    X(I, (te) => {
      Ka(D, te);
    });
  }, Hc = (D) => {
    const I = D.dom;
    I.parentNode !== null && I.parentNode.removeChild(I);
  }, Zh = (D) => {
    const I = En(D);
    I.length > 0 && $c(D, I), Hc(D);
  }, Jl = ((D, I) => {
    const te = (Ot) => {
      if (!D(Ot))
        throw new Error("Can only get " + I + " value of a " + I + " node");
      return he(Ot).getOr("");
    }, he = (Ot) => D(Ot) ? ee.from(Ot.dom.nodeValue) : ee.none();
    return {
      get: te,
      getOption: he,
      set: (Ot, rn) => {
        if (!D(Ot))
          throw new Error("Can only set raw " + I + " value of a " + I + " node");
        Ot.dom.nodeValue = rn;
      }
    };
  })(na, "text"), zc = (D) => Jl.get(D), wp = (D, I) => Jl.set(D, I);
  var qi = [
    "body",
    "p",
    "div",
    "article",
    "aside",
    "figcaption",
    "figure",
    "footer",
    "header",
    "nav",
    "section",
    "ol",
    "ul",
    "li",
    "table",
    "thead",
    "tbody",
    "tfoot",
    "caption",
    "tr",
    "td",
    "th",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "blockquote",
    "pre",
    "address"
  ], Ya = () => {
    const D = (ts) => hn.fromDom(ts.dom.cloneNode(!1)), I = (ts) => Xn(ts).dom, te = (ts) => ia(ts) ? qt(ts) === "body" ? !0 : Rt(qi, qt(ts)) : !1, he = (ts) => ia(ts) ? Rt([
      "br",
      "img",
      "hr",
      "input"
    ], qt(ts)) : !1, Be = (ts) => ia(ts) && ca(ts, "contenteditable") === "false", Ot = (ts, nr) => ts.dom.compareDocumentPosition(nr.dom), rn = (ts, nr) => {
      const Us = ii(ts);
      Ba(nr, Us);
    }, $n = (ts) => {
      const nr = qt(ts);
      return Rt([
        "script",
        "noscript",
        "iframe",
        "noframes",
        "noembed",
        "title",
        "style",
        "textarea",
        "xmp"
      ], nr);
    }, No = (ts) => ia(ts) ? gr(ts, "lang") : ee.none();
    return {
      up: ye({
        selector: Xs,
        closest: Pe,
        predicate: Kn,
        all: Ke
      }),
      down: ye({
        selector: ko,
        predicate: Ti
      }),
      styles: ye({
        get: bi,
        getRaw: ie,
        set: du,
        remove: Oe
      }),
      attrs: ye({
        get: ca,
        set: Rs,
        remove: Qs,
        copyTo: rn
      }),
      insert: ye({
        before: Bs,
        after: Gi,
        afterAll: $c,
        append: Ka,
        appendAll: Ni,
        prepend: $l,
        wrap: Qd
      }),
      remove: ye({
        unwrap: Zh,
        remove: Hc
      }),
      create: ye({
        nu: hn.fromTag,
        clone: D,
        text: hn.fromText
      }),
      query: ye({
        comparePosition: Ot,
        prevSibling: ht,
        nextSibling: gn
      }),
      property: ye({
        children: En,
        name: qt,
        parent: wr,
        document: I,
        isText: na,
        isComment: ha,
        isElement: ia,
        isSpecial: $n,
        getLanguage: No,
        getText: zc,
        setText: wp,
        isBoundary: te,
        isEmptyTag: he,
        isNonEditable: Be
      }),
      eq: Ms,
      is: hr
    };
  };
  const vd = (D, I, te, he) => {
    const Be = te[0], Ot = te.slice(1);
    return he(D, I, Be, Ot);
  }, Lf = (D, I, te) => te.length > 0 ? vd(D, I, te, _c) : ee.none(), _c = (D, I, te, he) => {
    const Be = I(D, te);
    return Pt(he, (Ot, rn) => {
      const $n = I(D, rn);
      return Ci(D, Ot, $n);
    }, Be);
  }, Ci = (D, I, te) => I.bind((he) => te.filter(U(D.eq, he))), Cp = Lf, Sp = Ya(), kp = (D, I) => Cp(Sp, (te, he) => D(he), I), Om = (D) => Xs(D, "table"), ec = (D, I) => {
    const te = ko(D, I);
    return te.length > 0 ? ee.some(te) : ee.none();
  }, _p = (D, I, te) => Oo(D, I).bind((he) => Oo(D, te).bind((Be) => kp(Om, [
    he,
    Be
  ]).map((Ot) => ({
    first: he,
    last: Be,
    table: Ot
  })))), dv = (D, I) => ec(D, I), zb = (D, I, te) => _p(D, I, te).bind((he) => {
    const Be = (No) => Ms(D, No), Ot = "thead,tfoot,tbody,table", rn = Xs(he.first, Ot, Be), $n = Xs(he.last, Ot, Be);
    return rn.bind((No) => $n.bind((ts) => Ms(No, ts) ? Wh(he.table, he.first, he.last) : ee.none()));
  }), fv = (D) => xt(D, hn.fromDom), Ep = "data-mce-selected", Dm = "td[" + Ep + "],th[" + Ep + "]", Lu = "data-mce-first-selected", Gh = "td[" + Lu + "],th[" + Lu + "]", Nr = "data-mce-last-selected", sa = "td[" + Nr + "],th[" + Nr + "]", Cl = {
    selected: Ep,
    selectedSelector: Dm,
    firstSelected: Lu,
    firstSelectedSelector: Gh,
    lastSelected: Nr,
    lastSelectedSelector: sa
  }, qh = (D) => wn(D).bind((I) => dv(I, Cl.firstSelectedSelector)).fold(ye(D), (I) => I[0]), Kh = (D) => (I, te) => {
    const he = qt(I), Be = he === "col" || he === "colgroup" ? qh(I) : I;
    return Pe(Be, D, te);
  }, Na = Kh("th,td,caption"), to = Kh("th,td"), mu = (D) => fv(D.model.table.getSelectedCells()), mv = (D, I) => {
    const te = to(D), he = te.bind((Be) => wn(Be)).map((Be) => Yo(Be));
    return ka(te, he, (Be, Ot) => At(Ot, (rn) => Cn(fv(rn.dom.cells), ($n) => ca($n, I) === "1" || Ms($n, Be)))).getOr([]);
  }, za = [
    {
      text: "None",
      value: ""
    },
    {
      text: "Top",
      value: "top"
    },
    {
      text: "Middle",
      value: "middle"
    },
    {
      text: "Bottom",
      value: "bottom"
    }
  ], cr = (D) => ({ value: Ap(D) }), Jd = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, Yh = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, Tp = (D) => Jd.test(D) || Yh.test(D), Ap = (D) => Za(D, "#").toUpperCase(), Ho = (D) => Tp(D) ? ee.some({ value: Ap(D) }) : ee.none(), da = (D) => {
    const I = D.toString(16);
    return (I.length === 1 ? "0" + I : I).toUpperCase();
  }, $f = (D) => {
    const I = da(D.red) + da(D.green) + da(D.blue);
    return cr(I);
  }, Sl = /^\s*rgb\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*\)\s*$/i, fl = /^\s*rgba\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*((?:\d?\.\d+|\d+)%?)\s*\)\s*$/i, kl = (D, I, te, he) => ({
    red: D,
    green: I,
    blue: te,
    alpha: he
  }), Pa = (D, I, te, he) => {
    const Be = parseInt(D, 10), Ot = parseInt(I, 10), rn = parseInt(te, 10), $n = parseFloat(he);
    return kl(Be, Ot, rn, $n);
  }, Ki = (D) => {
    const I = Sl.exec(D);
    if (I !== null)
      return ee.some(Pa(I[1], I[2], I[3], "1"));
    const te = fl.exec(D);
    return te !== null ? ee.some(Pa(te[1], te[2], te[3], te[4])) : ee.none();
  }, tc = (D) => Ho(D).orThunk(() => Ki(D).map($f)).getOrThunk(() => {
    const I = document.createElement("canvas");
    I.height = 1, I.width = 1;
    const te = I.getContext("2d");
    te.clearRect(0, 0, I.width, I.height), te.fillStyle = "#FFFFFF", te.fillStyle = D, te.fillRect(0, 0, 1, 1);
    const he = te.getImageData(0, 0, 1, 1).data, Be = he[0], Ot = he[1], rn = he[2], $n = he[3];
    return $f(kl(Be, Ot, rn, $n));
  }), Rm = (D) => Ki(D).map($f).map((I) => "#" + I.value).getOr(D), Zr = (D) => {
    let I = D;
    return {
      get: () => I,
      set: (Be) => {
        I = Be;
      }
    };
  }, Xh = (D) => {
    const I = Zr(ee.none()), te = () => I.get().each(D);
    return {
      clear: () => {
        te(), I.set(ee.none());
      },
      isSet: () => I.get().isSome(),
      get: () => I.get(),
      set: ($n) => {
        te(), I.set(ee.some($n));
      }
    };
  }, wa = () => Xh((D) => D.unbind()), bd = (D, I, te) => (he) => {
    const Be = wa(), Ot = Bl(te), rn = () => {
      const $n = mu(D), No = (ts) => D.formatter.match(I, { value: te }, ts.dom, Ot);
      Ot ? (he.setActive(!Cn($n, No)), Be.set(D.formatter.formatChanged(I, (ts) => he.setActive(!ts), !0))) : (he.setActive(An($n, No)), Be.set(D.formatter.formatChanged(I, he.setActive, !1, { value: te })));
    };
    return D.initialized ? rn() : D.on("init", rn), Be.clear;
  }, Vc = (D) => jt(D, "menu"), vr = (D) => xt(D, (I) => {
    const te = I.text || I.title || "";
    return Vc(I) ? {
      text: te,
      items: vr(I.menu)
    } : {
      text: te,
      value: I.value
    };
  }), Uc = (D) => D.length ? ee.some(vr([
    {
      text: "Select...",
      value: "mce-no-match"
    },
    ...D
  ])) : ee.none(), Hf = (D, I, te, he) => xt(I, (Be) => {
    const Ot = Be.text || Be.title;
    return Vc(Be) ? {
      type: "nestedmenuitem",
      text: Ot,
      getSubmenuItems: () => Hf(D, Be.menu, te, he)
    } : {
      text: Ot,
      type: "togglemenuitem",
      onAction: () => he(Be.value),
      onSetup: bd(D, te, Be.value)
    };
  }), $u = (D, I) => (te) => {
    D.execCommand("mceTableApplyCellStyle", !1, { [I]: te });
  }, Pr = (D) => je(D, (I) => Vc(I) ? [{
    ...I,
    menu: Pr(I.menu)
  }] : vi(I.value) ? [I] : []), yd = (D, I, te, he) => (Be) => Be(Hf(D, I, te, he)), nc = (D, I, te) => {
    const he = xt(I, (Be) => ({
      text: Be.title,
      value: "#" + tc(Be.value).value,
      type: "choiceitem"
    }));
    return [{
      type: "fancymenuitem",
      fancytype: "colorswatch",
      initData: {
        colors: he.length > 0 ? he : void 0,
        allowCustomColors: !1
      },
      onAction: (Be) => {
        const Ot = Be.value === "remove" ? "" : Be.value;
        D.execCommand("mceTableApplyCellStyle", !1, { [te]: Ot });
      }
    }];
  }, ls = (D) => () => {
    const te = D.queryCommandValue("mceTableRowType") === "header" ? "body" : "header";
    D.execCommand("mceTableRowType", !1, { type: te });
  }, ef = (D) => () => {
    const te = D.queryCommandValue("mceTableColType") === "th" ? "td" : "th";
    D.execCommand("mceTableColType", !1, { type: te });
  }, Nm = (D) => Uc(Zi(D)).map((I) => ({
    name: "class",
    type: "listbox",
    label: "Class",
    items: I
  })), Op = [
    {
      name: "width",
      type: "input",
      label: "Width"
    },
    {
      name: "celltype",
      type: "listbox",
      label: "Cell type",
      items: [
        {
          text: "Cell",
          value: "td"
        },
        {
          text: "Header cell",
          value: "th"
        }
      ]
    },
    {
      name: "scope",
      type: "listbox",
      label: "Scope",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Row",
          value: "row"
        },
        {
          text: "Column",
          value: "col"
        },
        {
          text: "Row group",
          value: "rowgroup"
        },
        {
          text: "Column group",
          value: "colgroup"
        }
      ]
    },
    {
      name: "halign",
      type: "listbox",
      label: "Horizontal align",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Left",
          value: "left"
        },
        {
          text: "Center",
          value: "center"
        },
        {
          text: "Right",
          value: "right"
        }
      ]
    },
    {
      name: "valign",
      type: "listbox",
      label: "Vertical align",
      items: za
    }
  ], pv = (D) => Op.concat(Nm(D).toArray()), Dp = (D, I) => {
    const he = [
      {
        name: "borderstyle",
        type: "listbox",
        label: "Border style",
        items: [{
          text: "Select...",
          value: ""
        }].concat(vr(qa(D)))
      },
      {
        name: "bordercolor",
        type: "colorinput",
        label: "Border color"
      },
      {
        name: "backgroundcolor",
        type: "colorinput",
        label: "Background color"
      }
    ];
    return {
      title: "Advanced",
      name: "advanced",
      items: I === "cell" ? [{
        name: "borderwidth",
        type: "input",
        label: "Border width"
      }].concat(he) : he
    };
  }, R = { normal: (D, I) => {
    const te = D.dom;
    return {
      setAttrib: (rn, $n) => {
        te.setAttrib(I, rn, $n);
      },
      setStyle: (rn, $n) => {
        te.setStyle(I, rn, $n);
      },
      setFormat: (rn, $n) => {
        $n === "" ? D.formatter.remove(rn, { value: null }, I, !0) : D.formatter.apply(rn, { value: $n }, I);
      }
    };
  } }, V = la("th"), se = (D, I) => D && I ? "sectionCells" : D ? "section" : "cells", De = (D) => {
    const I = D.section === "thead", te = xc(Le(D.cells), "th");
    return D.section === "tfoot" ? { type: "footer" } : I || te ? {
      type: "header",
      subType: se(I, te)
    } : { type: "body" };
  }, Le = (D) => {
    const I = At(D, (te) => V(te.element));
    return I.length === 0 ? ee.some("td") : I.length === D.length ? ee.some("th") : ee.none();
  }, $t = (D) => {
    const I = xt(D, (Be) => De(Be).type), te = Rt(I, "header"), he = Rt(I, "footer");
    if (!te && !he)
      return ee.some("body");
    {
      const Be = Rt(I, "body");
      return te && !Be && !he ? ee.some("header") : !te && !Be && he ? ee.some("footer") : ee.none();
    }
  }, vo = (D) => {
    let I = !1, te;
    return (...he) => (I || (I = !0, te = D.apply(null, he)), te);
  }, Lo = (D, I) => oo(D.all, (te) => Vn(te.cells, (he) => Ms(I, he.element))), Mo = (D, I, te) => {
    const he = xt(I.selection, (Ot) => ge(Ot).bind((rn) => Lo(D, rn)).filter(te)), Be = Is(he);
    return Qr(Be.length > 0, Be);
  }, go = (D, I) => I.mergable, Hr = (D, I) => I.unmergable, fa = (D, I) => Mo(D, I, rt), _l = (D, I) => Lo(D, I).exists((te) => !te.isLocked), va = (D, I) => An(I, (te) => _l(D, te)), gv = (D, I) => go(D, I).filter((te) => va(D, te.cells)), q0 = (D, I) => Hr(D, I).filter((te) => va(D, te));
  ({ ...{ generate: (D) => {
    if (!A(D))
      throw new Error("cases must be an array");
    if (D.length === 0)
      throw new Error("there must be at least one case");
    const I = [], te = {};
    return X(D, (he, Be) => {
      const Ot = lt(he);
      if (Ot.length !== 1)
        throw new Error("one and only one name per case");
      const rn = Ot[0], $n = he[rn];
      if (te[rn] !== void 0)
        throw new Error("duplicate key detected:" + rn);
      if (rn === "cata")
        throw new Error("cannot have a case named cata (sorry)");
      if (!A($n))
        throw new Error("case arguments must be an array");
      I.push(rn), te[rn] = (...No) => {
        const ts = No.length;
        if (ts !== $n.length)
          throw new Error("Wrong number of arguments to case " + rn + ". Expected " + $n.length + " (" + $n + "), got " + ts);
        return {
          fold: (...Us) => {
            if (Us.length !== D.length)
              throw new Error("Wrong number of arguments to fold. Expected " + D.length + ", got " + Us.length);
            return Us[Be].apply(null, No);
          },
          match: (Us) => {
            const Ir = lt(Us);
            if (I.length !== Ir.length)
              throw new Error("Wrong number of arguments to match. Expected: " + I.join(",") + `
Actual: ` + Ir.join(","));
            if (!An(I, (Sd) => Rt(Ir, Sd)))
              throw new Error("Not all branches were specified when using match. Specified: " + Ir.join(", ") + `
Required: ` + I.join(", "));
            return Us[rn].apply(null, No);
          },
          log: (Us) => {
            console.log(Us, {
              constructors: I,
              constructor: rn,
              params: No
            });
          }
        };
      };
    }), te;
  } }.generate([
    { none: [] },
    { only: ["index"] },
    {
      left: [
        "index",
        "next"
      ]
    },
    {
      middle: [
        "prev",
        "index",
        "next"
      ]
    },
    {
      right: [
        "prev",
        "index"
      ]
    }
  ]) });
  const Ub = (D, I) => {
    const te = Ql.fromTable(D);
    return fa(te, I).bind((Be) => {
      const Ot = Be[Be.length - 1], rn = Be[0].row, $n = Ot.row + Ot.rowspan, No = te.all.slice(rn, $n);
      return $t(No);
    }).getOr("");
  }, Mi = (D) => Di(D, "rgb") ? Rm(D) : D, xo = (D) => {
    const I = hn.fromDom(D);
    return {
      borderwidth: ie(I, "border-width").getOr(""),
      borderstyle: ie(I, "border-style").getOr(""),
      bordercolor: ie(I, "border-color").map(Mi).getOr(""),
      backgroundcolor: ie(I, "background-color").map(Mi).getOr("")
    };
  }, jc = (D) => {
    const I = D[0], te = D.slice(1);
    return X(te, (he) => {
      X(lt(I), (Be) => {
        Vt(he, (Ot, rn) => {
          const $n = I[Be];
          $n !== "" && Be === rn && $n !== Ot && (I[Be] = Be === "class" ? "mce-no-match" : "");
        });
      });
    }), I;
  }, Rp = (D, I, te, he) => Vn(D, (Be) => !H(te.formatter.matchNode(he, I + Be))).getOr(""), Np = U(Rp, [
    "left",
    "center",
    "right"
  ], "align"), K0 = U(Rp, [
    "top",
    "middle",
    "bottom"
  ], "valign"), jb = (D, I) => {
    const te = jh(D), he = Xd(D), Be = () => ({
      borderstyle: fn(te, "border-style").getOr(""),
      bordercolor: Mi(fn(te, "border-color").getOr("")),
      backgroundcolor: Mi(fn(te, "background-color").getOr(""))
    }), Ot = {
      height: "",
      width: "100%",
      cellspacing: "",
      cellpadding: "",
      caption: !1,
      class: "",
      align: "",
      border: ""
    }, rn = () => {
      const nr = te["border-width"];
      return kc(D) && nr ? { border: nr } : fn(he, "border").fold(() => ({}), (Us) => ({ border: Us }));
    }, $n = I ? Be() : {}, No = () => {
      const nr = fn(te, "border-spacing").or(fn(he, "cellspacing")).fold(() => ({}), (Ir) => ({ cellspacing: Ir })), Us = fn(te, "border-padding").or(fn(he, "cellpadding")).fold(() => ({}), (Ir) => ({ cellpadding: Ir }));
      return {
        ...nr,
        ...Us
      };
    };
    return {
      ...Ot,
      ...te,
      ...he,
      ...$n,
      ...rn(),
      ...No()
    };
  }, pu = (D) => wn(hn.fromDom(D)).map((I) => {
    const te = { selection: fv(D.cells) };
    return Ub(I, te);
  }).getOr(""), xd = (D, I, te) => {
    const he = ($n, No) => {
      const ts = ie(hn.fromDom(No), "border-width");
      return kc(D) && ts.isSome() ? ts.getOr("") : $n.getAttrib(No, "border") || Ga(D.dom, No, "border-width") || Ga(D.dom, No, "border") || "";
    }, Be = D.dom, Ot = kc(D) ? Be.getStyle(I, "border-spacing") || Be.getAttrib(I, "cellspacing") : Be.getAttrib(I, "cellspacing") || Be.getStyle(I, "border-spacing"), rn = kc(D) ? Ga(Be, I, "padding") || Be.getAttrib(I, "cellpadding") : Be.getAttrib(I, "cellpadding") || Ga(Be, I, "padding");
    return {
      width: Be.getStyle(I, "width") || Be.getAttrib(I, "width"),
      height: Be.getStyle(I, "height") || Be.getAttrib(I, "height"),
      cellspacing: Ot ?? "",
      cellpadding: rn ?? "",
      border: he(Be, I),
      caption: !!Be.select("caption", I)[0],
      class: Be.getAttrib(I, "class", ""),
      align: Np(D, I),
      ...te ? xo(I) : {}
    };
  }, zf = (D, I, te) => {
    const he = D.dom;
    return {
      height: he.getStyle(I, "height") || he.getAttrib(I, "height"),
      class: he.getAttrib(I, "class", ""),
      type: pu(I),
      align: Np(D, I),
      ...te ? xo(I) : {}
    };
  }, Tn = (D, I, te, he) => {
    const Be = D.dom, Ot = he.getOr(I);
    return {
      width: (($n, No) => Be.getStyle($n, No) || Be.getAttrib($n, No))(Ot, "width"),
      scope: Be.getAttrib(I, "scope"),
      celltype: kn(I),
      class: Be.getAttrib(I, "class", ""),
      halign: Np(D, I),
      valign: K0(D, I),
      ...te ? xo(I) : {}
    };
  }, Ec = (D, I) => {
    const te = Ql.fromTable(D), he = Ql.justCells(te), Be = At(he, (Ot) => Cn(I, (rn) => Ms(Ot.element, rn)));
    return xt(Be, (Ot) => ({
      element: Ot.element.dom,
      column: Ql.getColumnAt(te, Ot.column).map((rn) => rn.element.dom)
    }));
  }, Wb = (D, I, te, he) => {
    he("scope") && D.setAttrib("scope", te.scope), he("class") && te.class !== "mce-no-match" && D.setAttrib("class", te.class), he("width") && I.setStyle("width", Qn(te.width));
  }, Pm = (D, I, te) => {
    te("backgroundcolor") && D.setFormat("tablecellbackgroundcolor", I.backgroundcolor), te("bordercolor") && D.setFormat("tablecellbordercolor", I.bordercolor), te("borderstyle") && D.setFormat("tablecellborderstyle", I.borderstyle), te("borderwidth") && D.setFormat("tablecellborderwidth", Qn(I.borderwidth));
  }, hu = (D, I, te, he) => {
    const Be = I.length === 1;
    X(I, (Ot) => {
      const rn = Ot.element, $n = Be ? rt : he, No = R.normal(D, rn), ts = Ot.column.map((nr) => R.normal(D, nr)).getOr(No);
      Wb(No, ts, te, $n), dl(D) && Pm(No, te, $n), he("halign") && wi(D, rn, te.halign), he("valign") && If(D, rn, te.valign);
    });
  }, Qh = (D, I) => {
    D.execCommand("mceTableCellType", !1, {
      type: I.celltype,
      no_events: !0
    });
  }, Vf = (D, I, te, he) => {
    const Be = Rn(he, (Ot, rn) => te[rn] !== Ot);
    B(Be) > 0 && I.length >= 1 && wn(I[0]).each((Ot) => {
      const rn = Ec(Ot, I), $n = B(Rn(Be, (ts, nr) => nr !== "scope" && nr !== "celltype")) > 0, No = ze(Be, "celltype");
      ($n || ze(Be, "scope")) && hu(D, rn, he, U(ze, Be)), No && Qh(D, he), fs(D, Ot.dom, {
        structure: No,
        style: $n
      });
    });
  }, Mm = (D, I, te, he) => {
    const Be = he.getData();
    he.close(), D.undoManager.transact(() => {
      Vf(D, I, te, Be), D.focus();
    });
  }, Jh = (D, I) => {
    const te = wn(I[0]).map((he) => xt(Ec(he, I), (Be) => Tn(D, Be.element, dl(D), Be.column)));
    return jc(te.getOrDie());
  }, Hu = (D) => {
    const I = mu(D);
    if (I.length === 0)
      return;
    const te = Jh(D, I), he = {
      type: "tabpanel",
      tabs: [
        {
          title: "General",
          name: "general",
          items: pv(D)
        },
        Dp(D, "cell")
      ]
    }, Be = {
      type: "panel",
      items: [{
        type: "grid",
        columns: 2,
        items: pv(D)
      }]
    };
    D.windowManager.open({
      title: "Cell Properties",
      size: "normal",
      body: dl(D) ? he : Be,
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: te,
      onSubmit: U(Mm, D, I, te)
    });
  }, Y0 = (D) => Uc(gd(D)).map((I) => ({
    name: "class",
    type: "listbox",
    label: "Class",
    items: I
  })), ra = [
    {
      type: "listbox",
      name: "type",
      label: "Row type",
      items: [
        {
          text: "Header",
          value: "header"
        },
        {
          text: "Body",
          value: "body"
        },
        {
          text: "Footer",
          value: "footer"
        }
      ]
    },
    {
      type: "listbox",
      name: "align",
      label: "Alignment",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Left",
          value: "left"
        },
        {
          text: "Center",
          value: "center"
        },
        {
          text: "Right",
          value: "right"
        }
      ]
    },
    {
      label: "Height",
      name: "height",
      type: "input"
    }
  ], Gt = (D) => ra.concat(Y0(D).toArray()), El = (D, I, te) => {
    te("class") && I.class !== "mce-no-match" && D.setAttrib("class", I.class), te("height") && D.setStyle("height", Qn(I.height));
  }, zu = (D, I, te) => {
    te("backgroundcolor") && D.setStyle("background-color", I.backgroundcolor), te("bordercolor") && D.setStyle("border-color", I.bordercolor), te("borderstyle") && D.setStyle("border-style", I.borderstyle);
  }, ui = (D, I, te, he) => {
    const Ot = I.length === 1 ? rt : he;
    X(I, (rn) => {
      const $n = Ai(hn.fromDom(rn), "td,th"), No = R.normal(D, rn);
      El(No, te, Ot), Bc(D) && zu(No, te, Ot), he("height") && X($n, (ts) => {
        D.dom.setStyle(ts.dom, "height", null);
      }), he("align") && wi(D, rn, te.align);
    });
  }, Pp = (D, I) => {
    D.execCommand("mceTableRowType", !1, {
      type: I.type,
      no_events: !0
    });
  }, Qa = (D, I, te, he) => {
    const Be = Rn(he, (Ot, rn) => te[rn] !== Ot);
    if (B(Be) > 0) {
      const Ot = ze(Be, "type"), rn = Ot ? B(Be) > 1 : !0;
      rn && ui(D, I, he, U(ze, Be)), Ot && Pp(D, he), wn(hn.fromDom(I[0])).each(($n) => fs(D, $n.dom, {
        structure: Ot,
        style: rn
      }));
    }
  }, Vs = (D, I, te, he) => {
    const Be = he.getData();
    he.close(), D.undoManager.transact(() => {
      Qa(D, I, te, Be), D.focus();
    });
  }, bv = (D) => {
    const I = mv(co(D), Cl.selected);
    if (I.length === 0)
      return;
    const te = xt(I, (rn) => zf(D, rn.dom, Bc(D))), he = jc(te), Be = {
      type: "tabpanel",
      tabs: [
        {
          title: "General",
          name: "general",
          items: Gt(D)
        },
        Dp(D, "row")
      ]
    }, Ot = {
      type: "panel",
      items: [{
        type: "grid",
        columns: 2,
        items: Gt(D)
      }]
    };
    D.windowManager.open({
      title: "Row Properties",
      size: "normal",
      body: Bc(D) ? Be : Ot,
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: he,
      onSubmit: U(Vs, D, xt(I, (rn) => rn.dom), he)
    });
  }, Mt = (D, I, te) => {
    const he = te ? [
      {
        type: "input",
        name: "cols",
        label: "Cols",
        inputMode: "numeric"
      },
      {
        type: "input",
        name: "rows",
        label: "Rows",
        inputMode: "numeric"
      }
    ] : [], Be = [
      {
        type: "input",
        name: "width",
        label: "Width"
      },
      {
        type: "input",
        name: "height",
        label: "Height"
      }
    ], Ot = xp(D) ? [
      {
        type: "input",
        name: "cellspacing",
        label: "Cell spacing",
        inputMode: "numeric"
      },
      {
        type: "input",
        name: "cellpadding",
        label: "Cell padding",
        inputMode: "numeric"
      },
      {
        type: "input",
        name: "border",
        label: "Border width"
      },
      {
        type: "label",
        label: "Caption",
        items: [{
          type: "checkbox",
          name: "caption",
          label: "Show caption"
        }]
      }
    ] : [], rn = [{
      type: "listbox",
      name: "align",
      label: "Alignment",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Left",
          value: "left"
        },
        {
          text: "Center",
          value: "center"
        },
        {
          text: "Right",
          value: "right"
        }
      ]
    }], $n = I.length > 0 ? [{
      name: "class",
      type: "listbox",
      label: "Class",
      items: I
    }] : [];
    return he.concat(Be).concat(Ot).concat(rn).concat($n);
  }, Ls = (D, I, te, he) => {
    if (I.tagName === "TD" || I.tagName === "TH")
      k(te) && K(he) ? D.setStyle(I, te, he) : D.setStyles(I, te);
    else if (I.children)
      for (let Be = 0; Be < I.children.length; Be++)
        Ls(D, I.children[Be], te, he);
  }, yv = (D, I, te, he) => {
    const Be = D.dom, Ot = {}, rn = {}, $n = kc(D), No = Lc(D), ts = parseFloat(te.border) === 0;
    if (!H(te.class) && te.class !== "mce-no-match" && (Ot.class = te.class), rn.height = Qn(te.height), $n ? rn.width = Qn(te.width) : Be.getAttrib(I, "width") && (Ot.width = Gn(te.width)), $n ? (ts ? (Ot.border = 0, rn["border-width"] = "") : (rn["border-width"] = Qn(te.border), Ot.border = 1), rn["border-spacing"] = Qn(te.cellspacing)) : (Ot.border = ts ? 0 : te.border, Ot.cellpadding = te.cellpadding, Ot.cellspacing = te.cellspacing), $n && I.children) {
      const nr = {};
      if (ts ? nr["border-width"] = "" : he.border && (nr["border-width"] = Qn(te.border)), he.cellpadding && (nr.padding = Qn(te.cellpadding)), No && he.bordercolor && (nr["border-color"] = te.bordercolor), !Tt(nr))
        for (let Us = 0; Us < I.children.length; Us++)
          Ls(Be, I.children[Us], nr);
    }
    if (No) {
      const nr = te;
      rn["background-color"] = nr.backgroundcolor, rn["border-color"] = nr.bordercolor, rn["border-style"] = nr.borderstyle;
    }
    Be.setStyles(I, {
      ...jh(D),
      ...rn
    }), Be.setAttribs(I, {
      ...Xd(D),
      ...Ot
    });
  }, Va = (D, I, te, he) => {
    const Be = D.dom, Ot = he.getData(), rn = Rn(Ot, ($n, No) => te[No] !== $n);
    he.close(), D.undoManager.transact(() => {
      if (!I) {
        const $n = La(Ot.cols).getOr(1), No = La(Ot.rows).getOr(1);
        D.execCommand("mceInsertTable", !1, {
          rows: No,
          columns: $n
        }), I = to(co(D), Zn(D)).bind((ts) => wn(ts, Zn(D))).map((ts) => ts.dom).getOrDie();
      }
      if (B(rn) > 0) {
        const $n = {
          border: ze(rn, "border"),
          bordercolor: ze(rn, "bordercolor"),
          cellpadding: ze(rn, "cellpadding")
        };
        yv(D, I, Ot, $n);
        const No = Be.select("caption", I)[0];
        (No && !Ot.caption || !No && Ot.caption) && D.execCommand("mceTableToggleCaption"), wi(D, I, Ot.align);
      }
      if (D.focus(), D.addVisual(), B(rn) > 0) {
        const $n = ze(rn, "caption"), No = $n ? B(rn) > 1 : !0;
        fs(D, I, {
          structure: $n,
          style: No
        });
      }
    });
  }, Yi = (D, I) => {
    const te = D.dom;
    let he, Be = jb(D, Lc(D));
    I ? (Be.cols = "1", Be.rows = "1", Lc(D) && (Be.borderstyle = "", Be.bordercolor = "", Be.backgroundcolor = "")) : (he = te.getParent(D.selection.getStart(), "table", D.getBody()), he ? Be = xd(D, he, Lc(D)) : Lc(D) && (Be.borderstyle = "", Be.bordercolor = "", Be.backgroundcolor = ""));
    const Ot = Uc(Ff(D));
    Ot.isSome() && Be.class && (Be.class = Be.class.replace(/\s*mce\-item\-table\s*/g, ""));
    const rn = {
      type: "grid",
      columns: 2,
      items: Mt(D, Ot.getOr([]), I)
    }, $n = () => ({
      type: "panel",
      items: [rn]
    }), No = () => ({
      type: "tabpanel",
      tabs: [
        {
          title: "General",
          name: "general",
          items: [rn]
        },
        Dp(D, "table")
      ]
    }), ts = Lc(D) ? No() : $n();
    D.windowManager.open({
      title: "Table Properties",
      size: "normal",
      body: ts,
      onSubmit: U(Va, D, he, Be),
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: Be
    });
  }, Y2 = (D) => {
    const I = (te) => {
      Gs(co(D)) && te();
    };
    Vt({
      mceTableProps: U(Yi, D, !1),
      mceTableRowProps: U(bv, D),
      mceTableCellProps: U(Hu, D),
      mceInsertTableDialog: U(Yi, D, !0)
    }, (te, he) => D.addCommand(he, () => I(te)));
  }, Tc = (D, I) => $e(D, I).isSome(), X2 = re, tf = (D) => {
    const I = (he, Be) => gr(he, Be).exists((Ot) => parseInt(Ot, 10) > 1), te = (he) => I(he, "rowspan") || I(he, "colspan");
    return D.length > 0 && An(D, te) ? ee.some(D) : ee.none();
  }, X0 = (D, I, te) => I.length <= 1 ? ee.none() : zb(D, te.firstSelectedSelector, te.lastSelectedSelector).map((he) => ({
    bounds: he,
    cells: I
  })), Ac = (D) => ({
    element: D,
    mergable: ee.none(),
    unmergable: ee.none(),
    selection: [D]
  }), $s = (D, I, te) => ({
    element: te,
    mergable: X0(I, D, Cl),
    unmergable: tf(D),
    selection: X2(D)
  }), wd = (D) => {
    const I = Zr(ee.none()), te = Zr([]);
    let he = ee.none();
    const Be = la("caption"), Ot = (vs) => he.forall((Gr) => !Gr[vs]), rn = () => Na(co(D), Zn(D)), $n = () => Na(Jo(D), Zn(D)), No = () => rn().bind((vs) => li(ka(wn(vs), $n().bind(wn), (Gr, Ja) => Ms(Gr, Ja) ? Be(vs) ? ee.some(Ac(vs)) : ee.some($s(mu(D), Gr, vs)) : ee.none()))), ts = (vs) => wn(vs.element).map((Ja) => {
      const Oc = Ql.fromTable(Ja), sc = fa(Oc, vs).getOr([]), Sv = Hn(sc, (_d, Fm) => (Fm.isLocked && (_d.onAny = !0, Fm.column === 0 ? _d.onFirst = !0 : Fm.column + Fm.colspan >= Oc.grid.columns && (_d.onLast = !0)), _d), {
        onAny: !1,
        onFirst: !1,
        onLast: !1
      });
      return {
        mergeable: gv(Oc, vs).isSome(),
        unmergeable: q0(Oc, vs).isSome(),
        locked: Sv
      };
    }), nr = () => {
      I.set(vo(No)()), he = I.get().bind(ts), X(te.get(), ve);
    }, Us = (vs) => (vs(), te.set(te.get().concat([vs])), () => {
      te.set(At(te.get(), (Gr) => Gr !== vs));
    }), Ir = (vs, Gr) => Us(() => I.get().fold(() => {
      vs.setEnabled(!1);
    }, (Ja) => {
      vs.setEnabled(!Gr(Ja) && D.selection.isEditable());
    })), oc = (vs, Gr, Ja) => Us(() => I.get().fold(() => {
      vs.setEnabled(!1), vs.setActive(!1);
    }, (Oc) => {
      vs.setEnabled(!Gr(Oc) && D.selection.isEditable()), vs.setActive(Ja(Oc));
    })), Sd = (vs) => he.exists((Gr) => Gr.locked[vs]), ml = (vs) => Ir(vs, (Gr) => !1), kd = (vs) => Ir(vs, (Gr) => Be(Gr.element)), Uf = (vs) => (Gr) => Ir(Gr, (Ja) => Be(Ja.element) || Sd(vs)), Uu = (vs) => (Gr) => Ir(Gr, (Ja) => Be(Ja.element) || vs().isNone()), Fp = (vs, Gr) => (Ja) => Ir(Ja, (Oc) => Be(Oc.element) || vs().isNone() || Sd(Gr)), Zc = (vs) => Ir(vs, (Gr) => Ot("mergeable")), xv = (vs) => Ir(vs, (Gr) => Ot("unmergeable")), eg = (vs) => oc(vs, Ze, (Gr) => wn(Gr.element, Zn(D)).exists((Oc) => Tc(Oc, "caption"))), wv = (vs, Gr) => (Ja) => oc(Ja, (Oc) => Be(Oc.element), () => D.queryCommandValue(vs) === Gr), Cv = wv("mceTableRowType", "header"), di = wv("mceTableColType", "th");
    return D.on("NodeChange ExecCommand TableSelectorChange", nr), {
      onSetupTable: ml,
      onSetupCellOrRow: kd,
      onSetupColumn: Uf,
      onSetupPasteable: Uu,
      onSetupPasteableColumn: Fp,
      onSetupMergeable: Zc,
      onSetupUnmergeable: xv,
      resetTargets: nr,
      onSetupTableWithCaption: eg,
      onSetupTableRowHeaders: Cv,
      onSetupTableColumnHeaders: di,
      targets: I.get
    };
  };
  var Im = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
  const Ua = "x-tinymce/dom-table-", Zb = Ua + "rows", Cd = Ua + "columns", Vu = (D) => {
    var I;
    const te = (I = Im.read()) !== null && I !== void 0 ? I : [];
    return oo(te, (he) => ee.from(he.getType(D)));
  }, kr = () => Vu(Zb), Mp = () => Vu(Cd), Xe = (D) => (I) => {
    const te = () => {
      I.setEnabled(D.selection.isEditable());
    };
    return D.on("NodeChange", te), te(), () => {
      D.off("NodeChange", te);
    };
  }, Wc = (D, I) => {
    D.ui.registry.addMenuButton("table", {
      tooltip: "Table",
      icon: "table",
      onSetup: Xe(D),
      fetch: ($n) => $n("inserttable | cell row column | advtablesort | tableprops deletetable")
    });
    const te = ($n) => () => D.execCommand($n), he = ($n, No) => {
      D.queryCommandSupported(No.command) && D.ui.registry.addButton($n, {
        ...No,
        onAction: J(No.onAction) ? No.onAction : te(No.command)
      });
    }, Be = ($n, No) => {
      D.queryCommandSupported(No.command) && D.ui.registry.addToggleButton($n, {
        ...No,
        onAction: J(No.onAction) ? No.onAction : te(No.command)
      });
    };
    he("tableprops", {
      tooltip: "Table properties",
      command: "mceTableProps",
      icon: "table",
      onSetup: I.onSetupTable
    }), he("tabledelete", {
      tooltip: "Delete table",
      command: "mceTableDelete",
      icon: "table-delete-table",
      onSetup: I.onSetupTable
    }), he("tablecellprops", {
      tooltip: "Cell properties",
      command: "mceTableCellProps",
      icon: "table-cell-properties",
      onSetup: I.onSetupCellOrRow
    }), he("tablemergecells", {
      tooltip: "Merge cells",
      command: "mceTableMergeCells",
      icon: "table-merge-cells",
      onSetup: I.onSetupMergeable
    }), he("tablesplitcells", {
      tooltip: "Split cell",
      command: "mceTableSplitCells",
      icon: "table-split-cells",
      onSetup: I.onSetupUnmergeable
    }), he("tableinsertrowbefore", {
      tooltip: "Insert row before",
      command: "mceTableInsertRowBefore",
      icon: "table-insert-row-above",
      onSetup: I.onSetupCellOrRow
    }), he("tableinsertrowafter", {
      tooltip: "Insert row after",
      command: "mceTableInsertRowAfter",
      icon: "table-insert-row-after",
      onSetup: I.onSetupCellOrRow
    }), he("tabledeleterow", {
      tooltip: "Delete row",
      command: "mceTableDeleteRow",
      icon: "table-delete-row",
      onSetup: I.onSetupCellOrRow
    }), he("tablerowprops", {
      tooltip: "Row properties",
      command: "mceTableRowProps",
      icon: "table-row-properties",
      onSetup: I.onSetupCellOrRow
    }), he("tableinsertcolbefore", {
      tooltip: "Insert column before",
      command: "mceTableInsertColBefore",
      icon: "table-insert-column-before",
      onSetup: I.onSetupColumn("onFirst")
    }), he("tableinsertcolafter", {
      tooltip: "Insert column after",
      command: "mceTableInsertColAfter",
      icon: "table-insert-column-after",
      onSetup: I.onSetupColumn("onLast")
    }), he("tabledeletecol", {
      tooltip: "Delete column",
      command: "mceTableDeleteCol",
      icon: "table-delete-column",
      onSetup: I.onSetupColumn("onAny")
    }), he("tablecutrow", {
      tooltip: "Cut row",
      command: "mceTableCutRow",
      icon: "cut-row",
      onSetup: I.onSetupCellOrRow
    }), he("tablecopyrow", {
      tooltip: "Copy row",
      command: "mceTableCopyRow",
      icon: "duplicate-row",
      onSetup: I.onSetupCellOrRow
    }), he("tablepasterowbefore", {
      tooltip: "Paste row before",
      command: "mceTablePasteRowBefore",
      icon: "paste-row-before",
      onSetup: I.onSetupPasteable(kr)
    }), he("tablepasterowafter", {
      tooltip: "Paste row after",
      command: "mceTablePasteRowAfter",
      icon: "paste-row-after",
      onSetup: I.onSetupPasteable(kr)
    }), he("tablecutcol", {
      tooltip: "Cut column",
      command: "mceTableCutCol",
      icon: "cut-column",
      onSetup: I.onSetupColumn("onAny")
    }), he("tablecopycol", {
      tooltip: "Copy column",
      command: "mceTableCopyCol",
      icon: "duplicate-column",
      onSetup: I.onSetupColumn("onAny")
    }), he("tablepastecolbefore", {
      tooltip: "Paste column before",
      command: "mceTablePasteColBefore",
      icon: "paste-column-before",
      onSetup: I.onSetupPasteableColumn(Mp, "onFirst")
    }), he("tablepastecolafter", {
      tooltip: "Paste column after",
      command: "mceTablePasteColAfter",
      icon: "paste-column-after",
      onSetup: I.onSetupPasteableColumn(Mp, "onLast")
    }), he("tableinsertdialog", {
      tooltip: "Insert table",
      command: "mceInsertTableDialog",
      icon: "table",
      onSetup: Xe(D)
    });
    const Ot = Pr(Ff(D));
    Ot.length !== 0 && D.queryCommandSupported("mceTableToggleClass") && D.ui.registry.addMenuButton("tableclass", {
      icon: "table-classes",
      tooltip: "Table styles",
      fetch: yd(D, Ot, "tableclass", ($n) => D.execCommand("mceTableToggleClass", !1, $n)),
      onSetup: I.onSetupTable
    });
    const rn = Pr(Zi(D));
    rn.length !== 0 && D.queryCommandSupported("mceTableCellToggleClass") && D.ui.registry.addMenuButton("tablecellclass", {
      icon: "table-cell-classes",
      tooltip: "Cell styles",
      fetch: yd(D, rn, "tablecellclass", ($n) => D.execCommand("mceTableCellToggleClass", !1, $n)),
      onSetup: I.onSetupCellOrRow
    }), D.queryCommandSupported("mceTableApplyCellStyle") && (D.ui.registry.addMenuButton("tablecellvalign", {
      icon: "vertical-align",
      tooltip: "Vertical align",
      fetch: yd(D, za, "tablecellverticalalign", $u(D, "vertical-align")),
      onSetup: I.onSetupCellOrRow
    }), D.ui.registry.addMenuButton("tablecellborderwidth", {
      icon: "border-width",
      tooltip: "Border width",
      fetch: yd(D, Sc(D), "tablecellborderwidth", $u(D, "border-width")),
      onSetup: I.onSetupCellOrRow
    }), D.ui.registry.addMenuButton("tablecellborderstyle", {
      icon: "border-style",
      tooltip: "Border style",
      fetch: yd(D, qa(D), "tablecellborderstyle", $u(D, "border-style")),
      onSetup: I.onSetupCellOrRow
    }), D.ui.registry.addMenuButton("tablecellbackgroundcolor", {
      icon: "cell-background-color",
      tooltip: "Background color",
      fetch: ($n) => $n(nc(D, Vh(D), "background-color")),
      onSetup: I.onSetupCellOrRow
    }), D.ui.registry.addMenuButton("tablecellbordercolor", {
      icon: "cell-border-color",
      tooltip: "Border color",
      fetch: ($n) => $n(nc(D, Bf(D), "border-color")),
      onSetup: I.onSetupCellOrRow
    })), Be("tablecaption", {
      tooltip: "Table caption",
      icon: "table-caption",
      command: "mceTableToggleCaption",
      onSetup: I.onSetupTableWithCaption
    }), Be("tablerowheader", {
      tooltip: "Row header",
      icon: "table-top-header",
      command: "mceTableRowType",
      onAction: ls(D),
      onSetup: I.onSetupTableRowHeaders
    }), Be("tablecolheader", {
      tooltip: "Column header",
      icon: "table-left-header",
      command: "mceTableColType",
      onAction: ef(D),
      onSetup: I.onSetupTableColumnHeaders
    });
  }, Ip = (D) => {
    const I = (he) => D.dom.is(he, "table") && D.getBody().contains(he) && D.dom.isEditable(he.parentNode), te = fu(D);
    te.length > 0 && D.ui.registry.addContextToolbar("table", {
      predicate: I,
      items: te,
      scope: "node",
      position: "node"
    });
  }, Ii = (D) => (I) => {
    const te = () => {
      I.setEnabled(D.selection.isEditable());
    };
    return D.on("NodeChange", te), te(), () => {
      D.off("NodeChange", te);
    };
  }, gu = (D, I) => {
    const te = (Us) => () => D.execCommand(Us), he = (Us, Ir) => D.queryCommandSupported(Ir.command) ? (D.ui.registry.addMenuItem(Us, {
      ...Ir,
      onAction: J(Ir.onAction) ? Ir.onAction : te(Ir.command)
    }), !0) : !1, Be = (Us, Ir) => {
      D.queryCommandSupported(Ir.command) && D.ui.registry.addToggleMenuItem(Us, {
        ...Ir,
        onAction: J(Ir.onAction) ? Ir.onAction : te(Ir.command)
      });
    }, Ot = (Us) => {
      D.execCommand("mceInsertTable", !1, {
        rows: Us.numRows,
        columns: Us.numColumns
      });
    }, rn = [
      he("tableinsertrowbefore", {
        text: "Insert row before",
        icon: "table-insert-row-above",
        command: "mceTableInsertRowBefore",
        onSetup: I.onSetupCellOrRow
      }),
      he("tableinsertrowafter", {
        text: "Insert row after",
        icon: "table-insert-row-after",
        command: "mceTableInsertRowAfter",
        onSetup: I.onSetupCellOrRow
      }),
      he("tabledeleterow", {
        text: "Delete row",
        icon: "table-delete-row",
        command: "mceTableDeleteRow",
        onSetup: I.onSetupCellOrRow
      }),
      he("tablerowprops", {
        text: "Row properties",
        icon: "table-row-properties",
        command: "mceTableRowProps",
        onSetup: I.onSetupCellOrRow
      }),
      he("tablecutrow", {
        text: "Cut row",
        icon: "cut-row",
        command: "mceTableCutRow",
        onSetup: I.onSetupCellOrRow
      }),
      he("tablecopyrow", {
        text: "Copy row",
        icon: "duplicate-row",
        command: "mceTableCopyRow",
        onSetup: I.onSetupCellOrRow
      }),
      he("tablepasterowbefore", {
        text: "Paste row before",
        icon: "paste-row-before",
        command: "mceTablePasteRowBefore",
        onSetup: I.onSetupPasteable(kr)
      }),
      he("tablepasterowafter", {
        text: "Paste row after",
        icon: "paste-row-after",
        command: "mceTablePasteRowAfter",
        onSetup: I.onSetupPasteable(kr)
      })
    ], $n = [
      he("tableinsertcolumnbefore", {
        text: "Insert column before",
        icon: "table-insert-column-before",
        command: "mceTableInsertColBefore",
        onSetup: I.onSetupColumn("onFirst")
      }),
      he("tableinsertcolumnafter", {
        text: "Insert column after",
        icon: "table-insert-column-after",
        command: "mceTableInsertColAfter",
        onSetup: I.onSetupColumn("onLast")
      }),
      he("tabledeletecolumn", {
        text: "Delete column",
        icon: "table-delete-column",
        command: "mceTableDeleteCol",
        onSetup: I.onSetupColumn("onAny")
      }),
      he("tablecutcolumn", {
        text: "Cut column",
        icon: "cut-column",
        command: "mceTableCutCol",
        onSetup: I.onSetupColumn("onAny")
      }),
      he("tablecopycolumn", {
        text: "Copy column",
        icon: "duplicate-column",
        command: "mceTableCopyCol",
        onSetup: I.onSetupColumn("onAny")
      }),
      he("tablepastecolumnbefore", {
        text: "Paste column before",
        icon: "paste-column-before",
        command: "mceTablePasteColBefore",
        onSetup: I.onSetupPasteableColumn(Mp, "onFirst")
      }),
      he("tablepastecolumnafter", {
        text: "Paste column after",
        icon: "paste-column-after",
        command: "mceTablePasteColAfter",
        onSetup: I.onSetupPasteableColumn(Mp, "onLast")
      })
    ], No = [
      he("tablecellprops", {
        text: "Cell properties",
        icon: "table-cell-properties",
        command: "mceTableCellProps",
        onSetup: I.onSetupCellOrRow
      }),
      he("tablemergecells", {
        text: "Merge cells",
        icon: "table-merge-cells",
        command: "mceTableMergeCells",
        onSetup: I.onSetupMergeable
      }),
      he("tablesplitcells", {
        text: "Split cell",
        icon: "table-split-cells",
        command: "mceTableSplitCells",
        onSetup: I.onSetupUnmergeable
      })
    ];
    hd(D) ? D.ui.registry.addNestedMenuItem("inserttable", {
      text: "Table",
      icon: "table",
      getSubmenuItems: () => [{
        type: "fancymenuitem",
        fancytype: "inserttable",
        onAction: Ot
      }],
      onSetup: Ii(D)
    }) : D.ui.registry.addMenuItem("inserttable", {
      text: "Table",
      icon: "table",
      onAction: te("mceInsertTableDialog"),
      onSetup: Ii(D)
    }), D.ui.registry.addMenuItem("inserttabledialog", {
      text: "Insert table",
      icon: "table",
      onAction: te("mceInsertTableDialog"),
      onSetup: Ii(D)
    }), he("tableprops", {
      text: "Table properties",
      onSetup: I.onSetupTable,
      command: "mceTableProps"
    }), he("deletetable", {
      text: "Delete table",
      icon: "table-delete-table",
      onSetup: I.onSetupTable,
      command: "mceTableDelete"
    }), Rt(rn, !0) && D.ui.registry.addNestedMenuItem("row", {
      type: "nestedmenuitem",
      text: "Row",
      getSubmenuItems: ye("tableinsertrowbefore tableinsertrowafter tabledeleterow tablerowprops | tablecutrow tablecopyrow tablepasterowbefore tablepasterowafter")
    }), Rt($n, !0) && D.ui.registry.addNestedMenuItem("column", {
      type: "nestedmenuitem",
      text: "Column",
      getSubmenuItems: ye("tableinsertcolumnbefore tableinsertcolumnafter tabledeletecolumn | tablecutcolumn tablecopycolumn tablepastecolumnbefore tablepastecolumnafter")
    }), Rt(No, !0) && D.ui.registry.addNestedMenuItem("cell", {
      type: "nestedmenuitem",
      text: "Cell",
      getSubmenuItems: ye("tablecellprops tablemergecells tablesplitcells")
    }), D.ui.registry.addContextMenu("table", {
      update: () => (I.resetTargets(), I.targets().fold(ye(""), (Us) => qt(Us.element) === "caption" ? "tableprops deletetable" : "cell row column | advtablesort | tableprops deletetable"))
    });
    const ts = Pr(Ff(D));
    ts.length !== 0 && D.queryCommandSupported("mceTableToggleClass") && D.ui.registry.addNestedMenuItem("tableclass", {
      icon: "table-classes",
      text: "Table styles",
      getSubmenuItems: () => Hf(D, ts, "tableclass", (Us) => D.execCommand("mceTableToggleClass", !1, Us)),
      onSetup: I.onSetupTable
    });
    const nr = Pr(Zi(D));
    nr.length !== 0 && D.queryCommandSupported("mceTableCellToggleClass") && D.ui.registry.addNestedMenuItem("tablecellclass", {
      icon: "table-cell-classes",
      text: "Cell styles",
      getSubmenuItems: () => Hf(D, nr, "tablecellclass", (Us) => D.execCommand("mceTableCellToggleClass", !1, Us)),
      onSetup: I.onSetupCellOrRow
    }), D.queryCommandSupported("mceTableApplyCellStyle") && (D.ui.registry.addNestedMenuItem("tablecellvalign", {
      icon: "vertical-align",
      text: "Vertical align",
      getSubmenuItems: () => Hf(D, za, "tablecellverticalalign", $u(D, "vertical-align")),
      onSetup: I.onSetupCellOrRow
    }), D.ui.registry.addNestedMenuItem("tablecellborderwidth", {
      icon: "border-width",
      text: "Border width",
      getSubmenuItems: () => Hf(D, Sc(D), "tablecellborderwidth", $u(D, "border-width")),
      onSetup: I.onSetupCellOrRow
    }), D.ui.registry.addNestedMenuItem("tablecellborderstyle", {
      icon: "border-style",
      text: "Border style",
      getSubmenuItems: () => Hf(D, qa(D), "tablecellborderstyle", $u(D, "border-style")),
      onSetup: I.onSetupCellOrRow
    }), D.ui.registry.addNestedMenuItem("tablecellbackgroundcolor", {
      icon: "cell-background-color",
      text: "Background color",
      getSubmenuItems: () => nc(D, Vh(D), "background-color"),
      onSetup: I.onSetupCellOrRow
    }), D.ui.registry.addNestedMenuItem("tablecellbordercolor", {
      icon: "cell-border-color",
      text: "Border color",
      getSubmenuItems: () => nc(D, Bf(D), "border-color"),
      onSetup: I.onSetupCellOrRow
    })), Be("tablecaption", {
      icon: "table-caption",
      text: "Table caption",
      command: "mceTableToggleCaption",
      onSetup: I.onSetupTableWithCaption
    }), Be("tablerowheader", {
      text: "Row header",
      icon: "table-top-header",
      command: "mceTableRowType",
      onAction: ls(D),
      onSetup: I.onSetupTableRowHeaders
    }), Be("tablecolheader", {
      text: "Column header",
      icon: "table-left-header",
      command: "mceTableColType",
      onAction: ef(D),
      onSetup: I.onSetupTableRowHeaders
    });
  }, Ea = (D) => {
    const I = wd(D);
    Jr(D), Y2(D), gu(D, I), Wc(D, I), Ip(D);
  };
  var Ca = () => {
    o.add("table", Ea);
  };
  Ca();
})();
(function() {
  const o = (J) => {
    let pe = J;
    return {
      get: () => pe,
      set: (ye) => {
        pe = ye;
      }
    };
  };
  var a = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const c = (J, pe) => {
    J.dispatch("VisualBlocks", { state: pe });
  }, f = (J, pe, Se) => {
    J.dom.toggleClass(J.getBody(), "mce-visualblocks"), Se.set(!Se.get()), c(J, Se.get());
  }, g = (J, pe, Se) => {
    J.addCommand("mceVisualBlocks", () => {
      f(J, pe, Se);
    });
  }, x = (J) => (pe) => pe.options.get(J), k = (J) => {
    const pe = J.options.register;
    pe("visualblocks_default_state", {
      processor: "boolean",
      default: !1
    });
  }, A = x("visualblocks_default_state"), N = (J, pe, Se) => {
    J.on("PreviewFormats AfterPreviewFormats", (be) => {
      Se.get() && J.dom.toggleClass(J.getBody(), "mce-visualblocks", be.type === "afterpreviewformats");
    }), J.on("init", () => {
      A(J) && f(J, pe, Se);
    });
  }, H = (J, pe) => (Se) => {
    Se.setActive(pe.get());
    const be = (ye) => Se.setActive(ye.state);
    return J.on("VisualBlocks", be), () => J.off("VisualBlocks", be);
  }, Z = (J, pe) => {
    const Se = () => J.execCommand("mceVisualBlocks");
    J.ui.registry.addToggleButton("visualblocks", {
      icon: "visualblocks",
      tooltip: "Show blocks",
      onAction: Se,
      onSetup: H(J, pe)
    }), J.ui.registry.addToggleMenuItem("visualblocks", {
      text: "Show blocks",
      icon: "visualblocks",
      onAction: Se,
      onSetup: H(J, pe)
    });
  };
  var K = () => {
    a.add("visualblocks", (J, pe) => {
      k(J);
      const Se = o(!1);
      g(J, pe, Se), Z(J, Se), N(J, pe, Se);
    });
  };
  K();
})();
(function() {
  const o = (Ke) => {
    let ht = Ke;
    return {
      get: () => ht,
      set: (Ao) => {
        ht = Ao;
      }
    };
  };
  var a = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const c = (Ke) => ({ isEnabled: () => Ke.get() }), f = (Ke, ht) => Ke.dispatch("VisualChars", { state: ht }), g = (Ke, ht, gn) => {
    var En;
    return gn(Ke, ht.prototype) ? !0 : ((En = Ke.constructor) === null || En === void 0 ? void 0 : En.name) === ht.name;
  }, x = (Ke) => {
    const ht = typeof Ke;
    return Ke === null ? "null" : ht === "object" && Array.isArray(Ke) ? "array" : ht === "object" && g(Ke, String, (gn, En) => En.isPrototypeOf(gn)) ? "string" : ht;
  }, k = (Ke) => (ht) => x(ht) === Ke, A = (Ke) => (ht) => typeof ht === Ke, N = (Ke) => (ht) => Ke === ht, H = k("string"), Z = k("object"), K = N(null), J = A("boolean"), pe = (Ke) => Ke == null, Se = (Ke) => !pe(Ke), be = A("number");
  class ye {
    constructor(ht, gn) {
      this.tag = ht, this.value = gn;
    }
    static some(ht) {
      return new ye(!0, ht);
    }
    static none() {
      return ye.singletonNone;
    }
    fold(ht, gn) {
      return this.tag ? gn(this.value) : ht();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(ht) {
      return this.tag ? ye.some(ht(this.value)) : ye.none();
    }
    bind(ht) {
      return this.tag ? ht(this.value) : ye.none();
    }
    exists(ht) {
      return this.tag && ht(this.value);
    }
    forall(ht) {
      return !this.tag || ht(this.value);
    }
    filter(ht) {
      return !this.tag || ht(this.value) ? this : ye.none();
    }
    getOr(ht) {
      return this.tag ? this.value : ht;
    }
    or(ht) {
      return this.tag ? this : ht;
    }
    getOrThunk(ht) {
      return this.tag ? this.value : ht();
    }
    orThunk(ht) {
      return this.tag ? this : ht();
    }
    getOrDie(ht) {
      if (this.tag)
        return this.value;
      throw new Error(ht ?? "Called getOrDie on None");
    }
    static from(ht) {
      return Se(ht) ? ye.some(ht) : ye.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(ht) {
      this.tag && ht(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  ye.singletonNone = new ye(!1);
  const re = (Ke, ht) => {
    const gn = Ke.length, En = new Array(gn);
    for (let Ao = 0; Ao < gn; Ao++) {
      const as = Ke[Ao];
      En[Ao] = ht(as, Ao);
    }
    return En;
  }, oe = (Ke, ht) => {
    for (let gn = 0, En = Ke.length; gn < En; gn++) {
      const Ao = Ke[gn];
      ht(Ao, gn);
    }
  }, U = (Ke, ht) => {
    const gn = [];
    for (let En = 0, Ao = Ke.length; En < Ao; En++) {
      const as = Ke[En];
      ht(as, En) && gn.push(as);
    }
    return gn;
  }, ve = Object.keys, Ze = (Ke, ht) => {
    const gn = ve(Ke);
    for (let En = 0, Ao = gn.length; En < Ao; En++) {
      const as = gn[En], Yr = Ke[as];
      ht(Yr, as);
    }
  }, rt = typeof window < "u" ? window : Function("return this;")(), ee = (Ke, ht) => {
    let gn = ht ?? rt;
    for (let En = 0; En < Ke.length && gn !== void 0 && gn !== null; ++En)
      gn = gn[Ke[En]];
    return gn;
  }, lt = (Ke, ht) => {
    const gn = Ke.split(".");
    return ee(gn, ht);
  }, wt = (Ke, ht) => lt(Ke, ht), Vt = (Ke, ht) => {
    const gn = wt(Ke, ht);
    if (gn == null)
      throw new Error(Ke + " not available on this browser");
    return gn;
  }, Ue = Object.getPrototypeOf, Ce = (Ke) => Vt("HTMLElement", Ke), Rn = (Ke) => {
    const ht = lt("ownerDocument.defaultView", Ke);
    return Z(Ke) && (Ce(ht).prototype.isPrototypeOf(Ke) || /^HTML\w*Element$/.test(Ue(Ke).constructor.name));
  }, _t = 1, ot = 3, B = (Ke) => Ke.dom.nodeType, fn = (Ke) => Ke.dom.nodeValue, ze = (Ke) => (ht) => B(ht) === Ke, jt = (Ke) => Tt(Ke) && Rn(Ke.dom), Tt = ze(_t), Je = ze(ot), pn = (Ke, ht, gn) => {
    if (H(gn) || J(gn) || be(gn))
      Ke.setAttribute(ht, gn + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", ht, ":: Value ", gn, ":: Element ", Ke), new Error("Attribute value was not simple");
  }, Ro = (Ke, ht, gn) => {
    pn(Ke.dom, ht, gn);
  }, Rt = (Ke, ht) => {
    const gn = Ke.dom.getAttribute(ht);
    return gn === null ? void 0 : gn;
  }, Cn = (Ke, ht) => {
    Ke.dom.removeAttribute(ht);
  }, et = (Ke, ht) => {
    const gn = Rt(Ke, ht);
    return gn === void 0 || gn === "" ? [] : gn.split(" ");
  }, xt = (Ke, ht, gn) => {
    const Ao = et(Ke, ht).concat([gn]);
    return Ro(Ke, ht, Ao.join(" ")), !0;
  }, X = (Ke, ht, gn) => {
    const En = U(et(Ke, ht), (Ao) => Ao !== gn);
    return En.length > 0 ? Ro(Ke, ht, En.join(" ")) : Cn(Ke, ht), !1;
  }, ds = (Ke) => Ke.dom.classList !== void 0, So = (Ke) => et(Ke, "class"), At = (Ke, ht) => xt(Ke, "class", ht), Pt = (Ke, ht) => X(Ke, "class", ht), Hn = (Ke, ht) => {
    ds(Ke) ? Ke.dom.classList.add(ht) : At(Ke, ht);
  }, Nt = (Ke) => {
    (ds(Ke) ? Ke.dom.classList : So(Ke)).length === 0 && Cn(Ke, "class");
  }, Vn = (Ke, ht) => {
    ds(Ke) ? Ke.dom.classList.remove(ht) : Pt(Ke, ht), Nt(Ke);
  }, tn = (Ke, ht) => {
    const En = (ht || document).createElement("div");
    if (En.innerHTML = Ke, !En.hasChildNodes() || En.childNodes.length > 1) {
      const Ao = "HTML does not have a single root node";
      throw console.error(Ao, Ke), new Error(Ao);
    }
    return qn(En.childNodes[0]);
  }, je = (Ke, ht) => {
    const En = (ht || document).createElement(Ke);
    return qn(En);
  }, An = (Ke, ht) => {
    const En = (ht || document).createTextNode(Ke);
    return qn(En);
  }, qn = (Ke) => {
    if (Ke == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: Ke };
  }, zt = {
    fromHtml: tn,
    fromTag: je,
    fromText: An,
    fromDom: qn,
    fromPoint: (Ke, ht, gn) => ye.from(Ke.dom.elementFromPoint(ht, gn)).map(qn)
  }, vt = {
    " ": "nbsp",
    "­": "shy"
  }, oo = (Ke, ht) => {
    let gn = "";
    return Ze(Ke, (En, Ao) => {
      gn += Ao;
    }), new RegExp("[" + gn + "]", ht ? "g" : "");
  }, Dn = (Ke) => {
    let ht = "";
    return Ze(Ke, (gn) => {
      ht && (ht += ","), ht += "span.mce-" + gn;
    }), ht;
  }, ao = oo(vt), xs = oo(vt, !0), rs = Dn(vt), Qo = "mce-nbsp", os = (Ke) => Ke.dom.contentEditable, zs = (Ke) => '<span data-mce-bogus="1" class="mce-' + vt[Ke] + '">' + Ke + "</span>", it = (Ke) => Ke.nodeName.toLowerCase() === "span" && Ke.classList.contains("mce-nbsp-wrap"), kt = (Ke) => {
    const ht = fn(Ke);
    return Je(Ke) && H(ht) && ao.test(ht);
  }, xn = (Ke) => jt(Ke) && os(Ke) === "false", hn = (Ke, ht) => {
    if (jt(Ke) && !it(Ke.dom)) {
      const gn = os(Ke);
      if (gn === "true")
        return !0;
      if (gn === "false")
        return !1;
    }
    return ht;
  }, Do = (Ke, ht, gn) => {
    let En = [];
    const Ao = Ke.dom, as = re(Ao.childNodes, zt.fromDom), Yr = (Xr) => it(Xr.dom) || !xn(Xr);
    return oe(as, (Xr) => {
      gn && Yr(Xr) && ht(Xr) && (En = En.concat([Xr])), En = En.concat(Do(Xr, ht, hn(Xr, gn)));
    }), En;
  }, Ss = (Ke, ht) => {
    for (; Ke.parentNode; ) {
      if (Ke.parentNode === ht)
        return ht;
      Ke = Ke.parentNode;
    }
  }, pr = (Ke) => Ke.replace(xs, zs), ta = (Ke, ht) => {
    const gn = Ke.dom, En = Do(zt.fromDom(ht), kt, Ke.dom.isEditable(ht));
    oe(En, (Ao) => {
      var as;
      const Yr = Ao.dom.parentNode;
      if (it(Yr))
        Hn(zt.fromDom(Yr), Qo);
      else {
        const Xr = pr(gn.encode((as = fn(Ao)) !== null && as !== void 0 ? as : "")), Tr = gn.create("div", {}, Xr);
        let Ne;
        for (; Ne = Tr.lastChild; )
          gn.insertAfter(Ne, Ao.dom);
        Ke.dom.remove(Ao.dom);
      }
    });
  }, Ms = (Ke, ht) => {
    const gn = Ke.dom.select(rs, ht);
    oe(gn, (En) => {
      it(En) ? Vn(zt.fromDom(En), Qo) : Ke.dom.remove(En, !0);
    });
  }, hr = (Ke) => {
    const ht = Ke.getBody(), gn = Ke.selection.getBookmark();
    let En = Ss(Ke.selection.getNode(), ht);
    En = En !== void 0 ? En : ht, Ms(Ke, En), ta(Ke, En), Ke.selection.moveToBookmark(gn);
  }, qt = (Ke, ht) => {
    f(Ke, ht.get());
    const gn = Ke.getBody();
    ht.get() === !0 ? ta(Ke, gn) : Ms(Ke, gn);
  }, Ko = (Ke, ht) => {
    ht.set(!ht.get());
    const gn = Ke.selection.getBookmark();
    qt(Ke, ht), Ke.selection.moveToBookmark(gn);
  }, Lr = (Ke, ht) => {
    Ke.addCommand("mceVisualChars", () => {
      Ko(Ke, ht);
    });
  }, ha = (Ke) => (ht) => ht.options.get(Ke), ia = (Ke) => {
    const ht = Ke.options.register;
    ht("visualchars_default_state", {
      processor: "boolean",
      default: !1
    });
  }, na = ha("visualchars_default_state"), ks = (Ke, ht) => {
    Ke.on("init", () => {
      qt(Ke, ht);
    });
  }, xa = (Ke, ht) => {
    let gn = null;
    return {
      cancel: () => {
        K(gn) || (clearTimeout(gn), gn = null);
      },
      throttle: (...as) => {
        K(gn) && (gn = setTimeout(() => {
          gn = null, Ke.apply(null, as);
        }, ht));
      }
    };
  }, la = (Ke, ht) => {
    const gn = xa(() => {
      hr(Ke);
    }, 300);
    Ke.on("keydown", (En) => {
      ht.get() === !0 && (En.keyCode === 13 ? hr(Ke) : gn.throttle());
    }), Ke.on("remove", gn.cancel);
  }, _s = (Ke, ht) => (gn) => {
    gn.setActive(ht.get());
    const En = (Ao) => gn.setActive(Ao.state);
    return Ke.on("VisualChars", En), () => Ke.off("VisualChars", En);
  }, Xn = (Ke, ht) => {
    const gn = () => Ke.execCommand("mceVisualChars");
    Ke.ui.registry.addToggleButton("visualchars", {
      tooltip: "Show invisible characters",
      icon: "visualchars",
      onAction: gn,
      onSetup: _s(Ke, ht)
    }), Ke.ui.registry.addToggleMenuItem("visualchars", {
      text: "Show invisible characters",
      icon: "visualchars",
      onAction: gn,
      onSetup: _s(Ke, ht)
    });
  };
  var wr = () => {
    a.add("visualchars", (Ke) => {
      ia(Ke);
      const ht = o(na(Ke));
      return Lr(Ke, ht), Xn(Ke, ht), la(Ke, ht), ks(Ke, ht), c(ht);
    });
  };
  wr();
})();
tinymce.Resource.add("content/default/content.css", `body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Open Sans','Helvetica Neue',sans-serif;line-height:1.4;margin:1rem}table{border-collapse:collapse}table:not([cellpadding]) td,table:not([cellpadding]) th{padding:.4rem}table[border]:not([border="0"]):not([style*=border-width]) td,table[border]:not([border="0"]):not([style*=border-width]) th{border-width:1px}table[border]:not([border="0"]):not([style*=border-style]) td,table[border]:not([border="0"]):not([style*=border-style]) th{border-style:solid}table[border]:not([border="0"]):not([style*=border-color]) td,table[border]:not([border="0"]):not([style*=border-color]) th{border-color:#ccc}figure{display:table;margin:1rem auto}figure figcaption{color:#999;display:block;margin-top:.25rem;text-align:center}hr{border-color:#ccc;border-style:solid;border-width:1px 0 0 0}code{background-color:#e8e8e8;border-radius:3px;padding:.1rem .2rem}.mce-content-body:not([dir=rtl]) blockquote{border-left:2px solid #ccc;margin-left:1.5rem;padding-left:1rem}.mce-content-body[dir=rtl] blockquote{border-right:2px solid #ccc;margin-right:1.5rem;padding-right:1rem}`);
tinymce.Resource.add("ui/default/content.css", `.mce-content-body .mce-item-anchor{background:transparent url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D'8'%20height%3D'12'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%3E%3Cpath%20d%3D'M0%200L8%200%208%2012%204.09117821%209%200%2012z'%2F%3E%3C%2Fsvg%3E%0A") no-repeat center}.mce-content-body .mce-item-anchor:empty{cursor:default;display:inline-block;height:12px!important;padding:0 2px;-webkit-user-modify:read-only;-moz-user-modify:read-only;-webkit-user-select:all;-moz-user-select:all;user-select:all;width:8px!important}.mce-content-body .mce-item-anchor:not(:empty){background-position-x:2px;display:inline-block;padding-left:12px}.mce-content-body .mce-item-anchor[data-mce-selected]{outline-offset:1px}.tox-comments-visible .tox-comment[contenteditable=false]:not([data-mce-selected]),.tox-comments-visible span.tox-comment img:not([data-mce-selected]),.tox-comments-visible span.tox-comment span.mce-preview-object:not([data-mce-selected]),.tox-comments-visible span.tox-comment>audio:not([data-mce-selected]),.tox-comments-visible span.tox-comment>video:not([data-mce-selected]){outline:3px solid #ffe89d}.tox-comments-visible .tox-comment[contenteditable=false][data-mce-annotation-active=true]:not([data-mce-selected]){outline:3px solid #fed635}.tox-comments-visible span.tox-comment[data-mce-annotation-active=true] img:not([data-mce-selected]),.tox-comments-visible span.tox-comment[data-mce-annotation-active=true] span.mce-preview-object:not([data-mce-selected]),.tox-comments-visible span.tox-comment[data-mce-annotation-active=true]>audio:not([data-mce-selected]),.tox-comments-visible span.tox-comment[data-mce-annotation-active=true]>video:not([data-mce-selected]){outline:3px solid #fed635}.tox-comments-visible span.tox-comment:not([data-mce-selected]){background-color:#ffe89d;outline:0}.tox-comments-visible span.tox-comment[data-mce-annotation-active=true]:not([data-mce-selected=inline-boundary]){background-color:#fed635}.tox-checklist>li:not(.tox-checklist--hidden){list-style:none;margin:.25em 0}.tox-checklist>li:not(.tox-checklist--hidden)::before{content:url("data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cg%20id%3D%22checklist-unchecked%22%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%3E%3Crect%20id%3D%22Rectangle%22%20width%3D%2215%22%20height%3D%2215%22%20x%3D%22.5%22%20y%3D%22.5%22%20fill-rule%3D%22nonzero%22%20stroke%3D%22%234C4C4C%22%20rx%3D%222%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%0A");cursor:pointer;height:1em;margin-left:-1.5em;margin-top:.125em;position:absolute;width:1em}.tox-checklist li:not(.tox-checklist--hidden).tox-checklist--checked::before{content:url("data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cg%20id%3D%22checklist-checked%22%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%3E%3Crect%20id%3D%22Rectangle%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%234099FF%22%20fill-rule%3D%22nonzero%22%20rx%3D%222%22%2F%3E%3Cpath%20id%3D%22Path%22%20fill%3D%22%23FFF%22%20fill-rule%3D%22nonzero%22%20d%3D%22M11.5703186%2C3.14417309%20C11.8516238%2C2.73724603%2012.4164781%2C2.62829933%2012.83558%2C2.89774797%20C13.260121%2C3.17069355%2013.3759736%2C3.72932262%2013.0909105%2C4.14168582%20L7.7580587%2C11.8560195%20C7.43776896%2C12.3193404%206.76483983%2C12.3852142%206.35607322%2C11.9948725%20L3.02491697%2C8.8138662%20C2.66090143%2C8.46625845%202.65798871%2C7.89594698%203.01850234%2C7.54483354%20C3.373942%2C7.19866177%203.94940006%2C7.19592841%204.30829608%2C7.5386474%20L6.85276923%2C9.9684299%20L11.5703186%2C3.14417309%20Z%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%0A")}[dir=rtl] .tox-checklist>li:not(.tox-checklist--hidden)::before{margin-left:0;margin-right:-1.5em}code[class*=language-],pre[class*=language-]{color:#000;background:0 0;text-shadow:0 1px #fff;font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;tab-size:4;-webkit-hyphens:none;hyphens:none}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{text-shadow:none;background:#b3d4fc}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{text-shadow:none;background:#b3d4fc}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#f5f2f0}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#999}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{color:#9a6e3a;background:hsla(0,0%,100%,.5)}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.class-name,.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.mce-content-body{overflow-wrap:break-word;word-wrap:break-word}.mce-content-body .mce-visual-caret{background-color:#000;background-color:currentColor;position:absolute}.mce-content-body .mce-visual-caret-hidden{display:none}.mce-content-body [data-mce-caret]{left:-1000px;margin:0;padding:0;position:absolute;right:auto;top:0}.mce-content-body .mce-offscreen-selection{left:-2000000px;max-width:1000000px;position:absolute}.mce-content-body [contentEditable=false]{cursor:default}.mce-content-body [contentEditable=true]{cursor:text}.tox-cursor-format-painter{cursor:url("data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2224%22%20height%3D%2224%22%20viewBox%3D%220%200%2024%2024%22%3E%0A%20%20%3Cg%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%3E%0A%20%20%20%20%3Cpath%20fill%3D%22%23000%22%20fill-rule%3D%22nonzero%22%20d%3D%22M15%2C6%20C15%2C5.45%2014.55%2C5%2014%2C5%20L6%2C5%20C5.45%2C5%205%2C5.45%205%2C6%20L5%2C10%20C5%2C10.55%205.45%2C11%206%2C11%20L14%2C11%20C14.55%2C11%2015%2C10.55%2015%2C10%20L15%2C9%20L16%2C9%20L16%2C12%20L9%2C12%20L9%2C19%20C9%2C19.55%209.45%2C20%2010%2C20%20L11%2C20%20C11.55%2C20%2012%2C19.55%2012%2C19%20L12%2C14%20L18%2C14%20L18%2C7%20L15%2C7%20L15%2C6%20Z%22%2F%3E%0A%20%20%20%20%3Cpath%20fill%3D%22%23000%22%20fill-rule%3D%22nonzero%22%20d%3D%22M1%2C1%20L8.25%2C1%20C8.66421356%2C1%209%2C1.33578644%209%2C1.75%20L9%2C1.75%20C9%2C2.16421356%208.66421356%2C2.5%208.25%2C2.5%20L2.5%2C2.5%20L2.5%2C8.25%20C2.5%2C8.66421356%202.16421356%2C9%201.75%2C9%20L1.75%2C9%20C1.33578644%2C9%201%2C8.66421356%201%2C8.25%20L1%2C1%20Z%22%2F%3E%0A%20%20%3C%2Fg%3E%0A%3C%2Fsvg%3E%0A"),default}div.mce-footnotes hr{margin-inline-end:auto;margin-inline-start:0;width:25%}div.mce-footnotes li>a.mce-footnotes-backlink{text-decoration:none}@media print{sup.mce-footnote a{color:#000;text-decoration:none}div.mce-footnotes{break-inside:avoid;width:100%}div.mce-footnotes li>a.mce-footnotes-backlink{display:none}}tiny-math-block{display:flex;justify-content:center;margin:16px 0 16px 0}tiny-math-inline{display:inline-block}.mce-content-body figure.align-left{float:left}.mce-content-body figure.align-right{float:right}.mce-content-body figure.image.align-center{display:table;margin-left:auto;margin-right:auto}.mce-preview-object{border:1px solid gray;display:inline-block;line-height:0;margin:0 2px 0 2px;position:relative}.mce-preview-object .mce-shim{background:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7);height:100%;left:0;position:absolute;top:0;width:100%}.mce-preview-object[data-mce-selected="2"] .mce-shim{display:none}.mce-content-body .mce-mergetag{cursor:default!important;-webkit-user-select:none;-moz-user-select:none;user-select:none}.mce-content-body .mce-mergetag:hover{background-color:rgba(0,108,231,.1)}.mce-content-body .mce-mergetag-affix{background-color:rgba(0,108,231,.1);color:#006ce7}.mce-object{background:transparent url("data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2224%22%20height%3D%2224%22%3E%3Cpath%20d%3D%22M4%203h16a1%201%200%200%201%201%201v16a1%201%200%200%201-1%201H4a1%201%200%200%201-1-1V4a1%201%200%200%201%201-1zm1%202v14h14V5H5zm4.79%202.565l5.64%204.028a.5.5%200%200%201%200%20.814l-5.64%204.028a.5.5%200%200%201-.79-.407V7.972a.5.5%200%200%201%20.79-.407z%22%2F%3E%3C%2Fsvg%3E%0A") no-repeat center;border:1px dashed #aaa}.mce-pagebreak{border:1px dashed #aaa;cursor:default;display:block;height:5px;margin-top:15px;page-break-before:always;width:100%}@media print{.mce-pagebreak{border:0}}.tiny-pageembed .mce-shim{background:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7);height:100%;left:0;position:absolute;top:0;width:100%}.tiny-pageembed[data-mce-selected="2"] .mce-shim{display:none}.tiny-pageembed{display:inline-block;position:relative}.tiny-pageembed--16by9,.tiny-pageembed--1by1,.tiny-pageembed--21by9,.tiny-pageembed--4by3{display:block;overflow:hidden;padding:0;position:relative;width:100%}.tiny-pageembed--21by9{padding-top:42.857143%}.tiny-pageembed--16by9{padding-top:56.25%}.tiny-pageembed--4by3{padding-top:75%}.tiny-pageembed--1by1{padding-top:100%}.tiny-pageembed--16by9 iframe,.tiny-pageembed--1by1 iframe,.tiny-pageembed--21by9 iframe,.tiny-pageembed--4by3 iframe{border:0;height:100%;left:0;position:absolute;top:0;width:100%}.mce-content-body[data-mce-placeholder]{position:relative}.mce-content-body[data-mce-placeholder]:not(.mce-visualblocks)::before{color:rgba(34,47,62,.7);content:attr(data-mce-placeholder);position:absolute}@media (forced-colors:active){.mce-content-body[data-mce-placeholder]:not(.mce-visualblocks)::before{color:highlight;filter:brightness(30%);z-index:-1}}.mce-content-body:not([dir=rtl])[data-mce-placeholder]:not(.mce-visualblocks)::before{left:1px}.mce-content-body[dir=rtl][data-mce-placeholder]:not(.mce-visualblocks)::before{right:1px}.mce-content-body div.mce-resizehandle{background-color:#4099ff;border-color:#4099ff;border-style:solid;border-width:1px;box-sizing:border-box;height:10px;position:absolute;width:10px;z-index:1298}.mce-content-body div.mce-resizehandle:hover{background-color:#4099ff}.mce-content-body div.mce-resizehandle:nth-of-type(1){cursor:nwse-resize}.mce-content-body div.mce-resizehandle:nth-of-type(2){cursor:nesw-resize}.mce-content-body div.mce-resizehandle:nth-of-type(3){cursor:nwse-resize}.mce-content-body div.mce-resizehandle:nth-of-type(4){cursor:nesw-resize}.mce-content-body .mce-resize-backdrop{z-index:10000}.mce-content-body .mce-clonedresizable{cursor:default;opacity:.5;outline:1px dashed #000;position:absolute;z-index:10001}.mce-content-body .mce-clonedresizable.mce-resizetable-columns td,.mce-content-body .mce-clonedresizable.mce-resizetable-columns th{border:0}.mce-content-body .mce-resize-helper{background:#555;background:rgba(0,0,0,.75);border:1px;border-radius:3px;color:#fff;display:none;font-family:sans-serif;font-size:12px;line-height:14px;margin:5px 10px;padding:5px;position:absolute;white-space:nowrap;z-index:10002}.tox-rtc-user-selection{position:relative}.tox-rtc-user-cursor{bottom:0;cursor:default;position:absolute;top:0;width:2px}.tox-rtc-user-cursor::before{background-color:inherit;border-radius:50%;content:'';display:block;height:8px;position:absolute;right:-3px;top:-3px;width:8px}.tox-rtc-user-cursor:hover::after{background-color:inherit;border-radius:100px;box-sizing:border-box;color:#fff;content:attr(data-user);display:block;font-size:12px;font-weight:700;left:-5px;min-height:8px;min-width:8px;padding:0 12px;position:absolute;top:-11px;white-space:nowrap;z-index:1000}.tox-rtc-user-selection--1 .tox-rtc-user-cursor{background-color:#2dc26b}.tox-rtc-user-selection--2 .tox-rtc-user-cursor{background-color:#e03e2d}.tox-rtc-user-selection--3 .tox-rtc-user-cursor{background-color:#f1c40f}.tox-rtc-user-selection--4 .tox-rtc-user-cursor{background-color:#3598db}.tox-rtc-user-selection--5 .tox-rtc-user-cursor{background-color:#b96ad9}.tox-rtc-user-selection--6 .tox-rtc-user-cursor{background-color:#e67e23}.tox-rtc-user-selection--7 .tox-rtc-user-cursor{background-color:#aaa69d}.tox-rtc-user-selection--8 .tox-rtc-user-cursor{background-color:#f368e0}.tox-rtc-remote-image{background:#eaeaea url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2236%22%20height%3D%2212%22%20viewBox%3D%220%200%2036%2012%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%20%20%3Ccircle%20cx%3D%226%22%20cy%3D%226%22%20r%3D%223%22%20fill%3D%22rgba(0%2C%200%2C%200%2C%20.2)%22%3E%0A%20%20%20%20%3Canimate%20attributeName%3D%22r%22%20values%3D%223%3B5%3B3%22%20calcMode%3D%22linear%22%20dur%3D%221s%22%20repeatCount%3D%22indefinite%22%20%2F%3E%0A%20%20%3C%2Fcircle%3E%0A%20%20%3Ccircle%20cx%3D%2218%22%20cy%3D%226%22%20r%3D%223%22%20fill%3D%22rgba(0%2C%200%2C%200%2C%20.2)%22%3E%0A%20%20%20%20%3Canimate%20attributeName%3D%22r%22%20values%3D%223%3B5%3B3%22%20calcMode%3D%22linear%22%20begin%3D%22.33s%22%20dur%3D%221s%22%20repeatCount%3D%22indefinite%22%20%2F%3E%0A%20%20%3C%2Fcircle%3E%0A%20%20%3Ccircle%20cx%3D%2230%22%20cy%3D%226%22%20r%3D%223%22%20fill%3D%22rgba(0%2C%200%2C%200%2C%20.2)%22%3E%0A%20%20%20%20%3Canimate%20attributeName%3D%22r%22%20values%3D%223%3B5%3B3%22%20calcMode%3D%22linear%22%20begin%3D%22.66s%22%20dur%3D%221s%22%20repeatCount%3D%22indefinite%22%20%2F%3E%0A%20%20%3C%2Fcircle%3E%0A%3C%2Fsvg%3E%0A") no-repeat center center;border:1px solid #ccc;min-height:240px;min-width:320px}.mce-match-marker{background:#aaa;color:#fff}.mce-match-marker-selected{background:#39f;color:#fff}.mce-match-marker-selected::-moz-selection{background:#39f;color:#fff}.mce-match-marker-selected::selection{background:#39f;color:#fff}.mce-content-body audio[data-mce-selected],.mce-content-body details[data-mce-selected],.mce-content-body embed[data-mce-selected],.mce-content-body img[data-mce-selected],.mce-content-body object[data-mce-selected],.mce-content-body table[data-mce-selected],.mce-content-body video[data-mce-selected]{outline:3px solid #b4d7ff}.mce-content-body hr[data-mce-selected]{outline:3px solid #b4d7ff;outline-offset:1px}.mce-content-body [contentEditable=false] [contentEditable=true]:focus{outline:3px solid #b4d7ff}.mce-content-body [contentEditable=false] [contentEditable=true]:hover{outline:3px solid #b4d7ff}.mce-content-body [contentEditable=false][data-mce-selected]{cursor:not-allowed;outline:3px solid #b4d7ff}.mce-content-body.mce-content-readonly [contentEditable=true]:focus,.mce-content-body.mce-content-readonly [contentEditable=true]:hover{outline:0}.mce-content-body [data-mce-selected=inline-boundary]{background-color:#b4d7ff}.mce-content-body .mce-edit-focus{outline:3px solid #b4d7ff}.mce-content-body td[data-mce-selected],.mce-content-body th[data-mce-selected]{position:relative}.mce-content-body td[data-mce-selected]::-moz-selection,.mce-content-body th[data-mce-selected]::-moz-selection{background:0 0}.mce-content-body td[data-mce-selected]::selection,.mce-content-body th[data-mce-selected]::selection{background:0 0}.mce-content-body td[data-mce-selected] *,.mce-content-body th[data-mce-selected] *{outline:0;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.mce-content-body td[data-mce-selected]::after,.mce-content-body th[data-mce-selected]::after{background-color:rgba(180,215,255,.7);border:1px solid rgba(180,215,255,.7);bottom:-1px;content:'';left:-1px;mix-blend-mode:multiply;position:absolute;right:-1px;top:-1px}@media screen and (-ms-high-contrast:active),(-ms-high-contrast:none){.mce-content-body td[data-mce-selected]::after,.mce-content-body th[data-mce-selected]::after{border-color:rgba(0,84,180,.7)}}.mce-content-body img[data-mce-selected]::-moz-selection{background:0 0}.mce-content-body img[data-mce-selected]::selection{background:0 0}.ephox-snooker-resizer-bar{background-color:#b4d7ff;opacity:0;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ephox-snooker-resizer-cols{cursor:col-resize}.ephox-snooker-resizer-rows{cursor:row-resize}.ephox-snooker-resizer-bar.ephox-snooker-resizer-bar-dragging{opacity:1}.mce-spellchecker-word{background-image:url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D'4'%20height%3D'4'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%3E%3Cpath%20stroke%3D'%23ff0000'%20fill%3D'none'%20stroke-linecap%3D'round'%20stroke-opacity%3D'.75'%20d%3D'M0%203L2%201%204%203'%2F%3E%3C%2Fsvg%3E%0A");background-position:0 calc(100% + 1px);background-repeat:repeat-x;background-size:auto 6px;cursor:default;height:2rem}.mce-spellchecker-grammar{background-image:url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D'4'%20height%3D'4'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%3E%3Cpath%20stroke%3D'%2300A835'%20fill%3D'none'%20stroke-linecap%3D'round'%20d%3D'M0%203L2%201%204%203'%2F%3E%3C%2Fsvg%3E%0A");background-position:0 calc(100% + 1px);background-repeat:repeat-x;background-size:auto 6px;cursor:default}.mce-toc{border:1px solid gray}.mce-toc h2{margin:4px}.mce-toc ul>li{list-style-type:none}[data-mce-block]{display:block}.mce-item-table:not([border]),.mce-item-table:not([border]) caption,.mce-item-table:not([border]) td,.mce-item-table:not([border]) th,.mce-item-table[border="0"],.mce-item-table[border="0"] caption,.mce-item-table[border="0"] td,.mce-item-table[border="0"] th,table[style*="border-width: 0px"],table[style*="border-width: 0px"] caption,table[style*="border-width: 0px"] td,table[style*="border-width: 0px"] th{border:1px dashed #bbb}.mce-visualblocks address,.mce-visualblocks article,.mce-visualblocks aside,.mce-visualblocks blockquote,.mce-visualblocks div:not([data-mce-bogus]),.mce-visualblocks dl,.mce-visualblocks figcaption,.mce-visualblocks figure,.mce-visualblocks h1,.mce-visualblocks h2,.mce-visualblocks h3,.mce-visualblocks h4,.mce-visualblocks h5,.mce-visualblocks h6,.mce-visualblocks hgroup,.mce-visualblocks ol,.mce-visualblocks p,.mce-visualblocks pre,.mce-visualblocks section,.mce-visualblocks ul{background-repeat:no-repeat;border:1px dashed #bbb;margin-left:3px;padding-top:10px}.mce-visualblocks p{background-image:url(data:image/gif;base64,R0lGODlhCQAJAJEAAAAAAP///7u7u////yH5BAEAAAMALAAAAAAJAAkAAAIQnG+CqCN/mlyvsRUpThG6AgA7)}.mce-visualblocks h1{background-image:url(data:image/gif;base64,R0lGODlhDQAKAIABALu7u////yH5BAEAAAEALAAAAAANAAoAAAIXjI8GybGu1JuxHoAfRNRW3TWXyF2YiRUAOw==)}.mce-visualblocks h2{background-image:url(data:image/gif;base64,R0lGODlhDgAKAIABALu7u////yH5BAEAAAEALAAAAAAOAAoAAAIajI8Hybbx4oOuqgTynJd6bGlWg3DkJzoaUAAAOw==)}.mce-visualblocks h3{background-image:url(data:image/gif;base64,R0lGODlhDgAKAIABALu7u////yH5BAEAAAEALAAAAAAOAAoAAAIZjI8Hybbx4oOuqgTynJf2Ln2NOHpQpmhAAQA7)}.mce-visualblocks h4{background-image:url(data:image/gif;base64,R0lGODlhDgAKAIABALu7u////yH5BAEAAAEALAAAAAAOAAoAAAIajI8HybbxInR0zqeAdhtJlXwV1oCll2HaWgAAOw==)}.mce-visualblocks h5{background-image:url(data:image/gif;base64,R0lGODlhDgAKAIABALu7u////yH5BAEAAAEALAAAAAAOAAoAAAIajI8HybbxIoiuwjane4iq5GlW05GgIkIZUAAAOw==)}.mce-visualblocks h6{background-image:url(data:image/gif;base64,R0lGODlhDgAKAIABALu7u////yH5BAEAAAEALAAAAAAOAAoAAAIajI8HybbxIoiuwjan04jep1iZ1XRlAo5bVgAAOw==)}.mce-visualblocks div:not([data-mce-bogus]){background-image:url(data:image/gif;base64,R0lGODlhEgAKAIABALu7u////yH5BAEAAAEALAAAAAASAAoAAAIfjI9poI0cgDywrhuxfbrzDEbQM2Ei5aRjmoySW4pAAQA7)}.mce-visualblocks section{background-image:url(data:image/gif;base64,R0lGODlhKAAKAIABALu7u////yH5BAEAAAEALAAAAAAoAAoAAAI5jI+pywcNY3sBWHdNrplytD2ellDeSVbp+GmWqaDqDMepc8t17Y4vBsK5hDyJMcI6KkuYU+jpjLoKADs=)}.mce-visualblocks article{background-image:url(data:image/gif;base64,R0lGODlhKgAKAIABALu7u////yH5BAEAAAEALAAAAAAqAAoAAAI6jI+pywkNY3wG0GBvrsd2tXGYSGnfiF7ikpXemTpOiJScasYoDJJrjsG9gkCJ0ag6KhmaIe3pjDYBBQA7)}.mce-visualblocks blockquote{background-image:url(data:image/gif;base64,R0lGODlhPgAKAIABALu7u////yH5BAEAAAEALAAAAAA+AAoAAAJPjI+py+0Knpz0xQDyuUhvfoGgIX5iSKZYgq5uNL5q69asZ8s5rrf0yZmpNkJZzFesBTu8TOlDVAabUyatguVhWduud3EyiUk45xhTTgMBBQA7)}.mce-visualblocks address{background-image:url(data:image/gif;base64,R0lGODlhLQAKAIABALu7u////yH5BAEAAAEALAAAAAAtAAoAAAI/jI+pywwNozSP1gDyyZcjb3UaRpXkWaXmZW4OqKLhBmLs+K263DkJK7OJeifh7FicKD9A1/IpGdKkyFpNmCkAADs=)}.mce-visualblocks pre{background-image:url(data:image/gif;base64,R0lGODlhFQAKAIABALu7uwAAACH5BAEAAAEALAAAAAAVAAoAAAIjjI+ZoN0cgDwSmnpz1NCueYERhnibZVKLNnbOq8IvKpJtVQAAOw==)}.mce-visualblocks figure{background-image:url(data:image/gif;base64,R0lGODlhJAAKAIAAALu7u////yH5BAEAAAEALAAAAAAkAAoAAAI0jI+py+2fwAHUSFvD3RlvG4HIp4nX5JFSpnZUJ6LlrM52OE7uSWosBHScgkSZj7dDKnWAAgA7)}.mce-visualblocks figcaption{border:1px dashed #bbb}.mce-visualblocks hgroup{background-image:url(data:image/gif;base64,R0lGODlhJwAKAIABALu7uwAAACH5BAEAAAEALAAAAAAnAAoAAAI3jI+pywYNI3uB0gpsRtt5fFnfNZaVSYJil4Wo03Hv6Z62uOCgiXH1kZIIJ8NiIxRrAZNMZAtQAAA7)}.mce-visualblocks aside{background-image:url(data:image/gif;base64,R0lGODlhHgAKAIABAKqqqv///yH5BAEAAAEALAAAAAAeAAoAAAItjI+pG8APjZOTzgtqy7I3f1yehmQcFY4WKZbqByutmW4aHUd6vfcVbgudgpYCADs=)}.mce-visualblocks ul{background-image:url(data:image/gif;base64,R0lGODlhDQAKAIAAALu7u////yH5BAEAAAEALAAAAAANAAoAAAIXjI8GybGuYnqUVSjvw26DzzXiqIDlVwAAOw==)}.mce-visualblocks ol{background-image:url(data:image/gif;base64,R0lGODlhDQAKAIABALu7u////yH5BAEAAAEALAAAAAANAAoAAAIXjI8GybH6HHt0qourxC6CvzXieHyeWQAAOw==)}.mce-visualblocks dl{background-image:url(data:image/gif;base64,R0lGODlhDQAKAIABALu7u////yH5BAEAAAEALAAAAAANAAoAAAIXjI8GybEOnmOvUoWznTqeuEjNSCqeGRUAOw==)}.mce-visualblocks:not([dir=rtl]) address,.mce-visualblocks:not([dir=rtl]) article,.mce-visualblocks:not([dir=rtl]) aside,.mce-visualblocks:not([dir=rtl]) blockquote,.mce-visualblocks:not([dir=rtl]) div:not([data-mce-bogus]),.mce-visualblocks:not([dir=rtl]) dl,.mce-visualblocks:not([dir=rtl]) figcaption,.mce-visualblocks:not([dir=rtl]) figure,.mce-visualblocks:not([dir=rtl]) h1,.mce-visualblocks:not([dir=rtl]) h2,.mce-visualblocks:not([dir=rtl]) h3,.mce-visualblocks:not([dir=rtl]) h4,.mce-visualblocks:not([dir=rtl]) h5,.mce-visualblocks:not([dir=rtl]) h6,.mce-visualblocks:not([dir=rtl]) hgroup,.mce-visualblocks:not([dir=rtl]) ol,.mce-visualblocks:not([dir=rtl]) p,.mce-visualblocks:not([dir=rtl]) pre,.mce-visualblocks:not([dir=rtl]) section,.mce-visualblocks:not([dir=rtl]) ul{margin-left:3px}.mce-visualblocks[dir=rtl] address,.mce-visualblocks[dir=rtl] article,.mce-visualblocks[dir=rtl] aside,.mce-visualblocks[dir=rtl] blockquote,.mce-visualblocks[dir=rtl] div:not([data-mce-bogus]),.mce-visualblocks[dir=rtl] dl,.mce-visualblocks[dir=rtl] figcaption,.mce-visualblocks[dir=rtl] figure,.mce-visualblocks[dir=rtl] h1,.mce-visualblocks[dir=rtl] h2,.mce-visualblocks[dir=rtl] h3,.mce-visualblocks[dir=rtl] h4,.mce-visualblocks[dir=rtl] h5,.mce-visualblocks[dir=rtl] h6,.mce-visualblocks[dir=rtl] hgroup,.mce-visualblocks[dir=rtl] ol,.mce-visualblocks[dir=rtl] p,.mce-visualblocks[dir=rtl] pre,.mce-visualblocks[dir=rtl] section,.mce-visualblocks[dir=rtl] ul{background-position-x:right;margin-right:3px}.mce-nbsp,.mce-shy{background:#aaa}.mce-shy::after{content:'-'}body{font-family:sans-serif}table{border-collapse:collapse}`);
function Sce({ value: o, onChange: a }) {
  return /* @__PURE__ */ Ws.jsx(
    CCe,
    {
      licenseKey: "gpl",
      value: o,
      onEditorChange: (c) => a(c),
      init: {
        promotion: !1,
        menubar: !1,
        plugins: [
          "advlist",
          "autolink",
          "lists",
          "link",
          "image",
          "searchreplace",
          "visualblocks",
          "code",
          "fullscreen",
          "media",
          "table",
          "code",
          "help"
        ],
        toolbar: [
          "undo redo | blocks | bold italic forecolor | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | ",
          "link unlink | image media | table | removeformat | code | fullscreen | help"
        ]
      }
    }
  );
}
function kCe({
  title: o,
  setTitle: a,
  flashcards: c,
  setFlashcards: f
}) {
  const [g, x] = tt.useState(0), k = () => {
    f([...c, { front: "", back: "" }]), x(c.length);
  }, A = (H, Z) => {
    const K = [...c];
    Object.assign(K[H], Z), f(K);
  }, N = (H) => {
    const Z = c.filter((K, J) => J !== H);
    f(Z), g === H ? x(Z.length > 0 ? 0 : null) : g !== null && g > H && x(g - 1);
  };
  return /* @__PURE__ */ Ws.jsxs(Ws.Fragment, { children: [
    /* @__PURE__ */ Ws.jsxs("div", { className: "mb-3", children: [
      /* @__PURE__ */ Ws.jsx("label", { className: "mb-2", htmlFor: "flashcards-title", children: "Flashcards Deck Title" }),
      /* @__PURE__ */ Ws.jsx(
        "input",
        {
          id: "flashcards-title",
          className: "px-2 py-1 w-100",
          value: o,
          onChange: (H) => a(H.target.value),
          placeholder: "Enter deck title"
        }
      )
    ] }),
    /* @__PURE__ */ Ws.jsx("div", { className: "d-flex justify-content-end mb-2", children: /* @__PURE__ */ Ws.jsx(L2, { iconBefore: xye, onClick: k, children: "Add Flashcard" }) }),
    /* @__PURE__ */ Ws.jsxs("div", { className: "d-flex flex-row mx-2", children: [
      /* @__PURE__ */ Ws.jsx("div", { className: "d-flex flex-column mr-2", style: { flexGrow: 1, width: "30%" }, children: c.map((H, Z) => {
        var K, J;
        return /* @__PURE__ */ Ws.jsxs("div", { className: "d-flex align-items-center mb-1", children: [
          /* @__PURE__ */ Ws.jsx(
            L2,
            {
              className: "justify-content-start font-weight-bold p-2 rounded-0 flex-grow-1",
              variant: g === Z ? "light" : "outline",
              onClick: () => x(Z),
              size: "sm",
              children: H.front || `Flashcard ${Z + 1}`
            }
          ),
          /* @__PURE__ */ Ws.jsx(
            L2,
            {
              iconBefore: vye,
              variant: "outline-danger",
              size: "sm",
              className: "ml-1",
              onClick: () => N(Z)
            }
          )
        ] }, `${((K = H.front) == null ? void 0 : K.slice(0, 8)) || "empty"}-${((J = H.back) == null ? void 0 : J.slice(0, 8)) || "empty"}`);
      }) }),
      /* @__PURE__ */ Ws.jsx("div", { className: "d-flex flex-column", style: { flexGrow: 2 }, children: g !== null && c[g] && /* @__PURE__ */ Ws.jsxs(Ws.Fragment, { children: [
        /* @__PURE__ */ Ws.jsxs("div", { className: "mb-3 d-flex flex-column", children: [
          /* @__PURE__ */ Ws.jsx("label", { className: "mb-2", htmlFor: "flashcard-front", children: "Front (Question)" }),
          /* @__PURE__ */ Ws.jsx(
            Sce,
            {
              value: c[g].front,
              onChange: (H) => A(g, { front: H })
            }
          )
        ] }),
        /* @__PURE__ */ Ws.jsxs("div", { className: "mb-3 d-flex flex-column", children: [
          /* @__PURE__ */ Ws.jsx("label", { className: "mb-2", htmlFor: "flashcard-back", children: "Back (Answer)" }),
          /* @__PURE__ */ Ws.jsx(
            Sce,
            {
              value: c[g].back,
              onChange: (H) => A(g, { back: H })
            }
          )
        ] })
      ] }) })
    ] })
  ] });
}
function Nte({ className: o, onClick: a, label: c }) {
  return /* @__PURE__ */ Ws.jsx("li", { className: "action-item", children: /* @__PURE__ */ Ws.jsx(
    "a",
    {
      href: "#",
      className: `button action-primary ${o}`,
      onClick: a,
      children: c
    }
  ) });
}
function _Ce({
  initialTitle: o,
  initialFlashcards: a,
  initialStyling: c,
  studioSaveUrl: f,
  runtime: g
}) {
  const [x, k] = tt.useState(
    0
    /* Styling */
  ), [A, N] = tt.useState(c), [H, Z] = tt.useState(o), [K, J] = tt.useState(a), pe = () => {
    g.notify("save", { state: "start" });
    const Se = K.filter((be) => be.front && be.back);
    $.post(f, JSON.stringify({
      title: H,
      flashcards: Se
    })).done(() => {
      g.notify("save", { state: "end" });
    });
  };
  return /* @__PURE__ */ Ws.jsx("div", { className: "xblock-flashcards xblock--flashcards--editor editor-with-buttons", children: /* @__PURE__ */ Ws.jsxs("div", { className: "d-flex flex-column", style: { height: "375px" }, children: [
    /* @__PURE__ */ Ws.jsxs("div", { className: "d-flex flex-column overflow-auto m-2.5", children: [
      x === 0 && /* @__PURE__ */ Ws.jsx(uCe, { styling: A, setStyling: N }),
      x === 1 && /* @__PURE__ */ Ws.jsx(
        kCe,
        {
          title: H,
          setTitle: Z,
          flashcards: K,
          setFlashcards: J
        }
      )
    ] }),
    /* @__PURE__ */ Ws.jsx("div", { className: "xblock-actions", children: /* @__PURE__ */ Ws.jsxs("ul", { className: "action-buttons", children: [
      x === 0 ? /* @__PURE__ */ Ws.jsx(
        Nte,
        {
          onClick: () => k(
            1
            /* Editing */
          ),
          className: "continue-button",
          label: "Continue"
        }
      ) : /* @__PURE__ */ Ws.jsx(
        Nte,
        {
          onClick: () => k(
            0
            /* Styling */
          ),
          className: "continue-button",
          label: "Back"
        }
      ),
      /* @__PURE__ */ Ws.jsx(
        Nte,
        {
          onClick: pe,
          className: "save-button",
          label: "Save"
        }
      ),
      /* @__PURE__ */ Ws.jsx("li", { className: "action-item", children: /* @__PURE__ */ Ws.jsx(
        "a",
        {
          href: "#",
          className: "button cancel-button",
          onClick: () => g.notify("cancel", {}),
          children: "Cancel"
        }
      ) })
    ] }) })
  ] }) });
}
const OCe = (o, a, { title: c, flashcards: f, styling: g }) => {
  if (!a)
    return;
  const x = o.handlerUrl(a, "studio_submit");
  Fde(a).render(
    /* @__PURE__ */ Ws.jsx(tt.StrictMode, { children: /* @__PURE__ */ Ws.jsx(
      _Ce,
      {
        initialTitle: c,
        initialFlashcards: f,
        initialStyling: g,
        studioSaveUrl: x,
        runtime: o
      }
    ) })
  );
};
export {
  OCe as renderEditor
};
