function H3(o) {
  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
}
var nde = { exports: {} }, G5 = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Aie = Object.getOwnPropertySymbols, Lhe = Object.prototype.hasOwnProperty, Hhe = Object.prototype.propertyIsEnumerable;
function zhe(o) {
  if (o == null)
    throw new TypeError("Object.assign cannot be called with null or undefined");
  return Object(o);
}
function Vhe() {
  try {
    if (!Object.assign)
      return !1;
    var o = new String("abc");
    if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
      return !1;
    for (var r = {}, i = 0; i < 10; i++)
      r["_" + String.fromCharCode(i)] = i;
    var u = Object.getOwnPropertyNames(r).map(function(y) {
      return r[y];
    });
    if (u.join("") !== "0123456789")
      return !1;
    var h = {};
    return "abcdefghijklmnopqrst".split("").forEach(function(y) {
      h[y] = y;
    }), Object.keys(Object.assign({}, h)).join("") === "abcdefghijklmnopqrst";
  } catch {
    return !1;
  }
}
var ode = Vhe() ? Object.assign : function(o, r) {
  for (var i, u = zhe(o), h, y = 1; y < arguments.length; y++) {
    i = Object(arguments[y]);
    for (var k in i)
      Lhe.call(i, k) && (u[k] = i[k]);
    if (Aie) {
      h = Aie(i);
      for (var _ = 0; _ < h.length; _++)
        Hhe.call(i, h[_]) && (u[h[_]] = i[h[_]]);
    }
  }
  return u;
}, rde = { exports: {} }, Sa = {};
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Woe = ode, z3 = 60103, sde = 60106;
Sa.Fragment = 60107;
Sa.StrictMode = 60108;
Sa.Profiler = 60114;
var ade = 60109, ide = 60110, lde = 60112;
Sa.Suspense = 60113;
var cde = 60115, ude = 60116;
if (typeof Symbol == "function" && Symbol.for) {
  var Lg = Symbol.for;
  z3 = Lg("react.element"), sde = Lg("react.portal"), Sa.Fragment = Lg("react.fragment"), Sa.StrictMode = Lg("react.strict_mode"), Sa.Profiler = Lg("react.profiler"), ade = Lg("react.provider"), ide = Lg("react.context"), lde = Lg("react.forward_ref"), Sa.Suspense = Lg("react.suspense"), cde = Lg("react.memo"), ude = Lg("react.lazy");
}
var Pie = typeof Symbol == "function" && Symbol.iterator;
function jhe(o) {
  return o === null || typeof o != "object" ? null : (o = Pie && o[Pie] || o["@@iterator"], typeof o == "function" ? o : null);
}
function q5(o) {
  for (var r = "https://reactjs.org/docs/error-decoder.html?invariant=" + o, i = 1; i < arguments.length; i++) r += "&args[]=" + encodeURIComponent(arguments[i]);
  return "Minified React error #" + o + "; visit " + r + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var dde = { isMounted: function() {
  return !1;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, fde = {};
function V3(o, r, i) {
  this.props = o, this.context = r, this.refs = fde, this.updater = i || dde;
}
V3.prototype.isReactComponent = {};
V3.prototype.setState = function(o, r) {
  if (typeof o != "object" && typeof o != "function" && o != null) throw Error(q5(85));
  this.updater.enqueueSetState(this, o, r, "setState");
};
V3.prototype.forceUpdate = function(o) {
  this.updater.enqueueForceUpdate(this, o, "forceUpdate");
};
function mde() {
}
mde.prototype = V3.prototype;
function Zoe(o, r, i) {
  this.props = o, this.context = r, this.refs = fde, this.updater = i || dde;
}
var Goe = Zoe.prototype = new mde();
Goe.constructor = Zoe;
Woe(Goe, V3.prototype);
Goe.isPureReactComponent = !0;
var qoe = { current: null }, pde = Object.prototype.hasOwnProperty, hde = { key: !0, ref: !0, __self: !0, __source: !0 };
function gde(o, r, i) {
  var u, h = {}, y = null, k = null;
  if (r != null) for (u in r.ref !== void 0 && (k = r.ref), r.key !== void 0 && (y = "" + r.key), r) pde.call(r, u) && !hde.hasOwnProperty(u) && (h[u] = r[u]);
  var _ = arguments.length - 2;
  if (_ === 1) h.children = i;
  else if (1 < _) {
    for (var D = Array(_), L = 0; L < _; L++) D[L] = arguments[L + 2];
    h.children = D;
  }
  if (o && o.defaultProps) for (u in _ = o.defaultProps, _) h[u] === void 0 && (h[u] = _[u]);
  return { $$typeof: z3, type: o, key: y, ref: k, props: h, _owner: qoe.current };
}
function Uhe(o, r) {
  return { $$typeof: z3, type: o.type, key: r, ref: o.ref, props: o.props, _owner: o._owner };
}
function Koe(o) {
  return typeof o == "object" && o !== null && o.$$typeof === z3;
}
function Whe(o) {
  var r = { "=": "=0", ":": "=2" };
  return "$" + o.replace(/[=:]/g, function(i) {
    return r[i];
  });
}
var Die = /\/+/g;
function rte(o, r) {
  return typeof o == "object" && o !== null && o.key != null ? Whe("" + o.key) : r.toString(36);
}
function V9(o, r, i, u, h) {
  var y = typeof o;
  (y === "undefined" || y === "boolean") && (o = null);
  var k = !1;
  if (o === null) k = !0;
  else switch (y) {
    case "string":
    case "number":
      k = !0;
      break;
    case "object":
      switch (o.$$typeof) {
        case z3:
        case sde:
          k = !0;
      }
  }
  if (k) return k = o, h = h(k), o = u === "" ? "." + rte(k, 0) : u, Array.isArray(h) ? (i = "", o != null && (i = o.replace(Die, "$&/") + "/"), V9(h, r, i, "", function(L) {
    return L;
  })) : h != null && (Koe(h) && (h = Uhe(h, i + (!h.key || k && k.key === h.key ? "" : ("" + h.key).replace(Die, "$&/") + "/") + o)), r.push(h)), 1;
  if (k = 0, u = u === "" ? "." : u + ":", Array.isArray(o)) for (var _ = 0; _ < o.length; _++) {
    y = o[_];
    var D = u + rte(y, _);
    k += V9(y, r, i, D, h);
  }
  else if (D = jhe(o), typeof D == "function") for (o = D.call(o), _ = 0; !(y = o.next()).done; ) y = y.value, D = u + rte(y, _++), k += V9(y, r, i, D, h);
  else if (y === "object") throw r = "" + o, Error(q5(31, r === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : r));
  return k;
}
function f9(o, r, i) {
  if (o == null) return o;
  var u = [], h = 0;
  return V9(o, u, "", "", function(y) {
    return r.call(i, y, h++);
  }), u;
}
function Zhe(o) {
  if (o._status === -1) {
    var r = o._result;
    r = r(), o._status = 0, o._result = r, r.then(function(i) {
      o._status === 0 && (i = i.default, o._status = 1, o._result = i);
    }, function(i) {
      o._status === 0 && (o._status = 2, o._result = i);
    });
  }
  if (o._status === 1) return o._result;
  throw o._result;
}
var bde = { current: null };
function T0() {
  var o = bde.current;
  if (o === null) throw Error(q5(321));
  return o;
}
var Ghe = { ReactCurrentDispatcher: bde, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: qoe, IsSomeRendererActing: { current: !1 }, assign: Woe };
Sa.Children = { map: f9, forEach: function(o, r, i) {
  f9(o, function() {
    r.apply(this, arguments);
  }, i);
}, count: function(o) {
  var r = 0;
  return f9(o, function() {
    r++;
  }), r;
}, toArray: function(o) {
  return f9(o, function(r) {
    return r;
  }) || [];
}, only: function(o) {
  if (!Koe(o)) throw Error(q5(143));
  return o;
} };
Sa.Component = V3;
Sa.PureComponent = Zoe;
Sa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Ghe;
Sa.cloneElement = function(o, r, i) {
  if (o == null) throw Error(q5(267, o));
  var u = Woe({}, o.props), h = o.key, y = o.ref, k = o._owner;
  if (r != null) {
    if (r.ref !== void 0 && (y = r.ref, k = qoe.current), r.key !== void 0 && (h = "" + r.key), o.type && o.type.defaultProps) var _ = o.type.defaultProps;
    for (D in r) pde.call(r, D) && !hde.hasOwnProperty(D) && (u[D] = r[D] === void 0 && _ !== void 0 ? _[D] : r[D]);
  }
  var D = arguments.length - 2;
  if (D === 1) u.children = i;
  else if (1 < D) {
    _ = Array(D);
    for (var L = 0; L < D; L++) _[L] = arguments[L + 2];
    u.children = _;
  }
  return {
    $$typeof: z3,
    type: o.type,
    key: h,
    ref: y,
    props: u,
    _owner: k
  };
};
Sa.createContext = function(o, r) {
  return r === void 0 && (r = null), o = { $$typeof: ide, _calculateChangedBits: r, _currentValue: o, _currentValue2: o, _threadCount: 0, Provider: null, Consumer: null }, o.Provider = { $$typeof: ade, _context: o }, o.Consumer = o;
};
Sa.createElement = gde;
Sa.createFactory = function(o) {
  var r = gde.bind(null, o);
  return r.type = o, r;
};
Sa.createRef = function() {
  return { current: null };
};
Sa.forwardRef = function(o) {
  return { $$typeof: lde, render: o };
};
Sa.isValidElement = Koe;
Sa.lazy = function(o) {
  return { $$typeof: ude, _payload: { _status: -1, _result: o }, _init: Zhe };
};
Sa.memo = function(o, r) {
  return { $$typeof: cde, type: o, compare: r === void 0 ? null : r };
};
Sa.useCallback = function(o, r) {
  return T0().useCallback(o, r);
};
Sa.useContext = function(o, r) {
  return T0().useContext(o, r);
};
Sa.useDebugValue = function() {
};
Sa.useEffect = function(o, r) {
  return T0().useEffect(o, r);
};
Sa.useImperativeHandle = function(o, r, i) {
  return T0().useImperativeHandle(o, r, i);
};
Sa.useLayoutEffect = function(o, r) {
  return T0().useLayoutEffect(o, r);
};
Sa.useMemo = function(o, r) {
  return T0().useMemo(o, r);
};
Sa.useReducer = function(o, r, i) {
  return T0().useReducer(o, r, i);
};
Sa.useRef = function(o) {
  return T0().useRef(o);
};
Sa.useState = function(o) {
  return T0().useState(o);
};
Sa.version = "17.0.2";
rde.exports = Sa;
var et = rde.exports;
const Ve = /* @__PURE__ */ H3(et);
/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qhe = et, vde = 60103;
G5.Fragment = 60107;
if (typeof Symbol == "function" && Symbol.for) {
  var Rie = Symbol.for;
  vde = Rie("react.element"), G5.Fragment = Rie("react.fragment");
}
var Khe = qhe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, Yhe = Object.prototype.hasOwnProperty, Xhe = { key: !0, ref: !0, __self: !0, __source: !0 };
function yde(o, r, i) {
  var u, h = {}, y = null, k = null;
  i !== void 0 && (y = "" + i), r.key !== void 0 && (y = "" + r.key), r.ref !== void 0 && (k = r.ref);
  for (u in r) Yhe.call(r, u) && !Xhe.hasOwnProperty(u) && (h[u] = r[u]);
  if (o && o.defaultProps) for (u in r = o.defaultProps, r) h[u] === void 0 && (h[u] = r[u]);
  return { $$typeof: vde, type: o, key: y, ref: k, props: h, _owner: Khe.current };
}
G5.jsx = yde;
G5.jsxs = yde;
nde.exports = G5;
var cs = nde.exports, xde = { exports: {} }, Eh = {}, wde = { exports: {} }, Cde = {};
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(o) {
  var r, i, u, h;
  if (typeof performance == "object" && typeof performance.now == "function") {
    var y = performance;
    o.unstable_now = function() {
      return y.now();
    };
  } else {
    var k = Date, _ = k.now();
    o.unstable_now = function() {
      return k.now() - _;
    };
  }
  if (typeof window > "u" || typeof MessageChannel != "function") {
    var D = null, L = null, W = function() {
      if (D !== null) try {
        var Le = o.unstable_now();
        D(!0, Le), D = null;
      } catch (jt) {
        throw setTimeout(W, 0), jt;
      }
    };
    r = function(Le) {
      D !== null ? setTimeout(r, 0, Le) : (D = Le, setTimeout(W, 0));
    }, i = function(Le, jt) {
      L = setTimeout(Le, jt);
    }, u = function() {
      clearTimeout(L);
    }, o.unstable_shouldYield = function() {
      return !1;
    }, h = o.unstable_forceFrameRate = function() {
    };
  } else {
    var se = window.setTimeout, J = window.clearTimeout;
    if (typeof console < "u") {
      var be = window.cancelAnimationFrame;
      typeof window.requestAnimationFrame != "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), typeof be != "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    }
    var ke = !1, Ce = null, Q = -1, oe = 5, ae = 0;
    o.unstable_shouldYield = function() {
      return o.unstable_now() >= ae;
    }, h = function() {
    }, o.unstable_forceFrameRate = function(Le) {
      0 > Le || 125 < Le ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : oe = 0 < Le ? Math.floor(1e3 / Le) : 5;
    };
    var G = new MessageChannel(), ve = G.port2;
    G.port1.onmessage = function() {
      if (Ce !== null) {
        var Le = o.unstable_now();
        ae = Le + oe;
        try {
          Ce(!0, Le) ? ve.postMessage(null) : (ke = !1, Ce = null);
        } catch (jt) {
          throw ve.postMessage(null), jt;
        }
      } else ke = !1;
    }, r = function(Le) {
      Ce = Le, ke || (ke = !0, ve.postMessage(null));
    }, i = function(Le, jt) {
      Q = se(function() {
        Le(o.unstable_now());
      }, jt);
    }, u = function() {
      J(Q), Q = -1;
    };
  }
  function nt(Le, jt) {
    var Fn = Le.length;
    Le.push(jt);
    e: for (; ; ) {
      var St = Fn - 1 >>> 1, on = Le[St];
      if (on !== void 0 && 0 < lt(on, jt)) Le[St] = jt, Le[Fn] = on, Fn = St;
      else break e;
    }
  }
  function Xe(Le) {
    return Le = Le[0], Le === void 0 ? null : Le;
  }
  function te(Le) {
    var jt = Le[0];
    if (jt !== void 0) {
      var Fn = Le.pop();
      if (Fn !== jt) {
        Le[0] = Fn;
        e: for (var St = 0, on = Le.length; St < on; ) {
          var tt = 2 * (St + 1) - 1, mt = Le[tt], Y = tt + 1, Wo = Le[Y];
          if (mt !== void 0 && 0 > lt(mt, Fn)) Wo !== void 0 && 0 > lt(Wo, mt) ? (Le[St] = Wo, Le[Y] = Fn, St = Y) : (Le[St] = mt, Le[tt] = Fn, St = tt);
          else if (Wo !== void 0 && 0 > lt(Wo, Fn)) Le[St] = Wo, Le[Y] = Fn, St = Y;
          else break e;
        }
      }
      return jt;
    }
    return null;
  }
  function lt(Le, jt) {
    var Fn = Le.sortIndex - jt.sortIndex;
    return Fn !== 0 ? Fn : Le.id - jt.id;
  }
  var ot = [], Kt = [], je = 1, ye = null, dn = 3, wt = !1, qe = !1, B = !1;
  function mn(Le) {
    for (var jt = Xe(Kt); jt !== null; ) {
      if (jt.callback === null) te(Kt);
      else if (jt.startTime <= Le) te(Kt), jt.sortIndex = jt.expirationTime, nt(ot, jt);
      else break;
      jt = Xe(Kt);
    }
  }
  function dt(Le) {
    if (B = !1, mn(Le), !qe) if (Xe(ot) !== null) qe = !0, r(En);
    else {
      var jt = Xe(Kt);
      jt !== null && i(dt, jt.startTime - Le);
    }
  }
  function En(Le, jt) {
    qe = !1, B && (B = !1, u()), wt = !0;
    var Fn = dn;
    try {
      for (mn(jt), ye = Xe(ot); ye !== null && (!(ye.expirationTime > jt) || Le && !o.unstable_shouldYield()); ) {
        var St = ye.callback;
        if (typeof St == "function") {
          ye.callback = null, dn = ye.priorityLevel;
          var on = St(ye.expirationTime <= jt);
          jt = o.unstable_now(), typeof on == "function" ? ye.callback = on : ye === Xe(ot) && te(ot), mn(jt);
        } else te(ot);
        ye = Xe(ot);
      }
      if (ye !== null) var tt = !0;
      else {
        var mt = Xe(Kt);
        mt !== null && i(dt, mt.startTime - jt), tt = !1;
      }
      return tt;
    } finally {
      ye = null, dn = Fn, wt = !1;
    }
  }
  var tn = h;
  o.unstable_IdlePriority = 5, o.unstable_ImmediatePriority = 1, o.unstable_LowPriority = 4, o.unstable_NormalPriority = 3, o.unstable_Profiling = null, o.unstable_UserBlockingPriority = 2, o.unstable_cancelCallback = function(Le) {
    Le.callback = null;
  }, o.unstable_continueExecution = function() {
    qe || wt || (qe = !0, r(En));
  }, o.unstable_getCurrentPriorityLevel = function() {
    return dn;
  }, o.unstable_getFirstCallbackNode = function() {
    return Xe(ot);
  }, o.unstable_next = function(Le) {
    switch (dn) {
      case 1:
      case 2:
      case 3:
        var jt = 3;
        break;
      default:
        jt = dn;
    }
    var Fn = dn;
    dn = jt;
    try {
      return Le();
    } finally {
      dn = Fn;
    }
  }, o.unstable_pauseExecution = function() {
  }, o.unstable_requestPaint = tn, o.unstable_runWithPriority = function(Le, jt) {
    switch (Le) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        Le = 3;
    }
    var Fn = dn;
    dn = Le;
    try {
      return jt();
    } finally {
      dn = Fn;
    }
  }, o.unstable_scheduleCallback = function(Le, jt, Fn) {
    var St = o.unstable_now();
    switch (typeof Fn == "object" && Fn !== null ? (Fn = Fn.delay, Fn = typeof Fn == "number" && 0 < Fn ? St + Fn : St) : Fn = St, Le) {
      case 1:
        var on = -1;
        break;
      case 2:
        on = 250;
        break;
      case 5:
        on = 1073741823;
        break;
      case 4:
        on = 1e4;
        break;
      default:
        on = 5e3;
    }
    return on = Fn + on, Le = { id: je++, callback: jt, priorityLevel: Le, startTime: Fn, expirationTime: on, sortIndex: -1 }, Fn > St ? (Le.sortIndex = Fn, nt(Kt, Le), Xe(ot) === null && Le === Xe(Kt) && (B ? u() : B = !0, i(dt, Fn - St))) : (Le.sortIndex = on, nt(ot, Le), qe || wt || (qe = !0, r(En))), Le;
  }, o.unstable_wrapCallback = function(Le) {
    var jt = dn;
    return function() {
      var Fn = dn;
      dn = jt;
      try {
        return Le.apply(this, arguments);
      } finally {
        dn = Fn;
      }
    };
  };
})(Cde);
wde.exports = Cde;
var Qhe = wde.exports;
/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var XV = et, xl = ode, Pu = Qhe;
function ho(o) {
  for (var r = "https://reactjs.org/docs/error-decoder.html?invariant=" + o, i = 1; i < arguments.length; i++) r += "&args[]=" + encodeURIComponent(arguments[i]);
  return "Minified React error #" + o + "; visit " + r + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
if (!XV) throw Error(ho(227));
var Sde = /* @__PURE__ */ new Set(), JI = {};
function Fk(o, r) {
  _3(o, r), _3(o + "Capture", r);
}
function _3(o, r) {
  for (JI[o] = r, o = 0; o < r.length; o++) Sde.add(r[o]);
}
var w0 = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Jhe = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Nie = Object.prototype.hasOwnProperty, Mie = {}, Iie = {};
function ege(o) {
  return Nie.call(Iie, o) ? !0 : Nie.call(Mie, o) ? !1 : Jhe.test(o) ? Iie[o] = !0 : (Mie[o] = !0, !1);
}
function tge(o, r, i, u) {
  if (i !== null && i.type === 0) return !1;
  switch (typeof r) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return u ? !1 : i !== null ? !i.acceptsBooleans : (o = o.toLowerCase().slice(0, 5), o !== "data-" && o !== "aria-");
    default:
      return !1;
  }
}
function nge(o, r, i, u) {
  if (r === null || typeof r > "u" || tge(o, r, i, u)) return !0;
  if (u) return !1;
  if (i !== null) switch (i.type) {
    case 3:
      return !r;
    case 4:
      return r === !1;
    case 5:
      return isNaN(r);
    case 6:
      return isNaN(r) || 1 > r;
  }
  return !1;
}
function Tf(o, r, i, u, h, y, k) {
  this.acceptsBooleans = r === 2 || r === 3 || r === 4, this.attributeName = u, this.attributeNamespace = h, this.mustUseProperty = i, this.propertyName = o, this.type = r, this.sanitizeURL = y, this.removeEmptyString = k;
}
var id = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(o) {
  id[o] = new Tf(o, 0, !1, o, null, !1, !1);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(o) {
  var r = o[0];
  id[r] = new Tf(r, 1, !1, o[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(o) {
  id[o] = new Tf(o, 2, !1, o.toLowerCase(), null, !1, !1);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(o) {
  id[o] = new Tf(o, 2, !1, o, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(o) {
  id[o] = new Tf(o, 3, !1, o.toLowerCase(), null, !1, !1);
});
["checked", "multiple", "muted", "selected"].forEach(function(o) {
  id[o] = new Tf(o, 3, !0, o, null, !1, !1);
});
["capture", "download"].forEach(function(o) {
  id[o] = new Tf(o, 4, !1, o, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function(o) {
  id[o] = new Tf(o, 6, !1, o, null, !1, !1);
});
["rowSpan", "start"].forEach(function(o) {
  id[o] = new Tf(o, 5, !1, o.toLowerCase(), null, !1, !1);
});
var Yoe = /[\-:]([a-z])/g;
function Xoe(o) {
  return o[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(o) {
  var r = o.replace(
    Yoe,
    Xoe
  );
  id[r] = new Tf(r, 1, !1, o, null, !1, !1);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(o) {
  var r = o.replace(Yoe, Xoe);
  id[r] = new Tf(r, 1, !1, o, "http://www.w3.org/1999/xlink", !1, !1);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(o) {
  var r = o.replace(Yoe, Xoe);
  id[r] = new Tf(r, 1, !1, o, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function(o) {
  id[o] = new Tf(o, 1, !1, o.toLowerCase(), null, !1, !1);
});
id.xlinkHref = new Tf("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(o) {
  id[o] = new Tf(o, 1, !1, o.toLowerCase(), null, !0, !0);
});
function Qoe(o, r, i, u) {
  var h = id.hasOwnProperty(r) ? id[r] : null, y = h !== null ? h.type === 0 : u ? !1 : !(!(2 < r.length) || r[0] !== "o" && r[0] !== "O" || r[1] !== "n" && r[1] !== "N");
  y || (nge(r, i, h, u) && (i = null), u || h === null ? ege(r) && (i === null ? o.removeAttribute(r) : o.setAttribute(r, "" + i)) : h.mustUseProperty ? o[h.propertyName] = i === null ? h.type === 3 ? !1 : "" : i : (r = h.attributeName, u = h.attributeNamespace, i === null ? o.removeAttribute(r) : (h = h.type, i = h === 3 || h === 4 && i === !0 ? "" : "" + i, u ? o.setAttributeNS(u, r, i) : o.setAttribute(r, i))));
}
var Bk = XV.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, OI = 60103, pk = 60106, aw = 60107, Joe = 60108, FI = 60114, ere = 60109, tre = 60110, QV = 60112, BI = 60113, iV = 60120, JV = 60115, nre = 60116, ore = 60121, rre = 60128, kde = 60129, sre = 60130, Qte = 60131;
if (typeof Symbol == "function" && Symbol.for) {
  var Au = Symbol.for;
  OI = Au("react.element"), pk = Au("react.portal"), aw = Au("react.fragment"), Joe = Au("react.strict_mode"), FI = Au("react.profiler"), ere = Au("react.provider"), tre = Au("react.context"), QV = Au("react.forward_ref"), BI = Au("react.suspense"), iV = Au("react.suspense_list"), JV = Au("react.memo"), nre = Au("react.lazy"), ore = Au("react.block"), Au("react.scope"), rre = Au("react.opaque.id"), kde = Au("react.debug_trace_mode"), sre = Au("react.offscreen"), Qte = Au("react.legacy_hidden");
}
var Fie = typeof Symbol == "function" && Symbol.iterator;
function mI(o) {
  return o === null || typeof o != "object" ? null : (o = Fie && o[Fie] || o["@@iterator"], typeof o == "function" ? o : null);
}
var ste;
function AI(o) {
  if (ste === void 0) try {
    throw Error();
  } catch (i) {
    var r = i.stack.trim().match(/\n( *(at )?)/);
    ste = r && r[1] || "";
  }
  return `
` + ste + o;
}
var ate = !1;
function m9(o, r) {
  if (!o || ate) return "";
  ate = !0;
  var i = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (r) if (r = function() {
      throw Error();
    }, Object.defineProperty(r.prototype, "props", { set: function() {
      throw Error();
    } }), typeof Reflect == "object" && Reflect.construct) {
      try {
        Reflect.construct(r, []);
      } catch (D) {
        var u = D;
      }
      Reflect.construct(o, [], r);
    } else {
      try {
        r.call();
      } catch (D) {
        u = D;
      }
      o.call(r.prototype);
    }
    else {
      try {
        throw Error();
      } catch (D) {
        u = D;
      }
      o();
    }
  } catch (D) {
    if (D && u && typeof D.stack == "string") {
      for (var h = D.stack.split(`
`), y = u.stack.split(`
`), k = h.length - 1, _ = y.length - 1; 1 <= k && 0 <= _ && h[k] !== y[_]; ) _--;
      for (; 1 <= k && 0 <= _; k--, _--) if (h[k] !== y[_]) {
        if (k !== 1 || _ !== 1)
          do
            if (k--, _--, 0 > _ || h[k] !== y[_]) return `
` + h[k].replace(" at new ", " at ");
          while (1 <= k && 0 <= _);
        break;
      }
    }
  } finally {
    ate = !1, Error.prepareStackTrace = i;
  }
  return (o = o ? o.displayName || o.name : "") ? AI(o) : "";
}
function oge(o) {
  switch (o.tag) {
    case 5:
      return AI(o.type);
    case 16:
      return AI("Lazy");
    case 13:
      return AI("Suspense");
    case 19:
      return AI("SuspenseList");
    case 0:
    case 2:
    case 15:
      return o = m9(o.type, !1), o;
    case 11:
      return o = m9(o.type.render, !1), o;
    case 22:
      return o = m9(o.type._render, !1), o;
    case 1:
      return o = m9(o.type, !0), o;
    default:
      return "";
  }
}
function d3(o) {
  if (o == null) return null;
  if (typeof o == "function") return o.displayName || o.name || null;
  if (typeof o == "string") return o;
  switch (o) {
    case aw:
      return "Fragment";
    case pk:
      return "Portal";
    case FI:
      return "Profiler";
    case Joe:
      return "StrictMode";
    case BI:
      return "Suspense";
    case iV:
      return "SuspenseList";
  }
  if (typeof o == "object") switch (o.$$typeof) {
    case tre:
      return (o.displayName || "Context") + ".Consumer";
    case ere:
      return (o._context.displayName || "Context") + ".Provider";
    case QV:
      var r = o.render;
      return r = r.displayName || r.name || "", o.displayName || (r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef");
    case JV:
      return d3(o.type);
    case ore:
      return d3(o._render);
    case nre:
      r = o._payload, o = o._init;
      try {
        return d3(o(r));
      } catch {
      }
  }
  return null;
}
function xw(o) {
  switch (typeof o) {
    case "boolean":
    case "number":
    case "object":
    case "string":
    case "undefined":
      return o;
    default:
      return "";
  }
}
function _de(o) {
  var r = o.type;
  return (o = o.nodeName) && o.toLowerCase() === "input" && (r === "checkbox" || r === "radio");
}
function rge(o) {
  var r = _de(o) ? "checked" : "value", i = Object.getOwnPropertyDescriptor(o.constructor.prototype, r), u = "" + o[r];
  if (!o.hasOwnProperty(r) && typeof i < "u" && typeof i.get == "function" && typeof i.set == "function") {
    var h = i.get, y = i.set;
    return Object.defineProperty(o, r, { configurable: !0, get: function() {
      return h.call(this);
    }, set: function(k) {
      u = "" + k, y.call(this, k);
    } }), Object.defineProperty(o, r, { enumerable: i.enumerable }), { getValue: function() {
      return u;
    }, setValue: function(k) {
      u = "" + k;
    }, stopTracking: function() {
      o._valueTracker = null, delete o[r];
    } };
  }
}
function p9(o) {
  o._valueTracker || (o._valueTracker = rge(o));
}
function Ede(o) {
  if (!o) return !1;
  var r = o._valueTracker;
  if (!r) return !0;
  var i = r.getValue(), u = "";
  return o && (u = _de(o) ? o.checked ? "true" : "false" : o.value), o = u, o !== i ? (r.setValue(o), !0) : !1;
}
function lV(o) {
  if (o = o || (typeof document < "u" ? document : void 0), typeof o > "u") return null;
  try {
    return o.activeElement || o.body;
  } catch {
    return o.body;
  }
}
function Jte(o, r) {
  var i = r.checked;
  return xl({}, r, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: i ?? o._wrapperState.initialChecked });
}
function Bie(o, r) {
  var i = r.defaultValue == null ? "" : r.defaultValue, u = r.checked != null ? r.checked : r.defaultChecked;
  i = xw(r.value != null ? r.value : i), o._wrapperState = { initialChecked: u, initialValue: i, controlled: r.type === "checkbox" || r.type === "radio" ? r.checked != null : r.value != null };
}
function Tde(o, r) {
  r = r.checked, r != null && Qoe(o, "checked", r, !1);
}
function ene(o, r) {
  Tde(o, r);
  var i = xw(r.value), u = r.type;
  if (i != null) u === "number" ? (i === 0 && o.value === "" || o.value != i) && (o.value = "" + i) : o.value !== "" + i && (o.value = "" + i);
  else if (u === "submit" || u === "reset") {
    o.removeAttribute("value");
    return;
  }
  r.hasOwnProperty("value") ? tne(o, r.type, i) : r.hasOwnProperty("defaultValue") && tne(o, r.type, xw(r.defaultValue)), r.checked == null && r.defaultChecked != null && (o.defaultChecked = !!r.defaultChecked);
}
function $ie(o, r, i) {
  if (r.hasOwnProperty("value") || r.hasOwnProperty("defaultValue")) {
    var u = r.type;
    if (!(u !== "submit" && u !== "reset" || r.value !== void 0 && r.value !== null)) return;
    r = "" + o._wrapperState.initialValue, i || r === o.value || (o.value = r), o.defaultValue = r;
  }
  i = o.name, i !== "" && (o.name = ""), o.defaultChecked = !!o._wrapperState.initialChecked, i !== "" && (o.name = i);
}
function tne(o, r, i) {
  (r !== "number" || lV(o.ownerDocument) !== o) && (i == null ? o.defaultValue = "" + o._wrapperState.initialValue : o.defaultValue !== "" + i && (o.defaultValue = "" + i));
}
function sge(o) {
  var r = "";
  return XV.Children.forEach(o, function(i) {
    i != null && (r += i);
  }), r;
}
function nne(o, r) {
  return o = xl({ children: void 0 }, r), (r = sge(r.children)) && (o.children = r), o;
}
function f3(o, r, i, u) {
  if (o = o.options, r) {
    r = {};
    for (var h = 0; h < i.length; h++) r["$" + i[h]] = !0;
    for (i = 0; i < o.length; i++) h = r.hasOwnProperty("$" + o[i].value), o[i].selected !== h && (o[i].selected = h), h && u && (o[i].defaultSelected = !0);
  } else {
    for (i = "" + xw(i), r = null, h = 0; h < o.length; h++) {
      if (o[h].value === i) {
        o[h].selected = !0, u && (o[h].defaultSelected = !0);
        return;
      }
      r !== null || o[h].disabled || (r = o[h]);
    }
    r !== null && (r.selected = !0);
  }
}
function one(o, r) {
  if (r.dangerouslySetInnerHTML != null) throw Error(ho(91));
  return xl({}, r, { value: void 0, defaultValue: void 0, children: "" + o._wrapperState.initialValue });
}
function Lie(o, r) {
  var i = r.value;
  if (i == null) {
    if (i = r.children, r = r.defaultValue, i != null) {
      if (r != null) throw Error(ho(92));
      if (Array.isArray(i)) {
        if (!(1 >= i.length)) throw Error(ho(93));
        i = i[0];
      }
      r = i;
    }
    r == null && (r = ""), i = r;
  }
  o._wrapperState = { initialValue: xw(i) };
}
function Ode(o, r) {
  var i = xw(r.value), u = xw(r.defaultValue);
  i != null && (i = "" + i, i !== o.value && (o.value = i), r.defaultValue == null && o.defaultValue !== i && (o.defaultValue = i)), u != null && (o.defaultValue = "" + u);
}
function Hie(o) {
  var r = o.textContent;
  r === o._wrapperState.initialValue && r !== "" && r !== null && (o.value = r);
}
var rne = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
function Ade(o) {
  switch (o) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function sne(o, r) {
  return o == null || o === "http://www.w3.org/1999/xhtml" ? Ade(r) : o === "http://www.w3.org/2000/svg" && r === "foreignObject" ? "http://www.w3.org/1999/xhtml" : o;
}
var h9, Pde = function(o) {
  return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(r, i, u, h) {
    MSApp.execUnsafeLocalFunction(function() {
      return o(r, i, u, h);
    });
  } : o;
}(function(o, r) {
  if (o.namespaceURI !== rne.svg || "innerHTML" in o) o.innerHTML = r;
  else {
    for (h9 = h9 || document.createElement("div"), h9.innerHTML = "<svg>" + r.valueOf().toString() + "</svg>", r = h9.firstChild; o.firstChild; ) o.removeChild(o.firstChild);
    for (; r.firstChild; ) o.appendChild(r.firstChild);
  }
});
function e5(o, r) {
  if (r) {
    var i = o.firstChild;
    if (i && i === o.lastChild && i.nodeType === 3) {
      i.nodeValue = r;
      return;
    }
  }
  o.textContent = r;
}
var $I = {
  animationIterationCount: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridArea: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
}, age = ["Webkit", "ms", "Moz", "O"];
Object.keys($I).forEach(function(o) {
  age.forEach(function(r) {
    r = r + o.charAt(0).toUpperCase() + o.substring(1), $I[r] = $I[o];
  });
});
function Dde(o, r, i) {
  return r == null || typeof r == "boolean" || r === "" ? "" : i || typeof r != "number" || r === 0 || $I.hasOwnProperty(o) && $I[o] ? ("" + r).trim() : r + "px";
}
function Rde(o, r) {
  o = o.style;
  for (var i in r) if (r.hasOwnProperty(i)) {
    var u = i.indexOf("--") === 0, h = Dde(i, r[i], u);
    i === "float" && (i = "cssFloat"), u ? o.setProperty(i, h) : o[i] = h;
  }
}
var ige = xl({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
function ane(o, r) {
  if (r) {
    if (ige[o] && (r.children != null || r.dangerouslySetInnerHTML != null)) throw Error(ho(137, o));
    if (r.dangerouslySetInnerHTML != null) {
      if (r.children != null) throw Error(ho(60));
      if (!(typeof r.dangerouslySetInnerHTML == "object" && "__html" in r.dangerouslySetInnerHTML)) throw Error(ho(61));
    }
    if (r.style != null && typeof r.style != "object") throw Error(ho(62));
  }
}
function ine(o, r) {
  if (o.indexOf("-") === -1) return typeof r.is == "string";
  switch (o) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
function are(o) {
  return o = o.target || o.srcElement || window, o.correspondingUseElement && (o = o.correspondingUseElement), o.nodeType === 3 ? o.parentNode : o;
}
var lne = null, m3 = null, p3 = null;
function zie(o) {
  if (o = Y5(o)) {
    if (typeof lne != "function") throw Error(ho(280));
    var r = o.stateNode;
    r && (r = sj(r), lne(o.stateNode, o.type, r));
  }
}
function Nde(o) {
  m3 ? p3 ? p3.push(o) : p3 = [o] : m3 = o;
}
function Mde() {
  if (m3) {
    var o = m3, r = p3;
    if (p3 = m3 = null, zie(o), r) for (o = 0; o < r.length; o++) zie(r[o]);
  }
}
function ire(o, r) {
  return o(r);
}
function Ide(o, r, i, u, h) {
  return o(r, i, u, h);
}
function lre() {
}
var Fde = ire, hk = !1, ite = !1;
function cre() {
  (m3 !== null || p3 !== null) && (lre(), Mde());
}
function lge(o, r, i) {
  if (ite) return o(r, i);
  ite = !0;
  try {
    return Fde(o, r, i);
  } finally {
    ite = !1, cre();
  }
}
function t5(o, r) {
  var i = o.stateNode;
  if (i === null) return null;
  var u = sj(i);
  if (u === null) return null;
  i = u[r];
  e: switch (r) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (u = !u.disabled) || (o = o.type, u = !(o === "button" || o === "input" || o === "select" || o === "textarea")), o = !u;
      break e;
    default:
      o = !1;
  }
  if (o) return null;
  if (i && typeof i != "function") throw Error(ho(231, r, typeof i));
  return i;
}
var cne = !1;
if (w0) try {
  var pI = {};
  Object.defineProperty(pI, "passive", { get: function() {
    cne = !0;
  } }), window.addEventListener("test", pI, pI), window.removeEventListener("test", pI, pI);
} catch {
  cne = !1;
}
function cge(o, r, i, u, h, y, k, _, D) {
  var L = Array.prototype.slice.call(arguments, 3);
  try {
    r.apply(i, L);
  } catch (W) {
    this.onError(W);
  }
}
var LI = !1, cV = null, uV = !1, une = null, uge = { onError: function(o) {
  LI = !0, cV = o;
} };
function dge(o, r, i, u, h, y, k, _, D) {
  LI = !1, cV = null, cge.apply(uge, arguments);
}
function fge(o, r, i, u, h, y, k, _, D) {
  if (dge.apply(this, arguments), LI) {
    if (LI) {
      var L = cV;
      LI = !1, cV = null;
    } else throw Error(ho(198));
    uV || (uV = !0, une = L);
  }
}
function $k(o) {
  var r = o, i = o;
  if (o.alternate) for (; r.return; ) r = r.return;
  else {
    o = r;
    do
      r = o, r.flags & 1026 && (i = r.return), o = r.return;
    while (o);
  }
  return r.tag === 3 ? i : null;
}
function Bde(o) {
  if (o.tag === 13) {
    var r = o.memoizedState;
    if (r === null && (o = o.alternate, o !== null && (r = o.memoizedState)), r !== null) return r.dehydrated;
  }
  return null;
}
function Vie(o) {
  if ($k(o) !== o) throw Error(ho(188));
}
function mge(o) {
  var r = o.alternate;
  if (!r) {
    if (r = $k(o), r === null) throw Error(ho(188));
    return r !== o ? null : o;
  }
  for (var i = o, u = r; ; ) {
    var h = i.return;
    if (h === null) break;
    var y = h.alternate;
    if (y === null) {
      if (u = h.return, u !== null) {
        i = u;
        continue;
      }
      break;
    }
    if (h.child === y.child) {
      for (y = h.child; y; ) {
        if (y === i) return Vie(h), o;
        if (y === u) return Vie(h), r;
        y = y.sibling;
      }
      throw Error(ho(188));
    }
    if (i.return !== u.return) i = h, u = y;
    else {
      for (var k = !1, _ = h.child; _; ) {
        if (_ === i) {
          k = !0, i = h, u = y;
          break;
        }
        if (_ === u) {
          k = !0, u = h, i = y;
          break;
        }
        _ = _.sibling;
      }
      if (!k) {
        for (_ = y.child; _; ) {
          if (_ === i) {
            k = !0, i = y, u = h;
            break;
          }
          if (_ === u) {
            k = !0, u = y, i = h;
            break;
          }
          _ = _.sibling;
        }
        if (!k) throw Error(ho(189));
      }
    }
    if (i.alternate !== u) throw Error(ho(190));
  }
  if (i.tag !== 3) throw Error(ho(188));
  return i.stateNode.current === i ? o : r;
}
function $de(o) {
  if (o = mge(o), !o) return null;
  for (var r = o; ; ) {
    if (r.tag === 5 || r.tag === 6) return r;
    if (r.child) r.child.return = r, r = r.child;
    else {
      if (r === o) break;
      for (; !r.sibling; ) {
        if (!r.return || r.return === o) return null;
        r = r.return;
      }
      r.sibling.return = r.return, r = r.sibling;
    }
  }
  return null;
}
function jie(o, r) {
  for (var i = o.alternate; r !== null; ) {
    if (r === o || r === i) return !0;
    r = r.return;
  }
  return !1;
}
var Lde, ure, Hde, zde, dne = !1, fv = [], dw = null, fw = null, mw = null, n5 = /* @__PURE__ */ new Map(), o5 = /* @__PURE__ */ new Map(), hI = [], Uie = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function fne(o, r, i, u, h) {
  return { blockedOn: o, domEventName: r, eventSystemFlags: i | 16, nativeEvent: h, targetContainers: [u] };
}
function Wie(o, r) {
  switch (o) {
    case "focusin":
    case "focusout":
      dw = null;
      break;
    case "dragenter":
    case "dragleave":
      fw = null;
      break;
    case "mouseover":
    case "mouseout":
      mw = null;
      break;
    case "pointerover":
    case "pointerout":
      n5.delete(r.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      o5.delete(r.pointerId);
  }
}
function gI(o, r, i, u, h, y) {
  return o === null || o.nativeEvent !== y ? (o = fne(r, i, u, h, y), r !== null && (r = Y5(r), r !== null && ure(r)), o) : (o.eventSystemFlags |= u, r = o.targetContainers, h !== null && r.indexOf(h) === -1 && r.push(h), o);
}
function pge(o, r, i, u, h) {
  switch (r) {
    case "focusin":
      return dw = gI(dw, o, r, i, u, h), !0;
    case "dragenter":
      return fw = gI(fw, o, r, i, u, h), !0;
    case "mouseover":
      return mw = gI(mw, o, r, i, u, h), !0;
    case "pointerover":
      var y = h.pointerId;
      return n5.set(y, gI(n5.get(y) || null, o, r, i, u, h)), !0;
    case "gotpointercapture":
      return y = h.pointerId, o5.set(y, gI(o5.get(y) || null, o, r, i, u, h)), !0;
  }
  return !1;
}
function hge(o) {
  var r = gk(o.target);
  if (r !== null) {
    var i = $k(r);
    if (i !== null) {
      if (r = i.tag, r === 13) {
        if (r = Bde(i), r !== null) {
          o.blockedOn = r, zde(o.lanePriority, function() {
            Pu.unstable_runWithPriority(o.priority, function() {
              Hde(i);
            });
          });
          return;
        }
      } else if (r === 3 && i.stateNode.hydrate) {
        o.blockedOn = i.tag === 3 ? i.stateNode.containerInfo : null;
        return;
      }
    }
  }
  o.blockedOn = null;
}
function j9(o) {
  if (o.blockedOn !== null) return !1;
  for (var r = o.targetContainers; 0 < r.length; ) {
    var i = pre(o.domEventName, o.eventSystemFlags, r[0], o.nativeEvent);
    if (i !== null) return r = Y5(i), r !== null && ure(r), o.blockedOn = i, !1;
    r.shift();
  }
  return !0;
}
function Zie(o, r, i) {
  j9(o) && i.delete(r);
}
function gge() {
  for (dne = !1; 0 < fv.length; ) {
    var o = fv[0];
    if (o.blockedOn !== null) {
      o = Y5(o.blockedOn), o !== null && Lde(o);
      break;
    }
    for (var r = o.targetContainers; 0 < r.length; ) {
      var i = pre(o.domEventName, o.eventSystemFlags, r[0], o.nativeEvent);
      if (i !== null) {
        o.blockedOn = i;
        break;
      }
      r.shift();
    }
    o.blockedOn === null && fv.shift();
  }
  dw !== null && j9(dw) && (dw = null), fw !== null && j9(fw) && (fw = null), mw !== null && j9(mw) && (mw = null), n5.forEach(Zie), o5.forEach(Zie);
}
function bI(o, r) {
  o.blockedOn === r && (o.blockedOn = null, dne || (dne = !0, Pu.unstable_scheduleCallback(Pu.unstable_NormalPriority, gge)));
}
function Vde(o) {
  function r(h) {
    return bI(h, o);
  }
  if (0 < fv.length) {
    bI(fv[0], o);
    for (var i = 1; i < fv.length; i++) {
      var u = fv[i];
      u.blockedOn === o && (u.blockedOn = null);
    }
  }
  for (dw !== null && bI(dw, o), fw !== null && bI(fw, o), mw !== null && bI(mw, o), n5.forEach(r), o5.forEach(r), i = 0; i < hI.length; i++) u = hI[i], u.blockedOn === o && (u.blockedOn = null);
  for (; 0 < hI.length && (i = hI[0], i.blockedOn === null); ) hge(i), i.blockedOn === null && hI.shift();
}
function g9(o, r) {
  var i = {};
  return i[o.toLowerCase()] = r.toLowerCase(), i["Webkit" + o] = "webkit" + r, i["Moz" + o] = "moz" + r, i;
}
var QA = { animationend: g9("Animation", "AnimationEnd"), animationiteration: g9("Animation", "AnimationIteration"), animationstart: g9("Animation", "AnimationStart"), transitionend: g9("Transition", "TransitionEnd") }, lte = {}, jde = {};
w0 && (jde = document.createElement("div").style, "AnimationEvent" in window || (delete QA.animationend.animation, delete QA.animationiteration.animation, delete QA.animationstart.animation), "TransitionEvent" in window || delete QA.transitionend.transition);
function ej(o) {
  if (lte[o]) return lte[o];
  if (!QA[o]) return o;
  var r = QA[o], i;
  for (i in r) if (r.hasOwnProperty(i) && i in jde) return lte[o] = r[i];
  return o;
}
var Ude = ej("animationend"), Wde = ej("animationiteration"), Zde = ej("animationstart"), Gde = ej("transitionend"), qde = /* @__PURE__ */ new Map(), dre = /* @__PURE__ */ new Map(), bge = [
  "abort",
  "abort",
  Ude,
  "animationEnd",
  Wde,
  "animationIteration",
  Zde,
  "animationStart",
  "canplay",
  "canPlay",
  "canplaythrough",
  "canPlayThrough",
  "durationchange",
  "durationChange",
  "emptied",
  "emptied",
  "encrypted",
  "encrypted",
  "ended",
  "ended",
  "error",
  "error",
  "gotpointercapture",
  "gotPointerCapture",
  "load",
  "load",
  "loadeddata",
  "loadedData",
  "loadedmetadata",
  "loadedMetadata",
  "loadstart",
  "loadStart",
  "lostpointercapture",
  "lostPointerCapture",
  "playing",
  "playing",
  "progress",
  "progress",
  "seeking",
  "seeking",
  "stalled",
  "stalled",
  "suspend",
  "suspend",
  "timeupdate",
  "timeUpdate",
  Gde,
  "transitionEnd",
  "waiting",
  "waiting"
];
function fre(o, r) {
  for (var i = 0; i < o.length; i += 2) {
    var u = o[i], h = o[i + 1];
    h = "on" + (h[0].toUpperCase() + h.slice(1)), dre.set(u, r), qde.set(u, h), Fk(h, [u]);
  }
}
var vge = Pu.unstable_now;
vge();
var Vi = 8;
function YA(o) {
  if (1 & o) return Vi = 15, 1;
  if (2 & o) return Vi = 14, 2;
  if (4 & o) return Vi = 13, 4;
  var r = 24 & o;
  return r !== 0 ? (Vi = 12, r) : o & 32 ? (Vi = 11, 32) : (r = 192 & o, r !== 0 ? (Vi = 10, r) : o & 256 ? (Vi = 9, 256) : (r = 3584 & o, r !== 0 ? (Vi = 8, r) : o & 4096 ? (Vi = 7, 4096) : (r = 4186112 & o, r !== 0 ? (Vi = 6, r) : (r = 62914560 & o, r !== 0 ? (Vi = 5, r) : o & 67108864 ? (Vi = 4, 67108864) : o & 134217728 ? (Vi = 3, 134217728) : (r = 805306368 & o, r !== 0 ? (Vi = 2, r) : 1073741824 & o ? (Vi = 1, 1073741824) : (Vi = 8, o))))));
}
function yge(o) {
  switch (o) {
    case 99:
      return 15;
    case 98:
      return 10;
    case 97:
    case 96:
      return 8;
    case 95:
      return 2;
    default:
      return 0;
  }
}
function xge(o) {
  switch (o) {
    case 15:
    case 14:
      return 99;
    case 13:
    case 12:
    case 11:
    case 10:
      return 98;
    case 9:
    case 8:
    case 7:
    case 6:
    case 4:
    case 5:
      return 97;
    case 3:
    case 2:
    case 1:
      return 95;
    case 0:
      return 90;
    default:
      throw Error(ho(358, o));
  }
}
function r5(o, r) {
  var i = o.pendingLanes;
  if (i === 0) return Vi = 0;
  var u = 0, h = 0, y = o.expiredLanes, k = o.suspendedLanes, _ = o.pingedLanes;
  if (y !== 0) u = y, h = Vi = 15;
  else if (y = i & 134217727, y !== 0) {
    var D = y & ~k;
    D !== 0 ? (u = YA(D), h = Vi) : (_ &= y, _ !== 0 && (u = YA(_), h = Vi));
  } else y = i & ~k, y !== 0 ? (u = YA(y), h = Vi) : _ !== 0 && (u = YA(_), h = Vi);
  if (u === 0) return 0;
  if (u = 31 - ww(u), u = i & ((0 > u ? 0 : 1 << u) << 1) - 1, r !== 0 && r !== u && !(r & k)) {
    if (YA(r), h <= Vi) return r;
    Vi = h;
  }
  if (r = o.entangledLanes, r !== 0) for (o = o.entanglements, r &= u; 0 < r; ) i = 31 - ww(r), h = 1 << i, u |= o[i], r &= ~h;
  return u;
}
function Kde(o) {
  return o = o.pendingLanes & -1073741825, o !== 0 ? o : o & 1073741824 ? 1073741824 : 0;
}
function dV(o, r) {
  switch (o) {
    case 15:
      return 1;
    case 14:
      return 2;
    case 12:
      return o = XA(24 & ~r), o === 0 ? dV(10, r) : o;
    case 10:
      return o = XA(192 & ~r), o === 0 ? dV(8, r) : o;
    case 8:
      return o = XA(3584 & ~r), o === 0 && (o = XA(4186112 & ~r), o === 0 && (o = 512)), o;
    case 2:
      return r = XA(805306368 & ~r), r === 0 && (r = 268435456), r;
  }
  throw Error(ho(358, o));
}
function XA(o) {
  return o & -o;
}
function cte(o) {
  for (var r = [], i = 0; 31 > i; i++) r.push(o);
  return r;
}
function tj(o, r, i) {
  o.pendingLanes |= r;
  var u = r - 1;
  o.suspendedLanes &= u, o.pingedLanes &= u, o = o.eventTimes, r = 31 - ww(r), o[r] = i;
}
var ww = Math.clz32 ? Math.clz32 : Sge, wge = Math.log, Cge = Math.LN2;
function Sge(o) {
  return o === 0 ? 32 : 31 - (wge(o) / Cge | 0) | 0;
}
var kge = Pu.unstable_UserBlockingPriority, _ge = Pu.unstable_runWithPriority, U9 = !0;
function Ege(o, r, i, u) {
  hk || lre();
  var h = mre, y = hk;
  hk = !0;
  try {
    Ide(h, o, r, i, u);
  } finally {
    (hk = y) || cre();
  }
}
function Tge(o, r, i, u) {
  _ge(kge, mre.bind(null, o, r, i, u));
}
function mre(o, r, i, u) {
  if (U9) {
    var h;
    if ((h = (r & 4) === 0) && 0 < fv.length && -1 < Uie.indexOf(o)) o = fne(null, o, r, i, u), fv.push(o);
    else {
      var y = pre(o, r, i, u);
      if (y === null) h && Wie(o, u);
      else {
        if (h) {
          if (-1 < Uie.indexOf(o)) {
            o = fne(y, o, r, i, u), fv.push(o);
            return;
          }
          if (pge(y, o, r, i, u)) return;
          Wie(o, u);
        }
        ife(o, r, u, null, i);
      }
    }
  }
}
function pre(o, r, i, u) {
  var h = are(u);
  if (h = gk(h), h !== null) {
    var y = $k(h);
    if (y === null) h = null;
    else {
      var k = y.tag;
      if (k === 13) {
        if (h = Bde(y), h !== null) return h;
        h = null;
      } else if (k === 3) {
        if (y.stateNode.hydrate) return y.tag === 3 ? y.stateNode.containerInfo : null;
        h = null;
      } else y !== h && (h = null);
    }
  }
  return ife(o, r, u, h, i), null;
}
var iw = null, hre = null, W9 = null;
function Yde() {
  if (W9) return W9;
  var o, r = hre, i = r.length, u, h = "value" in iw ? iw.value : iw.textContent, y = h.length;
  for (o = 0; o < i && r[o] === h[o]; o++) ;
  var k = i - o;
  for (u = 1; u <= k && r[i - u] === h[y - u]; u++) ;
  return W9 = h.slice(o, 1 < u ? 1 - u : void 0);
}
function Z9(o) {
  var r = o.keyCode;
  return "charCode" in o ? (o = o.charCode, o === 0 && r === 13 && (o = 13)) : o = r, o === 10 && (o = 13), 32 <= o || o === 13 ? o : 0;
}
function b9() {
  return !0;
}
function Gie() {
  return !1;
}
function rp(o) {
  function r(i, u, h, y, k) {
    this._reactName = i, this._targetInst = h, this.type = u, this.nativeEvent = y, this.target = k, this.currentTarget = null;
    for (var _ in o) o.hasOwnProperty(_) && (i = o[_], this[_] = i ? i(y) : y[_]);
    return this.isDefaultPrevented = (y.defaultPrevented != null ? y.defaultPrevented : y.returnValue === !1) ? b9 : Gie, this.isPropagationStopped = Gie, this;
  }
  return xl(r.prototype, { preventDefault: function() {
    this.defaultPrevented = !0;
    var i = this.nativeEvent;
    i && (i.preventDefault ? i.preventDefault() : typeof i.returnValue != "unknown" && (i.returnValue = !1), this.isDefaultPrevented = b9);
  }, stopPropagation: function() {
    var i = this.nativeEvent;
    i && (i.stopPropagation ? i.stopPropagation() : typeof i.cancelBubble != "unknown" && (i.cancelBubble = !0), this.isPropagationStopped = b9);
  }, persist: function() {
  }, isPersistent: b9 }), r;
}
var j3 = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(o) {
  return o.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, gre = rp(j3), K5 = xl({}, j3, { view: 0, detail: 0 }), Oge = rp(K5), ute, dte, vI, nj = xl({}, K5, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: bre, button: 0, buttons: 0, relatedTarget: function(o) {
  return o.relatedTarget === void 0 ? o.fromElement === o.srcElement ? o.toElement : o.fromElement : o.relatedTarget;
}, movementX: function(o) {
  return "movementX" in o ? o.movementX : (o !== vI && (vI && o.type === "mousemove" ? (ute = o.screenX - vI.screenX, dte = o.screenY - vI.screenY) : dte = ute = 0, vI = o), ute);
}, movementY: function(o) {
  return "movementY" in o ? o.movementY : dte;
} }), qie = rp(nj), Age = xl({}, nj, { dataTransfer: 0 }), Pge = rp(Age), Dge = xl({}, K5, { relatedTarget: 0 }), fte = rp(Dge), Rge = xl({}, j3, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Nge = rp(Rge), Mge = xl({}, j3, { clipboardData: function(o) {
  return "clipboardData" in o ? o.clipboardData : window.clipboardData;
} }), Ige = rp(Mge), Fge = xl({}, j3, { data: 0 }), Kie = rp(Fge), Bge = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, $ge = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Lge = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Hge(o) {
  var r = this.nativeEvent;
  return r.getModifierState ? r.getModifierState(o) : (o = Lge[o]) ? !!r[o] : !1;
}
function bre() {
  return Hge;
}
var zge = xl({}, K5, { key: function(o) {
  if (o.key) {
    var r = Bge[o.key] || o.key;
    if (r !== "Unidentified") return r;
  }
  return o.type === "keypress" ? (o = Z9(o), o === 13 ? "Enter" : String.fromCharCode(o)) : o.type === "keydown" || o.type === "keyup" ? $ge[o.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: bre, charCode: function(o) {
  return o.type === "keypress" ? Z9(o) : 0;
}, keyCode: function(o) {
  return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
}, which: function(o) {
  return o.type === "keypress" ? Z9(o) : o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
} }), Vge = rp(zge), jge = xl({}, nj, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Yie = rp(jge), Uge = xl({}, K5, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: bre }), Wge = rp(Uge), Zge = xl({}, j3, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Gge = rp(Zge), qge = xl({}, nj, {
  deltaX: function(o) {
    return "deltaX" in o ? o.deltaX : "wheelDeltaX" in o ? -o.wheelDeltaX : 0;
  },
  deltaY: function(o) {
    return "deltaY" in o ? o.deltaY : "wheelDeltaY" in o ? -o.wheelDeltaY : "wheelDelta" in o ? -o.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Kge = rp(qge), Yge = [9, 13, 27, 32], vre = w0 && "CompositionEvent" in window, HI = null;
w0 && "documentMode" in document && (HI = document.documentMode);
var Xge = w0 && "TextEvent" in window && !HI, Xde = w0 && (!vre || HI && 8 < HI && 11 >= HI), Xie = " ", Qie = !1;
function Qde(o, r) {
  switch (o) {
    case "keyup":
      return Yge.indexOf(r.keyCode) !== -1;
    case "keydown":
      return r.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function Jde(o) {
  return o = o.detail, typeof o == "object" && "data" in o ? o.data : null;
}
var JA = !1;
function Qge(o, r) {
  switch (o) {
    case "compositionend":
      return Jde(r);
    case "keypress":
      return r.which !== 32 ? null : (Qie = !0, Xie);
    case "textInput":
      return o = r.data, o === Xie && Qie ? null : o;
    default:
      return null;
  }
}
function Jge(o, r) {
  if (JA) return o === "compositionend" || !vre && Qde(o, r) ? (o = Yde(), W9 = hre = iw = null, JA = !1, o) : null;
  switch (o) {
    case "paste":
      return null;
    case "keypress":
      if (!(r.ctrlKey || r.altKey || r.metaKey) || r.ctrlKey && r.altKey) {
        if (r.char && 1 < r.char.length) return r.char;
        if (r.which) return String.fromCharCode(r.which);
      }
      return null;
    case "compositionend":
      return Xde && r.locale !== "ko" ? null : r.data;
    default:
      return null;
  }
}
var ebe = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
function Jie(o) {
  var r = o && o.nodeName && o.nodeName.toLowerCase();
  return r === "input" ? !!ebe[o.type] : r === "textarea";
}
function efe(o, r, i, u) {
  Nde(u), r = fV(r, "onChange"), 0 < r.length && (i = new gre("onChange", "change", null, i, u), o.push({ event: i, listeners: r }));
}
var zI = null, s5 = null;
function tbe(o) {
  rfe(o, 0);
}
function oj(o) {
  var r = t3(o);
  if (Ede(r)) return o;
}
function nbe(o, r) {
  if (o === "change") return r;
}
var tfe = !1;
if (w0) {
  var mte;
  if (w0) {
    var pte = "oninput" in document;
    if (!pte) {
      var ele = document.createElement("div");
      ele.setAttribute("oninput", "return;"), pte = typeof ele.oninput == "function";
    }
    mte = pte;
  } else mte = !1;
  tfe = mte && (!document.documentMode || 9 < document.documentMode);
}
function tle() {
  zI && (zI.detachEvent("onpropertychange", nfe), s5 = zI = null);
}
function nfe(o) {
  if (o.propertyName === "value" && oj(s5)) {
    var r = [];
    if (efe(r, s5, o, are(o)), o = tbe, hk) o(r);
    else {
      hk = !0;
      try {
        ire(o, r);
      } finally {
        hk = !1, cre();
      }
    }
  }
}
function obe(o, r, i) {
  o === "focusin" ? (tle(), zI = r, s5 = i, zI.attachEvent("onpropertychange", nfe)) : o === "focusout" && tle();
}
function rbe(o) {
  if (o === "selectionchange" || o === "keyup" || o === "keydown") return oj(s5);
}
function sbe(o, r) {
  if (o === "click") return oj(r);
}
function abe(o, r) {
  if (o === "input" || o === "change") return oj(r);
}
function ibe(o, r) {
  return o === r && (o !== 0 || 1 / o === 1 / r) || o !== o && r !== r;
}
var vh = typeof Object.is == "function" ? Object.is : ibe, lbe = Object.prototype.hasOwnProperty;
function a5(o, r) {
  if (vh(o, r)) return !0;
  if (typeof o != "object" || o === null || typeof r != "object" || r === null) return !1;
  var i = Object.keys(o), u = Object.keys(r);
  if (i.length !== u.length) return !1;
  for (u = 0; u < i.length; u++) if (!lbe.call(r, i[u]) || !vh(o[i[u]], r[i[u]])) return !1;
  return !0;
}
function nle(o) {
  for (; o && o.firstChild; ) o = o.firstChild;
  return o;
}
function ole(o, r) {
  var i = nle(o);
  o = 0;
  for (var u; i; ) {
    if (i.nodeType === 3) {
      if (u = o + i.textContent.length, o <= r && u >= r) return { node: i, offset: r - o };
      o = u;
    }
    e: {
      for (; i; ) {
        if (i.nextSibling) {
          i = i.nextSibling;
          break e;
        }
        i = i.parentNode;
      }
      i = void 0;
    }
    i = nle(i);
  }
}
function ofe(o, r) {
  return o && r ? o === r ? !0 : o && o.nodeType === 3 ? !1 : r && r.nodeType === 3 ? ofe(o, r.parentNode) : "contains" in o ? o.contains(r) : o.compareDocumentPosition ? !!(o.compareDocumentPosition(r) & 16) : !1 : !1;
}
function rle() {
  for (var o = window, r = lV(); r instanceof o.HTMLIFrameElement; ) {
    try {
      var i = typeof r.contentWindow.location.href == "string";
    } catch {
      i = !1;
    }
    if (i) o = r.contentWindow;
    else break;
    r = lV(o.document);
  }
  return r;
}
function mne(o) {
  var r = o && o.nodeName && o.nodeName.toLowerCase();
  return r && (r === "input" && (o.type === "text" || o.type === "search" || o.type === "tel" || o.type === "url" || o.type === "password") || r === "textarea" || o.contentEditable === "true");
}
var cbe = w0 && "documentMode" in document && 11 >= document.documentMode, e3 = null, pne = null, VI = null, hne = !1;
function sle(o, r, i) {
  var u = i.window === i ? i.document : i.nodeType === 9 ? i : i.ownerDocument;
  hne || e3 == null || e3 !== lV(u) || (u = e3, "selectionStart" in u && mne(u) ? u = { start: u.selectionStart, end: u.selectionEnd } : (u = (u.ownerDocument && u.ownerDocument.defaultView || window).getSelection(), u = { anchorNode: u.anchorNode, anchorOffset: u.anchorOffset, focusNode: u.focusNode, focusOffset: u.focusOffset }), VI && a5(VI, u) || (VI = u, u = fV(pne, "onSelect"), 0 < u.length && (r = new gre("onSelect", "select", null, r, i), o.push({ event: r, listeners: u }), r.target = e3)));
}
fre(
  "cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
  0
);
fre("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
fre(bge, 2);
for (var ale = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), hte = 0; hte < ale.length; hte++) dre.set(ale[hte], 0);
_3("onMouseEnter", ["mouseout", "mouseover"]);
_3("onMouseLeave", ["mouseout", "mouseover"]);
_3("onPointerEnter", ["pointerout", "pointerover"]);
_3("onPointerLeave", ["pointerout", "pointerover"]);
Fk("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Fk("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Fk("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Fk("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Fk("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Fk("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var PI = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), ube = new Set("cancel close invalid load scroll toggle".split(" ").concat(PI));
function ile(o, r, i) {
  var u = o.type || "unknown-event";
  o.currentTarget = i, fge(u, r, void 0, o), o.currentTarget = null;
}
function rfe(o, r) {
  r = (r & 4) !== 0;
  for (var i = 0; i < o.length; i++) {
    var u = o[i], h = u.event;
    u = u.listeners;
    e: {
      var y = void 0;
      if (r) for (var k = u.length - 1; 0 <= k; k--) {
        var _ = u[k], D = _.instance, L = _.currentTarget;
        if (_ = _.listener, D !== y && h.isPropagationStopped()) break e;
        ile(h, _, L), y = D;
      }
      else for (k = 0; k < u.length; k++) {
        if (_ = u[k], D = _.instance, L = _.currentTarget, _ = _.listener, D !== y && h.isPropagationStopped()) break e;
        ile(h, _, L), y = D;
      }
    }
  }
  if (uV) throw o = une, uV = !1, une = null, o;
}
function sl(o, r) {
  var i = cfe(r), u = o + "__bubble";
  i.has(u) || (afe(r, o, 2, !1), i.add(u));
}
var lle = "_reactListening" + Math.random().toString(36).slice(2);
function sfe(o) {
  o[lle] || (o[lle] = !0, Sde.forEach(function(r) {
    ube.has(r) || cle(r, !1, o, null), cle(r, !0, o, null);
  }));
}
function cle(o, r, i, u) {
  var h = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : 0, y = i;
  o === "selectionchange" && i.nodeType !== 9 && (y = i.ownerDocument);
  var k = cfe(y), _ = o + "__" + (r ? "capture" : "bubble");
  k.has(_) || (r && (h |= 4), afe(y, o, h, r), k.add(_));
}
function afe(o, r, i, u) {
  var h = dre.get(r);
  switch (h === void 0 ? 2 : h) {
    case 0:
      h = Ege;
      break;
    case 1:
      h = Tge;
      break;
    default:
      h = mre;
  }
  i = h.bind(null, r, i, o), h = void 0, !cne || r !== "touchstart" && r !== "touchmove" && r !== "wheel" || (h = !0), u ? h !== void 0 ? o.addEventListener(r, i, { capture: !0, passive: h }) : o.addEventListener(r, i, !0) : h !== void 0 ? o.addEventListener(r, i, { passive: h }) : o.addEventListener(r, i, !1);
}
function ife(o, r, i, u, h) {
  var y = u;
  if (!(r & 1) && !(r & 2) && u !== null) e: for (; ; ) {
    if (u === null) return;
    var k = u.tag;
    if (k === 3 || k === 4) {
      var _ = u.stateNode.containerInfo;
      if (_ === h || _.nodeType === 8 && _.parentNode === h) break;
      if (k === 4) for (k = u.return; k !== null; ) {
        var D = k.tag;
        if ((D === 3 || D === 4) && (D = k.stateNode.containerInfo, D === h || D.nodeType === 8 && D.parentNode === h)) return;
        k = k.return;
      }
      for (; _ !== null; ) {
        if (k = gk(_), k === null) return;
        if (D = k.tag, D === 5 || D === 6) {
          u = y = k;
          continue e;
        }
        _ = _.parentNode;
      }
    }
    u = u.return;
  }
  lge(function() {
    var L = y, W = are(i), se = [];
    e: {
      var J = qde.get(o);
      if (J !== void 0) {
        var be = gre, ke = o;
        switch (o) {
          case "keypress":
            if (Z9(i) === 0) break e;
          case "keydown":
          case "keyup":
            be = Vge;
            break;
          case "focusin":
            ke = "focus", be = fte;
            break;
          case "focusout":
            ke = "blur", be = fte;
            break;
          case "beforeblur":
          case "afterblur":
            be = fte;
            break;
          case "click":
            if (i.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            be = qie;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            be = Pge;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            be = Wge;
            break;
          case Ude:
          case Wde:
          case Zde:
            be = Nge;
            break;
          case Gde:
            be = Gge;
            break;
          case "scroll":
            be = Oge;
            break;
          case "wheel":
            be = Kge;
            break;
          case "copy":
          case "cut":
          case "paste":
            be = Ige;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            be = Yie;
        }
        var Ce = (r & 4) !== 0, Q = !Ce && o === "scroll", oe = Ce ? J !== null ? J + "Capture" : null : J;
        Ce = [];
        for (var ae = L, G; ae !== null; ) {
          G = ae;
          var ve = G.stateNode;
          if (G.tag === 5 && ve !== null && (G = ve, oe !== null && (ve = t5(ae, oe), ve != null && Ce.push(i5(ae, ve, G)))), Q) break;
          ae = ae.return;
        }
        0 < Ce.length && (J = new be(J, ke, null, i, W), se.push({ event: J, listeners: Ce }));
      }
    }
    if (!(r & 7)) {
      e: {
        if (J = o === "mouseover" || o === "pointerover", be = o === "mouseout" || o === "pointerout", J && !(r & 16) && (ke = i.relatedTarget || i.fromElement) && (gk(ke) || ke[U3])) break e;
        if ((be || J) && (J = W.window === W ? W : (J = W.ownerDocument) ? J.defaultView || J.parentWindow : window, be ? (ke = i.relatedTarget || i.toElement, be = L, ke = ke ? gk(ke) : null, ke !== null && (Q = $k(ke), ke !== Q || ke.tag !== 5 && ke.tag !== 6) && (ke = null)) : (be = null, ke = L), be !== ke)) {
          if (Ce = qie, ve = "onMouseLeave", oe = "onMouseEnter", ae = "mouse", (o === "pointerout" || o === "pointerover") && (Ce = Yie, ve = "onPointerLeave", oe = "onPointerEnter", ae = "pointer"), Q = be == null ? J : t3(be), G = ke == null ? J : t3(ke), J = new Ce(ve, ae + "leave", be, i, W), J.target = Q, J.relatedTarget = G, ve = null, gk(W) === L && (Ce = new Ce(oe, ae + "enter", ke, i, W), Ce.target = G, Ce.relatedTarget = Q, ve = Ce), Q = ve, be && ke) t: {
            for (Ce = be, oe = ke, ae = 0, G = Ce; G; G = WA(G)) ae++;
            for (G = 0, ve = oe; ve; ve = WA(ve)) G++;
            for (; 0 < ae - G; ) Ce = WA(Ce), ae--;
            for (; 0 < G - ae; ) oe = WA(oe), G--;
            for (; ae--; ) {
              if (Ce === oe || oe !== null && Ce === oe.alternate) break t;
              Ce = WA(Ce), oe = WA(oe);
            }
            Ce = null;
          }
          else Ce = null;
          be !== null && ule(se, J, be, Ce, !1), ke !== null && Q !== null && ule(se, Q, ke, Ce, !0);
        }
      }
      e: {
        if (J = L ? t3(L) : window, be = J.nodeName && J.nodeName.toLowerCase(), be === "select" || be === "input" && J.type === "file") var nt = nbe;
        else if (Jie(J)) if (tfe) nt = abe;
        else {
          nt = rbe;
          var Xe = obe;
        }
        else (be = J.nodeName) && be.toLowerCase() === "input" && (J.type === "checkbox" || J.type === "radio") && (nt = sbe);
        if (nt && (nt = nt(o, L))) {
          efe(se, nt, i, W);
          break e;
        }
        Xe && Xe(o, J, L), o === "focusout" && (Xe = J._wrapperState) && Xe.controlled && J.type === "number" && tne(J, "number", J.value);
      }
      switch (Xe = L ? t3(L) : window, o) {
        case "focusin":
          (Jie(Xe) || Xe.contentEditable === "true") && (e3 = Xe, pne = L, VI = null);
          break;
        case "focusout":
          VI = pne = e3 = null;
          break;
        case "mousedown":
          hne = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          hne = !1, sle(se, i, W);
          break;
        case "selectionchange":
          if (cbe) break;
        case "keydown":
        case "keyup":
          sle(se, i, W);
      }
      var te;
      if (vre) e: {
        switch (o) {
          case "compositionstart":
            var lt = "onCompositionStart";
            break e;
          case "compositionend":
            lt = "onCompositionEnd";
            break e;
          case "compositionupdate":
            lt = "onCompositionUpdate";
            break e;
        }
        lt = void 0;
      }
      else JA ? Qde(o, i) && (lt = "onCompositionEnd") : o === "keydown" && i.keyCode === 229 && (lt = "onCompositionStart");
      lt && (Xde && i.locale !== "ko" && (JA || lt !== "onCompositionStart" ? lt === "onCompositionEnd" && JA && (te = Yde()) : (iw = W, hre = "value" in iw ? iw.value : iw.textContent, JA = !0)), Xe = fV(L, lt), 0 < Xe.length && (lt = new Kie(lt, o, null, i, W), se.push({ event: lt, listeners: Xe }), te ? lt.data = te : (te = Jde(i), te !== null && (lt.data = te)))), (te = Xge ? Qge(o, i) : Jge(o, i)) && (L = fV(L, "onBeforeInput"), 0 < L.length && (W = new Kie(
        "onBeforeInput",
        "beforeinput",
        null,
        i,
        W
      ), se.push({ event: W, listeners: L }), W.data = te));
    }
    rfe(se, r);
  });
}
function i5(o, r, i) {
  return { instance: o, listener: r, currentTarget: i };
}
function fV(o, r) {
  for (var i = r + "Capture", u = []; o !== null; ) {
    var h = o, y = h.stateNode;
    h.tag === 5 && y !== null && (h = y, y = t5(o, i), y != null && u.unshift(i5(o, y, h)), y = t5(o, r), y != null && u.push(i5(o, y, h))), o = o.return;
  }
  return u;
}
function WA(o) {
  if (o === null) return null;
  do
    o = o.return;
  while (o && o.tag !== 5);
  return o || null;
}
function ule(o, r, i, u, h) {
  for (var y = r._reactName, k = []; i !== null && i !== u; ) {
    var _ = i, D = _.alternate, L = _.stateNode;
    if (D !== null && D === u) break;
    _.tag === 5 && L !== null && (_ = L, h ? (D = t5(i, y), D != null && k.unshift(i5(i, D, _))) : h || (D = t5(i, y), D != null && k.push(i5(i, D, _)))), i = i.return;
  }
  k.length !== 0 && o.push({ event: r, listeners: k });
}
function mV() {
}
var gte = null, bte = null;
function lfe(o, r) {
  switch (o) {
    case "button":
    case "input":
    case "select":
    case "textarea":
      return !!r.autoFocus;
  }
  return !1;
}
function gne(o, r) {
  return o === "textarea" || o === "option" || o === "noscript" || typeof r.children == "string" || typeof r.children == "number" || typeof r.dangerouslySetInnerHTML == "object" && r.dangerouslySetInnerHTML !== null && r.dangerouslySetInnerHTML.__html != null;
}
var dle = typeof setTimeout == "function" ? setTimeout : void 0, dbe = typeof clearTimeout == "function" ? clearTimeout : void 0;
function yre(o) {
  o.nodeType === 1 ? o.textContent = "" : o.nodeType === 9 && (o = o.body, o != null && (o.textContent = ""));
}
function h3(o) {
  for (; o != null; o = o.nextSibling) {
    var r = o.nodeType;
    if (r === 1 || r === 3) break;
  }
  return o;
}
function fle(o) {
  o = o.previousSibling;
  for (var r = 0; o; ) {
    if (o.nodeType === 8) {
      var i = o.data;
      if (i === "$" || i === "$!" || i === "$?") {
        if (r === 0) return o;
        r--;
      } else i === "/$" && r++;
    }
    o = o.previousSibling;
  }
  return null;
}
var vte = 0;
function fbe(o) {
  return { $$typeof: rre, toString: o, valueOf: o };
}
var rj = Math.random().toString(36).slice(2), lw = "__reactFiber$" + rj, pV = "__reactProps$" + rj, U3 = "__reactContainer$" + rj, mle = "__reactEvents$" + rj;
function gk(o) {
  var r = o[lw];
  if (r) return r;
  for (var i = o.parentNode; i; ) {
    if (r = i[U3] || i[lw]) {
      if (i = r.alternate, r.child !== null || i !== null && i.child !== null) for (o = fle(o); o !== null; ) {
        if (i = o[lw]) return i;
        o = fle(o);
      }
      return r;
    }
    o = i, i = o.parentNode;
  }
  return null;
}
function Y5(o) {
  return o = o[lw] || o[U3], !o || o.tag !== 5 && o.tag !== 6 && o.tag !== 13 && o.tag !== 3 ? null : o;
}
function t3(o) {
  if (o.tag === 5 || o.tag === 6) return o.stateNode;
  throw Error(ho(33));
}
function sj(o) {
  return o[pV] || null;
}
function cfe(o) {
  var r = o[mle];
  return r === void 0 && (r = o[mle] = /* @__PURE__ */ new Set()), r;
}
var bne = [], n3 = -1;
function Pw(o) {
  return { current: o };
}
function il(o) {
  0 > n3 || (o.current = bne[n3], bne[n3] = null, n3--);
}
function ql(o, r) {
  n3++, bne[n3] = o.current, o.current = r;
}
var Cw = {}, Ud = Pw(Cw), pm = Pw(!1), Ok = Cw;
function E3(o, r) {
  var i = o.type.contextTypes;
  if (!i) return Cw;
  var u = o.stateNode;
  if (u && u.__reactInternalMemoizedUnmaskedChildContext === r) return u.__reactInternalMemoizedMaskedChildContext;
  var h = {}, y;
  for (y in i) h[y] = r[y];
  return u && (o = o.stateNode, o.__reactInternalMemoizedUnmaskedChildContext = r, o.__reactInternalMemoizedMaskedChildContext = h), h;
}
function hm(o) {
  return o = o.childContextTypes, o != null;
}
function hV() {
  il(pm), il(Ud);
}
function ple(o, r, i) {
  if (Ud.current !== Cw) throw Error(ho(168));
  ql(Ud, r), ql(pm, i);
}
function ufe(o, r, i) {
  var u = o.stateNode;
  if (o = r.childContextTypes, typeof u.getChildContext != "function") return i;
  u = u.getChildContext();
  for (var h in u) if (!(h in o)) throw Error(ho(108, d3(r) || "Unknown", h));
  return xl({}, i, u);
}
function G9(o) {
  return o = (o = o.stateNode) && o.__reactInternalMemoizedMergedChildContext || Cw, Ok = Ud.current, ql(Ud, o), ql(pm, pm.current), !0;
}
function hle(o, r, i) {
  var u = o.stateNode;
  if (!u) throw Error(ho(169));
  i ? (o = ufe(o, r, Ok), u.__reactInternalMemoizedMergedChildContext = o, il(pm), il(Ud), ql(Ud, o)) : il(pm), ql(pm, i);
}
var xre = null, kk = null, mbe = Pu.unstable_runWithPriority, wre = Pu.unstable_scheduleCallback, vne = Pu.unstable_cancelCallback, pbe = Pu.unstable_shouldYield, gle = Pu.unstable_requestPaint, yne = Pu.unstable_now, hbe = Pu.unstable_getCurrentPriorityLevel, aj = Pu.unstable_ImmediatePriority, dfe = Pu.unstable_UserBlockingPriority, ffe = Pu.unstable_NormalPriority, mfe = Pu.unstable_LowPriority, pfe = Pu.unstable_IdlePriority, yte = {}, gbe = gle !== void 0 ? gle : function() {
}, h0 = null, q9 = null, xte = !1, ble = yne(), Hd = 1e4 > ble ? yne : function() {
  return yne() - ble;
};
function T3() {
  switch (hbe()) {
    case aj:
      return 99;
    case dfe:
      return 98;
    case ffe:
      return 97;
    case mfe:
      return 96;
    case pfe:
      return 95;
    default:
      throw Error(ho(332));
  }
}
function hfe(o) {
  switch (o) {
    case 99:
      return aj;
    case 98:
      return dfe;
    case 97:
      return ffe;
    case 96:
      return mfe;
    case 95:
      return pfe;
    default:
      throw Error(ho(332));
  }
}
function Ak(o, r) {
  return o = hfe(o), mbe(o, r);
}
function l5(o, r, i) {
  return o = hfe(o), wre(o, r, i);
}
function wv() {
  if (q9 !== null) {
    var o = q9;
    q9 = null, vne(o);
  }
  gfe();
}
function gfe() {
  if (!xte && h0 !== null) {
    xte = !0;
    var o = 0;
    try {
      var r = h0;
      Ak(99, function() {
        for (; o < r.length; o++) {
          var i = r[o];
          do
            i = i(!0);
          while (i !== null);
        }
      }), h0 = null;
    } catch (i) {
      throw h0 !== null && (h0 = h0.slice(o + 1)), wre(aj, wv), i;
    } finally {
      xte = !1;
    }
  }
}
var bbe = Bk.ReactCurrentBatchConfig;
function Hg(o, r) {
  if (o && o.defaultProps) {
    r = xl({}, r), o = o.defaultProps;
    for (var i in o) r[i] === void 0 && (r[i] = o[i]);
    return r;
  }
  return r;
}
var gV = Pw(null), bV = null, o3 = null, vV = null;
function Cre() {
  vV = o3 = bV = null;
}
function Sre(o) {
  var r = gV.current;
  il(gV), o.type._context._currentValue = r;
}
function bfe(o, r) {
  for (; o !== null; ) {
    var i = o.alternate;
    if ((o.childLanes & r) === r) {
      if (i === null || (i.childLanes & r) === r) break;
      i.childLanes |= r;
    } else o.childLanes |= r, i !== null && (i.childLanes |= r);
    o = o.return;
  }
}
function g3(o, r) {
  bV = o, vV = o3 = null, o = o.dependencies, o !== null && o.firstContext !== null && (o.lanes & r && (Vg = !0), o.firstContext = null);
}
function Ch(o, r) {
  if (vV !== o && r !== !1 && r !== 0)
    if ((typeof r != "number" || r === 1073741823) && (vV = o, r = 1073741823), r = { context: o, observedBits: r, next: null }, o3 === null) {
      if (bV === null) throw Error(ho(308));
      o3 = r, bV.dependencies = { lanes: 0, firstContext: r, responders: null };
    } else o3 = o3.next = r;
  return o._currentValue;
}
var rw = !1;
function kre(o) {
  o.updateQueue = { baseState: o.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
}
function vfe(o, r) {
  o = o.updateQueue, r.updateQueue === o && (r.updateQueue = { baseState: o.baseState, firstBaseUpdate: o.firstBaseUpdate, lastBaseUpdate: o.lastBaseUpdate, shared: o.shared, effects: o.effects });
}
function pw(o, r) {
  return { eventTime: o, lane: r, tag: 0, payload: null, callback: null, next: null };
}
function hw(o, r) {
  if (o = o.updateQueue, o !== null) {
    o = o.shared;
    var i = o.pending;
    i === null ? r.next = r : (r.next = i.next, i.next = r), o.pending = r;
  }
}
function vle(o, r) {
  var i = o.updateQueue, u = o.alternate;
  if (u !== null && (u = u.updateQueue, i === u)) {
    var h = null, y = null;
    if (i = i.firstBaseUpdate, i !== null) {
      do {
        var k = { eventTime: i.eventTime, lane: i.lane, tag: i.tag, payload: i.payload, callback: i.callback, next: null };
        y === null ? h = y = k : y = y.next = k, i = i.next;
      } while (i !== null);
      y === null ? h = y = r : y = y.next = r;
    } else h = y = r;
    i = { baseState: u.baseState, firstBaseUpdate: h, lastBaseUpdate: y, shared: u.shared, effects: u.effects }, o.updateQueue = i;
    return;
  }
  o = i.lastBaseUpdate, o === null ? i.firstBaseUpdate = r : o.next = r, i.lastBaseUpdate = r;
}
function c5(o, r, i, u) {
  var h = o.updateQueue;
  rw = !1;
  var y = h.firstBaseUpdate, k = h.lastBaseUpdate, _ = h.shared.pending;
  if (_ !== null) {
    h.shared.pending = null;
    var D = _, L = D.next;
    D.next = null, k === null ? y = L : k.next = L, k = D;
    var W = o.alternate;
    if (W !== null) {
      W = W.updateQueue;
      var se = W.lastBaseUpdate;
      se !== k && (se === null ? W.firstBaseUpdate = L : se.next = L, W.lastBaseUpdate = D);
    }
  }
  if (y !== null) {
    se = h.baseState, k = 0, W = L = D = null;
    do {
      _ = y.lane;
      var J = y.eventTime;
      if ((u & _) === _) {
        W !== null && (W = W.next = {
          eventTime: J,
          lane: 0,
          tag: y.tag,
          payload: y.payload,
          callback: y.callback,
          next: null
        });
        e: {
          var be = o, ke = y;
          switch (_ = r, J = i, ke.tag) {
            case 1:
              if (be = ke.payload, typeof be == "function") {
                se = be.call(J, se, _);
                break e;
              }
              se = be;
              break e;
            case 3:
              be.flags = be.flags & -4097 | 64;
            case 0:
              if (be = ke.payload, _ = typeof be == "function" ? be.call(J, se, _) : be, _ == null) break e;
              se = xl({}, se, _);
              break e;
            case 2:
              rw = !0;
          }
        }
        y.callback !== null && (o.flags |= 32, _ = h.effects, _ === null ? h.effects = [y] : _.push(y));
      } else J = { eventTime: J, lane: _, tag: y.tag, payload: y.payload, callback: y.callback, next: null }, W === null ? (L = W = J, D = se) : W = W.next = J, k |= _;
      if (y = y.next, y === null) {
        if (_ = h.shared.pending, _ === null) break;
        y = _.next, _.next = null, h.lastBaseUpdate = _, h.shared.pending = null;
      }
    } while (!0);
    W === null && (D = se), h.baseState = D, h.firstBaseUpdate = L, h.lastBaseUpdate = W, Q5 |= k, o.lanes = k, o.memoizedState = se;
  }
}
function yle(o, r, i) {
  if (o = r.effects, r.effects = null, o !== null) for (r = 0; r < o.length; r++) {
    var u = o[r], h = u.callback;
    if (h !== null) {
      if (u.callback = null, u = i, typeof h != "function") throw Error(ho(191, h));
      h.call(u);
    }
  }
}
var yfe = new XV.Component().refs;
function yV(o, r, i, u) {
  r = o.memoizedState, i = i(u, r), i = i == null ? r : xl({}, r, i), o.memoizedState = i, o.lanes === 0 && (o.updateQueue.baseState = i);
}
var ij = { isMounted: function(o) {
  return (o = o._reactInternals) ? $k(o) === o : !1;
}, enqueueSetState: function(o, r, i) {
  o = o._reactInternals;
  var u = np(), h = gw(o), y = pw(u, h);
  y.payload = r, i != null && (y.callback = i), hw(o, y), bw(o, h, u);
}, enqueueReplaceState: function(o, r, i) {
  o = o._reactInternals;
  var u = np(), h = gw(o), y = pw(u, h);
  y.tag = 1, y.payload = r, i != null && (y.callback = i), hw(o, y), bw(o, h, u);
}, enqueueForceUpdate: function(o, r) {
  o = o._reactInternals;
  var i = np(), u = gw(o), h = pw(i, u);
  h.tag = 2, r != null && (h.callback = r), hw(o, h), bw(o, u, i);
} };
function xle(o, r, i, u, h, y, k) {
  return o = o.stateNode, typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(u, y, k) : r.prototype && r.prototype.isPureReactComponent ? !a5(i, u) || !a5(h, y) : !0;
}
function xfe(o, r, i) {
  var u = !1, h = Cw, y = r.contextType;
  return typeof y == "object" && y !== null ? y = Ch(y) : (h = hm(r) ? Ok : Ud.current, u = r.contextTypes, y = (u = u != null) ? E3(o, h) : Cw), r = new r(i, y), o.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null, r.updater = ij, o.stateNode = r, r._reactInternals = o, u && (o = o.stateNode, o.__reactInternalMemoizedUnmaskedChildContext = h, o.__reactInternalMemoizedMaskedChildContext = y), r;
}
function wle(o, r, i, u) {
  o = r.state, typeof r.componentWillReceiveProps == "function" && r.componentWillReceiveProps(i, u), typeof r.UNSAFE_componentWillReceiveProps == "function" && r.UNSAFE_componentWillReceiveProps(i, u), r.state !== o && ij.enqueueReplaceState(r, r.state, null);
}
function xne(o, r, i, u) {
  var h = o.stateNode;
  h.props = i, h.state = o.memoizedState, h.refs = yfe, kre(o);
  var y = r.contextType;
  typeof y == "object" && y !== null ? h.context = Ch(y) : (y = hm(r) ? Ok : Ud.current, h.context = E3(o, y)), c5(o, i, h, u), h.state = o.memoizedState, y = r.getDerivedStateFromProps, typeof y == "function" && (yV(o, r, y, i), h.state = o.memoizedState), typeof r.getDerivedStateFromProps == "function" || typeof h.getSnapshotBeforeUpdate == "function" || typeof h.UNSAFE_componentWillMount != "function" && typeof h.componentWillMount != "function" || (r = h.state, typeof h.componentWillMount == "function" && h.componentWillMount(), typeof h.UNSAFE_componentWillMount == "function" && h.UNSAFE_componentWillMount(), r !== h.state && ij.enqueueReplaceState(h, h.state, null), c5(o, i, h, u), h.state = o.memoizedState), typeof h.componentDidMount == "function" && (o.flags |= 4);
}
var v9 = Array.isArray;
function yI(o, r, i) {
  if (o = i.ref, o !== null && typeof o != "function" && typeof o != "object") {
    if (i._owner) {
      if (i = i._owner, i) {
        if (i.tag !== 1) throw Error(ho(309));
        var u = i.stateNode;
      }
      if (!u) throw Error(ho(147, o));
      var h = "" + o;
      return r !== null && r.ref !== null && typeof r.ref == "function" && r.ref._stringRef === h ? r.ref : (r = function(y) {
        var k = u.refs;
        k === yfe && (k = u.refs = {}), y === null ? delete k[h] : k[h] = y;
      }, r._stringRef = h, r);
    }
    if (typeof o != "string") throw Error(ho(284));
    if (!i._owner) throw Error(ho(290, o));
  }
  return o;
}
function y9(o, r) {
  if (o.type !== "textarea") throw Error(ho(31, Object.prototype.toString.call(r) === "[object Object]" ? "object with keys {" + Object.keys(r).join(", ") + "}" : r));
}
function wfe(o) {
  function r(Q, oe) {
    if (o) {
      var ae = Q.lastEffect;
      ae !== null ? (ae.nextEffect = oe, Q.lastEffect = oe) : Q.firstEffect = Q.lastEffect = oe, oe.nextEffect = null, oe.flags = 8;
    }
  }
  function i(Q, oe) {
    if (!o) return null;
    for (; oe !== null; ) r(Q, oe), oe = oe.sibling;
    return null;
  }
  function u(Q, oe) {
    for (Q = /* @__PURE__ */ new Map(); oe !== null; ) oe.key !== null ? Q.set(oe.key, oe) : Q.set(oe.index, oe), oe = oe.sibling;
    return Q;
  }
  function h(Q, oe) {
    return Q = kw(Q, oe), Q.index = 0, Q.sibling = null, Q;
  }
  function y(Q, oe, ae) {
    return Q.index = ae, o ? (ae = Q.alternate, ae !== null ? (ae = ae.index, ae < oe ? (Q.flags = 2, oe) : ae) : (Q.flags = 2, oe)) : oe;
  }
  function k(Q) {
    return o && Q.alternate === null && (Q.flags = 2), Q;
  }
  function _(Q, oe, ae, G) {
    return oe === null || oe.tag !== 6 ? (oe = _te(ae, Q.mode, G), oe.return = Q, oe) : (oe = h(oe, ae), oe.return = Q, oe);
  }
  function D(Q, oe, ae, G) {
    return oe !== null && oe.elementType === ae.type ? (G = h(oe, ae.props), G.ref = yI(Q, oe, ae), G.return = Q, G) : (G = Q9(ae.type, ae.key, ae.props, null, Q.mode, G), G.ref = yI(Q, oe, ae), G.return = Q, G);
  }
  function L(Q, oe, ae, G) {
    return oe === null || oe.tag !== 4 || oe.stateNode.containerInfo !== ae.containerInfo || oe.stateNode.implementation !== ae.implementation ? (oe = Ete(ae, Q.mode, G), oe.return = Q, oe) : (oe = h(oe, ae.children || []), oe.return = Q, oe);
  }
  function W(Q, oe, ae, G, ve) {
    return oe === null || oe.tag !== 7 ? (oe = x3(ae, Q.mode, G, ve), oe.return = Q, oe) : (oe = h(oe, ae), oe.return = Q, oe);
  }
  function se(Q, oe, ae) {
    if (typeof oe == "string" || typeof oe == "number") return oe = _te("" + oe, Q.mode, ae), oe.return = Q, oe;
    if (typeof oe == "object" && oe !== null) {
      switch (oe.$$typeof) {
        case OI:
          return ae = Q9(oe.type, oe.key, oe.props, null, Q.mode, ae), ae.ref = yI(Q, null, oe), ae.return = Q, ae;
        case pk:
          return oe = Ete(oe, Q.mode, ae), oe.return = Q, oe;
      }
      if (v9(oe) || mI(oe)) return oe = x3(
        oe,
        Q.mode,
        ae,
        null
      ), oe.return = Q, oe;
      y9(Q, oe);
    }
    return null;
  }
  function J(Q, oe, ae, G) {
    var ve = oe !== null ? oe.key : null;
    if (typeof ae == "string" || typeof ae == "number") return ve !== null ? null : _(Q, oe, "" + ae, G);
    if (typeof ae == "object" && ae !== null) {
      switch (ae.$$typeof) {
        case OI:
          return ae.key === ve ? ae.type === aw ? W(Q, oe, ae.props.children, G, ve) : D(Q, oe, ae, G) : null;
        case pk:
          return ae.key === ve ? L(Q, oe, ae, G) : null;
      }
      if (v9(ae) || mI(ae)) return ve !== null ? null : W(Q, oe, ae, G, null);
      y9(Q, ae);
    }
    return null;
  }
  function be(Q, oe, ae, G, ve) {
    if (typeof G == "string" || typeof G == "number") return Q = Q.get(ae) || null, _(oe, Q, "" + G, ve);
    if (typeof G == "object" && G !== null) {
      switch (G.$$typeof) {
        case OI:
          return Q = Q.get(G.key === null ? ae : G.key) || null, G.type === aw ? W(oe, Q, G.props.children, ve, G.key) : D(oe, Q, G, ve);
        case pk:
          return Q = Q.get(G.key === null ? ae : G.key) || null, L(oe, Q, G, ve);
      }
      if (v9(G) || mI(G)) return Q = Q.get(ae) || null, W(oe, Q, G, ve, null);
      y9(oe, G);
    }
    return null;
  }
  function ke(Q, oe, ae, G) {
    for (var ve = null, nt = null, Xe = oe, te = oe = 0, lt = null; Xe !== null && te < ae.length; te++) {
      Xe.index > te ? (lt = Xe, Xe = null) : lt = Xe.sibling;
      var ot = J(Q, Xe, ae[te], G);
      if (ot === null) {
        Xe === null && (Xe = lt);
        break;
      }
      o && Xe && ot.alternate === null && r(Q, Xe), oe = y(ot, oe, te), nt === null ? ve = ot : nt.sibling = ot, nt = ot, Xe = lt;
    }
    if (te === ae.length) return i(Q, Xe), ve;
    if (Xe === null) {
      for (; te < ae.length; te++) Xe = se(Q, ae[te], G), Xe !== null && (oe = y(Xe, oe, te), nt === null ? ve = Xe : nt.sibling = Xe, nt = Xe);
      return ve;
    }
    for (Xe = u(Q, Xe); te < ae.length; te++) lt = be(Xe, Q, te, ae[te], G), lt !== null && (o && lt.alternate !== null && Xe.delete(lt.key === null ? te : lt.key), oe = y(lt, oe, te), nt === null ? ve = lt : nt.sibling = lt, nt = lt);
    return o && Xe.forEach(function(Kt) {
      return r(Q, Kt);
    }), ve;
  }
  function Ce(Q, oe, ae, G) {
    var ve = mI(ae);
    if (typeof ve != "function") throw Error(ho(150));
    if (ae = ve.call(ae), ae == null) throw Error(ho(151));
    for (var nt = ve = null, Xe = oe, te = oe = 0, lt = null, ot = ae.next(); Xe !== null && !ot.done; te++, ot = ae.next()) {
      Xe.index > te ? (lt = Xe, Xe = null) : lt = Xe.sibling;
      var Kt = J(Q, Xe, ot.value, G);
      if (Kt === null) {
        Xe === null && (Xe = lt);
        break;
      }
      o && Xe && Kt.alternate === null && r(Q, Xe), oe = y(Kt, oe, te), nt === null ? ve = Kt : nt.sibling = Kt, nt = Kt, Xe = lt;
    }
    if (ot.done) return i(Q, Xe), ve;
    if (Xe === null) {
      for (; !ot.done; te++, ot = ae.next()) ot = se(Q, ot.value, G), ot !== null && (oe = y(ot, oe, te), nt === null ? ve = ot : nt.sibling = ot, nt = ot);
      return ve;
    }
    for (Xe = u(Q, Xe); !ot.done; te++, ot = ae.next()) ot = be(Xe, Q, te, ot.value, G), ot !== null && (o && ot.alternate !== null && Xe.delete(ot.key === null ? te : ot.key), oe = y(ot, oe, te), nt === null ? ve = ot : nt.sibling = ot, nt = ot);
    return o && Xe.forEach(function(je) {
      return r(Q, je);
    }), ve;
  }
  return function(Q, oe, ae, G) {
    var ve = typeof ae == "object" && ae !== null && ae.type === aw && ae.key === null;
    ve && (ae = ae.props.children);
    var nt = typeof ae == "object" && ae !== null;
    if (nt) switch (ae.$$typeof) {
      case OI:
        e: {
          for (nt = ae.key, ve = oe; ve !== null; ) {
            if (ve.key === nt) {
              switch (ve.tag) {
                case 7:
                  if (ae.type === aw) {
                    i(Q, ve.sibling), oe = h(ve, ae.props.children), oe.return = Q, Q = oe;
                    break e;
                  }
                  break;
                default:
                  if (ve.elementType === ae.type) {
                    i(Q, ve.sibling), oe = h(ve, ae.props), oe.ref = yI(Q, ve, ae), oe.return = Q, Q = oe;
                    break e;
                  }
              }
              i(Q, ve);
              break;
            } else r(Q, ve);
            ve = ve.sibling;
          }
          ae.type === aw ? (oe = x3(ae.props.children, Q.mode, G, ae.key), oe.return = Q, Q = oe) : (G = Q9(ae.type, ae.key, ae.props, null, Q.mode, G), G.ref = yI(Q, oe, ae), G.return = Q, Q = G);
        }
        return k(Q);
      case pk:
        e: {
          for (ve = ae.key; oe !== null; ) {
            if (oe.key === ve) if (oe.tag === 4 && oe.stateNode.containerInfo === ae.containerInfo && oe.stateNode.implementation === ae.implementation) {
              i(Q, oe.sibling), oe = h(oe, ae.children || []), oe.return = Q, Q = oe;
              break e;
            } else {
              i(Q, oe);
              break;
            }
            else r(Q, oe);
            oe = oe.sibling;
          }
          oe = Ete(ae, Q.mode, G), oe.return = Q, Q = oe;
        }
        return k(Q);
    }
    if (typeof ae == "string" || typeof ae == "number") return ae = "" + ae, oe !== null && oe.tag === 6 ? (i(Q, oe.sibling), oe = h(oe, ae), oe.return = Q, Q = oe) : (i(Q, oe), oe = _te(ae, Q.mode, G), oe.return = Q, Q = oe), k(Q);
    if (v9(ae)) return ke(Q, oe, ae, G);
    if (mI(ae)) return Ce(Q, oe, ae, G);
    if (nt && y9(Q, ae), typeof ae > "u" && !ve) switch (Q.tag) {
      case 1:
      case 22:
      case 0:
      case 11:
      case 15:
        throw Error(ho(152, d3(Q.type) || "Component"));
    }
    return i(Q, oe);
  };
}
var xV = wfe(!0), Cfe = wfe(!1), X5 = {}, bv = Pw(X5), u5 = Pw(X5), d5 = Pw(X5);
function bk(o) {
  if (o === X5) throw Error(ho(174));
  return o;
}
function wne(o, r) {
  switch (ql(d5, r), ql(u5, o), ql(bv, X5), o = r.nodeType, o) {
    case 9:
    case 11:
      r = (r = r.documentElement) ? r.namespaceURI : sne(null, "");
      break;
    default:
      o = o === 8 ? r.parentNode : r, r = o.namespaceURI || null, o = o.tagName, r = sne(r, o);
  }
  il(bv), ql(bv, r);
}
function O3() {
  il(bv), il(u5), il(d5);
}
function Cle(o) {
  bk(d5.current);
  var r = bk(bv.current), i = sne(r, o.type);
  r !== i && (ql(u5, o), ql(bv, i));
}
function _re(o) {
  u5.current === o && (il(bv), il(u5));
}
var Zl = Pw(0);
function wV(o) {
  for (var r = o; r !== null; ) {
    if (r.tag === 13) {
      var i = r.memoizedState;
      if (i !== null && (i = i.dehydrated, i === null || i.data === "$?" || i.data === "$!")) return r;
    } else if (r.tag === 19 && r.memoizedProps.revealOrder !== void 0) {
      if (r.flags & 64) return r;
    } else if (r.child !== null) {
      r.child.return = r, r = r.child;
      continue;
    }
    if (r === o) break;
    for (; r.sibling === null; ) {
      if (r.return === null || r.return === o) return null;
      r = r.return;
    }
    r.sibling.return = r.return, r = r.sibling;
  }
  return null;
}
var v0 = null, cw = null, vv = !1;
function Sfe(o, r) {
  var i = yh(5, null, null, 0);
  i.elementType = "DELETED", i.type = "DELETED", i.stateNode = r, i.return = o, i.flags = 8, o.lastEffect !== null ? (o.lastEffect.nextEffect = i, o.lastEffect = i) : o.firstEffect = o.lastEffect = i;
}
function Sle(o, r) {
  switch (o.tag) {
    case 5:
      var i = o.type;
      return r = r.nodeType !== 1 || i.toLowerCase() !== r.nodeName.toLowerCase() ? null : r, r !== null ? (o.stateNode = r, !0) : !1;
    case 6:
      return r = o.pendingProps === "" || r.nodeType !== 3 ? null : r, r !== null ? (o.stateNode = r, !0) : !1;
    case 13:
      return !1;
    default:
      return !1;
  }
}
function Cne(o) {
  if (vv) {
    var r = cw;
    if (r) {
      var i = r;
      if (!Sle(o, r)) {
        if (r = h3(i.nextSibling), !r || !Sle(o, r)) {
          o.flags = o.flags & -1025 | 2, vv = !1, v0 = o;
          return;
        }
        Sfe(v0, i);
      }
      v0 = o, cw = h3(r.firstChild);
    } else o.flags = o.flags & -1025 | 2, vv = !1, v0 = o;
  }
}
function kle(o) {
  for (o = o.return; o !== null && o.tag !== 5 && o.tag !== 3 && o.tag !== 13; ) o = o.return;
  v0 = o;
}
function x9(o) {
  if (o !== v0) return !1;
  if (!vv) return kle(o), vv = !0, !1;
  var r = o.type;
  if (o.tag !== 5 || r !== "head" && r !== "body" && !gne(r, o.memoizedProps)) for (r = cw; r; ) Sfe(o, r), r = h3(r.nextSibling);
  if (kle(o), o.tag === 13) {
    if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(ho(317));
    e: {
      for (o = o.nextSibling, r = 0; o; ) {
        if (o.nodeType === 8) {
          var i = o.data;
          if (i === "/$") {
            if (r === 0) {
              cw = h3(o.nextSibling);
              break e;
            }
            r--;
          } else i !== "$" && i !== "$!" && i !== "$?" || r++;
        }
        o = o.nextSibling;
      }
      cw = null;
    }
  } else cw = v0 ? h3(o.stateNode.nextSibling) : null;
  return !0;
}
function wte() {
  cw = v0 = null, vv = !1;
}
var b3 = [];
function Ere() {
  for (var o = 0; o < b3.length; o++) b3[o]._workInProgressVersionPrimary = null;
  b3.length = 0;
}
var jI = Bk.ReactCurrentDispatcher, xh = Bk.ReactCurrentBatchConfig, f5 = 0, bc = null, $d = null, rd = null, CV = !1, UI = !1;
function fm() {
  throw Error(ho(321));
}
function Tre(o, r) {
  if (r === null) return !1;
  for (var i = 0; i < r.length && i < o.length; i++) if (!vh(o[i], r[i])) return !1;
  return !0;
}
function Ore(o, r, i, u, h, y) {
  if (f5 = y, bc = r, r.memoizedState = null, r.updateQueue = null, r.lanes = 0, jI.current = o === null || o.memoizedState === null ? ybe : xbe, o = i(u, h), UI) {
    y = 0;
    do {
      if (UI = !1, !(25 > y)) throw Error(ho(301));
      y += 1, rd = $d = null, r.updateQueue = null, jI.current = wbe, o = i(u, h);
    } while (UI);
  }
  if (jI.current = EV, r = $d !== null && $d.next !== null, f5 = 0, rd = $d = bc = null, CV = !1, r) throw Error(ho(300));
  return o;
}
function vk() {
  var o = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  return rd === null ? bc.memoizedState = rd = o : rd = rd.next = o, rd;
}
function Lk() {
  if ($d === null) {
    var o = bc.alternate;
    o = o !== null ? o.memoizedState : null;
  } else o = $d.next;
  var r = rd === null ? bc.memoizedState : rd.next;
  if (r !== null) rd = r, $d = o;
  else {
    if (o === null) throw Error(ho(310));
    $d = o, o = { memoizedState: $d.memoizedState, baseState: $d.baseState, baseQueue: $d.baseQueue, queue: $d.queue, next: null }, rd === null ? bc.memoizedState = rd = o : rd = rd.next = o;
  }
  return rd;
}
function mv(o, r) {
  return typeof r == "function" ? r(o) : r;
}
function xI(o) {
  var r = Lk(), i = r.queue;
  if (i === null) throw Error(ho(311));
  i.lastRenderedReducer = o;
  var u = $d, h = u.baseQueue, y = i.pending;
  if (y !== null) {
    if (h !== null) {
      var k = h.next;
      h.next = y.next, y.next = k;
    }
    u.baseQueue = h = y, i.pending = null;
  }
  if (h !== null) {
    h = h.next, u = u.baseState;
    var _ = k = y = null, D = h;
    do {
      var L = D.lane;
      if ((f5 & L) === L) _ !== null && (_ = _.next = { lane: 0, action: D.action, eagerReducer: D.eagerReducer, eagerState: D.eagerState, next: null }), u = D.eagerReducer === o ? D.eagerState : o(u, D.action);
      else {
        var W = {
          lane: L,
          action: D.action,
          eagerReducer: D.eagerReducer,
          eagerState: D.eagerState,
          next: null
        };
        _ === null ? (k = _ = W, y = u) : _ = _.next = W, bc.lanes |= L, Q5 |= L;
      }
      D = D.next;
    } while (D !== null && D !== h);
    _ === null ? y = u : _.next = k, vh(u, r.memoizedState) || (Vg = !0), r.memoizedState = u, r.baseState = y, r.baseQueue = _, i.lastRenderedState = u;
  }
  return [r.memoizedState, i.dispatch];
}
function wI(o) {
  var r = Lk(), i = r.queue;
  if (i === null) throw Error(ho(311));
  i.lastRenderedReducer = o;
  var u = i.dispatch, h = i.pending, y = r.memoizedState;
  if (h !== null) {
    i.pending = null;
    var k = h = h.next;
    do
      y = o(y, k.action), k = k.next;
    while (k !== h);
    vh(y, r.memoizedState) || (Vg = !0), r.memoizedState = y, r.baseQueue === null && (r.baseState = y), i.lastRenderedState = y;
  }
  return [y, u];
}
function _le(o, r, i) {
  var u = r._getVersion;
  u = u(r._source);
  var h = r._workInProgressVersionPrimary;
  if (h !== null ? o = h === u : (o = o.mutableReadLanes, (o = (f5 & o) === o) && (r._workInProgressVersionPrimary = u, b3.push(r))), o) return i(r._source);
  throw b3.push(r), Error(ho(350));
}
function kfe(o, r, i, u) {
  var h = Ef;
  if (h === null) throw Error(ho(349));
  var y = r._getVersion, k = y(r._source), _ = jI.current, D = _.useState(function() {
    return _le(h, r, i);
  }), L = D[1], W = D[0];
  D = rd;
  var se = o.memoizedState, J = se.refs, be = J.getSnapshot, ke = se.source;
  se = se.subscribe;
  var Ce = bc;
  return o.memoizedState = { refs: J, source: r, subscribe: u }, _.useEffect(function() {
    J.getSnapshot = i, J.setSnapshot = L;
    var Q = y(r._source);
    if (!vh(k, Q)) {
      Q = i(r._source), vh(W, Q) || (L(Q), Q = gw(Ce), h.mutableReadLanes |= Q & h.pendingLanes), Q = h.mutableReadLanes, h.entangledLanes |= Q;
      for (var oe = h.entanglements, ae = Q; 0 < ae; ) {
        var G = 31 - ww(ae), ve = 1 << G;
        oe[G] |= Q, ae &= ~ve;
      }
    }
  }, [i, r, u]), _.useEffect(function() {
    return u(r._source, function() {
      var Q = J.getSnapshot, oe = J.setSnapshot;
      try {
        oe(Q(r._source));
        var ae = gw(Ce);
        h.mutableReadLanes |= ae & h.pendingLanes;
      } catch (G) {
        oe(function() {
          throw G;
        });
      }
    });
  }, [r, u]), vh(be, i) && vh(ke, r) && vh(se, u) || (o = { pending: null, dispatch: null, lastRenderedReducer: mv, lastRenderedState: W }, o.dispatch = L = Dre.bind(null, bc, o), D.queue = o, D.baseQueue = null, W = _le(h, r, i), D.memoizedState = D.baseState = W), W;
}
function _fe(o, r, i) {
  var u = Lk();
  return kfe(u, o, r, i);
}
function CI(o) {
  var r = vk();
  return typeof o == "function" && (o = o()), r.memoizedState = r.baseState = o, o = r.queue = { pending: null, dispatch: null, lastRenderedReducer: mv, lastRenderedState: o }, o = o.dispatch = Dre.bind(null, bc, o), [r.memoizedState, o];
}
function SV(o, r, i, u) {
  return o = { tag: o, create: r, destroy: i, deps: u, next: null }, r = bc.updateQueue, r === null ? (r = { lastEffect: null }, bc.updateQueue = r, r.lastEffect = o.next = o) : (i = r.lastEffect, i === null ? r.lastEffect = o.next = o : (u = i.next, i.next = o, o.next = u, r.lastEffect = o)), o;
}
function Ele(o) {
  var r = vk();
  return o = { current: o }, r.memoizedState = o;
}
function kV() {
  return Lk().memoizedState;
}
function Sne(o, r, i, u) {
  var h = vk();
  bc.flags |= o, h.memoizedState = SV(1 | r, i, void 0, u === void 0 ? null : u);
}
function Are(o, r, i, u) {
  var h = Lk();
  u = u === void 0 ? null : u;
  var y = void 0;
  if ($d !== null) {
    var k = $d.memoizedState;
    if (y = k.destroy, u !== null && Tre(u, k.deps)) {
      SV(r, i, y, u);
      return;
    }
  }
  bc.flags |= o, h.memoizedState = SV(1 | r, i, y, u);
}
function Tle(o, r) {
  return Sne(516, 4, o, r);
}
function _V(o, r) {
  return Are(516, 4, o, r);
}
function Efe(o, r) {
  return Are(4, 2, o, r);
}
function Tfe(o, r) {
  if (typeof r == "function") return o = o(), r(o), function() {
    r(null);
  };
  if (r != null) return o = o(), r.current = o, function() {
    r.current = null;
  };
}
function Ofe(o, r, i) {
  return i = i != null ? i.concat([o]) : null, Are(4, 2, Tfe.bind(null, r, o), i);
}
function Pre() {
}
function Afe(o, r) {
  var i = Lk();
  r = r === void 0 ? null : r;
  var u = i.memoizedState;
  return u !== null && r !== null && Tre(r, u[1]) ? u[0] : (i.memoizedState = [o, r], o);
}
function Pfe(o, r) {
  var i = Lk();
  r = r === void 0 ? null : r;
  var u = i.memoizedState;
  return u !== null && r !== null && Tre(r, u[1]) ? u[0] : (o = o(), i.memoizedState = [o, r], o);
}
function vbe(o, r) {
  var i = T3();
  Ak(98 > i ? 98 : i, function() {
    o(!0);
  }), Ak(97 < i ? 97 : i, function() {
    var u = xh.transition;
    xh.transition = 1;
    try {
      o(!1), r();
    } finally {
      xh.transition = u;
    }
  });
}
function Dre(o, r, i) {
  var u = np(), h = gw(o), y = { lane: h, action: i, eagerReducer: null, eagerState: null, next: null }, k = r.pending;
  if (k === null ? y.next = y : (y.next = k.next, k.next = y), r.pending = y, k = o.alternate, o === bc || k !== null && k === bc) UI = CV = !0;
  else {
    if (o.lanes === 0 && (k === null || k.lanes === 0) && (k = r.lastRenderedReducer, k !== null)) try {
      var _ = r.lastRenderedState, D = k(_, i);
      if (y.eagerReducer = k, y.eagerState = D, vh(D, _)) return;
    } catch {
    } finally {
    }
    bw(o, h, u);
  }
}
var EV = { readContext: Ch, useCallback: fm, useContext: fm, useEffect: fm, useImperativeHandle: fm, useLayoutEffect: fm, useMemo: fm, useReducer: fm, useRef: fm, useState: fm, useDebugValue: fm, useDeferredValue: fm, useTransition: fm, useMutableSource: fm, useOpaqueIdentifier: fm, unstable_isNewReconciler: !1 }, ybe = { readContext: Ch, useCallback: function(o, r) {
  return vk().memoizedState = [o, r === void 0 ? null : r], o;
}, useContext: Ch, useEffect: Tle, useImperativeHandle: function(o, r, i) {
  return i = i != null ? i.concat([o]) : null, Sne(4, 2, Tfe.bind(
    null,
    r,
    o
  ), i);
}, useLayoutEffect: function(o, r) {
  return Sne(4, 2, o, r);
}, useMemo: function(o, r) {
  var i = vk();
  return r = r === void 0 ? null : r, o = o(), i.memoizedState = [o, r], o;
}, useReducer: function(o, r, i) {
  var u = vk();
  return r = i !== void 0 ? i(r) : r, u.memoizedState = u.baseState = r, o = u.queue = { pending: null, dispatch: null, lastRenderedReducer: o, lastRenderedState: r }, o = o.dispatch = Dre.bind(null, bc, o), [u.memoizedState, o];
}, useRef: Ele, useState: CI, useDebugValue: Pre, useDeferredValue: function(o) {
  var r = CI(o), i = r[0], u = r[1];
  return Tle(function() {
    var h = xh.transition;
    xh.transition = 1;
    try {
      u(o);
    } finally {
      xh.transition = h;
    }
  }, [o]), i;
}, useTransition: function() {
  var o = CI(!1), r = o[0];
  return o = vbe.bind(null, o[1]), Ele(o), [o, r];
}, useMutableSource: function(o, r, i) {
  var u = vk();
  return u.memoizedState = { refs: { getSnapshot: r, setSnapshot: null }, source: o, subscribe: i }, kfe(u, o, r, i);
}, useOpaqueIdentifier: function() {
  if (vv) {
    var o = !1, r = fbe(function() {
      throw o || (o = !0, i("r:" + (vte++).toString(36))), Error(ho(355));
    }), i = CI(r)[1];
    return !(bc.mode & 2) && (bc.flags |= 516, SV(
      5,
      function() {
        i("r:" + (vte++).toString(36));
      },
      void 0,
      null
    )), r;
  }
  return r = "r:" + (vte++).toString(36), CI(r), r;
}, unstable_isNewReconciler: !1 }, xbe = { readContext: Ch, useCallback: Afe, useContext: Ch, useEffect: _V, useImperativeHandle: Ofe, useLayoutEffect: Efe, useMemo: Pfe, useReducer: xI, useRef: kV, useState: function() {
  return xI(mv);
}, useDebugValue: Pre, useDeferredValue: function(o) {
  var r = xI(mv), i = r[0], u = r[1];
  return _V(function() {
    var h = xh.transition;
    xh.transition = 1;
    try {
      u(o);
    } finally {
      xh.transition = h;
    }
  }, [o]), i;
}, useTransition: function() {
  var o = xI(mv)[0];
  return [
    kV().current,
    o
  ];
}, useMutableSource: _fe, useOpaqueIdentifier: function() {
  return xI(mv)[0];
}, unstable_isNewReconciler: !1 }, wbe = { readContext: Ch, useCallback: Afe, useContext: Ch, useEffect: _V, useImperativeHandle: Ofe, useLayoutEffect: Efe, useMemo: Pfe, useReducer: wI, useRef: kV, useState: function() {
  return wI(mv);
}, useDebugValue: Pre, useDeferredValue: function(o) {
  var r = wI(mv), i = r[0], u = r[1];
  return _V(function() {
    var h = xh.transition;
    xh.transition = 1;
    try {
      u(o);
    } finally {
      xh.transition = h;
    }
  }, [o]), i;
}, useTransition: function() {
  var o = wI(mv)[0];
  return [
    kV().current,
    o
  ];
}, useMutableSource: _fe, useOpaqueIdentifier: function() {
  return wI(mv)[0];
}, unstable_isNewReconciler: !1 }, Cbe = Bk.ReactCurrentOwner, Vg = !1;
function mm(o, r, i, u) {
  r.child = o === null ? Cfe(r, null, i, u) : xV(r, o.child, i, u);
}
function Ole(o, r, i, u, h) {
  i = i.render;
  var y = r.ref;
  return g3(r, h), u = Ore(o, r, i, u, y, h), o !== null && !Vg ? (r.updateQueue = o.updateQueue, r.flags &= -517, o.lanes &= ~h, y0(o, r, h)) : (r.flags |= 1, mm(o, r, u, h), r.child);
}
function Ale(o, r, i, u, h, y) {
  if (o === null) {
    var k = i.type;
    return typeof k == "function" && !Bre(k) && k.defaultProps === void 0 && i.compare === null && i.defaultProps === void 0 ? (r.tag = 15, r.type = k, Dfe(o, r, k, u, h, y)) : (o = Q9(i.type, null, u, r, r.mode, y), o.ref = r.ref, o.return = r, r.child = o);
  }
  return k = o.child, !(h & y) && (h = k.memoizedProps, i = i.compare, i = i !== null ? i : a5, i(h, u) && o.ref === r.ref) ? y0(o, r, y) : (r.flags |= 1, o = kw(k, u), o.ref = r.ref, o.return = r, r.child = o);
}
function Dfe(o, r, i, u, h, y) {
  if (o !== null && a5(o.memoizedProps, u) && o.ref === r.ref) if (Vg = !1, (y & h) !== 0) o.flags & 16384 && (Vg = !0);
  else return r.lanes = o.lanes, y0(o, r, y);
  return kne(o, r, i, u, y);
}
function Cte(o, r, i) {
  var u = r.pendingProps, h = u.children, y = o !== null ? o.memoizedState : null;
  if (u.mode === "hidden" || u.mode === "unstable-defer-without-hiding") if (!(r.mode & 4)) r.memoizedState = { baseLanes: 0 }, C9(r, i);
  else if (i & 1073741824) r.memoizedState = { baseLanes: 0 }, C9(r, y !== null ? y.baseLanes : i);
  else return o = y !== null ? y.baseLanes | i : i, r.lanes = r.childLanes = 1073741824, r.memoizedState = { baseLanes: o }, C9(r, o), null;
  else y !== null ? (u = y.baseLanes | i, r.memoizedState = null) : u = i, C9(r, u);
  return mm(o, r, h, i), r.child;
}
function Rfe(o, r) {
  var i = r.ref;
  (o === null && i !== null || o !== null && o.ref !== i) && (r.flags |= 128);
}
function kne(o, r, i, u, h) {
  var y = hm(i) ? Ok : Ud.current;
  return y = E3(r, y), g3(r, h), i = Ore(o, r, i, u, y, h), o !== null && !Vg ? (r.updateQueue = o.updateQueue, r.flags &= -517, o.lanes &= ~h, y0(o, r, h)) : (r.flags |= 1, mm(o, r, i, h), r.child);
}
function Ple(o, r, i, u, h) {
  if (hm(i)) {
    var y = !0;
    G9(r);
  } else y = !1;
  if (g3(r, h), r.stateNode === null) o !== null && (o.alternate = null, r.alternate = null, r.flags |= 2), xfe(r, i, u), xne(r, i, u, h), u = !0;
  else if (o === null) {
    var k = r.stateNode, _ = r.memoizedProps;
    k.props = _;
    var D = k.context, L = i.contextType;
    typeof L == "object" && L !== null ? L = Ch(L) : (L = hm(i) ? Ok : Ud.current, L = E3(r, L));
    var W = i.getDerivedStateFromProps, se = typeof W == "function" || typeof k.getSnapshotBeforeUpdate == "function";
    se || typeof k.UNSAFE_componentWillReceiveProps != "function" && typeof k.componentWillReceiveProps != "function" || (_ !== u || D !== L) && wle(r, k, u, L), rw = !1;
    var J = r.memoizedState;
    k.state = J, c5(r, u, k, h), D = r.memoizedState, _ !== u || J !== D || pm.current || rw ? (typeof W == "function" && (yV(r, i, W, u), D = r.memoizedState), (_ = rw || xle(r, i, _, u, J, D, L)) ? (se || typeof k.UNSAFE_componentWillMount != "function" && typeof k.componentWillMount != "function" || (typeof k.componentWillMount == "function" && k.componentWillMount(), typeof k.UNSAFE_componentWillMount == "function" && k.UNSAFE_componentWillMount()), typeof k.componentDidMount == "function" && (r.flags |= 4)) : (typeof k.componentDidMount == "function" && (r.flags |= 4), r.memoizedProps = u, r.memoizedState = D), k.props = u, k.state = D, k.context = L, u = _) : (typeof k.componentDidMount == "function" && (r.flags |= 4), u = !1);
  } else {
    k = r.stateNode, vfe(o, r), _ = r.memoizedProps, L = r.type === r.elementType ? _ : Hg(r.type, _), k.props = L, se = r.pendingProps, J = k.context, D = i.contextType, typeof D == "object" && D !== null ? D = Ch(D) : (D = hm(i) ? Ok : Ud.current, D = E3(r, D));
    var be = i.getDerivedStateFromProps;
    (W = typeof be == "function" || typeof k.getSnapshotBeforeUpdate == "function") || typeof k.UNSAFE_componentWillReceiveProps != "function" && typeof k.componentWillReceiveProps != "function" || (_ !== se || J !== D) && wle(r, k, u, D), rw = !1, J = r.memoizedState, k.state = J, c5(r, u, k, h);
    var ke = r.memoizedState;
    _ !== se || J !== ke || pm.current || rw ? (typeof be == "function" && (yV(r, i, be, u), ke = r.memoizedState), (L = rw || xle(r, i, L, u, J, ke, D)) ? (W || typeof k.UNSAFE_componentWillUpdate != "function" && typeof k.componentWillUpdate != "function" || (typeof k.componentWillUpdate == "function" && k.componentWillUpdate(
      u,
      ke,
      D
    ), typeof k.UNSAFE_componentWillUpdate == "function" && k.UNSAFE_componentWillUpdate(u, ke, D)), typeof k.componentDidUpdate == "function" && (r.flags |= 4), typeof k.getSnapshotBeforeUpdate == "function" && (r.flags |= 256)) : (typeof k.componentDidUpdate != "function" || _ === o.memoizedProps && J === o.memoizedState || (r.flags |= 4), typeof k.getSnapshotBeforeUpdate != "function" || _ === o.memoizedProps && J === o.memoizedState || (r.flags |= 256), r.memoizedProps = u, r.memoizedState = ke), k.props = u, k.state = ke, k.context = D, u = L) : (typeof k.componentDidUpdate != "function" || _ === o.memoizedProps && J === o.memoizedState || (r.flags |= 4), typeof k.getSnapshotBeforeUpdate != "function" || _ === o.memoizedProps && J === o.memoizedState || (r.flags |= 256), u = !1);
  }
  return _ne(o, r, i, u, y, h);
}
function _ne(o, r, i, u, h, y) {
  Rfe(o, r);
  var k = (r.flags & 64) !== 0;
  if (!u && !k) return h && hle(r, i, !1), y0(o, r, y);
  u = r.stateNode, Cbe.current = r;
  var _ = k && typeof i.getDerivedStateFromError != "function" ? null : u.render();
  return r.flags |= 1, o !== null && k ? (r.child = xV(r, o.child, null, y), r.child = xV(r, null, _, y)) : mm(o, r, _, y), r.memoizedState = u.state, h && hle(r, i, !0), r.child;
}
function Dle(o) {
  var r = o.stateNode;
  r.pendingContext ? ple(o, r.pendingContext, r.pendingContext !== r.context) : r.context && ple(o, r.context, !1), wne(o, r.containerInfo);
}
var w9 = { dehydrated: null, retryLane: 0 };
function Rle(o, r, i) {
  var u = r.pendingProps, h = Zl.current, y = !1, k;
  return (k = (r.flags & 64) !== 0) || (k = o !== null && o.memoizedState === null ? !1 : (h & 2) !== 0), k ? (y = !0, r.flags &= -65) : o !== null && o.memoizedState === null || u.fallback === void 0 || u.unstable_avoidThisFallback === !0 || (h |= 1), ql(Zl, h & 1), o === null ? (u.fallback !== void 0 && Cne(r), o = u.children, h = u.fallback, y ? (o = Nle(r, o, h, i), r.child.memoizedState = { baseLanes: i }, r.memoizedState = w9, o) : typeof u.unstable_expectedLoadTime == "number" ? (o = Nle(r, o, h, i), r.child.memoizedState = { baseLanes: i }, r.memoizedState = w9, r.lanes = 33554432, o) : (i = $re({ mode: "visible", children: o }, r.mode, i, null), i.return = r, r.child = i)) : o.memoizedState !== null ? y ? (u = Ile(o, r, u.children, u.fallback, i), y = r.child, h = o.child.memoizedState, y.memoizedState = h === null ? { baseLanes: i } : { baseLanes: h.baseLanes | i }, y.childLanes = o.childLanes & ~i, r.memoizedState = w9, u) : (i = Mle(o, r, u.children, i), r.memoizedState = null, i) : y ? (u = Ile(o, r, u.children, u.fallback, i), y = r.child, h = o.child.memoizedState, y.memoizedState = h === null ? { baseLanes: i } : { baseLanes: h.baseLanes | i }, y.childLanes = o.childLanes & ~i, r.memoizedState = w9, u) : (i = Mle(o, r, u.children, i), r.memoizedState = null, i);
}
function Nle(o, r, i, u) {
  var h = o.mode, y = o.child;
  return r = { mode: "hidden", children: r }, !(h & 2) && y !== null ? (y.childLanes = 0, y.pendingProps = r) : y = $re(r, h, 0, null), i = x3(i, h, u, null), y.return = o, i.return = o, y.sibling = i, o.child = y, i;
}
function Mle(o, r, i, u) {
  var h = o.child;
  return o = h.sibling, i = kw(h, { mode: "visible", children: i }), !(r.mode & 2) && (i.lanes = u), i.return = r, i.sibling = null, o !== null && (o.nextEffect = null, o.flags = 8, r.firstEffect = r.lastEffect = o), r.child = i;
}
function Ile(o, r, i, u, h) {
  var y = r.mode, k = o.child;
  o = k.sibling;
  var _ = { mode: "hidden", children: i };
  return !(y & 2) && r.child !== k ? (i = r.child, i.childLanes = 0, i.pendingProps = _, k = i.lastEffect, k !== null ? (r.firstEffect = i.firstEffect, r.lastEffect = k, k.nextEffect = null) : r.firstEffect = r.lastEffect = null) : i = kw(k, _), o !== null ? u = kw(o, u) : (u = x3(u, y, h, null), u.flags |= 2), u.return = r, i.return = r, i.sibling = u, r.child = i, u;
}
function Fle(o, r) {
  o.lanes |= r;
  var i = o.alternate;
  i !== null && (i.lanes |= r), bfe(o.return, r);
}
function Ste(o, r, i, u, h, y) {
  var k = o.memoizedState;
  k === null ? o.memoizedState = { isBackwards: r, rendering: null, renderingStartTime: 0, last: u, tail: i, tailMode: h, lastEffect: y } : (k.isBackwards = r, k.rendering = null, k.renderingStartTime = 0, k.last = u, k.tail = i, k.tailMode = h, k.lastEffect = y);
}
function Ble(o, r, i) {
  var u = r.pendingProps, h = u.revealOrder, y = u.tail;
  if (mm(o, r, u.children, i), u = Zl.current, u & 2) u = u & 1 | 2, r.flags |= 64;
  else {
    if (o !== null && o.flags & 64) e: for (o = r.child; o !== null; ) {
      if (o.tag === 13) o.memoizedState !== null && Fle(o, i);
      else if (o.tag === 19) Fle(o, i);
      else if (o.child !== null) {
        o.child.return = o, o = o.child;
        continue;
      }
      if (o === r) break e;
      for (; o.sibling === null; ) {
        if (o.return === null || o.return === r) break e;
        o = o.return;
      }
      o.sibling.return = o.return, o = o.sibling;
    }
    u &= 1;
  }
  if (ql(Zl, u), !(r.mode & 2)) r.memoizedState = null;
  else switch (h) {
    case "forwards":
      for (i = r.child, h = null; i !== null; ) o = i.alternate, o !== null && wV(o) === null && (h = i), i = i.sibling;
      i = h, i === null ? (h = r.child, r.child = null) : (h = i.sibling, i.sibling = null), Ste(r, !1, h, i, y, r.lastEffect);
      break;
    case "backwards":
      for (i = null, h = r.child, r.child = null; h !== null; ) {
        if (o = h.alternate, o !== null && wV(o) === null) {
          r.child = h;
          break;
        }
        o = h.sibling, h.sibling = i, i = h, h = o;
      }
      Ste(r, !0, i, null, y, r.lastEffect);
      break;
    case "together":
      Ste(r, !1, null, null, void 0, r.lastEffect);
      break;
    default:
      r.memoizedState = null;
  }
  return r.child;
}
function y0(o, r, i) {
  if (o !== null && (r.dependencies = o.dependencies), Q5 |= r.lanes, i & r.childLanes) {
    if (o !== null && r.child !== o.child) throw Error(ho(153));
    if (r.child !== null) {
      for (o = r.child, i = kw(o, o.pendingProps), r.child = i, i.return = r; o.sibling !== null; ) o = o.sibling, i = i.sibling = kw(o, o.pendingProps), i.return = r;
      i.sibling = null;
    }
    return r.child;
  }
  return null;
}
var Nfe, Ene, Mfe, Ife;
Nfe = function(o, r) {
  for (var i = r.child; i !== null; ) {
    if (i.tag === 5 || i.tag === 6) o.appendChild(i.stateNode);
    else if (i.tag !== 4 && i.child !== null) {
      i.child.return = i, i = i.child;
      continue;
    }
    if (i === r) break;
    for (; i.sibling === null; ) {
      if (i.return === null || i.return === r) return;
      i = i.return;
    }
    i.sibling.return = i.return, i = i.sibling;
  }
};
Ene = function() {
};
Mfe = function(o, r, i, u) {
  var h = o.memoizedProps;
  if (h !== u) {
    o = r.stateNode, bk(bv.current);
    var y = null;
    switch (i) {
      case "input":
        h = Jte(o, h), u = Jte(o, u), y = [];
        break;
      case "option":
        h = nne(o, h), u = nne(o, u), y = [];
        break;
      case "select":
        h = xl({}, h, { value: void 0 }), u = xl({}, u, { value: void 0 }), y = [];
        break;
      case "textarea":
        h = one(o, h), u = one(o, u), y = [];
        break;
      default:
        typeof h.onClick != "function" && typeof u.onClick == "function" && (o.onclick = mV);
    }
    ane(i, u);
    var k;
    i = null;
    for (L in h) if (!u.hasOwnProperty(L) && h.hasOwnProperty(L) && h[L] != null) if (L === "style") {
      var _ = h[L];
      for (k in _) _.hasOwnProperty(k) && (i || (i = {}), i[k] = "");
    } else L !== "dangerouslySetInnerHTML" && L !== "children" && L !== "suppressContentEditableWarning" && L !== "suppressHydrationWarning" && L !== "autoFocus" && (JI.hasOwnProperty(L) ? y || (y = []) : (y = y || []).push(L, null));
    for (L in u) {
      var D = u[L];
      if (_ = h != null ? h[L] : void 0, u.hasOwnProperty(L) && D !== _ && (D != null || _ != null)) if (L === "style") if (_) {
        for (k in _) !_.hasOwnProperty(k) || D && D.hasOwnProperty(k) || (i || (i = {}), i[k] = "");
        for (k in D) D.hasOwnProperty(k) && _[k] !== D[k] && (i || (i = {}), i[k] = D[k]);
      } else i || (y || (y = []), y.push(L, i)), i = D;
      else L === "dangerouslySetInnerHTML" ? (D = D ? D.__html : void 0, _ = _ ? _.__html : void 0, D != null && _ !== D && (y = y || []).push(L, D)) : L === "children" ? typeof D != "string" && typeof D != "number" || (y = y || []).push(L, "" + D) : L !== "suppressContentEditableWarning" && L !== "suppressHydrationWarning" && (JI.hasOwnProperty(L) ? (D != null && L === "onScroll" && sl("scroll", o), y || _ === D || (y = [])) : typeof D == "object" && D !== null && D.$$typeof === rre ? D.toString() : (y = y || []).push(L, D));
    }
    i && (y = y || []).push(
      "style",
      i
    );
    var L = y;
    (r.updateQueue = L) && (r.flags |= 4);
  }
};
Ife = function(o, r, i, u) {
  i !== u && (r.flags |= 4);
};
function SI(o, r) {
  if (!vv) switch (o.tailMode) {
    case "hidden":
      r = o.tail;
      for (var i = null; r !== null; ) r.alternate !== null && (i = r), r = r.sibling;
      i === null ? o.tail = null : i.sibling = null;
      break;
    case "collapsed":
      i = o.tail;
      for (var u = null; i !== null; ) i.alternate !== null && (u = i), i = i.sibling;
      u === null ? r || o.tail === null ? o.tail = null : o.tail.sibling = null : u.sibling = null;
  }
}
function Sbe(o, r, i) {
  var u = r.pendingProps;
  switch (r.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return null;
    case 1:
      return hm(r.type) && hV(), null;
    case 3:
      return O3(), il(pm), il(Ud), Ere(), u = r.stateNode, u.pendingContext && (u.context = u.pendingContext, u.pendingContext = null), (o === null || o.child === null) && (x9(r) ? r.flags |= 4 : u.hydrate || (r.flags |= 256)), Ene(r), null;
    case 5:
      _re(r);
      var h = bk(d5.current);
      if (i = r.type, o !== null && r.stateNode != null) Mfe(o, r, i, u, h), o.ref !== r.ref && (r.flags |= 128);
      else {
        if (!u) {
          if (r.stateNode === null) throw Error(ho(166));
          return null;
        }
        if (o = bk(bv.current), x9(r)) {
          u = r.stateNode, i = r.type;
          var y = r.memoizedProps;
          switch (u[lw] = r, u[pV] = y, i) {
            case "dialog":
              sl("cancel", u), sl("close", u);
              break;
            case "iframe":
            case "object":
            case "embed":
              sl("load", u);
              break;
            case "video":
            case "audio":
              for (o = 0; o < PI.length; o++) sl(PI[o], u);
              break;
            case "source":
              sl("error", u);
              break;
            case "img":
            case "image":
            case "link":
              sl("error", u), sl("load", u);
              break;
            case "details":
              sl("toggle", u);
              break;
            case "input":
              Bie(u, y), sl("invalid", u);
              break;
            case "select":
              u._wrapperState = { wasMultiple: !!y.multiple }, sl("invalid", u);
              break;
            case "textarea":
              Lie(u, y), sl("invalid", u);
          }
          ane(i, y), o = null;
          for (var k in y) y.hasOwnProperty(k) && (h = y[k], k === "children" ? typeof h == "string" ? u.textContent !== h && (o = ["children", h]) : typeof h == "number" && u.textContent !== "" + h && (o = ["children", "" + h]) : JI.hasOwnProperty(k) && h != null && k === "onScroll" && sl("scroll", u));
          switch (i) {
            case "input":
              p9(u), $ie(u, y, !0);
              break;
            case "textarea":
              p9(u), Hie(u);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof y.onClick == "function" && (u.onclick = mV);
          }
          u = o, r.updateQueue = u, u !== null && (r.flags |= 4);
        } else {
          switch (k = h.nodeType === 9 ? h : h.ownerDocument, o === rne.html && (o = Ade(i)), o === rne.html ? i === "script" ? (o = k.createElement("div"), o.innerHTML = "<script><\/script>", o = o.removeChild(o.firstChild)) : typeof u.is == "string" ? o = k.createElement(i, { is: u.is }) : (o = k.createElement(i), i === "select" && (k = o, u.multiple ? k.multiple = !0 : u.size && (k.size = u.size))) : o = k.createElementNS(o, i), o[lw] = r, o[pV] = u, Nfe(o, r, !1, !1), r.stateNode = o, k = ine(i, u), i) {
            case "dialog":
              sl("cancel", o), sl("close", o), h = u;
              break;
            case "iframe":
            case "object":
            case "embed":
              sl("load", o), h = u;
              break;
            case "video":
            case "audio":
              for (h = 0; h < PI.length; h++) sl(PI[h], o);
              h = u;
              break;
            case "source":
              sl("error", o), h = u;
              break;
            case "img":
            case "image":
            case "link":
              sl("error", o), sl("load", o), h = u;
              break;
            case "details":
              sl("toggle", o), h = u;
              break;
            case "input":
              Bie(o, u), h = Jte(o, u), sl("invalid", o);
              break;
            case "option":
              h = nne(o, u);
              break;
            case "select":
              o._wrapperState = { wasMultiple: !!u.multiple }, h = xl({}, u, { value: void 0 }), sl("invalid", o);
              break;
            case "textarea":
              Lie(o, u), h = one(o, u), sl("invalid", o);
              break;
            default:
              h = u;
          }
          ane(i, h);
          var _ = h;
          for (y in _) if (_.hasOwnProperty(y)) {
            var D = _[y];
            y === "style" ? Rde(o, D) : y === "dangerouslySetInnerHTML" ? (D = D ? D.__html : void 0, D != null && Pde(o, D)) : y === "children" ? typeof D == "string" ? (i !== "textarea" || D !== "") && e5(o, D) : typeof D == "number" && e5(o, "" + D) : y !== "suppressContentEditableWarning" && y !== "suppressHydrationWarning" && y !== "autoFocus" && (JI.hasOwnProperty(y) ? D != null && y === "onScroll" && sl("scroll", o) : D != null && Qoe(o, y, D, k));
          }
          switch (i) {
            case "input":
              p9(o), $ie(o, u, !1);
              break;
            case "textarea":
              p9(o), Hie(o);
              break;
            case "option":
              u.value != null && o.setAttribute("value", "" + xw(u.value));
              break;
            case "select":
              o.multiple = !!u.multiple, y = u.value, y != null ? f3(o, !!u.multiple, y, !1) : u.defaultValue != null && f3(o, !!u.multiple, u.defaultValue, !0);
              break;
            default:
              typeof h.onClick == "function" && (o.onclick = mV);
          }
          lfe(i, u) && (r.flags |= 4);
        }
        r.ref !== null && (r.flags |= 128);
      }
      return null;
    case 6:
      if (o && r.stateNode != null) Ife(o, r, o.memoizedProps, u);
      else {
        if (typeof u != "string" && r.stateNode === null) throw Error(ho(166));
        i = bk(d5.current), bk(bv.current), x9(r) ? (u = r.stateNode, i = r.memoizedProps, u[lw] = r, u.nodeValue !== i && (r.flags |= 4)) : (u = (i.nodeType === 9 ? i : i.ownerDocument).createTextNode(u), u[lw] = r, r.stateNode = u);
      }
      return null;
    case 13:
      return il(Zl), u = r.memoizedState, r.flags & 64 ? (r.lanes = i, r) : (u = u !== null, i = !1, o === null ? r.memoizedProps.fallback !== void 0 && x9(r) : i = o.memoizedState !== null, u && !i && r.mode & 2 && (o === null && r.memoizedProps.unstable_avoidThisFallback !== !0 || Zl.current & 1 ? sd === 0 && (sd = 3) : ((sd === 0 || sd === 3) && (sd = 4), Ef === null || !(Q5 & 134217727) && !(Z3 & 134217727) || v3(Ef, zd))), (u || i) && (r.flags |= 4), null);
    case 4:
      return O3(), Ene(r), o === null && sfe(r.stateNode.containerInfo), null;
    case 10:
      return Sre(r), null;
    case 17:
      return hm(r.type) && hV(), null;
    case 19:
      if (il(Zl), u = r.memoizedState, u === null) return null;
      if (y = (r.flags & 64) !== 0, k = u.rendering, k === null) if (y) SI(u, !1);
      else {
        if (sd !== 0 || o !== null && o.flags & 64) for (o = r.child; o !== null; ) {
          if (k = wV(o), k !== null) {
            for (r.flags |= 64, SI(u, !1), y = k.updateQueue, y !== null && (r.updateQueue = y, r.flags |= 4), u.lastEffect === null && (r.firstEffect = null), r.lastEffect = u.lastEffect, u = i, i = r.child; i !== null; ) y = i, o = u, y.flags &= 2, y.nextEffect = null, y.firstEffect = null, y.lastEffect = null, k = y.alternate, k === null ? (y.childLanes = 0, y.lanes = o, y.child = null, y.memoizedProps = null, y.memoizedState = null, y.updateQueue = null, y.dependencies = null, y.stateNode = null) : (y.childLanes = k.childLanes, y.lanes = k.lanes, y.child = k.child, y.memoizedProps = k.memoizedProps, y.memoizedState = k.memoizedState, y.updateQueue = k.updateQueue, y.type = k.type, o = k.dependencies, y.dependencies = o === null ? null : { lanes: o.lanes, firstContext: o.firstContext }), i = i.sibling;
            return ql(Zl, Zl.current & 1 | 2), r.child;
          }
          o = o.sibling;
        }
        u.tail !== null && Hd() > Rne && (r.flags |= 64, y = !0, SI(u, !1), r.lanes = 33554432);
      }
      else {
        if (!y) if (o = wV(k), o !== null) {
          if (r.flags |= 64, y = !0, i = o.updateQueue, i !== null && (r.updateQueue = i, r.flags |= 4), SI(u, !0), u.tail === null && u.tailMode === "hidden" && !k.alternate && !vv) return r = r.lastEffect = u.lastEffect, r !== null && (r.nextEffect = null), null;
        } else 2 * Hd() - u.renderingStartTime > Rne && i !== 1073741824 && (r.flags |= 64, y = !0, SI(u, !1), r.lanes = 33554432);
        u.isBackwards ? (k.sibling = r.child, r.child = k) : (i = u.last, i !== null ? i.sibling = k : r.child = k, u.last = k);
      }
      return u.tail !== null ? (i = u.tail, u.rendering = i, u.tail = i.sibling, u.lastEffect = r.lastEffect, u.renderingStartTime = Hd(), i.sibling = null, r = Zl.current, ql(Zl, y ? r & 1 | 2 : r & 1), i) : null;
    case 23:
    case 24:
      return Fre(), o !== null && o.memoizedState !== null != (r.memoizedState !== null) && u.mode !== "unstable-defer-without-hiding" && (r.flags |= 4), null;
  }
  throw Error(ho(156, r.tag));
}
function kbe(o) {
  switch (o.tag) {
    case 1:
      hm(o.type) && hV();
      var r = o.flags;
      return r & 4096 ? (o.flags = r & -4097 | 64, o) : null;
    case 3:
      if (O3(), il(pm), il(Ud), Ere(), r = o.flags, r & 64) throw Error(ho(285));
      return o.flags = r & -4097 | 64, o;
    case 5:
      return _re(o), null;
    case 13:
      return il(Zl), r = o.flags, r & 4096 ? (o.flags = r & -4097 | 64, o) : null;
    case 19:
      return il(Zl), null;
    case 4:
      return O3(), null;
    case 10:
      return Sre(o), null;
    case 23:
    case 24:
      return Fre(), null;
    default:
      return null;
  }
}
function Rre(o, r) {
  try {
    var i = "", u = r;
    do
      i += oge(u), u = u.return;
    while (u);
    var h = i;
  } catch (y) {
    h = `
Error generating stack: ` + y.message + `
` + y.stack;
  }
  return { value: o, source: r, stack: h };
}
function Tne(o, r) {
  try {
    console.error(r.value);
  } catch (i) {
    setTimeout(function() {
      throw i;
    });
  }
}
var _be = typeof WeakMap == "function" ? WeakMap : Map;
function Ffe(o, r, i) {
  i = pw(-1, i), i.tag = 3, i.payload = { element: null };
  var u = r.value;
  return i.callback = function() {
    OV || (OV = !0, Nne = u), Tne(o, r);
  }, i;
}
function Bfe(o, r, i) {
  i = pw(-1, i), i.tag = 3;
  var u = o.type.getDerivedStateFromError;
  if (typeof u == "function") {
    var h = r.value;
    i.payload = function() {
      return Tne(o, r), u(h);
    };
  }
  var y = o.stateNode;
  return y !== null && typeof y.componentDidCatch == "function" && (i.callback = function() {
    typeof u != "function" && (pv === null ? pv = /* @__PURE__ */ new Set([this]) : pv.add(this), Tne(o, r));
    var k = r.stack;
    this.componentDidCatch(r.value, { componentStack: k !== null ? k : "" });
  }), i;
}
var Ebe = typeof WeakSet == "function" ? WeakSet : Set;
function $le(o) {
  var r = o.ref;
  if (r !== null) if (typeof r == "function") try {
    r(null);
  } catch (i) {
    vw(o, i);
  }
  else r.current = null;
}
function Tbe(o, r) {
  switch (r.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      return;
    case 1:
      if (r.flags & 256 && o !== null) {
        var i = o.memoizedProps, u = o.memoizedState;
        o = r.stateNode, r = o.getSnapshotBeforeUpdate(r.elementType === r.type ? i : Hg(r.type, i), u), o.__reactInternalSnapshotBeforeUpdate = r;
      }
      return;
    case 3:
      r.flags & 256 && yre(r.stateNode.containerInfo);
      return;
    case 5:
    case 6:
    case 4:
    case 17:
      return;
  }
  throw Error(ho(163));
}
function Obe(o, r, i) {
  switch (i.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      if (r = i.updateQueue, r = r !== null ? r.lastEffect : null, r !== null) {
        o = r = r.next;
        do {
          if ((o.tag & 3) === 3) {
            var u = o.create;
            o.destroy = u();
          }
          o = o.next;
        } while (o !== r);
      }
      if (r = i.updateQueue, r = r !== null ? r.lastEffect : null, r !== null) {
        o = r = r.next;
        do {
          var h = o;
          u = h.next, h = h.tag, h & 4 && h & 1 && (Zfe(i, o), Fbe(i, o)), o = u;
        } while (o !== r);
      }
      return;
    case 1:
      o = i.stateNode, i.flags & 4 && (r === null ? o.componentDidMount() : (u = i.elementType === i.type ? r.memoizedProps : Hg(i.type, r.memoizedProps), o.componentDidUpdate(
        u,
        r.memoizedState,
        o.__reactInternalSnapshotBeforeUpdate
      ))), r = i.updateQueue, r !== null && yle(i, r, o);
      return;
    case 3:
      if (r = i.updateQueue, r !== null) {
        if (o = null, i.child !== null) switch (i.child.tag) {
          case 5:
            o = i.child.stateNode;
            break;
          case 1:
            o = i.child.stateNode;
        }
        yle(i, r, o);
      }
      return;
    case 5:
      o = i.stateNode, r === null && i.flags & 4 && lfe(i.type, i.memoizedProps) && o.focus();
      return;
    case 6:
      return;
    case 4:
      return;
    case 12:
      return;
    case 13:
      i.memoizedState === null && (i = i.alternate, i !== null && (i = i.memoizedState, i !== null && (i = i.dehydrated, i !== null && Vde(i))));
      return;
    case 19:
    case 17:
    case 20:
    case 21:
    case 23:
    case 24:
      return;
  }
  throw Error(ho(163));
}
function Lle(o, r) {
  for (var i = o; ; ) {
    if (i.tag === 5) {
      var u = i.stateNode;
      if (r) u = u.style, typeof u.setProperty == "function" ? u.setProperty("display", "none", "important") : u.display = "none";
      else {
        u = i.stateNode;
        var h = i.memoizedProps.style;
        h = h != null && h.hasOwnProperty("display") ? h.display : null, u.style.display = Dde("display", h);
      }
    } else if (i.tag === 6) i.stateNode.nodeValue = r ? "" : i.memoizedProps;
    else if ((i.tag !== 23 && i.tag !== 24 || i.memoizedState === null || i === o) && i.child !== null) {
      i.child.return = i, i = i.child;
      continue;
    }
    if (i === o) break;
    for (; i.sibling === null; ) {
      if (i.return === null || i.return === o) return;
      i = i.return;
    }
    i.sibling.return = i.return, i = i.sibling;
  }
}
function Hle(o, r) {
  if (kk && typeof kk.onCommitFiberUnmount == "function") try {
    kk.onCommitFiberUnmount(xre, r);
  } catch {
  }
  switch (r.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      if (o = r.updateQueue, o !== null && (o = o.lastEffect, o !== null)) {
        var i = o = o.next;
        do {
          var u = i, h = u.destroy;
          if (u = u.tag, h !== void 0) if (u & 4) Zfe(r, i);
          else {
            u = r;
            try {
              h();
            } catch (y) {
              vw(u, y);
            }
          }
          i = i.next;
        } while (i !== o);
      }
      break;
    case 1:
      if ($le(r), o = r.stateNode, typeof o.componentWillUnmount == "function") try {
        o.props = r.memoizedProps, o.state = r.memoizedState, o.componentWillUnmount();
      } catch (y) {
        vw(
          r,
          y
        );
      }
      break;
    case 5:
      $le(r);
      break;
    case 4:
      $fe(o, r);
  }
}
function zle(o) {
  o.alternate = null, o.child = null, o.dependencies = null, o.firstEffect = null, o.lastEffect = null, o.memoizedProps = null, o.memoizedState = null, o.pendingProps = null, o.return = null, o.updateQueue = null;
}
function Vle(o) {
  return o.tag === 5 || o.tag === 3 || o.tag === 4;
}
function jle(o) {
  e: {
    for (var r = o.return; r !== null; ) {
      if (Vle(r)) break e;
      r = r.return;
    }
    throw Error(ho(160));
  }
  var i = r;
  switch (r = i.stateNode, i.tag) {
    case 5:
      var u = !1;
      break;
    case 3:
      r = r.containerInfo, u = !0;
      break;
    case 4:
      r = r.containerInfo, u = !0;
      break;
    default:
      throw Error(ho(161));
  }
  i.flags & 16 && (e5(r, ""), i.flags &= -17);
  e: t: for (i = o; ; ) {
    for (; i.sibling === null; ) {
      if (i.return === null || Vle(i.return)) {
        i = null;
        break e;
      }
      i = i.return;
    }
    for (i.sibling.return = i.return, i = i.sibling; i.tag !== 5 && i.tag !== 6 && i.tag !== 18; ) {
      if (i.flags & 2 || i.child === null || i.tag === 4) continue t;
      i.child.return = i, i = i.child;
    }
    if (!(i.flags & 2)) {
      i = i.stateNode;
      break e;
    }
  }
  u ? One(o, i, r) : Ane(o, i, r);
}
function One(o, r, i) {
  var u = o.tag, h = u === 5 || u === 6;
  if (h) o = h ? o.stateNode : o.stateNode.instance, r ? i.nodeType === 8 ? i.parentNode.insertBefore(o, r) : i.insertBefore(o, r) : (i.nodeType === 8 ? (r = i.parentNode, r.insertBefore(o, i)) : (r = i, r.appendChild(o)), i = i._reactRootContainer, i != null || r.onclick !== null || (r.onclick = mV));
  else if (u !== 4 && (o = o.child, o !== null)) for (One(o, r, i), o = o.sibling; o !== null; ) One(o, r, i), o = o.sibling;
}
function Ane(o, r, i) {
  var u = o.tag, h = u === 5 || u === 6;
  if (h) o = h ? o.stateNode : o.stateNode.instance, r ? i.insertBefore(o, r) : i.appendChild(o);
  else if (u !== 4 && (o = o.child, o !== null)) for (Ane(o, r, i), o = o.sibling; o !== null; ) Ane(o, r, i), o = o.sibling;
}
function $fe(o, r) {
  for (var i = r, u = !1, h, y; ; ) {
    if (!u) {
      u = i.return;
      e: for (; ; ) {
        if (u === null) throw Error(ho(160));
        switch (h = u.stateNode, u.tag) {
          case 5:
            y = !1;
            break e;
          case 3:
            h = h.containerInfo, y = !0;
            break e;
          case 4:
            h = h.containerInfo, y = !0;
            break e;
        }
        u = u.return;
      }
      u = !0;
    }
    if (i.tag === 5 || i.tag === 6) {
      e: for (var k = o, _ = i, D = _; ; ) if (Hle(k, D), D.child !== null && D.tag !== 4) D.child.return = D, D = D.child;
      else {
        if (D === _) break e;
        for (; D.sibling === null; ) {
          if (D.return === null || D.return === _) break e;
          D = D.return;
        }
        D.sibling.return = D.return, D = D.sibling;
      }
      y ? (k = h, _ = i.stateNode, k.nodeType === 8 ? k.parentNode.removeChild(_) : k.removeChild(_)) : h.removeChild(i.stateNode);
    } else if (i.tag === 4) {
      if (i.child !== null) {
        h = i.stateNode.containerInfo, y = !0, i.child.return = i, i = i.child;
        continue;
      }
    } else if (Hle(o, i), i.child !== null) {
      i.child.return = i, i = i.child;
      continue;
    }
    if (i === r) break;
    for (; i.sibling === null; ) {
      if (i.return === null || i.return === r) return;
      i = i.return, i.tag === 4 && (u = !1);
    }
    i.sibling.return = i.return, i = i.sibling;
  }
}
function kte(o, r) {
  switch (r.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      var i = r.updateQueue;
      if (i = i !== null ? i.lastEffect : null, i !== null) {
        var u = i = i.next;
        do
          (u.tag & 3) === 3 && (o = u.destroy, u.destroy = void 0, o !== void 0 && o()), u = u.next;
        while (u !== i);
      }
      return;
    case 1:
      return;
    case 5:
      if (i = r.stateNode, i != null) {
        u = r.memoizedProps;
        var h = o !== null ? o.memoizedProps : u;
        o = r.type;
        var y = r.updateQueue;
        if (r.updateQueue = null, y !== null) {
          for (i[pV] = u, o === "input" && u.type === "radio" && u.name != null && Tde(i, u), ine(o, h), r = ine(o, u), h = 0; h < y.length; h += 2) {
            var k = y[h], _ = y[h + 1];
            k === "style" ? Rde(i, _) : k === "dangerouslySetInnerHTML" ? Pde(i, _) : k === "children" ? e5(i, _) : Qoe(i, k, _, r);
          }
          switch (o) {
            case "input":
              ene(i, u);
              break;
            case "textarea":
              Ode(i, u);
              break;
            case "select":
              o = i._wrapperState.wasMultiple, i._wrapperState.wasMultiple = !!u.multiple, y = u.value, y != null ? f3(i, !!u.multiple, y, !1) : o !== !!u.multiple && (u.defaultValue != null ? f3(i, !!u.multiple, u.defaultValue, !0) : f3(i, !!u.multiple, u.multiple ? [] : "", !1));
          }
        }
      }
      return;
    case 6:
      if (r.stateNode === null) throw Error(ho(162));
      r.stateNode.nodeValue = r.memoizedProps;
      return;
    case 3:
      i = r.stateNode, i.hydrate && (i.hydrate = !1, Vde(i.containerInfo));
      return;
    case 12:
      return;
    case 13:
      r.memoizedState !== null && (Ire = Hd(), Lle(r.child, !0)), Ule(r);
      return;
    case 19:
      Ule(r);
      return;
    case 17:
      return;
    case 23:
    case 24:
      Lle(r, r.memoizedState !== null);
      return;
  }
  throw Error(ho(163));
}
function Ule(o) {
  var r = o.updateQueue;
  if (r !== null) {
    o.updateQueue = null;
    var i = o.stateNode;
    i === null && (i = o.stateNode = new Ebe()), r.forEach(function(u) {
      var h = Lbe.bind(null, o, u);
      i.has(u) || (i.add(u), u.then(h, h));
    });
  }
}
function Abe(o, r) {
  return o !== null && (o = o.memoizedState, o === null || o.dehydrated !== null) ? (r = r.memoizedState, r !== null && r.dehydrated === null) : !1;
}
var Pbe = Math.ceil, TV = Bk.ReactCurrentDispatcher, Nre = Bk.ReactCurrentOwner, ds = 0, Ef = null, ru = null, zd = 0, Pk = 0, Pne = Pw(0), sd = 0, lj = null, W3 = 0, Q5 = 0, Z3 = 0, Mre = 0, Dne = null, Ire = 0, Rne = 1 / 0;
function G3() {
  Rne = Hd() + 500;
}
var er = null, OV = !1, Nne = null, pv = null, Sw = !1, WI = null, DI = 90, Mne = [], Ine = [], x0 = null, ZI = 0, Fne = null, K9 = -1, g0 = 0, Y9 = 0, GI = null, X9 = !1;
function np() {
  return ds & 48 ? Hd() : K9 !== -1 ? K9 : K9 = Hd();
}
function gw(o) {
  if (o = o.mode, !(o & 2)) return 1;
  if (!(o & 4)) return T3() === 99 ? 1 : 2;
  if (g0 === 0 && (g0 = W3), bbe.transition !== 0) {
    Y9 !== 0 && (Y9 = Dne !== null ? Dne.pendingLanes : 0), o = g0;
    var r = 4186112 & ~Y9;
    return r &= -r, r === 0 && (o = 4186112 & ~o, r = o & -o, r === 0 && (r = 8192)), r;
  }
  return o = T3(), ds & 4 && o === 98 ? o = dV(12, g0) : (o = yge(o), o = dV(o, g0)), o;
}
function bw(o, r, i) {
  if (50 < ZI) throw ZI = 0, Fne = null, Error(ho(185));
  if (o = cj(o, r), o === null) return null;
  tj(o, r, i), o === Ef && (Z3 |= r, sd === 4 && v3(o, zd));
  var u = T3();
  r === 1 ? ds & 8 && !(ds & 48) ? Bne(o) : (Sh(o, i), ds === 0 && (G3(), wv())) : (!(ds & 4) || u !== 98 && u !== 99 || (x0 === null ? x0 = /* @__PURE__ */ new Set([o]) : x0.add(o)), Sh(o, i)), Dne = o;
}
function cj(o, r) {
  o.lanes |= r;
  var i = o.alternate;
  for (i !== null && (i.lanes |= r), i = o, o = o.return; o !== null; ) o.childLanes |= r, i = o.alternate, i !== null && (i.childLanes |= r), i = o, o = o.return;
  return i.tag === 3 ? i.stateNode : null;
}
function Sh(o, r) {
  for (var i = o.callbackNode, u = o.suspendedLanes, h = o.pingedLanes, y = o.expirationTimes, k = o.pendingLanes; 0 < k; ) {
    var _ = 31 - ww(k), D = 1 << _, L = y[_];
    if (L === -1) {
      if (!(D & u) || D & h) {
        L = r, YA(D);
        var W = Vi;
        y[_] = 10 <= W ? L + 250 : 6 <= W ? L + 5e3 : -1;
      }
    } else L <= r && (o.expiredLanes |= D);
    k &= ~D;
  }
  if (u = r5(o, o === Ef ? zd : 0), r = Vi, u === 0) i !== null && (i !== yte && vne(i), o.callbackNode = null, o.callbackPriority = 0);
  else {
    if (i !== null) {
      if (o.callbackPriority === r) return;
      i !== yte && vne(i);
    }
    r === 15 ? (i = Bne.bind(null, o), h0 === null ? (h0 = [i], q9 = wre(aj, gfe)) : h0.push(i), i = yte) : r === 14 ? i = l5(99, Bne.bind(null, o)) : (i = xge(r), i = l5(i, Lfe.bind(null, o))), o.callbackPriority = r, o.callbackNode = i;
  }
}
function Lfe(o) {
  if (K9 = -1, Y9 = g0 = 0, ds & 48) throw Error(ho(327));
  var r = o.callbackNode;
  if (Dw() && o.callbackNode !== r) return null;
  var i = r5(o, o === Ef ? zd : 0);
  if (i === 0) return null;
  var u = i, h = ds;
  ds |= 16;
  var y = jfe();
  (Ef !== o || zd !== u) && (G3(), y3(o, u));
  do
    try {
      Nbe();
      break;
    } catch (_) {
      Vfe(o, _);
    }
  while (!0);
  if (Cre(), TV.current = y, ds = h, ru !== null ? u = 0 : (Ef = null, zd = 0, u = sd), W3 & Z3) y3(o, 0);
  else if (u !== 0) {
    if (u === 2 && (ds |= 64, o.hydrate && (o.hydrate = !1, yre(o.containerInfo)), i = Kde(o), i !== 0 && (u = RI(o, i))), u === 1) throw r = lj, y3(o, 0), v3(o, i), Sh(o, Hd()), r;
    switch (o.finishedWork = o.current.alternate, o.finishedLanes = i, u) {
      case 0:
      case 1:
        throw Error(ho(345));
      case 2:
        dk(o);
        break;
      case 3:
        if (v3(o, i), (i & 62914560) === i && (u = Ire + 500 - Hd(), 10 < u)) {
          if (r5(o, 0) !== 0) break;
          if (h = o.suspendedLanes, (h & i) !== i) {
            np(), o.pingedLanes |= o.suspendedLanes & h;
            break;
          }
          o.timeoutHandle = dle(dk.bind(null, o), u);
          break;
        }
        dk(o);
        break;
      case 4:
        if (v3(o, i), (i & 4186112) === i) break;
        for (u = o.eventTimes, h = -1; 0 < i; ) {
          var k = 31 - ww(i);
          y = 1 << k, k = u[k], k > h && (h = k), i &= ~y;
        }
        if (i = h, i = Hd() - i, i = (120 > i ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * Pbe(i / 1960)) - i, 10 < i) {
          o.timeoutHandle = dle(dk.bind(null, o), i);
          break;
        }
        dk(o);
        break;
      case 5:
        dk(o);
        break;
      default:
        throw Error(ho(329));
    }
  }
  return Sh(o, Hd()), o.callbackNode === r ? Lfe.bind(null, o) : null;
}
function v3(o, r) {
  for (r &= ~Mre, r &= ~Z3, o.suspendedLanes |= r, o.pingedLanes &= ~r, o = o.expirationTimes; 0 < r; ) {
    var i = 31 - ww(r), u = 1 << i;
    o[i] = -1, r &= ~u;
  }
}
function Bne(o) {
  if (ds & 48) throw Error(ho(327));
  if (Dw(), o === Ef && o.expiredLanes & zd) {
    var r = zd, i = RI(o, r);
    W3 & Z3 && (r = r5(o, r), i = RI(o, r));
  } else r = r5(o, 0), i = RI(o, r);
  if (o.tag !== 0 && i === 2 && (ds |= 64, o.hydrate && (o.hydrate = !1, yre(o.containerInfo)), r = Kde(o), r !== 0 && (i = RI(o, r))), i === 1) throw i = lj, y3(o, 0), v3(o, r), Sh(o, Hd()), i;
  return o.finishedWork = o.current.alternate, o.finishedLanes = r, dk(o), Sh(o, Hd()), null;
}
function Dbe() {
  if (x0 !== null) {
    var o = x0;
    x0 = null, o.forEach(function(r) {
      r.expiredLanes |= 24 & r.pendingLanes, Sh(r, Hd());
    });
  }
  wv();
}
function Hfe(o, r) {
  var i = ds;
  ds |= 1;
  try {
    return o(r);
  } finally {
    ds = i, ds === 0 && (G3(), wv());
  }
}
function zfe(o, r) {
  var i = ds;
  ds &= -2, ds |= 8;
  try {
    return o(r);
  } finally {
    ds = i, ds === 0 && (G3(), wv());
  }
}
function C9(o, r) {
  ql(Pne, Pk), Pk |= r, W3 |= r;
}
function Fre() {
  Pk = Pne.current, il(Pne);
}
function y3(o, r) {
  o.finishedWork = null, o.finishedLanes = 0;
  var i = o.timeoutHandle;
  if (i !== -1 && (o.timeoutHandle = -1, dbe(i)), ru !== null) for (i = ru.return; i !== null; ) {
    var u = i;
    switch (u.tag) {
      case 1:
        u = u.type.childContextTypes, u != null && hV();
        break;
      case 3:
        O3(), il(pm), il(Ud), Ere();
        break;
      case 5:
        _re(u);
        break;
      case 4:
        O3();
        break;
      case 13:
        il(Zl);
        break;
      case 19:
        il(Zl);
        break;
      case 10:
        Sre(u);
        break;
      case 23:
      case 24:
        Fre();
    }
    i = i.return;
  }
  Ef = o, ru = kw(o.current, null), zd = Pk = W3 = r, sd = 0, lj = null, Mre = Z3 = Q5 = 0;
}
function Vfe(o, r) {
  do {
    var i = ru;
    try {
      if (Cre(), jI.current = EV, CV) {
        for (var u = bc.memoizedState; u !== null; ) {
          var h = u.queue;
          h !== null && (h.pending = null), u = u.next;
        }
        CV = !1;
      }
      if (f5 = 0, rd = $d = bc = null, UI = !1, Nre.current = null, i === null || i.return === null) {
        sd = 1, lj = r, ru = null;
        break;
      }
      e: {
        var y = o, k = i.return, _ = i, D = r;
        if (r = zd, _.flags |= 2048, _.firstEffect = _.lastEffect = null, D !== null && typeof D == "object" && typeof D.then == "function") {
          var L = D;
          if (!(_.mode & 2)) {
            var W = _.alternate;
            W ? (_.updateQueue = W.updateQueue, _.memoizedState = W.memoizedState, _.lanes = W.lanes) : (_.updateQueue = null, _.memoizedState = null);
          }
          var se = (Zl.current & 1) !== 0, J = k;
          do {
            var be;
            if (be = J.tag === 13) {
              var ke = J.memoizedState;
              if (ke !== null) be = ke.dehydrated !== null;
              else {
                var Ce = J.memoizedProps;
                be = Ce.fallback === void 0 ? !1 : Ce.unstable_avoidThisFallback !== !0 ? !0 : !se;
              }
            }
            if (be) {
              var Q = J.updateQueue;
              if (Q === null) {
                var oe = /* @__PURE__ */ new Set();
                oe.add(L), J.updateQueue = oe;
              } else Q.add(L);
              if (!(J.mode & 2)) {
                if (J.flags |= 64, _.flags |= 16384, _.flags &= -2981, _.tag === 1) if (_.alternate === null) _.tag = 17;
                else {
                  var ae = pw(-1, 1);
                  ae.tag = 2, hw(_, ae);
                }
                _.lanes |= 1;
                break e;
              }
              D = void 0, _ = r;
              var G = y.pingCache;
              if (G === null ? (G = y.pingCache = new _be(), D = /* @__PURE__ */ new Set(), G.set(L, D)) : (D = G.get(L), D === void 0 && (D = /* @__PURE__ */ new Set(), G.set(L, D))), !D.has(_)) {
                D.add(_);
                var ve = $be.bind(null, y, L, _);
                L.then(ve, ve);
              }
              J.flags |= 4096, J.lanes = r;
              break e;
            }
            J = J.return;
          } while (J !== null);
          D = Error((d3(_.type) || "A React component") + ` suspended while rendering, but no fallback UI was specified.

Add a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.`);
        }
        sd !== 5 && (sd = 2), D = Rre(D, _), J = k;
        do {
          switch (J.tag) {
            case 3:
              y = D, J.flags |= 4096, r &= -r, J.lanes |= r;
              var nt = Ffe(J, y, r);
              vle(J, nt);
              break e;
            case 1:
              y = D;
              var Xe = J.type, te = J.stateNode;
              if (!(J.flags & 64) && (typeof Xe.getDerivedStateFromError == "function" || te !== null && typeof te.componentDidCatch == "function" && (pv === null || !pv.has(te)))) {
                J.flags |= 4096, r &= -r, J.lanes |= r;
                var lt = Bfe(J, y, r);
                vle(J, lt);
                break e;
              }
          }
          J = J.return;
        } while (J !== null);
      }
      Wfe(i);
    } catch (ot) {
      r = ot, ru === i && i !== null && (ru = i = i.return);
      continue;
    }
    break;
  } while (!0);
}
function jfe() {
  var o = TV.current;
  return TV.current = EV, o === null ? EV : o;
}
function RI(o, r) {
  var i = ds;
  ds |= 16;
  var u = jfe();
  Ef === o && zd === r || y3(o, r);
  do
    try {
      Rbe();
      break;
    } catch (h) {
      Vfe(o, h);
    }
  while (!0);
  if (Cre(), ds = i, TV.current = u, ru !== null) throw Error(ho(261));
  return Ef = null, zd = 0, sd;
}
function Rbe() {
  for (; ru !== null; ) Ufe(ru);
}
function Nbe() {
  for (; ru !== null && !pbe(); ) Ufe(ru);
}
function Ufe(o) {
  var r = Gfe(o.alternate, o, Pk);
  o.memoizedProps = o.pendingProps, r === null ? Wfe(o) : ru = r, Nre.current = null;
}
function Wfe(o) {
  var r = o;
  do {
    var i = r.alternate;
    if (o = r.return, r.flags & 2048) {
      if (i = kbe(r), i !== null) {
        i.flags &= 2047, ru = i;
        return;
      }
      o !== null && (o.firstEffect = o.lastEffect = null, o.flags |= 2048);
    } else {
      if (i = Sbe(i, r, Pk), i !== null) {
        ru = i;
        return;
      }
      if (i = r, i.tag !== 24 && i.tag !== 23 || i.memoizedState === null || Pk & 1073741824 || !(i.mode & 4)) {
        for (var u = 0, h = i.child; h !== null; ) u |= h.lanes | h.childLanes, h = h.sibling;
        i.childLanes = u;
      }
      o !== null && !(o.flags & 2048) && (o.firstEffect === null && (o.firstEffect = r.firstEffect), r.lastEffect !== null && (o.lastEffect !== null && (o.lastEffect.nextEffect = r.firstEffect), o.lastEffect = r.lastEffect), 1 < r.flags && (o.lastEffect !== null ? o.lastEffect.nextEffect = r : o.firstEffect = r, o.lastEffect = r));
    }
    if (r = r.sibling, r !== null) {
      ru = r;
      return;
    }
    ru = r = o;
  } while (r !== null);
  sd === 0 && (sd = 5);
}
function dk(o) {
  var r = T3();
  return Ak(99, Mbe.bind(null, o, r)), null;
}
function Mbe(o, r) {
  do
    Dw();
  while (WI !== null);
  if (ds & 48) throw Error(ho(327));
  var i = o.finishedWork;
  if (i === null) return null;
  if (o.finishedWork = null, o.finishedLanes = 0, i === o.current) throw Error(ho(177));
  o.callbackNode = null;
  var u = i.lanes | i.childLanes, h = u, y = o.pendingLanes & ~h;
  o.pendingLanes = h, o.suspendedLanes = 0, o.pingedLanes = 0, o.expiredLanes &= h, o.mutableReadLanes &= h, o.entangledLanes &= h, h = o.entanglements;
  for (var k = o.eventTimes, _ = o.expirationTimes; 0 < y; ) {
    var D = 31 - ww(y), L = 1 << D;
    h[D] = 0, k[D] = -1, _[D] = -1, y &= ~L;
  }
  if (x0 !== null && !(u & 24) && x0.has(o) && x0.delete(o), o === Ef && (ru = Ef = null, zd = 0), 1 < i.flags ? i.lastEffect !== null ? (i.lastEffect.nextEffect = i, u = i.firstEffect) : u = i : u = i.firstEffect, u !== null) {
    if (h = ds, ds |= 32, Nre.current = null, gte = U9, k = rle(), mne(k)) {
      if ("selectionStart" in k) _ = { start: k.selectionStart, end: k.selectionEnd };
      else e: if (_ = (_ = k.ownerDocument) && _.defaultView || window, (L = _.getSelection && _.getSelection()) && L.rangeCount !== 0) {
        _ = L.anchorNode, y = L.anchorOffset, D = L.focusNode, L = L.focusOffset;
        try {
          _.nodeType, D.nodeType;
        } catch {
          _ = null;
          break e;
        }
        var W = 0, se = -1, J = -1, be = 0, ke = 0, Ce = k, Q = null;
        t: for (; ; ) {
          for (var oe; Ce !== _ || y !== 0 && Ce.nodeType !== 3 || (se = W + y), Ce !== D || L !== 0 && Ce.nodeType !== 3 || (J = W + L), Ce.nodeType === 3 && (W += Ce.nodeValue.length), (oe = Ce.firstChild) !== null; )
            Q = Ce, Ce = oe;
          for (; ; ) {
            if (Ce === k) break t;
            if (Q === _ && ++be === y && (se = W), Q === D && ++ke === L && (J = W), (oe = Ce.nextSibling) !== null) break;
            Ce = Q, Q = Ce.parentNode;
          }
          Ce = oe;
        }
        _ = se === -1 || J === -1 ? null : { start: se, end: J };
      } else _ = null;
      _ = _ || { start: 0, end: 0 };
    } else _ = null;
    bte = { focusedElem: k, selectionRange: _ }, U9 = !1, GI = null, X9 = !1, er = u;
    do
      try {
        Ibe();
      } catch (ot) {
        if (er === null) throw Error(ho(330));
        vw(er, ot), er = er.nextEffect;
      }
    while (er !== null);
    GI = null, er = u;
    do
      try {
        for (k = o; er !== null; ) {
          var ae = er.flags;
          if (ae & 16 && e5(er.stateNode, ""), ae & 128) {
            var G = er.alternate;
            if (G !== null) {
              var ve = G.ref;
              ve !== null && (typeof ve == "function" ? ve(null) : ve.current = null);
            }
          }
          switch (ae & 1038) {
            case 2:
              jle(er), er.flags &= -3;
              break;
            case 6:
              jle(er), er.flags &= -3, kte(er.alternate, er);
              break;
            case 1024:
              er.flags &= -1025;
              break;
            case 1028:
              er.flags &= -1025, kte(er.alternate, er);
              break;
            case 4:
              kte(er.alternate, er);
              break;
            case 8:
              _ = er, $fe(k, _);
              var nt = _.alternate;
              zle(_), nt !== null && zle(nt);
          }
          er = er.nextEffect;
        }
      } catch (ot) {
        if (er === null) throw Error(ho(330));
        vw(er, ot), er = er.nextEffect;
      }
    while (er !== null);
    if (ve = bte, G = rle(), ae = ve.focusedElem, k = ve.selectionRange, G !== ae && ae && ae.ownerDocument && ofe(ae.ownerDocument.documentElement, ae)) {
      for (k !== null && mne(ae) && (G = k.start, ve = k.end, ve === void 0 && (ve = G), "selectionStart" in ae ? (ae.selectionStart = G, ae.selectionEnd = Math.min(ve, ae.value.length)) : (ve = (G = ae.ownerDocument || document) && G.defaultView || window, ve.getSelection && (ve = ve.getSelection(), _ = ae.textContent.length, nt = Math.min(k.start, _), k = k.end === void 0 ? nt : Math.min(k.end, _), !ve.extend && nt > k && (_ = k, k = nt, nt = _), _ = ole(ae, nt), y = ole(ae, k), _ && y && (ve.rangeCount !== 1 || ve.anchorNode !== _.node || ve.anchorOffset !== _.offset || ve.focusNode !== y.node || ve.focusOffset !== y.offset) && (G = G.createRange(), G.setStart(_.node, _.offset), ve.removeAllRanges(), nt > k ? (ve.addRange(G), ve.extend(y.node, y.offset)) : (G.setEnd(y.node, y.offset), ve.addRange(G)))))), G = [], ve = ae; ve = ve.parentNode; ) ve.nodeType === 1 && G.push({ element: ve, left: ve.scrollLeft, top: ve.scrollTop });
      for (typeof ae.focus == "function" && ae.focus(), ae = 0; ae < G.length; ae++) ve = G[ae], ve.element.scrollLeft = ve.left, ve.element.scrollTop = ve.top;
    }
    U9 = !!gte, bte = gte = null, o.current = i, er = u;
    do
      try {
        for (ae = o; er !== null; ) {
          var Xe = er.flags;
          if (Xe & 36 && Obe(ae, er.alternate, er), Xe & 128) {
            G = void 0;
            var te = er.ref;
            if (te !== null) {
              var lt = er.stateNode;
              switch (er.tag) {
                case 5:
                  G = lt;
                  break;
                default:
                  G = lt;
              }
              typeof te == "function" ? te(G) : te.current = G;
            }
          }
          er = er.nextEffect;
        }
      } catch (ot) {
        if (er === null) throw Error(ho(330));
        vw(er, ot), er = er.nextEffect;
      }
    while (er !== null);
    er = null, gbe(), ds = h;
  } else o.current = i;
  if (Sw) Sw = !1, WI = o, DI = r;
  else for (er = u; er !== null; ) r = er.nextEffect, er.nextEffect = null, er.flags & 8 && (Xe = er, Xe.sibling = null, Xe.stateNode = null), er = r;
  if (u = o.pendingLanes, u === 0 && (pv = null), u === 1 ? o === Fne ? ZI++ : (ZI = 0, Fne = o) : ZI = 0, i = i.stateNode, kk && typeof kk.onCommitFiberRoot == "function") try {
    kk.onCommitFiberRoot(xre, i, void 0, (i.current.flags & 64) === 64);
  } catch {
  }
  if (Sh(o, Hd()), OV) throw OV = !1, o = Nne, Nne = null, o;
  return ds & 8 || wv(), null;
}
function Ibe() {
  for (; er !== null; ) {
    var o = er.alternate;
    X9 || GI === null || (er.flags & 8 ? jie(er, GI) && (X9 = !0) : er.tag === 13 && Abe(o, er) && jie(er, GI) && (X9 = !0));
    var r = er.flags;
    r & 256 && Tbe(o, er), !(r & 512) || Sw || (Sw = !0, l5(97, function() {
      return Dw(), null;
    })), er = er.nextEffect;
  }
}
function Dw() {
  if (DI !== 90) {
    var o = 97 < DI ? 97 : DI;
    return DI = 90, Ak(o, Bbe);
  }
  return !1;
}
function Fbe(o, r) {
  Mne.push(r, o), Sw || (Sw = !0, l5(97, function() {
    return Dw(), null;
  }));
}
function Zfe(o, r) {
  Ine.push(r, o), Sw || (Sw = !0, l5(97, function() {
    return Dw(), null;
  }));
}
function Bbe() {
  if (WI === null) return !1;
  var o = WI;
  if (WI = null, ds & 48) throw Error(ho(331));
  var r = ds;
  ds |= 32;
  var i = Ine;
  Ine = [];
  for (var u = 0; u < i.length; u += 2) {
    var h = i[u], y = i[u + 1], k = h.destroy;
    if (h.destroy = void 0, typeof k == "function") try {
      k();
    } catch (D) {
      if (y === null) throw Error(ho(330));
      vw(y, D);
    }
  }
  for (i = Mne, Mne = [], u = 0; u < i.length; u += 2) {
    h = i[u], y = i[u + 1];
    try {
      var _ = h.create;
      h.destroy = _();
    } catch (D) {
      if (y === null) throw Error(ho(330));
      vw(y, D);
    }
  }
  for (_ = o.current.firstEffect; _ !== null; ) o = _.nextEffect, _.nextEffect = null, _.flags & 8 && (_.sibling = null, _.stateNode = null), _ = o;
  return ds = r, wv(), !0;
}
function Wle(o, r, i) {
  r = Rre(i, r), r = Ffe(o, r, 1), hw(o, r), r = np(), o = cj(o, 1), o !== null && (tj(o, 1, r), Sh(o, r));
}
function vw(o, r) {
  if (o.tag === 3) Wle(o, o, r);
  else for (var i = o.return; i !== null; ) {
    if (i.tag === 3) {
      Wle(i, o, r);
      break;
    } else if (i.tag === 1) {
      var u = i.stateNode;
      if (typeof i.type.getDerivedStateFromError == "function" || typeof u.componentDidCatch == "function" && (pv === null || !pv.has(u))) {
        o = Rre(r, o);
        var h = Bfe(i, o, 1);
        if (hw(i, h), h = np(), i = cj(i, 1), i !== null) tj(i, 1, h), Sh(i, h);
        else if (typeof u.componentDidCatch == "function" && (pv === null || !pv.has(u))) try {
          u.componentDidCatch(r, o);
        } catch {
        }
        break;
      }
    }
    i = i.return;
  }
}
function $be(o, r, i) {
  var u = o.pingCache;
  u !== null && u.delete(r), r = np(), o.pingedLanes |= o.suspendedLanes & i, Ef === o && (zd & i) === i && (sd === 4 || sd === 3 && (zd & 62914560) === zd && 500 > Hd() - Ire ? y3(o, 0) : Mre |= i), Sh(o, r);
}
function Lbe(o, r) {
  var i = o.stateNode;
  i !== null && i.delete(r), r = 0, r === 0 && (r = o.mode, r & 2 ? r & 4 ? (g0 === 0 && (g0 = W3), r = XA(62914560 & ~g0), r === 0 && (r = 4194304)) : r = T3() === 99 ? 1 : 2 : r = 1), i = np(), o = cj(o, r), o !== null && (tj(o, r, i), Sh(o, i));
}
var Gfe;
Gfe = function(o, r, i) {
  var u = r.lanes;
  if (o !== null) if (o.memoizedProps !== r.pendingProps || pm.current) Vg = !0;
  else if (i & u) Vg = !!(o.flags & 16384);
  else {
    switch (Vg = !1, r.tag) {
      case 3:
        Dle(r), wte();
        break;
      case 5:
        Cle(r);
        break;
      case 1:
        hm(r.type) && G9(r);
        break;
      case 4:
        wne(r, r.stateNode.containerInfo);
        break;
      case 10:
        u = r.memoizedProps.value;
        var h = r.type._context;
        ql(gV, h._currentValue), h._currentValue = u;
        break;
      case 13:
        if (r.memoizedState !== null)
          return i & r.child.childLanes ? Rle(o, r, i) : (ql(Zl, Zl.current & 1), r = y0(o, r, i), r !== null ? r.sibling : null);
        ql(Zl, Zl.current & 1);
        break;
      case 19:
        if (u = (i & r.childLanes) !== 0, o.flags & 64) {
          if (u) return Ble(o, r, i);
          r.flags |= 64;
        }
        if (h = r.memoizedState, h !== null && (h.rendering = null, h.tail = null, h.lastEffect = null), ql(Zl, Zl.current), u) break;
        return null;
      case 23:
      case 24:
        return r.lanes = 0, Cte(o, r, i);
    }
    return y0(o, r, i);
  }
  else Vg = !1;
  switch (r.lanes = 0, r.tag) {
    case 2:
      if (u = r.type, o !== null && (o.alternate = null, r.alternate = null, r.flags |= 2), o = r.pendingProps, h = E3(r, Ud.current), g3(r, i), h = Ore(null, r, u, o, h, i), r.flags |= 1, typeof h == "object" && h !== null && typeof h.render == "function" && h.$$typeof === void 0) {
        if (r.tag = 1, r.memoizedState = null, r.updateQueue = null, hm(u)) {
          var y = !0;
          G9(r);
        } else y = !1;
        r.memoizedState = h.state !== null && h.state !== void 0 ? h.state : null, kre(r);
        var k = u.getDerivedStateFromProps;
        typeof k == "function" && yV(r, u, k, o), h.updater = ij, r.stateNode = h, h._reactInternals = r, xne(r, u, o, i), r = _ne(null, r, u, !0, y, i);
      } else r.tag = 0, mm(null, r, h, i), r = r.child;
      return r;
    case 16:
      h = r.elementType;
      e: {
        switch (o !== null && (o.alternate = null, r.alternate = null, r.flags |= 2), o = r.pendingProps, y = h._init, h = y(h._payload), r.type = h, y = r.tag = zbe(h), o = Hg(h, o), y) {
          case 0:
            r = kne(null, r, h, o, i);
            break e;
          case 1:
            r = Ple(null, r, h, o, i);
            break e;
          case 11:
            r = Ole(null, r, h, o, i);
            break e;
          case 14:
            r = Ale(null, r, h, Hg(h.type, o), u, i);
            break e;
        }
        throw Error(ho(306, h, ""));
      }
      return r;
    case 0:
      return u = r.type, h = r.pendingProps, h = r.elementType === u ? h : Hg(u, h), kne(o, r, u, h, i);
    case 1:
      return u = r.type, h = r.pendingProps, h = r.elementType === u ? h : Hg(u, h), Ple(o, r, u, h, i);
    case 3:
      if (Dle(r), u = r.updateQueue, o === null || u === null) throw Error(ho(282));
      if (u = r.pendingProps, h = r.memoizedState, h = h !== null ? h.element : null, vfe(o, r), c5(r, u, null, i), u = r.memoizedState.element, u === h) wte(), r = y0(o, r, i);
      else {
        if (h = r.stateNode, (y = h.hydrate) && (cw = h3(r.stateNode.containerInfo.firstChild), v0 = r, y = vv = !0), y) {
          if (o = h.mutableSourceEagerHydrationData, o != null) for (h = 0; h < o.length; h += 2) y = o[h], y._workInProgressVersionPrimary = o[h + 1], b3.push(y);
          for (i = Cfe(r, null, u, i), r.child = i; i; ) i.flags = i.flags & -3 | 1024, i = i.sibling;
        } else mm(o, r, u, i), wte();
        r = r.child;
      }
      return r;
    case 5:
      return Cle(r), o === null && Cne(r), u = r.type, h = r.pendingProps, y = o !== null ? o.memoizedProps : null, k = h.children, gne(u, h) ? k = null : y !== null && gne(u, y) && (r.flags |= 16), Rfe(o, r), mm(o, r, k, i), r.child;
    case 6:
      return o === null && Cne(r), null;
    case 13:
      return Rle(o, r, i);
    case 4:
      return wne(r, r.stateNode.containerInfo), u = r.pendingProps, o === null ? r.child = xV(r, null, u, i) : mm(o, r, u, i), r.child;
    case 11:
      return u = r.type, h = r.pendingProps, h = r.elementType === u ? h : Hg(u, h), Ole(o, r, u, h, i);
    case 7:
      return mm(o, r, r.pendingProps, i), r.child;
    case 8:
      return mm(
        o,
        r,
        r.pendingProps.children,
        i
      ), r.child;
    case 12:
      return mm(o, r, r.pendingProps.children, i), r.child;
    case 10:
      e: {
        u = r.type._context, h = r.pendingProps, k = r.memoizedProps, y = h.value;
        var _ = r.type._context;
        if (ql(gV, _._currentValue), _._currentValue = y, k !== null) if (_ = k.value, y = vh(_, y) ? 0 : (typeof u._calculateChangedBits == "function" ? u._calculateChangedBits(_, y) : 1073741823) | 0, y === 0) {
          if (k.children === h.children && !pm.current) {
            r = y0(o, r, i);
            break e;
          }
        } else for (_ = r.child, _ !== null && (_.return = r); _ !== null; ) {
          var D = _.dependencies;
          if (D !== null) {
            k = _.child;
            for (var L = D.firstContext; L !== null; ) {
              if (L.context === u && L.observedBits & y) {
                _.tag === 1 && (L = pw(-1, i & -i), L.tag = 2, hw(_, L)), _.lanes |= i, L = _.alternate, L !== null && (L.lanes |= i), bfe(_.return, i), D.lanes |= i;
                break;
              }
              L = L.next;
            }
          } else k = _.tag === 10 && _.type === r.type ? null : _.child;
          if (k !== null) k.return = _;
          else for (k = _; k !== null; ) {
            if (k === r) {
              k = null;
              break;
            }
            if (_ = k.sibling, _ !== null) {
              _.return = k.return, k = _;
              break;
            }
            k = k.return;
          }
          _ = k;
        }
        mm(o, r, h.children, i), r = r.child;
      }
      return r;
    case 9:
      return h = r.type, y = r.pendingProps, u = y.children, g3(r, i), h = Ch(
        h,
        y.unstable_observedBits
      ), u = u(h), r.flags |= 1, mm(o, r, u, i), r.child;
    case 14:
      return h = r.type, y = Hg(h, r.pendingProps), y = Hg(h.type, y), Ale(o, r, h, y, u, i);
    case 15:
      return Dfe(o, r, r.type, r.pendingProps, u, i);
    case 17:
      return u = r.type, h = r.pendingProps, h = r.elementType === u ? h : Hg(u, h), o !== null && (o.alternate = null, r.alternate = null, r.flags |= 2), r.tag = 1, hm(u) ? (o = !0, G9(r)) : o = !1, g3(r, i), xfe(r, u, h), xne(r, u, h, i), _ne(null, r, u, !0, o, i);
    case 19:
      return Ble(o, r, i);
    case 23:
      return Cte(o, r, i);
    case 24:
      return Cte(o, r, i);
  }
  throw Error(ho(156, r.tag));
};
function Hbe(o, r, i, u) {
  this.tag = o, this.key = i, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = r, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = u, this.flags = 0, this.lastEffect = this.firstEffect = this.nextEffect = null, this.childLanes = this.lanes = 0, this.alternate = null;
}
function yh(o, r, i, u) {
  return new Hbe(o, r, i, u);
}
function Bre(o) {
  return o = o.prototype, !(!o || !o.isReactComponent);
}
function zbe(o) {
  if (typeof o == "function") return Bre(o) ? 1 : 0;
  if (o != null) {
    if (o = o.$$typeof, o === QV) return 11;
    if (o === JV) return 14;
  }
  return 2;
}
function kw(o, r) {
  var i = o.alternate;
  return i === null ? (i = yh(o.tag, r, o.key, o.mode), i.elementType = o.elementType, i.type = o.type, i.stateNode = o.stateNode, i.alternate = o, o.alternate = i) : (i.pendingProps = r, i.type = o.type, i.flags = 0, i.nextEffect = null, i.firstEffect = null, i.lastEffect = null), i.childLanes = o.childLanes, i.lanes = o.lanes, i.child = o.child, i.memoizedProps = o.memoizedProps, i.memoizedState = o.memoizedState, i.updateQueue = o.updateQueue, r = o.dependencies, i.dependencies = r === null ? null : { lanes: r.lanes, firstContext: r.firstContext }, i.sibling = o.sibling, i.index = o.index, i.ref = o.ref, i;
}
function Q9(o, r, i, u, h, y) {
  var k = 2;
  if (u = o, typeof o == "function") Bre(o) && (k = 1);
  else if (typeof o == "string") k = 5;
  else e: switch (o) {
    case aw:
      return x3(i.children, h, y, r);
    case kde:
      k = 8, h |= 16;
      break;
    case Joe:
      k = 8, h |= 1;
      break;
    case FI:
      return o = yh(12, i, r, h | 8), o.elementType = FI, o.type = FI, o.lanes = y, o;
    case BI:
      return o = yh(13, i, r, h), o.type = BI, o.elementType = BI, o.lanes = y, o;
    case iV:
      return o = yh(19, i, r, h), o.elementType = iV, o.lanes = y, o;
    case sre:
      return $re(i, h, y, r);
    case Qte:
      return o = yh(24, i, r, h), o.elementType = Qte, o.lanes = y, o;
    default:
      if (typeof o == "object" && o !== null) switch (o.$$typeof) {
        case ere:
          k = 10;
          break e;
        case tre:
          k = 9;
          break e;
        case QV:
          k = 11;
          break e;
        case JV:
          k = 14;
          break e;
        case nre:
          k = 16, u = null;
          break e;
        case ore:
          k = 22;
          break e;
      }
      throw Error(ho(130, o == null ? o : typeof o, ""));
  }
  return r = yh(k, i, r, h), r.elementType = o, r.type = u, r.lanes = y, r;
}
function x3(o, r, i, u) {
  return o = yh(7, o, u, r), o.lanes = i, o;
}
function $re(o, r, i, u) {
  return o = yh(23, o, u, r), o.elementType = sre, o.lanes = i, o;
}
function _te(o, r, i) {
  return o = yh(6, o, null, r), o.lanes = i, o;
}
function Ete(o, r, i) {
  return r = yh(4, o.children !== null ? o.children : [], o.key, r), r.lanes = i, r.stateNode = { containerInfo: o.containerInfo, pendingChildren: null, implementation: o.implementation }, r;
}
function Vbe(o, r, i) {
  this.tag = r, this.containerInfo = o, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.pendingContext = this.context = null, this.hydrate = i, this.callbackNode = null, this.callbackPriority = 0, this.eventTimes = cte(0), this.expirationTimes = cte(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = cte(0), this.mutableSourceEagerHydrationData = null;
}
function jbe(o, r, i) {
  var u = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return { $$typeof: pk, key: u == null ? null : "" + u, children: o, containerInfo: r, implementation: i };
}
function AV(o, r, i, u) {
  var h = r.current, y = np(), k = gw(h);
  e: if (i) {
    i = i._reactInternals;
    t: {
      if ($k(i) !== i || i.tag !== 1) throw Error(ho(170));
      var _ = i;
      do {
        switch (_.tag) {
          case 3:
            _ = _.stateNode.context;
            break t;
          case 1:
            if (hm(_.type)) {
              _ = _.stateNode.__reactInternalMemoizedMergedChildContext;
              break t;
            }
        }
        _ = _.return;
      } while (_ !== null);
      throw Error(ho(171));
    }
    if (i.tag === 1) {
      var D = i.type;
      if (hm(D)) {
        i = ufe(i, D, _);
        break e;
      }
    }
    i = _;
  } else i = Cw;
  return r.context === null ? r.context = i : r.pendingContext = i, r = pw(y, k), r.payload = { element: o }, u = u === void 0 ? null : u, u !== null && (r.callback = u), hw(h, r), bw(h, k, y), k;
}
function Tte(o) {
  if (o = o.current, !o.child) return null;
  switch (o.child.tag) {
    case 5:
      return o.child.stateNode;
    default:
      return o.child.stateNode;
  }
}
function Zle(o, r) {
  if (o = o.memoizedState, o !== null && o.dehydrated !== null) {
    var i = o.retryLane;
    o.retryLane = i !== 0 && i < r ? i : r;
  }
}
function Lre(o, r) {
  Zle(o, r), (o = o.alternate) && Zle(o, r);
}
function Ube() {
  return null;
}
function Hre(o, r, i) {
  var u = i != null && i.hydrationOptions != null && i.hydrationOptions.mutableSources || null;
  if (i = new Vbe(o, r, i != null && i.hydrate === !0), r = yh(3, null, null, r === 2 ? 7 : r === 1 ? 3 : 0), i.current = r, r.stateNode = i, kre(r), o[U3] = i.current, sfe(o.nodeType === 8 ? o.parentNode : o), u) for (o = 0; o < u.length; o++) {
    r = u[o];
    var h = r._getVersion;
    h = h(r._source), i.mutableSourceEagerHydrationData == null ? i.mutableSourceEagerHydrationData = [r, h] : i.mutableSourceEagerHydrationData.push(r, h);
  }
  this._internalRoot = i;
}
Hre.prototype.render = function(o) {
  AV(o, this._internalRoot, null, null);
};
Hre.prototype.unmount = function() {
  var o = this._internalRoot, r = o.containerInfo;
  AV(null, o, null, function() {
    r[U3] = null;
  });
};
function J5(o) {
  return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11 && (o.nodeType !== 8 || o.nodeValue !== " react-mount-point-unstable "));
}
function Wbe(o, r) {
  if (r || (r = o ? o.nodeType === 9 ? o.documentElement : o.firstChild : null, r = !(!r || r.nodeType !== 1 || !r.hasAttribute("data-reactroot"))), !r) for (var i; i = o.lastChild; ) o.removeChild(i);
  return new Hre(o, 0, r ? { hydrate: !0 } : void 0);
}
function uj(o, r, i, u, h) {
  var y = i._reactRootContainer;
  if (y) {
    var k = y._internalRoot;
    if (typeof h == "function") {
      var _ = h;
      h = function() {
        var L = Tte(k);
        _.call(L);
      };
    }
    AV(r, k, o, h);
  } else {
    if (y = i._reactRootContainer = Wbe(i, u), k = y._internalRoot, typeof h == "function") {
      var D = h;
      h = function() {
        var L = Tte(k);
        D.call(L);
      };
    }
    zfe(function() {
      AV(r, k, o, h);
    });
  }
  return Tte(k);
}
Lde = function(o) {
  if (o.tag === 13) {
    var r = np();
    bw(o, 4, r), Lre(o, 4);
  }
};
ure = function(o) {
  if (o.tag === 13) {
    var r = np();
    bw(o, 67108864, r), Lre(o, 67108864);
  }
};
Hde = function(o) {
  if (o.tag === 13) {
    var r = np(), i = gw(o);
    bw(o, i, r), Lre(o, i);
  }
};
zde = function(o, r) {
  return r();
};
lne = function(o, r, i) {
  switch (r) {
    case "input":
      if (ene(o, i), r = i.name, i.type === "radio" && r != null) {
        for (i = o; i.parentNode; ) i = i.parentNode;
        for (i = i.querySelectorAll("input[name=" + JSON.stringify("" + r) + '][type="radio"]'), r = 0; r < i.length; r++) {
          var u = i[r];
          if (u !== o && u.form === o.form) {
            var h = sj(u);
            if (!h) throw Error(ho(90));
            Ede(u), ene(u, h);
          }
        }
      }
      break;
    case "textarea":
      Ode(o, i);
      break;
    case "select":
      r = i.value, r != null && f3(o, !!i.multiple, r, !1);
  }
};
ire = Hfe;
Ide = function(o, r, i, u, h) {
  var y = ds;
  ds |= 4;
  try {
    return Ak(98, o.bind(null, r, i, u, h));
  } finally {
    ds = y, ds === 0 && (G3(), wv());
  }
};
lre = function() {
  !(ds & 49) && (Dbe(), Dw());
};
Fde = function(o, r) {
  var i = ds;
  ds |= 2;
  try {
    return o(r);
  } finally {
    ds = i, ds === 0 && (G3(), wv());
  }
};
function qfe(o, r) {
  var i = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!J5(r)) throw Error(ho(200));
  return jbe(o, r, null, i);
}
var Zbe = { Events: [Y5, t3, sj, Nde, Mde, Dw, { current: !1 }] }, kI = { findFiberByHostInstance: gk, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom" }, Gbe = { bundleType: kI.bundleType, version: kI.version, rendererPackageName: kI.rendererPackageName, rendererConfig: kI.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Bk.ReactCurrentDispatcher, findHostInstanceByFiber: function(o) {
  return o = $de(o), o === null ? null : o.stateNode;
}, findFiberByHostInstance: kI.findFiberByHostInstance || Ube, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var S9 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!S9.isDisabled && S9.supportsFiber) try {
    xre = S9.inject(Gbe), kk = S9;
  } catch {
  }
}
Eh.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Zbe;
Eh.createPortal = qfe;
Eh.findDOMNode = function(o) {
  if (o == null) return null;
  if (o.nodeType === 1) return o;
  var r = o._reactInternals;
  if (r === void 0)
    throw typeof o.render == "function" ? Error(ho(188)) : Error(ho(268, Object.keys(o)));
  return o = $de(r), o = o === null ? null : o.stateNode, o;
};
Eh.flushSync = function(o, r) {
  var i = ds;
  if (i & 48) return o(r);
  ds |= 1;
  try {
    if (o) return Ak(99, o.bind(null, r));
  } finally {
    ds = i, wv();
  }
};
Eh.hydrate = function(o, r, i) {
  if (!J5(r)) throw Error(ho(200));
  return uj(null, o, r, !0, i);
};
Eh.render = function(o, r, i) {
  if (!J5(r)) throw Error(ho(200));
  return uj(null, o, r, !1, i);
};
Eh.unmountComponentAtNode = function(o) {
  if (!J5(o)) throw Error(ho(40));
  return o._reactRootContainer ? (zfe(function() {
    uj(null, null, o, !1, function() {
      o._reactRootContainer = null, o[U3] = null;
    });
  }), !0) : !1;
};
Eh.unstable_batchedUpdates = Hfe;
Eh.unstable_createPortal = function(o, r) {
  return qfe(o, r, 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null);
};
Eh.unstable_renderSubtreeIntoContainer = function(o, r, i, u) {
  if (!J5(i)) throw Error(ho(200));
  if (o == null || o._reactInternals === void 0) throw Error(ho(38));
  return uj(o, r, i, !1, u);
};
Eh.version = "17.0.2";
function Kfe() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Kfe);
    } catch (o) {
      console.error(o);
    }
}
Kfe(), xde.exports = Eh;
var zre = xde.exports;
const yk = /* @__PURE__ */ H3(zre);
var Yfe = { exports: {} }, qbe = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED", Kbe = qbe, Ybe = Kbe;
function Xfe() {
}
function Qfe() {
}
Qfe.resetWarningCache = Xfe;
var Xbe = function() {
  function o(u, h, y, k, _, D) {
    if (D !== Ybe) {
      var L = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      throw L.name = "Invariant Violation", L;
    }
  }
  o.isRequired = o;
  function r() {
    return o;
  }
  var i = {
    array: o,
    bigint: o,
    bool: o,
    func: o,
    number: o,
    object: o,
    string: o,
    symbol: o,
    any: o,
    arrayOf: r,
    element: o,
    elementType: o,
    instanceOf: r,
    node: o,
    objectOf: r,
    oneOf: r,
    oneOfType: r,
    shape: r,
    exact: r,
    checkPropTypes: Qfe,
    resetWarningCache: Xfe
  };
  return i.PropTypes = i, i;
};
Yfe.exports = Xbe();
var Rn = Yfe.exports;
const ce = /* @__PURE__ */ H3(Rn);
var Jfe = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(o) {
  (function() {
    var r = {}.hasOwnProperty;
    function i() {
      for (var y = "", k = 0; k < arguments.length; k++) {
        var _ = arguments[k];
        _ && (y = h(y, u(_)));
      }
      return y;
    }
    function u(y) {
      if (typeof y == "string" || typeof y == "number")
        return y;
      if (typeof y != "object")
        return "";
      if (Array.isArray(y))
        return i.apply(null, y);
      if (y.toString !== Object.prototype.toString && !y.toString.toString().includes("[native code]"))
        return y.toString();
      var k = "";
      for (var _ in y)
        r.call(y, _) && y[_] && (k = h(k, _));
      return k;
    }
    function h(y, k) {
      return k ? y ? y + " " + k : y + k : y;
    }
    o.exports ? (i.default = i, o.exports = i) : window.classNames = i;
  })();
})(Jfe);
var Qbe = Jfe.exports;
const ns = /* @__PURE__ */ H3(Qbe);
function qr() {
  return qr = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i) ({}).hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, qr.apply(null, arguments);
}
function _i(o, r) {
  if (o == null) return {};
  var i = {};
  for (var u in o) if ({}.hasOwnProperty.call(o, u)) {
    if (r.indexOf(u) >= 0) continue;
    i[u] = o[u];
  }
  return i;
}
var Vre = /* @__PURE__ */ Ve.createContext({});
Vre.Consumer;
Vre.Provider;
function Nc(o, r) {
  var i = et.useContext(Vre);
  return o || i[r] || r;
}
function Jbe() {
  for (var o = arguments.length, r = new Array(o), i = 0; i < o; i++)
    r[i] = arguments[i];
  return r.filter(function(u) {
    return u != null;
  }).reduce(function(u, h) {
    if (typeof h != "function")
      throw new Error("Invalid Argument Type, must only provide functions, undefined, or null.");
    return u === null ? h : function() {
      for (var k = arguments.length, _ = new Array(k), D = 0; D < k; D++)
        _[D] = arguments[D];
      u.apply(this, _), h.apply(this, _);
    };
  }, null);
}
var eve = ["as", "disabled", "onKeyDown"];
function Gle(o) {
  return !o || o.trim() === "#";
}
var eme = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.as, u = i === void 0 ? "a" : i, h = o.disabled, y = o.onKeyDown, k = _i(o, eve), _ = function(W) {
    var se = k.href, J = k.onClick;
    if ((h || Gle(se)) && W.preventDefault(), h) {
      W.stopPropagation();
      return;
    }
    J && J(W);
  }, D = function(W) {
    W.key === " " && (W.preventDefault(), _(W));
  };
  return Gle(k.href) && (k.role = k.role || "button", k.href = k.href || "#"), h && (k.tabIndex = -1, k["aria-disabled"] = !0), /* @__PURE__ */ Ve.createElement(u, qr({
    ref: r
  }, k, {
    onClick: _,
    onKeyDown: Jbe(D, y)
  }));
});
eme.displayName = "SafeAnchor";
var tve = ["bsPrefix", "variant", "size", "active", "className", "block", "type", "as"], nve = {
  variant: "primary",
  active: !1,
  disabled: !1
}, jre = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.bsPrefix, u = o.variant, h = o.size, y = o.active, k = o.className, _ = o.block, D = o.type, L = o.as, W = _i(o, tve), se = Nc(i, "btn"), J = ns(k, se, y && "active", u && se + "-" + u, _ && se + "-block", h && se + "-" + h);
  if (W.href)
    return /* @__PURE__ */ Ve.createElement(eme, qr({}, W, {
      as: L,
      ref: r,
      className: ns(J, W.disabled && "disabled")
    }));
  r && (W.ref = r), D ? W.type = D : L || (W.type = "button");
  var be = L || "button";
  return /* @__PURE__ */ Ve.createElement(be, qr({}, W, {
    className: J
  }));
});
jre.displayName = "Button";
jre.defaultProps = nve;
var ove = ["bsPrefix", "size", "toggle", "vertical", "className", "as"], rve = {
  vertical: !1,
  toggle: !1,
  role: "group"
}, Ure = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.bsPrefix, u = o.size, h = o.toggle, y = o.vertical, k = o.className, _ = o.as, D = _ === void 0 ? "div" : _, L = _i(o, ove), W = Nc(i, "btn-group"), se = W;
  return y && (se = W + "-vertical"), /* @__PURE__ */ Ve.createElement(D, qr({}, L, {
    ref: r,
    className: ns(k, se, u && W + "-" + u, h && W + "-toggle")
  }));
});
Ure.displayName = "ButtonGroup";
Ure.defaultProps = rve;
var sve = ["bsPrefix", "className"], ave = {
  role: "toolbar"
}, Wre = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.bsPrefix, u = o.className, h = _i(o, sve), y = Nc(i, "btn-toolbar");
  return /* @__PURE__ */ Ve.createElement("div", qr({}, h, {
    ref: r,
    className: ns(u, y)
  }));
});
Wre.displayName = "ButtonToolbar";
Wre.defaultProps = ave;
var ive = ["children"];
function A3(o) {
  "@babel/helpers - typeof";
  return A3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, A3(o);
}
function lve(o, r) {
  if (o == null) return {};
  var i = cve(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function cve(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
function uve(o, r) {
  if (!(o instanceof r))
    throw new TypeError("Cannot call a class as a function");
}
function dve(o, r) {
  for (var i = 0; i < r.length; i++) {
    var u = r[i];
    u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(o, ome(u.key), u);
  }
}
function fve(o, r, i) {
  return r && dve(o.prototype, r), Object.defineProperty(o, "prototype", { writable: !1 }), o;
}
function mve(o, r) {
  if (typeof r != "function" && r !== null)
    throw new TypeError("Super expression must either be null or a function");
  o.prototype = Object.create(r && r.prototype, { constructor: { value: o, writable: !0, configurable: !0 } }), Object.defineProperty(o, "prototype", { writable: !1 }), r && $ne(o, r);
}
function $ne(o, r) {
  return $ne = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(u, h) {
    return u.__proto__ = h, u;
  }, $ne(o, r);
}
function pve(o) {
  var r = nme();
  return function() {
    var u = PV(o), h;
    if (r) {
      var y = PV(this).constructor;
      h = Reflect.construct(u, arguments, y);
    } else
      h = u.apply(this, arguments);
    return hve(this, h);
  };
}
function hve(o, r) {
  if (r && (A3(r) === "object" || typeof r == "function"))
    return r;
  if (r !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return tme(o);
}
function tme(o) {
  if (o === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return o;
}
function nme() {
  try {
    var o = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (nme = function() {
    return !!o;
  })();
}
function PV(o) {
  return PV = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(i) {
    return i.__proto__ || Object.getPrototypeOf(i);
  }, PV(o);
}
function gve(o, r, i) {
  return r = ome(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function ome(o) {
  var r = bve(o, "string");
  return A3(r) == "symbol" ? r : r + "";
}
function bve(o, r) {
  if (A3(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (A3(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
var xk = /* @__PURE__ */ function(o) {
  return o.MOVED = "MOVED", o.REMOVED = "REMOVED", o.FORMAT = "FORMAT", o.MOVED_AND_FORMAT = "MOVED_AND_FORMAT", o;
}({});
function rme(o, r, i) {
  var u = /* @__PURE__ */ function(h) {
    mve(k, h);
    var y = pve(k);
    function k(_) {
      var D;
      return uve(this, k), D = y.call(this, _), D.transformProps = D.transformProps.bind(tme(D)), D;
    }
    return fve(k, [{
      key: "warn",
      value: function(D) {
      }
    }, {
      key: "transformProps",
      value: function(D, L) {
        if (i[L] === void 0)
          return D[L] = this.props[L], D;
        var W = i[L], se = W.deprType, J = W.newName, be = W.expect, ke = W.transform, Ce = W.message;
        switch (se) {
          case xk.MOVED:
            this.warn("".concat(r, ": The prop '").concat(L, "' has been moved to '").concat(J, "'.")), D[J] = this.props[L];
            break;
          case xk.REMOVED:
            this.warn("".concat(r, ": The prop '").concat(L, "' has been removed. '").concat(Ce, "'"));
            break;
          case xk.FORMAT:
            be(this.props[L]) ? D[L] = this.props[L] : (this.warn("".concat(r, ": The prop '").concat(L, "' expects a new format. ").concat(Ce)), D[L] = ke(this.props[L], this.props));
            break;
          case xk.MOVED_AND_FORMAT:
            this.warn("".concat(r, ": The prop '").concat(L, "' has been moved to '").concat(J, "' and expects a new format. ").concat(Ce)), D[J] = ke(this.props[L], this.props);
            break;
          default:
            D[L] = this.props[L];
            break;
        }
        return D;
      }
    }, {
      key: "render",
      value: function() {
        var D = Object.keys(this.props).reduce(this.transformProps, {}), L = D.children, W = lve(D, ive);
        return /* @__PURE__ */ Ve.createElement(o, W, this.props.children || L);
      }
    }]), k;
  }(Ve.Component);
  return gve(u, "displayName", "withDeprecatedProps(".concat(r, ")")), u;
}
function P3(o) {
  "@babel/helpers - typeof";
  return P3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, P3(o);
}
var vve = ["buttonType", "className", "children", "isClose", "type", "inputRef"];
function Lne() {
  return Lne = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, Lne.apply(this, arguments);
}
function yve(o, r, i) {
  return r = sme(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function xve(o, r) {
  if (o == null) return {};
  var i = wve(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function wve(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
function Cve(o, r) {
  if (!(o instanceof r))
    throw new TypeError("Cannot call a class as a function");
}
function Sve(o, r) {
  for (var i = 0; i < r.length; i++) {
    var u = r[i];
    u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(o, sme(u.key), u);
  }
}
function kve(o, r, i) {
  return r && Sve(o.prototype, r), Object.defineProperty(o, "prototype", { writable: !1 }), o;
}
function sme(o) {
  var r = _ve(o, "string");
  return P3(r) == "symbol" ? r : r + "";
}
function _ve(o, r) {
  if (P3(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (P3(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
function Eve(o, r) {
  if (typeof r != "function" && r !== null)
    throw new TypeError("Super expression must either be null or a function");
  o.prototype = Object.create(r && r.prototype, { constructor: { value: o, writable: !0, configurable: !0 } }), Object.defineProperty(o, "prototype", { writable: !1 }), r && Hne(o, r);
}
function Hne(o, r) {
  return Hne = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(u, h) {
    return u.__proto__ = h, u;
  }, Hne(o, r);
}
function Tve(o) {
  var r = ame();
  return function() {
    var u = DV(o), h;
    if (r) {
      var y = DV(this).constructor;
      h = Reflect.construct(u, arguments, y);
    } else
      h = u.apply(this, arguments);
    return Ove(this, h);
  };
}
function Ove(o, r) {
  if (r && (P3(r) === "object" || typeof r == "function"))
    return r;
  if (r !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return NI(o);
}
function NI(o) {
  if (o === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return o;
}
function ame() {
  try {
    var o = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (ame = function() {
    return !!o;
  })();
}
function DV(o) {
  return DV = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(i) {
    return i.__proto__ || Object.getPrototypeOf(i);
  }, DV(o);
}
var Zre = /* @__PURE__ */ function(o) {
  Eve(i, o);
  var r = Tve(i);
  function i(u) {
    var h;
    Cve(this, i), h = r.call(this, u);
    var y = u.onBlur, k = u.onKeyDown;
    return h.onBlur = y.bind(NI(h)), h.onKeyDown = k.bind(NI(h)), h.onClick = h.onClick.bind(NI(h)), h.setRefs = h.setRefs.bind(NI(h)), h;
  }
  return kve(i, [{
    key: "onClick",
    value: function(h) {
      this.buttonRef.focus(), this.props.onClick(h);
    }
    /*
      The button component needs a ref to itself to be able to force
      focus in its onClick function (buttonRef). It also needs to accept
      a callback function from parent components to give those parents
      a reference to their child button (e.g. for the modal component).
      Therefore, both have been wrapped in a function bound on the class,
      since one cannot set two ref attributes on a component.
    */
  }, {
    key: "setRefs",
    value: function(h) {
      this.buttonRef = h, this.props.inputRef(h);
    }
  }, {
    key: "render",
    value: function() {
      var h = this.props, y = h.buttonType, k = h.className, _ = h.children, D = h.isClose, L = h.type;
      h.inputRef;
      var W = xve(h, vve);
      return /* @__PURE__ */ Ve.createElement("button", Lne({}, W, {
        className: ns(["btn", k], yve({}, "btn-".concat(y), y !== void 0), {
          close: D
        }),
        onBlur: this.onBlur,
        onClick: this.onClick,
        onKeyDown: this.onKeyDown,
        type: L,
        ref: this.setRefs
      }), _);
    }
  }]), i;
}(Ve.Component), Ave = {
  /** Used to determine the type of button to be rendered.  See [Bootstrap's buttons documentation](https://getbootstrap.com/docs/4.0/components/buttons/) for a list of applicable button types. For example, `buttonType="light"`. The default is `undefined`. */
  buttonType: ce.string,
  /** Specifies Bootstrap class names to apply to the button. See [Bootstrap's buttons documentation](https://getbootstrap.com/docs/4.0/components/buttons/) for a list of applicable class names. The default is an empty array. */
  className: ce.string,
  /** Specifies the text that is displayed within the button. */
  children: ce.node.isRequired,
  // eslint-disable-next-line max-len
  /** A function that defines a reference for the button. An example `inputRef` from the calling component could look something like: `inputRef={(input) => { this.button = input; }}`. The default is an empty function. */
  inputRef: ce.oneOfType([ce.func, ce.shape({
    current: ce.instanceOf(ce.element)
  })]),
  /** Used to determine if the button is a "Close" style button to leverage bootstrap styling. Example use case is with the Status Alert [dismiss button](https://getbootstrap.com/docs/4.0/components/alerts/#dismissing). The default is false. */
  isClose: ce.bool,
  // eslint-disable-next-line max-len
  /** A function that would specify what the button should do when the `onBlur` event is triggered. For example, the button could change in color or `buttonType` when focus is changed. The default is an empty function. */
  onBlur: ce.func,
  // eslint-disable-next-line max-len
  /** A function that would specify what the button should do when the `onClick` event is triggered. For example, the button could launch a `Modal`. The default is an empty function. */
  onClick: ce.func,
  // eslint-disable-next-line max-len
  /** A function that would specify what the button should do when the `onKeyDown` event is triggered.  For example, this could handle using the `Escape` key to trigger the button's action. The default is an empty function. */
  onKeyDown: ce.func,
  /** Used to set the `type` attribute on the `button` tag.  The default type is `button`. */
  type: ce.string,
  /** Specifies variant to use. */
  variant: ce.oneOf(["primary", "secondary", "success", "danger", "warning", "info", "dark", "light", "link", "outline-primary", "outline-secondary", "outline-success", "outline-danger", "outline-warning", "outline-info", "outline-dark", "outline-light"])
};
Zre.propTypes = Ave;
Zre.defaultProps = {
  buttonType: void 0,
  className: void 0,
  inputRef: function() {
  },
  isClose: !1,
  onBlur: function() {
  },
  onKeyDown: function() {
  },
  onClick: function() {
  },
  type: "button",
  variant: "outline-primary"
};
const Pve = rme(Zre, "Button", {
  label: {
    deprType: xk.MOVED,
    newName: "children"
  },
  className: {
    deprType: xk.FORMAT,
    expect: function(r) {
      return typeof r == "string";
    },
    transform: function(r) {
      return Array.isArray(r) ? r.join(" ") : r;
    },
    message: "It should be a string."
  }
});
let qle = 0;
const Gre = (o = "id") => (qle += 1, `${o}${qle}`);
function m5(o) {
  "@babel/helpers - typeof";
  return m5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, m5(o);
}
var Dve = ["src", "id", "className", "hidden", "screenReaderText", "svgAttrs", "size"];
function RV() {
  return RV = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, RV.apply(this, arguments);
}
function Kle(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function Rve(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? Kle(Object(i), !0).forEach(function(u) {
      ime(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : Kle(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function ime(o, r, i) {
  return r = Nve(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function Nve(o) {
  var r = Mve(o, "string");
  return m5(r) == "symbol" ? r : r + "";
}
function Mve(o, r) {
  if (m5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (m5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
function Ive(o, r) {
  if (o == null) return {};
  var i = Fve(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function Fve(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
function qre(o) {
  var r = o.src, i = o.id, u = o.className, h = o.hidden, y = o.screenReaderText, k = o.svgAttrs, _ = o.size, D = Ive(o, Dve);
  if (r) {
    var L = k["aria-label"] || k["aria-labelledby"], W = Rve({}, k);
    return L || (W["aria-label"] = void 0, W["aria-hidden"] = !0), /* @__PURE__ */ Ve.createElement("span", RV({
      className: ns("pgn__icon", ime({}, "pgn__icon__".concat(_), !!_), u),
      id: i
    }, D), /* @__PURE__ */ Ve.createElement(r, RV({
      role: "img",
      focusable: !1
    }, W)), y && /* @__PURE__ */ Ve.createElement("span", {
      className: "sr-only"
    }, y));
  }
  return /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, /* @__PURE__ */ Ve.createElement("span", {
    id: i || Gre("Icon"),
    className: u,
    "aria-hidden": h
  }), y && /* @__PURE__ */ Ve.createElement("span", {
    className: "sr-only"
  }, y));
}
qre.propTypes = {
  /**
   * An icon component to render.
   * Example import of a Paragon icon component: `import { Check } from '@openedx/paragon/icons';`
   */
  src: ce.elementType,
  /** HTML element attributes to pass through to the underlying svg element */
  svgAttrs: ce.shape({
    "aria-label": ce.string,
    "aria-labelledby": ce.string
  }),
  /**
   * the `id` property of the Icon element, by default this value is generated
   * with the `newId` function with the `prefix` of `Icon`.
   */
  id: ce.string,
  /** The size of the icon. */
  size: ce.oneOf(["xs", "sm", "md", "lg"]),
  /** A class name that will define what the Icon looks like. */
  className: ce.string,
  /**
   * a boolean that determines the value of `aria-hidden` attribute on the Icon span,
   * this value is `true` by default.
   */
  hidden: ce.bool,
  /**
   * a string or an element that will be used on a secondary span leveraging the `sr-only` style
   * for screenreader only text, this value is `undefined` by default. This value is recommended for use unless
   * the Icon is being used in a way that is purely decorative or provides no additional context for screen
   * reader users. This field should be thought of the same way an `alt` attribute would be used for `image` tags.
   */
  screenReaderText: ce.oneOfType([ce.string, ce.element])
};
qre.defaultProps = {
  src: null,
  svgAttrs: {},
  id: void 0,
  hidden: !0,
  screenReaderText: void 0,
  size: void 0,
  className: void 0
};
const D3 = rme(qre, "Icon", {
  className: {
    deprType: xk.FORMAT,
    expect: function(r) {
      return typeof r == "string";
    },
    transform: function(r) {
      return Array.isArray(r) ? r.join(" ") : r;
    },
    message: "It should be a string."
  }
});
function p5(o) {
  "@babel/helpers - typeof";
  return p5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, p5(o);
}
var Bve = ["children", "iconAfter", "iconBefore", "size"], $ve = ["size"];
function Yle(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function Xle(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? Yle(Object(i), !0).forEach(function(u) {
      Lve(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : Yle(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function Lve(o, r, i) {
  return r = Hve(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function Hve(o) {
  var r = zve(o, "string");
  return p5(r) == "symbol" ? r : r + "";
}
function zve(o, r) {
  if (p5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (p5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
function h5() {
  return h5 = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, h5.apply(this, arguments);
}
function lme(o, r) {
  if (o == null) return {};
  var i = Vve(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function Vve(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
var Dk = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.children, u = o.iconAfter, h = o.iconBefore, y = o.size, k = lme(o, Bve);
  return /* @__PURE__ */ Ve.createElement(jre, h5({
    size: y
    // Bootstrap's <Button> types do not allow 'md' or 'inline', but we do.
  }, k, {
    className: ns(k.className),
    ref: r
  }), h && /* @__PURE__ */ Ve.createElement(D3, {
    className: "btn-icon-before",
    size: y,
    src: h
  }), i, u && /* @__PURE__ */ Ve.createElement(D3, {
    className: "btn-icon-after",
    size: y,
    src: u
  }));
});
Dk.propTypes = {
  /** Specifies class name to apply to the button */
  className: ce.string,
  /** Disables the Button, preventing mouse events, even if the underlying component is an `<a>` element */
  disabled: ce.bool,
  /** Specifies the text that is displayed within the button. */
  children: ce.node.isRequired,
  /** A function that would specify what the button should do when the `onClick` event is triggered.
   * For example, the button could launch a `Modal`. The default is an empty function. */
  onClick: ce.func,
  /** A function that would specify what the button should do when the `onKeyDown` event is triggered.
   * For example, this could handle using the `Escape` key to trigger the button's action.
   * The default is an empty function. */
  onKeyDown: ce.func,
  /** Used to set the `type` attribute on the `button` tag.  The default type is `button`. */
  type: ce.string,
  /** Specifies variant to use.
   * Can be on of the base variants: `primary`, `secondary`, `success`, `danger`, `warning`, `info`, `dark`,
   * `light`, `link`
   *
   * as well as one of the customized variants (= base variant prefixed with `inverse-`, `outline-`
   * or `inverse-outline-`)
   * */
  variant: ce.string,
  /** An icon component to render.
  * Example import of a Paragon icon component: `import { Check } from '@openedx/paragon/icons';` */
  iconBefore: ce.elementType,
  /** An icon component to render.
  * Example import of a Paragon icon component: `import { Check } from '@openedx/paragon/icons';` */
  iconAfter: ce.elementType
  // The 'as' type casting above is required for TypeScript checking, because the 'PropTypes.elementType' type normally
  // allows strings as a value (for use cases like 'div') but we don't support that for <Icon />/iconBefore/iconAfter.
  // The React TypeScript type definitions are more specific (React.ComponentType vs React.ElementType).
};
Dk.defaultProps = Xle(Xle({}, Dk.defaultProps), {}, {
  children: void 0,
  className: void 0,
  iconBefore: void 0,
  iconAfter: void 0,
  disabled: !1
});
Dk.Deprecated = Pve;
var cme = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.size, u = lme(o, $ve);
  return /* @__PURE__ */ Ve.createElement(Ure, h5({
    size: i
  }, u, {
    ref: r
  }));
});
cme.propTypes = {
  /** Specifies element type for this component. */
  as: ce.elementType,
  /** An ARIA role describing the button group. */
  role: ce.string,
  /** Specifies the size for all Buttons in the group. */
  size: ce.oneOf(["sm", "md", "lg", "inline"]),
  /** Display as a button toggle group. */
  toggle: ce.bool,
  /** Specifies if the set of Buttons should appear vertically stacked. */
  vertical: ce.bool,
  /** Overrides underlying component base CSS class name */
  bsPrefix: ce.string
};
cme.defaultProps = {
  as: "div",
  role: "group",
  toggle: !1,
  vertical: !1,
  bsPrefix: "btn-group",
  size: "md"
};
var ume = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  return /* @__PURE__ */ Ve.createElement(Wre, h5({}, o, {
    ref: r
  }));
});
ume.propTypes = {
  /** An ARIA role describing the button group. */
  role: ce.string,
  /** Overrides underlying component base CSS class name */
  bsPrefix: ce.string
};
ume.defaultProps = {
  role: "toolbar",
  bsPrefix: "btn-toolbar"
};
const jve = (o, r, i) => (u, h, y, ...k) => r(u) && u[h] === void 0 ? new Error(
  `${y}: ${h} is required when ${i}`
) : o(u, h, y, ...k), Uve = (o, r) => r.every((i) => o[i] !== void 0), Ote = (o, r) => jve(
  o,
  (i) => Array.isArray(r) ? Uve(i, r) : i[r] === !0,
  `${r} ${Array.isArray(r) ? "are defined" : "is truthy"}`
);
function Qle(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function qo(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? Qle(Object(i), !0).forEach(function(u) {
      su(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : Qle(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function NV(o) {
  "@babel/helpers - typeof";
  return NV = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, NV(o);
}
function Wve(o, r) {
  if (!(o instanceof r))
    throw new TypeError("Cannot call a class as a function");
}
function Zve(o, r) {
  for (var i = 0; i < r.length; i++) {
    var u = r[i];
    u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(o, u.key, u);
  }
}
function Gve(o, r, i) {
  return r && Zve(o.prototype, r), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function su(o, r, i) {
  return r in o ? Object.defineProperty(o, r, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : o[r] = i, o;
}
function Kre(o, r) {
  return Kve(o) || Xve(o, r) || dme(o, r) || Jve();
}
function eF(o) {
  return qve(o) || Yve(o) || dme(o) || Qve();
}
function qve(o) {
  if (Array.isArray(o)) return zne(o);
}
function Kve(o) {
  if (Array.isArray(o)) return o;
}
function Yve(o) {
  if (typeof Symbol < "u" && o[Symbol.iterator] != null || o["@@iterator"] != null) return Array.from(o);
}
function Xve(o, r) {
  var i = o == null ? null : typeof Symbol < "u" && o[Symbol.iterator] || o["@@iterator"];
  if (i != null) {
    var u = [], h = !0, y = !1, k, _;
    try {
      for (i = i.call(o); !(h = (k = i.next()).done) && (u.push(k.value), !(r && u.length === r)); h = !0)
        ;
    } catch (D) {
      y = !0, _ = D;
    } finally {
      try {
        !h && i.return != null && i.return();
      } finally {
        if (y) throw _;
      }
    }
    return u;
  }
}
function dme(o, r) {
  if (o) {
    if (typeof o == "string") return zne(o, r);
    var i = Object.prototype.toString.call(o).slice(8, -1);
    if (i === "Object" && o.constructor && (i = o.constructor.name), i === "Map" || i === "Set") return Array.from(o);
    if (i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return zne(o, r);
  }
}
function zne(o, r) {
  (r == null || r > o.length) && (r = o.length);
  for (var i = 0, u = new Array(r); i < r; i++) u[i] = o[i];
  return u;
}
function Qve() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Jve() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var Jle = function() {
}, Yre = {}, fme = {}, mme = null, pme = {
  mark: Jle,
  measure: Jle
};
try {
  typeof window < "u" && (Yre = window), typeof document < "u" && (fme = document), typeof MutationObserver < "u" && (mme = MutationObserver), typeof performance < "u" && (pme = performance);
} catch {
}
var e1e = Yre.navigator || {}, ece = e1e.userAgent, tce = ece === void 0 ? "" : ece, _w = Yre, ll = fme, nce = mme, k9 = pme;
_w.document;
var O0 = !!ll.documentElement && !!ll.head && typeof ll.addEventListener == "function" && typeof ll.createElement == "function", hme = ~tce.indexOf("MSIE") || ~tce.indexOf("Trident/"), _9, E9, T9, O9, A9, C0 = "___FONT_AWESOME___", Vne = 16, gme = "fa", bme = "svg-inline--fa", Rk = "data-fa-i2svg", jne = "data-fa-pseudo-element", t1e = "data-fa-pseudo-element-pending", Xre = "data-prefix", Qre = "data-icon", oce = "fontawesome-i2svg", n1e = "async", o1e = ["HTML", "HEAD", "STYLE", "SCRIPT"], vme = function() {
  try {
    return !0;
  } catch {
    return !1;
  }
}(), al = "classic", Gl = "sharp", Jre = [al, Gl];
function tF(o) {
  return new Proxy(o, {
    get: function(i, u) {
      return u in i ? i[u] : i[al];
    }
  });
}
var g5 = tF((_9 = {}, su(_9, al, {
  fa: "solid",
  fas: "solid",
  "fa-solid": "solid",
  far: "regular",
  "fa-regular": "regular",
  fal: "light",
  "fa-light": "light",
  fat: "thin",
  "fa-thin": "thin",
  fad: "duotone",
  "fa-duotone": "duotone",
  fab: "brands",
  "fa-brands": "brands",
  fak: "kit",
  fakd: "kit",
  "fa-kit": "kit",
  "fa-kit-duotone": "kit"
}), su(_9, Gl, {
  fa: "solid",
  fass: "solid",
  "fa-solid": "solid",
  fasr: "regular",
  "fa-regular": "regular",
  fasl: "light",
  "fa-light": "light",
  fast: "thin",
  "fa-thin": "thin"
}), _9)), b5 = tF((E9 = {}, su(E9, al, {
  solid: "fas",
  regular: "far",
  light: "fal",
  thin: "fat",
  duotone: "fad",
  brands: "fab",
  kit: "fak"
}), su(E9, Gl, {
  solid: "fass",
  regular: "fasr",
  light: "fasl",
  thin: "fast"
}), E9)), v5 = tF((T9 = {}, su(T9, al, {
  fab: "fa-brands",
  fad: "fa-duotone",
  fak: "fa-kit",
  fal: "fa-light",
  far: "fa-regular",
  fas: "fa-solid",
  fat: "fa-thin"
}), su(T9, Gl, {
  fass: "fa-solid",
  fasr: "fa-regular",
  fasl: "fa-light",
  fast: "fa-thin"
}), T9)), r1e = tF((O9 = {}, su(O9, al, {
  "fa-brands": "fab",
  "fa-duotone": "fad",
  "fa-kit": "fak",
  "fa-light": "fal",
  "fa-regular": "far",
  "fa-solid": "fas",
  "fa-thin": "fat"
}), su(O9, Gl, {
  "fa-solid": "fass",
  "fa-regular": "fasr",
  "fa-light": "fasl",
  "fa-thin": "fast"
}), O9)), s1e = /fa(s|r|l|t|d|b|k|ss|sr|sl|st)?[\-\ ]/, yme = "fa-layers-text", a1e = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp|Kit)?.*/i, i1e = tF((A9 = {}, su(A9, al, {
  900: "fas",
  400: "far",
  normal: "far",
  300: "fal",
  100: "fat"
}), su(A9, Gl, {
  900: "fass",
  400: "fasr",
  300: "fasl",
  100: "fast"
}), A9)), xme = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], l1e = xme.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), c1e = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], wk = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, y5 = /* @__PURE__ */ new Set();
Object.keys(b5[al]).map(y5.add.bind(y5));
Object.keys(b5[Gl]).map(y5.add.bind(y5));
var u1e = [].concat(Jre, eF(y5), ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", wk.GROUP, wk.SWAP_OPACITY, wk.PRIMARY, wk.SECONDARY]).concat(xme.map(function(o) {
  return "".concat(o, "x");
})).concat(l1e.map(function(o) {
  return "w-".concat(o);
})), qI = _w.FontAwesomeConfig || {};
function d1e(o) {
  var r = ll.querySelector("script[" + o + "]");
  if (r)
    return r.getAttribute(o);
}
function f1e(o) {
  return o === "" ? !0 : o === "false" ? !1 : o === "true" ? !0 : o;
}
if (ll && typeof ll.querySelector == "function") {
  var m1e = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
  m1e.forEach(function(o) {
    var r = Kre(o, 2), i = r[0], u = r[1], h = f1e(d1e(i));
    h != null && (qI[u] = h);
  });
}
var wme = {
  styleDefault: "solid",
  familyDefault: "classic",
  cssPrefix: gme,
  replacementClass: bme,
  autoReplaceSvg: !0,
  autoAddCss: !0,
  autoA11y: !0,
  searchPseudoElements: !1,
  observeMutations: !0,
  mutateApproach: "async",
  keepOriginalSource: !0,
  measurePerformance: !1,
  showMissingIcons: !0
};
qI.familyPrefix && (qI.cssPrefix = qI.familyPrefix);
var R3 = qo(qo({}, wme), qI);
R3.autoReplaceSvg || (R3.observeMutations = !1);
var vr = {};
Object.keys(wme).forEach(function(o) {
  Object.defineProperty(vr, o, {
    enumerable: !0,
    set: function(i) {
      R3[o] = i, KI.forEach(function(u) {
        return u(vr);
      });
    },
    get: function() {
      return R3[o];
    }
  });
});
Object.defineProperty(vr, "familyPrefix", {
  enumerable: !0,
  set: function(r) {
    R3.cssPrefix = r, KI.forEach(function(i) {
      return i(vr);
    });
  },
  get: function() {
    return R3.cssPrefix;
  }
});
_w.FontAwesomeConfig = vr;
var KI = [];
function p1e(o) {
  return KI.push(o), function() {
    KI.splice(KI.indexOf(o), 1);
  };
}
var nw = Vne, hv = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: !1,
  flipY: !1
};
function h1e(o) {
  if (!(!o || !O0)) {
    var r = ll.createElement("style");
    r.setAttribute("type", "text/css"), r.innerHTML = o;
    for (var i = ll.head.childNodes, u = null, h = i.length - 1; h > -1; h--) {
      var y = i[h], k = (y.tagName || "").toUpperCase();
      ["STYLE", "LINK"].indexOf(k) > -1 && (u = y);
    }
    return ll.head.insertBefore(r, u), o;
  }
}
var g1e = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function x5() {
  for (var o = 12, r = ""; o-- > 0; )
    r += g1e[Math.random() * 62 | 0];
  return r;
}
function q3(o) {
  for (var r = [], i = (o || []).length >>> 0; i--; )
    r[i] = o[i];
  return r;
}
function ese(o) {
  return o.classList ? q3(o.classList) : (o.getAttribute("class") || "").split(" ").filter(function(r) {
    return r;
  });
}
function Cme(o) {
  return "".concat(o).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function b1e(o) {
  return Object.keys(o || {}).reduce(function(r, i) {
    return r + "".concat(i, '="').concat(Cme(o[i]), '" ');
  }, "").trim();
}
function dj(o) {
  return Object.keys(o || {}).reduce(function(r, i) {
    return r + "".concat(i, ": ").concat(o[i].trim(), ";");
  }, "");
}
function tse(o) {
  return o.size !== hv.size || o.x !== hv.x || o.y !== hv.y || o.rotate !== hv.rotate || o.flipX || o.flipY;
}
function v1e(o) {
  var r = o.transform, i = o.containerWidth, u = o.iconWidth, h = {
    transform: "translate(".concat(i / 2, " 256)")
  }, y = "translate(".concat(r.x * 32, ", ").concat(r.y * 32, ") "), k = "scale(".concat(r.size / 16 * (r.flipX ? -1 : 1), ", ").concat(r.size / 16 * (r.flipY ? -1 : 1), ") "), _ = "rotate(".concat(r.rotate, " 0 0)"), D = {
    transform: "".concat(y, " ").concat(k, " ").concat(_)
  }, L = {
    transform: "translate(".concat(u / 2 * -1, " -256)")
  };
  return {
    outer: h,
    inner: D,
    path: L
  };
}
function y1e(o) {
  var r = o.transform, i = o.width, u = i === void 0 ? Vne : i, h = o.height, y = h === void 0 ? Vne : h, k = o.startCentered, _ = k === void 0 ? !1 : k, D = "";
  return _ && hme ? D += "translate(".concat(r.x / nw - u / 2, "em, ").concat(r.y / nw - y / 2, "em) ") : _ ? D += "translate(calc(-50% + ".concat(r.x / nw, "em), calc(-50% + ").concat(r.y / nw, "em)) ") : D += "translate(".concat(r.x / nw, "em, ").concat(r.y / nw, "em) "), D += "scale(".concat(r.size / nw * (r.flipX ? -1 : 1), ", ").concat(r.size / nw * (r.flipY ? -1 : 1), ") "), D += "rotate(".concat(r.rotate, "deg) "), D;
}
var x1e = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Solid";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Regular";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Light";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Thin";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  -webkit-transform: scale(var(--fa-counter-scale, 0.25));
          transform: scale(var(--fa-counter-scale, 0.25));
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: bottom right;
          transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: bottom left;
          transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: top left;
          transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(var(--fa-li-width, 2em) * -1);
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  -webkit-animation-name: fa-beat;
          animation-name: fa-beat;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);
          animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  -webkit-animation-name: fa-bounce;
          animation-name: fa-bounce;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  -webkit-animation-name: fa-fade;
          animation-name: fa-fade;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  -webkit-animation-name: fa-beat-fade;
          animation-name: fa-beat-fade;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  -webkit-animation-name: fa-flip;
          animation-name: fa-flip;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);
          animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  -webkit-animation-name: fa-shake;
          animation-name: fa-shake;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, linear);
          animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  -webkit-animation-name: fa-spin;
          animation-name: fa-spin;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 2s);
          animation-duration: var(--fa-animation-duration, 2s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, linear);
          animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  -webkit-animation-name: fa-spin;
          animation-name: fa-spin;
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, steps(8));
          animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    -webkit-animation-delay: -1ms;
            animation-delay: -1ms;
    -webkit-animation-duration: 1ms;
            animation-duration: 1ms;
    -webkit-animation-iteration-count: 1;
            animation-iteration-count: 1;
    -webkit-transition-delay: 0s;
            transition-delay: 0s;
    -webkit-transition-duration: 0s;
            transition-duration: 0s;
  }
}
@-webkit-keyframes fa-beat {
  0%, 90% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  45% {
    -webkit-transform: scale(var(--fa-beat-scale, 1.25));
            transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-beat {
  0%, 90% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  45% {
    -webkit-transform: scale(var(--fa-beat-scale, 1.25));
            transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@-webkit-keyframes fa-bounce {
  0% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  10% {
    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  100% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-bounce {
  0% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  10% {
    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  100% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
}
@-webkit-keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@-webkit-keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  50% {
    opacity: 1;
    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
            transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  50% {
    opacity: 1;
    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
            transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@-webkit-keyframes fa-flip {
  50% {
    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-flip {
  50% {
    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@-webkit-keyframes fa-shake {
  0% {
    -webkit-transform: rotate(-15deg);
            transform: rotate(-15deg);
  }
  4% {
    -webkit-transform: rotate(15deg);
            transform: rotate(15deg);
  }
  8%, 24% {
    -webkit-transform: rotate(-18deg);
            transform: rotate(-18deg);
  }
  12%, 28% {
    -webkit-transform: rotate(18deg);
            transform: rotate(18deg);
  }
  16% {
    -webkit-transform: rotate(-22deg);
            transform: rotate(-22deg);
  }
  20% {
    -webkit-transform: rotate(22deg);
            transform: rotate(22deg);
  }
  32% {
    -webkit-transform: rotate(-12deg);
            transform: rotate(-12deg);
  }
  36% {
    -webkit-transform: rotate(12deg);
            transform: rotate(12deg);
  }
  40%, 100% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
}
@keyframes fa-shake {
  0% {
    -webkit-transform: rotate(-15deg);
            transform: rotate(-15deg);
  }
  4% {
    -webkit-transform: rotate(15deg);
            transform: rotate(15deg);
  }
  8%, 24% {
    -webkit-transform: rotate(-18deg);
            transform: rotate(-18deg);
  }
  12%, 28% {
    -webkit-transform: rotate(18deg);
            transform: rotate(18deg);
  }
  16% {
    -webkit-transform: rotate(-22deg);
            transform: rotate(-22deg);
  }
  20% {
    -webkit-transform: rotate(22deg);
            transform: rotate(22deg);
  }
  32% {
    -webkit-transform: rotate(-12deg);
            transform: rotate(-12deg);
  }
  36% {
    -webkit-transform: rotate(12deg);
            transform: rotate(12deg);
  }
  40%, 100% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
}
@-webkit-keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
@keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  -webkit-transform: rotate(90deg);
          transform: rotate(90deg);
}

.fa-rotate-180 {
  -webkit-transform: rotate(180deg);
          transform: rotate(180deg);
}

.fa-rotate-270 {
  -webkit-transform: rotate(270deg);
          transform: rotate(270deg);
}

.fa-flip-horizontal {
  -webkit-transform: scale(-1, 1);
          transform: scale(-1, 1);
}

.fa-flip-vertical {
  -webkit-transform: scale(1, -1);
          transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  -webkit-transform: scale(-1, -1);
          transform: scale(-1, -1);
}

.fa-rotate-by {
  -webkit-transform: rotate(var(--fa-rotate-angle, 0));
          transform: rotate(var(--fa-rotate-angle, 0));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.fad.fa-inverse,
.fa-duotone.fa-inverse {
  color: var(--fa-inverse, #fff);
}`;
function Sme() {
  var o = gme, r = bme, i = vr.cssPrefix, u = vr.replacementClass, h = x1e;
  if (i !== o || u !== r) {
    var y = new RegExp("\\.".concat(o, "\\-"), "g"), k = new RegExp("\\--".concat(o, "\\-"), "g"), _ = new RegExp("\\.".concat(r), "g");
    h = h.replace(y, ".".concat(i, "-")).replace(k, "--".concat(i, "-")).replace(_, ".".concat(u));
  }
  return h;
}
var rce = !1;
function Ate() {
  vr.autoAddCss && !rce && (h1e(Sme()), rce = !0);
}
var w1e = {
  mixout: function() {
    return {
      dom: {
        css: Sme,
        insertCss: Ate
      }
    };
  },
  hooks: function() {
    return {
      beforeDOMElementCreation: function() {
        Ate();
      },
      beforeI2svg: function() {
        Ate();
      }
    };
  }
}, S0 = _w || {};
S0[C0] || (S0[C0] = {});
S0[C0].styles || (S0[C0].styles = {});
S0[C0].hooks || (S0[C0].hooks = {});
S0[C0].shims || (S0[C0].shims = []);
var jg = S0[C0], kme = [], C1e = function o() {
  ll.removeEventListener("DOMContentLoaded", o), MV = 1, kme.map(function(r) {
    return r();
  });
}, MV = !1;
O0 && (MV = (ll.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(ll.readyState), MV || ll.addEventListener("DOMContentLoaded", C1e));
function S1e(o) {
  O0 && (MV ? setTimeout(o, 0) : kme.push(o));
}
function nF(o) {
  var r = o.tag, i = o.attributes, u = i === void 0 ? {} : i, h = o.children, y = h === void 0 ? [] : h;
  return typeof o == "string" ? Cme(o) : "<".concat(r, " ").concat(b1e(u), ">").concat(y.map(nF).join(""), "</").concat(r, ">");
}
function sce(o, r, i) {
  if (o && o[r] && o[r][i])
    return {
      prefix: r,
      iconName: i,
      icon: o[r][i]
    };
}
var Pte = function(r, i, u, h) {
  var y = Object.keys(r), k = y.length, _ = i, D, L, W;
  for (u === void 0 ? (D = 1, W = r[y[0]]) : (D = 0, W = u); D < k; D++)
    L = y[D], W = _(W, r[L], L, r);
  return W;
};
function k1e(o) {
  for (var r = [], i = 0, u = o.length; i < u; ) {
    var h = o.charCodeAt(i++);
    if (h >= 55296 && h <= 56319 && i < u) {
      var y = o.charCodeAt(i++);
      (y & 64512) == 56320 ? r.push(((h & 1023) << 10) + (y & 1023) + 65536) : (r.push(h), i--);
    } else
      r.push(h);
  }
  return r;
}
function Une(o) {
  var r = k1e(o);
  return r.length === 1 ? r[0].toString(16) : null;
}
function _1e(o, r) {
  var i = o.length, u = o.charCodeAt(r), h;
  return u >= 55296 && u <= 56319 && i > r + 1 && (h = o.charCodeAt(r + 1), h >= 56320 && h <= 57343) ? (u - 55296) * 1024 + h - 56320 + 65536 : u;
}
function ace(o) {
  return Object.keys(o).reduce(function(r, i) {
    var u = o[i], h = !!u.icon;
    return h ? r[u.iconName] = u.icon : r[i] = u, r;
  }, {});
}
function Wne(o, r) {
  var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, u = i.skipHooks, h = u === void 0 ? !1 : u, y = ace(r);
  typeof jg.hooks.addPack == "function" && !h ? jg.hooks.addPack(o, ace(r)) : jg.styles[o] = qo(qo({}, jg.styles[o] || {}), y), o === "fas" && Wne("fa", r);
}
var P9, D9, R9, r3 = jg.styles, E1e = jg.shims, T1e = (P9 = {}, su(P9, al, Object.values(v5[al])), su(P9, Gl, Object.values(v5[Gl])), P9), nse = null, _me = {}, Eme = {}, Tme = {}, Ome = {}, Ame = {}, O1e = (D9 = {}, su(D9, al, Object.keys(g5[al])), su(D9, Gl, Object.keys(g5[Gl])), D9);
function A1e(o) {
  return ~u1e.indexOf(o);
}
function P1e(o, r) {
  var i = r.split("-"), u = i[0], h = i.slice(1).join("-");
  return u === o && h !== "" && !A1e(h) ? h : null;
}
var Pme = function() {
  var r = function(y) {
    return Pte(r3, function(k, _, D) {
      return k[D] = Pte(_, y, {}), k;
    }, {});
  };
  _me = r(function(h, y, k) {
    if (y[3] && (h[y[3]] = k), y[2]) {
      var _ = y[2].filter(function(D) {
        return typeof D == "number";
      });
      _.forEach(function(D) {
        h[D.toString(16)] = k;
      });
    }
    return h;
  }), Eme = r(function(h, y, k) {
    if (h[k] = k, y[2]) {
      var _ = y[2].filter(function(D) {
        return typeof D == "string";
      });
      _.forEach(function(D) {
        h[D] = k;
      });
    }
    return h;
  }), Ame = r(function(h, y, k) {
    var _ = y[2];
    return h[k] = k, _.forEach(function(D) {
      h[D] = k;
    }), h;
  });
  var i = "far" in r3 || vr.autoFetchSvg, u = Pte(E1e, function(h, y) {
    var k = y[0], _ = y[1], D = y[2];
    return _ === "far" && !i && (_ = "fas"), typeof k == "string" && (h.names[k] = {
      prefix: _,
      iconName: D
    }), typeof k == "number" && (h.unicodes[k.toString(16)] = {
      prefix: _,
      iconName: D
    }), h;
  }, {
    names: {},
    unicodes: {}
  });
  Tme = u.names, Ome = u.unicodes, nse = fj(vr.styleDefault, {
    family: vr.familyDefault
  });
};
p1e(function(o) {
  nse = fj(o.styleDefault, {
    family: vr.familyDefault
  });
});
Pme();
function ose(o, r) {
  return (_me[o] || {})[r];
}
function D1e(o, r) {
  return (Eme[o] || {})[r];
}
function Ck(o, r) {
  return (Ame[o] || {})[r];
}
function Dme(o) {
  return Tme[o] || {
    prefix: null,
    iconName: null
  };
}
function R1e(o) {
  var r = Ome[o], i = ose("fas", o);
  return r || (i ? {
    prefix: "fas",
    iconName: i
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function Ew() {
  return nse;
}
var rse = function() {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function fj(o) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = r.family, u = i === void 0 ? al : i, h = g5[u][o], y = b5[u][o] || b5[u][h], k = o in jg.styles ? o : null;
  return y || k || null;
}
var ice = (R9 = {}, su(R9, al, Object.keys(v5[al])), su(R9, Gl, Object.keys(v5[Gl])), R9);
function mj(o) {
  var r, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, u = i.skipLookups, h = u === void 0 ? !1 : u, y = (r = {}, su(r, al, "".concat(vr.cssPrefix, "-").concat(al)), su(r, Gl, "".concat(vr.cssPrefix, "-").concat(Gl)), r), k = null, _ = al;
  (o.includes(y[al]) || o.some(function(L) {
    return ice[al].includes(L);
  })) && (_ = al), (o.includes(y[Gl]) || o.some(function(L) {
    return ice[Gl].includes(L);
  })) && (_ = Gl);
  var D = o.reduce(function(L, W) {
    var se = P1e(vr.cssPrefix, W);
    if (r3[W] ? (W = T1e[_].includes(W) ? r1e[_][W] : W, k = W, L.prefix = W) : O1e[_].indexOf(W) > -1 ? (k = W, L.prefix = fj(W, {
      family: _
    })) : se ? L.iconName = se : W !== vr.replacementClass && W !== y[al] && W !== y[Gl] && L.rest.push(W), !h && L.prefix && L.iconName) {
      var J = k === "fa" ? Dme(L.iconName) : {}, be = Ck(L.prefix, L.iconName);
      J.prefix && (k = null), L.iconName = J.iconName || be || L.iconName, L.prefix = J.prefix || L.prefix, L.prefix === "far" && !r3.far && r3.fas && !vr.autoFetchSvg && (L.prefix = "fas");
    }
    return L;
  }, rse());
  return (o.includes("fa-brands") || o.includes("fab")) && (D.prefix = "fab"), (o.includes("fa-duotone") || o.includes("fad")) && (D.prefix = "fad"), !D.prefix && _ === Gl && (r3.fass || vr.autoFetchSvg) && (D.prefix = "fass", D.iconName = Ck(D.prefix, D.iconName) || D.iconName), (D.prefix === "fa" || k === "fa") && (D.prefix = Ew() || "fas"), D;
}
var N1e = /* @__PURE__ */ function() {
  function o() {
    Wve(this, o), this.definitions = {};
  }
  return Gve(o, [{
    key: "add",
    value: function() {
      for (var i = this, u = arguments.length, h = new Array(u), y = 0; y < u; y++)
        h[y] = arguments[y];
      var k = h.reduce(this._pullDefinitions, {});
      Object.keys(k).forEach(function(_) {
        i.definitions[_] = qo(qo({}, i.definitions[_] || {}), k[_]), Wne(_, k[_]);
        var D = v5[al][_];
        D && Wne(D, k[_]), Pme();
      });
    }
  }, {
    key: "reset",
    value: function() {
      this.definitions = {};
    }
  }, {
    key: "_pullDefinitions",
    value: function(i, u) {
      var h = u.prefix && u.iconName && u.icon ? {
        0: u
      } : u;
      return Object.keys(h).map(function(y) {
        var k = h[y], _ = k.prefix, D = k.iconName, L = k.icon, W = L[2];
        i[_] || (i[_] = {}), W.length > 0 && W.forEach(function(se) {
          typeof se == "string" && (i[_][se] = L);
        }), i[_][D] = L;
      }), i;
    }
  }]), o;
}(), lce = [], s3 = {}, w3 = {}, M1e = Object.keys(w3);
function I1e(o, r) {
  var i = r.mixoutsTo;
  return lce = o, s3 = {}, Object.keys(w3).forEach(function(u) {
    M1e.indexOf(u) === -1 && delete w3[u];
  }), lce.forEach(function(u) {
    var h = u.mixout ? u.mixout() : {};
    if (Object.keys(h).forEach(function(k) {
      typeof h[k] == "function" && (i[k] = h[k]), NV(h[k]) === "object" && Object.keys(h[k]).forEach(function(_) {
        i[k] || (i[k] = {}), i[k][_] = h[k][_];
      });
    }), u.hooks) {
      var y = u.hooks();
      Object.keys(y).forEach(function(k) {
        s3[k] || (s3[k] = []), s3[k].push(y[k]);
      });
    }
    u.provides && u.provides(w3);
  }), i;
}
function Zne(o, r) {
  for (var i = arguments.length, u = new Array(i > 2 ? i - 2 : 0), h = 2; h < i; h++)
    u[h - 2] = arguments[h];
  var y = s3[o] || [];
  return y.forEach(function(k) {
    r = k.apply(null, [r].concat(u));
  }), r;
}
function Nk(o) {
  for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), u = 1; u < r; u++)
    i[u - 1] = arguments[u];
  var h = s3[o] || [];
  h.forEach(function(y) {
    y.apply(null, i);
  });
}
function k0() {
  var o = arguments[0], r = Array.prototype.slice.call(arguments, 1);
  return w3[o] ? w3[o].apply(null, r) : void 0;
}
function Gne(o) {
  o.prefix === "fa" && (o.prefix = "fas");
  var r = o.iconName, i = o.prefix || Ew();
  if (r)
    return r = Ck(i, r) || r, sce(Rme.definitions, i, r) || sce(jg.styles, i, r);
}
var Rme = new N1e(), F1e = function() {
  vr.autoReplaceSvg = !1, vr.observeMutations = !1, Nk("noAuto");
}, B1e = {
  i2svg: function() {
    var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return O0 ? (Nk("beforeI2svg", r), k0("pseudoElements2svg", r), k0("i2svg", r)) : Promise.reject("Operation requires a DOM of some kind.");
  },
  watch: function() {
    var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, i = r.autoReplaceSvgRoot;
    vr.autoReplaceSvg === !1 && (vr.autoReplaceSvg = !0), vr.observeMutations = !0, S1e(function() {
      L1e({
        autoReplaceSvgRoot: i
      }), Nk("watch", r);
    });
  }
}, $1e = {
  icon: function(r) {
    if (r === null)
      return null;
    if (NV(r) === "object" && r.prefix && r.iconName)
      return {
        prefix: r.prefix,
        iconName: Ck(r.prefix, r.iconName) || r.iconName
      };
    if (Array.isArray(r) && r.length === 2) {
      var i = r[1].indexOf("fa-") === 0 ? r[1].slice(3) : r[1], u = fj(r[0]);
      return {
        prefix: u,
        iconName: Ck(u, i) || i
      };
    }
    if (typeof r == "string" && (r.indexOf("".concat(vr.cssPrefix, "-")) > -1 || r.match(s1e))) {
      var h = mj(r.split(" "), {
        skipLookups: !0
      });
      return {
        prefix: h.prefix || Ew(),
        iconName: Ck(h.prefix, h.iconName) || h.iconName
      };
    }
    if (typeof r == "string") {
      var y = Ew();
      return {
        prefix: y,
        iconName: Ck(y, r) || r
      };
    }
  }
}, sp = {
  noAuto: F1e,
  config: vr,
  dom: B1e,
  parse: $1e,
  library: Rme,
  findIconDefinition: Gne,
  toHtml: nF
}, L1e = function() {
  var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, i = r.autoReplaceSvgRoot, u = i === void 0 ? ll : i;
  (Object.keys(jg.styles).length > 0 || vr.autoFetchSvg) && O0 && vr.autoReplaceSvg && sp.dom.i2svg({
    node: u
  });
};
function pj(o, r) {
  return Object.defineProperty(o, "abstract", {
    get: r
  }), Object.defineProperty(o, "html", {
    get: function() {
      return o.abstract.map(function(u) {
        return nF(u);
      });
    }
  }), Object.defineProperty(o, "node", {
    get: function() {
      if (O0) {
        var u = ll.createElement("div");
        return u.innerHTML = o.html, u.children;
      }
    }
  }), o;
}
function H1e(o) {
  var r = o.children, i = o.main, u = o.mask, h = o.attributes, y = o.styles, k = o.transform;
  if (tse(k) && i.found && !u.found) {
    var _ = i.width, D = i.height, L = {
      x: _ / D / 2,
      y: 0.5
    };
    h.style = dj(qo(qo({}, y), {}, {
      "transform-origin": "".concat(L.x + k.x / 16, "em ").concat(L.y + k.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes: h,
    children: r
  }];
}
function z1e(o) {
  var r = o.prefix, i = o.iconName, u = o.children, h = o.attributes, y = o.symbol, k = y === !0 ? "".concat(r, "-").concat(vr.cssPrefix, "-").concat(i) : y;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: qo(qo({}, h), {}, {
        id: k
      }),
      children: u
    }]
  }];
}
function sse(o) {
  var r = o.icons, i = r.main, u = r.mask, h = o.prefix, y = o.iconName, k = o.transform, _ = o.symbol, D = o.title, L = o.maskId, W = o.titleId, se = o.extra, J = o.watchable, be = J === void 0 ? !1 : J, ke = u.found ? u : i, Ce = ke.width, Q = ke.height, oe = h === "fak", ae = [vr.replacementClass, y ? "".concat(vr.cssPrefix, "-").concat(y) : ""].filter(function(ot) {
    return se.classes.indexOf(ot) === -1;
  }).filter(function(ot) {
    return ot !== "" || !!ot;
  }).concat(se.classes).join(" "), G = {
    children: [],
    attributes: qo(qo({}, se.attributes), {}, {
      "data-prefix": h,
      "data-icon": y,
      class: ae,
      role: se.attributes.role || "img",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 ".concat(Ce, " ").concat(Q)
    })
  }, ve = oe && !~se.classes.indexOf("fa-fw") ? {
    width: "".concat(Ce / Q * 16 * 0.0625, "em")
  } : {};
  be && (G.attributes[Rk] = ""), D && (G.children.push({
    tag: "title",
    attributes: {
      id: G.attributes["aria-labelledby"] || "title-".concat(W || x5())
    },
    children: [D]
  }), delete G.attributes.title);
  var nt = qo(qo({}, G), {}, {
    prefix: h,
    iconName: y,
    main: i,
    mask: u,
    maskId: L,
    transform: k,
    symbol: _,
    styles: qo(qo({}, ve), se.styles)
  }), Xe = u.found && i.found ? k0("generateAbstractMask", nt) || {
    children: [],
    attributes: {}
  } : k0("generateAbstractIcon", nt) || {
    children: [],
    attributes: {}
  }, te = Xe.children, lt = Xe.attributes;
  return nt.children = te, nt.attributes = lt, _ ? z1e(nt) : H1e(nt);
}
function cce(o) {
  var r = o.content, i = o.width, u = o.height, h = o.transform, y = o.title, k = o.extra, _ = o.watchable, D = _ === void 0 ? !1 : _, L = qo(qo(qo({}, k.attributes), y ? {
    title: y
  } : {}), {}, {
    class: k.classes.join(" ")
  });
  D && (L[Rk] = "");
  var W = qo({}, k.styles);
  tse(h) && (W.transform = y1e({
    transform: h,
    startCentered: !0,
    width: i,
    height: u
  }), W["-webkit-transform"] = W.transform);
  var se = dj(W);
  se.length > 0 && (L.style = se);
  var J = [];
  return J.push({
    tag: "span",
    attributes: L,
    children: [r]
  }), y && J.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [y]
  }), J;
}
function V1e(o) {
  var r = o.content, i = o.title, u = o.extra, h = qo(qo(qo({}, u.attributes), i ? {
    title: i
  } : {}), {}, {
    class: u.classes.join(" ")
  }), y = dj(u.styles);
  y.length > 0 && (h.style = y);
  var k = [];
  return k.push({
    tag: "span",
    attributes: h,
    children: [r]
  }), i && k.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [i]
  }), k;
}
var Dte = jg.styles;
function qne(o) {
  var r = o[0], i = o[1], u = o.slice(4), h = Kre(u, 1), y = h[0], k = null;
  return Array.isArray(y) ? k = {
    tag: "g",
    attributes: {
      class: "".concat(vr.cssPrefix, "-").concat(wk.GROUP)
    },
    children: [{
      tag: "path",
      attributes: {
        class: "".concat(vr.cssPrefix, "-").concat(wk.SECONDARY),
        fill: "currentColor",
        d: y[0]
      }
    }, {
      tag: "path",
      attributes: {
        class: "".concat(vr.cssPrefix, "-").concat(wk.PRIMARY),
        fill: "currentColor",
        d: y[1]
      }
    }]
  } : k = {
    tag: "path",
    attributes: {
      fill: "currentColor",
      d: y
    }
  }, {
    found: !0,
    width: r,
    height: i,
    icon: k
  };
}
var j1e = {
  found: !1,
  width: 512,
  height: 512
};
function U1e(o, r) {
  !vme && !vr.showMissingIcons && o && console.error('Icon with name "'.concat(o, '" and prefix "').concat(r, '" is missing.'));
}
function Kne(o, r) {
  var i = r;
  return r === "fa" && vr.styleDefault !== null && (r = Ew()), new Promise(function(u, h) {
    if (k0("missingIconAbstract"), i === "fa") {
      var y = Dme(o) || {};
      o = y.iconName || o, r = y.prefix || r;
    }
    if (o && r && Dte[r] && Dte[r][o]) {
      var k = Dte[r][o];
      return u(qne(k));
    }
    U1e(o, r), u(qo(qo({}, j1e), {}, {
      icon: vr.showMissingIcons && o ? k0("missingIconAbstract") || {} : {}
    }));
  });
}
var uce = function() {
}, Yne = vr.measurePerformance && k9 && k9.mark && k9.measure ? k9 : {
  mark: uce,
  measure: uce
}, MI = 'FA "6.5.2"', W1e = function(r) {
  return Yne.mark("".concat(MI, " ").concat(r, " begins")), function() {
    return Nme(r);
  };
}, Nme = function(r) {
  Yne.mark("".concat(MI, " ").concat(r, " ends")), Yne.measure("".concat(MI, " ").concat(r), "".concat(MI, " ").concat(r, " begins"), "".concat(MI, " ").concat(r, " ends"));
}, ase = {
  begin: W1e,
  end: Nme
}, J9 = function() {
};
function dce(o) {
  var r = o.getAttribute ? o.getAttribute(Rk) : null;
  return typeof r == "string";
}
function Z1e(o) {
  var r = o.getAttribute ? o.getAttribute(Xre) : null, i = o.getAttribute ? o.getAttribute(Qre) : null;
  return r && i;
}
function G1e(o) {
  return o && o.classList && o.classList.contains && o.classList.contains(vr.replacementClass);
}
function q1e() {
  if (vr.autoReplaceSvg === !0)
    return eV.replace;
  var o = eV[vr.autoReplaceSvg];
  return o || eV.replace;
}
function K1e(o) {
  return ll.createElementNS("http://www.w3.org/2000/svg", o);
}
function Y1e(o) {
  return ll.createElement(o);
}
function Mme(o) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = r.ceFn, u = i === void 0 ? o.tag === "svg" ? K1e : Y1e : i;
  if (typeof o == "string")
    return ll.createTextNode(o);
  var h = u(o.tag);
  Object.keys(o.attributes || []).forEach(function(k) {
    h.setAttribute(k, o.attributes[k]);
  });
  var y = o.children || [];
  return y.forEach(function(k) {
    h.appendChild(Mme(k, {
      ceFn: u
    }));
  }), h;
}
function X1e(o) {
  var r = " ".concat(o.outerHTML, " ");
  return r = "".concat(r, "Font Awesome fontawesome.com "), r;
}
var eV = {
  replace: function(r) {
    var i = r[0];
    if (i.parentNode)
      if (r[1].forEach(function(h) {
        i.parentNode.insertBefore(Mme(h), i);
      }), i.getAttribute(Rk) === null && vr.keepOriginalSource) {
        var u = ll.createComment(X1e(i));
        i.parentNode.replaceChild(u, i);
      } else
        i.remove();
  },
  nest: function(r) {
    var i = r[0], u = r[1];
    if (~ese(i).indexOf(vr.replacementClass))
      return eV.replace(r);
    var h = new RegExp("".concat(vr.cssPrefix, "-.*"));
    if (delete u[0].attributes.id, u[0].attributes.class) {
      var y = u[0].attributes.class.split(" ").reduce(function(_, D) {
        return D === vr.replacementClass || D.match(h) ? _.toSvg.push(D) : _.toNode.push(D), _;
      }, {
        toNode: [],
        toSvg: []
      });
      u[0].attributes.class = y.toSvg.join(" "), y.toNode.length === 0 ? i.removeAttribute("class") : i.setAttribute("class", y.toNode.join(" "));
    }
    var k = u.map(function(_) {
      return nF(_);
    }).join(`
`);
    i.setAttribute(Rk, ""), i.innerHTML = k;
  }
};
function fce(o) {
  o();
}
function Ime(o, r) {
  var i = typeof r == "function" ? r : J9;
  if (o.length === 0)
    i();
  else {
    var u = fce;
    vr.mutateApproach === n1e && (u = _w.requestAnimationFrame || fce), u(function() {
      var h = q1e(), y = ase.begin("mutate");
      o.map(h), y(), i();
    });
  }
}
var ise = !1;
function Fme() {
  ise = !0;
}
function Xne() {
  ise = !1;
}
var IV = null;
function mce(o) {
  if (nce && vr.observeMutations) {
    var r = o.treeCallback, i = r === void 0 ? J9 : r, u = o.nodeCallback, h = u === void 0 ? J9 : u, y = o.pseudoElementsCallback, k = y === void 0 ? J9 : y, _ = o.observeMutationsRoot, D = _ === void 0 ? ll : _;
    IV = new nce(function(L) {
      if (!ise) {
        var W = Ew();
        q3(L).forEach(function(se) {
          if (se.type === "childList" && se.addedNodes.length > 0 && !dce(se.addedNodes[0]) && (vr.searchPseudoElements && k(se.target), i(se.target)), se.type === "attributes" && se.target.parentNode && vr.searchPseudoElements && k(se.target.parentNode), se.type === "attributes" && dce(se.target) && ~c1e.indexOf(se.attributeName))
            if (se.attributeName === "class" && Z1e(se.target)) {
              var J = mj(ese(se.target)), be = J.prefix, ke = J.iconName;
              se.target.setAttribute(Xre, be || W), ke && se.target.setAttribute(Qre, ke);
            } else G1e(se.target) && h(se.target);
        });
      }
    }), O0 && IV.observe(D, {
      childList: !0,
      attributes: !0,
      characterData: !0,
      subtree: !0
    });
  }
}
function Q1e() {
  IV && IV.disconnect();
}
function J1e(o) {
  var r = o.getAttribute("style"), i = [];
  return r && (i = r.split(";").reduce(function(u, h) {
    var y = h.split(":"), k = y[0], _ = y.slice(1);
    return k && _.length > 0 && (u[k] = _.join(":").trim()), u;
  }, {})), i;
}
function e0e(o) {
  var r = o.getAttribute("data-prefix"), i = o.getAttribute("data-icon"), u = o.innerText !== void 0 ? o.innerText.trim() : "", h = mj(ese(o));
  return h.prefix || (h.prefix = Ew()), r && i && (h.prefix = r, h.iconName = i), h.iconName && h.prefix || (h.prefix && u.length > 0 && (h.iconName = D1e(h.prefix, o.innerText) || ose(h.prefix, Une(o.innerText))), !h.iconName && vr.autoFetchSvg && o.firstChild && o.firstChild.nodeType === Node.TEXT_NODE && (h.iconName = o.firstChild.data)), h;
}
function t0e(o) {
  var r = q3(o.attributes).reduce(function(h, y) {
    return h.name !== "class" && h.name !== "style" && (h[y.name] = y.value), h;
  }, {}), i = o.getAttribute("title"), u = o.getAttribute("data-fa-title-id");
  return vr.autoA11y && (i ? r["aria-labelledby"] = "".concat(vr.replacementClass, "-title-").concat(u || x5()) : (r["aria-hidden"] = "true", r.focusable = "false")), r;
}
function n0e() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: hv,
    symbol: !1,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function pce(o) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: !0
  }, i = e0e(o), u = i.iconName, h = i.prefix, y = i.rest, k = t0e(o), _ = Zne("parseNodeAttributes", {}, o), D = r.styleParser ? J1e(o) : [];
  return qo({
    iconName: u,
    title: o.getAttribute("title"),
    titleId: o.getAttribute("data-fa-title-id"),
    prefix: h,
    transform: hv,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: !1,
    extra: {
      classes: y,
      styles: D,
      attributes: k
    }
  }, _);
}
var o0e = jg.styles;
function Bme(o) {
  var r = vr.autoReplaceSvg === "nest" ? pce(o, {
    styleParser: !1
  }) : pce(o);
  return ~r.extra.classes.indexOf(yme) ? k0("generateLayersText", o, r) : k0("generateSvgReplacementMutation", o, r);
}
var Tw = /* @__PURE__ */ new Set();
Jre.map(function(o) {
  Tw.add("fa-".concat(o));
});
Object.keys(g5[al]).map(Tw.add.bind(Tw));
Object.keys(g5[Gl]).map(Tw.add.bind(Tw));
Tw = eF(Tw);
function hce(o) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!O0) return Promise.resolve();
  var i = ll.documentElement.classList, u = function(se) {
    return i.add("".concat(oce, "-").concat(se));
  }, h = function(se) {
    return i.remove("".concat(oce, "-").concat(se));
  }, y = vr.autoFetchSvg ? Tw : Jre.map(function(W) {
    return "fa-".concat(W);
  }).concat(Object.keys(o0e));
  y.includes("fa") || y.push("fa");
  var k = [".".concat(yme, ":not([").concat(Rk, "])")].concat(y.map(function(W) {
    return ".".concat(W, ":not([").concat(Rk, "])");
  })).join(", ");
  if (k.length === 0)
    return Promise.resolve();
  var _ = [];
  try {
    _ = q3(o.querySelectorAll(k));
  } catch {
  }
  if (_.length > 0)
    u("pending"), h("complete");
  else
    return Promise.resolve();
  var D = ase.begin("onTree"), L = _.reduce(function(W, se) {
    try {
      var J = Bme(se);
      J && W.push(J);
    } catch (be) {
      vme || be.name === "MissingIcon" && console.error(be);
    }
    return W;
  }, []);
  return new Promise(function(W, se) {
    Promise.all(L).then(function(J) {
      Ime(J, function() {
        u("active"), u("complete"), h("pending"), typeof r == "function" && r(), D(), W();
      });
    }).catch(function(J) {
      D(), se(J);
    });
  });
}
function r0e(o) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  Bme(o).then(function(i) {
    i && Ime([i], r);
  });
}
function s0e(o) {
  return function(r) {
    var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, u = (r || {}).icon ? r : Gne(r || {}), h = i.mask;
    return h && (h = (h || {}).icon ? h : Gne(h || {})), o(u, qo(qo({}, i), {}, {
      mask: h
    }));
  };
}
var a0e = function(r) {
  var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, u = i.transform, h = u === void 0 ? hv : u, y = i.symbol, k = y === void 0 ? !1 : y, _ = i.mask, D = _ === void 0 ? null : _, L = i.maskId, W = L === void 0 ? null : L, se = i.title, J = se === void 0 ? null : se, be = i.titleId, ke = be === void 0 ? null : be, Ce = i.classes, Q = Ce === void 0 ? [] : Ce, oe = i.attributes, ae = oe === void 0 ? {} : oe, G = i.styles, ve = G === void 0 ? {} : G;
  if (r) {
    var nt = r.prefix, Xe = r.iconName, te = r.icon;
    return pj(qo({
      type: "icon"
    }, r), function() {
      return Nk("beforeDOMElementCreation", {
        iconDefinition: r,
        params: i
      }), vr.autoA11y && (J ? ae["aria-labelledby"] = "".concat(vr.replacementClass, "-title-").concat(ke || x5()) : (ae["aria-hidden"] = "true", ae.focusable = "false")), sse({
        icons: {
          main: qne(te),
          mask: D ? qne(D.icon) : {
            found: !1,
            width: null,
            height: null,
            icon: {}
          }
        },
        prefix: nt,
        iconName: Xe,
        transform: qo(qo({}, hv), h),
        symbol: k,
        title: J,
        maskId: W,
        titleId: ke,
        extra: {
          attributes: ae,
          styles: ve,
          classes: Q
        }
      });
    });
  }
}, i0e = {
  mixout: function() {
    return {
      icon: s0e(a0e)
    };
  },
  hooks: function() {
    return {
      mutationObserverCallbacks: function(i) {
        return i.treeCallback = hce, i.nodeCallback = r0e, i;
      }
    };
  },
  provides: function(r) {
    r.i2svg = function(i) {
      var u = i.node, h = u === void 0 ? ll : u, y = i.callback, k = y === void 0 ? function() {
      } : y;
      return hce(h, k);
    }, r.generateSvgReplacementMutation = function(i, u) {
      var h = u.iconName, y = u.title, k = u.titleId, _ = u.prefix, D = u.transform, L = u.symbol, W = u.mask, se = u.maskId, J = u.extra;
      return new Promise(function(be, ke) {
        Promise.all([Kne(h, _), W.iconName ? Kne(W.iconName, W.prefix) : Promise.resolve({
          found: !1,
          width: 512,
          height: 512,
          icon: {}
        })]).then(function(Ce) {
          var Q = Kre(Ce, 2), oe = Q[0], ae = Q[1];
          be([i, sse({
            icons: {
              main: oe,
              mask: ae
            },
            prefix: _,
            iconName: h,
            transform: D,
            symbol: L,
            maskId: se,
            title: y,
            titleId: k,
            extra: J,
            watchable: !0
          })]);
        }).catch(ke);
      });
    }, r.generateAbstractIcon = function(i) {
      var u = i.children, h = i.attributes, y = i.main, k = i.transform, _ = i.styles, D = dj(_);
      D.length > 0 && (h.style = D);
      var L;
      return tse(k) && (L = k0("generateAbstractTransformGrouping", {
        main: y,
        transform: k,
        containerWidth: y.width,
        iconWidth: y.width
      })), u.push(L || y.icon), {
        children: u,
        attributes: h
      };
    };
  }
}, l0e = {
  mixout: function() {
    return {
      layer: function(i) {
        var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, h = u.classes, y = h === void 0 ? [] : h;
        return pj({
          type: "layer"
        }, function() {
          Nk("beforeDOMElementCreation", {
            assembler: i,
            params: u
          });
          var k = [];
          return i(function(_) {
            Array.isArray(_) ? _.map(function(D) {
              k = k.concat(D.abstract);
            }) : k = k.concat(_.abstract);
          }), [{
            tag: "span",
            attributes: {
              class: ["".concat(vr.cssPrefix, "-layers")].concat(eF(y)).join(" ")
            },
            children: k
          }];
        });
      }
    };
  }
}, c0e = {
  mixout: function() {
    return {
      counter: function(i) {
        var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, h = u.title, y = h === void 0 ? null : h, k = u.classes, _ = k === void 0 ? [] : k, D = u.attributes, L = D === void 0 ? {} : D, W = u.styles, se = W === void 0 ? {} : W;
        return pj({
          type: "counter",
          content: i
        }, function() {
          return Nk("beforeDOMElementCreation", {
            content: i,
            params: u
          }), V1e({
            content: i.toString(),
            title: y,
            extra: {
              attributes: L,
              styles: se,
              classes: ["".concat(vr.cssPrefix, "-layers-counter")].concat(eF(_))
            }
          });
        });
      }
    };
  }
}, u0e = {
  mixout: function() {
    return {
      text: function(i) {
        var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, h = u.transform, y = h === void 0 ? hv : h, k = u.title, _ = k === void 0 ? null : k, D = u.classes, L = D === void 0 ? [] : D, W = u.attributes, se = W === void 0 ? {} : W, J = u.styles, be = J === void 0 ? {} : J;
        return pj({
          type: "text",
          content: i
        }, function() {
          return Nk("beforeDOMElementCreation", {
            content: i,
            params: u
          }), cce({
            content: i,
            transform: qo(qo({}, hv), y),
            title: _,
            extra: {
              attributes: se,
              styles: be,
              classes: ["".concat(vr.cssPrefix, "-layers-text")].concat(eF(L))
            }
          });
        });
      }
    };
  },
  provides: function(r) {
    r.generateLayersText = function(i, u) {
      var h = u.title, y = u.transform, k = u.extra, _ = null, D = null;
      if (hme) {
        var L = parseInt(getComputedStyle(i).fontSize, 10), W = i.getBoundingClientRect();
        _ = W.width / L, D = W.height / L;
      }
      return vr.autoA11y && !h && (k.attributes["aria-hidden"] = "true"), Promise.resolve([i, cce({
        content: i.innerHTML,
        width: _,
        height: D,
        transform: y,
        title: h,
        extra: k,
        watchable: !0
      })]);
    };
  }
}, d0e = new RegExp('"', "ug"), gce = [1105920, 1112319];
function f0e(o) {
  var r = o.replace(d0e, ""), i = _1e(r, 0), u = i >= gce[0] && i <= gce[1], h = r.length === 2 ? r[0] === r[1] : !1;
  return {
    value: Une(h ? r[0] : r),
    isSecondary: u || h
  };
}
function bce(o, r) {
  var i = "".concat(t1e).concat(r.replace(":", "-"));
  return new Promise(function(u, h) {
    if (o.getAttribute(i) !== null)
      return u();
    var y = q3(o.children), k = y.filter(function(te) {
      return te.getAttribute(jne) === r;
    })[0], _ = _w.getComputedStyle(o, r), D = _.getPropertyValue("font-family").match(a1e), L = _.getPropertyValue("font-weight"), W = _.getPropertyValue("content");
    if (k && !D)
      return o.removeChild(k), u();
    if (D && W !== "none" && W !== "") {
      var se = _.getPropertyValue("content"), J = ~["Sharp"].indexOf(D[2]) ? Gl : al, be = ~["Solid", "Regular", "Light", "Thin", "Duotone", "Brands", "Kit"].indexOf(D[2]) ? b5[J][D[2].toLowerCase()] : i1e[J][L], ke = f0e(se), Ce = ke.value, Q = ke.isSecondary, oe = D[0].startsWith("FontAwesome"), ae = ose(be, Ce), G = ae;
      if (oe) {
        var ve = R1e(Ce);
        ve.iconName && ve.prefix && (ae = ve.iconName, be = ve.prefix);
      }
      if (ae && !Q && (!k || k.getAttribute(Xre) !== be || k.getAttribute(Qre) !== G)) {
        o.setAttribute(i, G), k && o.removeChild(k);
        var nt = n0e(), Xe = nt.extra;
        Xe.attributes[jne] = r, Kne(ae, be).then(function(te) {
          var lt = sse(qo(qo({}, nt), {}, {
            icons: {
              main: te,
              mask: rse()
            },
            prefix: be,
            iconName: G,
            extra: Xe,
            watchable: !0
          })), ot = ll.createElementNS("http://www.w3.org/2000/svg", "svg");
          r === "::before" ? o.insertBefore(ot, o.firstChild) : o.appendChild(ot), ot.outerHTML = lt.map(function(Kt) {
            return nF(Kt);
          }).join(`
`), o.removeAttribute(i), u();
        }).catch(h);
      } else
        u();
    } else
      u();
  });
}
function m0e(o) {
  return Promise.all([bce(o, "::before"), bce(o, "::after")]);
}
function p0e(o) {
  return o.parentNode !== document.head && !~o1e.indexOf(o.tagName.toUpperCase()) && !o.getAttribute(jne) && (!o.parentNode || o.parentNode.tagName !== "svg");
}
function vce(o) {
  if (O0)
    return new Promise(function(r, i) {
      var u = q3(o.querySelectorAll("*")).filter(p0e).map(m0e), h = ase.begin("searchPseudoElements");
      Fme(), Promise.all(u).then(function() {
        h(), Xne(), r();
      }).catch(function() {
        h(), Xne(), i();
      });
    });
}
var h0e = {
  hooks: function() {
    return {
      mutationObserverCallbacks: function(i) {
        return i.pseudoElementsCallback = vce, i;
      }
    };
  },
  provides: function(r) {
    r.pseudoElements2svg = function(i) {
      var u = i.node, h = u === void 0 ? ll : u;
      vr.searchPseudoElements && vce(h);
    };
  }
}, yce = !1, g0e = {
  mixout: function() {
    return {
      dom: {
        unwatch: function() {
          Fme(), yce = !0;
        }
      }
    };
  },
  hooks: function() {
    return {
      bootstrap: function() {
        mce(Zne("mutationObserverCallbacks", {}));
      },
      noAuto: function() {
        Q1e();
      },
      watch: function(i) {
        var u = i.observeMutationsRoot;
        yce ? Xne() : mce(Zne("mutationObserverCallbacks", {
          observeMutationsRoot: u
        }));
      }
    };
  }
}, xce = function(r) {
  var i = {
    size: 16,
    x: 0,
    y: 0,
    flipX: !1,
    flipY: !1,
    rotate: 0
  };
  return r.toLowerCase().split(" ").reduce(function(u, h) {
    var y = h.toLowerCase().split("-"), k = y[0], _ = y.slice(1).join("-");
    if (k && _ === "h")
      return u.flipX = !0, u;
    if (k && _ === "v")
      return u.flipY = !0, u;
    if (_ = parseFloat(_), isNaN(_))
      return u;
    switch (k) {
      case "grow":
        u.size = u.size + _;
        break;
      case "shrink":
        u.size = u.size - _;
        break;
      case "left":
        u.x = u.x - _;
        break;
      case "right":
        u.x = u.x + _;
        break;
      case "up":
        u.y = u.y - _;
        break;
      case "down":
        u.y = u.y + _;
        break;
      case "rotate":
        u.rotate = u.rotate + _;
        break;
    }
    return u;
  }, i);
}, b0e = {
  mixout: function() {
    return {
      parse: {
        transform: function(i) {
          return xce(i);
        }
      }
    };
  },
  hooks: function() {
    return {
      parseNodeAttributes: function(i, u) {
        var h = u.getAttribute("data-fa-transform");
        return h && (i.transform = xce(h)), i;
      }
    };
  },
  provides: function(r) {
    r.generateAbstractTransformGrouping = function(i) {
      var u = i.main, h = i.transform, y = i.containerWidth, k = i.iconWidth, _ = {
        transform: "translate(".concat(y / 2, " 256)")
      }, D = "translate(".concat(h.x * 32, ", ").concat(h.y * 32, ") "), L = "scale(".concat(h.size / 16 * (h.flipX ? -1 : 1), ", ").concat(h.size / 16 * (h.flipY ? -1 : 1), ") "), W = "rotate(".concat(h.rotate, " 0 0)"), se = {
        transform: "".concat(D, " ").concat(L, " ").concat(W)
      }, J = {
        transform: "translate(".concat(k / 2 * -1, " -256)")
      }, be = {
        outer: _,
        inner: se,
        path: J
      };
      return {
        tag: "g",
        attributes: qo({}, be.outer),
        children: [{
          tag: "g",
          attributes: qo({}, be.inner),
          children: [{
            tag: u.icon.tag,
            children: u.icon.children,
            attributes: qo(qo({}, u.icon.attributes), be.path)
          }]
        }]
      };
    };
  }
}, Rte = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function wce(o) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return o.attributes && (o.attributes.fill || r) && (o.attributes.fill = "black"), o;
}
function v0e(o) {
  return o.tag === "g" ? o.children : [o];
}
var y0e = {
  hooks: function() {
    return {
      parseNodeAttributes: function(i, u) {
        var h = u.getAttribute("data-fa-mask"), y = h ? mj(h.split(" ").map(function(k) {
          return k.trim();
        })) : rse();
        return y.prefix || (y.prefix = Ew()), i.mask = y, i.maskId = u.getAttribute("data-fa-mask-id"), i;
      }
    };
  },
  provides: function(r) {
    r.generateAbstractMask = function(i) {
      var u = i.children, h = i.attributes, y = i.main, k = i.mask, _ = i.maskId, D = i.transform, L = y.width, W = y.icon, se = k.width, J = k.icon, be = v1e({
        transform: D,
        containerWidth: se,
        iconWidth: L
      }), ke = {
        tag: "rect",
        attributes: qo(qo({}, Rte), {}, {
          fill: "white"
        })
      }, Ce = W.children ? {
        children: W.children.map(wce)
      } : {}, Q = {
        tag: "g",
        attributes: qo({}, be.inner),
        children: [wce(qo({
          tag: W.tag,
          attributes: qo(qo({}, W.attributes), be.path)
        }, Ce))]
      }, oe = {
        tag: "g",
        attributes: qo({}, be.outer),
        children: [Q]
      }, ae = "mask-".concat(_ || x5()), G = "clip-".concat(_ || x5()), ve = {
        tag: "mask",
        attributes: qo(qo({}, Rte), {}, {
          id: ae,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        }),
        children: [ke, oe]
      }, nt = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: G
          },
          children: v0e(J)
        }, ve]
      };
      return u.push(nt, {
        tag: "rect",
        attributes: qo({
          fill: "currentColor",
          "clip-path": "url(#".concat(G, ")"),
          mask: "url(#".concat(ae, ")")
        }, Rte)
      }), {
        children: u,
        attributes: h
      };
    };
  }
}, x0e = {
  provides: function(r) {
    var i = !1;
    _w.matchMedia && (i = _w.matchMedia("(prefers-reduced-motion: reduce)").matches), r.missingIconAbstract = function() {
      var u = [], h = {
        fill: "currentColor"
      }, y = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      u.push({
        tag: "path",
        attributes: qo(qo({}, h), {}, {
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        })
      });
      var k = qo(qo({}, y), {}, {
        attributeName: "opacity"
      }), _ = {
        tag: "circle",
        attributes: qo(qo({}, h), {}, {
          cx: "256",
          cy: "364",
          r: "28"
        }),
        children: []
      };
      return i || _.children.push({
        tag: "animate",
        attributes: qo(qo({}, y), {}, {
          attributeName: "r",
          values: "28;14;28;28;14;28;"
        })
      }, {
        tag: "animate",
        attributes: qo(qo({}, k), {}, {
          values: "1;0;1;1;0;1;"
        })
      }), u.push(_), u.push({
        tag: "path",
        attributes: qo(qo({}, h), {}, {
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        }),
        children: i ? [] : [{
          tag: "animate",
          attributes: qo(qo({}, k), {}, {
            values: "1;0;0;0;0;1;"
          })
        }]
      }), i || u.push({
        tag: "path",
        attributes: qo(qo({}, h), {}, {
          opacity: "0",
          d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
        }),
        children: [{
          tag: "animate",
          attributes: qo(qo({}, k), {}, {
            values: "0;0;1;1;0;0;"
          })
        }]
      }), {
        tag: "g",
        attributes: {
          class: "missing"
        },
        children: u
      };
    };
  }
}, w0e = {
  hooks: function() {
    return {
      parseNodeAttributes: function(i, u) {
        var h = u.getAttribute("data-fa-symbol"), y = h === null ? !1 : h === "" ? !0 : h;
        return i.symbol = y, i;
      }
    };
  }
}, C0e = [w1e, i0e, l0e, c0e, u0e, h0e, g0e, b0e, y0e, x0e, w0e];
I1e(C0e, {
  mixoutsTo: sp
});
sp.noAuto;
sp.config;
sp.library;
sp.dom;
var Qne = sp.parse;
sp.findIconDefinition;
sp.toHtml;
var S0e = sp.icon;
sp.layer;
sp.text;
sp.counter;
function Cce(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function uw(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? Cce(Object(i), !0).forEach(function(u) {
      a3(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : Cce(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function FV(o) {
  "@babel/helpers - typeof";
  return FV = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, FV(o);
}
function a3(o, r, i) {
  return r in o ? Object.defineProperty(o, r, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : o[r] = i, o;
}
function k0e(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
function $me(o, r) {
  if (o == null) return {};
  var i = k0e(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function Jne(o) {
  return _0e(o) || E0e(o) || T0e(o) || O0e();
}
function _0e(o) {
  if (Array.isArray(o)) return eoe(o);
}
function E0e(o) {
  if (typeof Symbol < "u" && o[Symbol.iterator] != null || o["@@iterator"] != null) return Array.from(o);
}
function T0e(o, r) {
  if (o) {
    if (typeof o == "string") return eoe(o, r);
    var i = Object.prototype.toString.call(o).slice(8, -1);
    if (i === "Object" && o.constructor && (i = o.constructor.name), i === "Map" || i === "Set") return Array.from(o);
    if (i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return eoe(o, r);
  }
}
function eoe(o, r) {
  (r == null || r > o.length) && (r = o.length);
  for (var i = 0, u = new Array(r); i < r; i++) u[i] = o[i];
  return u;
}
function O0e() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function A0e(o) {
  var r, i = o.beat, u = o.fade, h = o.beatFade, y = o.bounce, k = o.shake, _ = o.flash, D = o.spin, L = o.spinPulse, W = o.spinReverse, se = o.pulse, J = o.fixedWidth, be = o.inverse, ke = o.border, Ce = o.listItem, Q = o.flip, oe = o.size, ae = o.rotation, G = o.pull, ve = (r = {
    "fa-beat": i,
    "fa-fade": u,
    "fa-beat-fade": h,
    "fa-bounce": y,
    "fa-shake": k,
    "fa-flash": _,
    "fa-spin": D,
    "fa-spin-reverse": W,
    "fa-spin-pulse": L,
    "fa-pulse": se,
    "fa-fw": J,
    "fa-inverse": be,
    "fa-border": ke,
    "fa-li": Ce,
    "fa-flip": Q === !0,
    "fa-flip-horizontal": Q === "horizontal" || Q === "both",
    "fa-flip-vertical": Q === "vertical" || Q === "both"
  }, a3(r, "fa-".concat(oe), typeof oe < "u" && oe !== null), a3(r, "fa-rotate-".concat(ae), typeof ae < "u" && ae !== null && ae !== 0), a3(r, "fa-pull-".concat(G), typeof G < "u" && G !== null), a3(r, "fa-swap-opacity", o.swapOpacity), r);
  return Object.keys(ve).map(function(nt) {
    return ve[nt] ? nt : null;
  }).filter(function(nt) {
    return nt;
  });
}
function P0e(o) {
  return o = o - 0, o === o;
}
function Lme(o) {
  return P0e(o) ? o : (o = o.replace(/[\-_\s]+(.)?/g, function(r, i) {
    return i ? i.toUpperCase() : "";
  }), o.substr(0, 1).toLowerCase() + o.substr(1));
}
var D0e = ["style"];
function R0e(o) {
  return o.charAt(0).toUpperCase() + o.slice(1);
}
function N0e(o) {
  return o.split(";").map(function(r) {
    return r.trim();
  }).filter(function(r) {
    return r;
  }).reduce(function(r, i) {
    var u = i.indexOf(":"), h = Lme(i.slice(0, u)), y = i.slice(u + 1).trim();
    return h.startsWith("webkit") ? r[R0e(h)] = y : r[h] = y, r;
  }, {});
}
function Hme(o, r) {
  var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof r == "string")
    return r;
  var u = (r.children || []).map(function(D) {
    return Hme(o, D);
  }), h = Object.keys(r.attributes || {}).reduce(function(D, L) {
    var W = r.attributes[L];
    switch (L) {
      case "class":
        D.attrs.className = W, delete r.attributes.class;
        break;
      case "style":
        D.attrs.style = N0e(W);
        break;
      default:
        L.indexOf("aria-") === 0 || L.indexOf("data-") === 0 ? D.attrs[L.toLowerCase()] = W : D.attrs[Lme(L)] = W;
    }
    return D;
  }, {
    attrs: {}
  }), y = i.style, k = y === void 0 ? {} : y, _ = $me(i, D0e);
  return h.attrs.style = uw(uw({}, h.attrs.style), k), o.apply(void 0, [r.tag, uw(uw({}, h.attrs), _)].concat(Jne(u)));
}
var zme = !1;
try {
  zme = !0;
} catch {
}
function M0e() {
  if (!zme && console && typeof console.error == "function") {
    var o;
    (o = console).error.apply(o, arguments);
  }
}
function Sce(o) {
  if (o && FV(o) === "object" && o.prefix && o.iconName && o.icon)
    return o;
  if (Qne.icon)
    return Qne.icon(o);
  if (o === null)
    return null;
  if (o && FV(o) === "object" && o.prefix && o.iconName)
    return o;
  if (Array.isArray(o) && o.length === 2)
    return {
      prefix: o[0],
      iconName: o[1]
    };
  if (typeof o == "string")
    return {
      prefix: "fas",
      iconName: o
    };
}
function Nte(o, r) {
  return Array.isArray(r) && r.length > 0 || !Array.isArray(r) && r ? a3({}, o, r) : {};
}
var I0e = ["forwardedRef"];
function oF(o) {
  var r = o.forwardedRef, i = $me(o, I0e), u = i.icon, h = i.mask, y = i.symbol, k = i.className, _ = i.title, D = i.titleId, L = i.maskId, W = Sce(u), se = Nte("classes", [].concat(Jne(A0e(i)), Jne(k.split(" ")))), J = Nte("transform", typeof i.transform == "string" ? Qne.transform(i.transform) : i.transform), be = Nte("mask", Sce(h)), ke = S0e(W, uw(uw(uw(uw({}, se), J), be), {}, {
    symbol: y,
    title: _,
    titleId: D,
    maskId: L
  }));
  if (!ke)
    return M0e("Could not find icon", W), null;
  var Ce = ke.abstract, Q = {
    ref: r
  };
  return Object.keys(i).forEach(function(oe) {
    oF.defaultProps.hasOwnProperty(oe) || (Q[oe] = i[oe]);
  }), F0e(Ce[0], Q);
}
oF.displayName = "FontAwesomeIcon";
oF.propTypes = {
  beat: ce.bool,
  border: ce.bool,
  beatFade: ce.bool,
  bounce: ce.bool,
  className: ce.string,
  fade: ce.bool,
  flash: ce.bool,
  mask: ce.oneOfType([ce.object, ce.array, ce.string]),
  maskId: ce.string,
  fixedWidth: ce.bool,
  inverse: ce.bool,
  flip: ce.oneOf([!0, !1, "horizontal", "vertical", "both"]),
  icon: ce.oneOfType([ce.object, ce.array, ce.string]),
  listItem: ce.bool,
  pull: ce.oneOf(["right", "left"]),
  pulse: ce.bool,
  rotation: ce.oneOf([0, 90, 180, 270]),
  shake: ce.bool,
  size: ce.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
  spin: ce.bool,
  spinPulse: ce.bool,
  spinReverse: ce.bool,
  symbol: ce.oneOfType([ce.bool, ce.string]),
  title: ce.string,
  titleId: ce.string,
  transform: ce.oneOfType([ce.string, ce.object]),
  swapOpacity: ce.bool
};
oF.defaultProps = {
  border: !1,
  className: "",
  mask: null,
  maskId: null,
  fixedWidth: !1,
  inverse: !1,
  flip: !1,
  icon: null,
  listItem: !1,
  pull: null,
  pulse: !1,
  rotation: null,
  size: null,
  spin: !1,
  spinPulse: !1,
  spinReverse: !1,
  beat: !1,
  fade: !1,
  beatFade: !1,
  bounce: !1,
  shake: !1,
  symbol: !1,
  title: "",
  titleId: null,
  transform: null,
  swapOpacity: !1
};
var F0e = Hme.bind(null, Ve.createElement);
function kce() {
  return et.useState(null);
}
const _ce = (o) => !o || typeof o == "function" ? o : (r) => {
  o.current = r;
};
function B0e(o, r) {
  const i = _ce(o), u = _ce(r);
  return (h) => {
    i && i(h), u && u(h);
  };
}
function $0e(o, r) {
  return et.useMemo(() => B0e(o, r), [o, r]);
}
var gm = "top", kh = "bottom", _h = "right", bm = "left", lse = "auto", rF = [gm, kh, _h, bm], N3 = "start", w5 = "end", L0e = "clippingParents", Vme = "viewport", _I = "popper", H0e = "reference", Ece = /* @__PURE__ */ rF.reduce(function(o, r) {
  return o.concat([r + "-" + N3, r + "-" + w5]);
}, []), cse = /* @__PURE__ */ [].concat(rF, [lse]).reduce(function(o, r) {
  return o.concat([r, r + "-" + N3, r + "-" + w5]);
}, []), z0e = "beforeRead", V0e = "read", j0e = "afterRead", U0e = "beforeMain", W0e = "main", Z0e = "afterMain", G0e = "beforeWrite", q0e = "write", K0e = "afterWrite", Y0e = [z0e, V0e, j0e, U0e, W0e, Z0e, G0e, q0e, K0e];
function yv(o) {
  return o.split("-")[0];
}
function op(o) {
  if (o == null)
    return window;
  if (o.toString() !== "[object Window]") {
    var r = o.ownerDocument;
    return r && r.defaultView || window;
  }
  return o;
}
function Mk(o) {
  var r = op(o).Element;
  return o instanceof r || o instanceof Element;
}
function wh(o) {
  var r = op(o).HTMLElement;
  return o instanceof r || o instanceof HTMLElement;
}
function use(o) {
  if (typeof ShadowRoot > "u")
    return !1;
  var r = op(o).ShadowRoot;
  return o instanceof r || o instanceof ShadowRoot;
}
var _k = Math.max, BV = Math.min, M3 = Math.round;
function toe() {
  var o = navigator.userAgentData;
  return o != null && o.brands && Array.isArray(o.brands) ? o.brands.map(function(r) {
    return r.brand + "/" + r.version;
  }).join(" ") : navigator.userAgent;
}
function jme() {
  return !/^((?!chrome|android).)*safari/i.test(toe());
}
function I3(o, r, i) {
  r === void 0 && (r = !1), i === void 0 && (i = !1);
  var u = o.getBoundingClientRect(), h = 1, y = 1;
  r && wh(o) && (h = o.offsetWidth > 0 && M3(u.width) / o.offsetWidth || 1, y = o.offsetHeight > 0 && M3(u.height) / o.offsetHeight || 1);
  var k = Mk(o) ? op(o) : window, _ = k.visualViewport, D = !jme() && i, L = (u.left + (D && _ ? _.offsetLeft : 0)) / h, W = (u.top + (D && _ ? _.offsetTop : 0)) / y, se = u.width / h, J = u.height / y;
  return {
    width: se,
    height: J,
    top: W,
    right: L + se,
    bottom: W + J,
    left: L,
    x: L,
    y: W
  };
}
function dse(o) {
  var r = I3(o), i = o.offsetWidth, u = o.offsetHeight;
  return Math.abs(r.width - i) <= 1 && (i = r.width), Math.abs(r.height - u) <= 1 && (u = r.height), {
    x: o.offsetLeft,
    y: o.offsetTop,
    width: i,
    height: u
  };
}
function Ume(o, r) {
  var i = r.getRootNode && r.getRootNode();
  if (o.contains(r))
    return !0;
  if (i && use(i)) {
    var u = r;
    do {
      if (u && o.isSameNode(u))
        return !0;
      u = u.parentNode || u.host;
    } while (u);
  }
  return !1;
}
function xv(o) {
  return o ? (o.nodeName || "").toLowerCase() : null;
}
function _0(o) {
  return op(o).getComputedStyle(o);
}
function X0e(o) {
  return ["table", "td", "th"].indexOf(xv(o)) >= 0;
}
function Rw(o) {
  return ((Mk(o) ? o.ownerDocument : (
    // $FlowFixMe[prop-missing]
    o.document
  )) || window.document).documentElement;
}
function hj(o) {
  return xv(o) === "html" ? o : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    o.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    o.parentNode || // DOM Element detected
    (use(o) ? o.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Rw(o)
  );
}
function Tce(o) {
  return !wh(o) || // https://github.com/popperjs/popper-core/issues/837
  _0(o).position === "fixed" ? null : o.offsetParent;
}
function Q0e(o) {
  var r = /firefox/i.test(toe()), i = /Trident/i.test(toe());
  if (i && wh(o)) {
    var u = _0(o);
    if (u.position === "fixed")
      return null;
  }
  var h = hj(o);
  for (use(h) && (h = h.host); wh(h) && ["html", "body"].indexOf(xv(h)) < 0; ) {
    var y = _0(h);
    if (y.transform !== "none" || y.perspective !== "none" || y.contain === "paint" || ["transform", "perspective"].indexOf(y.willChange) !== -1 || r && y.willChange === "filter" || r && y.filter && y.filter !== "none")
      return h;
    h = h.parentNode;
  }
  return null;
}
function sF(o) {
  for (var r = op(o), i = Tce(o); i && X0e(i) && _0(i).position === "static"; )
    i = Tce(i);
  return i && (xv(i) === "html" || xv(i) === "body" && _0(i).position === "static") ? r : i || Q0e(o) || r;
}
function fse(o) {
  return ["top", "bottom"].indexOf(o) >= 0 ? "x" : "y";
}
function YI(o, r, i) {
  return _k(o, BV(r, i));
}
function J0e(o, r, i) {
  var u = YI(o, r, i);
  return u > i ? i : u;
}
function Wme() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function Zme(o) {
  return Object.assign({}, Wme(), o);
}
function Gme(o, r) {
  return r.reduce(function(i, u) {
    return i[u] = o, i;
  }, {});
}
var eye = function(r, i) {
  return r = typeof r == "function" ? r(Object.assign({}, i.rects, {
    placement: i.placement
  })) : r, Zme(typeof r != "number" ? r : Gme(r, rF));
};
function tye(o) {
  var r, i = o.state, u = o.name, h = o.options, y = i.elements.arrow, k = i.modifiersData.popperOffsets, _ = yv(i.placement), D = fse(_), L = [bm, _h].indexOf(_) >= 0, W = L ? "height" : "width";
  if (!(!y || !k)) {
    var se = eye(h.padding, i), J = dse(y), be = D === "y" ? gm : bm, ke = D === "y" ? kh : _h, Ce = i.rects.reference[W] + i.rects.reference[D] - k[D] - i.rects.popper[W], Q = k[D] - i.rects.reference[D], oe = sF(y), ae = oe ? D === "y" ? oe.clientHeight || 0 : oe.clientWidth || 0 : 0, G = Ce / 2 - Q / 2, ve = se[be], nt = ae - J[W] - se[ke], Xe = ae / 2 - J[W] / 2 + G, te = YI(ve, Xe, nt), lt = D;
    i.modifiersData[u] = (r = {}, r[lt] = te, r.centerOffset = te - Xe, r);
  }
}
function nye(o) {
  var r = o.state, i = o.options, u = i.element, h = u === void 0 ? "[data-popper-arrow]" : u;
  h != null && (typeof h == "string" && (h = r.elements.popper.querySelector(h), !h) || Ume(r.elements.popper, h) && (r.elements.arrow = h));
}
const qme = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: tye,
  effect: nye,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function F3(o) {
  return o.split("-")[1];
}
var oye = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function rye(o, r) {
  var i = o.x, u = o.y, h = r.devicePixelRatio || 1;
  return {
    x: M3(i * h) / h || 0,
    y: M3(u * h) / h || 0
  };
}
function Oce(o) {
  var r, i = o.popper, u = o.popperRect, h = o.placement, y = o.variation, k = o.offsets, _ = o.position, D = o.gpuAcceleration, L = o.adaptive, W = o.roundOffsets, se = o.isFixed, J = k.x, be = J === void 0 ? 0 : J, ke = k.y, Ce = ke === void 0 ? 0 : ke, Q = typeof W == "function" ? W({
    x: be,
    y: Ce
  }) : {
    x: be,
    y: Ce
  };
  be = Q.x, Ce = Q.y;
  var oe = k.hasOwnProperty("x"), ae = k.hasOwnProperty("y"), G = bm, ve = gm, nt = window;
  if (L) {
    var Xe = sF(i), te = "clientHeight", lt = "clientWidth";
    if (Xe === op(i) && (Xe = Rw(i), _0(Xe).position !== "static" && _ === "absolute" && (te = "scrollHeight", lt = "scrollWidth")), Xe = Xe, h === gm || (h === bm || h === _h) && y === w5) {
      ve = kh;
      var ot = se && Xe === nt && nt.visualViewport ? nt.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        Xe[te]
      );
      Ce -= ot - u.height, Ce *= D ? 1 : -1;
    }
    if (h === bm || (h === gm || h === kh) && y === w5) {
      G = _h;
      var Kt = se && Xe === nt && nt.visualViewport ? nt.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        Xe[lt]
      );
      be -= Kt - u.width, be *= D ? 1 : -1;
    }
  }
  var je = Object.assign({
    position: _
  }, L && oye), ye = W === !0 ? rye({
    x: be,
    y: Ce
  }, op(i)) : {
    x: be,
    y: Ce
  };
  if (be = ye.x, Ce = ye.y, D) {
    var dn;
    return Object.assign({}, je, (dn = {}, dn[ve] = ae ? "0" : "", dn[G] = oe ? "0" : "", dn.transform = (nt.devicePixelRatio || 1) <= 1 ? "translate(" + be + "px, " + Ce + "px)" : "translate3d(" + be + "px, " + Ce + "px, 0)", dn));
  }
  return Object.assign({}, je, (r = {}, r[ve] = ae ? Ce + "px" : "", r[G] = oe ? be + "px" : "", r.transform = "", r));
}
function sye(o) {
  var r = o.state, i = o.options, u = i.gpuAcceleration, h = u === void 0 ? !0 : u, y = i.adaptive, k = y === void 0 ? !0 : y, _ = i.roundOffsets, D = _ === void 0 ? !0 : _, L = {
    placement: yv(r.placement),
    variation: F3(r.placement),
    popper: r.elements.popper,
    popperRect: r.rects.popper,
    gpuAcceleration: h,
    isFixed: r.options.strategy === "fixed"
  };
  r.modifiersData.popperOffsets != null && (r.styles.popper = Object.assign({}, r.styles.popper, Oce(Object.assign({}, L, {
    offsets: r.modifiersData.popperOffsets,
    position: r.options.strategy,
    adaptive: k,
    roundOffsets: D
  })))), r.modifiersData.arrow != null && (r.styles.arrow = Object.assign({}, r.styles.arrow, Oce(Object.assign({}, L, {
    offsets: r.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: D
  })))), r.attributes.popper = Object.assign({}, r.attributes.popper, {
    "data-popper-placement": r.placement
  });
}
const Kme = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: sye,
  data: {}
};
var N9 = {
  passive: !0
};
function aye(o) {
  var r = o.state, i = o.instance, u = o.options, h = u.scroll, y = h === void 0 ? !0 : h, k = u.resize, _ = k === void 0 ? !0 : k, D = op(r.elements.popper), L = [].concat(r.scrollParents.reference, r.scrollParents.popper);
  return y && L.forEach(function(W) {
    W.addEventListener("scroll", i.update, N9);
  }), _ && D.addEventListener("resize", i.update, N9), function() {
    y && L.forEach(function(W) {
      W.removeEventListener("scroll", i.update, N9);
    }), _ && D.removeEventListener("resize", i.update, N9);
  };
}
const Yme = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: aye,
  data: {}
};
var iye = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function tV(o) {
  return o.replace(/left|right|bottom|top/g, function(r) {
    return iye[r];
  });
}
var lye = {
  start: "end",
  end: "start"
};
function Ace(o) {
  return o.replace(/start|end/g, function(r) {
    return lye[r];
  });
}
function mse(o) {
  var r = op(o), i = r.pageXOffset, u = r.pageYOffset;
  return {
    scrollLeft: i,
    scrollTop: u
  };
}
function pse(o) {
  return I3(Rw(o)).left + mse(o).scrollLeft;
}
function cye(o, r) {
  var i = op(o), u = Rw(o), h = i.visualViewport, y = u.clientWidth, k = u.clientHeight, _ = 0, D = 0;
  if (h) {
    y = h.width, k = h.height;
    var L = jme();
    (L || !L && r === "fixed") && (_ = h.offsetLeft, D = h.offsetTop);
  }
  return {
    width: y,
    height: k,
    x: _ + pse(o),
    y: D
  };
}
function uye(o) {
  var r, i = Rw(o), u = mse(o), h = (r = o.ownerDocument) == null ? void 0 : r.body, y = _k(i.scrollWidth, i.clientWidth, h ? h.scrollWidth : 0, h ? h.clientWidth : 0), k = _k(i.scrollHeight, i.clientHeight, h ? h.scrollHeight : 0, h ? h.clientHeight : 0), _ = -u.scrollLeft + pse(o), D = -u.scrollTop;
  return _0(h || i).direction === "rtl" && (_ += _k(i.clientWidth, h ? h.clientWidth : 0) - y), {
    width: y,
    height: k,
    x: _,
    y: D
  };
}
function hse(o) {
  var r = _0(o), i = r.overflow, u = r.overflowX, h = r.overflowY;
  return /auto|scroll|overlay|hidden/.test(i + h + u);
}
function Xme(o) {
  return ["html", "body", "#document"].indexOf(xv(o)) >= 0 ? o.ownerDocument.body : wh(o) && hse(o) ? o : Xme(hj(o));
}
function XI(o, r) {
  var i;
  r === void 0 && (r = []);
  var u = Xme(o), h = u === ((i = o.ownerDocument) == null ? void 0 : i.body), y = op(u), k = h ? [y].concat(y.visualViewport || [], hse(u) ? u : []) : u, _ = r.concat(k);
  return h ? _ : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    _.concat(XI(hj(k)))
  );
}
function noe(o) {
  return Object.assign({}, o, {
    left: o.x,
    top: o.y,
    right: o.x + o.width,
    bottom: o.y + o.height
  });
}
function dye(o, r) {
  var i = I3(o, !1, r === "fixed");
  return i.top = i.top + o.clientTop, i.left = i.left + o.clientLeft, i.bottom = i.top + o.clientHeight, i.right = i.left + o.clientWidth, i.width = o.clientWidth, i.height = o.clientHeight, i.x = i.left, i.y = i.top, i;
}
function Pce(o, r, i) {
  return r === Vme ? noe(cye(o, i)) : Mk(r) ? dye(r, i) : noe(uye(Rw(o)));
}
function fye(o) {
  var r = XI(hj(o)), i = ["absolute", "fixed"].indexOf(_0(o).position) >= 0, u = i && wh(o) ? sF(o) : o;
  return Mk(u) ? r.filter(function(h) {
    return Mk(h) && Ume(h, u) && xv(h) !== "body";
  }) : [];
}
function mye(o, r, i, u) {
  var h = r === "clippingParents" ? fye(o) : [].concat(r), y = [].concat(h, [i]), k = y[0], _ = y.reduce(function(D, L) {
    var W = Pce(o, L, u);
    return D.top = _k(W.top, D.top), D.right = BV(W.right, D.right), D.bottom = BV(W.bottom, D.bottom), D.left = _k(W.left, D.left), D;
  }, Pce(o, k, u));
  return _.width = _.right - _.left, _.height = _.bottom - _.top, _.x = _.left, _.y = _.top, _;
}
function Qme(o) {
  var r = o.reference, i = o.element, u = o.placement, h = u ? yv(u) : null, y = u ? F3(u) : null, k = r.x + r.width / 2 - i.width / 2, _ = r.y + r.height / 2 - i.height / 2, D;
  switch (h) {
    case gm:
      D = {
        x: k,
        y: r.y - i.height
      };
      break;
    case kh:
      D = {
        x: k,
        y: r.y + r.height
      };
      break;
    case _h:
      D = {
        x: r.x + r.width,
        y: _
      };
      break;
    case bm:
      D = {
        x: r.x - i.width,
        y: _
      };
      break;
    default:
      D = {
        x: r.x,
        y: r.y
      };
  }
  var L = h ? fse(h) : null;
  if (L != null) {
    var W = L === "y" ? "height" : "width";
    switch (y) {
      case N3:
        D[L] = D[L] - (r[W] / 2 - i[W] / 2);
        break;
      case w5:
        D[L] = D[L] + (r[W] / 2 - i[W] / 2);
        break;
    }
  }
  return D;
}
function C5(o, r) {
  r === void 0 && (r = {});
  var i = r, u = i.placement, h = u === void 0 ? o.placement : u, y = i.strategy, k = y === void 0 ? o.strategy : y, _ = i.boundary, D = _ === void 0 ? L0e : _, L = i.rootBoundary, W = L === void 0 ? Vme : L, se = i.elementContext, J = se === void 0 ? _I : se, be = i.altBoundary, ke = be === void 0 ? !1 : be, Ce = i.padding, Q = Ce === void 0 ? 0 : Ce, oe = Zme(typeof Q != "number" ? Q : Gme(Q, rF)), ae = J === _I ? H0e : _I, G = o.rects.popper, ve = o.elements[ke ? ae : J], nt = mye(Mk(ve) ? ve : ve.contextElement || Rw(o.elements.popper), D, W, k), Xe = I3(o.elements.reference), te = Qme({
    reference: Xe,
    element: G,
    strategy: "absolute",
    placement: h
  }), lt = noe(Object.assign({}, G, te)), ot = J === _I ? lt : Xe, Kt = {
    top: nt.top - ot.top + oe.top,
    bottom: ot.bottom - nt.bottom + oe.bottom,
    left: nt.left - ot.left + oe.left,
    right: ot.right - nt.right + oe.right
  }, je = o.modifiersData.offset;
  if (J === _I && je) {
    var ye = je[h];
    Object.keys(Kt).forEach(function(dn) {
      var wt = [_h, kh].indexOf(dn) >= 0 ? 1 : -1, qe = [gm, kh].indexOf(dn) >= 0 ? "y" : "x";
      Kt[dn] += ye[qe] * wt;
    });
  }
  return Kt;
}
function pye(o, r) {
  r === void 0 && (r = {});
  var i = r, u = i.placement, h = i.boundary, y = i.rootBoundary, k = i.padding, _ = i.flipVariations, D = i.allowedAutoPlacements, L = D === void 0 ? cse : D, W = F3(u), se = W ? _ ? Ece : Ece.filter(function(ke) {
    return F3(ke) === W;
  }) : rF, J = se.filter(function(ke) {
    return L.indexOf(ke) >= 0;
  });
  J.length === 0 && (J = se);
  var be = J.reduce(function(ke, Ce) {
    return ke[Ce] = C5(o, {
      placement: Ce,
      boundary: h,
      rootBoundary: y,
      padding: k
    })[yv(Ce)], ke;
  }, {});
  return Object.keys(be).sort(function(ke, Ce) {
    return be[ke] - be[Ce];
  });
}
function hye(o) {
  if (yv(o) === lse)
    return [];
  var r = tV(o);
  return [Ace(o), r, Ace(r)];
}
function gye(o) {
  var r = o.state, i = o.options, u = o.name;
  if (!r.modifiersData[u]._skip) {
    for (var h = i.mainAxis, y = h === void 0 ? !0 : h, k = i.altAxis, _ = k === void 0 ? !0 : k, D = i.fallbackPlacements, L = i.padding, W = i.boundary, se = i.rootBoundary, J = i.altBoundary, be = i.flipVariations, ke = be === void 0 ? !0 : be, Ce = i.allowedAutoPlacements, Q = r.options.placement, oe = yv(Q), ae = oe === Q, G = D || (ae || !ke ? [tV(Q)] : hye(Q)), ve = [Q].concat(G).reduce(function(St, on) {
      return St.concat(yv(on) === lse ? pye(r, {
        placement: on,
        boundary: W,
        rootBoundary: se,
        padding: L,
        flipVariations: ke,
        allowedAutoPlacements: Ce
      }) : on);
    }, []), nt = r.rects.reference, Xe = r.rects.popper, te = /* @__PURE__ */ new Map(), lt = !0, ot = ve[0], Kt = 0; Kt < ve.length; Kt++) {
      var je = ve[Kt], ye = yv(je), dn = F3(je) === N3, wt = [gm, kh].indexOf(ye) >= 0, qe = wt ? "width" : "height", B = C5(r, {
        placement: je,
        boundary: W,
        rootBoundary: se,
        altBoundary: J,
        padding: L
      }), mn = wt ? dn ? _h : bm : dn ? kh : gm;
      nt[qe] > Xe[qe] && (mn = tV(mn));
      var dt = tV(mn), En = [];
      if (y && En.push(B[ye] <= 0), _ && En.push(B[mn] <= 0, B[dt] <= 0), En.every(function(St) {
        return St;
      })) {
        ot = je, lt = !1;
        break;
      }
      te.set(je, En);
    }
    if (lt)
      for (var tn = ke ? 3 : 1, Le = function(on) {
        var tt = ve.find(function(mt) {
          var Y = te.get(mt);
          if (Y)
            return Y.slice(0, on).every(function(Wo) {
              return Wo;
            });
        });
        if (tt)
          return ot = tt, "break";
      }, jt = tn; jt > 0; jt--) {
        var Fn = Le(jt);
        if (Fn === "break") break;
      }
    r.placement !== ot && (r.modifiersData[u]._skip = !0, r.placement = ot, r.reset = !0);
  }
}
const Jme = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: gye,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function Dce(o, r, i) {
  return i === void 0 && (i = {
    x: 0,
    y: 0
  }), {
    top: o.top - r.height - i.y,
    right: o.right - r.width + i.x,
    bottom: o.bottom - r.height + i.y,
    left: o.left - r.width - i.x
  };
}
function Rce(o) {
  return [gm, _h, kh, bm].some(function(r) {
    return o[r] >= 0;
  });
}
function bye(o) {
  var r = o.state, i = o.name, u = r.rects.reference, h = r.rects.popper, y = r.modifiersData.preventOverflow, k = C5(r, {
    elementContext: "reference"
  }), _ = C5(r, {
    altBoundary: !0
  }), D = Dce(k, u), L = Dce(_, h, y), W = Rce(D), se = Rce(L);
  r.modifiersData[i] = {
    referenceClippingOffsets: D,
    popperEscapeOffsets: L,
    isReferenceHidden: W,
    hasPopperEscaped: se
  }, r.attributes.popper = Object.assign({}, r.attributes.popper, {
    "data-popper-reference-hidden": W,
    "data-popper-escaped": se
  });
}
const epe = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: bye
};
function vye(o, r, i) {
  var u = yv(o), h = [bm, gm].indexOf(u) >= 0 ? -1 : 1, y = typeof i == "function" ? i(Object.assign({}, r, {
    placement: o
  })) : i, k = y[0], _ = y[1];
  return k = k || 0, _ = (_ || 0) * h, [bm, _h].indexOf(u) >= 0 ? {
    x: _,
    y: k
  } : {
    x: k,
    y: _
  };
}
function yye(o) {
  var r = o.state, i = o.options, u = o.name, h = i.offset, y = h === void 0 ? [0, 0] : h, k = cse.reduce(function(W, se) {
    return W[se] = vye(se, r.rects, y), W;
  }, {}), _ = k[r.placement], D = _.x, L = _.y;
  r.modifiersData.popperOffsets != null && (r.modifiersData.popperOffsets.x += D, r.modifiersData.popperOffsets.y += L), r.modifiersData[u] = k;
}
const tpe = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: yye
};
function xye(o) {
  var r = o.state, i = o.name;
  r.modifiersData[i] = Qme({
    reference: r.rects.reference,
    element: r.rects.popper,
    strategy: "absolute",
    placement: r.placement
  });
}
const npe = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: xye,
  data: {}
};
function wye(o) {
  return o === "x" ? "y" : "x";
}
function Cye(o) {
  var r = o.state, i = o.options, u = o.name, h = i.mainAxis, y = h === void 0 ? !0 : h, k = i.altAxis, _ = k === void 0 ? !1 : k, D = i.boundary, L = i.rootBoundary, W = i.altBoundary, se = i.padding, J = i.tether, be = J === void 0 ? !0 : J, ke = i.tetherOffset, Ce = ke === void 0 ? 0 : ke, Q = C5(r, {
    boundary: D,
    rootBoundary: L,
    padding: se,
    altBoundary: W
  }), oe = yv(r.placement), ae = F3(r.placement), G = !ae, ve = fse(oe), nt = wye(ve), Xe = r.modifiersData.popperOffsets, te = r.rects.reference, lt = r.rects.popper, ot = typeof Ce == "function" ? Ce(Object.assign({}, r.rects, {
    placement: r.placement
  })) : Ce, Kt = typeof ot == "number" ? {
    mainAxis: ot,
    altAxis: ot
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, ot), je = r.modifiersData.offset ? r.modifiersData.offset[r.placement] : null, ye = {
    x: 0,
    y: 0
  };
  if (Xe) {
    if (y) {
      var dn, wt = ve === "y" ? gm : bm, qe = ve === "y" ? kh : _h, B = ve === "y" ? "height" : "width", mn = Xe[ve], dt = mn + Q[wt], En = mn - Q[qe], tn = be ? -lt[B] / 2 : 0, Le = ae === N3 ? te[B] : lt[B], jt = ae === N3 ? -lt[B] : -te[B], Fn = r.elements.arrow, St = be && Fn ? dse(Fn) : {
        width: 0,
        height: 0
      }, on = r.modifiersData["arrow#persistent"] ? r.modifiersData["arrow#persistent"].padding : Wme(), tt = on[wt], mt = on[qe], Y = YI(0, te[B], St[B]), Wo = G ? te[B] / 2 - tn - Y - tt - Kt.mainAxis : Le - Y - tt - Kt.mainAxis, To = G ? -te[B] / 2 + tn + Y + mt + Kt.mainAxis : jt + Y + mt + Kt.mainAxis, Ot = r.elements.arrow && sF(r.elements.arrow), Mt = Ot ? ve === "y" ? Ot.clientTop || 0 : Ot.clientLeft || 0 : 0, zn = (dn = je == null ? void 0 : je[ve]) != null ? dn : 0, At = mn + Wo - zn - Mt, $n = mn + To - zn, en = YI(be ? BV(dt, At) : dt, mn, be ? _k(En, $n) : En);
      Xe[ve] = en, ye[ve] = en - mn;
    }
    if (_) {
      var Ue, jn = ve === "x" ? gm : bm, mo = ve === "x" ? kh : _h, xn = Xe[nt], Vt = nt === "y" ? "height" : "width", Ct = xn + Q[jn], Jn = xn - Q[mo], Pn = [gm, bm].indexOf(oe) !== -1, so = (Ue = je == null ? void 0 : je[nt]) != null ? Ue : 0, pr = Pn ? Ct : xn - te[Vt] - lt[Vt] - so + Kt.altAxis, nr = Pn ? xn + te[Vt] + lt[Vt] - so - Kt.altAxis : Jn, Ko = be && Pn ? J0e(pr, xn, nr) : YI(be ? pr : Ct, xn, be ? nr : Jn);
      Xe[nt] = Ko, ye[nt] = Ko - xn;
    }
    r.modifiersData[u] = ye;
  }
}
const ope = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: Cye,
  requiresIfExists: ["offset"]
};
function Sye(o) {
  return {
    scrollLeft: o.scrollLeft,
    scrollTop: o.scrollTop
  };
}
function kye(o) {
  return o === op(o) || !wh(o) ? mse(o) : Sye(o);
}
function _ye(o) {
  var r = o.getBoundingClientRect(), i = M3(r.width) / o.offsetWidth || 1, u = M3(r.height) / o.offsetHeight || 1;
  return i !== 1 || u !== 1;
}
function Eye(o, r, i) {
  i === void 0 && (i = !1);
  var u = wh(r), h = wh(r) && _ye(r), y = Rw(r), k = I3(o, h, i), _ = {
    scrollLeft: 0,
    scrollTop: 0
  }, D = {
    x: 0,
    y: 0
  };
  return (u || !u && !i) && ((xv(r) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  hse(y)) && (_ = kye(r)), wh(r) ? (D = I3(r, !0), D.x += r.clientLeft, D.y += r.clientTop) : y && (D.x = pse(y))), {
    x: k.left + _.scrollLeft - D.x,
    y: k.top + _.scrollTop - D.y,
    width: k.width,
    height: k.height
  };
}
function Tye(o) {
  var r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), u = [];
  o.forEach(function(y) {
    r.set(y.name, y);
  });
  function h(y) {
    i.add(y.name);
    var k = [].concat(y.requires || [], y.requiresIfExists || []);
    k.forEach(function(_) {
      if (!i.has(_)) {
        var D = r.get(_);
        D && h(D);
      }
    }), u.push(y);
  }
  return o.forEach(function(y) {
    i.has(y.name) || h(y);
  }), u;
}
function Oye(o) {
  var r = Tye(o);
  return Y0e.reduce(function(i, u) {
    return i.concat(r.filter(function(h) {
      return h.phase === u;
    }));
  }, []);
}
function Aye(o) {
  var r;
  return function() {
    return r || (r = new Promise(function(i) {
      Promise.resolve().then(function() {
        r = void 0, i(o());
      });
    })), r;
  };
}
function Pye(o) {
  var r = o.reduce(function(i, u) {
    var h = i[u.name];
    return i[u.name] = h ? Object.assign({}, h, u, {
      options: Object.assign({}, h.options, u.options),
      data: Object.assign({}, h.data, u.data)
    }) : u, i;
  }, {});
  return Object.keys(r).map(function(i) {
    return r[i];
  });
}
var Nce = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function Mce() {
  for (var o = arguments.length, r = new Array(o), i = 0; i < o; i++)
    r[i] = arguments[i];
  return !r.some(function(u) {
    return !(u && typeof u.getBoundingClientRect == "function");
  });
}
function rpe(o) {
  o === void 0 && (o = {});
  var r = o, i = r.defaultModifiers, u = i === void 0 ? [] : i, h = r.defaultOptions, y = h === void 0 ? Nce : h;
  return function(_, D, L) {
    L === void 0 && (L = y);
    var W = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, Nce, y),
      modifiersData: {},
      elements: {
        reference: _,
        popper: D
      },
      attributes: {},
      styles: {}
    }, se = [], J = !1, be = {
      state: W,
      setOptions: function(oe) {
        var ae = typeof oe == "function" ? oe(W.options) : oe;
        Ce(), W.options = Object.assign({}, y, W.options, ae), W.scrollParents = {
          reference: Mk(_) ? XI(_) : _.contextElement ? XI(_.contextElement) : [],
          popper: XI(D)
        };
        var G = Oye(Pye([].concat(u, W.options.modifiers)));
        return W.orderedModifiers = G.filter(function(ve) {
          return ve.enabled;
        }), ke(), be.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!J) {
          var oe = W.elements, ae = oe.reference, G = oe.popper;
          if (Mce(ae, G)) {
            W.rects = {
              reference: Eye(ae, sF(G), W.options.strategy === "fixed"),
              popper: dse(G)
            }, W.reset = !1, W.placement = W.options.placement, W.orderedModifiers.forEach(function(Kt) {
              return W.modifiersData[Kt.name] = Object.assign({}, Kt.data);
            });
            for (var ve = 0; ve < W.orderedModifiers.length; ve++) {
              if (W.reset === !0) {
                W.reset = !1, ve = -1;
                continue;
              }
              var nt = W.orderedModifiers[ve], Xe = nt.fn, te = nt.options, lt = te === void 0 ? {} : te, ot = nt.name;
              typeof Xe == "function" && (W = Xe({
                state: W,
                options: lt,
                name: ot,
                instance: be
              }) || W);
            }
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: Aye(function() {
        return new Promise(function(Q) {
          be.forceUpdate(), Q(W);
        });
      }),
      destroy: function() {
        Ce(), J = !0;
      }
    };
    if (!Mce(_, D))
      return be;
    be.setOptions(L).then(function(Q) {
      !J && L.onFirstUpdate && L.onFirstUpdate(Q);
    });
    function ke() {
      W.orderedModifiers.forEach(function(Q) {
        var oe = Q.name, ae = Q.options, G = ae === void 0 ? {} : ae, ve = Q.effect;
        if (typeof ve == "function") {
          var nt = ve({
            state: W,
            name: oe,
            instance: be,
            options: G
          }), Xe = function() {
          };
          se.push(nt || Xe);
        }
      });
    }
    function Ce() {
      se.forEach(function(Q) {
        return Q();
      }), se = [];
    }
    return be;
  };
}
var Dye = rpe({
  defaultModifiers: [epe, npe, Kme, Yme, tpe, Jme, ope, qme]
});
function spe() {
  const o = et.useRef(!0), r = et.useRef(() => o.current);
  return et.useEffect(() => (o.current = !0, () => {
    o.current = !1;
  }), []), r.current;
}
function Rye(o) {
  const r = spe();
  return [o[0], et.useCallback((i) => {
    if (r())
      return o[1](i);
  }, [r, o[1]])];
}
var Ice = function(r) {
  return {
    position: r,
    top: "0",
    left: "0",
    opacity: "0",
    pointerEvents: "none"
  };
}, Nye = {
  name: "applyStyles",
  enabled: !1
}, Mye = {
  name: "ariaDescribedBy",
  enabled: !0,
  phase: "afterWrite",
  effect: function(r) {
    var i = r.state;
    return function() {
      var u = i.elements, h = u.reference, y = u.popper;
      if ("removeAttribute" in h) {
        var k = (h.getAttribute("aria-describedby") || "").split(",").filter(function(_) {
          return _.trim() !== y.id;
        });
        k.length ? h.setAttribute("aria-describedby", k.join(",")) : h.removeAttribute("aria-describedby");
      }
    };
  },
  fn: function(r) {
    var i, u = r.state, h = u.elements, y = h.popper, k = h.reference, _ = (i = y.getAttribute("role")) == null ? void 0 : i.toLowerCase();
    if (y.id && _ === "tooltip" && "setAttribute" in k) {
      var D = k.getAttribute("aria-describedby");
      if (D && D.split(",").indexOf(y.id) !== -1)
        return;
      k.setAttribute("aria-describedby", D ? D + "," + y.id : y.id);
    }
  }
}, Iye = [];
function Fye(o, r, i) {
  var u = i === void 0 ? {} : i, h = u.enabled, y = h === void 0 ? !0 : h, k = u.placement, _ = k === void 0 ? "bottom" : k, D = u.strategy, L = D === void 0 ? "absolute" : D, W = u.modifiers, se = W === void 0 ? Iye : W, J = _i(u, ["enabled", "placement", "strategy", "modifiers"]), be = et.useRef(), ke = et.useCallback(function() {
    var ve;
    (ve = be.current) == null || ve.update();
  }, []), Ce = et.useCallback(function() {
    var ve;
    (ve = be.current) == null || ve.forceUpdate();
  }, []), Q = Rye(et.useState({
    placement: _,
    update: ke,
    forceUpdate: Ce,
    attributes: {},
    styles: {
      popper: Ice(L),
      arrow: {}
    }
  })), oe = Q[0], ae = Q[1], G = et.useMemo(function() {
    return {
      name: "updateStateModifier",
      enabled: !0,
      phase: "write",
      requires: ["computeStyles"],
      fn: function(nt) {
        var Xe = nt.state, te = {}, lt = {};
        Object.keys(Xe.elements).forEach(function(ot) {
          te[ot] = Xe.styles[ot], lt[ot] = Xe.attributes[ot];
        }), ae({
          state: Xe,
          styles: te,
          attributes: lt,
          update: ke,
          forceUpdate: Ce,
          placement: Xe.placement
        });
      }
    };
  }, [ke, Ce, ae]);
  return et.useEffect(function() {
    !be.current || !y || be.current.setOptions({
      placement: _,
      strategy: L,
      modifiers: [].concat(se, [G, Nye])
    });
  }, [L, _, G, y]), et.useEffect(function() {
    if (!(!y || o == null || r == null))
      return be.current = Dye(o, r, qr({}, J, {
        placement: _,
        strategy: L,
        modifiers: [].concat(se, [Mye, G])
      })), function() {
        be.current != null && (be.current.destroy(), be.current = void 0, ae(function(ve) {
          return qr({}, ve, {
            attributes: {},
            styles: {
              popper: Ice(L)
            }
          });
        }));
      };
  }, [y, o, r]), oe;
}
function ape(o, r) {
  if (o.contains) return o.contains(r);
  if (o.compareDocumentPosition) return o === r || !!(o.compareDocumentPosition(r) & 16);
}
const Bye = !!(typeof window < "u" && window.document && window.document.createElement);
var ooe = !1, roe = !1;
try {
  var Mte = {
    get passive() {
      return ooe = !0;
    },
    get once() {
      return roe = ooe = !0;
    }
  };
  Bye && (window.addEventListener("test", Mte, Mte), window.removeEventListener("test", Mte, !0));
} catch {
}
function $ye(o, r, i, u) {
  if (u && typeof u != "boolean" && !roe) {
    var h = u.once, y = u.capture, k = i;
    !roe && h && (k = i.__once || function _(D) {
      this.removeEventListener(r, _, y), i.call(this, D);
    }, i.__once = k), o.addEventListener(r, k, ooe ? u : y);
  }
  o.addEventListener(r, i, u);
}
function Lye(o, r, i, u) {
  var h = u && typeof u != "boolean" ? u.capture : u;
  o.removeEventListener(r, i, h), i.__once && o.removeEventListener(r, i.__once, h);
}
function i3(o, r, i, u) {
  return $ye(o, r, i, u), function() {
    Lye(o, r, i, u);
  };
}
function Hye(o) {
  const r = et.useRef(o);
  return et.useEffect(() => {
    r.current = o;
  }, [o]), r;
}
function Fce(o) {
  const r = Hye(o);
  return et.useCallback(function(...i) {
    return r.current && r.current(...i);
  }, [r]);
}
var zye = function() {
}, Vye = zye;
const jye = /* @__PURE__ */ H3(Vye);
function gse(o) {
  return o && o.ownerDocument || document;
}
function $V(o) {
  return o && "setState" in o ? yk.findDOMNode(o) : o ?? null;
}
const Uye = function(o) {
  return gse($V(o));
};
var Wye = 27, Bce = function() {
};
function Zye(o) {
  return o.button === 0;
}
function Gye(o) {
  return !!(o.metaKey || o.altKey || o.ctrlKey || o.shiftKey);
}
var $ce = function(r) {
  return r && ("current" in r ? r.current : r);
};
function qye(o, r, i) {
  var u = i === void 0 ? {} : i, h = u.disabled, y = u.clickTrigger, k = y === void 0 ? "click" : y, _ = et.useRef(!1), D = r || Bce, L = et.useCallback(function(J) {
    var be, ke = $ce(o);
    jye(!!ke, "RootClose captured a close event but does not have a ref to compare it to. useRootClose(), should be passed a ref that resolves to a DOM node"), _.current = !ke || Gye(J) || !Zye(J) || !!ape(ke, (be = J.composedPath == null ? void 0 : J.composedPath()[0]) != null ? be : J.target);
  }, [o]), W = Fce(function(J) {
    _.current || D(J);
  }), se = Fce(function(J) {
    J.keyCode === Wye && D(J);
  });
  et.useEffect(function() {
    if (!(h || o == null)) {
      var J = window.event, be = Uye($ce(o)), ke = i3(be, k, L, !0), Ce = i3(be, k, function(ae) {
        if (ae === J) {
          J = void 0;
          return;
        }
        W(ae);
      }), Q = i3(be, "keyup", function(ae) {
        if (ae === J) {
          J = void 0;
          return;
        }
        se(ae);
      }), oe = [];
      return "ontouchstart" in be.documentElement && (oe = [].slice.call(be.body.children).map(function(ae) {
        return i3(ae, "mousemove", Bce);
      })), function() {
        ke(), Ce(), Q(), oe.forEach(function(ae) {
          return ae();
        });
      };
    }
  }, [o, h, k, L, W, se]);
}
var Ite = function(r) {
  var i;
  return typeof document > "u" ? null : r == null ? gse().body : (typeof r == "function" && (r = r()), r && "current" in r && (r = r.current), (i = r) != null && i.nodeType && r || null);
};
function Lce(o, r) {
  var i = et.useState(function() {
    return Ite(o);
  }), u = i[0], h = i[1];
  if (!u) {
    var y = Ite(o);
    y && h(y);
  }
  return et.useEffect(function() {
  }, [r, u]), et.useEffect(function() {
    var k = Ite(o);
    k !== u && h(k);
  }, [o, u]), u;
}
function Kye(o) {
  var r = {};
  return Array.isArray(o) ? (o == null || o.forEach(function(i) {
    r[i.name] = i;
  }), r) : o || r;
}
function Yye(o) {
  return o === void 0 && (o = {}), Array.isArray(o) ? o : Object.keys(o).map(function(r) {
    return o[r].name = r, o[r];
  });
}
function Xye(o) {
  var r, i, u, h, y = o.enabled, k = o.enableEvents, _ = o.placement, D = o.flip, L = o.offset, W = o.fixed, se = o.containerPadding, J = o.arrowElement, be = o.popperConfig, ke = be === void 0 ? {} : be, Ce = Kye(ke.modifiers);
  return qr({}, ke, {
    placement: _,
    enabled: y,
    strategy: W ? "fixed" : ke.strategy,
    modifiers: Yye(qr({}, Ce, {
      eventListeners: {
        enabled: k
      },
      preventOverflow: qr({}, Ce.preventOverflow, {
        options: se ? qr({
          padding: se
        }, (r = Ce.preventOverflow) == null ? void 0 : r.options) : (i = Ce.preventOverflow) == null ? void 0 : i.options
      }),
      offset: {
        options: qr({
          offset: L
        }, (u = Ce.offset) == null ? void 0 : u.options)
      },
      arrow: qr({}, Ce.arrow, {
        enabled: !!J,
        options: qr({}, (h = Ce.arrow) == null ? void 0 : h.options, {
          element: J
        })
      }),
      flip: qr({
        enabled: !!D
      }, Ce.flip)
    }))
  });
}
var bse = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.flip, u = o.offset, h = o.placement, y = o.containerPadding, k = y === void 0 ? 5 : y, _ = o.popperConfig, D = _ === void 0 ? {} : _, L = o.transition, W = kce(), se = W[0], J = W[1], be = kce(), ke = be[0], Ce = be[1], Q = $0e(J, r), oe = Lce(o.container), ae = Lce(o.target), G = et.useState(!o.show), ve = G[0], nt = G[1], Xe = Fye(ae, se, Xye({
    placement: h,
    enableEvents: !!o.show,
    containerPadding: k || 5,
    flip: i,
    offset: u,
    arrowElement: ke,
    popperConfig: D
  })), te = Xe.styles, lt = Xe.attributes, ot = _i(Xe, ["styles", "attributes"]);
  o.show ? ve && nt(!1) : !o.transition && !ve && nt(!0);
  var Kt = function() {
    nt(!0), o.onExited && o.onExited.apply(o, arguments);
  }, je = o.show || L && !ve;
  if (qye(se, o.onHide, {
    disabled: !o.rootClose || o.rootCloseDisabled,
    clickTrigger: o.rootCloseEvent
  }), !je)
    return null;
  var ye = o.children(qr({}, ot, {
    show: !!o.show,
    props: qr({}, lt.popper, {
      style: te.popper,
      ref: Q
    }),
    arrowProps: qr({}, lt.arrow, {
      style: te.arrow,
      ref: Ce
    })
  }));
  if (L) {
    var dn = o.onExit, wt = o.onExiting, qe = o.onEnter, B = o.onEntering, mn = o.onEntered;
    ye = /* @__PURE__ */ Ve.createElement(L, {
      in: o.show,
      appear: !0,
      onExit: dn,
      onExiting: wt,
      onExited: Kt,
      onEnter: qe,
      onEntering: B,
      onEntered: mn
    }, ye);
  }
  return oe ? /* @__PURE__ */ yk.createPortal(ye, oe) : null;
});
bse.displayName = "Overlay";
bse.propTypes = {
  /**
   * Set the visibility of the Overlay
   */
  show: ce.bool,
  /** Specify where the overlay element is positioned in relation to the target element */
  placement: ce.oneOf(cse),
  /**
   * A DOM Element, Ref to an element, or function that returns either. The `target` element is where
   * the overlay is positioned relative to.
   */
  target: ce.any,
  /**
   * A DOM Element, Ref to an element, or function that returns either. The `container` will have the Portal children
   * appended to it.
   */
  container: ce.any,
  /**
   * Enables the Popper.js `flip` modifier, allowing the Overlay to
   * automatically adjust it's placement in case of overlap with the viewport or toggle.
   * Refer to the [flip docs](https://popper.js.org/popper-documentation.html#modifiers..flip.enabled) for more info
   */
  flip: ce.bool,
  /**
   * A render prop that returns an element to overlay and position. See
   * the [react-popper documentation](https://github.com/FezVrasta/react-popper#children) for more info.
   *
   * @type {Function ({
   *   show: boolean,
   *   placement: Placement,
   *   update: () => void,
   *   forceUpdate: () => void,
   *   props: {
   *     ref: (?HTMLElement) => void,
   *     style: { [string]: string | number },
   *     aria-labelledby: ?string
   *     [string]: string | number,
   *   },
   *   arrowProps: {
   *     ref: (?HTMLElement) => void,
   *     style: { [string]: string | number },
   *     [string]: string | number,
   *   },
   * }) => React.Element}
   */
  children: ce.func.isRequired,
  /**
   * Control how much space there is between the edge of the boundary element and overlay.
   * A convenience shortcut to setting `popperConfig.modfiers.preventOverflow.padding`
   */
  containerPadding: ce.number,
  /**
   * A set of popper options and props passed directly to react-popper's Popper component.
   */
  popperConfig: ce.object,
  /**
   * Specify whether the overlay should trigger `onHide` when the user clicks outside the overlay
   */
  rootClose: ce.bool,
  /**
   * Specify event for toggling overlay
   */
  rootCloseEvent: ce.oneOf(["click", "mousedown"]),
  /**
   * Specify disabled for disable RootCloseWrapper
   */
  rootCloseDisabled: ce.bool,
  /**
   * A Callback fired by the Overlay when it wishes to be hidden.
   *
   * __required__ when `rootClose` is `true`.
   *
   * @type func
   */
  onHide: function(r) {
    for (var i = arguments.length, u = new Array(i > 1 ? i - 1 : 0), h = 1; h < i; h++)
      u[h - 1] = arguments[h];
    if (r.rootClose) {
      var y;
      return (y = ce.func).isRequired.apply(y, [r].concat(u));
    }
    return ce.func.apply(ce, [r].concat(u));
  },
  /**
   * A `react-transition-group@2.0.0` `<Transition/>` component
   * used to animate the overlay as it changes visibility.
   */
  // @ts-ignore
  transition: ce.elementType,
  /**
   * Callback fired before the Overlay transitions in
   */
  onEnter: ce.func,
  /**
   * Callback fired as the Overlay begins to transition in
   */
  onEntering: ce.func,
  /**
   * Callback fired after the Overlay finishes transitioning in
   */
  onEntered: ce.func,
  /**
   * Callback fired right before the Overlay transitions out
   */
  onExit: ce.func,
  /**
   * Callback fired as the Overlay begins to transition out
   */
  onExiting: ce.func,
  /**
   * Callback fired after the Overlay finishes transitioning out
   */
  onExited: ce.func
};
function Fte(o, r) {
  return o.classList ? !!r && o.classList.contains(r) : (" " + (o.className.baseVal || o.className) + " ").indexOf(" " + r + " ") !== -1;
}
function Bte(o) {
  var r = window.getComputedStyle(o), i = parseFloat(r.marginTop) || 0, u = parseFloat(r.marginRight) || 0, h = parseFloat(r.marginBottom) || 0, y = parseFloat(r.marginLeft) || 0;
  return {
    top: i,
    right: u,
    bottom: h,
    left: y
  };
}
function Qye() {
  var o = et.useRef(null), r = et.useRef(null), i = et.useRef(null), u = Nc(void 0, "popover"), h = Nc(void 0, "dropdown-menu"), y = et.useCallback(function(L) {
    !L || !(Fte(L, u) || Fte(L, h)) || (r.current = Bte(L), L.style.margin = "0", o.current = L);
  }, [u, h]), k = et.useMemo(function() {
    return {
      name: "offset",
      options: {
        offset: function(W) {
          var se = W.placement;
          if (!r.current) return [0, 0];
          var J = r.current, be = J.top, ke = J.left, Ce = J.bottom, Q = J.right;
          switch (se.split("-")[0]) {
            case "top":
              return [0, Ce];
            case "left":
              return [0, Q];
            case "bottom":
              return [0, be];
            case "right":
              return [0, ke];
            default:
              return [0, 0];
          }
        }
      }
    };
  }, [r]), _ = et.useMemo(function() {
    return {
      name: "arrow",
      options: {
        padding: function() {
          if (!i.current)
            return 0;
          var W = i.current, se = W.top, J = W.right, be = se || J;
          return {
            top: be,
            left: be,
            right: be,
            bottom: be
          };
        }
      }
    };
  }, [i]), D = et.useMemo(function() {
    return {
      name: "popoverArrowMargins",
      enabled: !0,
      phase: "main",
      fn: function() {
      },
      requiresIfExists: ["arrow"],
      effect: function(W) {
        var se = W.state;
        if (!(!o.current || !se.elements.arrow || !Fte(o.current, u))) {
          if (se.modifiersData["arrow#persistent"]) {
            var J = Bte(se.elements.arrow), be = J.top, ke = J.right, Ce = be || ke;
            se.modifiersData["arrow#persistent"].padding = {
              top: Ce,
              left: Ce,
              right: Ce,
              bottom: Ce
            };
          } else
            i.current = Bte(se.elements.arrow);
          return se.elements.arrow.style.margin = "0", function() {
            se.elements.arrow && (se.elements.arrow.style.margin = "");
          };
        }
      }
    };
  }, [u]);
  return [y, [k, _, D]];
}
function soe(o, r) {
  return soe = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, u) {
    return i.__proto__ = u, i;
  }, soe(o, r);
}
function vse(o, r) {
  o.prototype = Object.create(r.prototype), o.prototype.constructor = o, soe(o, r);
}
const Hce = {
  disabled: !1
}, ipe = Ve.createContext(null);
var Jye = function(r) {
  return r.scrollTop;
}, II = "unmounted", fk = "exited", sw = "entering", mk = "entered", aoe = "exiting", A0 = /* @__PURE__ */ function(o) {
  vse(r, o);
  function r(u, h) {
    var y;
    y = o.call(this, u, h) || this;
    var k = h, _ = k && !k.isMounting ? u.enter : u.appear, D;
    return y.appearStatus = null, u.in ? _ ? (D = fk, y.appearStatus = sw) : D = mk : u.unmountOnExit || u.mountOnEnter ? D = II : D = fk, y.state = {
      status: D
    }, y.nextCallback = null, y;
  }
  r.getDerivedStateFromProps = function(h, y) {
    var k = h.in;
    return k && y.status === II ? {
      status: fk
    } : null;
  };
  var i = r.prototype;
  return i.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, i.componentDidUpdate = function(h) {
    var y = null;
    if (h !== this.props) {
      var k = this.state.status;
      this.props.in ? k !== sw && k !== mk && (y = sw) : (k === sw || k === mk) && (y = aoe);
    }
    this.updateStatus(!1, y);
  }, i.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, i.getTimeouts = function() {
    var h = this.props.timeout, y, k, _;
    return y = k = _ = h, h != null && typeof h != "number" && (y = h.exit, k = h.enter, _ = h.appear !== void 0 ? h.appear : k), {
      exit: y,
      enter: k,
      appear: _
    };
  }, i.updateStatus = function(h, y) {
    if (h === void 0 && (h = !1), y !== null)
      if (this.cancelNextCallback(), y === sw) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var k = this.props.nodeRef ? this.props.nodeRef.current : yk.findDOMNode(this);
          k && Jye(k);
        }
        this.performEnter(h);
      } else
        this.performExit();
    else this.props.unmountOnExit && this.state.status === fk && this.setState({
      status: II
    });
  }, i.performEnter = function(h) {
    var y = this, k = this.props.enter, _ = this.context ? this.context.isMounting : h, D = this.props.nodeRef ? [_] : [yk.findDOMNode(this), _], L = D[0], W = D[1], se = this.getTimeouts(), J = _ ? se.appear : se.enter;
    if (!h && !k || Hce.disabled) {
      this.safeSetState({
        status: mk
      }, function() {
        y.props.onEntered(L);
      });
      return;
    }
    this.props.onEnter(L, W), this.safeSetState({
      status: sw
    }, function() {
      y.props.onEntering(L, W), y.onTransitionEnd(J, function() {
        y.safeSetState({
          status: mk
        }, function() {
          y.props.onEntered(L, W);
        });
      });
    });
  }, i.performExit = function() {
    var h = this, y = this.props.exit, k = this.getTimeouts(), _ = this.props.nodeRef ? void 0 : yk.findDOMNode(this);
    if (!y || Hce.disabled) {
      this.safeSetState({
        status: fk
      }, function() {
        h.props.onExited(_);
      });
      return;
    }
    this.props.onExit(_), this.safeSetState({
      status: aoe
    }, function() {
      h.props.onExiting(_), h.onTransitionEnd(k.exit, function() {
        h.safeSetState({
          status: fk
        }, function() {
          h.props.onExited(_);
        });
      });
    });
  }, i.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, i.safeSetState = function(h, y) {
    y = this.setNextCallback(y), this.setState(h, y);
  }, i.setNextCallback = function(h) {
    var y = this, k = !0;
    return this.nextCallback = function(_) {
      k && (k = !1, y.nextCallback = null, h(_));
    }, this.nextCallback.cancel = function() {
      k = !1;
    }, this.nextCallback;
  }, i.onTransitionEnd = function(h, y) {
    this.setNextCallback(y);
    var k = this.props.nodeRef ? this.props.nodeRef.current : yk.findDOMNode(this), _ = h == null && !this.props.addEndListener;
    if (!k || _) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var D = this.props.nodeRef ? [this.nextCallback] : [k, this.nextCallback], L = D[0], W = D[1];
      this.props.addEndListener(L, W);
    }
    h != null && setTimeout(this.nextCallback, h);
  }, i.render = function() {
    var h = this.state.status;
    if (h === II)
      return null;
    var y = this.props, k = y.children;
    y.in, y.mountOnEnter, y.unmountOnExit, y.appear, y.enter, y.exit, y.timeout, y.addEndListener, y.onEnter, y.onEntering, y.onEntered, y.onExit, y.onExiting, y.onExited, y.nodeRef;
    var _ = _i(y, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ Ve.createElement(ipe.Provider, {
        value: null
      }, typeof k == "function" ? k(h, _) : Ve.cloneElement(Ve.Children.only(k), _))
    );
  }, r;
}(Ve.Component);
A0.contextType = ipe;
A0.propTypes = {};
function ZA() {
}
A0.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: ZA,
  onEntering: ZA,
  onEntered: ZA,
  onExit: ZA,
  onExiting: ZA,
  onExited: ZA
};
A0.UNMOUNTED = II;
A0.EXITED = fk;
A0.ENTERING = sw;
A0.ENTERED = mk;
A0.EXITING = aoe;
const exe = A0;
function txe(o) {
  var r = gse(o);
  return r && r.defaultView || window;
}
function nxe(o, r) {
  return txe(o).getComputedStyle(o, r);
}
var oxe = /([A-Z])/g;
function rxe(o) {
  return o.replace(oxe, "-$1").toLowerCase();
}
var sxe = /^ms-/;
function M9(o) {
  return rxe(o).replace(sxe, "-ms-");
}
var axe = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i;
function ixe(o) {
  return !!(o && axe.test(o));
}
function lpe(o, r) {
  var i = "", u = "";
  if (typeof r == "string")
    return o.style.getPropertyValue(M9(r)) || nxe(o).getPropertyValue(M9(r));
  Object.keys(r).forEach(function(h) {
    var y = r[h];
    !y && y !== 0 ? o.style.removeProperty(M9(h)) : ixe(h) ? u += h + "(" + y + ") " : i += M9(h) + ": " + y + ";";
  }), u && (i += "transform: " + u + ";"), o.style.cssText += ";" + i;
}
function lxe(o, r, i, u) {
  if (u === void 0 && (u = !0), o) {
    var h = document.createEvent("HTMLEvents");
    h.initEvent(r, i, u), o.dispatchEvent(h);
  }
}
function cxe(o) {
  var r = lpe(o, "transitionDuration") || "", i = r.indexOf("ms") === -1 ? 1e3 : 1;
  return parseFloat(r) * i;
}
function uxe(o, r, i) {
  i === void 0 && (i = 5);
  var u = !1, h = setTimeout(function() {
    u || lxe(o, "transitionend", !0);
  }, r + i), y = i3(o, "transitionend", function() {
    u = !0;
  }, {
    once: !0
  });
  return function() {
    clearTimeout(h), y();
  };
}
function dxe(o, r, i, u) {
  i == null && (i = cxe(o) || 0);
  var h = uxe(o, i, u), y = i3(o, "transitionend", r);
  return function() {
    h(), y();
  };
}
function zce(o, r) {
  var i = lpe(o, r) || "", u = i.indexOf("ms") === -1 ? 1e3 : 1;
  return parseFloat(i) * u;
}
function fxe(o, r) {
  var i = zce(o, "transitionDuration"), u = zce(o, "transitionDelay"), h = dxe(o, function(y) {
    y.target === o && (h(), r(y));
  }, i + u);
}
function mxe(o) {
  o.offsetHeight;
}
var pxe = ["className", "children"], I9, hxe = {
  in: !1,
  timeout: 300,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1
}, gxe = (I9 = {}, I9[sw] = "show", I9[mk] = "show", I9), gj = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.className, u = o.children, h = _i(o, pxe), y = et.useCallback(function(k) {
    mxe(k), h.onEnter && h.onEnter(k);
  }, [h]);
  return /* @__PURE__ */ Ve.createElement(exe, qr({
    ref: r,
    addEndListener: fxe
  }, h, {
    onEnter: y
  }), function(k, _) {
    return /* @__PURE__ */ Ve.cloneElement(u, qr({}, _, {
      className: ns("fade", i, u.props.className, gxe[k])
    }));
  });
});
gj.defaultProps = hxe;
gj.displayName = "Fade";
var bxe = ["children", "transition", "popperConfig"], vxe = ["props", "arrowProps", "show", "update", "forceUpdate", "placement", "state"], yxe = {
  transition: gj,
  rootClose: !1,
  show: !1,
  placement: "top"
};
function xxe(o, r) {
  var i = o.ref, u = r.ref;
  o.ref = i.__wrapped || (i.__wrapped = function(h) {
    return i($V(h));
  }), r.ref = u.__wrapped || (u.__wrapped = function(h) {
    return u($V(h));
  });
}
function cpe(o) {
  var r = o.children, i = o.transition, u = o.popperConfig, h = u === void 0 ? {} : u, y = _i(o, bxe), k = et.useRef({}), _ = Qye(), D = _[0], L = _[1], W = i === !0 ? gj : i || null;
  return /* @__PURE__ */ Ve.createElement(bse, qr({}, y, {
    ref: D,
    popperConfig: qr({}, h, {
      modifiers: L.concat(h.modifiers || [])
    }),
    transition: W
  }), function(se) {
    var J, be = se.props, ke = se.arrowProps, Ce = se.show, Q = se.update;
    se.forceUpdate;
    var oe = se.placement, ae = se.state, G = _i(se, vxe);
    xxe(be, ke);
    var ve = Object.assign(k.current, {
      state: ae,
      scheduleUpdate: Q,
      placement: oe,
      outOfBoundaries: (ae == null || (J = ae.modifiersData.hide) == null ? void 0 : J.isReferenceHidden) || !1
    });
    return typeof r == "function" ? r(qr({}, G, be, {
      placement: oe,
      show: Ce
    }, !i && Ce && {
      className: "show"
    }, {
      popper: ve,
      arrowProps: ke
    })) : /* @__PURE__ */ Ve.cloneElement(r, qr({}, G, be, {
      placement: oe,
      arrowProps: ke,
      popper: ve,
      className: ns(r.props.className, !i && Ce && "show"),
      style: qr({}, r.props.style, be.style)
    }));
  });
}
cpe.defaultProps = yxe;
function wxe(o) {
  const r = et.useRef(o);
  return r.current = o, r;
}
function Cxe(o) {
  const r = wxe(o);
  et.useEffect(() => () => r.current(), []);
}
const ioe = 2 ** 31 - 1;
function upe(o, r, i) {
  const u = i - Date.now();
  o.current = u <= ioe ? setTimeout(r, u) : setTimeout(() => upe(o, r, i), ioe);
}
function Sxe() {
  const o = spe(), r = et.useRef();
  return Cxe(() => clearTimeout(r.current)), et.useMemo(() => {
    const i = () => clearTimeout(r.current);
    function u(h, y = 0) {
      o() && (i(), y <= ioe ? r.current = setTimeout(h, y) : upe(r, h, Date.now() + y));
    }
    return {
      set: u,
      clear: i,
      handleRef: r
    };
  }, []);
}
function kxe(o, r, i) {
  var u = et.useRef(o !== void 0), h = et.useState(r), y = h[0], k = h[1], _ = o !== void 0, D = u.current;
  return u.current = _, !_ && D && y !== r && k(r), [_ ? o : y, et.useCallback(function(L) {
    for (var W = arguments.length, se = new Array(W > 1 ? W - 1 : 0), J = 1; J < W; J++)
      se[J - 1] = arguments[J];
    i && i.apply(void 0, [L].concat(se)), k(L);
  }, [i])];
}
var _xe = ["trigger", "overlay", "children", "popperConfig", "show", "defaultShow", "onToggle", "delay", "placement", "flip"], Exe = /* @__PURE__ */ function(o) {
  vse(r, o);
  function r() {
    return o.apply(this, arguments) || this;
  }
  var i = r.prototype;
  return i.render = function() {
    return this.props.children;
  }, r;
}(Ve.Component);
function Txe(o) {
  return o && typeof o == "object" ? o : {
    show: o,
    hide: o
  };
}
function Vce(o, r, i) {
  var u = r[0], h = u.currentTarget, y = u.relatedTarget || u.nativeEvent[i];
  (!y || y !== h) && !ape(h, y) && o.apply(void 0, r);
}
var Oxe = {
  defaultShow: !1,
  trigger: ["hover", "focus"]
};
function dpe(o) {
  var r = o.trigger, i = o.overlay, u = o.children, h = o.popperConfig, y = h === void 0 ? {} : h, k = o.show, _ = o.defaultShow, D = _ === void 0 ? !1 : _, L = o.onToggle, W = o.delay, se = o.placement, J = o.flip, be = J === void 0 ? se && se.indexOf("auto") !== -1 : J, ke = _i(o, _xe), Ce = et.useRef(null), Q = Sxe(), oe = et.useRef(""), ae = kxe(k, D, L), G = ae[0], ve = ae[1], nt = Txe(W), Xe = typeof u != "function" ? Ve.Children.only(u).props : {}, te = Xe.onFocus, lt = Xe.onBlur, ot = Xe.onClick, Kt = et.useCallback(function() {
    return $V(Ce.current);
  }, []), je = et.useCallback(function() {
    if (Q.clear(), oe.current = "show", !nt.show) {
      ve(!0);
      return;
    }
    Q.set(function() {
      oe.current === "show" && ve(!0);
    }, nt.show);
  }, [nt.show, ve, Q]), ye = et.useCallback(function() {
    if (Q.clear(), oe.current = "hide", !nt.hide) {
      ve(!1);
      return;
    }
    Q.set(function() {
      oe.current === "hide" && ve(!1);
    }, nt.hide);
  }, [nt.hide, ve, Q]), dn = et.useCallback(function() {
    je();
    for (var tn = arguments.length, Le = new Array(tn), jt = 0; jt < tn; jt++)
      Le[jt] = arguments[jt];
    te == null || te.apply(void 0, Le);
  }, [je, te]), wt = et.useCallback(function() {
    ye();
    for (var tn = arguments.length, Le = new Array(tn), jt = 0; jt < tn; jt++)
      Le[jt] = arguments[jt];
    lt == null || lt.apply(void 0, Le);
  }, [ye, lt]), qe = et.useCallback(function() {
    ve(!G), ot && ot.apply(void 0, arguments);
  }, [ot, ve, G]), B = et.useCallback(function() {
    for (var tn = arguments.length, Le = new Array(tn), jt = 0; jt < tn; jt++)
      Le[jt] = arguments[jt];
    Vce(je, Le, "fromElement");
  }, [je]), mn = et.useCallback(function() {
    for (var tn = arguments.length, Le = new Array(tn), jt = 0; jt < tn; jt++)
      Le[jt] = arguments[jt];
    Vce(ye, Le, "toElement");
  }, [ye]), dt = r == null ? [] : [].concat(r), En = {};
  return dt.indexOf("click") !== -1 && (En.onClick = qe), dt.indexOf("focus") !== -1 && (En.onFocus = dn, En.onBlur = wt), dt.indexOf("hover") !== -1 && (En.onMouseOver = B, En.onMouseOut = mn), /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, typeof u == "function" ? u(qr({}, En, {
    ref: Ce
  })) : /* @__PURE__ */ Ve.createElement(Exe, {
    ref: Ce
  }, /* @__PURE__ */ et.cloneElement(u, En)), /* @__PURE__ */ Ve.createElement(cpe, qr({}, ke, {
    show: G,
    onHide: ye,
    flip: be,
    placement: se,
    popperConfig: y,
    target: Kt
  }), i));
}
dpe.defaultProps = Oxe;
var fpe = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"], Axe = ["hover", "click", "focus"];
function bj(o) {
  return /* @__PURE__ */ Ve.createElement(dpe, o, o.children);
}
var jce = ce.oneOf(Axe);
ce.node.isRequired, ce.oneOfType([ce.elementType, ce.func]), ce.func, ce.func, ce.func, ce.func, ce.func, ce.func, ce.func, ce.oneOf(fpe), ce.shape({}), ce.bool, ce.oneOf(["click", "mousedown"]), ce.bool, ce.oneOfType([ce.elementType, ce.func]), ce.oneOfType([ce.object, ce.bool]);
bj.propTypes = {
  /** Specifies the content of the `OverlayTrigger`. */
  children: ce.oneOfType([ce.element, ce.func]).isRequired,
  /** An element or text to overlay next to the target. */
  overlay: ce.oneOfType([ce.element, ce.func]).isRequired,
  /** The initial visibility state of the `Overlay`. */
  defaultShow: ce.bool,
  /** A millisecond delay amount to show and hide the `Overlay` once triggered. */
  delay: ce.oneOfType([ce.number, ce.shape({})]),
  /** The initial flip state of the `Overlay`. */
  flip: ce.bool,
  onHide: ce.func,
  /**
   * A callback that fires when the user triggers a change in tooltip visibility.
   * `onToggle` is called with the desired next show, and generally should be
   * passed back to the `show` prop. `onToggle` fires after the configured `delay`.
   *
   * Controls `show`.
   */
  onToggle: ce.func,
  /** The placement of the `Overlay` in relation to it's target. */
  placement: ce.oneOf(fpe),
  /** A `Popper.js` config object passed to the the underlying popper instance. */
  popperConfig: ce.shape({}),
  /**
   * The visibility of the `Overlay`. `show` is a controlled prop so should
   * be paired with `onToggle` to avoid breaking user interactions.
   *
   * Manually toggling show does not wait for delay to change the visibility.
   *
   * Controls `onToggle`.
   */
  show: ce.bool,
  target: ce.instanceOf(EventTarget),
  /** Specify which action or actions trigger `Overlay` visibility. */
  trigger: ce.oneOfType([jce, ce.arrayOf(jce)])
};
bj.defaultProps = {
  defaultShow: !1,
  delay: void 0,
  flip: void 0,
  onHide: void 0,
  onToggle: void 0,
  placement: void 0,
  popperConfig: {},
  show: void 0,
  target: void 0,
  trigger: ["hover", "focus"]
};
var Uce = { exports: {} };
(function(o, r) {
  Object.defineProperty(r, "__esModule", {
    value: !0
  }), r.default = i;
  function i(u) {
    return function(y, k, _, D, L) {
      var W = _ || "<<anonymous>>", se = L || k;
      if (y[k] == null)
        return new Error("The " + D + " `" + se + "` is required to make " + ("`" + W + "` accessible for users of assistive ") + "technologies such as screen readers.");
      for (var J = arguments.length, be = Array(J > 5 ? J - 5 : 0), ke = 5; ke < J; ke++)
        be[ke - 5] = arguments[ke];
      return u.apply(void 0, [y, k, _, D, L].concat(be));
    };
  }
  o.exports = r.default;
})(Uce, Uce.exports);
var Pxe = ["bsPrefix", "placement", "className", "style", "children", "arrowProps", "popper", "show"], Dxe = {
  placement: "right"
}, vj = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.bsPrefix, u = o.placement, h = o.className, y = o.style, k = o.children, _ = o.arrowProps;
  o.popper, o.show;
  var D = _i(o, Pxe);
  i = Nc(i, "tooltip");
  var L = (u == null ? void 0 : u.split("-")) || [], W = L[0];
  return /* @__PURE__ */ Ve.createElement("div", qr({
    ref: r,
    style: y,
    role: "tooltip",
    "x-placement": W,
    className: ns(h, i, "bs-tooltip-" + W)
  }, D), /* @__PURE__ */ Ve.createElement("div", qr({
    className: "arrow"
  }, _)), /* @__PURE__ */ Ve.createElement("div", {
    className: i + "-inner"
  }, k));
});
vj.defaultProps = Dxe;
vj.displayName = "Tooltip";
function S5(o) {
  "@babel/helpers - typeof";
  return S5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, S5(o);
}
var Rxe = ["children", "variant"];
function Wce(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function LV(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? Wce(Object(i), !0).forEach(function(u) {
      Nxe(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : Wce(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function Nxe(o, r, i) {
  return r = Mxe(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function Mxe(o) {
  var r = Ixe(o, "string");
  return S5(r) == "symbol" ? r : r + "";
}
function Ixe(o, r) {
  if (S5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (S5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
function loe() {
  return loe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, loe.apply(this, arguments);
}
function Fxe(o, r) {
  if (o == null) return {};
  var i = Bxe(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function Bxe(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
var $xe = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"], k5 = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.children, u = o.variant, h = Fxe(o, Rxe);
  return /* @__PURE__ */ Ve.createElement(vj, loe({}, h, {
    className: ns({
      "tooltip-light": u === "light"
    }, h.className),
    ref: r
  }), i);
});
k5.propTypes = LV(LV({}, vj.propTypes), {}, {
  /** An html id attribute, necessary for accessibility. */
  id: ce.string.isRequired,
  /**
   * Sets the direction the `Tooltip` is positioned towards.
   *
   * This is generally provided by the `Overlay` component positioning the tooltip.
   */
  placement: ce.oneOf($xe),
  /**
   * An `Overlay` injected set of props for positioning the `Tooltip` arrow.
   *
   * This is generally provided by the `Overlay` component positioning the tooltip.
   */
  arrowProps: ce.shape({
    ref: ce.oneOfType([ce.func, ce.shape({
      current: ce.element
    })]),
    style: ce.shape({})
  }),
  /** Whether the `Overlay` is shown. */
  show: ce.bool,
  /** A `Popper.js` config object passed to the the underlying popper instance. */
  popper: ce.shape({}),
  /** Overrides underlying component base CSS class name */
  bsPrefix: ce.string,
  /** Specifies the content of the `Tooltip` */
  children: ce.node,
  /** Specifies class name to append to the base element */
  className: ce.string,
  /** The visual style of the `Tooltip` */
  variant: ce.string
});
k5.defaultProps = LV(LV({}, k5.defaultProps), {}, {
  id: void 0,
  placement: "right",
  arrowProps: void 0,
  show: void 0,
  popper: void 0,
  children: void 0,
  className: void 0,
  variant: void 0,
  bsPrefix: "tooltip"
});
function _5(o) {
  "@babel/helpers - typeof";
  return _5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, _5(o);
}
var Lxe = ["className", "alt", "invertColors", "icon", "src", "iconClassNames", "onClick", "size", "variant", "iconAs", "isActive"], Hxe = ["tooltipPlacement", "tooltipContent", "variant", "invertColors"];
function HV() {
  return HV = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, HV.apply(this, arguments);
}
function zxe(o, r, i) {
  return r = Vxe(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function Vxe(o) {
  var r = jxe(o, "string");
  return _5(r) == "symbol" ? r : r + "";
}
function jxe(o, r) {
  if (_5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (_5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
function mpe(o, r) {
  if (o == null) return {};
  var i = Uxe(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function Uxe(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
var aF = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.className, u = o.alt, h = o.invertColors, y = o.icon, k = o.src, _ = o.iconClassNames, D = o.onClick, L = o.size, W = o.variant, se = o.iconAs, J = o.isActive, be = mpe(o, Lxe), ke = h ? "inverse-" : "", Ce = J ? "".concat(W, "-") : "";
  if (!se && !1)
    var Q;
  var oe = se || oF;
  return /* @__PURE__ */ Ve.createElement("button", HV({
    "aria-label": u,
    className: ns("btn-icon", "btn-icon-".concat(ke).concat(W), "btn-icon-".concat(L), zxe({}, "btn-icon-".concat(ke).concat(Ce, "active"), J), i),
    onClick: D,
    type: "button",
    ref: r
  }, be), /* @__PURE__ */ Ve.createElement("span", {
    className: "btn-icon__icon-container"
  }, /* @__PURE__ */ Ve.createElement(oe, {
    className: ns("btn-icon__icon", _),
    icon: y,
    src: k
  })));
});
aF.defaultProps = {
  iconAs: void 0,
  src: null,
  icon: void 0,
  iconClassNames: void 0,
  className: void 0,
  invertColors: !1,
  variant: "primary",
  size: "md",
  onClick: function() {
  },
  isActive: !1
};
aF.propTypes = {
  /** A custom class name. */
  className: ce.string,
  /** Component that renders the icon, currently defaults to `FontAwesomeIcon`,
   *  but is going to be deprecated soon, please use Paragon's icons instead. */
  iconAs: ce.elementType,
  /** An icon component to render. Example import of a Paragon icon component:
   * `import { Check } from '@openedx/paragon/dist/icon';`
   * */
  src: ce.oneOfType([ce.element, ce.elementType]),
  /** Alt text for your icon. For best practice, avoid using alt text to describe
   * the image in the `IconButton`. Instead, we recommend describing the function
   * of the button. */
  alt: ce.string.isRequired,
  /** Changes icon styles for dark background */
  invertColors: ce.bool,
  /** Accepts a React fontawesome icon. */
  icon: ce.shape({
    prefix: ce.string,
    iconName: ce.string,
    // eslint-disable-next-line react/forbid-prop-types
    icon: ce.array
  }),
  /** Extra class names that will be added to the icon */
  iconClassNames: ce.string,
  /** Click handler for the button */
  onClick: ce.func,
  /** Type of button (uses Bootstrap options) */
  variant: ce.oneOf(["primary", "secondary", "success", "warning", "danger", "light", "dark", "black", "brand"]),
  /** size of button to render */
  size: ce.oneOf(["sm", "md", "inline"]),
  /** whether to show the `IconButton` in an active state, whose styling is distinct from default state */
  isActive: ce.bool
};
function yse(o) {
  var r = o.tooltipPlacement, i = o.tooltipContent, u = o.variant, h = o.invertColors, y = mpe(o, Hxe), k = h ? "inverse-" : "";
  return /* @__PURE__ */ Ve.createElement(bj, {
    placement: r,
    overlay: /* @__PURE__ */ Ve.createElement(k5, {
      id: "iconbutton-tooltip-".concat(r),
      variant: k ? "light" : ""
    }, i)
  }, /* @__PURE__ */ Ve.createElement(aF, HV({
    variant: u,
    invertColors: h
  }, y)));
}
yse.defaultProps = {
  tooltipPlacement: "top",
  variant: "primary",
  invertColors: !1
};
yse.propTypes = {
  /** tooltip placement can be top, left, right etc, per https://popper.js.org/docs/v2/constructors/#options  */
  tooltipPlacement: ce.string,
  /** any valid JSX or text to be rendered as tooltip contents */
  tooltipContent: ce.node.isRequired,
  /** Type of button (uses Bootstrap options) */
  variant: ce.oneOf(["primary", "secondary", "success", "warning", "danger", "light", "dark", "black", "brand"]),
  /** Changes icon styles for dark background */
  invertColors: ce.bool
};
aF.IconButtonWithTooltip = yse;
var Ld = function() {
  return Ld = Object.assign || function(r) {
    for (var i, u = 1, h = arguments.length; u < h; u++) {
      i = arguments[u];
      for (var y in i) Object.prototype.hasOwnProperty.call(i, y) && (r[y] = i[y]);
    }
    return r;
  }, Ld.apply(this, arguments);
};
function B3(o, r) {
  var i = {};
  for (var u in o) Object.prototype.hasOwnProperty.call(o, u) && r.indexOf(u) < 0 && (i[u] = o[u]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var h = 0, u = Object.getOwnPropertySymbols(o); h < u.length; h++)
      r.indexOf(u[h]) < 0 && Object.prototype.propertyIsEnumerable.call(o, u[h]) && (i[u[h]] = o[u[h]]);
  return i;
}
function Wxe() {
  for (var o = 0, r = 0, i = arguments.length; r < i; r++) o += arguments[r].length;
  for (var u = Array(o), h = 0, r = 0; r < i; r++)
    for (var y = arguments[r], k = 0, _ = y.length; k < _; k++, h++)
      u[h] = y[k];
  return u;
}
function Zxe(o, r, i) {
  if (i || arguments.length === 2) for (var u = 0, h = r.length, y; u < h; u++)
    (y || !(u in r)) && (y || (y = Array.prototype.slice.call(r, 0, u)), y[u] = r[u]);
  return o.concat(y || Array.prototype.slice.call(r));
}
var ppe = { exports: {} }, si = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Du = typeof Symbol == "function" && Symbol.for, xse = Du ? Symbol.for("react.element") : 60103, wse = Du ? Symbol.for("react.portal") : 60106, yj = Du ? Symbol.for("react.fragment") : 60107, xj = Du ? Symbol.for("react.strict_mode") : 60108, wj = Du ? Symbol.for("react.profiler") : 60114, Cj = Du ? Symbol.for("react.provider") : 60109, Sj = Du ? Symbol.for("react.context") : 60110, Cse = Du ? Symbol.for("react.async_mode") : 60111, kj = Du ? Symbol.for("react.concurrent_mode") : 60111, _j = Du ? Symbol.for("react.forward_ref") : 60112, Ej = Du ? Symbol.for("react.suspense") : 60113, Gxe = Du ? Symbol.for("react.suspense_list") : 60120, Tj = Du ? Symbol.for("react.memo") : 60115, Oj = Du ? Symbol.for("react.lazy") : 60116, qxe = Du ? Symbol.for("react.block") : 60121, Kxe = Du ? Symbol.for("react.fundamental") : 60117, Yxe = Du ? Symbol.for("react.responder") : 60118, Xxe = Du ? Symbol.for("react.scope") : 60119;
function ap(o) {
  if (typeof o == "object" && o !== null) {
    var r = o.$$typeof;
    switch (r) {
      case xse:
        switch (o = o.type, o) {
          case Cse:
          case kj:
          case yj:
          case wj:
          case xj:
          case Ej:
            return o;
          default:
            switch (o = o && o.$$typeof, o) {
              case Sj:
              case _j:
              case Oj:
              case Tj:
              case Cj:
                return o;
              default:
                return r;
            }
        }
      case wse:
        return r;
    }
  }
}
function hpe(o) {
  return ap(o) === kj;
}
si.AsyncMode = Cse;
si.ConcurrentMode = kj;
si.ContextConsumer = Sj;
si.ContextProvider = Cj;
si.Element = xse;
si.ForwardRef = _j;
si.Fragment = yj;
si.Lazy = Oj;
si.Memo = Tj;
si.Portal = wse;
si.Profiler = wj;
si.StrictMode = xj;
si.Suspense = Ej;
si.isAsyncMode = function(o) {
  return hpe(o) || ap(o) === Cse;
};
si.isConcurrentMode = hpe;
si.isContextConsumer = function(o) {
  return ap(o) === Sj;
};
si.isContextProvider = function(o) {
  return ap(o) === Cj;
};
si.isElement = function(o) {
  return typeof o == "object" && o !== null && o.$$typeof === xse;
};
si.isForwardRef = function(o) {
  return ap(o) === _j;
};
si.isFragment = function(o) {
  return ap(o) === yj;
};
si.isLazy = function(o) {
  return ap(o) === Oj;
};
si.isMemo = function(o) {
  return ap(o) === Tj;
};
si.isPortal = function(o) {
  return ap(o) === wse;
};
si.isProfiler = function(o) {
  return ap(o) === wj;
};
si.isStrictMode = function(o) {
  return ap(o) === xj;
};
si.isSuspense = function(o) {
  return ap(o) === Ej;
};
si.isValidElementType = function(o) {
  return typeof o == "string" || typeof o == "function" || o === yj || o === kj || o === wj || o === xj || o === Ej || o === Gxe || typeof o == "object" && o !== null && (o.$$typeof === Oj || o.$$typeof === Tj || o.$$typeof === Cj || o.$$typeof === Sj || o.$$typeof === _j || o.$$typeof === Kxe || o.$$typeof === Yxe || o.$$typeof === Xxe || o.$$typeof === qxe);
};
si.typeOf = ap;
ppe.exports = si;
var Qxe = ppe.exports, gpe = Qxe, Jxe = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, ewe = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, bpe = {};
bpe[gpe.ForwardRef] = Jxe;
bpe[gpe.Memo] = ewe;
function twe(o, r, i) {
  if (i === void 0 && (i = Error), !o)
    throw new i(r);
}
var nwe = function(o) {
}, owe = function(o) {
}, rwe = {
  formats: {},
  messages: {},
  timeZone: void 0,
  defaultLocale: "en",
  defaultFormats: {},
  fallbackOnEmptyString: !0,
  onError: nwe,
  onWarn: owe
};
function swe(o) {
  twe(o, "[React Intl] Could not find required `intl` object. <IntlProvider> needs to exist in the component ancestry.");
}
Ld(Ld({}, rwe), { textComponent: et.Fragment });
var Sse = typeof window < "u" && !window.__REACT_INTL_BYPASS_GLOBAL_CONTEXT__ ? window.__REACT_INTL_CONTEXT__ || (window.__REACT_INTL_CONTEXT__ = et.createContext(null)) : et.createContext(null);
Sse.Consumer;
Sse.Provider;
var awe = Sse;
function kse() {
  var o = et.useContext(awe);
  return swe(o), o;
}
var coe;
(function(o) {
  o.formatDate = "FormattedDate", o.formatTime = "FormattedTime", o.formatNumber = "FormattedNumber", o.formatList = "FormattedList", o.formatDisplayName = "FormattedDisplayName";
})(coe || (coe = {}));
var uoe;
(function(o) {
  o.formatDate = "FormattedDateParts", o.formatTime = "FormattedTimeParts", o.formatNumber = "FormattedNumberParts", o.formatList = "FormattedListParts";
})(uoe || (uoe = {}));
function vpe(o) {
  var r = function(i) {
    var u = kse(), h = i.value, y = i.children, k = B3(i, ["value", "children"]), _ = typeof h == "string" ? new Date(h || 0) : h, D = o === "formatDate" ? u.formatDateToParts(_, k) : u.formatTimeToParts(_, k);
    return y(D);
  };
  return r.displayName = uoe[o], r;
}
function iF(o) {
  var r = function(i) {
    var u = kse(), h = i.value, y = i.children, k = B3(
      i,
      ["value", "children"]
    ), _ = u[o](h, k);
    if (typeof y == "function")
      return y(_);
    var D = u.textComponent || et.Fragment;
    return et.createElement(D, null, _);
  };
  return r.displayName = coe[o], r;
}
iF("formatDate");
iF("formatTime");
iF("formatNumber");
iF("formatList");
iF("formatDisplayName");
vpe("formatDate");
vpe("formatTime");
function doe() {
  return doe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, doe.apply(this, arguments);
}
var iwe = function(r) {
  return /* @__PURE__ */ et.createElement("svg", doe({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, r), /* @__PURE__ */ et.createElement("path", {
    d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2Zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59Z",
    fill: "currentColor"
  }));
};
function foe() {
  return foe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, foe.apply(this, arguments);
}
var lwe = function(r) {
  return /* @__PURE__ */ et.createElement("svg", foe({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, r), /* @__PURE__ */ et.createElement("path", {
    d: "M9 16.2 4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2Z",
    fill: "currentColor"
  }));
};
function moe() {
  return moe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, moe.apply(this, arguments);
}
var cwe = function(r) {
  return /* @__PURE__ */ et.createElement("svg", moe({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, r), /* @__PURE__ */ et.createElement("path", {
    d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2Zm-2 15-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9Z",
    fill: "currentColor"
  }));
};
function poe() {
  return poe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, poe.apply(this, arguments);
}
var uwe = function(r) {
  return /* @__PURE__ */ et.createElement("svg", poe({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, r), /* @__PURE__ */ et.createElement("path", {
    d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z",
    fill: "currentColor"
  }));
};
function hoe() {
  return hoe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, hoe.apply(this, arguments);
}
var dwe = function(r) {
  return /* @__PURE__ */ et.createElement("svg", hoe({
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none"
  }, r), /* @__PURE__ */ et.createElement("path", {
    d: "M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z",
    fill: "currentColor"
  }));
};
function goe() {
  return goe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, goe.apply(this, arguments);
}
var fwe = function(r) {
  return /* @__PURE__ */ et.createElement("svg", goe({
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none"
  }, r), /* @__PURE__ */ et.createElement("path", {
    d: "M7.41 15.41 12 10.83l4.59 4.58L18 14l-6-6-6 6 1.41 1.41z",
    fill: "currentColor"
  }));
};
function boe() {
  return boe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, boe.apply(this, arguments);
}
var mwe = function(r) {
  return /* @__PURE__ */ et.createElement("svg", boe({
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none"
  }, r), /* @__PURE__ */ et.createElement("path", {
    d: "M19 12.998h-6v6h-2v-6H5v-2h6v-6h2v6h6z",
    fill: "currentColor"
  }));
};
function voe() {
  return voe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, voe.apply(this, arguments);
}
var pwe = function(r) {
  return /* @__PURE__ */ et.createElement("svg", voe({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, r), /* @__PURE__ */ et.createElement("path", {
    d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2Zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8Z",
    fill: "currentColor"
  }));
};
function yoe() {
  return yoe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, yoe.apply(this, arguments);
}
var hwe = function(r) {
  return /* @__PURE__ */ et.createElement("svg", yoe({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, r), /* @__PURE__ */ et.createElement("path", {
    xmlns: "http://www.w3.org/2000/svg",
    d: "M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z",
    fill: "currentColor"
  }));
}, gwe = /-(.)/g;
function bwe(o) {
  return o.replace(gwe, function(r, i) {
    return i.toUpperCase();
  });
}
var vwe = ["className", "bsPrefix", "as"], ywe = function(r) {
  return r[0].toUpperCase() + bwe(r).slice(1);
};
function xwe(o, r) {
  var i = {}, u = i.displayName, h = u === void 0 ? ywe(o) : u, y = i.Component, k = i.defaultProps, _ = /* @__PURE__ */ Ve.forwardRef(function(D, L) {
    var W = D.className, se = D.bsPrefix, J = D.as, be = J === void 0 ? y || "div" : J, ke = _i(D, vwe), Ce = Nc(se, o);
    return /* @__PURE__ */ Ve.createElement(be, qr({
      ref: L,
      className: ns(W, Ce)
    }, ke));
  });
  return _.defaultProps = k, _.displayName = h, _;
}
var wwe = ["bsPrefix", "className", "as"], Cwe = ["xl", "lg", "md", "sm", "xs"], ype = /* @__PURE__ */ Ve.forwardRef(
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  function(o, r) {
    var i = o.bsPrefix, u = o.className, h = o.as, y = h === void 0 ? "div" : h, k = _i(o, wwe), _ = Nc(i, "col"), D = [], L = [];
    return Cwe.forEach(function(W) {
      var se = k[W];
      delete k[W];
      var J, be, ke;
      if (typeof se == "object" && se != null) {
        var Ce = se.span;
        J = Ce === void 0 ? !0 : Ce, be = se.offset, ke = se.order;
      } else
        J = se;
      var Q = W !== "xs" ? "-" + W : "";
      J && D.push(J === !0 ? "" + _ + Q : "" + _ + Q + "-" + J), ke != null && L.push("order" + Q + "-" + ke), be != null && L.push("offset" + Q + "-" + be);
    }), D.length || D.push(_), /* @__PURE__ */ Ve.createElement(y, qr({}, k, {
      ref: r,
      className: ns.apply(void 0, [u].concat(D, L))
    }));
  }
);
ype.displayName = "Col";
var Zce = { exports: {} }, xoe = { exports: {} };
(function(o, r) {
  Object.defineProperty(r, "__esModule", {
    value: !0
  }), r.default = i;
  function i(u) {
    function h(k, _, D, L, W, se) {
      var J = L || "<<anonymous>>", be = se || D;
      if (_[D] == null)
        return k ? new Error("Required " + W + " `" + be + "` was not specified " + ("in `" + J + "`.")) : null;
      for (var ke = arguments.length, Ce = Array(ke > 6 ? ke - 6 : 0), Q = 6; Q < ke; Q++)
        Ce[Q - 6] = arguments[Q];
      return u.apply(void 0, [_, D, J, W, be].concat(Ce));
    }
    var y = h.bind(null, !1);
    return y.isRequired = h.bind(null, !0), y;
  }
  o.exports = r.default;
})(xoe, xoe.exports);
var Swe = xoe.exports;
(function(o, r) {
  Object.defineProperty(r, "__esModule", {
    value: !0
  }), r.default = y;
  var i = Swe, u = h(i);
  function h(k) {
    return k && k.__esModule ? k : { default: k };
  }
  function y() {
    for (var k = arguments.length, _ = Array(k), D = 0; D < k; D++)
      _[D] = arguments[D];
    function L() {
      for (var W = arguments.length, se = Array(W), J = 0; J < W; J++)
        se[J] = arguments[J];
      var be = null;
      return _.forEach(function(ke) {
        if (be == null) {
          var Ce = ke.apply(void 0, se);
          Ce != null && (be = Ce);
        }
      }), be;
    }
    return (0, u.default)(L);
  }
  o.exports = r.default;
})(Zce, Zce.exports);
var kwe = ["as", "className", "type", "tooltip"], _we = {
  /**
   * Specify whether the feedback is for valid or invalid fields
   *
   * @type {('valid'|'invalid')}
   */
  type: ce.string,
  /** Display feedback as a tooltip. */
  tooltip: ce.bool,
  as: ce.elementType
}, lF = /* @__PURE__ */ Ve.forwardRef(
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  function(o, r) {
    var i = o.as, u = i === void 0 ? "div" : i, h = o.className, y = o.type, k = y === void 0 ? "valid" : y, _ = o.tooltip, D = _ === void 0 ? !1 : _, L = _i(o, kwe);
    return /* @__PURE__ */ Ve.createElement(u, qr({}, L, {
      ref: r,
      className: ns(h, k + "-" + (D ? "tooltip" : "feedback"))
    }));
  }
);
lF.displayName = "Feedback";
lF.propTypes = _we;
var Ug = /* @__PURE__ */ Ve.createContext({
  controlId: void 0
}), Ewe = ["id", "bsPrefix", "bsCustomPrefix", "className", "type", "isValid", "isInvalid", "isStatic", "as"], _se = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.id, u = o.bsPrefix, h = o.bsCustomPrefix, y = o.className, k = o.type, _ = k === void 0 ? "checkbox" : k, D = o.isValid, L = D === void 0 ? !1 : D, W = o.isInvalid, se = W === void 0 ? !1 : W, J = o.isStatic, be = o.as, ke = be === void 0 ? "input" : be, Ce = _i(o, Ewe), Q = et.useContext(Ug), oe = Q.controlId, ae = Q.custom, G = ae ? [h, "custom-control-input"] : [u, "form-check-input"], ve = G[0], nt = G[1];
  return u = Nc(ve, nt), /* @__PURE__ */ Ve.createElement(ke, qr({}, Ce, {
    ref: r,
    type: _,
    id: i || oe,
    className: ns(y, u, L && "is-valid", se && "is-invalid", J && "position-static")
  }));
});
_se.displayName = "FormCheckInput";
var Twe = ["bsPrefix", "bsCustomPrefix", "className", "htmlFor"], Ese = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.bsPrefix, u = o.bsCustomPrefix, h = o.className, y = o.htmlFor, k = _i(o, Twe), _ = et.useContext(Ug), D = _.controlId, L = _.custom, W = L ? [u, "custom-control-label"] : [i, "form-check-label"], se = W[0], J = W[1];
  return i = Nc(se, J), /* @__PURE__ */ Ve.createElement("label", qr({}, k, {
    ref: r,
    htmlFor: y || D,
    className: ns(h, i)
  }));
});
Ese.displayName = "FormCheckLabel";
var Owe = ["id", "bsPrefix", "bsCustomPrefix", "inline", "disabled", "isValid", "isInvalid", "feedbackTooltip", "feedback", "className", "style", "title", "type", "label", "children", "custom", "as"], Hk = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.id, u = o.bsPrefix, h = o.bsCustomPrefix, y = o.inline, k = y === void 0 ? !1 : y, _ = o.disabled, D = _ === void 0 ? !1 : _, L = o.isValid, W = L === void 0 ? !1 : L, se = o.isInvalid, J = se === void 0 ? !1 : se, be = o.feedbackTooltip, ke = be === void 0 ? !1 : be, Ce = o.feedback, Q = o.className, oe = o.style, ae = o.title, G = ae === void 0 ? "" : ae, ve = o.type, nt = ve === void 0 ? "checkbox" : ve, Xe = o.label, te = o.children, lt = o.custom, ot = o.as, Kt = ot === void 0 ? "input" : ot, je = _i(o, Owe), ye = nt === "switch" ? !0 : lt, dn = ye ? [h, "custom-control"] : [u, "form-check"], wt = dn[0], qe = dn[1];
  u = Nc(wt, qe);
  var B = et.useContext(Ug), mn = B.controlId, dt = et.useMemo(function() {
    return {
      controlId: i || mn,
      custom: ye
    };
  }, [mn, ye, i]), En = ye || Xe != null && Xe !== !1 && !te, tn = /* @__PURE__ */ Ve.createElement(_se, qr({}, je, {
    type: nt === "switch" ? "checkbox" : nt,
    ref: r,
    isValid: W,
    isInvalid: J,
    isStatic: !En,
    disabled: D,
    as: Kt
  }));
  return /* @__PURE__ */ Ve.createElement(Ug.Provider, {
    value: dt
  }, /* @__PURE__ */ Ve.createElement("div", {
    style: oe,
    className: ns(Q, u, ye && "custom-" + nt, k && u + "-inline")
  }, te || /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, tn, En && /* @__PURE__ */ Ve.createElement(Ese, {
    title: G
  }, Xe), (W || J) && /* @__PURE__ */ Ve.createElement(lF, {
    type: W ? "valid" : "invalid",
    tooltip: ke
  }, Ce))));
});
Hk.displayName = "FormCheck";
Hk.Input = _se;
Hk.Label = Ese;
var Awe = ["id", "bsPrefix", "bsCustomPrefix", "className", "isValid", "isInvalid", "lang", "as"], Tse = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.id, u = o.bsPrefix, h = o.bsCustomPrefix, y = o.className, k = o.isValid, _ = o.isInvalid, D = o.lang, L = o.as, W = L === void 0 ? "input" : L, se = _i(o, Awe), J = et.useContext(Ug), be = J.controlId, ke = J.custom, Ce = "file", Q = ke ? [h, "custom-file-input"] : [u, "form-control-file"], oe = Q[0], ae = Q[1];
  return u = Nc(oe, ae), /* @__PURE__ */ Ve.createElement(W, qr({}, se, {
    ref: r,
    id: i || be,
    type: Ce,
    lang: D,
    className: ns(y, u, k && "is-valid", _ && "is-invalid")
  }));
});
Tse.displayName = "FormFileInput";
var Pwe = ["bsPrefix", "bsCustomPrefix", "className", "htmlFor"], zV = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.bsPrefix, u = o.bsCustomPrefix, h = o.className, y = o.htmlFor, k = _i(o, Pwe), _ = et.useContext(Ug), D = _.controlId, L = _.custom, W = L ? [u, "custom-file-label"] : [i, "form-file-label"], se = W[0], J = W[1];
  return i = Nc(se, J), /* @__PURE__ */ Ve.createElement("label", qr({}, k, {
    ref: r,
    htmlFor: y || D,
    className: ns(h, i),
    "data-browse": k["data-browse"]
  }));
});
zV.displayName = "FormFileLabel";
var Dwe = ["id", "bsPrefix", "bsCustomPrefix", "disabled", "isValid", "isInvalid", "feedbackTooltip", "feedback", "className", "style", "label", "children", "custom", "lang", "data-browse", "as", "inputAs"], Aj = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.id, u = o.bsPrefix, h = o.bsCustomPrefix, y = o.disabled, k = y === void 0 ? !1 : y, _ = o.isValid, D = _ === void 0 ? !1 : _, L = o.isInvalid, W = L === void 0 ? !1 : L, se = o.feedbackTooltip, J = se === void 0 ? !1 : se, be = o.feedback, ke = o.className, Ce = o.style, Q = o.label, oe = o.children, ae = o.custom, G = o.lang, ve = o["data-browse"], nt = o.as, Xe = nt === void 0 ? "div" : nt, te = o.inputAs, lt = te === void 0 ? "input" : te, ot = _i(o, Dwe), Kt = ae ? [h, "custom"] : [u, "form-file"], je = Kt[0], ye = Kt[1];
  u = Nc(je, ye);
  var dn = "file", wt = et.useContext(Ug), qe = wt.controlId, B = et.useMemo(function() {
    return {
      controlId: i || qe,
      custom: ae
    };
  }, [qe, ae, i]), mn = Q != null && Q !== !1 && !oe, dt = /* @__PURE__ */ Ve.createElement(Tse, qr({}, ot, {
    ref: r,
    isValid: D,
    isInvalid: W,
    disabled: k,
    as: lt,
    lang: G
  }));
  return /* @__PURE__ */ Ve.createElement(Ug.Provider, {
    value: B
  }, /* @__PURE__ */ Ve.createElement(Xe, {
    style: Ce,
    className: ns(ke, u, ae && "custom-" + dn)
  }, oe || /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, ae ? /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, dt, mn && /* @__PURE__ */ Ve.createElement(zV, {
    "data-browse": ve
  }, Q)) : /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, mn && /* @__PURE__ */ Ve.createElement(zV, null, Q), dt), (D || W) && /* @__PURE__ */ Ve.createElement(lF, {
    type: D ? "valid" : "invalid",
    tooltip: J
  }, be))));
});
Aj.displayName = "FormFile";
Aj.Input = Tse;
Aj.Label = zV;
var Rwe = ["bsPrefix", "bsCustomPrefix", "type", "size", "htmlSize", "id", "className", "isValid", "isInvalid", "plaintext", "readOnly", "custom", "as"], xpe = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.bsPrefix, u = o.bsCustomPrefix, h = o.type, y = o.size, k = o.htmlSize, _ = o.id, D = o.className, L = o.isValid, W = L === void 0 ? !1 : L, se = o.isInvalid, J = se === void 0 ? !1 : se, be = o.plaintext, ke = o.readOnly, Ce = o.custom, Q = o.as, oe = Q === void 0 ? "input" : Q, ae = _i(o, Rwe), G = et.useContext(Ug), ve = G.controlId, nt = Ce ? [u, "custom"] : [i, "form-control"], Xe = nt[0], te = nt[1];
  i = Nc(Xe, te);
  var lt;
  if (be) {
    var ot;
    lt = (ot = {}, ot[i + "-plaintext"] = !0, ot);
  } else if (h === "file") {
    var Kt;
    lt = (Kt = {}, Kt[i + "-file"] = !0, Kt);
  } else if (h === "range") {
    var je;
    lt = (je = {}, je[i + "-range"] = !0, je);
  } else if (oe === "select" && Ce) {
    var ye;
    lt = (ye = {}, ye[i + "-select"] = !0, ye[i + "-select-" + y] = y, ye);
  } else {
    var dn;
    lt = (dn = {}, dn[i] = !0, dn[i + "-" + y] = y, dn);
  }
  return /* @__PURE__ */ Ve.createElement(oe, qr({}, ae, {
    type: h,
    size: k,
    ref: r,
    readOnly: ke,
    id: _ || ve,
    className: ns(D, lt, W && "is-valid", J && "is-invalid")
  }));
});
xpe.displayName = "FormControl";
const wpe = Object.assign(xpe, {
  Feedback: lF
});
var Nwe = ["bsPrefix", "className", "children", "controlId", "as"], Cpe = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.bsPrefix, u = o.className, h = o.children, y = o.controlId, k = o.as, _ = k === void 0 ? "div" : k, D = _i(o, Nwe);
  i = Nc(i, "form-group");
  var L = et.useMemo(function() {
    return {
      controlId: y
    };
  }, [y]);
  return /* @__PURE__ */ Ve.createElement(Ug.Provider, {
    value: L
  }, /* @__PURE__ */ Ve.createElement(_, qr({}, D, {
    ref: r,
    className: ns(u, i)
  }), h));
});
Cpe.displayName = "FormGroup";
var Mwe = ["as", "bsPrefix", "column", "srOnly", "className", "htmlFor"], Iwe = {
  column: !1,
  srOnly: !1
}, Ose = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.as, u = i === void 0 ? "label" : i, h = o.bsPrefix, y = o.column, k = o.srOnly, _ = o.className, D = o.htmlFor, L = _i(o, Mwe), W = et.useContext(Ug), se = W.controlId;
  h = Nc(h, "form-label");
  var J = "col-form-label";
  typeof y == "string" && (J = J + " " + J + "-" + y);
  var be = ns(_, h, k && "sr-only", y && J);
  return D = D || se, y ? /* @__PURE__ */ Ve.createElement(ype, qr({
    ref: r,
    as: "label",
    className: be,
    htmlFor: D
  }, L)) : (
    // eslint-disable-next-line jsx-a11y/label-has-for, jsx-a11y/label-has-associated-control
    /* @__PURE__ */ Ve.createElement(u, qr({
      ref: r,
      className: be,
      htmlFor: D
    }, L))
  );
});
Ose.displayName = "FormLabel";
Ose.defaultProps = Iwe;
var Fwe = ["bsPrefix", "className", "as", "muted"], Spe = /* @__PURE__ */ Ve.forwardRef(
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  function(o, r) {
    var i = o.bsPrefix, u = o.className, h = o.as, y = h === void 0 ? "small" : h, k = o.muted, _ = _i(o, Fwe);
    return i = Nc(i, "form-text"), /* @__PURE__ */ Ve.createElement(y, qr({}, _, {
      ref: r,
      className: ns(u, i, k && "text-muted")
    }));
  }
);
Spe.displayName = "FormText";
var Pj = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  return /* @__PURE__ */ Ve.createElement(Hk, qr({}, o, {
    ref: r,
    type: "switch"
  }));
});
Pj.displayName = "Switch";
Pj.Input = Hk.Input;
Pj.Label = Hk.Label;
var Bwe = ["bsPrefix", "inline", "className", "validated", "as"], $we = xwe("form-row"), Lwe = {
  inline: !1
}, ji = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.bsPrefix, u = o.inline, h = o.className, y = o.validated, k = o.as, _ = k === void 0 ? "form" : k, D = _i(o, Bwe);
  return i = Nc(i, "form"), /* @__PURE__ */ Ve.createElement(_, qr({}, D, {
    ref: r,
    className: ns(h, y && "was-validated", u && i + "-inline")
  }));
});
ji.displayName = "Form";
ji.defaultProps = Lwe;
ji.Row = $we;
ji.Group = Cpe;
ji.Control = wpe;
ji.Check = Hk;
ji.File = Aj;
ji.Switch = Pj;
ji.Label = Ose;
ji.Text = Spe;
function yw(o) {
  return typeof o == "string" || o instanceof String;
}
function Gce(o) {
  var r;
  return typeof o == "object" && o != null && (o == null || (r = o.constructor) == null ? void 0 : r.name) === "Object";
}
function kpe(o, r) {
  return Array.isArray(r) ? kpe(o, (i, u) => r.includes(u)) : Object.entries(o).reduce((i, u) => {
    let [h, y] = u;
    return r(y, h) && (i[h] = y), i;
  }, {});
}
const Dr = {
  NONE: "NONE",
  LEFT: "LEFT",
  FORCE_LEFT: "FORCE_LEFT",
  RIGHT: "RIGHT",
  FORCE_RIGHT: "FORCE_RIGHT"
};
function Hwe(o) {
  switch (o) {
    case Dr.LEFT:
      return Dr.FORCE_LEFT;
    case Dr.RIGHT:
      return Dr.FORCE_RIGHT;
    default:
      return o;
  }
}
function $te(o) {
  return o.replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1");
}
function VV(o, r) {
  if (r === o) return !0;
  const i = Array.isArray(r), u = Array.isArray(o);
  let h;
  if (i && u) {
    if (r.length != o.length) return !1;
    for (h = 0; h < r.length; h++) if (!VV(r[h], o[h])) return !1;
    return !0;
  }
  if (i != u) return !1;
  if (r && o && typeof r == "object" && typeof o == "object") {
    const y = r instanceof Date, k = o instanceof Date;
    if (y && k) return r.getTime() == o.getTime();
    if (y != k) return !1;
    const _ = r instanceof RegExp, D = o instanceof RegExp;
    if (_ && D) return r.toString() == o.toString();
    if (_ != D) return !1;
    const L = Object.keys(r);
    for (h = 0; h < L.length; h++) if (!Object.prototype.hasOwnProperty.call(o, L[h])) return !1;
    for (h = 0; h < L.length; h++) if (!VV(o[L[h]], r[L[h]])) return !1;
    return !0;
  } else if (r && o && typeof r == "function" && typeof o == "function")
    return r.toString() === o.toString();
  return !1;
}
class zwe {
  /** Current input value */
  /** Current cursor position */
  /** Old input value */
  /** Old selection */
  constructor(r) {
    for (Object.assign(this, r); this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos); )
      --this.oldSelection.start;
    if (this.insertedCount)
      for (; this.value.slice(this.cursorPos) !== this.oldValue.slice(this.oldSelection.end); )
        this.value.length - this.cursorPos < this.oldValue.length - this.oldSelection.end ? ++this.oldSelection.end : ++this.cursorPos;
  }
  /** Start changing position */
  get startChangePos() {
    return Math.min(this.cursorPos, this.oldSelection.start);
  }
  /** Inserted symbols count */
  get insertedCount() {
    return this.cursorPos - this.startChangePos;
  }
  /** Inserted symbols */
  get inserted() {
    return this.value.substr(this.startChangePos, this.insertedCount);
  }
  /** Removed symbols count */
  get removedCount() {
    return Math.max(this.oldSelection.end - this.startChangePos || // for Delete
    this.oldValue.length - this.value.length, 0);
  }
  /** Removed symbols */
  get removed() {
    return this.oldValue.substr(this.startChangePos, this.removedCount);
  }
  /** Unchanged head symbols */
  get head() {
    return this.value.substring(0, this.startChangePos);
  }
  /** Unchanged tail symbols */
  get tail() {
    return this.value.substring(this.startChangePos + this.insertedCount);
  }
  /** Remove direction */
  get removeDirection() {
    return !this.removedCount || this.insertedCount ? Dr.NONE : (this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos) && // if not range removed (event with backspace)
    this.oldSelection.end === this.oldSelection.start ? Dr.RIGHT : Dr.LEFT;
  }
}
function us(o, r) {
  return new us.InputMask(o, r);
}
function _pe(o) {
  if (o == null) throw new Error("mask property should be defined");
  return o instanceof RegExp ? us.MaskedRegExp : yw(o) ? us.MaskedPattern : o === Date ? us.MaskedDate : o === Number ? us.MaskedNumber : Array.isArray(o) || o === Array ? us.MaskedDynamic : us.Masked && o.prototype instanceof us.Masked ? o : us.Masked && o instanceof us.Masked ? o.constructor : o instanceof Function ? us.MaskedFunction : (console.warn("Mask not found for mask", o), us.Masked);
}
function E5(o) {
  if (!o) throw new Error("Options in not defined");
  if (us.Masked) {
    if (o.prototype instanceof us.Masked) return {
      mask: o
    };
    const {
      mask: r = void 0,
      ...i
    } = o instanceof us.Masked ? {
      mask: o
    } : Gce(o) && o.mask instanceof us.Masked ? o : {};
    if (r) {
      const u = r.mask;
      return {
        ...kpe(r, (h, y) => !y.startsWith("_")),
        mask: r.constructor,
        _mask: u,
        ...i
      };
    }
  }
  return Gce(o) ? {
    ...o
  } : {
    mask: o
  };
}
function E0(o) {
  if (us.Masked && o instanceof us.Masked) return o;
  const r = E5(o), i = _pe(r.mask);
  if (!i) throw new Error("Masked class is not found for provided mask " + r.mask + ", appropriate module needs to be imported manually before creating mask.");
  return r.mask === i && delete r.mask, r._mask && (r.mask = r._mask, delete r._mask), new i(r);
}
us.createMask = E0;
class Ase {
  /** */
  /** */
  /** */
  /** Safely returns selection start */
  get selectionStart() {
    let r;
    try {
      r = this._unsafeSelectionStart;
    } catch {
    }
    return r ?? this.value.length;
  }
  /** Safely returns selection end */
  get selectionEnd() {
    let r;
    try {
      r = this._unsafeSelectionEnd;
    } catch {
    }
    return r ?? this.value.length;
  }
  /** Safely sets element selection */
  select(r, i) {
    if (!(r == null || i == null || r === this.selectionStart && i === this.selectionEnd))
      try {
        this._unsafeSelect(r, i);
      } catch {
      }
  }
  /** */
  get isActive() {
    return !1;
  }
  /** */
  /** */
  /** */
}
us.MaskElement = Ase;
const qce = 90, Vwe = 89;
class Dj extends Ase {
  /** HTMLElement to use mask on */
  constructor(r) {
    super(), this.input = r, this._onKeydown = this._onKeydown.bind(this), this._onInput = this._onInput.bind(this), this._onBeforeinput = this._onBeforeinput.bind(this), this._onCompositionEnd = this._onCompositionEnd.bind(this);
  }
  get rootElement() {
    var r, i, u;
    return (r = (i = (u = this.input).getRootNode) == null ? void 0 : i.call(u)) != null ? r : document;
  }
  /** Is element in focus */
  get isActive() {
    return this.input === this.rootElement.activeElement;
  }
  /** Binds HTMLElement events to mask internal events */
  bindEvents(r) {
    this.input.addEventListener("keydown", this._onKeydown), this.input.addEventListener("input", this._onInput), this.input.addEventListener("beforeinput", this._onBeforeinput), this.input.addEventListener("compositionend", this._onCompositionEnd), this.input.addEventListener("drop", r.drop), this.input.addEventListener("click", r.click), this.input.addEventListener("focus", r.focus), this.input.addEventListener("blur", r.commit), this._handlers = r;
  }
  _onKeydown(r) {
    if (this._handlers.redo && (r.keyCode === qce && r.shiftKey && (r.metaKey || r.ctrlKey) || r.keyCode === Vwe && r.ctrlKey))
      return r.preventDefault(), this._handlers.redo(r);
    if (this._handlers.undo && r.keyCode === qce && (r.metaKey || r.ctrlKey))
      return r.preventDefault(), this._handlers.undo(r);
    r.isComposing || this._handlers.selectionChange(r);
  }
  _onBeforeinput(r) {
    if (r.inputType === "historyUndo" && this._handlers.undo)
      return r.preventDefault(), this._handlers.undo(r);
    if (r.inputType === "historyRedo" && this._handlers.redo)
      return r.preventDefault(), this._handlers.redo(r);
  }
  _onCompositionEnd(r) {
    this._handlers.input(r);
  }
  _onInput(r) {
    r.isComposing || this._handlers.input(r);
  }
  /** Unbinds HTMLElement events to mask internal events */
  unbindEvents() {
    this.input.removeEventListener("keydown", this._onKeydown), this.input.removeEventListener("input", this._onInput), this.input.removeEventListener("beforeinput", this._onBeforeinput), this.input.removeEventListener("compositionend", this._onCompositionEnd), this.input.removeEventListener("drop", this._handlers.drop), this.input.removeEventListener("click", this._handlers.click), this.input.removeEventListener("focus", this._handlers.focus), this.input.removeEventListener("blur", this._handlers.commit), this._handlers = {};
  }
}
us.HTMLMaskElement = Dj;
class jwe extends Dj {
  /** InputElement to use mask on */
  constructor(r) {
    super(r), this.input = r;
  }
  /** Returns InputElement selection start */
  get _unsafeSelectionStart() {
    return this.input.selectionStart != null ? this.input.selectionStart : this.value.length;
  }
  /** Returns InputElement selection end */
  get _unsafeSelectionEnd() {
    return this.input.selectionEnd;
  }
  /** Sets InputElement selection */
  _unsafeSelect(r, i) {
    this.input.setSelectionRange(r, i);
  }
  get value() {
    return this.input.value;
  }
  set value(r) {
    this.input.value = r;
  }
}
us.HTMLMaskElement = Dj;
class Epe extends Dj {
  /** Returns HTMLElement selection start */
  get _unsafeSelectionStart() {
    const r = this.rootElement, i = r.getSelection && r.getSelection(), u = i && i.anchorOffset, h = i && i.focusOffset;
    return h == null || u == null || u < h ? u : h;
  }
  /** Returns HTMLElement selection end */
  get _unsafeSelectionEnd() {
    const r = this.rootElement, i = r.getSelection && r.getSelection(), u = i && i.anchorOffset, h = i && i.focusOffset;
    return h == null || u == null || u > h ? u : h;
  }
  /** Sets HTMLElement selection */
  _unsafeSelect(r, i) {
    if (!this.rootElement.createRange) return;
    const u = this.rootElement.createRange();
    u.setStart(this.input.firstChild || this.input, r), u.setEnd(this.input.lastChild || this.input, i);
    const h = this.rootElement, y = h.getSelection && h.getSelection();
    y && (y.removeAllRanges(), y.addRange(u));
  }
  /** HTMLElement value */
  get value() {
    return this.input.textContent || "";
  }
  set value(r) {
    this.input.textContent = r;
  }
}
us.HTMLContenteditableMaskElement = Epe;
class Rj {
  constructor() {
    this.states = [], this.currentIndex = 0;
  }
  get currentState() {
    return this.states[this.currentIndex];
  }
  get isEmpty() {
    return this.states.length === 0;
  }
  push(r) {
    this.currentIndex < this.states.length - 1 && (this.states.length = this.currentIndex + 1), this.states.push(r), this.states.length > Rj.MAX_LENGTH && this.states.shift(), this.currentIndex = this.states.length - 1;
  }
  go(r) {
    return this.currentIndex = Math.min(Math.max(this.currentIndex + r, 0), this.states.length - 1), this.currentState;
  }
  undo() {
    return this.go(-1);
  }
  redo() {
    return this.go(1);
  }
  clear() {
    this.states.length = 0, this.currentIndex = 0;
  }
}
Rj.MAX_LENGTH = 100;
class Uwe {
  /**
    View element
  */
  /** Internal {@link Masked} model */
  constructor(r, i) {
    this.el = r instanceof Ase ? r : r.isContentEditable && r.tagName !== "INPUT" && r.tagName !== "TEXTAREA" ? new Epe(r) : new jwe(r), this.masked = E0(i), this._listeners = {}, this._value = "", this._unmaskedValue = "", this._rawInputValue = "", this.history = new Rj(), this._saveSelection = this._saveSelection.bind(this), this._onInput = this._onInput.bind(this), this._onChange = this._onChange.bind(this), this._onDrop = this._onDrop.bind(this), this._onFocus = this._onFocus.bind(this), this._onClick = this._onClick.bind(this), this._onUndo = this._onUndo.bind(this), this._onRedo = this._onRedo.bind(this), this.alignCursor = this.alignCursor.bind(this), this.alignCursorFriendly = this.alignCursorFriendly.bind(this), this._bindEvents(), this.updateValue(), this._onChange();
  }
  maskEquals(r) {
    var i;
    return r == null || ((i = this.masked) == null ? void 0 : i.maskEquals(r));
  }
  /** Masked */
  get mask() {
    return this.masked.mask;
  }
  set mask(r) {
    if (this.maskEquals(r)) return;
    if (!(r instanceof us.Masked) && this.masked.constructor === _pe(r)) {
      this.masked.updateOptions({
        mask: r
      });
      return;
    }
    const i = r instanceof us.Masked ? r : E0({
      mask: r
    });
    i.unmaskedValue = this.masked.unmaskedValue, this.masked = i;
  }
  /** Raw value */
  get value() {
    return this._value;
  }
  set value(r) {
    this.value !== r && (this.masked.value = r, this.updateControl("auto"));
  }
  /** Unmasked value */
  get unmaskedValue() {
    return this._unmaskedValue;
  }
  set unmaskedValue(r) {
    this.unmaskedValue !== r && (this.masked.unmaskedValue = r, this.updateControl("auto"));
  }
  /** Raw input value */
  get rawInputValue() {
    return this._rawInputValue;
  }
  set rawInputValue(r) {
    this.rawInputValue !== r && (this.masked.rawInputValue = r, this.updateControl(), this.alignCursor());
  }
  /** Typed unmasked value */
  get typedValue() {
    return this.masked.typedValue;
  }
  set typedValue(r) {
    this.masked.typedValueEquals(r) || (this.masked.typedValue = r, this.updateControl("auto"));
  }
  /** Display value */
  get displayValue() {
    return this.masked.displayValue;
  }
  /** Starts listening to element events */
  _bindEvents() {
    this.el.bindEvents({
      selectionChange: this._saveSelection,
      input: this._onInput,
      drop: this._onDrop,
      click: this._onClick,
      focus: this._onFocus,
      commit: this._onChange,
      undo: this._onUndo,
      redo: this._onRedo
    });
  }
  /** Stops listening to element events */
  _unbindEvents() {
    this.el && this.el.unbindEvents();
  }
  /** Fires custom event */
  _fireEvent(r, i) {
    const u = this._listeners[r];
    u && u.forEach((h) => h(i));
  }
  /** Current selection start */
  get selectionStart() {
    return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;
  }
  /** Current cursor position */
  get cursorPos() {
    return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;
  }
  set cursorPos(r) {
    !this.el || !this.el.isActive || (this.el.select(r, r), this._saveSelection());
  }
  /** Stores current selection */
  _saveSelection() {
    this.displayValue !== this.el.value && console.warn("Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly."), this._selection = {
      start: this.selectionStart,
      end: this.cursorPos
    };
  }
  /** Syncronizes model value from view */
  updateValue() {
    this.masked.value = this.el.value, this._value = this.masked.value, this._unmaskedValue = this.masked.unmaskedValue, this._rawInputValue = this.masked.rawInputValue;
  }
  /** Syncronizes view from model value, fires change events */
  updateControl(r) {
    const i = this.masked.unmaskedValue, u = this.masked.value, h = this.masked.rawInputValue, y = this.displayValue, k = this.unmaskedValue !== i || this.value !== u || this._rawInputValue !== h;
    this._unmaskedValue = i, this._value = u, this._rawInputValue = h, this.el.value !== y && (this.el.value = y), r === "auto" ? this.alignCursor() : r != null && (this.cursorPos = r), k && this._fireChangeEvents(), !this._historyChanging && (k || this.history.isEmpty) && this.history.push({
      unmaskedValue: i,
      selection: {
        start: this.selectionStart,
        end: this.cursorPos
      }
    });
  }
  /** Updates options with deep equal check, recreates {@link Masked} model if mask type changes */
  updateOptions(r) {
    const {
      mask: i,
      ...u
    } = r, h = !this.maskEquals(i), y = this.masked.optionsIsChanged(u);
    h && (this.mask = i), y && this.masked.updateOptions(u), (h || y) && this.updateControl();
  }
  /** Updates cursor */
  updateCursor(r) {
    r != null && (this.cursorPos = r, this._delayUpdateCursor(r));
  }
  /** Delays cursor update to support mobile browsers */
  _delayUpdateCursor(r) {
    this._abortUpdateCursor(), this._changingCursorPos = r, this._cursorChanging = setTimeout(() => {
      this.el && (this.cursorPos = this._changingCursorPos, this._abortUpdateCursor());
    }, 10);
  }
  /** Fires custom events */
  _fireChangeEvents() {
    this._fireEvent("accept", this._inputEvent), this.masked.isComplete && this._fireEvent("complete", this._inputEvent);
  }
  /** Aborts delayed cursor update */
  _abortUpdateCursor() {
    this._cursorChanging && (clearTimeout(this._cursorChanging), delete this._cursorChanging);
  }
  /** Aligns cursor to nearest available position */
  alignCursor() {
    this.cursorPos = this.masked.nearestInputPos(this.masked.nearestInputPos(this.cursorPos, Dr.LEFT));
  }
  /** Aligns cursor only if selection is empty */
  alignCursorFriendly() {
    this.selectionStart === this.cursorPos && this.alignCursor();
  }
  /** Adds listener on custom event */
  on(r, i) {
    return this._listeners[r] || (this._listeners[r] = []), this._listeners[r].push(i), this;
  }
  /** Removes custom event listener */
  off(r, i) {
    if (!this._listeners[r]) return this;
    if (!i)
      return delete this._listeners[r], this;
    const u = this._listeners[r].indexOf(i);
    return u >= 0 && this._listeners[r].splice(u, 1), this;
  }
  /** Handles view input event */
  _onInput(r) {
    this._inputEvent = r, this._abortUpdateCursor();
    const i = new zwe({
      // new state
      value: this.el.value,
      cursorPos: this.cursorPos,
      // old state
      oldValue: this.displayValue,
      oldSelection: this._selection
    }), u = this.masked.rawInputValue, h = this.masked.splice(i.startChangePos, i.removed.length, i.inserted, i.removeDirection, {
      input: !0,
      raw: !0
    }).offset, y = u === this.masked.rawInputValue ? i.removeDirection : Dr.NONE;
    let k = this.masked.nearestInputPos(i.startChangePos + h, y);
    y !== Dr.NONE && (k = this.masked.nearestInputPos(k, Dr.NONE)), this.updateControl(k), delete this._inputEvent;
  }
  /** Handles view change event and commits model value */
  _onChange() {
    this.displayValue !== this.el.value && this.updateValue(), this.masked.doCommit(), this.updateControl(), this._saveSelection();
  }
  /** Handles view drop event, prevents by default */
  _onDrop(r) {
    r.preventDefault(), r.stopPropagation();
  }
  /** Restore last selection on focus */
  _onFocus(r) {
    this.alignCursorFriendly();
  }
  /** Restore last selection on focus */
  _onClick(r) {
    this.alignCursorFriendly();
  }
  _onUndo() {
    this._applyHistoryState(this.history.undo());
  }
  _onRedo() {
    this._applyHistoryState(this.history.redo());
  }
  _applyHistoryState(r) {
    r && (this._historyChanging = !0, this.unmaskedValue = r.unmaskedValue, this.el.select(r.selection.start, r.selection.end), this._saveSelection(), this._historyChanging = !1);
  }
  /** Unbind view events and removes element reference */
  destroy() {
    this._unbindEvents(), this._listeners.length = 0, delete this.el;
  }
}
us.InputMask = Uwe;
class Hs {
  /** Inserted symbols */
  /** Additional offset if any changes occurred before tail */
  /** Raw inserted is used by dynamic mask */
  /** Can skip chars */
  static normalize(r) {
    return Array.isArray(r) ? r : [r, new Hs()];
  }
  constructor(r) {
    Object.assign(this, {
      inserted: "",
      rawInserted: "",
      tailShift: 0,
      skip: !1
    }, r);
  }
  /** Aggregate changes */
  aggregate(r) {
    return this.inserted += r.inserted, this.rawInserted += r.rawInserted, this.tailShift += r.tailShift, this.skip = this.skip || r.skip, this;
  }
  /** Total offset considering all changes */
  get offset() {
    return this.tailShift + this.inserted.length;
  }
  get consumed() {
    return !!this.rawInserted || this.skip;
  }
  equals(r) {
    return this.inserted === r.inserted && this.tailShift === r.tailShift && this.rawInserted === r.rawInserted && this.skip === r.skip;
  }
}
us.ChangeDetails = Hs;
class gv {
  /** Tail value as string */
  /** Tail start position */
  /** Start position */
  constructor(r, i, u) {
    r === void 0 && (r = ""), i === void 0 && (i = 0), this.value = r, this.from = i, this.stop = u;
  }
  toString() {
    return this.value;
  }
  extend(r) {
    this.value += String(r);
  }
  appendTo(r) {
    return r.append(this.toString(), {
      tail: !0
    }).aggregate(r._appendPlaceholder());
  }
  get state() {
    return {
      value: this.value,
      from: this.from,
      stop: this.stop
    };
  }
  set state(r) {
    Object.assign(this, r);
  }
  unshift(r) {
    if (!this.value.length || r != null && this.from >= r) return "";
    const i = this.value[0];
    return this.value = this.value.slice(1), i;
  }
  shift() {
    if (!this.value.length) return "";
    const r = this.value[this.value.length - 1];
    return this.value = this.value.slice(0, -1), r;
  }
}
class Vd {
  /** */
  /** */
  /** Transforms value before mask processing */
  /** Transforms each char before mask processing */
  /** Validates if value is acceptable */
  /** Does additional processing at the end of editing */
  /** Format typed value to string */
  /** Parse string to get typed value */
  /** Enable characters overwriting */
  /** */
  /** */
  /** */
  /** */
  constructor(r) {
    this._value = "", this._update({
      ...Vd.DEFAULTS,
      ...r
    }), this._initialized = !0;
  }
  /** Sets and applies new options */
  updateOptions(r) {
    this.optionsIsChanged(r) && this.withValueRefresh(this._update.bind(this, r));
  }
  /** Sets new options */
  _update(r) {
    Object.assign(this, r);
  }
  /** Mask state */
  get state() {
    return {
      _value: this.value,
      _rawInputValue: this.rawInputValue
    };
  }
  set state(r) {
    this._value = r._value;
  }
  /** Resets value */
  reset() {
    this._value = "";
  }
  get value() {
    return this._value;
  }
  set value(r) {
    this.resolve(r, {
      input: !0
    });
  }
  /** Resolve new value */
  resolve(r, i) {
    i === void 0 && (i = {
      input: !0
    }), this.reset(), this.append(r, i, ""), this.doCommit();
  }
  get unmaskedValue() {
    return this.value;
  }
  set unmaskedValue(r) {
    this.resolve(r, {});
  }
  get typedValue() {
    return this.parse ? this.parse(this.value, this) : this.unmaskedValue;
  }
  set typedValue(r) {
    this.format ? this.value = this.format(r, this) : this.unmaskedValue = String(r);
  }
  /** Value that includes raw user input */
  get rawInputValue() {
    return this.extractInput(0, this.displayValue.length, {
      raw: !0
    });
  }
  set rawInputValue(r) {
    this.resolve(r, {
      raw: !0
    });
  }
  get displayValue() {
    return this.value;
  }
  get isComplete() {
    return !0;
  }
  get isFilled() {
    return this.isComplete;
  }
  /** Finds nearest input position in direction */
  nearestInputPos(r, i) {
    return r;
  }
  totalInputPositions(r, i) {
    return r === void 0 && (r = 0), i === void 0 && (i = this.displayValue.length), Math.min(this.displayValue.length, i - r);
  }
  /** Extracts value in range considering flags */
  extractInput(r, i, u) {
    return r === void 0 && (r = 0), i === void 0 && (i = this.displayValue.length), this.displayValue.slice(r, i);
  }
  /** Extracts tail in range */
  extractTail(r, i) {
    return r === void 0 && (r = 0), i === void 0 && (i = this.displayValue.length), new gv(this.extractInput(r, i), r);
  }
  /** Appends tail */
  appendTail(r) {
    return yw(r) && (r = new gv(String(r))), r.appendTo(this);
  }
  /** Appends char */
  _appendCharRaw(r, i) {
    return r ? (this._value += r, new Hs({
      inserted: r,
      rawInserted: r
    })) : new Hs();
  }
  /** Appends char */
  _appendChar(r, i, u) {
    i === void 0 && (i = {});
    const h = this.state;
    let y;
    if ([r, y] = this.doPrepareChar(r, i), r && (y = y.aggregate(this._appendCharRaw(r, i)), !y.rawInserted && this.autofix === "pad")) {
      const k = this.state;
      this.state = h;
      let _ = this.pad(i);
      const D = this._appendCharRaw(r, i);
      _ = _.aggregate(D), D.rawInserted || _.equals(y) ? y = _ : this.state = k;
    }
    if (y.inserted) {
      let k, _ = this.doValidate(i) !== !1;
      if (_ && u != null) {
        const D = this.state;
        if (this.overwrite === !0) {
          k = u.state;
          for (let W = 0; W < y.rawInserted.length; ++W)
            u.unshift(this.displayValue.length - y.tailShift);
        }
        let L = this.appendTail(u);
        if (_ = L.rawInserted.length === u.toString().length, !(_ && L.inserted) && this.overwrite === "shift") {
          this.state = D, k = u.state;
          for (let W = 0; W < y.rawInserted.length; ++W)
            u.shift();
          L = this.appendTail(u), _ = L.rawInserted.length === u.toString().length;
        }
        _ && L.inserted && (this.state = D);
      }
      _ || (y = new Hs(), this.state = h, u && k && (u.state = k));
    }
    return y;
  }
  /** Appends optional placeholder at the end */
  _appendPlaceholder() {
    return new Hs();
  }
  /** Appends optional eager placeholder at the end */
  _appendEager() {
    return new Hs();
  }
  /** Appends symbols considering flags */
  append(r, i, u) {
    if (!yw(r)) throw new Error("value should be string");
    const h = yw(u) ? new gv(String(u)) : u;
    i != null && i.tail && (i._beforeTailState = this.state);
    let y;
    [r, y] = this.doPrepare(r, i);
    for (let k = 0; k < r.length; ++k) {
      const _ = this._appendChar(r[k], i, h);
      if (!_.rawInserted && !this.doSkipInvalid(r[k], i, h)) break;
      y.aggregate(_);
    }
    return (this.eager === !0 || this.eager === "append") && i != null && i.input && r && y.aggregate(this._appendEager()), h != null && (y.tailShift += this.appendTail(h).tailShift), y;
  }
  remove(r, i) {
    return r === void 0 && (r = 0), i === void 0 && (i = this.displayValue.length), this._value = this.displayValue.slice(0, r) + this.displayValue.slice(i), new Hs();
  }
  /** Calls function and reapplies current value */
  withValueRefresh(r) {
    if (this._refreshing || !this._initialized) return r();
    this._refreshing = !0;
    const i = this.rawInputValue, u = this.value, h = r();
    return this.rawInputValue = i, this.value && this.value !== u && u.indexOf(this.value) === 0 && (this.append(u.slice(this.displayValue.length), {}, ""), this.doCommit()), delete this._refreshing, h;
  }
  runIsolated(r) {
    if (this._isolated || !this._initialized) return r(this);
    this._isolated = !0;
    const i = this.state, u = r(this);
    return this.state = i, delete this._isolated, u;
  }
  doSkipInvalid(r, i, u) {
    return !!this.skipInvalid;
  }
  /** Prepares string before mask processing */
  doPrepare(r, i) {
    return i === void 0 && (i = {}), Hs.normalize(this.prepare ? this.prepare(r, this, i) : r);
  }
  /** Prepares each char before mask processing */
  doPrepareChar(r, i) {
    return i === void 0 && (i = {}), Hs.normalize(this.prepareChar ? this.prepareChar(r, this, i) : r);
  }
  /** Validates if value is acceptable */
  doValidate(r) {
    return (!this.validate || this.validate(this.value, this, r)) && (!this.parent || this.parent.doValidate(r));
  }
  /** Does additional processing at the end of editing */
  doCommit() {
    this.commit && this.commit(this.value, this);
  }
  splice(r, i, u, h, y) {
    u === void 0 && (u = ""), h === void 0 && (h = Dr.NONE), y === void 0 && (y = {
      input: !0
    });
    const k = r + i, _ = this.extractTail(k), D = this.eager === !0 || this.eager === "remove";
    let L;
    D && (h = Hwe(h), L = this.extractInput(0, k, {
      raw: !0
    }));
    let W = r;
    const se = new Hs();
    if (h !== Dr.NONE && (W = this.nearestInputPos(r, i > 1 && r !== 0 && !D ? Dr.NONE : h), se.tailShift = W - r), se.aggregate(this.remove(W)), D && h !== Dr.NONE && L === this.rawInputValue)
      if (h === Dr.FORCE_LEFT) {
        let J;
        for (; L === this.rawInputValue && (J = this.displayValue.length); )
          se.aggregate(new Hs({
            tailShift: -1
          })).aggregate(this.remove(J - 1));
      } else h === Dr.FORCE_RIGHT && _.unshift();
    return se.aggregate(this.append(u, y, _));
  }
  maskEquals(r) {
    return this.mask === r;
  }
  optionsIsChanged(r) {
    return !VV(this, r);
  }
  typedValueEquals(r) {
    const i = this.typedValue;
    return r === i || Vd.EMPTY_VALUES.includes(r) && Vd.EMPTY_VALUES.includes(i) || (this.format ? this.format(r, this) === this.format(this.typedValue, this) : !1);
  }
  pad(r) {
    return new Hs();
  }
}
Vd.DEFAULTS = {
  skipInvalid: !0
};
Vd.EMPTY_VALUES = [void 0, null, ""];
us.Masked = Vd;
class Sk {
  /** */
  constructor(r, i) {
    r === void 0 && (r = []), i === void 0 && (i = 0), this.chunks = r, this.from = i;
  }
  toString() {
    return this.chunks.map(String).join("");
  }
  extend(r) {
    if (!String(r)) return;
    r = yw(r) ? new gv(String(r)) : r;
    const i = this.chunks[this.chunks.length - 1], u = i && // if stops are same or tail has no stop
    (i.stop === r.stop || r.stop == null) && // if tail chunk goes just after last chunk
    r.from === i.from + i.toString().length;
    if (r instanceof gv)
      u ? i.extend(r.toString()) : this.chunks.push(r);
    else if (r instanceof Sk) {
      if (r.stop == null) {
        let h;
        for (; r.chunks.length && r.chunks[0].stop == null; )
          h = r.chunks.shift(), h.from += r.from, this.extend(h);
      }
      r.toString() && (r.stop = r.blockIndex, this.chunks.push(r));
    }
  }
  appendTo(r) {
    if (!(r instanceof us.MaskedPattern))
      return new gv(this.toString()).appendTo(r);
    const i = new Hs();
    for (let u = 0; u < this.chunks.length; ++u) {
      const h = this.chunks[u], y = r._mapPosToBlock(r.displayValue.length), k = h.stop;
      let _;
      if (k != null && // if block not found or stop is behind lastBlock
      (!y || y.index <= k) && ((h instanceof Sk || // for continuous block also check if stop is exist
      r._stops.indexOf(k) >= 0) && i.aggregate(r._appendPlaceholder(k)), _ = h instanceof Sk && r._blocks[k]), _) {
        const D = _.appendTail(h);
        i.aggregate(D);
        const L = h.toString().slice(D.rawInserted.length);
        L && i.aggregate(r.append(L, {
          tail: !0
        }));
      } else
        i.aggregate(r.append(h.toString(), {
          tail: !0
        }));
    }
    return i;
  }
  get state() {
    return {
      chunks: this.chunks.map((r) => r.state),
      from: this.from,
      stop: this.stop,
      blockIndex: this.blockIndex
    };
  }
  set state(r) {
    const {
      chunks: i,
      ...u
    } = r;
    Object.assign(this, u), this.chunks = i.map((h) => {
      const y = "chunks" in h ? new Sk() : new gv();
      return y.state = h, y;
    });
  }
  unshift(r) {
    if (!this.chunks.length || r != null && this.from >= r) return "";
    const i = r != null ? r - this.from : r;
    let u = 0;
    for (; u < this.chunks.length; ) {
      const h = this.chunks[u], y = h.unshift(i);
      if (h.toString()) {
        if (!y) break;
        ++u;
      } else
        this.chunks.splice(u, 1);
      if (y) return y;
    }
    return "";
  }
  shift() {
    if (!this.chunks.length) return "";
    let r = this.chunks.length - 1;
    for (; 0 <= r; ) {
      const i = this.chunks[r], u = i.shift();
      if (i.toString()) {
        if (!u) break;
        --r;
      } else
        this.chunks.splice(r, 1);
      if (u) return u;
    }
    return "";
  }
}
class Wwe {
  constructor(r, i) {
    this.masked = r, this._log = [];
    const {
      offset: u,
      index: h
    } = r._mapPosToBlock(i) || (i < 0 ? (
      // first
      {
        index: 0,
        offset: 0
      }
    ) : (
      // last
      {
        index: this.masked._blocks.length,
        offset: 0
      }
    ));
    this.offset = u, this.index = h, this.ok = !1;
  }
  get block() {
    return this.masked._blocks[this.index];
  }
  get pos() {
    return this.masked._blockStartPos(this.index) + this.offset;
  }
  get state() {
    return {
      index: this.index,
      offset: this.offset,
      ok: this.ok
    };
  }
  set state(r) {
    Object.assign(this, r);
  }
  pushState() {
    this._log.push(this.state);
  }
  popState() {
    const r = this._log.pop();
    return r && (this.state = r), r;
  }
  bindBlock() {
    this.block || (this.index < 0 && (this.index = 0, this.offset = 0), this.index >= this.masked._blocks.length && (this.index = this.masked._blocks.length - 1, this.offset = this.block.displayValue.length));
  }
  _pushLeft(r) {
    for (this.pushState(), this.bindBlock(); 0 <= this.index; --this.index, this.offset = ((i = this.block) == null ? void 0 : i.displayValue.length) || 0) {
      var i;
      if (r()) return this.ok = !0;
    }
    return this.ok = !1;
  }
  _pushRight(r) {
    for (this.pushState(), this.bindBlock(); this.index < this.masked._blocks.length; ++this.index, this.offset = 0)
      if (r()) return this.ok = !0;
    return this.ok = !1;
  }
  pushLeftBeforeFilled() {
    return this._pushLeft(() => {
      if (!(this.block.isFixed || !this.block.value) && (this.offset = this.block.nearestInputPos(this.offset, Dr.FORCE_LEFT), this.offset !== 0))
        return !0;
    });
  }
  pushLeftBeforeInput() {
    return this._pushLeft(() => {
      if (!this.block.isFixed)
        return this.offset = this.block.nearestInputPos(this.offset, Dr.LEFT), !0;
    });
  }
  pushLeftBeforeRequired() {
    return this._pushLeft(() => {
      if (!(this.block.isFixed || this.block.isOptional && !this.block.value))
        return this.offset = this.block.nearestInputPos(this.offset, Dr.LEFT), !0;
    });
  }
  pushRightBeforeFilled() {
    return this._pushRight(() => {
      if (!(this.block.isFixed || !this.block.value) && (this.offset = this.block.nearestInputPos(this.offset, Dr.FORCE_RIGHT), this.offset !== this.block.value.length))
        return !0;
    });
  }
  pushRightBeforeInput() {
    return this._pushRight(() => {
      if (!this.block.isFixed)
        return this.offset = this.block.nearestInputPos(this.offset, Dr.NONE), !0;
    });
  }
  pushRightBeforeRequired() {
    return this._pushRight(() => {
      if (!(this.block.isFixed || this.block.isOptional && !this.block.value))
        return this.offset = this.block.nearestInputPos(this.offset, Dr.NONE), !0;
    });
  }
}
class Tpe {
  /** */
  /** */
  /** */
  /** */
  /** */
  /** */
  constructor(r) {
    Object.assign(this, r), this._value = "", this.isFixed = !0;
  }
  get value() {
    return this._value;
  }
  get unmaskedValue() {
    return this.isUnmasking ? this.value : "";
  }
  get rawInputValue() {
    return this._isRawInput ? this.value : "";
  }
  get displayValue() {
    return this.value;
  }
  reset() {
    this._isRawInput = !1, this._value = "";
  }
  remove(r, i) {
    return r === void 0 && (r = 0), i === void 0 && (i = this._value.length), this._value = this._value.slice(0, r) + this._value.slice(i), this._value || (this._isRawInput = !1), new Hs();
  }
  nearestInputPos(r, i) {
    i === void 0 && (i = Dr.NONE);
    const u = 0, h = this._value.length;
    switch (i) {
      case Dr.LEFT:
      case Dr.FORCE_LEFT:
        return u;
      case Dr.NONE:
      case Dr.RIGHT:
      case Dr.FORCE_RIGHT:
      default:
        return h;
    }
  }
  totalInputPositions(r, i) {
    return r === void 0 && (r = 0), i === void 0 && (i = this._value.length), this._isRawInput ? i - r : 0;
  }
  extractInput(r, i, u) {
    return r === void 0 && (r = 0), i === void 0 && (i = this._value.length), u === void 0 && (u = {}), u.raw && this._isRawInput && this._value.slice(r, i) || "";
  }
  get isComplete() {
    return !0;
  }
  get isFilled() {
    return !!this._value;
  }
  _appendChar(r, i) {
    if (i === void 0 && (i = {}), this.isFilled) return new Hs();
    const u = this.eager === !0 || this.eager === "append", y = this.char === r && (this.isUnmasking || i.input || i.raw) && (!i.raw || !u) && !i.tail, k = new Hs({
      inserted: this.char,
      rawInserted: y ? this.char : ""
    });
    return this._value = this.char, this._isRawInput = y && (i.raw || i.input), k;
  }
  _appendEager() {
    return this._appendChar(this.char, {
      tail: !0
    });
  }
  _appendPlaceholder() {
    const r = new Hs();
    return this.isFilled || (this._value = r.inserted = this.char), r;
  }
  extractTail() {
    return new gv("");
  }
  appendTail(r) {
    return yw(r) && (r = new gv(String(r))), r.appendTo(this);
  }
  append(r, i, u) {
    const h = this._appendChar(r[0], i);
    return u != null && (h.tailShift += this.appendTail(u).tailShift), h;
  }
  doCommit() {
  }
  get state() {
    return {
      _value: this._value,
      _rawInputValue: this.rawInputValue
    };
  }
  set state(r) {
    this._value = r._value, this._isRawInput = !!r._rawInputValue;
  }
  pad(r) {
    return this._appendPlaceholder();
  }
}
class jV {
  /** */
  /** */
  /** */
  /** */
  /** */
  /** */
  /** */
  /** */
  constructor(r) {
    const {
      parent: i,
      isOptional: u,
      placeholderChar: h,
      displayChar: y,
      lazy: k,
      eager: _,
      ...D
    } = r;
    this.masked = E0(D), Object.assign(this, {
      parent: i,
      isOptional: u,
      placeholderChar: h,
      displayChar: y,
      lazy: k,
      eager: _
    });
  }
  reset() {
    this.isFilled = !1, this.masked.reset();
  }
  remove(r, i) {
    return r === void 0 && (r = 0), i === void 0 && (i = this.value.length), r === 0 && i >= 1 ? (this.isFilled = !1, this.masked.remove(r, i)) : new Hs();
  }
  get value() {
    return this.masked.value || (this.isFilled && !this.isOptional ? this.placeholderChar : "");
  }
  get unmaskedValue() {
    return this.masked.unmaskedValue;
  }
  get rawInputValue() {
    return this.masked.rawInputValue;
  }
  get displayValue() {
    return this.masked.value && this.displayChar || this.value;
  }
  get isComplete() {
    return !!this.masked.value || this.isOptional;
  }
  _appendChar(r, i) {
    if (i === void 0 && (i = {}), this.isFilled) return new Hs();
    const u = this.masked.state;
    let h = this.masked._appendChar(r, this.currentMaskFlags(i));
    return h.inserted && this.doValidate(i) === !1 && (h = new Hs(), this.masked.state = u), !h.inserted && !this.isOptional && !this.lazy && !i.input && (h.inserted = this.placeholderChar), h.skip = !h.inserted && !this.isOptional, this.isFilled = !!h.inserted, h;
  }
  append(r, i, u) {
    return this.masked.append(r, this.currentMaskFlags(i), u);
  }
  _appendPlaceholder() {
    return this.isFilled || this.isOptional ? new Hs() : (this.isFilled = !0, new Hs({
      inserted: this.placeholderChar
    }));
  }
  _appendEager() {
    return new Hs();
  }
  extractTail(r, i) {
    return this.masked.extractTail(r, i);
  }
  appendTail(r) {
    return this.masked.appendTail(r);
  }
  extractInput(r, i, u) {
    return r === void 0 && (r = 0), i === void 0 && (i = this.value.length), this.masked.extractInput(r, i, u);
  }
  nearestInputPos(r, i) {
    i === void 0 && (i = Dr.NONE);
    const u = 0, h = this.value.length, y = Math.min(Math.max(r, u), h);
    switch (i) {
      case Dr.LEFT:
      case Dr.FORCE_LEFT:
        return this.isComplete ? y : u;
      case Dr.RIGHT:
      case Dr.FORCE_RIGHT:
        return this.isComplete ? y : h;
      case Dr.NONE:
      default:
        return y;
    }
  }
  totalInputPositions(r, i) {
    return r === void 0 && (r = 0), i === void 0 && (i = this.value.length), this.value.slice(r, i).length;
  }
  doValidate(r) {
    return this.masked.doValidate(this.currentMaskFlags(r)) && (!this.parent || this.parent.doValidate(this.currentMaskFlags(r)));
  }
  doCommit() {
    this.masked.doCommit();
  }
  get state() {
    return {
      _value: this.value,
      _rawInputValue: this.rawInputValue,
      masked: this.masked.state,
      isFilled: this.isFilled
    };
  }
  set state(r) {
    this.masked.state = r.masked, this.isFilled = r.isFilled;
  }
  currentMaskFlags(r) {
    var i;
    return {
      ...r,
      _beforeTailState: (r == null || (i = r._beforeTailState) == null ? void 0 : i.masked) || (r == null ? void 0 : r._beforeTailState)
    };
  }
  pad(r) {
    return new Hs();
  }
}
jV.DEFAULT_DEFINITIONS = {
  0: /\d/,
  a: /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
  // http://stackoverflow.com/a/22075070
  "*": /./
};
class Zwe extends Vd {
  /** */
  /** Enable characters overwriting */
  /** */
  /** */
  /** */
  updateOptions(r) {
    super.updateOptions(r);
  }
  _update(r) {
    const i = r.mask;
    i && (r.validate = (u) => u.search(i) >= 0), super._update(r);
  }
}
us.MaskedRegExp = Zwe;
class jd extends Vd {
  /** */
  /** */
  /** Single char for empty input */
  /** Single char for filled input */
  /** Show placeholder only when needed */
  /** Enable characters overwriting */
  /** */
  /** */
  /** */
  constructor(r) {
    super({
      ...jd.DEFAULTS,
      ...r,
      definitions: Object.assign({}, jV.DEFAULT_DEFINITIONS, r == null ? void 0 : r.definitions)
    });
  }
  updateOptions(r) {
    super.updateOptions(r);
  }
  _update(r) {
    r.definitions = Object.assign({}, this.definitions, r.definitions), super._update(r), this._rebuildMask();
  }
  _rebuildMask() {
    const r = this.definitions;
    this._blocks = [], this.exposeBlock = void 0, this._stops = [], this._maskedBlocks = {};
    const i = this.mask;
    if (!i || !r) return;
    let u = !1, h = !1;
    for (let y = 0; y < i.length; ++y) {
      if (this.blocks) {
        const L = i.slice(y), W = Object.keys(this.blocks).filter((J) => L.indexOf(J) === 0);
        W.sort((J, be) => be.length - J.length);
        const se = W[0];
        if (se) {
          const {
            expose: J,
            repeat: be,
            ...ke
          } = E5(this.blocks[se]), Ce = {
            lazy: this.lazy,
            eager: this.eager,
            placeholderChar: this.placeholderChar,
            displayChar: this.displayChar,
            overwrite: this.overwrite,
            autofix: this.autofix,
            ...ke,
            repeat: be,
            parent: this
          }, Q = be != null ? new us.RepeatBlock(
            Ce
            /* TODO */
          ) : E0(Ce);
          Q && (this._blocks.push(Q), J && (this.exposeBlock = Q), this._maskedBlocks[se] || (this._maskedBlocks[se] = []), this._maskedBlocks[se].push(this._blocks.length - 1)), y += se.length - 1;
          continue;
        }
      }
      let k = i[y], _ = k in r;
      if (k === jd.STOP_CHAR) {
        this._stops.push(this._blocks.length);
        continue;
      }
      if (k === "{" || k === "}") {
        u = !u;
        continue;
      }
      if (k === "[" || k === "]") {
        h = !h;
        continue;
      }
      if (k === jd.ESCAPE_CHAR) {
        if (++y, k = i[y], !k) break;
        _ = !1;
      }
      const D = _ ? new jV({
        isOptional: h,
        lazy: this.lazy,
        eager: this.eager,
        placeholderChar: this.placeholderChar,
        displayChar: this.displayChar,
        ...E5(r[k]),
        parent: this
      }) : new Tpe({
        char: k,
        eager: this.eager,
        isUnmasking: u
      });
      this._blocks.push(D);
    }
  }
  get state() {
    return {
      ...super.state,
      _blocks: this._blocks.map((r) => r.state)
    };
  }
  set state(r) {
    if (!r) {
      this.reset();
      return;
    }
    const {
      _blocks: i,
      ...u
    } = r;
    this._blocks.forEach((h, y) => h.state = i[y]), super.state = u;
  }
  reset() {
    super.reset(), this._blocks.forEach((r) => r.reset());
  }
  get isComplete() {
    return this.exposeBlock ? this.exposeBlock.isComplete : this._blocks.every((r) => r.isComplete);
  }
  get isFilled() {
    return this._blocks.every((r) => r.isFilled);
  }
  get isFixed() {
    return this._blocks.every((r) => r.isFixed);
  }
  get isOptional() {
    return this._blocks.every((r) => r.isOptional);
  }
  doCommit() {
    this._blocks.forEach((r) => r.doCommit()), super.doCommit();
  }
  get unmaskedValue() {
    return this.exposeBlock ? this.exposeBlock.unmaskedValue : this._blocks.reduce((r, i) => r += i.unmaskedValue, "");
  }
  set unmaskedValue(r) {
    if (this.exposeBlock) {
      const i = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);
      this.exposeBlock.unmaskedValue = r, this.appendTail(i), this.doCommit();
    } else super.unmaskedValue = r;
  }
  get value() {
    return this.exposeBlock ? this.exposeBlock.value : (
      // TODO return _value when not in change?
      this._blocks.reduce((r, i) => r += i.value, "")
    );
  }
  set value(r) {
    if (this.exposeBlock) {
      const i = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);
      this.exposeBlock.value = r, this.appendTail(i), this.doCommit();
    } else super.value = r;
  }
  get typedValue() {
    return this.exposeBlock ? this.exposeBlock.typedValue : super.typedValue;
  }
  set typedValue(r) {
    if (this.exposeBlock) {
      const i = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);
      this.exposeBlock.typedValue = r, this.appendTail(i), this.doCommit();
    } else super.typedValue = r;
  }
  get displayValue() {
    return this._blocks.reduce((r, i) => r += i.displayValue, "");
  }
  appendTail(r) {
    return super.appendTail(r).aggregate(this._appendPlaceholder());
  }
  _appendEager() {
    var r;
    const i = new Hs();
    let u = (r = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : r.index;
    if (u == null) return i;
    this._blocks[u].isFilled && ++u;
    for (let h = u; h < this._blocks.length; ++h) {
      const y = this._blocks[h]._appendEager();
      if (!y.inserted) break;
      i.aggregate(y);
    }
    return i;
  }
  _appendCharRaw(r, i) {
    i === void 0 && (i = {});
    const u = this._mapPosToBlock(this.displayValue.length), h = new Hs();
    if (!u) return h;
    for (let k = u.index, _; _ = this._blocks[k]; ++k) {
      var y;
      const D = _._appendChar(r, {
        ...i,
        _beforeTailState: (y = i._beforeTailState) == null || (y = y._blocks) == null ? void 0 : y[k]
      });
      if (h.aggregate(D), D.consumed) break;
    }
    return h;
  }
  extractTail(r, i) {
    r === void 0 && (r = 0), i === void 0 && (i = this.displayValue.length);
    const u = new Sk();
    return r === i || this._forEachBlocksInRange(r, i, (h, y, k, _) => {
      const D = h.extractTail(k, _);
      D.stop = this._findStopBefore(y), D.from = this._blockStartPos(y), D instanceof Sk && (D.blockIndex = y), u.extend(D);
    }), u;
  }
  extractInput(r, i, u) {
    if (r === void 0 && (r = 0), i === void 0 && (i = this.displayValue.length), u === void 0 && (u = {}), r === i) return "";
    let h = "";
    return this._forEachBlocksInRange(r, i, (y, k, _, D) => {
      h += y.extractInput(_, D, u);
    }), h;
  }
  _findStopBefore(r) {
    let i;
    for (let u = 0; u < this._stops.length; ++u) {
      const h = this._stops[u];
      if (h <= r) i = h;
      else break;
    }
    return i;
  }
  /** Appends placeholder depending on laziness */
  _appendPlaceholder(r) {
    const i = new Hs();
    if (this.lazy && r == null) return i;
    const u = this._mapPosToBlock(this.displayValue.length);
    if (!u) return i;
    const h = u.index, y = r ?? this._blocks.length;
    return this._blocks.slice(h, y).forEach((k) => {
      if (!k.lazy || r != null) {
        var _;
        i.aggregate(k._appendPlaceholder((_ = k._blocks) == null ? void 0 : _.length));
      }
    }), i;
  }
  /** Finds block in pos */
  _mapPosToBlock(r) {
    let i = "";
    for (let u = 0; u < this._blocks.length; ++u) {
      const h = this._blocks[u], y = i.length;
      if (i += h.displayValue, r <= i.length)
        return {
          index: u,
          offset: r - y
        };
    }
  }
  _blockStartPos(r) {
    return this._blocks.slice(0, r).reduce((i, u) => i += u.displayValue.length, 0);
  }
  _forEachBlocksInRange(r, i, u) {
    i === void 0 && (i = this.displayValue.length);
    const h = this._mapPosToBlock(r);
    if (h) {
      const y = this._mapPosToBlock(i), k = y && h.index === y.index, _ = h.offset, D = y && k ? y.offset : this._blocks[h.index].displayValue.length;
      if (u(this._blocks[h.index], h.index, _, D), y && !k) {
        for (let L = h.index + 1; L < y.index; ++L)
          u(this._blocks[L], L, 0, this._blocks[L].displayValue.length);
        u(this._blocks[y.index], y.index, 0, y.offset);
      }
    }
  }
  remove(r, i) {
    r === void 0 && (r = 0), i === void 0 && (i = this.displayValue.length);
    const u = super.remove(r, i);
    return this._forEachBlocksInRange(r, i, (h, y, k, _) => {
      u.aggregate(h.remove(k, _));
    }), u;
  }
  nearestInputPos(r, i) {
    if (i === void 0 && (i = Dr.NONE), !this._blocks.length) return 0;
    const u = new Wwe(this, r);
    if (i === Dr.NONE)
      return u.pushRightBeforeInput() || (u.popState(), u.pushLeftBeforeInput()) ? u.pos : this.displayValue.length;
    if (i === Dr.LEFT || i === Dr.FORCE_LEFT) {
      if (i === Dr.LEFT) {
        if (u.pushRightBeforeFilled(), u.ok && u.pos === r) return r;
        u.popState();
      }
      if (u.pushLeftBeforeInput(), u.pushLeftBeforeRequired(), u.pushLeftBeforeFilled(), i === Dr.LEFT) {
        if (u.pushRightBeforeInput(), u.pushRightBeforeRequired(), u.ok && u.pos <= r || (u.popState(), u.ok && u.pos <= r)) return u.pos;
        u.popState();
      }
      return u.ok ? u.pos : i === Dr.FORCE_LEFT ? 0 : (u.popState(), u.ok || (u.popState(), u.ok) ? u.pos : 0);
    }
    return i === Dr.RIGHT || i === Dr.FORCE_RIGHT ? (u.pushRightBeforeInput(), u.pushRightBeforeRequired(), u.pushRightBeforeFilled() ? u.pos : i === Dr.FORCE_RIGHT ? this.displayValue.length : (u.popState(), u.ok || (u.popState(), u.ok) ? u.pos : this.nearestInputPos(r, Dr.LEFT))) : r;
  }
  totalInputPositions(r, i) {
    r === void 0 && (r = 0), i === void 0 && (i = this.displayValue.length);
    let u = 0;
    return this._forEachBlocksInRange(r, i, (h, y, k, _) => {
      u += h.totalInputPositions(k, _);
    }), u;
  }
  /** Get block by name */
  maskedBlock(r) {
    return this.maskedBlocks(r)[0];
  }
  /** Get all blocks by name */
  maskedBlocks(r) {
    const i = this._maskedBlocks[r];
    return i ? i.map((u) => this._blocks[u]) : [];
  }
  pad(r) {
    const i = new Hs();
    return this._forEachBlocksInRange(0, this.displayValue.length, (u) => i.aggregate(u.pad(r))), i;
  }
}
jd.DEFAULTS = {
  ...Vd.DEFAULTS,
  lazy: !0,
  placeholderChar: "_"
};
jd.STOP_CHAR = "`";
jd.ESCAPE_CHAR = "\\";
jd.InputDefinition = jV;
jd.FixedDefinition = Tpe;
us.MaskedPattern = jd;
class nV extends jd {
  /**
    Optionally sets max length of pattern.
    Used when pattern length is longer then `to` param length. Pads zeros at start in this case.
  */
  /** Min bound */
  /** Max bound */
  get _matchFrom() {
    return this.maxLength - String(this.from).length;
  }
  constructor(r) {
    super(r);
  }
  updateOptions(r) {
    super.updateOptions(r);
  }
  _update(r) {
    const {
      to: i = this.to || 0,
      from: u = this.from || 0,
      maxLength: h = this.maxLength || 0,
      autofix: y = this.autofix,
      ...k
    } = r;
    this.to = i, this.from = u, this.maxLength = Math.max(String(i).length, h), this.autofix = y;
    const _ = String(this.from).padStart(this.maxLength, "0"), D = String(this.to).padStart(this.maxLength, "0");
    let L = 0;
    for (; L < D.length && D[L] === _[L]; ) ++L;
    k.mask = D.slice(0, L).replace(/0/g, "\\0") + "0".repeat(this.maxLength - L), super._update(k);
  }
  get isComplete() {
    return super.isComplete && !!this.value;
  }
  boundaries(r) {
    let i = "", u = "";
    const [, h, y] = r.match(/^(\D*)(\d*)(\D*)/) || [];
    return y && (i = "0".repeat(h.length) + y, u = "9".repeat(h.length) + y), i = i.padEnd(this.maxLength, "0"), u = u.padEnd(this.maxLength, "9"), [i, u];
  }
  doPrepareChar(r, i) {
    i === void 0 && (i = {});
    let u;
    return [r, u] = super.doPrepareChar(r.replace(/\D/g, ""), i), r || (u.skip = !this.isComplete), [r, u];
  }
  _appendCharRaw(r, i) {
    if (i === void 0 && (i = {}), !this.autofix || this.value.length + 1 > this.maxLength) return super._appendCharRaw(r, i);
    const u = String(this.from).padStart(this.maxLength, "0"), h = String(this.to).padStart(this.maxLength, "0"), [y, k] = this.boundaries(this.value + r);
    return Number(k) < this.from ? super._appendCharRaw(u[this.value.length], i) : Number(y) > this.to ? !i.tail && this.autofix === "pad" && this.value.length + 1 < this.maxLength ? super._appendCharRaw(u[this.value.length], i).aggregate(this._appendCharRaw(r, i)) : super._appendCharRaw(h[this.value.length], i) : super._appendCharRaw(r, i);
  }
  doValidate(r) {
    const i = this.value;
    if (i.search(/[^0]/) === -1 && i.length <= this._matchFrom) return !0;
    const [h, y] = this.boundaries(i);
    return this.from <= Number(y) && Number(h) <= this.to && super.doValidate(r);
  }
  pad(r) {
    const i = new Hs();
    if (this.value.length === this.maxLength) return i;
    const u = this.value, h = this.maxLength - this.value.length;
    if (h) {
      this.reset();
      for (let y = 0; y < h; ++y)
        i.aggregate(super._appendCharRaw("0", r));
      u.split("").forEach((y) => this._appendCharRaw(y));
    }
    return i;
  }
}
us.MaskedRange = nV;
const Gwe = "d{.}`m{.}`Y";
class b0 extends jd {
  static extractPatternOptions(r) {
    const {
      mask: i,
      pattern: u,
      ...h
    } = r;
    return {
      ...h,
      mask: yw(i) ? i : u
    };
  }
  /** Pattern mask for date according to {@link MaskedDate#format} */
  /** Start date */
  /** End date */
  /** Format typed value to string */
  /** Parse string to get typed value */
  constructor(r) {
    super(b0.extractPatternOptions({
      ...b0.DEFAULTS,
      ...r
    }));
  }
  updateOptions(r) {
    super.updateOptions(r);
  }
  _update(r) {
    const {
      mask: i,
      pattern: u,
      blocks: h,
      ...y
    } = {
      ...b0.DEFAULTS,
      ...r
    }, k = Object.assign({}, b0.GET_DEFAULT_BLOCKS());
    r.min && (k.Y.from = r.min.getFullYear()), r.max && (k.Y.to = r.max.getFullYear()), r.min && r.max && k.Y.from === k.Y.to && (k.m.from = r.min.getMonth() + 1, k.m.to = r.max.getMonth() + 1, k.m.from === k.m.to && (k.d.from = r.min.getDate(), k.d.to = r.max.getDate())), Object.assign(k, this.blocks, h), super._update({
      ...y,
      mask: yw(i) ? i : u,
      blocks: k
    });
  }
  doValidate(r) {
    const i = this.date;
    return super.doValidate(r) && (!this.isComplete || this.isDateExist(this.value) && i != null && (this.min == null || this.min <= i) && (this.max == null || i <= this.max));
  }
  /** Checks if date is exists */
  isDateExist(r) {
    return this.format(this.parse(r, this), this).indexOf(r) >= 0;
  }
  /** Parsed Date */
  get date() {
    return this.typedValue;
  }
  set date(r) {
    this.typedValue = r;
  }
  get typedValue() {
    return this.isComplete ? super.typedValue : null;
  }
  set typedValue(r) {
    super.typedValue = r;
  }
  maskEquals(r) {
    return r === Date || super.maskEquals(r);
  }
  optionsIsChanged(r) {
    return super.optionsIsChanged(b0.extractPatternOptions(r));
  }
}
b0.GET_DEFAULT_BLOCKS = () => ({
  d: {
    mask: nV,
    from: 1,
    to: 31,
    maxLength: 2
  },
  m: {
    mask: nV,
    from: 1,
    to: 12,
    maxLength: 2
  },
  Y: {
    mask: nV,
    from: 1900,
    to: 9999
  }
});
b0.DEFAULTS = {
  ...jd.DEFAULTS,
  mask: Date,
  pattern: Gwe,
  format: (o, r) => {
    if (!o) return "";
    const i = String(o.getDate()).padStart(2, "0"), u = String(o.getMonth() + 1).padStart(2, "0"), h = o.getFullYear();
    return [i, u, h].join(".");
  },
  parse: (o, r) => {
    const [i, u, h] = o.split(".").map(Number);
    return new Date(h, u - 1, i);
  }
};
us.MaskedDate = b0;
class Nj extends Vd {
  constructor(r) {
    super({
      ...Nj.DEFAULTS,
      ...r
    }), this.currentMask = void 0;
  }
  updateOptions(r) {
    super.updateOptions(r);
  }
  _update(r) {
    super._update(r), "mask" in r && (this.exposeMask = void 0, this.compiledMasks = Array.isArray(r.mask) ? r.mask.map((i) => {
      const {
        expose: u,
        ...h
      } = E5(i), y = E0({
        overwrite: this._overwrite,
        eager: this._eager,
        skipInvalid: this._skipInvalid,
        ...h
      });
      return u && (this.exposeMask = y), y;
    }) : []);
  }
  _appendCharRaw(r, i) {
    i === void 0 && (i = {});
    const u = this._applyDispatch(r, i);
    return this.currentMask && u.aggregate(this.currentMask._appendChar(r, this.currentMaskFlags(i))), u;
  }
  _applyDispatch(r, i, u) {
    r === void 0 && (r = ""), i === void 0 && (i = {}), u === void 0 && (u = "");
    const h = i.tail && i._beforeTailState != null ? i._beforeTailState._value : this.value, y = this.rawInputValue, k = i.tail && i._beforeTailState != null ? i._beforeTailState._rawInputValue : y, _ = y.slice(k.length), D = this.currentMask, L = new Hs(), W = D == null ? void 0 : D.state;
    return this.currentMask = this.doDispatch(r, {
      ...i
    }, u), this.currentMask && (this.currentMask !== D ? (this.currentMask.reset(), k && (this.currentMask.append(k, {
      raw: !0
    }), L.tailShift = this.currentMask.value.length - h.length), _ && (L.tailShift += this.currentMask.append(_, {
      raw: !0,
      tail: !0
    }).tailShift)) : W && (this.currentMask.state = W)), L;
  }
  _appendPlaceholder() {
    const r = this._applyDispatch();
    return this.currentMask && r.aggregate(this.currentMask._appendPlaceholder()), r;
  }
  _appendEager() {
    const r = this._applyDispatch();
    return this.currentMask && r.aggregate(this.currentMask._appendEager()), r;
  }
  appendTail(r) {
    const i = new Hs();
    return r && i.aggregate(this._applyDispatch("", {}, r)), i.aggregate(this.currentMask ? this.currentMask.appendTail(r) : super.appendTail(r));
  }
  currentMaskFlags(r) {
    var i, u;
    return {
      ...r,
      _beforeTailState: ((i = r._beforeTailState) == null ? void 0 : i.currentMaskRef) === this.currentMask && ((u = r._beforeTailState) == null ? void 0 : u.currentMask) || r._beforeTailState
    };
  }
  doDispatch(r, i, u) {
    return i === void 0 && (i = {}), u === void 0 && (u = ""), this.dispatch(r, this, i, u);
  }
  doValidate(r) {
    return super.doValidate(r) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(r)));
  }
  doPrepare(r, i) {
    i === void 0 && (i = {});
    let [u, h] = super.doPrepare(r, i);
    if (this.currentMask) {
      let y;
      [u, y] = super.doPrepare(u, this.currentMaskFlags(i)), h = h.aggregate(y);
    }
    return [u, h];
  }
  doPrepareChar(r, i) {
    i === void 0 && (i = {});
    let [u, h] = super.doPrepareChar(r, i);
    if (this.currentMask) {
      let y;
      [u, y] = super.doPrepareChar(u, this.currentMaskFlags(i)), h = h.aggregate(y);
    }
    return [u, h];
  }
  reset() {
    var r;
    (r = this.currentMask) == null || r.reset(), this.compiledMasks.forEach((i) => i.reset());
  }
  get value() {
    return this.exposeMask ? this.exposeMask.value : this.currentMask ? this.currentMask.value : "";
  }
  set value(r) {
    this.exposeMask ? (this.exposeMask.value = r, this.currentMask = this.exposeMask, this._applyDispatch()) : super.value = r;
  }
  get unmaskedValue() {
    return this.exposeMask ? this.exposeMask.unmaskedValue : this.currentMask ? this.currentMask.unmaskedValue : "";
  }
  set unmaskedValue(r) {
    this.exposeMask ? (this.exposeMask.unmaskedValue = r, this.currentMask = this.exposeMask, this._applyDispatch()) : super.unmaskedValue = r;
  }
  get typedValue() {
    return this.exposeMask ? this.exposeMask.typedValue : this.currentMask ? this.currentMask.typedValue : "";
  }
  set typedValue(r) {
    if (this.exposeMask) {
      this.exposeMask.typedValue = r, this.currentMask = this.exposeMask, this._applyDispatch();
      return;
    }
    let i = String(r);
    this.currentMask && (this.currentMask.typedValue = r, i = this.currentMask.unmaskedValue), this.unmaskedValue = i;
  }
  get displayValue() {
    return this.currentMask ? this.currentMask.displayValue : "";
  }
  get isComplete() {
    var r;
    return !!((r = this.currentMask) != null && r.isComplete);
  }
  get isFilled() {
    var r;
    return !!((r = this.currentMask) != null && r.isFilled);
  }
  remove(r, i) {
    const u = new Hs();
    return this.currentMask && u.aggregate(this.currentMask.remove(r, i)).aggregate(this._applyDispatch()), u;
  }
  get state() {
    var r;
    return {
      ...super.state,
      _rawInputValue: this.rawInputValue,
      compiledMasks: this.compiledMasks.map((i) => i.state),
      currentMaskRef: this.currentMask,
      currentMask: (r = this.currentMask) == null ? void 0 : r.state
    };
  }
  set state(r) {
    const {
      compiledMasks: i,
      currentMaskRef: u,
      currentMask: h,
      ...y
    } = r;
    i && this.compiledMasks.forEach((k, _) => k.state = i[_]), u != null && (this.currentMask = u, this.currentMask.state = h), super.state = y;
  }
  extractInput(r, i, u) {
    return this.currentMask ? this.currentMask.extractInput(r, i, u) : "";
  }
  extractTail(r, i) {
    return this.currentMask ? this.currentMask.extractTail(r, i) : super.extractTail(r, i);
  }
  doCommit() {
    this.currentMask && this.currentMask.doCommit(), super.doCommit();
  }
  nearestInputPos(r, i) {
    return this.currentMask ? this.currentMask.nearestInputPos(r, i) : super.nearestInputPos(r, i);
  }
  get overwrite() {
    return this.currentMask ? this.currentMask.overwrite : this._overwrite;
  }
  set overwrite(r) {
    this._overwrite = r;
  }
  get eager() {
    return this.currentMask ? this.currentMask.eager : this._eager;
  }
  set eager(r) {
    this._eager = r;
  }
  get skipInvalid() {
    return this.currentMask ? this.currentMask.skipInvalid : this._skipInvalid;
  }
  set skipInvalid(r) {
    this._skipInvalid = r;
  }
  get autofix() {
    return this.currentMask ? this.currentMask.autofix : this._autofix;
  }
  set autofix(r) {
    this._autofix = r;
  }
  maskEquals(r) {
    return Array.isArray(r) ? this.compiledMasks.every((i, u) => {
      if (!r[u]) return;
      const {
        mask: h,
        ...y
      } = r[u];
      return VV(i, y) && i.maskEquals(h);
    }) : super.maskEquals(r);
  }
  typedValueEquals(r) {
    var i;
    return !!((i = this.currentMask) != null && i.typedValueEquals(r));
  }
}
Nj.DEFAULTS = {
  ...Vd.DEFAULTS,
  dispatch: (o, r, i, u) => {
    if (!r.compiledMasks.length) return;
    const h = r.rawInputValue, y = r.compiledMasks.map((k, _) => {
      const D = r.currentMask === k, L = D ? k.displayValue.length : k.nearestInputPos(k.displayValue.length, Dr.FORCE_LEFT);
      return k.rawInputValue !== h ? (k.reset(), k.append(h, {
        raw: !0
      })) : D || k.remove(L), k.append(o, r.currentMaskFlags(i)), k.appendTail(u), {
        index: _,
        weight: k.rawInputValue.length,
        totalInputPositions: k.totalInputPositions(0, Math.max(L, k.nearestInputPos(k.displayValue.length, Dr.FORCE_LEFT)))
      };
    });
    return y.sort((k, _) => _.weight - k.weight || _.totalInputPositions - k.totalInputPositions), r.compiledMasks[y[0].index];
  }
};
us.MaskedDynamic = Nj;
class Mj extends jd {
  constructor(r) {
    super({
      ...Mj.DEFAULTS,
      ...r
    });
  }
  updateOptions(r) {
    super.updateOptions(r);
  }
  _update(r) {
    const {
      enum: i,
      ...u
    } = r;
    if (i) {
      const h = i.map((_) => _.length), y = Math.min(...h), k = Math.max(...h) - y;
      u.mask = "*".repeat(y), k && (u.mask += "[" + "*".repeat(k) + "]"), this.enum = i;
    }
    super._update(u);
  }
  _appendCharRaw(r, i) {
    i === void 0 && (i = {});
    const u = Math.min(this.nearestInputPos(0, Dr.FORCE_RIGHT), this.value.length), h = this.enum.filter((y) => this.matchValue(y, this.unmaskedValue + r, u));
    if (h.length) {
      h.length === 1 && this._forEachBlocksInRange(0, this.value.length, (k, _) => {
        const D = h[0][_];
        _ >= this.value.length || D === k.value || (k.reset(), k._appendChar(D, i));
      });
      const y = super._appendCharRaw(h[0][this.value.length], i);
      return h.length === 1 && h[0].slice(this.unmaskedValue.length).split("").forEach((k) => y.aggregate(super._appendCharRaw(k))), y;
    }
    return new Hs({
      skip: !this.isComplete
    });
  }
  extractTail(r, i) {
    return r === void 0 && (r = 0), i === void 0 && (i = this.displayValue.length), new gv("", r);
  }
  remove(r, i) {
    if (r === void 0 && (r = 0), i === void 0 && (i = this.displayValue.length), r === i) return new Hs();
    const u = Math.min(super.nearestInputPos(0, Dr.FORCE_RIGHT), this.value.length);
    let h;
    for (h = r; h >= 0 && !(this.enum.filter((_) => this.matchValue(_, this.value.slice(u, h), u)).length > 1); --h)
      ;
    const y = super.remove(h, i);
    return y.tailShift += h - r, y;
  }
  get isComplete() {
    return this.enum.indexOf(this.value) >= 0;
  }
}
Mj.DEFAULTS = {
  ...jd.DEFAULTS,
  matchValue: (o, r, i) => o.indexOf(r, i) === i
};
us.MaskedEnum = Mj;
class qwe extends Vd {
  /** */
  /** Enable characters overwriting */
  /** */
  /** */
  /** */
  updateOptions(r) {
    super.updateOptions(r);
  }
  _update(r) {
    super._update({
      ...r,
      validate: r.mask
    });
  }
}
us.MaskedFunction = qwe;
var Ope;
class tp extends Vd {
  /** Single char */
  /** Single char */
  /** Array of single chars */
  /** */
  /** */
  /** Digits after point */
  /** Flag to remove leading and trailing zeros in the end of editing */
  /** Flag to pad trailing zeros after point in the end of editing */
  /** Enable characters overwriting */
  /** */
  /** */
  /** */
  /** Format typed value to string */
  /** Parse string to get typed value */
  constructor(r) {
    super({
      ...tp.DEFAULTS,
      ...r
    });
  }
  updateOptions(r) {
    super.updateOptions(r);
  }
  _update(r) {
    super._update(r), this._updateRegExps();
  }
  _updateRegExps() {
    const r = "^" + (this.allowNegative ? "[+|\\-]?" : ""), i = "\\d*", u = (this.scale ? "(" + $te(this.radix) + "\\d{0," + this.scale + "})?" : "") + "$";
    this._numberRegExp = new RegExp(r + i + u), this._mapToRadixRegExp = new RegExp("[" + this.mapToRadix.map($te).join("") + "]", "g"), this._thousandsSeparatorRegExp = new RegExp($te(this.thousandsSeparator), "g");
  }
  _removeThousandsSeparators(r) {
    return r.replace(this._thousandsSeparatorRegExp, "");
  }
  _insertThousandsSeparators(r) {
    const i = r.split(this.radix);
    return i[0] = i[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator), i.join(this.radix);
  }
  doPrepareChar(r, i) {
    i === void 0 && (i = {});
    const [u, h] = super.doPrepareChar(this._removeThousandsSeparators(this.scale && this.mapToRadix.length && /*
      radix should be mapped when
      1) input is done from keyboard = flags.input && flags.raw
      2) unmasked value is set = !flags.input && !flags.raw
      and should not be mapped when
      1) value is set = flags.input && !flags.raw
      2) raw value is set = !flags.input && flags.raw
    */
    (i.input && i.raw || !i.input && !i.raw) ? r.replace(this._mapToRadixRegExp, this.radix) : r), i);
    return r && !u && (h.skip = !0), u && !this.allowPositive && !this.value && u !== "-" && h.aggregate(this._appendChar("-")), [u, h];
  }
  _separatorsCount(r, i) {
    i === void 0 && (i = !1);
    let u = 0;
    for (let h = 0; h < r; ++h)
      this._value.indexOf(this.thousandsSeparator, h) === h && (++u, i && (r += this.thousandsSeparator.length));
    return u;
  }
  _separatorsCountFromSlice(r) {
    return r === void 0 && (r = this._value), this._separatorsCount(this._removeThousandsSeparators(r).length, !0);
  }
  extractInput(r, i, u) {
    return r === void 0 && (r = 0), i === void 0 && (i = this.displayValue.length), [r, i] = this._adjustRangeWithSeparators(r, i), this._removeThousandsSeparators(super.extractInput(r, i, u));
  }
  _appendCharRaw(r, i) {
    i === void 0 && (i = {});
    const u = i.tail && i._beforeTailState ? i._beforeTailState._value : this._value, h = this._separatorsCountFromSlice(u);
    this._value = this._removeThousandsSeparators(this.value);
    const y = this._value;
    this._value += r;
    const k = this.number;
    let _ = !isNaN(k), D = !1;
    if (_) {
      let J;
      this.min != null && this.min < 0 && this.number < this.min && (J = this.min), this.max != null && this.max > 0 && this.number > this.max && (J = this.max), J != null && (this.autofix ? (this._value = this.format(J, this).replace(tp.UNMASKED_RADIX, this.radix), D || (D = y === this._value && !i.tail)) : _ = !1), _ && (_ = !!this._value.match(this._numberRegExp));
    }
    let L;
    _ ? L = new Hs({
      inserted: this._value.slice(y.length),
      rawInserted: D ? "" : r,
      skip: D
    }) : (this._value = y, L = new Hs()), this._value = this._insertThousandsSeparators(this._value);
    const W = i.tail && i._beforeTailState ? i._beforeTailState._value : this._value, se = this._separatorsCountFromSlice(W);
    return L.tailShift += (se - h) * this.thousandsSeparator.length, L;
  }
  _findSeparatorAround(r) {
    if (this.thousandsSeparator) {
      const i = r - this.thousandsSeparator.length + 1, u = this.value.indexOf(this.thousandsSeparator, i);
      if (u <= r) return u;
    }
    return -1;
  }
  _adjustRangeWithSeparators(r, i) {
    const u = this._findSeparatorAround(r);
    u >= 0 && (r = u);
    const h = this._findSeparatorAround(i);
    return h >= 0 && (i = h + this.thousandsSeparator.length), [r, i];
  }
  remove(r, i) {
    r === void 0 && (r = 0), i === void 0 && (i = this.displayValue.length), [r, i] = this._adjustRangeWithSeparators(r, i);
    const u = this.value.slice(0, r), h = this.value.slice(i), y = this._separatorsCount(u.length);
    this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(u + h));
    const k = this._separatorsCountFromSlice(u);
    return new Hs({
      tailShift: (k - y) * this.thousandsSeparator.length
    });
  }
  nearestInputPos(r, i) {
    if (!this.thousandsSeparator) return r;
    switch (i) {
      case Dr.NONE:
      case Dr.LEFT:
      case Dr.FORCE_LEFT: {
        const u = this._findSeparatorAround(r - 1);
        if (u >= 0) {
          const h = u + this.thousandsSeparator.length;
          if (r < h || this.value.length <= h || i === Dr.FORCE_LEFT)
            return u;
        }
        break;
      }
      case Dr.RIGHT:
      case Dr.FORCE_RIGHT: {
        const u = this._findSeparatorAround(r);
        if (u >= 0)
          return u + this.thousandsSeparator.length;
      }
    }
    return r;
  }
  doCommit() {
    if (this.value) {
      const r = this.number;
      let i = r;
      this.min != null && (i = Math.max(i, this.min)), this.max != null && (i = Math.min(i, this.max)), i !== r && (this.unmaskedValue = this.format(i, this));
      let u = this.value;
      this.normalizeZeros && (u = this._normalizeZeros(u)), this.padFractionalZeros && this.scale > 0 && (u = this._padFractionalZeros(u)), this._value = u;
    }
    super.doCommit();
  }
  _normalizeZeros(r) {
    const i = this._removeThousandsSeparators(r).split(this.radix);
    return i[0] = i[0].replace(/^(\D*)(0*)(\d*)/, (u, h, y, k) => h + k), r.length && !/\d$/.test(i[0]) && (i[0] = i[0] + "0"), i.length > 1 && (i[1] = i[1].replace(/0*$/, ""), i[1].length || (i.length = 1)), this._insertThousandsSeparators(i.join(this.radix));
  }
  _padFractionalZeros(r) {
    if (!r) return r;
    const i = r.split(this.radix);
    return i.length < 2 && i.push(""), i[1] = i[1].padEnd(this.scale, "0"), i.join(this.radix);
  }
  doSkipInvalid(r, i, u) {
    i === void 0 && (i = {});
    const h = this.scale === 0 && r !== this.thousandsSeparator && (r === this.radix || r === tp.UNMASKED_RADIX || this.mapToRadix.includes(r));
    return super.doSkipInvalid(r, i, u) && !h;
  }
  get unmaskedValue() {
    return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, tp.UNMASKED_RADIX);
  }
  set unmaskedValue(r) {
    super.unmaskedValue = r;
  }
  get typedValue() {
    return this.parse(this.unmaskedValue, this);
  }
  set typedValue(r) {
    this.rawInputValue = this.format(r, this).replace(tp.UNMASKED_RADIX, this.radix);
  }
  /** Parsed Number */
  get number() {
    return this.typedValue;
  }
  set number(r) {
    this.typedValue = r;
  }
  get allowNegative() {
    return this.min != null && this.min < 0 || this.max != null && this.max < 0;
  }
  get allowPositive() {
    return this.min != null && this.min > 0 || this.max != null && this.max > 0;
  }
  typedValueEquals(r) {
    return (super.typedValueEquals(r) || tp.EMPTY_VALUES.includes(r) && tp.EMPTY_VALUES.includes(this.typedValue)) && !(r === 0 && this.value === "");
  }
}
Ope = tp;
tp.UNMASKED_RADIX = ".";
tp.EMPTY_VALUES = [...Vd.EMPTY_VALUES, 0];
tp.DEFAULTS = {
  ...Vd.DEFAULTS,
  mask: Number,
  radix: ",",
  thousandsSeparator: "",
  mapToRadix: [Ope.UNMASKED_RADIX],
  min: Number.MIN_SAFE_INTEGER,
  max: Number.MAX_SAFE_INTEGER,
  scale: 2,
  normalizeZeros: !0,
  padFractionalZeros: !1,
  parse: Number,
  format: (o) => o.toLocaleString("en-US", {
    useGrouping: !1,
    maximumFractionDigits: 20
  })
};
us.MaskedNumber = tp;
const woe = {
  MASKED: "value",
  UNMASKED: "unmaskedValue",
  TYPED: "typedValue"
};
function Ape(o, r, i) {
  r === void 0 && (r = woe.MASKED), i === void 0 && (i = woe.MASKED);
  const u = E0(o);
  return (h) => u.runIsolated((y) => (y[r] = h, y[i]));
}
function Kwe(o, r, i, u) {
  return Ape(r, i, u)(o);
}
us.PIPE_TYPE = woe;
us.createPipe = Ape;
us.pipe = Kwe;
class Ywe extends jd {
  get repeatFrom() {
    var r;
    return (r = Array.isArray(this.repeat) ? this.repeat[0] : this.repeat === 1 / 0 ? 0 : this.repeat) != null ? r : 0;
  }
  get repeatTo() {
    var r;
    return (r = Array.isArray(this.repeat) ? this.repeat[1] : this.repeat) != null ? r : 1 / 0;
  }
  constructor(r) {
    super(r);
  }
  updateOptions(r) {
    super.updateOptions(r);
  }
  _update(r) {
    var i, u, h;
    const {
      repeat: y,
      ...k
    } = E5(r);
    this._blockOpts = Object.assign({}, this._blockOpts, k);
    const _ = E0(this._blockOpts);
    this.repeat = (i = (u = y ?? _.repeat) != null ? u : this.repeat) != null ? i : 1 / 0, super._update({
      mask: "m".repeat(Math.max(this.repeatTo === 1 / 0 && ((h = this._blocks) == null ? void 0 : h.length) || 0, this.repeatFrom)),
      blocks: {
        m: _
      },
      eager: _.eager,
      overwrite: _.overwrite,
      skipInvalid: _.skipInvalid,
      lazy: _.lazy,
      placeholderChar: _.placeholderChar,
      displayChar: _.displayChar
    });
  }
  _allocateBlock(r) {
    if (r < this._blocks.length) return this._blocks[r];
    if (this.repeatTo === 1 / 0 || this._blocks.length < this.repeatTo)
      return this._blocks.push(E0(this._blockOpts)), this.mask += "m", this._blocks[this._blocks.length - 1];
  }
  _appendCharRaw(r, i) {
    i === void 0 && (i = {});
    const u = new Hs();
    for (
      let D = (h = (y = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : y.index) != null ? h : Math.max(this._blocks.length - 1, 0), L, W;
      // try to get a block or
      // try to allocate a new block if not allocated already
      L = (k = this._blocks[D]) != null ? k : W = !W && this._allocateBlock(D);
      ++D
    ) {
      var h, y, k, _;
      const se = L._appendChar(r, {
        ...i,
        _beforeTailState: (_ = i._beforeTailState) == null || (_ = _._blocks) == null ? void 0 : _[D]
      });
      if (se.skip && W) {
        this._blocks.pop(), this.mask = this.mask.slice(1);
        break;
      }
      if (u.aggregate(se), se.consumed) break;
    }
    return u;
  }
  _trimEmptyTail(r, i) {
    var u, h;
    r === void 0 && (r = 0);
    const y = Math.max(((u = this._mapPosToBlock(r)) == null ? void 0 : u.index) || 0, this.repeatFrom, 0);
    let k;
    i != null && (k = (h = this._mapPosToBlock(i)) == null ? void 0 : h.index), k == null && (k = this._blocks.length - 1);
    let _ = 0;
    for (let D = k; y <= D && !this._blocks[D].unmaskedValue; --D, ++_)
      ;
    _ && (this._blocks.splice(k - _ + 1, _), this.mask = this.mask.slice(_));
  }
  reset() {
    super.reset(), this._trimEmptyTail();
  }
  remove(r, i) {
    r === void 0 && (r = 0), i === void 0 && (i = this.displayValue.length);
    const u = super.remove(r, i);
    return this._trimEmptyTail(r, i), u;
  }
  totalInputPositions(r, i) {
    return r === void 0 && (r = 0), i == null && this.repeatTo === 1 / 0 ? 1 / 0 : super.totalInputPositions(r, i);
  }
  get state() {
    return super.state;
  }
  set state(r) {
    this._blocks.length = r._blocks.length, this.mask = this.mask.slice(0, this._blocks.length), super.state = r;
  }
}
us.RepeatBlock = Ywe;
try {
  globalThis.IMask = us;
} catch {
}
const Ppe = {
  // common
  mask: ce.oneOfType([ce.array, ce.func, ce.string, ce.instanceOf(RegExp), ce.oneOf([Date, Number, us.Masked]), ce.instanceOf(us.Masked)]),
  value: ce.any,
  unmask: ce.oneOfType([ce.bool, ce.oneOf(["typed"])]),
  prepare: ce.func,
  prepareChar: ce.func,
  validate: ce.func,
  commit: ce.func,
  overwrite: ce.oneOfType([ce.bool, ce.oneOf(["shift"])]),
  eager: ce.oneOfType([ce.bool, ce.oneOf(["append", "remove"])]),
  skipInvalid: ce.bool,
  // events
  onAccept: ce.func,
  onComplete: ce.func,
  // pattern
  placeholderChar: ce.string,
  displayChar: ce.string,
  lazy: ce.bool,
  definitions: ce.object,
  blocks: ce.object,
  // enum
  enum: ce.arrayOf(ce.string),
  // range
  maxLength: ce.number,
  from: ce.number,
  to: ce.number,
  // date
  pattern: ce.string,
  format: ce.func,
  parse: ce.func,
  autofix: ce.oneOfType([ce.bool, ce.oneOf(["pad"])]),
  // number
  radix: ce.string,
  thousandsSeparator: ce.string,
  mapToRadix: ce.arrayOf(ce.string),
  scale: ce.number,
  normalizeZeros: ce.bool,
  padFractionalZeros: ce.bool,
  min: ce.oneOfType([ce.number, ce.instanceOf(Date)]),
  max: ce.oneOfType([ce.number, ce.instanceOf(Date)]),
  // dynamic
  dispatch: ce.func,
  // ref
  inputRef: ce.oneOfType([ce.func, ce.shape({
    current: ce.object
  })])
}, Dpe = Object.keys(Ppe).filter((o) => o !== "value"), Xwe = ["value", "unmask", "onAccept", "onComplete", "inputRef"], Qwe = Dpe.filter((o) => Xwe.indexOf(o) < 0);
function Jwe(o) {
  var r;
  const i = (r = class extends Ve.Component {
    constructor(y) {
      super(y), this._inputRef = this._inputRef.bind(this);
    }
    componentDidMount() {
      this.props.mask && this.initMask();
    }
    componentDidUpdate() {
      const y = this.props, k = this._extractMaskOptionsFromProps(y);
      if (k.mask)
        this.maskRef ? (this.maskRef.updateOptions(k), "value" in y && y.value !== void 0 && (this.maskValue = y.value)) : this.initMask(k);
      else if (this.destroyMask(), "value" in y && y.value !== void 0) {
        var _;
        (_ = this.element) != null && _.isContentEditable && this.element.tagName !== "INPUT" && this.element.tagName !== "TEXTAREA" ? this.element.textContent = y.value : this.element.value = y.value;
      }
    }
    componentWillUnmount() {
      this.destroyMask();
    }
    _inputRef(y) {
      this.element = y, this.props.inputRef && (Object.prototype.hasOwnProperty.call(this.props.inputRef, "current") ? this.props.inputRef.current = y : this.props.inputRef(y));
    }
    initMask(y) {
      y === void 0 && (y = this._extractMaskOptionsFromProps(this.props)), this.maskRef = us(this.element, y).on("accept", this._onAccept.bind(this)).on("complete", this._onComplete.bind(this)), "value" in this.props && this.props.value !== void 0 && (this.maskValue = this.props.value);
    }
    destroyMask() {
      this.maskRef && (this.maskRef.destroy(), delete this.maskRef);
    }
    _extractMaskOptionsFromProps(y) {
      const {
        ...k
      } = y;
      return Object.keys(k).filter((_) => Qwe.indexOf(_) < 0).forEach((_) => {
        delete k[_];
      }), k;
    }
    _extractNonMaskProps(y) {
      const {
        ...k
      } = y;
      return Dpe.forEach((_) => {
        _ !== "maxLength" && delete k[_];
      }), "defaultValue" in k || (k.defaultValue = y.mask ? "" : k.value), delete k.value, k;
    }
    get maskValue() {
      return this.maskRef ? this.props.unmask === "typed" ? this.maskRef.typedValue : this.props.unmask ? this.maskRef.unmaskedValue : this.maskRef.value : "";
    }
    set maskValue(y) {
      this.maskRef && (y = y == null && this.props.unmask !== "typed" ? "" : y, this.props.unmask === "typed" ? this.maskRef.typedValue = y : this.props.unmask ? this.maskRef.unmaskedValue = y : this.maskRef.value = y);
    }
    _onAccept(y) {
      this.props.onAccept && this.maskRef && this.props.onAccept(this.maskValue, this.maskRef, y);
    }
    _onComplete(y) {
      this.props.onComplete && this.maskRef && this.props.onComplete(this.maskValue, this.maskRef, y);
    }
    render() {
      return Ve.createElement(o, {
        ...this._extractNonMaskProps(this.props),
        inputRef: this._inputRef
      });
    }
  }, r.displayName = void 0, r.propTypes = void 0, r), u = o.displayName || o.name || "Component";
  return i.displayName = "IMask(" + u + ")", i.propTypes = Ppe, Ve.forwardRef((h, y) => Ve.createElement(i, {
    ...h,
    ref: y
  }));
}
const e2e = Jwe((o) => {
  let {
    inputRef: r,
    ...i
  } = o;
  return Ve.createElement("input", {
    ...i,
    ref: r
  });
}), t2e = (o, r) => Ve.createElement(e2e, {
  ...o,
  ref: r
}), n2e = Ve.forwardRef(t2e), o2e = (o = {}) => Object.entries(o).reduce((r, [i, u]) => (u !== void 0 && (r[i] = u), r), {}), Ek = (...o) => (i) => {
  o.filter((u) => typeof u == "function").forEach((u) => u(i));
}, r2e = ({ defaultValue: o, value: r }) => {
  const [i, u] = et.useState(!!o || o === 0);
  return [!!r || r === 0 || i, (k) => u(k.target.value)];
}, Kce = (o, r) => {
  const [i, u] = et.useState([]), h = (D) => (u((L) => [...L, D]), D), y = () => {
    const D = Gre(`${o}-`);
    return h(D);
  }, k = (D) => {
    u((L) => L.filter((W) => W !== D));
  };
  return [i, (D) => {
    const [L, W] = et.useState(D);
    return et.useEffect(() => (D ? h(D) : L || W(y()), () => k(L)), [L, D]), L;
  }];
}, Ow = {
  SMALL: "sm",
  LARGE: "lg"
}, zg = {
  DEFAULT: "default",
  VALID: "valid",
  INVALID: "invalid",
  WARNING: "warning",
  CRITERIA_EMPTY: "criteria-empty",
  CRITERIA_VALID: "criteria-valid",
  CRITERIA_INVALID: "criteria-invalid"
};
function T5(o) {
  "@babel/helpers - typeof";
  return T5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, T5(o);
}
function Yce(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function ow(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? Yce(Object(i), !0).forEach(function(u) {
      s2e(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : Yce(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function s2e(o, r, i) {
  return r = a2e(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function a2e(o) {
  var r = i2e(o, "string");
  return T5(r) == "symbol" ? r : r + "";
}
function i2e(o, r) {
  if (T5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (T5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
function oV(o, r) {
  return d2e(o) || u2e(o, r) || c2e(o, r) || l2e();
}
function l2e() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function c2e(o, r) {
  if (o) {
    if (typeof o == "string") return Xce(o, r);
    var i = Object.prototype.toString.call(o).slice(8, -1);
    if (i === "Object" && o.constructor && (i = o.constructor.name), i === "Map" || i === "Set") return Array.from(o);
    if (i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return Xce(o, r);
  }
}
function Xce(o, r) {
  (r == null || r > o.length) && (r = o.length);
  for (var i = 0, u = new Array(r); i < r; i++) u[i] = o[i];
  return u;
}
function u2e(o, r) {
  var i = o == null ? null : typeof Symbol < "u" && o[Symbol.iterator] || o["@@iterator"];
  if (i != null) {
    var u, h, y, k, _ = [], D = !0, L = !1;
    try {
      if (y = (i = i.call(o)).next, r !== 0) for (; !(D = (u = y.call(i)).done) && (_.push(u.value), _.length !== r); D = !0) ;
    } catch (W) {
      L = !0, h = W;
    } finally {
      try {
        if (!D && i.return != null && (k = i.return(), Object(k) !== k)) return;
      } finally {
        if (L) throw h;
      }
    }
    return _;
  }
}
function d2e(o) {
  if (Array.isArray(o)) return o;
}
var Lte = function(r) {
  return r;
}, f2e = function() {
}, Rpe = /* @__PURE__ */ Ve.createContext({
  getControlProps: Lte,
  useSetIsControlGroupEffect: f2e,
  getLabelProps: Lte,
  getDescriptorProps: Lte,
  hasFormGroupProvider: !1
}), Th = function() {
  return Ve.useContext(Rpe);
}, m2e = function(r) {
  var i = et.useState(r), u = oV(i, 2), h = u[0], y = u[1], k = function(D) {
    et.useEffect(function() {
      return y(D);
    }, [D]);
  };
  return [h, k];
};
function K3(o) {
  var r = o.children, i = o.controlId, u = o.isInvalid, h = o.isValid, y = o.size, k = et.useMemo(function() {
    return i || Gre("form-field");
  }, [i]), _ = Kce(k), D = oV(_, 2), L = D[0], W = D[1], se = Kce(k), J = oV(se, 2), be = J[0], ke = J[1], Ce = m2e(!1), Q = oV(Ce, 2), oe = Q[0], ae = Q[1], G = et.useCallback(function(te) {
    var lt = oe ? be : void 0;
    return o2e(ow(ow({}, te), {}, {
      "aria-describedby": ns(te["aria-describedby"], L) || void 0,
      "aria-labelledby": ns(te["aria-labelledby"], lt) || void 0,
      id: k
    }));
  }, [oe, L, be, k]), ve = function(lt) {
    var ot = ke(lt == null ? void 0 : lt.id);
    return oe ? ow(ow({}, lt), {}, {
      id: ot
    }) : ow(ow({}, lt), {}, {
      htmlFor: k
    });
  }, nt = function(lt) {
    var ot = W(lt == null ? void 0 : lt.id);
    return ow(ow({}, lt), {}, {
      id: ot
    });
  }, Xe = {
    getControlProps: G,
    getLabelProps: ve,
    getDescriptorProps: nt,
    useSetIsControlGroupEffect: ae,
    isControlGroup: oe,
    controlId: k,
    isInvalid: u,
    isValid: h,
    size: y,
    hasFormGroupProvider: !0
  };
  return /* @__PURE__ */ Ve.createElement(Rpe.Provider, {
    value: Xe
  }, r);
}
K3.propTypes = {
  children: ce.node.isRequired,
  controlId: ce.string,
  isInvalid: ce.bool,
  isValid: ce.bool,
  size: ce.oneOf([Ow.SMALL, Ow.LARGE])
};
K3.defaultProps = {
  controlId: void 0,
  isInvalid: void 0,
  isValid: void 0,
  size: void 0
};
var p2e = ["children", "type", "icon", "muted", "hasIcon"], m0;
function O5(o) {
  "@babel/helpers - typeof";
  return O5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, O5(o);
}
function Coe() {
  return Coe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, Coe.apply(this, arguments);
}
function h2e(o, r) {
  if (o == null) return {};
  var i = g2e(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function g2e(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
function uk(o, r, i) {
  return r = b2e(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function b2e(o) {
  var r = v2e(o, "string");
  return O5(r) == "symbol" ? r : r + "";
}
function v2e(o, r) {
  if (O5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (O5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
var y2e = (m0 = {}, uk(m0, zg.DEFAULT, null), uk(m0, zg.VALID, lwe), uk(m0, zg.INVALID, uwe), uk(m0, zg.WARNING, hwe), uk(m0, zg.CRITERIA_EMPTY, pwe), uk(m0, zg.CRITERIA_VALID, cwe), uk(m0, zg.CRITERIA_INVALID, iwe), m0), x2e = function(r) {
  var i = r.isInvalid, u = r.isValid;
  return u ? zg.VALID : i ? zg.INVALID : zg.DEFAULT;
};
function Pse(o) {
  var r = o.type, i = o.customIcon;
  if (i)
    return i;
  var u = y2e[r];
  return u ? /* @__PURE__ */ Ve.createElement(D3, {
    src: u
  }) : null;
}
Pse.propTypes = {
  type: ce.oneOf(Object.values(zg)),
  customIcon: ce.node
};
Pse.defaultProps = {
  type: void 0,
  customIcon: void 0
};
function Ij(o) {
  var r = o.children, i = o.type, u = o.icon, h = o.muted, y = o.hasIcon, k = h2e(o, p2e), _ = ns(k.className, "pgn__form-text", "pgn__form-text-".concat(i), {
    "text-muted": h
  });
  return /* @__PURE__ */ Ve.createElement("div", Coe({}, k, {
    className: _
  }), y && /* @__PURE__ */ Ve.createElement(Pse, {
    customIcon: u,
    type: i
  }), /* @__PURE__ */ Ve.createElement("div", null, r));
}
var w2e = ["default", "valid", "invalid", "warning", "criteria-empty", "criteria-valid", "criteria-invalid"];
Ij.propTypes = {
  /** Specifies contents of the component. */
  children: ce.node.isRequired,
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies whether to show an icon next to the text. */
  hasIcon: ce.bool,
  /** Specifies text type, this affects styling. */
  type: ce.oneOf(w2e),
  /** Specifies icon to show, will only be shown if `hasIcon` prop is set to `true`. */
  icon: ce.node,
  /** Specifies whether to show text with muted styling. */
  muted: ce.bool
};
Ij.defaultProps = {
  hasIcon: !0,
  type: "default",
  icon: void 0,
  className: void 0,
  muted: !1
};
var C2e = ["children"];
function Soe() {
  return Soe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, Soe.apply(this, arguments);
}
function S2e(o, r) {
  if (o == null) return {};
  var i = k2e(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function k2e(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
function Aw(o) {
  var r = o.children, i = S2e(o, C2e), u = Th(), h = u.getDescriptorProps, y = u.isInvalid, k = u.isValid, _ = h(i), D = ns("pgn__form-control-description", i.className), L = i.type || x2e({
    isInvalid: y,
    isValid: k
  });
  return /* @__PURE__ */ Ve.createElement(Ij, Soe({}, _, {
    className: D,
    type: L
  }), r);
}
var _2e = ["default", "valid", "invalid", "warning", "criteria-empty", "criteria-valid", "criteria-invalid"];
Aw.propTypes = {
  /** Specifies contents of the component. */
  children: ce.node.isRequired,
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies whether to show an icon next to the text. */
  hasIcon: ce.bool,
  /** Specifies feedback type, this affects styling. */
  type: ce.oneOf(_2e),
  /** Specifies icon to show, will only be shown if `hasIcon` prop is set to `true`. */
  icon: ce.node,
  /** Specifies whether to show feedback with muted styling. */
  muted: ce.bool
};
Aw.defaultProps = {
  hasIcon: !0,
  type: void 0,
  icon: void 0,
  className: void 0,
  muted: !1
};
function Npe(o) {
  var r = o.children, i = Th(), u = i.controlId;
  return /* @__PURE__ */ Ve.createElement("div", {
    className: "pgn__form-control-floating-label"
  }, /* @__PURE__ */ Ve.createElement("div", {
    className: "pgn__form-control-floating-label-content"
  }, /* @__PURE__ */ Ve.createElement("label", {
    className: "pgn__form-control-floating-label-text",
    htmlFor: u
  }, r)));
}
Npe.propTypes = {
  children: ce.node.isRequired
};
function UV(o) {
  var r = o.children, i = o.location;
  return /* @__PURE__ */ Ve.createElement("div", {
    className: "pgn__form-control-decorator pgn__form-control-decorator-".concat(i)
  }, r);
}
UV.propTypes = {
  children: ce.node.isRequired,
  location: ce.oneOf(["leading", "trailing"])
};
UV.defaultProps = {
  location: "leading"
};
var E2e = ["children", "leadingElement", "trailingElement", "floatingLabel", "className"];
function koe() {
  return koe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, koe.apply(this, arguments);
}
function T2e(o, r) {
  if (o == null) return {};
  var i = O2e(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function O2e(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
function Dse(o) {
  var r = o.children, i = o.leadingElement, u = o.trailingElement, h = o.floatingLabel, y = o.className, k = T2e(o, E2e), _ = Th(), D = k.size || _.size;
  return /* @__PURE__ */ Ve.createElement("div", koe({
    className: ns("pgn__form-control-decorator-group", {
      "has-prepended-node": !!i,
      "has-appended-node": !!u,
      "has-leading-element": !!i,
      "has-trailing-element": !!u,
      "has-floating-label": !!h,
      "pgn__form-control-decorator-group-lg": D === Ow.LARGE,
      "pgn__form-control-decorator-group-sm": D === Ow.SMALL
    }, y)
  }, k), r, i && /* @__PURE__ */ Ve.createElement(UV, {
    location: "leading"
  }, i), u && /* @__PURE__ */ Ve.createElement(UV, {
    location: "trailing"
  }, u), h && /* @__PURE__ */ Ve.createElement(Npe, null, h));
}
Dse.propTypes = {
  children: ce.node.isRequired,
  leadingElement: ce.node,
  trailingElement: ce.node,
  floatingLabel: ce.node,
  className: ce.string,
  size: ce.oneOf([Ow.SMALL, Ow.LARGE])
};
Dse.defaultProps = {
  leadingElement: void 0,
  trailingElement: void 0,
  floatingLabel: void 0,
  className: void 0,
  size: void 0
};
function A5(o) {
  "@babel/helpers - typeof";
  return A5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, A5(o);
}
var A2e = ["as", "className", "controlClassName", "leadingElement", "trailingElement", "floatingLabel", "autoResize", "onChange", "inputMask"], P2e = ["isInvalid", "isValid", "getControlProps"];
function _oe() {
  return _oe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, _oe.apply(this, arguments);
}
function Qce(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function Jce(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? Qce(Object(i), !0).forEach(function(u) {
      D2e(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : Qce(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function D2e(o, r, i) {
  return r = R2e(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function R2e(o) {
  var r = N2e(o, "string");
  return A5(r) == "symbol" ? r : r + "";
}
function N2e(o, r) {
  if (A5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (A5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
function M2e(o, r) {
  return $2e(o) || B2e(o, r) || F2e(o, r) || I2e();
}
function I2e() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function F2e(o, r) {
  if (o) {
    if (typeof o == "string") return eue(o, r);
    var i = Object.prototype.toString.call(o).slice(8, -1);
    if (i === "Object" && o.constructor && (i = o.constructor.name), i === "Map" || i === "Set") return Array.from(o);
    if (i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return eue(o, r);
  }
}
function eue(o, r) {
  (r == null || r > o.length) && (r = o.length);
  for (var i = 0, u = new Array(r); i < r; i++) u[i] = o[i];
  return u;
}
function B2e(o, r) {
  var i = o == null ? null : typeof Symbol < "u" && o[Symbol.iterator] || o["@@iterator"];
  if (i != null) {
    var u, h, y, k, _ = [], D = !0, L = !1;
    try {
      if (y = (i = i.call(o)).next, r !== 0) for (; !(D = (u = y.call(i)).done) && (_.push(u.value), _.length !== r); D = !0) ;
    } catch (W) {
      L = !0, h = W;
    } finally {
      try {
        if (!D && i.return != null && (k = i.return(), Object(k) !== k)) return;
      } finally {
        if (L) throw h;
      }
    }
    return _;
  }
}
function $2e(o) {
  if (Array.isArray(o)) return o;
}
function tue(o, r) {
  if (o == null) return {};
  var i = L2e(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function L2e(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
var Y3 = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.as, u = o.className, h = o.controlClassName, y = o.leadingElement, k = o.trailingElement, _ = o.floatingLabel, D = o.autoResize, L = o.onChange, W = o.inputMask, se = tue(o, A2e), J = Th(), be = J.isInvalid, ke = J.isValid, Ce = J.getControlProps, Q = tue(J, P2e), oe = Ve.useRef(), ae = r || oe, G = se.size || Q.size, ve = r2e({
    defaultValue: se.defaultValue,
    value: se.value
  }), nt = M2e(ve, 2), Xe = nt[0], te = nt[1], lt = et.useCallback(function() {
    i === "textarea" && D && (!ae.current.initialHeight && !ae.current.offsets && (ae.current.initialHeight = ae.current.offsetHeight, ae.current.offsets = ae.current.offsetHeight - ae.current.clientHeight), ae.current.style.height = "".concat(ae.current.initialHeight, "px"), ae.current.style.height = "".concat(ae.current.scrollHeight + ae.current.offsets, "px"));
  }, [i, D, ae]);
  et.useEffect(function() {
    lt();
  }, [lt]);
  var ot = Ce(Jce(Jce({}, se), {}, {
    // eslint-disable-next-line react/prop-types
    onBlur: Ek(te, se.onBlur)
  })), Kt = function(ye) {
    lt(), L && L(ye);
  };
  return /* @__PURE__ */ Ve.createElement(Dse, {
    size: G,
    leadingElement: y,
    trailingElement: k,
    floatingLabel: _,
    className: u
  }, /* @__PURE__ */ Ve.createElement(wpe, _oe({
    as: W ? n2e : i,
    ref: ae,
    size: G,
    isInvalid: be,
    isValid: ke,
    className: ns(h, {
      "has-value": Xe
    }),
    onChange: Kt,
    mask: W
  }, ot)));
}), H2e = ["sm", "lg"];
Y3.Feedback = Aw;
Y3.Description = Aw;
Y3.propTypes = {
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies base element for the control component. */
  as: ce.elementType,
  /** Specifies function that is triggered on input value change. */
  onChange: ce.func,
  /** Specifies default value of the input component. */
  defaultValue: ce.oneOfType([ce.string, ce.number]),
  /** Specifies current value of the input component. */
  value: ce.oneOfType([ce.string, ce.number]),
  /** Specifies id of the control component. */
  id: ce.string,
  /** Specifies class name for the control component. */
  controlClassName: ce.string,
  /** Specifies size for the control component. */
  size: ce.oneOf(H2e),
  /** Specifies leading element to display for the input component. */
  leadingElement: ce.node,
  /** Specifies trailing element to display for the input component. */
  trailingElement: ce.node,
  /** Specifies floating label to display for the input component. */
  floatingLabel: ce.node,
  /** Specifies whether to render input as plain text. */
  plaintext: ce.bool,
  /** Specifies whether to display control in valid state, this affects styling. */
  isValid: ce.bool,
  /** Specifies whether to display control in invalid state, this affects styling. */
  isInvalid: ce.bool,
  /** Only for `as="textarea"`. Specifies whether the input can be resized according to the height of content. */
  autoResize: ce.bool,
  /** Specifies what format to use for the input mask. */
  inputMask: ce.string
};
Y3.defaultProps = {
  as: "input",
  className: void 0,
  id: void 0,
  controlClassName: void 0,
  onChange: void 0,
  defaultValue: void 0,
  value: void 0,
  size: void 0,
  leadingElement: void 0,
  trailingElement: void 0,
  floatingLabel: void 0,
  plaintext: !1,
  isValid: void 0,
  isInvalid: void 0,
  autoResize: !1,
  inputMask: void 0
};
function P5(o) {
  "@babel/helpers - typeof";
  return P5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, P5(o);
}
var z2e = ["children", "isInline"];
function nue(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function oue(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? nue(Object(i), !0).forEach(function(u) {
      V2e(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : nue(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function V2e(o, r, i) {
  return r = j2e(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function j2e(o) {
  var r = U2e(o, "string");
  return P5(r) == "symbol" ? r : r + "";
}
function U2e(o, r) {
  if (P5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (P5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
function W2e(o, r) {
  if (o == null) return {};
  var i = Z2e(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function Z2e(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
function cF(o) {
  var r = o.children, i = o.isInline, u = W2e(o, z2e), h = Th(), y = h.size, k = h.isControlGroup, _ = h.getLabelProps, D = ns("pgn__form-label", {
    "pgn__form-label-inline": i,
    "pgn__form-label-lg": y === Ow.LARGE,
    "pgn__form-label-sm": y === Ow.SMALL
  }, u.className), L = _(oue(oue({}, u), {}, {
    className: D
  })), W = k ? "p" : "label";
  return /* @__PURE__ */ Ve.createElement(W, L, r);
}
var G2e = ["sm", "lg"];
cF.propTypes = {
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies contents of the component. */
  children: ce.node.isRequired,
  /** Specifies whether the component should be displayed with inline styling. */
  isInline: ce.bool,
  /** Specifies size of the component. */
  size: ce.oneOf(G2e)
};
cF.defaultProps = {
  isInline: !1,
  size: void 0,
  className: void 0
};
function D5(o) {
  "@babel/helpers - typeof";
  return D5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, D5(o);
}
var q2e = ["children", "controlId", "isInvalid", "isValid", "size", "as"];
function rue(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function sue(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? rue(Object(i), !0).forEach(function(u) {
      K2e(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : rue(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function K2e(o, r, i) {
  return r = Y2e(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function Y2e(o) {
  var r = X2e(o, "string");
  return D5(r) == "symbol" ? r : r + "";
}
function X2e(o, r) {
  if (D5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (D5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
function Q2e(o, r) {
  if (o == null) return {};
  var i = J2e(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function J2e(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
function Rse(o) {
  var r = o.children, i = o.controlId, u = o.isInvalid, h = o.isValid, y = o.size, k = o.as, _ = Q2e(o, q2e);
  return /* @__PURE__ */ Ve.createElement(k, sue(sue({}, _), {}, {
    className: ns("pgn__form-group", _.className)
  }), /* @__PURE__ */ Ve.createElement(K3, {
    controlId: i,
    isInvalid: u,
    isValid: h,
    size: y
  }, r));
}
var eCe = ["sm", "lg"];
Rse.propTypes = {
  /** Specifies contents of the component. */
  children: ce.node.isRequired,
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies base element for the component. */
  as: ce.elementType,
  /** Specifies id to use in the group, it will be used as `htmlFor` in `FormLabel` and as `id` in input components.
   *  Will be autogenerated if none is supplied. */
  controlId: ce.string,
  /** Specifies whether to display components in invalid state, this affects styling. */
  isInvalid: ce.bool,
  /** Specifies whether to display components in valid state, this affects styling. */
  isValid: ce.bool,
  /** Specifies size for the component. */
  size: ce.oneOf(eCe)
};
Rse.defaultProps = {
  as: "div",
  className: void 0,
  controlId: void 0,
  isInvalid: !1,
  isValid: !1,
  size: void 0
};
function R5(o) {
  "@babel/helpers - typeof";
  return R5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, R5(o);
}
function aue(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function iue(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? aue(Object(i), !0).forEach(function(u) {
      tCe(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : aue(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function tCe(o, r, i) {
  return r = nCe(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function nCe(o) {
  var r = oCe(o, "string");
  return R5(r) == "symbol" ? r : r + "";
}
function oCe(o, r) {
  if (R5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (R5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
var rCe = function(r) {
  return r;
}, Mpe = /* @__PURE__ */ Ve.createContext({
  getRadioControlProps: rCe,
  hasRadioSetProvider: !1
}), sCe = function() {
  return et.useContext(Mpe);
};
function Nse(o) {
  var r = o.children, i = o.name, u = o.onBlur, h = o.onFocus, y = o.onChange, k = o.value, _ = o.defaultValue, D = !_ && k !== void 0, L = function(J) {
    return iue(iue({}, J), {}, {
      name: i,
      /* istanbul ignore next */
      onBlur: J.onBlur ? Ek(u, J.onBlur) : u,
      /* istanbul ignore next */
      onFocus: J.onFocus ? Ek(h, J.onFocus) : h,
      /* istanbul ignore next */
      onChange: J.onChange ? Ek(y, J.onChange) : y,
      checked: D ? k === J.value : void 0,
      defaultChecked: D ? void 0 : _ === J.value
    });
  }, W = {
    name: i,
    value: k,
    defaultValue: _,
    getRadioControlProps: L,
    onBlur: u,
    onFocus: h,
    onChange: y,
    hasRadioSetProvider: !0
  };
  return /* @__PURE__ */ Ve.createElement(Mpe.Provider, {
    value: W
  }, r);
}
Nse.propTypes = {
  children: ce.node.isRequired,
  name: ce.string.isRequired,
  onBlur: ce.func,
  onFocus: ce.func,
  onChange: ce.func,
  value: ce.string,
  defaultValue: ce.string
};
Nse.defaultProps = {
  onBlur: void 0,
  onFocus: void 0,
  onChange: void 0,
  value: void 0,
  defaultValue: void 0
};
var aCe = ["children", "className", "controlClassName", "labelClassName", "description", "isInvalid", "isValid"];
function N5(o) {
  "@babel/helpers - typeof";
  return N5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, N5(o);
}
function iCe(o, r) {
  if (o == null) return {};
  var i = lCe(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function lCe(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
function WV() {
  return WV = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, WV.apply(this, arguments);
}
function lue(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function cue(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? lue(Object(i), !0).forEach(function(u) {
      cCe(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : lue(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function cCe(o, r, i) {
  return r = uCe(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function uCe(o) {
  var r = dCe(o, "string");
  return N5(r) == "symbol" ? r : r + "";
}
function dCe(o, r) {
  if (N5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (N5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
var Mse = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = Th(), u = i.getControlProps, h = sCe(), y = h.getRadioControlProps, k = h.hasRadioSetProvider, _ = u(cue(cue({}, o), {}, {
    className: ns("pgn__form-radio-input", o.className)
  }));
  return k && (_ = y(_)), /* @__PURE__ */ Ve.createElement("input", WV({}, _, {
    type: "radio",
    ref: r
  }));
});
Mse.propTypes = {
  className: ce.string
};
Mse.defaultProps = {
  className: void 0
};
var Ise = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.children, u = o.className, h = o.controlClassName, y = o.labelClassName, k = o.description, _ = o.isInvalid, D = o.isValid, L = iCe(o, aCe);
  return /* @__PURE__ */ Ve.createElement(K3, {
    controlId: L.id,
    isInvalid: _,
    isValid: D
  }, /* @__PURE__ */ Ve.createElement("div", {
    className: ns("pgn__form-radio", u, {
      "pgn__form-control-valid": D,
      "pgn__form-control-invalid": _,
      "pgn__form-control-disabled": L.disabled
    })
  }, /* @__PURE__ */ Ve.createElement(Mse, WV({
    ref: r,
    className: h
  }, L)), /* @__PURE__ */ Ve.createElement("div", null, /* @__PURE__ */ Ve.createElement(cF, {
    className: y
  }, i), k && /* @__PURE__ */ Ve.createElement(Aw, {
    hasIcon: !1
  }, k))));
});
Ise.propTypes = {
  /** Specifies id of the FormRadio component. */
  id: ce.string,
  /** Specifies contents of the component. */
  children: ce.node.isRequired,
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies class name for control component. */
  controlClassName: ce.string,
  /** Specifies class name for label component. */
  labelClassName: ce.string,
  /** Specifies description to show under the radio's value. */
  description: ce.node,
  /** Specifies whether to display component in invalid state, this affects styling. */
  isInvalid: ce.bool,
  /** Specifies whether to display component in valid state, this affects styling. */
  isValid: ce.bool,
  /** Specifies whether the `FormRadio` is disabled. */
  disabled: ce.bool
};
Ise.defaultProps = {
  id: void 0,
  className: void 0,
  controlClassName: void 0,
  labelClassName: void 0,
  description: void 0,
  isInvalid: !1,
  isValid: !1,
  disabled: !1
};
function M5(o) {
  "@babel/helpers - typeof";
  return M5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, M5(o);
}
var fCe = ["as", "className", "isInline", "children"];
function uue(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function mCe(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? uue(Object(i), !0).forEach(function(u) {
      pCe(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : uue(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function pCe(o, r, i) {
  return r = hCe(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function hCe(o) {
  var r = gCe(o, "string");
  return M5(r) == "symbol" ? r : r + "";
}
function gCe(o, r) {
  if (M5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (M5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
function bCe(o, r) {
  if (o == null) return {};
  var i = vCe(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function vCe(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
function Fj(o) {
  var r = o.as, i = o.className, u = o.isInline, h = o.children, y = bCe(o, fCe);
  return /* @__PURE__ */ Ve.createElement(r, mCe({
    className: ns(i, {
      "pgn__form-control-set": !u,
      "pgn__form-control-set-inline": u
    })
  }, y), h);
}
Fj.propTypes = {
  /** Specifies the base element */
  as: ce.elementType,
  /** A class name to append to the base element. */
  className: ce.string,
  /** Specifies whether the component should be displayed with inline styling. */
  isInline: ce.bool,
  /** Specifies contents of the component. */
  children: ce.node
};
Fj.defaultProps = {
  as: "div",
  className: void 0,
  isInline: !1,
  children: null
};
var yCe = ["children", "name", "value", "defaultValue", "isInline", "onChange", "onFocus", "onBlur"];
function Eoe() {
  return Eoe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, Eoe.apply(this, arguments);
}
function xCe(o, r) {
  if (o == null) return {};
  var i = wCe(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function wCe(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
function Fse(o) {
  var r = o.children, i = o.name, u = o.value, h = o.defaultValue, y = o.isInline, k = o.onChange, _ = o.onFocus, D = o.onBlur, L = xCe(o, yCe), W = Th(), se = W.getControlProps, J = W.useSetIsControlGroupEffect;
  J(!0);
  var be = se(L);
  return /* @__PURE__ */ Ve.createElement(Nse, {
    name: i,
    value: u,
    defaultValue: h,
    onFocus: _,
    onBlur: D,
    onChange: k
  }, /* @__PURE__ */ Ve.createElement(Fj, Eoe({
    role: "radiogroup",
    isInline: y
  }, be), r));
}
Fse.propTypes = {
  /** Specifies contents of the component. */
  children: ce.node.isRequired,
  /** A class name to append to the base element. */
  className: ce.string,
  /** Specifies name for the component. */
  name: ce.string.isRequired,
  /** Specifies values for the FormRadioSet. */
  value: ce.string,
  /** Specifies default values. */
  defaultValue: ce.string,
  /** Specifies whether the component should be displayed with inline styling. */
  isInline: ce.bool,
  /** Specifies onChange event handler. */
  onChange: ce.func,
  /** Specifies onFocus event handler. */
  onFocus: ce.func,
  /** Specifies onBlur event handler. */
  onBlur: ce.func
};
Fse.defaultProps = {
  className: void 0,
  value: void 0,
  defaultValue: void 0,
  isInline: !1,
  onChange: void 0,
  onFocus: void 0,
  onBlur: void 0
};
let F9;
const CCe = new Uint8Array(16);
function SCe() {
  if (!F9 && (F9 = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !F9))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return F9(CCe);
}
const od = [];
for (let o = 0; o < 256; ++o)
  od.push((o + 256).toString(16).slice(1));
function kCe(o, r = 0) {
  return od[o[r + 0]] + od[o[r + 1]] + od[o[r + 2]] + od[o[r + 3]] + "-" + od[o[r + 4]] + od[o[r + 5]] + "-" + od[o[r + 6]] + od[o[r + 7]] + "-" + od[o[r + 8]] + od[o[r + 9]] + "-" + od[o[r + 10]] + od[o[r + 11]] + od[o[r + 12]] + od[o[r + 13]] + od[o[r + 14]] + od[o[r + 15]];
}
const _Ce = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), due = {
  randomUUID: _Ce
};
function ECe(o, r, i) {
  if (due.randomUUID && !r && !o)
    return due.randomUUID();
  o = o || {};
  const u = o.random || (o.rng || SCe)();
  return u[6] = u[6] & 15 | 64, u[8] = u[8] & 63 | 128, kCe(u);
}
var TCe = ["bsPrefix", "variant", "animation", "size", "children", "as", "className"], Ipe = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.bsPrefix, u = o.variant, h = o.animation, y = o.size, k = o.children, _ = o.as, D = _ === void 0 ? "div" : _, L = o.className, W = _i(o, TCe);
  i = Nc(i, "spinner");
  var se = i + "-" + h;
  return /* @__PURE__ */ Ve.createElement(D, qr({
    ref: r
  }, W, {
    className: ns(L, se, y && se + "-" + y, u && "text-" + u)
  }), k);
});
Ipe.displayName = "Spinner";
function I5(o) {
  "@babel/helpers - typeof";
  return I5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, I5(o);
}
var OCe = ["className", "screenReaderText"];
function Toe() {
  return Toe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, Toe.apply(this, arguments);
}
function fue(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function mue(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? fue(Object(i), !0).forEach(function(u) {
      ACe(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : fue(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function ACe(o, r, i) {
  return r = PCe(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function PCe(o) {
  var r = DCe(o, "string");
  return I5(r) == "symbol" ? r : r + "";
}
function DCe(o, r) {
  if (I5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (I5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
function RCe(o, r) {
  if (o == null) return {};
  var i = NCe(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function NCe(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
var Bse = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.className, u = o.screenReaderText, h = RCe(o, OCe), y = mue(mue({}, h), {}, {
    className: ns("pgn__spinner", i),
    role: u ? "status" : void 0
  });
  return /* @__PURE__ */ Ve.createElement(Ipe, Toe({}, y, {
    ref: r
  }), u && /* @__PURE__ */ Ve.createElement("span", {
    className: "sr-only"
  }, u));
});
Bse.propTypes = {
  /** Specifies the class name for the component. */
  className: ce.string,
  /** Specifies the screen reader content for a11y. */
  screenReaderText: ce.node
};
Bse.defaultProps = {
  className: void 0,
  screenReaderText: void 0
};
function MCe(o, r) {
  return $Ce(o) || BCe(o, r) || FCe(o, r) || ICe();
}
function ICe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function FCe(o, r) {
  if (o) {
    if (typeof o == "string") return pue(o, r);
    var i = Object.prototype.toString.call(o).slice(8, -1);
    if (i === "Object" && o.constructor && (i = o.constructor.name), i === "Map" || i === "Set") return Array.from(o);
    if (i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return pue(o, r);
  }
}
function pue(o, r) {
  (r == null || r > o.length) && (r = o.length);
  for (var i = 0, u = new Array(r); i < r; i++) u[i] = o[i];
  return u;
}
function BCe(o, r) {
  var i = o == null ? null : typeof Symbol < "u" && o[Symbol.iterator] || o["@@iterator"];
  if (i != null) {
    var u, h, y, k, _ = [], D = !0, L = !1;
    try {
      if (y = (i = i.call(o)).next, r !== 0) for (; !(D = (u = y.call(i)).done) && (_.push(u.value), _.length !== r); D = !0) ;
    } catch (W) {
      L = !0, h = W;
    } finally {
      try {
        if (!D && i.return != null && (k = i.return(), Object(k) !== k)) return;
      } finally {
        if (L) throw h;
      }
    }
    return _;
  }
}
function $Ce(o) {
  if (Array.isArray(o)) return o;
}
function LCe(o) {
  var r = o.event, i = o.currentIndex, u = o.activeElement;
  i !== -1 && (u.click(), r.preventDefault());
}
function HCe(o) {
  var r = o.event, i = o.currentIndex, u = o.availableElements;
  i === -1 && u[0].focus();
  var h;
  if ((r.key === "ArrowDown" || r.key === "ArrowRight") && (h = u[(i + 1) % u.length]), (r.key === "ArrowUp" || r.key === "ArrowLeft") && (h = i - 1 < 0 ? u[i - 1 + u.length] : u[i - 1]), r.key === "End" && (h = u[u.length - 1]), r.key === "Home") {
    var y = MCe(u, 1);
    h = y[0];
  }
  h && h.focus(), r.preventDefault();
}
function zCe(o) {
  var r = o.event, i = o.ignoredKeys, u = i === void 0 ? [] : i, h = o.parentNode, y = o.selectors, k = y === void 0 ? "a,button,input" : y;
  if (h) {
    var _ = r.key;
    if (!(!["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft", "Enter", "Home", "End"].includes(_) || u.includes(_))) {
      var D = document, L = D.activeElement;
      if (h.contains(L)) {
        var W = h.querySelectorAll(k);
        if (W.length) {
          var se = Array.from(W).findIndex(function(J) {
            return J === L;
          });
          _ === "Enter" && LCe({
            event: r,
            currentIndex: se,
            activeElement: L
          }), HCe({
            event: r,
            currentIndex: se,
            availableElements: W
          });
        }
      }
    }
  }
}
function VCe(o) {
  var r = o || {}, i = r.selectors, u = r.ignoredKeys, h = et.useRef();
  return et.useEffect(function() {
    var y = function(_) {
      zCe({
        event: _,
        ignoredKeys: u,
        parentNode: h.current,
        selectors: i
      });
    };
    return document.addEventListener("keydown", y), function() {
      return document.removeEventListener("keydown", y);
    };
  }, [u, i]), h;
}
const hue = {
  iconButtonOpened: {
    id: "pgn.FormAutosuggest.iconButtonOpened",
    defaultMessage: "Open the options menu",
    description: "A message shown in case when the autosuggest menu is closed."
  },
  iconButtonClosed: {
    id: "pgn.FormAutosuggest.iconButtonClosed",
    defaultMessage: "Close the options menu",
    description: "A message shown in case when the autosuggest menu is opened."
  }
};
function F5(o) {
  "@babel/helpers - typeof";
  return F5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, F5(o);
}
var jCe = ["children", "arrowKeyNavigationSelector", "ignoredArrowKeysNames", "screenReaderText", "value", "isLoading", "isValueRequired", "valueRequiredErrorMessageText", "isSelectionRequired", "selectionRequiredErrorMessageText", "hasCustomError", "customErrorMessageText", "onChange", "helpMessage"], UCe = ["children", "onClick"];
function Ooe() {
  return Ooe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, Ooe.apply(this, arguments);
}
function gue(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function bue(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? gue(Object(i), !0).forEach(function(u) {
      WCe(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : gue(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function WCe(o, r, i) {
  return r = ZCe(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function ZCe(o) {
  var r = GCe(o, "string");
  return F5(r) == "symbol" ? r : r + "";
}
function GCe(o, r) {
  if (F5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (F5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
function p0(o, r) {
  return XCe(o) || YCe(o, r) || KCe(o, r) || qCe();
}
function qCe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function KCe(o, r) {
  if (o) {
    if (typeof o == "string") return vue(o, r);
    var i = Object.prototype.toString.call(o).slice(8, -1);
    if (i === "Object" && o.constructor && (i = o.constructor.name), i === "Map" || i === "Set") return Array.from(o);
    if (i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return vue(o, r);
  }
}
function vue(o, r) {
  (r == null || r > o.length) && (r = o.length);
  for (var i = 0, u = new Array(r); i < r; i++) u[i] = o[i];
  return u;
}
function YCe(o, r) {
  var i = o == null ? null : typeof Symbol < "u" && o[Symbol.iterator] || o["@@iterator"];
  if (i != null) {
    var u, h, y, k, _ = [], D = !0, L = !1;
    try {
      if (y = (i = i.call(o)).next, r !== 0) for (; !(D = (u = y.call(i)).done) && (_.push(u.value), _.length !== r); D = !0) ;
    } catch (W) {
      L = !0, h = W;
    } finally {
      try {
        if (!D && i.return != null && (k = i.return(), Object(k) !== k)) return;
      } finally {
        if (L) throw h;
      }
    }
    return _;
  }
}
function XCe(o) {
  if (Array.isArray(o)) return o;
}
function yue(o, r) {
  if (o == null) return {};
  var i = QCe(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function QCe(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
var $se = /* @__PURE__ */ et.forwardRef(function(o, r) {
  var i = o.children, u = o.arrowKeyNavigationSelector, h = o.ignoredArrowKeysNames, y = o.screenReaderText, k = o.value, _ = o.isLoading, D = o.isValueRequired, L = o.valueRequiredErrorMessageText, W = o.isSelectionRequired, se = o.selectionRequiredErrorMessageText, J = o.hasCustomError, be = o.customErrorMessageText, ke = o.onChange, Ce = o.helpMessage, Q = yue(o, jCe), oe = kse(), ae = et.useRef(), G = VCe({
    selectors: u,
    ignoredKeys: h
  }), ve = et.useState(!1), nt = p0(ve, 2), Xe = nt[0], te = nt[1], lt = et.useState(!1), ot = p0(lt, 2), Kt = ot[0], je = ot[1], ye = et.useState(!1), dn = p0(ye, 2), wt = dn[0], qe = dn[1], B = et.useState(!1), mn = p0(B, 2), dt = mn[0], En = mn[1], tn = et.useState((k == null ? void 0 : k.userProvidedText) || ""), Le = p0(tn, 2), jt = Le[0], Fn = Le[1], St = et.useState([]), on = p0(St, 2), tt = on[0], mt = on[1], Y = et.useState(null), Wo = p0(Y, 2), To = Wo[0], Ot = Wo[1], Mt = et.useState(!0), zn = p0(Mt, 2), At = zn[0], $n = zn[1], en = et.useState(""), Ue = p0(en, 2), jn = Ue[0], mo = Ue[1], xn = function(Ir) {
    Ot(Ir);
  }, Vt = function() {
    mt([]), te(!1), Ot(null);
  }, Ct = function(Ir, Zo) {
    var Tr = Ir.currentTarget.getAttribute("data-value"), Ht = Ir.currentTarget.id;
    qe(!0), En(!0), Fn(Tr), ke && (!k || k && Tr !== k.selectionValue) && ke({
      userProvidedText: Tr,
      selectionValue: Tr,
      selectionId: Ht
    }), Vt(), Zo && Zo(Ir);
  };
  function Jn() {
    var or = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", Ir = Ve.Children.map(i, function(Zo) {
      var Tr, Ht = Zo.props, Ho = Ht.children, As = Ht.onClick, ra = yue(Ht, UCe), qs = (Tr = Zo.props.id) !== null && Tr !== void 0 ? Tr : ECe();
      return /* @__PURE__ */ Ve.cloneElement(Zo, bue(bue({}, ra), {}, {
        children: Ho,
        "data-value": Ho,
        onClick: function(kr) {
          return Ct(kr, As);
        },
        id: qs,
        onFocus: function() {
          return xn(qs);
        }
      }));
    });
    return or.length > 0 && (Ir = Ir.filter(function(Zo) {
      return Zo.props.children.toLowerCase().includes(or.toLowerCase());
    })), Ir;
  }
  var Pn = function() {
    mt(Jn(jt)), $n(!0), mo(""), te(!0);
  }, so = function() {
    Xe ? Vt() : Pn();
  }, pr = /* @__PURE__ */ Ve.createElement(aF, {
    className: "pgn__form-autosuggest__icon-button",
    "data-testid": "autosuggest-iconbutton",
    tabIndex: "-1",
    src: Xe ? fwe : dwe,
    iconAs: D3,
    size: "sm",
    variant: "secondary",
    alt: Xe ? oe.formatMessage(hue.iconButtonClosed) : oe.formatMessage(hue.iconButtonOpened),
    onClick: so
  }), nr = function() {
    je(!0);
  }, Ko = function() {
    if (J) {
      $n(!1), mo(be);
      return;
    }
    if (D && !wt) {
      $n(!1), mo(L);
      return;
    }
    if (wt && W && !dt) {
      $n(!1), mo(se);
      return;
    }
    $n(!0), mo("");
  };
  et.useImperativeHandle(r, function() {
    return {
      // expose updateErrorStateAndErrorMessage so consumers can trigger validation
      // when changing the value of the control externally
      updateErrorStateAndErrorMessage: Ko
    };
  });
  var Qo = function() {
    je(!1), Vt(), Ko();
  }, Mr = function(Ir) {
    if (Kt) {
      if (Ir.key === "Escape") {
        Ir.preventDefault(), ae && ae.current.focus(), Vt();
        return;
      }
      Ir.key === "Tab" && Qo();
    }
  }, at = function(Ir) {
    G.current && !G.current.contains(Ir.target) && Kt && Qo();
  };
  et.useEffect(function() {
    return document.addEventListener("keydown", Mr), document.addEventListener("click", at, !0), function() {
      document.removeEventListener("click", at, !0), document.removeEventListener("keydown", Mr);
    };
  }), et.useEffect(function() {
    var or;
    Fn(k && (or = k.userProvidedText) !== null && or !== void 0 ? or : ""), qe(!!k && !!k.userProvidedText), En(!!k && !!k.selectionValue);
  }, [k]);
  var kt = function() {
    Pn();
  }, yn = function(Ir) {
    var Zo = Ir.target.value;
    if (!Zo.length) {
      Fn(""), qe(!1), En(!1), mt([]), Vt(), ke && ke({
        userProvidedText: "",
        selectionValue: "",
        selectionId: ""
      });
      return;
    }
    qe(!0);
    var Tr = Jn(Zo);
    mt(Tr);
    var Ht = Tr.find(function(Ho) {
      return Ho.props.children.toLowerCase() === Zo.toLowerCase();
    });
    if (!Ht) {
      En(!1), Fn(Zo), ke && ke({
        userProvidedText: Zo,
        selectionValue: "",
        selectionId: ""
      });
      return;
    }
    En(!0), Fn(Ht.props.children), ke && ke({
      userProvidedText: Ht.props.children,
      selectionValue: Ht.props.children,
      selectionId: Ht.props.id
    });
  }, pn = Th(), Oo = pn.getControlProps, hr = Oo(Q);
  return /* @__PURE__ */ Ve.createElement("div", {
    className: "pgn__form-autosuggest__wrapper",
    ref: G,
    onFocus: nr
  }, /* @__PURE__ */ Ve.createElement("div", {
    "aria-live": "assertive",
    className: "sr-only",
    "data-testid": "autosuggest-screen-reader-options-count"
  }, "".concat(tt.length, " options found")), /* @__PURE__ */ Ve.createElement(K3, {
    controlId: hr.id,
    isInvalid: !At
  }, /* @__PURE__ */ Ve.createElement(Y3, Ooe({
    ref: ae,
    "aria-expanded": (tt.length > 0).toString(),
    "aria-owns": "pgn__form-autosuggest__dropdown-box",
    role: "combobox",
    "aria-autocomplete": "list",
    autoComplete: "off",
    value: jt,
    "aria-invalid": jn,
    "aria-activedescendant": To,
    onChange: yn,
    onClick: kt,
    trailingElement: pr,
    "data-testid": "autosuggest-textbox-input"
  }, hr)), Ce && At && /* @__PURE__ */ Ve.createElement(Aw, {
    type: "default"
  }, Ce), !At && /* @__PURE__ */ Ve.createElement(Aw, {
    type: "invalid",
    "feedback-for": hr.name
  }, jn)), /* @__PURE__ */ Ve.createElement("ul", {
    id: "pgn__form-autosuggest__dropdown-box",
    className: "pgn__form-autosuggest__dropdown",
    role: "listbox"
  }, _ ? /* @__PURE__ */ Ve.createElement("div", {
    className: "pgn__form-autosuggest__dropdown-loading"
  }, /* @__PURE__ */ Ve.createElement(Bse, {
    animation: "border",
    variant: "dark",
    screenReaderText: y,
    "data-testid": "autosuggest-loading-spinner"
  })) : tt.length > 0 && tt));
});
$se.defaultProps = {
  arrowKeyNavigationSelector: "a:not(:disabled),li:not(:disabled, .btn-icon),input:not(:disabled)",
  ignoredArrowKeysNames: ["ArrowRight", "ArrowLeft"],
  isLoading: !1,
  className: null,
  floatingLabel: null,
  onChange: null,
  helpMessage: "",
  placeholder: "",
  value: null,
  isValueRequired: !1,
  valueRequiredErrorMessageText: null,
  isSelectionRequired: !1,
  selectionRequiredErrorMessageText: null,
  hasCustomError: !1,
  customErrorMessageText: null,
  readOnly: !1,
  children: null,
  name: "form-autosuggest",
  screenReaderText: "loading"
};
$se.propTypes = {
  /**
   * Specifies the CSS selector string that indicates to which elements
   * the user can navigate using the arrow keys
  */
  arrowKeyNavigationSelector: ce.string,
  /** Specifies ignored hook keys. */
  ignoredArrowKeysNames: ce.arrayOf(ce.string),
  /** Specifies loading state. */
  isLoading: ce.bool,
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies floating label to display for the input component. */
  floatingLabel: ce.string,
  /** Specifies onChange event handler. */
  onChange: ce.func,
  /** Specifies help information for the user. */
  helpMessage: ce.string,
  /** Specifies the placeholder text for the input. */
  placeholder: ce.string,
  /** Specifies values for the input. */
  value: ce.shape({
    userProvidedText: ce.string,
    selectionValue: ce.string,
    selectionId: ce.string
  }),
  /** Specifies if empty values trigger an error state */
  isValueRequired: ce.bool,
  /** Informs user they must input a value. */
  valueRequiredErrorMessageText: Ote(ce.string, "isValueRequired"),
  /** Specifies if freeform values trigger an error state */
  isSelectionRequired: ce.bool,
  /** Informs user they must make a selection. */
  selectionRequiredErrorMessageText: Ote(ce.string, "isSelectionRequired"),
  /** Specifies the control is in a consumer provided error state */
  hasCustomError: ce.bool,
  /** Informs user of other errors. */
  customErrorMessageText: Ote(ce.string, "hasCustomError"),
  /** Specifies the name of the base input element. */
  name: ce.string,
  /** Selected list item is read-only. */
  readOnly: ce.bool,
  /** Specifies the content of the `FormAutosuggest`. */
  children: ce.node,
  /** Specifies the screen reader text */
  screenReaderText: ce.string
};
function B5(o) {
  "@babel/helpers - typeof";
  return B5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, B5(o);
}
var JCe = ["as", "children", "defaultSelected", "iconAfter", "iconBefore"];
function xue(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function wue(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? xue(Object(i), !0).forEach(function(u) {
      eSe(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : xue(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function eSe(o, r, i) {
  return r = tSe(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function tSe(o) {
  var r = nSe(o, "string");
  return B5(r) == "symbol" ? r : r + "";
}
function nSe(o, r) {
  if (B5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (B5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
function oSe(o, r) {
  if (o == null) return {};
  var i = rSe(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function rSe(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
function Lse(o) {
  var r = o.as, i = o.children;
  o.defaultSelected;
  var u = o.iconAfter, h = o.iconBefore, y = oSe(o, JCe), k = ns(y.className, "pgn__menu-item");
  return /* @__PURE__ */ Ve.createElement(r, wue(wue({}, y), {}, {
    className: k
  }), /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, h && /* @__PURE__ */ Ve.createElement(D3, {
    className: "btn-icon-before",
    src: h
  }), /* @__PURE__ */ Ve.createElement("span", {
    className: "pgn__menu-item-text"
  }, i), /* @__PURE__ */ Ve.createElement("span", {
    className: "pgn__menu-item-content-spacer"
  }), u && /* @__PURE__ */ Ve.createElement(D3, {
    className: "btn-icon-after",
    src: u
  })));
}
Lse.propTypes = {
  /** Specifies that this ``MenuItem`` is selected inside the ``SelectMenu`` */
  defaultSelected: ce.bool,
  /** Specifies class name to append to the base element */
  className: ce.string,
  /** Specifies the content of the ``MenuItem`` */
  children: ce.node,
  /** Specifies the base element */
  as: ce.elementType,
  /** Specifies the jsx before the content of the ``MenuItem`` */
  iconBefore: ce.oneOfType([ce.element, ce.elementType]),
  /** Specifies the jsx after the content of the ``MenuItem`` */
  iconAfter: ce.oneOfType([ce.element, ce.elementType])
};
Lse.defaultProps = {
  defaultSelected: !1,
  as: "button",
  className: void 0,
  children: null,
  iconBefore: void 0,
  iconAfter: void 0
};
var sSe = ["children", "className", "onClick"];
function Aoe() {
  return Aoe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, Aoe.apply(this, arguments);
}
function aSe(o, r) {
  if (o == null) return {};
  var i = iSe(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function iSe(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
function Hse(o) {
  var r = o.children, i = o.className, u = o.onClick, h = aSe(o, sSe);
  return /* @__PURE__ */ Ve.createElement(Lse, Aoe({
    as: "li",
    "data-testid": "autosuggest-optionitem",
    role: "option",
    tabIndex: "-1",
    onClick: u,
    className: ns(i, "dropdown-item")
  }, h), r);
}
Hse.defaultProps = {
  className: null,
  children: null,
  onClick: null
};
Hse.propTypes = {
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies the text-content of the `FormAutosuggestOption`. */
  children: ce.string,
  /** A click handler for the `FormAutosuggestOption` */
  onClick: ce.func
};
function $5(o) {
  "@babel/helpers - typeof";
  return $5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, $5(o);
}
function Cue(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function Sue(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? Cue(Object(i), !0).forEach(function(u) {
      lSe(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : Cue(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function lSe(o, r, i) {
  return r = cSe(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function cSe(o) {
  var r = uSe(o, "string");
  return $5(r) == "symbol" ? r : r + "";
}
function uSe(o, r) {
  if ($5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if ($5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
var dSe = function(r) {
  return r;
}, Fpe = /* @__PURE__ */ Ve.createContext({
  getCheckboxControlProps: dSe,
  hasCheckboxSetProvider: !1
}), Bpe = function() {
  return et.useContext(Fpe);
};
function zse(o) {
  var r = o.children, i = o.name, u = o.onBlur, h = o.onFocus, y = o.onChange, k = o.value, _ = o.defaultValue, D = !_ && Array.isArray(k), L = function(J) {
    return Sue(Sue({}, J), {}, {
      name: i,
      /* istanbul ignore next */
      onBlur: J.onBlur ? Ek(u, J.onBlur) : u,
      /* istanbul ignore next */
      onFocus: J.onFocus ? Ek(h, J.onFocus) : h,
      /* istanbul ignore next */
      onChange: J.onChange ? Ek(y, J.onChange) : y,
      checked: D ? k.includes(J.value) : void 0,
      defaultChecked: D ? void 0 : _ && _.includes(J.value)
    });
  }, W = {
    name: i,
    value: k,
    defaultValue: _,
    getCheckboxControlProps: L,
    onBlur: u,
    onFocus: h,
    onChange: y,
    hasCheckboxSetProvider: !0
  };
  return /* @__PURE__ */ Ve.createElement(Fpe.Provider, {
    value: W
  }, r);
}
zse.propTypes = {
  children: ce.node.isRequired,
  name: ce.string,
  onBlur: ce.func,
  onFocus: ce.func,
  onChange: ce.func,
  value: ce.arrayOf(ce.string),
  defaultValue: ce.arrayOf(ce.string)
};
zse.defaultProps = {
  onBlur: void 0,
  name: void 0,
  onFocus: void 0,
  onChange: void 0,
  value: void 0,
  defaultValue: void 0
};
function L5(o) {
  "@babel/helpers - typeof";
  return L5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, L5(o);
}
var fSe = ["isIndeterminate"], mSe = ["children", "className", "controlClassName", "labelClassName", "description", "isInvalid", "isValid", "controlAs", "floatLabelLeft"];
function ZV() {
  return ZV = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, ZV.apply(this, arguments);
}
function kue(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function l3(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? kue(Object(i), !0).forEach(function(u) {
      pSe(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : kue(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function pSe(o, r, i) {
  return r = hSe(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function hSe(o) {
  var r = gSe(o, "string");
  return L5(r) == "symbol" ? r : r + "";
}
function gSe(o, r) {
  if (L5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (L5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
function $pe(o, r) {
  if (o == null) return {};
  var i = bSe(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function bSe(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
var Vse = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.isIndeterminate, u = $pe(o, fSe), h = Bpe(), y = h.getCheckboxControlProps, k = h.hasCheckboxSetProvider, _ = Ve.useRef(), D = r || _, L = Th(), W = L.getControlProps, se = W(l3(l3({}, u), {}, {
    className: ns("pgn__form-checkbox-input", u.className)
  }));
  return k && (se = y(se)), Ve.useEffect(function() {
    D.current && (D.current.indeterminate = i);
  }, [D, i]), /* @__PURE__ */ Ve.createElement("input", ZV({
    type: "checkbox"
  }, se, {
    ref: D
  }));
});
Vse.propTypes = {
  /** Specifies whether the checkbox should be rendered in indeterminate state. */
  isIndeterminate: ce.bool,
  /** Specifies class name to append to the base element. */
  className: ce.string
};
Vse.defaultProps = {
  isIndeterminate: !1,
  className: void 0
};
var Bj = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.children, u = o.className, h = o.controlClassName, y = o.labelClassName, k = o.description, _ = o.isInvalid, D = o.isValid, L = o.controlAs, W = o.floatLabelLeft, se = $pe(o, mSe), J = Bpe(), be = J.hasCheckboxSetProvider, ke = Th(), Ce = ke.hasFormGroupProvider, Q = ke.useSetIsControlGroupEffect, oe = ke.getControlProps;
  Q(!0);
  var ae = Ce && !be, G = ae ? l3(l3({}, oe({})), {}, {
    role: "group"
  }) : {}, ve = /* @__PURE__ */ Ve.createElement(L, l3(l3({}, se), {}, {
    className: h,
    ref: r
  }));
  return /* @__PURE__ */ Ve.createElement(K3, {
    controlId: se.id,
    isInvalid: _,
    isValid: D
  }, /* @__PURE__ */ Ve.createElement("div", ZV({
    className: ns("pgn__form-checkbox", u, {
      "pgn__form-control-valid": D,
      "pgn__form-control-invalid": _,
      "pgn__form-control-disabled": se.disabled,
      "pgn__form-control-label-left": !!W
    })
  }, G), ve, /* @__PURE__ */ Ve.createElement("div", null, /* @__PURE__ */ Ve.createElement(cF, {
    className: y
  }, i), k && /* @__PURE__ */ Ve.createElement(Aw, {
    hasIcon: !1
  }, k))));
});
Bj.propTypes = {
  /** Specifies id of the FormCheckbox component. */
  id: ce.string,
  /** Specifies contents of the component. */
  children: ce.node.isRequired,
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies class name for control component. */
  controlClassName: ce.string,
  /** Specifies class name for label component. */
  labelClassName: ce.string,
  /** Specifies description to show under the checkbox. */
  description: ce.node,
  /** Specifies whether to display checkbox in invalid state, this affects styling. */
  isInvalid: ce.bool,
  /** Specifies whether to display checkbox in valid state, this affects styling. */
  isValid: ce.bool,
  /** Specifies control element. */
  controlAs: ce.elementType,
  /** Specifies whether the floating label should be aligned to the left. */
  floatLabelLeft: ce.bool,
  /** Specifies whether the `FormCheckbox` is disabled. */
  disabled: ce.bool
};
Bj.defaultProps = {
  id: void 0,
  className: void 0,
  controlClassName: void 0,
  labelClassName: void 0,
  description: void 0,
  isInvalid: !1,
  isValid: !1,
  controlAs: Vse,
  floatLabelLeft: !1,
  disabled: !1
};
function H5(o) {
  "@babel/helpers - typeof";
  return H5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, H5(o);
}
var vSe = ["isIndeterminate"], ySe = ["children", "className", "helperText"];
function GV() {
  return GV = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, GV.apply(this, arguments);
}
function _ue(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function Eue(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? _ue(Object(i), !0).forEach(function(u) {
      xSe(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : _ue(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function xSe(o, r, i) {
  return r = wSe(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function wSe(o) {
  var r = CSe(o, "string");
  return H5(r) == "symbol" ? r : r + "";
}
function CSe(o, r) {
  if (H5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (H5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
function Lpe(o, r) {
  if (o == null) return {};
  var i = SSe(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function SSe(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
var jse = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.isIndeterminate, u = Lpe(o, vSe), h = Ve.useRef(), y = r || h, k = Th(), _ = k.getControlProps, D = _(Eue(Eue({}, u), {}, {
    className: ns("pgn__form-switch-input", u.className)
  }));
  return Ve.useEffect(function() {
    y.current && (y.current.indeterminate = i);
  }, [y, i]), /* @__PURE__ */ Ve.createElement("input", GV({
    type: "checkbox"
  }, D, {
    ref: y
  }));
});
jse.propTypes = {
  /** Specifies whether input should be rendered in indeterminate state. */
  isIndeterminate: ce.bool,
  /** Specifies class name to append to the base element. */
  className: ce.string
};
jse.defaultProps = {
  isIndeterminate: !1,
  className: void 0
};
var Use = /* @__PURE__ */ Ve.forwardRef(function(o, r) {
  var i = o.children, u = o.className, h = o.helperText, y = Lpe(o, ySe);
  return /* @__PURE__ */ Ve.createElement("div", {
    className: "d-inline-flex flex-column"
  }, /* @__PURE__ */ Ve.createElement(Bj, GV({
    className: ns("pgn__form-switch", u)
  }, y, {
    role: "switch",
    ref: r,
    controlAs: jse,
    isValid: null,
    isInvalid: null,
    description: null
  }), i), h && /* @__PURE__ */ Ve.createElement("div", {
    className: "pgn__form-switch-helper-text"
  }, h));
});
Use.propTypes = {
  /** Specifies contents of the component. */
  children: ce.node.isRequired,
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies class name to append to the label element. */
  labelClassName: ce.string,
  /** Specifies helper text to display below the switch. */
  helperText: ce.node,
  /** Determines whether the label should float to the left when the switch is active. */
  floatLabelLeft: ce.bool
};
Use.defaultProps = {
  className: void 0,
  labelClassName: void 0,
  helperText: void 0,
  floatLabelLeft: !1
};
var kSe = ["children", "name", "value", "defaultValue", "isInline", "onChange", "onFocus", "onBlur"];
function Poe() {
  return Poe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, Poe.apply(this, arguments);
}
function _Se(o, r) {
  if (o == null) return {};
  var i = ESe(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function ESe(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
function $j(o) {
  var r = o.children, i = o.name, u = o.value, h = o.defaultValue, y = o.isInline, k = o.onChange, _ = o.onFocus, D = o.onBlur, L = _Se(o, kSe), W = Th(), se = W.getControlProps, J = W.useSetIsControlGroupEffect;
  J(!0);
  var be = se(L);
  return /* @__PURE__ */ Ve.createElement(zse, {
    name: i,
    value: u,
    defaultValue: h,
    onFocus: _,
    onBlur: D,
    onChange: k
  }, /* @__PURE__ */ Ve.createElement(Fj, Poe({
    role: "group",
    isInline: y
  }, be), r));
}
$j.propTypes = {
  /** Specifies contents of the component. */
  children: ce.node.isRequired,
  /** Specifies class name to append to the base element. */
  className: ce.string,
  /** Specifies name for the component. */
  name: ce.string.isRequired,
  /** Specifies values for the checkboxes. */
  value: ce.arrayOf(ce.string),
  /** Specifies default values for the checkboxes. */
  defaultValue: ce.arrayOf(ce.string),
  /** Specifies whether to display components with inline styling. */
  isInline: ce.bool,
  /** Specifies onChange event handler. */
  onChange: ce.func,
  /** Specifies onFocus event handler. */
  onFocus: ce.func,
  /** Specifies onBlur event handler. */
  onBlur: ce.func
};
$j.defaultProps = {
  className: void 0,
  value: void 0,
  defaultValue: void 0,
  isInline: !1,
  onChange: void 0,
  onFocus: void 0,
  onBlur: void 0
};
ji.Control = Y3;
ji.Radio = Ise;
ji.RadioSet = Fse;
ji.Autosuggest = $se;
ji.AutosuggestOption = Hse;
ji.Checkbox = Bj;
ji.CheckboxSet = $j;
ji.Switch = Use;
ji.SwitchSet = $j;
ji.Label = cF;
ji.Group = Rse;
ji.Text = Ij;
var rV = "right-scroll-bar-position", sV = "width-before-scroll-bar", TSe = "with-scroll-bars-hidden", OSe = "--removed-body-scroll-bar-size";
function Hte(o, r) {
  return typeof o == "function" ? o(r) : o && (o.current = r), o;
}
function ASe(o, r) {
  var i = et.useState(function() {
    return {
      // value
      value: o,
      // last callback
      callback: r,
      // "memoized" public interface
      facade: {
        get current() {
          return i.value;
        },
        set current(u) {
          var h = i.value;
          h !== u && (i.value = u, i.callback(u, h));
        }
      }
    };
  })[0];
  return i.callback = r, i.facade;
}
var PSe = typeof window < "u" ? et.useLayoutEffect : et.useEffect, Tue = /* @__PURE__ */ new WeakMap();
function Hpe(o, r) {
  var i = ASe(null, function(u) {
    return o.forEach(function(h) {
      return Hte(h, u);
    });
  });
  return PSe(function() {
    var u = Tue.get(i);
    if (u) {
      var h = new Set(u), y = new Set(o), k = i.current;
      h.forEach(function(_) {
        y.has(_) || Hte(_, null);
      }), y.forEach(function(_) {
        h.has(_) || Hte(_, k);
      });
    }
    Tue.set(i, o);
  }, [o]), i;
}
function zpe(o) {
  return o;
}
function Vpe(o, r) {
  r === void 0 && (r = zpe);
  var i = [], u = !1, h = {
    read: function() {
      if (u)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return i.length ? i[i.length - 1] : o;
    },
    useMedium: function(y) {
      var k = r(y, u);
      return i.push(k), function() {
        i = i.filter(function(_) {
          return _ !== k;
        });
      };
    },
    assignSyncMedium: function(y) {
      for (u = !0; i.length; ) {
        var k = i;
        i = [], k.forEach(y);
      }
      i = {
        push: function(_) {
          return y(_);
        },
        filter: function() {
          return i;
        }
      };
    },
    assignMedium: function(y) {
      u = !0;
      var k = [];
      if (i.length) {
        var _ = i;
        i = [], _.forEach(y), k = i;
      }
      var D = function() {
        var W = k;
        k = [], W.forEach(y);
      }, L = function() {
        return Promise.resolve().then(D);
      };
      L(), i = {
        push: function(W) {
          k.push(W), L();
        },
        filter: function(W) {
          return k = k.filter(W), i;
        }
      };
    }
  };
  return h;
}
function Wse(o, r) {
  return r === void 0 && (r = zpe), Vpe(o, r);
}
function Zse(o) {
  o === void 0 && (o = {});
  var r = Vpe(null);
  return r.options = Ld({ async: !0, ssr: !1 }, o), r;
}
var jpe = function(o) {
  var r = o.sideCar, i = B3(o, ["sideCar"]);
  if (!r)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var u = r.read();
  if (!u)
    throw new Error("Sidecar medium not found");
  return et.createElement(u, Ld({}, i));
};
jpe.isSideCarExport = !0;
function Gse(o, r) {
  return o.useMedium(r), jpe;
}
var Upe = Zse(), zte = function() {
}, qse = et.forwardRef(function(o, r) {
  var i = et.useRef(null), u = et.useState({
    onScrollCapture: zte,
    onWheelCapture: zte,
    onTouchMoveCapture: zte
  }), h = u[0], y = u[1], k = o.forwardProps, _ = o.children, D = o.className, L = o.removeScrollBar, W = o.enabled, se = o.shards, J = o.sideCar, be = o.noIsolation, ke = o.inert, Ce = o.allowPinchZoom, Q = o.as, oe = Q === void 0 ? "div" : Q, ae = o.gapMode, G = B3(o, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), ve = J, nt = Hpe([i, r]), Xe = Ld(Ld({}, G), h);
  return et.createElement(
    et.Fragment,
    null,
    W && et.createElement(ve, { sideCar: Upe, removeScrollBar: L, shards: se, noIsolation: be, inert: ke, setCallbacks: y, allowPinchZoom: !!Ce, lockRef: i, gapMode: ae }),
    k ? et.cloneElement(et.Children.only(_), Ld(Ld({}, Xe), { ref: nt })) : et.createElement(oe, Ld({}, Xe, { className: D, ref: nt }), _)
  );
});
qse.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
qse.classNames = {
  fullWidth: sV,
  zeroRight: rV
};
var Doe = "data-focus-lock", Wpe = "data-focus-lock-disabled", DSe = "data-no-focus-lock", RSe = "data-autofocus-inside", NSe = "data-no-autofocus", Vte = {
  width: "1px",
  height: "0px",
  padding: 0,
  overflow: "hidden",
  position: "fixed",
  top: "1px",
  left: "1px"
}, Zpe = Wse({}, function(o) {
  var r = o.target, i = o.currentTarget;
  return {
    target: r,
    currentTarget: i
  };
}), Gpe = Wse(), MSe = Wse(), qpe = Zse({
  async: !0,
  ssr: typeof document < "u"
}), ISe = /* @__PURE__ */ et.createContext(void 0), FSe = [], Kpe = /* @__PURE__ */ et.forwardRef(function(r, i) {
  var u, h = et.useState(), y = h[0], k = h[1], _ = et.useRef(), D = et.useRef(!1), L = et.useRef(null), W = et.useState({}), se = W[1], J = r.children, be = r.disabled, ke = be === void 0 ? !1 : be, Ce = r.noFocusGuards, Q = Ce === void 0 ? !1 : Ce, oe = r.persistentFocus, ae = oe === void 0 ? !1 : oe, G = r.crossFrame, ve = G === void 0 ? !0 : G, nt = r.autoFocus, Xe = nt === void 0 ? !0 : nt;
  r.allowTextSelection;
  var te = r.group, lt = r.className, ot = r.whiteList, Kt = r.hasPositiveIndices, je = r.shards, ye = je === void 0 ? FSe : je, dn = r.as, wt = dn === void 0 ? "div" : dn, qe = r.lockProps, B = qe === void 0 ? {} : qe, mn = r.sideCar, dt = r.returnFocus, En = dt === void 0 ? !1 : dt, tn = r.focusOptions, Le = r.onActivation, jt = r.onDeactivation, Fn = et.useState({}), St = Fn[0], on = et.useCallback(function(en) {
    var Ue = en.captureFocusRestore;
    if (!L.current) {
      var jn, mo = (jn = document) == null ? void 0 : jn.activeElement;
      L.current = mo, mo !== document.body && (L.current = Ue(mo));
    }
    _.current && Le && Le(_.current), D.current = !0, se();
  }, [Le]), tt = et.useCallback(function() {
    D.current = !1, jt && jt(_.current), se();
  }, [jt]), mt = et.useCallback(function(en) {
    var Ue = L.current;
    if (Ue) {
      var jn = (typeof Ue == "function" ? Ue() : Ue) || document.body, mo = typeof En == "function" ? En(jn) : En;
      if (mo) {
        var xn = typeof mo == "object" ? mo : void 0;
        L.current = null, en ? Promise.resolve().then(function() {
          return jn.focus(xn);
        }) : jn.focus(xn);
      }
    }
  }, [En]), Y = et.useCallback(function(en) {
    D.current && Zpe.useMedium(en);
  }, []), Wo = Gpe.useMedium, To = et.useCallback(function(en) {
    _.current !== en && (_.current = en, k(en));
  }, []), Ot = qr((u = {}, u[Wpe] = ke && "disabled", u[Doe] = te, u), B), Mt = Q !== !0, zn = Mt && Q !== "tail", At = Hpe([i, To]), $n = et.useMemo(function() {
    return {
      observed: _,
      shards: ye,
      enabled: !ke,
      active: D.current
    };
  }, [ke, D.current, ye, y]);
  return /* @__PURE__ */ et.createElement(et.Fragment, null, Mt && [
    /* @__PURE__ */ et.createElement("div", {
      key: "guard-first",
      "data-focus-guard": !0,
      tabIndex: ke ? -1 : 0,
      style: Vte
    }),
    Kt ? /* @__PURE__ */ et.createElement("div", {
      key: "guard-nearest",
      "data-focus-guard": !0,
      tabIndex: ke ? -1 : 1,
      style: Vte
    }) : null
  ], !ke && /* @__PURE__ */ et.createElement(mn, {
    id: St,
    sideCar: qpe,
    observed: y,
    disabled: ke,
    persistentFocus: ae,
    crossFrame: ve,
    autoFocus: Xe,
    whiteList: ot,
    shards: ye,
    onActivation: on,
    onDeactivation: tt,
    returnFocus: mt,
    focusOptions: tn
  }), /* @__PURE__ */ et.createElement(wt, qr({
    ref: At
  }, Ot, {
    className: lt,
    onBlur: Wo,
    onFocus: Y
  }), /* @__PURE__ */ et.createElement(ISe.Provider, {
    value: $n
  }, J)), zn && /* @__PURE__ */ et.createElement("div", {
    "data-focus-guard": !0,
    tabIndex: ke ? -1 : 0,
    style: Vte
  }));
});
Kpe.propTypes = {};
function Kse(o) {
  setTimeout(o, 1);
}
var BSe = function(r) {
  return r && "current" in r ? r.current : r;
}, Ype = Zse(), Xpe = "data-focus-on-hidden", $Se = { preventScroll: !0 }, LSe = et.forwardRef(function(o, r) {
  var i = et.useState(!1), u = i[0], h = i[1], y = o.children, k = o.autoFocus, _ = o.shards, D = o.crossFrame, L = o.enabled, W = L === void 0 ? !0 : L, se = o.scrollLock, J = se === void 0 ? !0 : se, be = o.focusLock, ke = be === void 0 ? !0 : be, Ce = o.returnFocus, Q = Ce === void 0 ? !0 : Ce, oe = o.inert, ae = o.allowPinchZoom, G = o.sideCar, ve = o.className, nt = o.shouldIgnore, Xe = o.preventScrollOnFocus, te = o.style, lt = o.as, ot = o.gapMode, Kt = B3(o, ["children", "autoFocus", "shards", "crossFrame", "enabled", "scrollLock", "focusLock", "returnFocus", "inert", "allowPinchZoom", "sideCar", "className", "shouldIgnore", "preventScrollOnFocus", "style", "as", "gapMode"]), je = G, ye = u.onActivation, dn = u.onDeactivation, wt = B3(u, ["onActivation", "onDeactivation"]), qe = Ld(Ld({}, wt), {
    as: lt,
    style: te,
    sideCar: G,
    shards: _,
    allowPinchZoom: ae,
    gapMode: ot,
    inert: oe,
    enabled: W && J
  });
  return et.createElement(
    et.Fragment,
    null,
    et.createElement(Kpe, { ref: r, sideCar: G, disabled: !(u && W && ke), returnFocus: Q, autoFocus: k, shards: _, crossFrame: D, onActivation: ye, onDeactivation: dn, className: ve, whiteList: nt, lockProps: qe, focusOptions: Xe ? $Se : void 0, as: qse }, y),
    W && et.createElement(je, Ld({}, Kt, { sideCar: Ype, setLockProps: h, shards: _ }))
  );
});
function z5(o) {
  "@babel/helpers - typeof";
  return z5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, z5(o);
}
function HSe(o, r) {
  if (z5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (z5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
function zSe(o) {
  var r = HSe(o, "string");
  return z5(r) == "symbol" ? r : r + "";
}
function VSe(o, r, i) {
  return (r = zSe(r)) in o ? Object.defineProperty(o, r, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : o[r] = i, o;
}
function jSe(o, r) {
  function i(u) {
    return u.displayName || u.name || "Component";
  }
  return function(h) {
    var y = [], k;
    function _() {
      k = o(y.map(function(L) {
        return L.props;
      })), r(k);
    }
    var D = /* @__PURE__ */ function(L) {
      vse(W, L);
      function W() {
        return L.apply(this, arguments) || this;
      }
      W.peek = function() {
        return k;
      };
      var se = W.prototype;
      return se.componentDidMount = function() {
        y.push(this), _();
      }, se.componentDidUpdate = function() {
        _();
      }, se.componentWillUnmount = function() {
        var be = y.indexOf(this);
        y.splice(be, 1), _();
      }, se.render = function() {
        return /* @__PURE__ */ Ve.createElement(h, this.props);
      }, W;
    }(et.PureComponent);
    return VSe(D, "displayName", "SideEffect(" + i(h) + ")"), D;
  };
}
var Cv = function(o) {
  for (var r = Array(o.length), i = 0; i < o.length; ++i)
    r[i] = o[i];
  return r;
}, Ik = function(o) {
  return Array.isArray(o) ? o : [o];
}, Qpe = function(o) {
  return Array.isArray(o) ? o[0] : o;
}, USe = function(o) {
  if (o.nodeType !== Node.ELEMENT_NODE)
    return !1;
  var r = window.getComputedStyle(o, null);
  return !r || !r.getPropertyValue ? !1 : r.getPropertyValue("display") === "none" || r.getPropertyValue("visibility") === "hidden";
}, Jpe = function(o) {
  return o.parentNode && o.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    o.parentNode.host
  ) : o.parentNode;
}, ehe = function(o) {
  return o === document || o && o.nodeType === Node.DOCUMENT_NODE;
}, WSe = function(o) {
  return o.hasAttribute("inert");
}, ZSe = function(o, r) {
  return !o || ehe(o) || !USe(o) && !WSe(o) && r(Jpe(o));
}, the = function(o, r) {
  var i = o.get(r);
  if (i !== void 0)
    return i;
  var u = ZSe(r, the.bind(void 0, o));
  return o.set(r, u), u;
}, GSe = function(o, r) {
  return o && !ehe(o) ? YSe(o) ? r(Jpe(o)) : !1 : !0;
}, nhe = function(o, r) {
  var i = o.get(r);
  if (i !== void 0)
    return i;
  var u = GSe(r, nhe.bind(void 0, o));
  return o.set(r, u), u;
}, ohe = function(o) {
  return o.dataset;
}, qSe = function(o) {
  return o.tagName === "BUTTON";
}, rhe = function(o) {
  return o.tagName === "INPUT";
}, she = function(o) {
  return rhe(o) && o.type === "radio";
}, KSe = function(o) {
  return !((rhe(o) || qSe(o)) && (o.type === "hidden" || o.disabled));
}, YSe = function(o) {
  var r = o.getAttribute(NSe);
  return ![!0, "true", ""].includes(r);
}, Yse = function(o) {
  var r;
  return !!(o && (!((r = ohe(o)) === null || r === void 0) && r.focusGuard));
}, Roe = function(o) {
  return !Yse(o);
}, XSe = function(o) {
  return !!o;
}, QSe = function(o, r) {
  var i = Math.max(0, o.tabIndex), u = Math.max(0, r.tabIndex), h = i - u, y = o.index - r.index;
  if (h) {
    if (!i)
      return 1;
    if (!u)
      return -1;
  }
  return h || y;
}, JSe = function(o) {
  return o.tabIndex < 0 && !o.hasAttribute("tabindex") ? 0 : o.tabIndex;
}, Xse = function(o, r, i) {
  return Cv(o).map(function(u, h) {
    var y = JSe(u);
    return {
      node: u,
      index: h,
      tabIndex: i && y === -1 ? (u.dataset || {}).focusGuard ? 0 : -1 : y
    };
  }).filter(function(u) {
    return !r || u.tabIndex >= 0;
  }).sort(QSe);
}, eke = [
  "button:enabled",
  "select:enabled",
  "textarea:enabled",
  "input:enabled",
  // elements with explicit roles will also use explicit tabindex
  // '[role="button"]',
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[tabindex]",
  "[contenteditable]",
  "[autofocus]"
], Qse = eke.join(","), tke = "".concat(Qse, ", [data-focus-guard]"), ahe = function(o, r) {
  return Cv((o.shadowRoot || o).children).reduce(function(i, u) {
    return i.concat(u.matches(r ? tke : Qse) ? [u] : [], ahe(u));
  }, []);
}, nke = function(o, r) {
  var i;
  return o instanceof HTMLIFrameElement && (!((i = o.contentDocument) === null || i === void 0) && i.body) ? $3([o.contentDocument.body], r) : [o];
}, $3 = function(o, r) {
  return o.reduce(function(i, u) {
    var h, y = ahe(u, r), k = (h = []).concat.apply(h, y.map(function(_) {
      return nke(_, r);
    }));
    return i.concat(
      // add all tabbables inside and within shadow DOMs in DOM order
      k,
      // add if node is tabbable itself
      u.parentNode ? Cv(u.parentNode.querySelectorAll(Qse)).filter(function(_) {
        return _ === u;
      }) : []
    );
  }, []);
}, oke = function(o) {
  var r = o.querySelectorAll("[".concat(RSe, "]"));
  return Cv(r).map(function(i) {
    return $3([i]);
  }).reduce(function(i, u) {
    return i.concat(u);
  }, []);
}, Jse = function(o, r) {
  return Cv(o).filter(function(i) {
    return the(r, i);
  }).filter(function(i) {
    return KSe(i);
  });
}, Oue = function(o, r) {
  return r === void 0 && (r = /* @__PURE__ */ new Map()), Cv(o).filter(function(i) {
    return nhe(r, i);
  });
}, eae = function(o, r, i) {
  return Xse(Jse($3(o, i), r), !0, i);
}, qV = function(o, r) {
  return Xse(Jse($3(o), r), !1);
}, rke = function(o, r) {
  return Jse(oke(o), r);
}, Tk = function(o, r) {
  return o.shadowRoot ? Tk(o.shadowRoot, r) : Object.getPrototypeOf(o).contains !== void 0 && Object.getPrototypeOf(o).contains.call(o, r) ? !0 : Cv(o.children).some(function(i) {
    var u;
    if (i instanceof HTMLIFrameElement) {
      var h = (u = i.contentDocument) === null || u === void 0 ? void 0 : u.body;
      return h ? Tk(h, r) : !1;
    }
    return Tk(i, r);
  });
}, ske = function(o) {
  for (var r = /* @__PURE__ */ new Set(), i = o.length, u = 0; u < i; u += 1)
    for (var h = u + 1; h < i; h += 1) {
      var y = o[u].compareDocumentPosition(o[h]);
      (y & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0 && r.add(h), (y & Node.DOCUMENT_POSITION_CONTAINS) > 0 && r.add(u);
    }
  return o.filter(function(k, _) {
    return !r.has(_);
  });
}, ihe = function(o) {
  return o.parentNode ? ihe(o.parentNode) : o;
}, tae = function(o) {
  var r = Ik(o);
  return r.filter(Boolean).reduce(function(i, u) {
    var h = u.getAttribute(Doe);
    return i.push.apply(i, h ? ske(Cv(ihe(u).querySelectorAll("[".concat(Doe, '="').concat(h, '"]:not([').concat(Wpe, '="disabled"])')))) : [u]), i;
  }, []);
}, ake = function(o) {
  try {
    return o();
  } catch {
    return;
  }
}, V5 = function(o) {
  if (o === void 0 && (o = document), !(!o || !o.activeElement)) {
    var r = o.activeElement;
    return r.shadowRoot ? V5(r.shadowRoot) : r instanceof HTMLIFrameElement && ake(function() {
      return r.contentWindow.document;
    }) ? V5(r.contentWindow.document) : r;
  }
}, ike = function(o, r) {
  return o === r;
}, lke = function(o, r) {
  return !!Cv(o.querySelectorAll("iframe")).some(function(i) {
    return ike(i, r);
  });
}, lhe = function(o, r) {
  return r === void 0 && (r = V5(Qpe(o).ownerDocument)), !r || r.dataset && r.dataset.focusGuard ? !1 : tae(o).some(function(i) {
    return Tk(i, r) || lke(i, r);
  });
}, cke = function(o) {
  o === void 0 && (o = document);
  var r = V5(o);
  return r ? Cv(o.querySelectorAll("[".concat(DSe, "]"))).some(function(i) {
    return Tk(i, r);
  }) : !1;
}, uke = function(o, r) {
  return r.filter(she).filter(function(i) {
    return i.name === o.name;
  }).filter(function(i) {
    return i.checked;
  })[0] || o;
}, nae = function(o, r) {
  return she(o) && o.name ? uke(o, r) : o;
}, dke = function(o) {
  var r = /* @__PURE__ */ new Set();
  return o.forEach(function(i) {
    return r.add(nae(i, o));
  }), o.filter(function(i) {
    return r.has(i);
  });
}, Aue = function(o) {
  return o[0] && o.length > 1 ? nae(o[0], o) : o[0];
}, Pue = function(o, r) {
  return o.indexOf(nae(r, o));
}, Noe = "NEW_FOCUS", fke = function(o, r, i, u, h) {
  var y = o.length, k = o[0], _ = o[y - 1], D = Yse(u);
  if (!(u && o.indexOf(u) >= 0)) {
    var L = u !== void 0 ? i.indexOf(u) : -1, W = h ? i.indexOf(h) : L, se = h ? o.indexOf(h) : -1;
    if (L === -1)
      return se !== -1 ? se : Noe;
    if (se === -1)
      return Noe;
    var J = L - W, be = i.indexOf(k), ke = i.indexOf(_), Ce = dke(i), Q = u !== void 0 ? Ce.indexOf(u) : -1, oe = Q - (h ? Ce.indexOf(h) : L);
    if (!J && se >= 0 || r.length === 0)
      return se;
    var ae = Pue(o, r[0]), G = Pue(o, r[r.length - 1]);
    if (L <= be && D && Math.abs(J) > 1)
      return G;
    if (L >= ke && D && Math.abs(J) > 1)
      return ae;
    if (J && Math.abs(oe) > 1)
      return se;
    if (L <= be)
      return G;
    if (L > ke)
      return ae;
    if (J)
      return Math.abs(J) > 1 ? se : (y + se + J) % y;
  }
}, mke = function(o) {
  return function(r) {
    var i, u = (i = ohe(r)) === null || i === void 0 ? void 0 : i.autofocus;
    return (
      // @ts-expect-error
      r.autofocus || //
      u !== void 0 && u !== "false" || //
      o.indexOf(r) >= 0
    );
  };
}, Due = function(o, r, i) {
  var u = o.map(function(y) {
    var k = y.node;
    return k;
  }), h = Oue(u.filter(mke(i)));
  return h && h.length ? Aue(h) : Aue(Oue(r));
}, Moe = function(o, r) {
  return r === void 0 && (r = []), r.push(o), o.parentNode && Moe(o.parentNode.host || o.parentNode, r), r;
}, jte = function(o, r) {
  for (var i = Moe(o), u = Moe(r), h = 0; h < i.length; h += 1) {
    var y = i[h];
    if (u.indexOf(y) >= 0)
      return y;
  }
  return !1;
}, che = function(o, r, i) {
  var u = Ik(o), h = Ik(r), y = u[0], k = !1;
  return h.filter(Boolean).forEach(function(_) {
    k = jte(k || _, _) || k, i.filter(Boolean).forEach(function(D) {
      var L = jte(y, D);
      L && (!k || Tk(L, k) ? k = L : k = jte(L, k));
    });
  }), k;
}, Rue = function(o, r) {
  return o.reduce(function(i, u) {
    return i.concat(rke(u, r));
  }, []);
}, pke = function(o, r) {
  var i = /* @__PURE__ */ new Map();
  return r.forEach(function(u) {
    return i.set(u.node, u);
  }), o.map(function(u) {
    return i.get(u);
  }).filter(XSe);
}, hke = function(o, r) {
  var i = V5(Ik(o).length > 0 ? document : Qpe(o).ownerDocument), u = tae(o).filter(Roe), h = che(i || o, o, u), y = /* @__PURE__ */ new Map(), k = qV(u, y), _ = k.filter(function(ke) {
    var Ce = ke.node;
    return Roe(Ce);
  });
  if (_[0]) {
    var D = qV([h], y).map(function(ke) {
      var Ce = ke.node;
      return Ce;
    }), L = pke(D, _), W = L.map(function(ke) {
      var Ce = ke.node;
      return Ce;
    }), se = L.filter(function(ke) {
      var Ce = ke.tabIndex;
      return Ce >= 0;
    }).map(function(ke) {
      var Ce = ke.node;
      return Ce;
    }), J = fke(W, se, D, i, r);
    if (J === Noe) {
      var be = (
        // first try only tabbable, and the fallback to all focusable, as long as at least one element should be picked for focus
        Due(k, se, Rue(u, y)) || Due(k, W, Rue(u, y))
      );
      if (be)
        return { node: be };
      console.warn("focus-lock: cannot find any node to move focus into");
      return;
    }
    return J === void 0 ? J : L[J];
  }
}, gke = function(o) {
  var r = tae(o).filter(Roe), i = che(o, o, r), u = Xse($3([i], !0), !0, !0), h = $3(r, !1);
  return u.map(function(y) {
    var k = y.node, _ = y.index;
    return {
      node: k,
      index: _,
      lockItem: h.indexOf(k) >= 0,
      guard: Yse(k)
    };
  });
}, oae = function(o, r) {
  o && ("focus" in o && o.focus(r), "contentWindow" in o && o.contentWindow && o.contentWindow.focus());
}, Ute = 0, Wte = !1, uhe = function(o, r, i) {
  i === void 0 && (i = {});
  var u = hke(o, r);
  if (!Wte && u) {
    if (Ute > 2) {
      console.error("FocusLock: focus-fighting detected. Only one focus management system could be active. See https://github.com/theKashey/focus-lock/#focus-fighting"), Wte = !0, setTimeout(function() {
        Wte = !1;
      }, 1);
      return;
    }
    Ute++, oae(u.node, i.focusOptions), Ute--;
  }
};
function EI(o) {
  if (!o)
    return null;
  if (typeof WeakRef > "u")
    return function() {
      return o || null;
    };
  var r = o ? new WeakRef(o) : null;
  return function() {
    return (r == null ? void 0 : r.deref()) || null;
  };
}
var bke = function(o) {
  if (!o)
    return null;
  for (var r = [], i = o; i && i !== document.body; )
    r.push({
      current: EI(i),
      parent: EI(i.parentElement),
      left: EI(i.previousElementSibling),
      right: EI(i.nextElementSibling)
    }), i = i.parentElement;
  return {
    element: EI(o),
    stack: r,
    ownerDocument: o.ownerDocument
  };
}, vke = function(o) {
  var r, i, u, h, y;
  if (o)
    for (var k = o.stack, _ = o.ownerDocument, D = /* @__PURE__ */ new Map(), L = 0, W = k; L < W.length; L++) {
      var se = W[L], J = (r = se.parent) === null || r === void 0 ? void 0 : r.call(se);
      if (J && _.contains(J)) {
        for (var be = (i = se.left) === null || i === void 0 ? void 0 : i.call(se), ke = se.current(), Ce = J.contains(ke) ? ke : void 0, Q = (u = se.right) === null || u === void 0 ? void 0 : u.call(se), oe = eae([J], D), ae = (
          // that is element itself
          (y = (h = Ce ?? // or something in it's place
          (be == null ? void 0 : be.nextElementSibling)) !== null && h !== void 0 ? h : (
            // or somebody to the right, still close enough
            Q
          )) !== null && y !== void 0 ? y : (
            // or somebody to the left, something?
            be
          )
        ); ae; ) {
          for (var G = 0, ve = oe; G < ve.length; G++) {
            var nt = ve[G];
            if (ae != null && ae.contains(nt.node))
              return nt.node;
          }
          ae = ae.nextElementSibling;
        }
        if (oe.length)
          return oe[0].node;
      }
    }
}, yke = function(o) {
  var r = bke(o);
  return function() {
    return vke(r);
  };
}, xke = function(o, r, i) {
  if (!o || !r)
    return console.error("no element or scope given"), {};
  var u = Ik(r);
  if (u.every(function(k) {
    return !Tk(k, o);
  }))
    return console.error("Active element is not contained in the scope"), {};
  var h = i ? eae(u, /* @__PURE__ */ new Map()) : qV(u, /* @__PURE__ */ new Map()), y = h.findIndex(function(k) {
    var _ = k.node;
    return _ === o;
  });
  if (y !== -1)
    return {
      prev: h[y - 1],
      next: h[y + 1],
      first: h[0],
      last: h[h.length - 1]
    };
}, wke = function(o, r) {
  var i = r ? eae(Ik(o), /* @__PURE__ */ new Map()) : qV(Ik(o), /* @__PURE__ */ new Map());
  return {
    first: i[0],
    last: i[i.length - 1]
  };
}, Cke = function(o) {
  return Object.assign({
    scope: document.body,
    cycle: !0,
    onlyTabbable: !0
  }, o);
}, dhe = function(o, r, i) {
  r === void 0 && (r = {});
  var u = Cke(r), h = xke(o, u.scope, u.onlyTabbable);
  if (h) {
    var y = i(h, u.cycle);
    y && oae(y.node, u.focusOptions);
  }
}, Ske = function(o, r) {
  r === void 0 && (r = {}), dhe(o, r, function(i, u) {
    var h = i.next, y = i.first;
    return h || u && y;
  });
}, kke = function(o, r) {
  r === void 0 && (r = {}), dhe(o, r, function(i, u) {
    var h = i.prev, y = i.last;
    return h || u && y;
  });
}, fhe = function(o, r, i) {
  var u, h = wke(o, (u = r.onlyTabbable) !== null && u !== void 0 ? u : !0), y = h[i];
  y && oae(y.node, r.focusOptions);
}, _ke = function(o, r) {
  r === void 0 && (r = {}), fhe(o, r, "first");
}, Eke = function(o, r) {
  r === void 0 && (r = {}), fhe(o, r, "last");
}, Tke = function() {
  return document && document.activeElement === document.body;
}, Oke = function() {
  return Tke() || cke();
}, C3 = null, c3 = null, S3 = null, j5 = !1, Ake = function() {
  return !0;
}, Pke = function(r) {
  return (C3.whiteList || Ake)(r);
}, Dke = function(r, i) {
  S3 = {
    observerNode: r,
    portaledElement: i
  };
}, Rke = function(r) {
  return S3 && S3.portaledElement === r;
};
function Nue(o, r, i, u) {
  var h = null, y = o;
  do {
    var k = u[y];
    if (k.guard)
      k.node.dataset.focusAutoGuard && (h = k);
    else if (k.lockItem) {
      if (y !== o)
        return;
      h = null;
    } else
      break;
  } while ((y += i) !== r);
  h && (h.node.tabIndex = 0);
}
var Nke = function(r) {
  return r ? !!j5 : j5 === "meanwhile";
}, Mke = function o(r, i, u) {
  return i && (i.host === r && (!i.activeElement || u.contains(i.activeElement)) || i.parentNode && o(r, i.parentNode, u));
}, Ike = function(r, i) {
  return i.some(function(u) {
    return Mke(r, u, u);
  });
}, KV = function() {
  var r = !1;
  if (C3) {
    var i = C3, u = i.observed, h = i.persistentFocus, y = i.autoFocus, k = i.shards, _ = i.crossFrame, D = i.focusOptions, L = u || S3 && S3.portaledElement, W = document && document.activeElement;
    if (L) {
      var se = [L].concat(k.map(BSe).filter(Boolean));
      if ((!W || Pke(W)) && (h || Nke(_) || !Oke() || !c3 && y) && (L && !(lhe(se) || W && Ike(W, se) || Rke(W)) && (document && !c3 && W && !y ? (W.blur && W.blur(), document.body.focus()) : (r = uhe(se, c3, {
        focusOptions: D
      }), S3 = {})), j5 = !1, c3 = document && document.activeElement), document && W !== document.activeElement && document.querySelector("[data-focus-auto-guard]")) {
        var J = document && document.activeElement, be = gke(se), ke = be.map(function(Ce) {
          var Q = Ce.node;
          return Q;
        }).indexOf(J);
        ke > -1 && (be.filter(function(Ce) {
          var Q = Ce.guard, oe = Ce.node;
          return Q && oe.dataset.focusAutoGuard;
        }).forEach(function(Ce) {
          var Q = Ce.node;
          return Q.removeAttribute("tabIndex");
        }), Nue(ke, be.length, 1, be), Nue(ke, -1, -1, be));
      }
    }
  }
  return r;
}, mhe = function(r) {
  KV() && r && (r.stopPropagation(), r.preventDefault());
}, rae = function() {
  return Kse(KV);
}, Fke = function(r) {
  var i = r.target, u = r.currentTarget;
  u.contains(i) || Dke(u, i);
}, Bke = function() {
  return null;
}, phe = function() {
  j5 = "just", Kse(function() {
    j5 = "meanwhile";
  });
}, $ke = function() {
  document.addEventListener("focusin", mhe), document.addEventListener("focusout", rae), window.addEventListener("blur", phe);
}, Lke = function() {
  document.removeEventListener("focusin", mhe), document.removeEventListener("focusout", rae), window.removeEventListener("blur", phe);
};
function Hke(o) {
  return o.filter(function(r) {
    var i = r.disabled;
    return !i;
  });
}
var hhe = {
  moveFocusInside: uhe,
  focusInside: lhe,
  focusNextElement: Ske,
  focusPrevElement: kke,
  focusFirstElement: _ke,
  focusLastElement: Eke,
  captureFocusRestore: yke
};
function zke(o) {
  var r = o.slice(-1)[0];
  r && !C3 && $ke();
  var i = C3, u = i && r && r.id === i.id;
  C3 = r, i && !u && (i.onDeactivation(), o.filter(function(h) {
    var y = h.id;
    return y === i.id;
  }).length || i.returnFocus(!r)), r ? (c3 = null, (!u || i.observed !== r.observed) && r.onActivation(hhe), KV(), Kse(KV)) : (Lke(), c3 = null);
}
Zpe.assignSyncMedium(Fke);
Gpe.assignMedium(rae);
MSe.assignMedium(function(o) {
  return o(hhe);
});
const Vke = jSe(Hke, zke)(Bke);
Gse(qpe, Vke);
var jke = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function Uke() {
  if (!document)
    return null;
  var o = document.createElement("style");
  o.type = "text/css";
  var r = jke();
  return r && o.setAttribute("nonce", r), o;
}
function Wke(o, r) {
  o.styleSheet ? o.styleSheet.cssText = r : o.appendChild(document.createTextNode(r));
}
function Zke(o) {
  var r = document.head || document.getElementsByTagName("head")[0];
  r.appendChild(o);
}
var Gke = function() {
  var o = 0, r = null;
  return {
    add: function(i) {
      o == 0 && (r = Uke()) && (Wke(r, i), Zke(r)), o++;
    },
    remove: function() {
      o--, !o && r && (r.parentNode && r.parentNode.removeChild(r), r = null);
    }
  };
}, qke = function() {
  var o = Gke();
  return function(r, i) {
    et.useEffect(function() {
      return o.add(r), function() {
        o.remove();
      };
    }, [r && i]);
  };
}, sae = function() {
  var o = qke(), r = function(i) {
    var u = i.styles, h = i.dynamic;
    return o(u, h), null;
  };
  return r;
}, Kke = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, Zte = function(o) {
  return parseInt(o || "", 10) || 0;
}, Yke = function(o) {
  var r = window.getComputedStyle(document.body), i = r[o === "padding" ? "paddingLeft" : "marginLeft"], u = r[o === "padding" ? "paddingTop" : "marginTop"], h = r[o === "padding" ? "paddingRight" : "marginRight"];
  return [Zte(i), Zte(u), Zte(h)];
}, Xke = function(o) {
  if (o === void 0 && (o = "margin"), typeof window > "u")
    return Kke;
  var r = Yke(o), i = document.documentElement.clientWidth, u = window.innerWidth;
  return {
    left: r[0],
    top: r[1],
    right: r[2],
    gap: Math.max(0, u - i + r[2] - r[0])
  };
}, Qke = sae(), k3 = "data-scroll-locked", Jke = function(o, r, i, u) {
  var h = o.left, y = o.top, k = o.right, _ = o.gap;
  return i === void 0 && (i = "margin"), `
  .`.concat(TSe, ` {
   overflow: hidden `).concat(u, `;
   padding-right: `).concat(_, "px ").concat(u, `;
  }
  body[`).concat(k3, `] {
    overflow: hidden `).concat(u, `;
    overscroll-behavior: contain;
    `).concat([
    r && "position: relative ".concat(u, ";"),
    i === "margin" && `
    padding-left: `.concat(h, `px;
    padding-top: `).concat(y, `px;
    padding-right: `).concat(k, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(_, "px ").concat(u, `;
    `),
    i === "padding" && "padding-right: ".concat(_, "px ").concat(u, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(rV, ` {
    right: `).concat(_, "px ").concat(u, `;
  }
  
  .`).concat(sV, ` {
    margin-right: `).concat(_, "px ").concat(u, `;
  }
  
  .`).concat(rV, " .").concat(rV, ` {
    right: 0 `).concat(u, `;
  }
  
  .`).concat(sV, " .").concat(sV, ` {
    margin-right: 0 `).concat(u, `;
  }
  
  body[`).concat(k3, `] {
    `).concat(OSe, ": ").concat(_, `px;
  }
`);
}, Mue = function() {
  var o = parseInt(document.body.getAttribute(k3) || "0", 10);
  return isFinite(o) ? o : 0;
}, e_e = function() {
  et.useEffect(function() {
    return document.body.setAttribute(k3, (Mue() + 1).toString()), function() {
      var o = Mue() - 1;
      o <= 0 ? document.body.removeAttribute(k3) : document.body.setAttribute(k3, o.toString());
    };
  }, []);
}, t_e = function(o) {
  var r = o.noRelative, i = o.noImportant, u = o.gapMode, h = u === void 0 ? "margin" : u;
  e_e();
  var y = et.useMemo(function() {
    return Xke(h);
  }, [h]);
  return et.createElement(Qke, { styles: Jke(y, !r, h, i ? "" : "!important") });
}, Ioe = !1;
if (typeof window < "u")
  try {
    var B9 = Object.defineProperty({}, "passive", {
      get: function() {
        return Ioe = !0, !0;
      }
    });
    window.addEventListener("test", B9, B9), window.removeEventListener("test", B9, B9);
  } catch {
    Ioe = !1;
  }
var GA = Ioe ? { passive: !1 } : !1, n_e = function(o) {
  return o.tagName === "TEXTAREA";
}, ghe = function(o, r) {
  if (!(o instanceof Element))
    return !1;
  var i = window.getComputedStyle(o);
  return (
    // not-not-scrollable
    i[r] !== "hidden" && // contains scroll inside self
    !(i.overflowY === i.overflowX && !n_e(o) && i[r] === "visible")
  );
}, o_e = function(o) {
  return ghe(o, "overflowY");
}, r_e = function(o) {
  return ghe(o, "overflowX");
}, Iue = function(o, r) {
  var i = r.ownerDocument, u = r;
  do {
    typeof ShadowRoot < "u" && u instanceof ShadowRoot && (u = u.host);
    var h = bhe(o, u);
    if (h) {
      var y = vhe(o, u), k = y[1], _ = y[2];
      if (k > _)
        return !0;
    }
    u = u.parentNode;
  } while (u && u !== i.body);
  return !1;
}, s_e = function(o) {
  var r = o.scrollTop, i = o.scrollHeight, u = o.clientHeight;
  return [
    r,
    i,
    u
  ];
}, a_e = function(o) {
  var r = o.scrollLeft, i = o.scrollWidth, u = o.clientWidth;
  return [
    r,
    i,
    u
  ];
}, bhe = function(o, r) {
  return o === "v" ? o_e(r) : r_e(r);
}, vhe = function(o, r) {
  return o === "v" ? s_e(r) : a_e(r);
}, i_e = function(o, r) {
  return o === "h" && r === "rtl" ? -1 : 1;
}, l_e = function(o, r, i, u, h) {
  var y = i_e(o, window.getComputedStyle(r).direction), k = y * u, _ = i.target, D = r.contains(_), L = !1, W = k > 0, se = 0, J = 0;
  do {
    var be = vhe(o, _), ke = be[0], Ce = be[1], Q = be[2], oe = Ce - Q - y * ke;
    (ke || oe) && bhe(o, _) && (se += oe, J += ke), _ instanceof ShadowRoot ? _ = _.host : _ = _.parentNode;
  } while (
    // portaled content
    !D && _ !== document.body || // self content
    D && (r.contains(_) || r === _)
  );
  return (W && (Math.abs(se) < 1 || !h) || !W && (Math.abs(J) < 1 || !h)) && (L = !0), L;
}, $9 = function(o) {
  return "changedTouches" in o ? [o.changedTouches[0].clientX, o.changedTouches[0].clientY] : [0, 0];
}, Fue = function(o) {
  return [o.deltaX, o.deltaY];
}, Bue = function(o) {
  return o && "current" in o ? o.current : o;
}, c_e = function(o, r) {
  return o[0] === r[0] && o[1] === r[1];
}, u_e = function(o) {
  return `
  .block-interactivity-`.concat(o, ` {pointer-events: none;}
  .allow-interactivity-`).concat(o, ` {pointer-events: all;}
`);
}, d_e = 0, qA = [];
function f_e(o) {
  var r = et.useRef([]), i = et.useRef([0, 0]), u = et.useRef(), h = et.useState(d_e++)[0], y = et.useState(sae)[0], k = et.useRef(o);
  et.useEffect(function() {
    k.current = o;
  }, [o]), et.useEffect(function() {
    if (o.inert) {
      document.body.classList.add("block-interactivity-".concat(h));
      var Ce = Zxe([o.lockRef.current], (o.shards || []).map(Bue), !0).filter(Boolean);
      return Ce.forEach(function(Q) {
        return Q.classList.add("allow-interactivity-".concat(h));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(h)), Ce.forEach(function(Q) {
          return Q.classList.remove("allow-interactivity-".concat(h));
        });
      };
    }
  }, [o.inert, o.lockRef.current, o.shards]);
  var _ = et.useCallback(function(Ce, Q) {
    if ("touches" in Ce && Ce.touches.length === 2)
      return !k.current.allowPinchZoom;
    var oe = $9(Ce), ae = i.current, G = "deltaX" in Ce ? Ce.deltaX : ae[0] - oe[0], ve = "deltaY" in Ce ? Ce.deltaY : ae[1] - oe[1], nt, Xe = Ce.target, te = Math.abs(G) > Math.abs(ve) ? "h" : "v";
    if ("touches" in Ce && te === "h" && Xe.type === "range")
      return !1;
    var lt = Iue(te, Xe);
    if (!lt)
      return !0;
    if (lt ? nt = te : (nt = te === "v" ? "h" : "v", lt = Iue(te, Xe)), !lt)
      return !1;
    if (!u.current && "changedTouches" in Ce && (G || ve) && (u.current = nt), !nt)
      return !0;
    var ot = u.current || nt;
    return l_e(ot, Q, Ce, ot === "h" ? G : ve, !0);
  }, []), D = et.useCallback(function(Ce) {
    var Q = Ce;
    if (!(!qA.length || qA[qA.length - 1] !== y)) {
      var oe = "deltaY" in Q ? Fue(Q) : $9(Q), ae = r.current.filter(function(nt) {
        return nt.name === Q.type && (nt.target === Q.target || Q.target === nt.shadowParent) && c_e(nt.delta, oe);
      })[0];
      if (ae && ae.should) {
        Q.cancelable && Q.preventDefault();
        return;
      }
      if (!ae) {
        var G = (k.current.shards || []).map(Bue).filter(Boolean).filter(function(nt) {
          return nt.contains(Q.target);
        }), ve = G.length > 0 ? _(Q, G[0]) : !k.current.noIsolation;
        ve && Q.cancelable && Q.preventDefault();
      }
    }
  }, []), L = et.useCallback(function(Ce, Q, oe, ae) {
    var G = { name: Ce, delta: Q, target: oe, should: ae, shadowParent: m_e(oe) };
    r.current.push(G), setTimeout(function() {
      r.current = r.current.filter(function(ve) {
        return ve !== G;
      });
    }, 1);
  }, []), W = et.useCallback(function(Ce) {
    i.current = $9(Ce), u.current = void 0;
  }, []), se = et.useCallback(function(Ce) {
    L(Ce.type, Fue(Ce), Ce.target, _(Ce, o.lockRef.current));
  }, []), J = et.useCallback(function(Ce) {
    L(Ce.type, $9(Ce), Ce.target, _(Ce, o.lockRef.current));
  }, []);
  et.useEffect(function() {
    return qA.push(y), o.setCallbacks({
      onScrollCapture: se,
      onWheelCapture: se,
      onTouchMoveCapture: J
    }), document.addEventListener("wheel", D, GA), document.addEventListener("touchmove", D, GA), document.addEventListener("touchstart", W, GA), function() {
      qA = qA.filter(function(Ce) {
        return Ce !== y;
      }), document.removeEventListener("wheel", D, GA), document.removeEventListener("touchmove", D, GA), document.removeEventListener("touchstart", W, GA);
    };
  }, []);
  var be = o.removeScrollBar, ke = o.inert;
  return et.createElement(
    et.Fragment,
    null,
    ke ? et.createElement(y, { styles: u_e(h) }) : null,
    be ? et.createElement(t_e, { gapMode: o.gapMode }) : null
  );
}
function m_e(o) {
  for (var r = null; o !== null; )
    o instanceof ShadowRoot && (r = o.host, o = o.host), o = o.parentNode;
  return r;
}
Gse(Upe, f_e);
var p_e = function(o) {
  if (typeof document > "u")
    return null;
  var r = Array.isArray(o) ? o[0] : o;
  return r.ownerDocument.body;
}, KA = /* @__PURE__ */ new WeakMap(), L9 = /* @__PURE__ */ new WeakMap(), H9 = {}, Gte = 0, yhe = function(o) {
  return o && (o.host || yhe(o.parentNode));
}, h_e = function(o, r) {
  return r.map(function(i) {
    if (o.contains(i))
      return i;
    var u = yhe(i);
    return u && o.contains(u) ? u : (console.error("aria-hidden", i, "in not contained inside", o, ". Doing nothing"), null);
  }).filter(function(i) {
    return !!i;
  });
}, g_e = function(o, r, i, u) {
  var h = h_e(r, Array.isArray(o) ? o : [o]);
  H9[i] || (H9[i] = /* @__PURE__ */ new WeakMap());
  var y = H9[i], k = [], _ = /* @__PURE__ */ new Set(), D = new Set(h), L = function(se) {
    !se || _.has(se) || (_.add(se), L(se.parentNode));
  };
  h.forEach(L);
  var W = function(se) {
    !se || D.has(se) || Array.prototype.forEach.call(se.children, function(J) {
      if (_.has(J))
        W(J);
      else
        try {
          var be = J.getAttribute(u), ke = be !== null && be !== "false", Ce = (KA.get(J) || 0) + 1, Q = (y.get(J) || 0) + 1;
          KA.set(J, Ce), y.set(J, Q), k.push(J), Ce === 1 && ke && L9.set(J, !0), Q === 1 && J.setAttribute(i, "true"), ke || J.setAttribute(u, "true");
        } catch (oe) {
          console.error("aria-hidden: cannot operate on ", J, oe);
        }
    });
  };
  return W(r), _.clear(), Gte++, function() {
    k.forEach(function(se) {
      var J = KA.get(se) - 1, be = y.get(se) - 1;
      KA.set(se, J), y.set(se, be), J || (L9.has(se) || se.removeAttribute(u), L9.delete(se)), be || se.removeAttribute(i);
    }), Gte--, Gte || (KA = /* @__PURE__ */ new WeakMap(), KA = /* @__PURE__ */ new WeakMap(), L9 = /* @__PURE__ */ new WeakMap(), H9 = {});
  };
}, b_e = function(o, r, i) {
  var u = Array.from(Array.isArray(o) ? o : [o]), h = r || p_e(o);
  return h ? (u.push.apply(u, Array.from(h.querySelectorAll("[aria-live]"))), g_e(u, h, i, "aria-hidden")) : function() {
    return null;
  };
}, v_e = sae(), y_e = `
 [` + Xpe + `] {
   pointer-events: none !important;
 }
`, x_e = function() {
  return et.createElement(v_e, { styles: y_e });
}, $ue = function(o) {
  return "current" in o ? o.current : o;
};
function w_e(o) {
  var r = o.setLockProps, i = o.onEscapeKey, u = o.onClickOutside, h = o.shards, y = o.onActivation, k = o.onDeactivation, _ = o.noIsolation, D = et.useState(void 0), L = D[0], W = D[1], se = et.useRef(null), J = et.useRef(0);
  return et.useEffect(function() {
    var be = function(oe) {
      oe.defaultPrevented || (oe.code === "Escape" || oe.key === "Escape" || oe.keyCode === 27) && i && i(oe);
    }, ke = function(oe) {
      oe.defaultPrevented || oe.target === se.current || oe instanceof MouseEvent && oe.button !== 0 || h && h.map($ue).some(function(ae) {
        return ae && ae.contains(oe.target) || ae === oe.target;
      }) || u && u(oe);
    }, Ce = function(oe) {
      ke(oe), J.current = oe.touches.length;
    }, Q = function(oe) {
      J.current = oe.touches.length;
    };
    if (L)
      return document.addEventListener("keydown", be), document.addEventListener("mousedown", ke), document.addEventListener("touchstart", Ce), document.addEventListener("touchend", Q), function() {
        document.removeEventListener("keydown", be), document.removeEventListener("mousedown", ke), document.removeEventListener("touchstart", Ce), document.removeEventListener("touchend", Q);
      };
  }, [L, u, i]), et.useEffect(function() {
    if (L)
      return y && y(L), function() {
        k && k();
      };
  }, [!!L]), et.useEffect(function() {
    var be = function() {
      return null;
    }, ke = !1, Ce = function(oe) {
      _ || (be = b_e(Wxe([oe], (h || []).map($ue)), document.body, Xpe)), W(function() {
        return oe;
      });
    }, Q = function() {
      be(), ke || W(null);
    };
    return r({
      onMouseDown: function(oe) {
        se.current = oe.target;
      },
      onTouchStart: function(oe) {
        se.current = oe.target;
      },
      onActivation: Ce,
      onDeactivation: Q
    }), function() {
      ke = !0, r(!1);
    };
  }, []), et.createElement(x_e, null);
}
const C_e = Gse(Ype, w_e);
var S_e = function(o) {
  return et.createElement(C_e, Ld({}, o));
}, k_e = et.forwardRef(function(o, r) {
  return et.createElement(LSe, Ld({}, o, { ref: r, sideCar: S_e }));
});
function L3(o) {
  "@babel/helpers - typeof";
  return L3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, L3(o);
}
function __e(o, r) {
  if (!(o instanceof r))
    throw new TypeError("Cannot call a class as a function");
}
function E_e(o, r) {
  for (var i = 0; i < r.length; i++) {
    var u = r[i];
    u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(o, O_e(u.key), u);
  }
}
function T_e(o, r, i) {
  return r && E_e(o.prototype, r), Object.defineProperty(o, "prototype", { writable: !1 }), o;
}
function O_e(o) {
  var r = A_e(o, "string");
  return L3(r) == "symbol" ? r : r + "";
}
function A_e(o, r) {
  if (L3(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r);
    if (L3(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(o);
}
function P_e(o, r) {
  if (typeof r != "function" && r !== null)
    throw new TypeError("Super expression must either be null or a function");
  o.prototype = Object.create(r && r.prototype, { constructor: { value: o, writable: !0, configurable: !0 } }), Object.defineProperty(o, "prototype", { writable: !1 }), r && Foe(o, r);
}
function Foe(o, r) {
  return Foe = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(u, h) {
    return u.__proto__ = h, u;
  }, Foe(o, r);
}
function D_e(o) {
  var r = xhe();
  return function() {
    var u = YV(o), h;
    if (r) {
      var y = YV(this).constructor;
      h = Reflect.construct(u, arguments, y);
    } else
      h = u.apply(this, arguments);
    return R_e(this, h);
  };
}
function R_e(o, r) {
  if (r && (L3(r) === "object" || typeof r == "function"))
    return r;
  if (r !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return N_e(o);
}
function N_e(o) {
  if (o === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return o;
}
function xhe() {
  try {
    var o = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (xhe = function() {
    return !!o;
  })();
}
function YV(o) {
  return YV = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(i) {
    return i.__proto__ || Object.getPrototypeOf(i);
  }, YV(o);
}
var whe = /* @__PURE__ */ function(o) {
  P_e(i, o);
  var r = D_e(i);
  function i(u) {
    var h;
    if (__e(this, i), h = r.call(this, u), h.rootName = "paragon-portal-root", typeof document > "u")
      h.rootElement = null;
    else if (document.getElementById(h.rootName))
      h.rootElement = document.getElementById(h.rootName);
    else {
      var y = document.createElement("div");
      y.setAttribute("id", h.rootName), h.rootElement = document.body.appendChild(y);
    }
    return h;
  }
  return T_e(i, [{
    key: "render",
    value: function() {
      return this.rootElement ? /* @__PURE__ */ yk.createPortal(this.props.children, this.rootElement) : null;
    }
  }]), i;
}(Ve.Component);
whe.propTypes = {
  children: ce.node.isRequired
};
var Lue = function(r) {
  return r.reduce(function(i, u) {
    var h = u[0], y = u[1];
    return i[h] = y, i;
  }, {});
}, Hue = typeof window < "u" && window.document && window.document.createElement ? et.useLayoutEffect : et.useEffect;
function M_e(o) {
  var r = o.state;
  Object.keys(r.elements).forEach(function(i) {
    var u = r.styles[i] || {}, h = r.attributes[i] || {}, y = r.elements[i];
    !wh(y) || !xv(y) || (Object.assign(y.style, u), Object.keys(h).forEach(function(k) {
      var _ = h[k];
      _ === !1 ? y.removeAttribute(k) : y.setAttribute(k, _ === !0 ? "" : _);
    }));
  });
}
function I_e(o) {
  var r = o.state, i = {
    popper: {
      position: r.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(r.elements.popper.style, i.popper), r.styles = i, r.elements.arrow && Object.assign(r.elements.arrow.style, i.arrow), function() {
    Object.keys(r.elements).forEach(function(u) {
      var h = r.elements[u], y = r.attributes[u] || {}, k = Object.keys(r.styles.hasOwnProperty(u) ? r.styles[u] : i[u]), _ = k.reduce(function(D, L) {
        return D[L] = "", D;
      }, {});
      !wh(h) || !xv(h) || (Object.assign(h.style, _), Object.keys(y).forEach(function(D) {
        h.removeAttribute(D);
      }));
    });
  };
}
const F_e = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: M_e,
  effect: I_e,
  requires: ["computeStyles"]
};
var B_e = [Yme, npe, Kme, F_e, tpe, Jme, ope, qme, epe], $_e = /* @__PURE__ */ rpe({
  defaultModifiers: B_e
}), L_e = typeof Element < "u", H_e = typeof Map == "function", z_e = typeof Set == "function", V_e = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
function aV(o, r) {
  if (o === r) return !0;
  if (o && r && typeof o == "object" && typeof r == "object") {
    if (o.constructor !== r.constructor) return !1;
    var i, u, h;
    if (Array.isArray(o)) {
      if (i = o.length, i != r.length) return !1;
      for (u = i; u-- !== 0; )
        if (!aV(o[u], r[u])) return !1;
      return !0;
    }
    var y;
    if (H_e && o instanceof Map && r instanceof Map) {
      if (o.size !== r.size) return !1;
      for (y = o.entries(); !(u = y.next()).done; )
        if (!r.has(u.value[0])) return !1;
      for (y = o.entries(); !(u = y.next()).done; )
        if (!aV(u.value[1], r.get(u.value[0]))) return !1;
      return !0;
    }
    if (z_e && o instanceof Set && r instanceof Set) {
      if (o.size !== r.size) return !1;
      for (y = o.entries(); !(u = y.next()).done; )
        if (!r.has(u.value[0])) return !1;
      return !0;
    }
    if (V_e && ArrayBuffer.isView(o) && ArrayBuffer.isView(r)) {
      if (i = o.length, i != r.length) return !1;
      for (u = i; u-- !== 0; )
        if (o[u] !== r[u]) return !1;
      return !0;
    }
    if (o.constructor === RegExp) return o.source === r.source && o.flags === r.flags;
    if (o.valueOf !== Object.prototype.valueOf && typeof o.valueOf == "function" && typeof r.valueOf == "function") return o.valueOf() === r.valueOf();
    if (o.toString !== Object.prototype.toString && typeof o.toString == "function" && typeof r.toString == "function") return o.toString() === r.toString();
    if (h = Object.keys(o), i = h.length, i !== Object.keys(r).length) return !1;
    for (u = i; u-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, h[u])) return !1;
    if (L_e && o instanceof Element) return !1;
    for (u = i; u-- !== 0; )
      if (!((h[u] === "_owner" || h[u] === "__v" || h[u] === "__o") && o.$$typeof) && !aV(o[h[u]], r[h[u]]))
        return !1;
    return !0;
  }
  return o !== o && r !== r;
}
var j_e = function(r, i) {
  try {
    return aV(r, i);
  } catch (u) {
    if ((u.message || "").match(/stack|recursion/i))
      return console.warn("react-fast-compare cannot handle circular refs"), !1;
    throw u;
  }
};
const U_e = /* @__PURE__ */ H3(j_e);
var W_e = [], Z_e = function(r, i, u) {
  u === void 0 && (u = {});
  var h = et.useRef(null), y = {
    onFirstUpdate: u.onFirstUpdate,
    placement: u.placement || "bottom",
    strategy: u.strategy || "absolute",
    modifiers: u.modifiers || W_e
  }, k = et.useState({
    styles: {
      popper: {
        position: y.strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), _ = k[0], D = k[1], L = et.useMemo(function() {
    return {
      name: "updateState",
      enabled: !0,
      phase: "write",
      fn: function(be) {
        var ke = be.state, Ce = Object.keys(ke.elements);
        zre.flushSync(function() {
          D({
            styles: Lue(Ce.map(function(Q) {
              return [Q, ke.styles[Q] || {}];
            })),
            attributes: Lue(Ce.map(function(Q) {
              return [Q, ke.attributes[Q]];
            }))
          });
        });
      },
      requires: ["computeStyles"]
    };
  }, []), W = et.useMemo(function() {
    var J = {
      onFirstUpdate: y.onFirstUpdate,
      placement: y.placement,
      strategy: y.strategy,
      modifiers: [].concat(y.modifiers, [L, {
        name: "applyStyles",
        enabled: !1
      }])
    };
    return U_e(h.current, J) ? h.current || J : (h.current = J, J);
  }, [y.onFirstUpdate, y.placement, y.strategy, y.modifiers, L]), se = et.useRef();
  return Hue(function() {
    se.current && se.current.setOptions(W);
  }, [W]), Hue(function() {
    if (!(r == null || i == null)) {
      var J = u.createPopper || $_e, be = J(r, i, W);
      return se.current = be, function() {
        be.destroy(), se.current = null;
      };
    }
  }, [r, i, u.createPopper]), {
    state: se.current ? se.current.state : null,
    styles: _.styles,
    attributes: _.attributes,
    update: se.current ? se.current.update : null,
    forceUpdate: se.current ? se.current.forceUpdate : null
  };
};
function U5(o) {
  "@babel/helpers - typeof";
  return U5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, U5(o);
}
function Boe() {
  return Boe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, Boe.apply(this, arguments);
}
function zue(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function Vue(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? zue(Object(i), !0).forEach(function(u) {
      G_e(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : zue(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function G_e(o, r, i) {
  return r = q_e(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function q_e(o) {
  var r = K_e(o, "string");
  return U5(r) == "symbol" ? r : r + "";
}
function K_e(o, r) {
  if (U5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (U5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
function Y_e(o, r) {
  return eEe(o) || J_e(o, r) || Q_e(o, r) || X_e();
}
function X_e() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Q_e(o, r) {
  if (o) {
    if (typeof o == "string") return jue(o, r);
    var i = Object.prototype.toString.call(o).slice(8, -1);
    if (i === "Object" && o.constructor && (i = o.constructor.name), i === "Map" || i === "Set") return Array.from(o);
    if (i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return jue(o, r);
  }
}
function jue(o, r) {
  (r == null || r > o.length) && (r = o.length);
  for (var i = 0, u = new Array(r); i < r; i++) u[i] = o[i];
  return u;
}
function J_e(o, r) {
  var i = o == null ? null : typeof Symbol < "u" && o[Symbol.iterator] || o["@@iterator"];
  if (i != null) {
    var u, h, y, k, _ = [], D = !0, L = !1;
    try {
      if (y = (i = i.call(o)).next, r !== 0) for (; !(D = (u = y.call(i)).done) && (_.push(u.value), _.length !== r); D = !0) ;
    } catch (W) {
      L = !0, h = W;
    } finally {
      try {
        if (!D && i.return != null && (k = i.return(), Object(k) !== k)) return;
      } finally {
        if (L) throw h;
      }
    }
    return _;
  }
}
function eEe(o) {
  if (Array.isArray(o)) return o;
}
function uF(o) {
  var r = o.children, i = o.target, u = o.strategy, h = o.placement, y = o.modifiers, k = et.useState(null), _ = Y_e(k, 2), D = _[0], L = _[1], W = {
    modifiers: y,
    strategy: u,
    placement: h
  }, se = Z_e(i, D, W), J = se.styles, be = se.attributes;
  return i ? /* @__PURE__ */ Ve.createElement("div", Boe({
    ref: L,
    style: Vue(Vue({}, J.popper), {}, {
      zIndex: 2e3
    })
  }, be.popper), r) : null;
}
uF.defaultProps = {
  target: void 0
};
uF.propTypes = {
  children: ce.node,
  target: ce.shape({
    current: ce.shape({})
  }),
  strategy: ce.oneOf(["absolute", "fixed"]),
  placement: ce.oneOf(["auto", "auto-start", "auto-end", "top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "right", "right-start", "right-end", "left", "left-start", "left-end"]),
  modifiers: ce.arrayOf(ce.shape({}))
};
uF.defaultProps = {
  children: void 0,
  strategy: "absolute",
  placement: "bottom-start",
  modifiers: [{
    name: "flip",
    enabled: !0
  }, {
    name: "preventOverflow",
    options: {
      tether: !1
    }
  }]
};
var tEe = /* @__PURE__ */ Ve.createContext({
  onClose: function() {
  }
});
function aae(o) {
  var r = o.onClose, i = o.isOpen, u = o.isBlocking, h = o.children, y = et.useMemo(function() {
    return {
      onClose: r,
      isOpen: i,
      isBlocking: u
    };
  }, [r, i, u]);
  return /* @__PURE__ */ Ve.createElement(tEe.Provider, {
    value: y
  }, h);
}
aae.propTypes = {
  children: ce.node,
  onClose: ce.func.isRequired,
  isBlocking: ce.bool,
  isOpen: ce.bool.isRequired
};
aae.defaultProps = {
  children: null,
  isBlocking: !1
};
var nEe = ["children", "onClose", "isOpen", "positionRef", "isBlocking", "withPortal", "placement", "hasArrow"];
function $oe() {
  return $oe = Object.assign ? Object.assign.bind() : function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i)
        Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }, $oe.apply(this, arguments);
}
function oEe(o, r) {
  if (o == null) return {};
  var i = rEe(o, r), u, h;
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(o);
    for (h = 0; h < y.length; h++)
      u = y[h], !(r.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(o, u) && (i[u] = o[u]);
  }
  return i;
}
function rEe(o, r) {
  if (o == null) return {};
  var i = {}, u = Object.keys(o), h, y;
  for (y = 0; y < u.length; y++)
    h = u[y], !(r.indexOf(h) >= 0) && (i[h] = o[h]);
  return i;
}
var sEe = {
  right: [-2, 10],
  left: [-2, 10]
};
function iae(o) {
  var r = o.children, i = o.onClose, u = o.isOpen, h = o.positionRef, y = o.isBlocking, k = o.withPortal, _ = o.placement, D = o.hasArrow, L = oEe(o, nEe), W = k ? whe : Ve.Fragment, se = sEe[_] || [0, 10], J = [{
    name: "eventListeners",
    options: {
      scroll: !1
    }
  }, {
    name: "offset",
    options: {
      offset: function() {
        return se;
      }
    }
  }], be = function(Ce) {
    Ce.type !== "touchstart" && i();
  };
  return /* @__PURE__ */ Ve.createElement(aae, {
    onClose: i,
    isOpen: u,
    isBlocking: y
  }, /* @__PURE__ */ Ve.createElement(W, null, /* @__PURE__ */ Ve.createElement(uF, $oe({
    modifiers: D ? J : null,
    target: h,
    placement: _
  }, L), /* @__PURE__ */ Ve.createElement(k_e, {
    scrollLock: !1,
    enabled: u,
    onEscapeKey: i,
    onClickOutside: be
  }, u && /* @__PURE__ */ Ve.createElement("div", {
    className: "pgn__modal-popup__tooltip"
  }, r, D && /* @__PURE__ */ Ve.createElement("div", {
    id: "arrow",
    "data-testid": "modal-popup-arrow",
    className: "pgn__modal-popup__arrow pgn__modal-popup__arrow-".concat(_),
    "data-popper-arrow": ""
  }))))));
}
iae.propTypes = {
  /** Specifies the contents of the modal */
  children: ce.node.isRequired,
  /** A callback function for when the modal is dismissed */
  onClose: ce.func.isRequired,
  /** Is the modal dialog open or closed */
  isOpen: ce.bool.isRequired,
  /** Prevent clicking on the backdrop or pressing Esc to close the modal */
  isBlocking: ce.bool,
  /** Insert modal into a different location in the DOM */
  withPortal: ce.bool,
  // This type: https://stackoverflow.com/questions/48007326/what-is-the-correct-proptype-for-a-ref-in-react
  /** Specifies an element near which the modal should be displayed */
  positionRef: ce.oneOfType([ce.func, ce.shape({
    current: ce.shape({})
  })]),
  /** Specifies position according to the element that the ``positionRef`` prop points to */
  placement: uF.propTypes.placement,
  /** Caret to the modal popup pointing to the target */
  hasArrow: ce.bool
};
iae.defaultProps = {
  isBlocking: !1,
  withPortal: !1,
  placement: "bottom-start",
  positionRef: null,
  hasArrow: !1
};
function aEe(o, r) {
  return uEe(o) || cEe(o, r) || lEe(o, r) || iEe();
}
function iEe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function lEe(o, r) {
  if (o) {
    if (typeof o == "string") return Uue(o, r);
    var i = Object.prototype.toString.call(o).slice(8, -1);
    if (i === "Object" && o.constructor && (i = o.constructor.name), i === "Map" || i === "Set") return Array.from(o);
    if (i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return Uue(o, r);
  }
}
function Uue(o, r) {
  (r == null || r > o.length) && (r = o.length);
  for (var i = 0, u = new Array(r); i < r; i++) u[i] = o[i];
  return u;
}
function cEe(o, r) {
  var i = o == null ? null : typeof Symbol < "u" && o[Symbol.iterator] || o["@@iterator"];
  if (i != null) {
    var u, h, y, k, _ = [], D = !0, L = !1;
    try {
      if (y = (i = i.call(o)).next, r !== 0) for (; !(D = (u = y.call(i)).done) && (_.push(u.value), _.length !== r); D = !0) ;
    } catch (W) {
      L = !0, h = W;
    } finally {
      try {
        if (!D && i.return != null && (k = i.return(), Object(k) !== k)) return;
      } finally {
        if (L) throw h;
      }
    }
    return _;
  }
}
function uEe(o) {
  if (Array.isArray(o)) return o;
}
function dEe(o) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = r.handleToggleOn, u = r.handleToggleOff, h = r.handleToggle, y = et.useState(!1), k = aEe(y, 2), _ = k[0], D = k[1], L = et.useCallback(function() {
    D(!0), i && i(), h && h(!0);
  }, [i, h]), W = et.useCallback(function() {
    D(!1), u && u(), h && h(!1);
  }, [u, h]), se = et.useCallback(function() {
    var J = _ ? W : L;
    J();
  }, [_, L, W]);
  return [_, L, W, se];
}
function Lj() {
  return (Lj = Object.assign || function(o) {
    for (var r = 1; r < arguments.length; r++) {
      var i = arguments[r];
      for (var u in i) Object.prototype.hasOwnProperty.call(i, u) && (o[u] = i[u]);
    }
    return o;
  }).apply(this, arguments);
}
function Che(o, r) {
  if (o == null) return {};
  var i, u, h = {}, y = Object.keys(o);
  for (u = 0; u < y.length; u++) r.indexOf(i = y[u]) >= 0 || (h[i] = o[i]);
  return h;
}
function Loe(o) {
  var r = et.useRef(o), i = et.useRef(function(u) {
    r.current && r.current(u);
  });
  return r.current = o, i.current;
}
var W5 = function(o, r, i) {
  return r === void 0 && (r = 0), i === void 0 && (i = 1), o > i ? i : o < r ? r : o;
}, QI = function(o) {
  return "touches" in o;
}, Hoe = function(o) {
  return o && o.ownerDocument.defaultView || self;
}, Wue = function(o, r, i) {
  var u = o.getBoundingClientRect(), h = QI(r) ? function(y, k) {
    for (var _ = 0; _ < y.length; _++) if (y[_].identifier === k) return y[_];
    return y[0];
  }(r.touches, i) : r;
  return { left: W5((h.pageX - (u.left + Hoe(o).pageXOffset)) / u.width), top: W5((h.pageY - (u.top + Hoe(o).pageYOffset)) / u.height) };
}, Zue = function(o) {
  !QI(o) && o.preventDefault();
}, She = Ve.memo(function(o) {
  var r = o.onMove, i = o.onKey, u = Che(o, ["onMove", "onKey"]), h = et.useRef(null), y = Loe(r), k = Loe(i), _ = et.useRef(null), D = et.useRef(!1), L = et.useMemo(function() {
    var be = function(Q) {
      Zue(Q), (QI(Q) ? Q.touches.length > 0 : Q.buttons > 0) && h.current ? y(Wue(h.current, Q, _.current)) : Ce(!1);
    }, ke = function() {
      return Ce(!1);
    };
    function Ce(Q) {
      var oe = D.current, ae = Hoe(h.current), G = Q ? ae.addEventListener : ae.removeEventListener;
      G(oe ? "touchmove" : "mousemove", be), G(oe ? "touchend" : "mouseup", ke);
    }
    return [function(Q) {
      var oe = Q.nativeEvent, ae = h.current;
      if (ae && (Zue(oe), !function(ve, nt) {
        return nt && !QI(ve);
      }(oe, D.current) && ae)) {
        if (QI(oe)) {
          D.current = !0;
          var G = oe.changedTouches || [];
          G.length && (_.current = G[0].identifier);
        }
        ae.focus(), y(Wue(ae, oe, _.current)), Ce(!0);
      }
    }, function(Q) {
      var oe = Q.which || Q.keyCode;
      oe < 37 || oe > 40 || (Q.preventDefault(), k({ left: oe === 39 ? 0.05 : oe === 37 ? -0.05 : 0, top: oe === 40 ? 0.05 : oe === 38 ? -0.05 : 0 }));
    }, Ce];
  }, [k, y]), W = L[0], se = L[1], J = L[2];
  return et.useEffect(function() {
    return J;
  }, [J]), Ve.createElement("div", Lj({}, u, { onTouchStart: W, onMouseDown: W, className: "react-colorful__interactive", ref: h, onKeyDown: se, tabIndex: 0, role: "slider" }));
}), lae = function(o) {
  return o.filter(Boolean).join(" ");
}, khe = function(o) {
  var r = o.color, i = o.left, u = o.top, h = u === void 0 ? 0.5 : u, y = lae(["react-colorful__pointer", o.className]);
  return Ve.createElement("div", { className: y, style: { top: 100 * h + "%", left: 100 * i + "%" } }, Ve.createElement("div", { className: "react-colorful__pointer-fill", style: { backgroundColor: r } }));
}, ad = function(o, r, i) {
  return r === void 0 && (r = 0), i === void 0 && (i = Math.pow(10, r)), Math.round(i * o) / i;
}, fEe = function(o) {
  return bEe(zoe(o));
}, zoe = function(o) {
  return o[0] === "#" && (o = o.substring(1)), o.length < 6 ? { r: parseInt(o[0] + o[0], 16), g: parseInt(o[1] + o[1], 16), b: parseInt(o[2] + o[2], 16), a: o.length === 4 ? ad(parseInt(o[3] + o[3], 16) / 255, 2) : 1 } : { r: parseInt(o.substring(0, 2), 16), g: parseInt(o.substring(2, 4), 16), b: parseInt(o.substring(4, 6), 16), a: o.length === 8 ? ad(parseInt(o.substring(6, 8), 16) / 255, 2) : 1 };
}, mEe = function(o) {
  return gEe(hEe(o));
}, pEe = function(o) {
  var r = o.s, i = o.v, u = o.a, h = (200 - r) * i / 100;
  return { h: ad(o.h), s: ad(h > 0 && h < 200 ? r * i / 100 / (h <= 100 ? h : 200 - h) * 100 : 0), l: ad(h / 2), a: ad(u, 2) };
}, Voe = function(o) {
  var r = pEe(o);
  return "hsl(" + r.h + ", " + r.s + "%, " + r.l + "%)";
}, hEe = function(o) {
  var r = o.h, i = o.s, u = o.v, h = o.a;
  r = r / 360 * 6, i /= 100, u /= 100;
  var y = Math.floor(r), k = u * (1 - i), _ = u * (1 - (r - y) * i), D = u * (1 - (1 - r + y) * i), L = y % 6;
  return { r: ad(255 * [u, _, k, k, D, u][L]), g: ad(255 * [D, u, u, _, k, k][L]), b: ad(255 * [k, k, D, u, u, _][L]), a: ad(h, 2) };
}, z9 = function(o) {
  var r = o.toString(16);
  return r.length < 2 ? "0" + r : r;
}, gEe = function(o) {
  var r = o.r, i = o.g, u = o.b, h = o.a, y = h < 1 ? z9(ad(255 * h)) : "";
  return "#" + z9(r) + z9(i) + z9(u) + y;
}, bEe = function(o) {
  var r = o.r, i = o.g, u = o.b, h = o.a, y = Math.max(r, i, u), k = y - Math.min(r, i, u), _ = k ? y === r ? (i - u) / k : y === i ? 2 + (u - r) / k : 4 + (r - i) / k : 0;
  return { h: ad(60 * (_ < 0 ? _ + 6 : _)), s: ad(y ? k / y * 100 : 0), v: ad(y / 255 * 100), a: h };
}, vEe = Ve.memo(function(o) {
  var r = o.hue, i = o.onChange, u = lae(["react-colorful__hue", o.className]);
  return Ve.createElement("div", { className: u }, Ve.createElement(She, { onMove: function(h) {
    i({ h: 360 * h.left });
  }, onKey: function(h) {
    i({ h: W5(r + 360 * h.left, 0, 360) });
  }, "aria-label": "Hue", "aria-valuenow": ad(r), "aria-valuemax": "360", "aria-valuemin": "0" }, Ve.createElement(khe, { className: "react-colorful__hue-pointer", left: r / 360, color: Voe({ h: r, s: 100, v: 100, a: 1 }) })));
}), yEe = Ve.memo(function(o) {
  var r = o.hsva, i = o.onChange, u = { backgroundColor: Voe({ h: r.h, s: 100, v: 100, a: 1 }) };
  return Ve.createElement("div", { className: "react-colorful__saturation", style: u }, Ve.createElement(She, { onMove: function(h) {
    i({ s: 100 * h.left, v: 100 - 100 * h.top });
  }, onKey: function(h) {
    i({ s: W5(r.s + 100 * h.left, 0, 100), v: W5(r.v - 100 * h.top, 0, 100) });
  }, "aria-label": "Color", "aria-valuetext": "Saturation " + ad(r.s) + "%, Brightness " + ad(r.v) + "%" }, Ve.createElement(khe, { className: "react-colorful__saturation-pointer", top: 1 - r.v / 100, left: r.s / 100, color: Voe(r) })));
}), _he = function(o, r) {
  if (o === r) return !0;
  for (var i in o) if (o[i] !== r[i]) return !1;
  return !0;
}, xEe = function(o, r) {
  return o.toLowerCase() === r.toLowerCase() || _he(zoe(o), zoe(r));
};
function wEe(o, r, i) {
  var u = Loe(i), h = et.useState(function() {
    return o.toHsva(r);
  }), y = h[0], k = h[1], _ = et.useRef({ color: r, hsva: y });
  et.useEffect(function() {
    if (!o.equal(r, _.current.color)) {
      var L = o.toHsva(r);
      _.current = { hsva: L, color: r }, k(L);
    }
  }, [r, o]), et.useEffect(function() {
    var L;
    _he(y, _.current.hsva) || o.equal(L = o.fromHsva(y), _.current.color) || (_.current = { hsva: y, color: L }, u(L));
  }, [y, o, u]);
  var D = et.useCallback(function(L) {
    k(function(W) {
      return Object.assign({}, W, L);
    });
  }, []);
  return [y, D];
}
var CEe = typeof window < "u" ? et.useLayoutEffect : et.useEffect, SEe = function() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : void 0;
}, Gue = /* @__PURE__ */ new Map(), kEe = function(o) {
  CEe(function() {
    var r = o.current ? o.current.ownerDocument : document;
    if (r !== void 0 && !Gue.has(r)) {
      var i = r.createElement("style");
      i.innerHTML = `.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}`, Gue.set(r, i);
      var u = SEe();
      u && i.setAttribute("nonce", u), r.head.appendChild(i);
    }
  }, []);
}, _Ee = function(o) {
  var r = o.className, i = o.colorModel, u = o.color, h = u === void 0 ? i.defaultColor : u, y = o.onChange, k = Che(o, ["className", "colorModel", "color", "onChange"]), _ = et.useRef(null);
  kEe(_);
  var D = wEe(i, h, y), L = D[0], W = D[1], se = lae(["react-colorful", r]);
  return Ve.createElement("div", Lj({}, k, { ref: _, className: se }), Ve.createElement(yEe, { hsva: L, onChange: W }), Ve.createElement(vEe, { hue: L.h, onChange: W, className: "react-colorful__last-control" }));
}, EEe = { defaultColor: "000", toHsva: fEe, fromHsva: function(o) {
  return mEe({ h: o.h, s: o.s, v: o.v, a: 1 });
}, equal: xEe }, TEe = function(o) {
  return Ve.createElement(_Ee, Lj({}, o, { colorModel: EEe }));
};
function Z5(o) {
  "@babel/helpers - typeof";
  return Z5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
    return typeof r;
  } : function(r) {
    return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
  }, Z5(o);
}
function que(o, r) {
  var i = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(o);
    r && (u = u.filter(function(h) {
      return Object.getOwnPropertyDescriptor(o, h).enumerable;
    })), i.push.apply(i, u);
  }
  return i;
}
function OEe(o) {
  for (var r = 1; r < arguments.length; r++) {
    var i = arguments[r] != null ? arguments[r] : {};
    r % 2 ? que(Object(i), !0).forEach(function(u) {
      AEe(o, u, i[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(i)) : que(Object(i)).forEach(function(u) {
      Object.defineProperty(o, u, Object.getOwnPropertyDescriptor(i, u));
    });
  }
  return o;
}
function AEe(o, r, i) {
  return r = PEe(r), r in o ? Object.defineProperty(o, r, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : o[r] = i, o;
}
function PEe(o) {
  var r = DEe(o, "string");
  return Z5(r) == "symbol" ? r : r + "";
}
function DEe(o, r) {
  if (Z5(o) != "object" || !o) return o;
  var i = o[Symbol.toPrimitive];
  if (i !== void 0) {
    var u = i.call(o, r || "default");
    if (Z5(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(o);
}
function TI(o, r) {
  return IEe(o) || MEe(o, r) || NEe(o, r) || REe();
}
function REe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function NEe(o, r) {
  if (o) {
    if (typeof o == "string") return Kue(o, r);
    var i = Object.prototype.toString.call(o).slice(8, -1);
    if (i === "Object" && o.constructor && (i = o.constructor.name), i === "Map" || i === "Set") return Array.from(o);
    if (i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return Kue(o, r);
  }
}
function Kue(o, r) {
  (r == null || r > o.length) && (r = o.length);
  for (var i = 0, u = new Array(r); i < r; i++) u[i] = o[i];
  return u;
}
function MEe(o, r) {
  var i = o == null ? null : typeof Symbol < "u" && o[Symbol.iterator] || o["@@iterator"];
  if (i != null) {
    var u, h, y, k, _ = [], D = !0, L = !1;
    try {
      if (y = (i = i.call(o)).next, r === 0) {
        if (Object(i) !== i) return;
        D = !1;
      } else for (; !(D = (u = y.call(i)).done) && (_.push(u.value), _.length !== r); D = !0) ;
    } catch (W) {
      L = !0, h = W;
    } finally {
      try {
        if (!D && i.return != null && (k = i.return(), Object(k) !== k)) return;
      } finally {
        if (L) throw h;
      }
    }
    return _;
  }
}
function IEe(o) {
  if (Array.isArray(o)) return o;
}
function cae(o) {
  var r = o.color, i = o.setColor, u = o.className, h = o.size, y = dEe(!1), k = TI(y, 3), _ = k[0], D = k[1], L = k[2], W = Ve.useState(null), se = TI(W, 2), J = se[0], be = se[1], ke = function(wt) {
    var qe = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
    return qe.test(wt);
  }, Ce = function(wt) {
    return wt.startsWith("#") ? wt.slice(0, 7) : "#".concat(wt).slice(0, 7);
  }, Q = Ve.useState(function() {
    return r === "" || ke(Ce(r));
  }), oe = TI(Q, 2), ae = oe[0], G = oe[1], ve = Ve.useState(function() {
    return r === "" ? "" : Ce(r);
  }), nt = TI(ve, 2), Xe = nt[0], te = nt[1], lt = Ve.useState(function() {
    var dn = Ce(r);
    return ke(dn) ? dn : "#fff";
  }), ot = TI(lt, 2), Kt = ot[0], je = ot[1], ye = function(wt) {
    if (wt === "") {
      G(!0), i(""), te(""), je("#fff");
      return;
    }
    var qe = Ce(wt);
    if (ke(qe)) {
      G(!0), i(qe), te(qe), je(qe);
      return;
    }
    G(!1), te(qe), i(qe);
  };
  return /* @__PURE__ */ Ve.createElement(Ve.Fragment, null, /* @__PURE__ */ Ve.createElement("span", {
    className: "d-flex"
  }, /* @__PURE__ */ Ve.createElement(bj, {
    placement: "top",
    overlay: /* @__PURE__ */ Ve.createElement(k5, {
      id: "color-picker-tooltip"
    }, "Color picker")
  }, /* @__PURE__ */ Ve.createElement(Dk, {
    ref: be,
    className: ns(u, "pgn__color-picker", "pgn__color-picker-".concat(h)),
    style: OEe({}, r && ae ? {
      background: "".concat(r)
    } : {}),
    onClick: D
  }))), /* @__PURE__ */ Ve.createElement(iae, {
    positionRef: J,
    isOpen: _,
    style: {
      background: "black"
    },
    onClose: L
  }, /* @__PURE__ */ Ve.createElement("div", {
    className: "pgn__color-modal rounded shadow",
    style: {
      textAlign: "start"
    }
  }, /* @__PURE__ */ Ve.createElement(TEe, {
    color: Kt,
    onChange: ye
  }), /* @__PURE__ */ Ve.createElement(ji.Group, {
    className: "pgn__hex-form",
    size: "sm"
  }, /* @__PURE__ */ Ve.createElement("div", null, /* @__PURE__ */ Ve.createElement(ji.Label, {
    className: "pgn__hex-label"
  }, "Hex"), /* @__PURE__ */ Ve.createElement(ji.Control, {
    className: "pgn__hex-field",
    isInvalid: !ae,
    value: Xe,
    onChange: function(wt) {
      return ye(wt.target.value);
    },
    "data-testid": "hex-input",
    spellCheck: "false"
  })), !ae && /* @__PURE__ */ Ve.createElement(ji.Control.Feedback, {
    className: "pgn__color-error",
    type: "invalid"
  }, "Colors must be in hexadecimal format.")))));
}
cae.defaultProps = {
  color: "",
  className: void 0,
  size: "md"
};
cae.propTypes = {
  /** A default hex code to preset the picker to display. */
  color: ce.string,
  /** Passing setState function allows parent to alter the color. */
  setColor: ce.func.isRequired,
  /** A class name to append to the base element. */
  className: ce.string,
  /** Size of the color picker */
  size: ce.oneOf(["sm", "md"])
};
function qte({
  label: o,
  color: r,
  setColor: i,
  help: u
}) {
  return /* @__PURE__ */ cs.jsxs("div", { className: "d-flex flex-column pb-3", children: [
    /* @__PURE__ */ cs.jsxs("div", { className: "d-flex align-items-center", "data-testid": o, children: [
      /* @__PURE__ */ cs.jsx("span", { className: "mr-2", children: o }),
      /* @__PURE__ */ cs.jsx(
        cae,
        {
          size: "sm",
          color: r,
          setColor: i
        }
      )
    ] }),
    /* @__PURE__ */ cs.jsx("span", { className: "text-light-800 small mt-2", children: u })
  ] });
}
function FEe({
  styling: o,
  setStyling: r
}) {
  const i = (u) => r({ ...o, ...u });
  return /* @__PURE__ */ cs.jsxs("div", { style: { maxWidth: "800px" }, children: [
    /* @__PURE__ */ cs.jsx("h3", { className: "mb-2 h3", children: "Styling of Accordions" }),
    /* @__PURE__ */ cs.jsxs("div", { className: "d-flex align-items-center mb-2", children: [
      /* @__PURE__ */ cs.jsx("label", { className: "mr-2", htmlFor: "font-size-input", children: "Font size" }),
      /* @__PURE__ */ cs.jsx(
        "input",
        {
          id: "font-size-input",
          value: o.fontSize,
          onChange: (u) => i({ fontSize: u.target.value })
        }
      )
    ] }),
    /* @__PURE__ */ cs.jsx(
      qte,
      {
        label: "Background color",
        help: "Background color of accordion titles",
        color: o.backgroundColor,
        setColor: (u) => i({ backgroundColor: u })
      }
    ),
    /* @__PURE__ */ cs.jsx(
      qte,
      {
        label: "Border color",
        help: "Border color of accordion titles",
        color: o.borderColor,
        setColor: (u) => i({ borderColor: u })
      }
    ),
    /* @__PURE__ */ cs.jsx(
      qte,
      {
        label: "Text color",
        help: "Text color of accordion titles",
        color: o.textColor,
        setColor: (u) => i({ textColor: u })
      }
    )
  ] });
}
var joe = function() {
  return joe = Object.assign || function(o) {
    for (var r, i = 1, u = arguments.length; i < u; i++) {
      r = arguments[i];
      for (var h in r) Object.prototype.hasOwnProperty.call(r, h) && (o[h] = r[h]);
    }
    return o;
  }, joe.apply(this, arguments);
}, Ehe = {
  onActivate: Rn.func,
  onAddUndo: Rn.func,
  onBeforeAddUndo: Rn.func,
  onBeforeExecCommand: Rn.func,
  onBeforeGetContent: Rn.func,
  onBeforeRenderUI: Rn.func,
  onBeforeSetContent: Rn.func,
  onBeforePaste: Rn.func,
  onBlur: Rn.func,
  onChange: Rn.func,
  onClearUndos: Rn.func,
  onClick: Rn.func,
  onContextMenu: Rn.func,
  onCommentChange: Rn.func,
  onCompositionEnd: Rn.func,
  onCompositionStart: Rn.func,
  onCompositionUpdate: Rn.func,
  onCopy: Rn.func,
  onCut: Rn.func,
  onDblclick: Rn.func,
  onDeactivate: Rn.func,
  onDirty: Rn.func,
  onDrag: Rn.func,
  onDragDrop: Rn.func,
  onDragEnd: Rn.func,
  onDragGesture: Rn.func,
  onDragOver: Rn.func,
  onDrop: Rn.func,
  onExecCommand: Rn.func,
  onFocus: Rn.func,
  onFocusIn: Rn.func,
  onFocusOut: Rn.func,
  onGetContent: Rn.func,
  onHide: Rn.func,
  onInit: Rn.func,
  onInput: Rn.func,
  onKeyDown: Rn.func,
  onKeyPress: Rn.func,
  onKeyUp: Rn.func,
  onLoadContent: Rn.func,
  onMouseDown: Rn.func,
  onMouseEnter: Rn.func,
  onMouseLeave: Rn.func,
  onMouseMove: Rn.func,
  onMouseOut: Rn.func,
  onMouseOver: Rn.func,
  onMouseUp: Rn.func,
  onNodeChange: Rn.func,
  onObjectResizeStart: Rn.func,
  onObjectResized: Rn.func,
  onObjectSelected: Rn.func,
  onPaste: Rn.func,
  onPostProcess: Rn.func,
  onPostRender: Rn.func,
  onPreProcess: Rn.func,
  onProgressState: Rn.func,
  onRedo: Rn.func,
  onRemove: Rn.func,
  onReset: Rn.func,
  onSaveContent: Rn.func,
  onSelectionChange: Rn.func,
  onSetAttrib: Rn.func,
  onSetContent: Rn.func,
  onShow: Rn.func,
  onSubmit: Rn.func,
  onUndo: Rn.func,
  onVisualAid: Rn.func,
  onSkinLoadError: Rn.func,
  onThemeLoadError: Rn.func,
  onModelLoadError: Rn.func,
  onPluginLoadError: Rn.func,
  onIconsLoadError: Rn.func,
  onLanguageLoadError: Rn.func,
  onScriptsLoad: Rn.func,
  onScriptsLoadError: Rn.func
}, BEe = joe({ apiKey: Rn.string, licenseKey: Rn.string, id: Rn.string, inline: Rn.bool, init: Rn.object, initialValue: Rn.string, onEditorChange: Rn.func, value: Rn.string, tagName: Rn.string, tabIndex: Rn.number, cloudChannel: Rn.string, plugins: Rn.oneOfType([Rn.string, Rn.array]), toolbar: Rn.oneOfType([Rn.string, Rn.array]), disabled: Rn.bool, textareaName: Rn.string, tinymceScriptSrc: Rn.oneOfType([
  Rn.string,
  Rn.arrayOf(Rn.string),
  Rn.arrayOf(Rn.shape({
    src: Rn.string,
    async: Rn.bool,
    defer: Rn.bool
  }))
]), rollback: Rn.oneOfType([Rn.number, Rn.oneOf([!1])]), scriptLoading: Rn.shape({
  async: Rn.bool,
  defer: Rn.bool,
  delay: Rn.number
}) }, Ehe), Kte = function(o) {
  return typeof o == "function";
}, Yue = function(o) {
  return o in Ehe;
}, Xue = function(o) {
  return o.substr(2);
}, $Ee = function(o, r, i, u, h, y, k) {
  var _ = Object.keys(h).filter(Yue), D = Object.keys(y).filter(Yue), L = _.filter(function(se) {
    return y[se] === void 0;
  }), W = D.filter(function(se) {
    return h[se] === void 0;
  });
  L.forEach(function(se) {
    var J = Xue(se), be = k[J];
    i(J, be), delete k[J];
  }), W.forEach(function(se) {
    var J = u(o, se), be = Xue(se);
    k[be] = J, r(be, J);
  });
}, LEe = function(o, r, i, u, h) {
  return $Ee(
    h,
    o.on.bind(o),
    o.off.bind(o),
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    function(y, k) {
      return function(_) {
        var D;
        return (D = y(k)) === null || D === void 0 ? void 0 : D(_, o);
      };
    },
    r,
    i,
    u
  );
}, Que = 0, The = function(o) {
  var r = Date.now(), i = Math.floor(Math.random() * 1e9);
  return Que++, o + "_" + i + Que + String(r);
}, Jue = function(o) {
  return o !== null && (o.tagName.toLowerCase() === "textarea" || o.tagName.toLowerCase() === "input");
}, ede = function(o) {
  return typeof o > "u" || o === "" ? [] : Array.isArray(o) ? o : o.split(" ");
}, HEe = function(o, r) {
  return ede(o).concat(ede(r));
}, zEe = function() {
  return window.InputEvent && typeof InputEvent.prototype.getTargetRanges == "function";
}, VEe = function(o) {
  if (!("isConnected" in Node.prototype)) {
    for (var r = o, i = o.parentNode; i != null; )
      r = i, i = r.parentNode;
    return r === o.ownerDocument;
  }
  return o.isConnected;
}, tde = function(o, r) {
  o !== void 0 && (o.mode != null && typeof o.mode == "object" && typeof o.mode.set == "function" ? o.mode.set(r) : o.setMode(r));
}, Uoe = function() {
  return Uoe = Object.assign || function(o) {
    for (var r, i = 1, u = arguments.length; i < u; i++) {
      r = arguments[i];
      for (var h in r) Object.prototype.hasOwnProperty.call(r, h) && (o[h] = r[h]);
    }
    return o;
  }, Uoe.apply(this, arguments);
}, jEe = function(o, r, i) {
  var u, h, y = o.createElement("script");
  y.referrerPolicy = "origin", y.type = "application/javascript", y.id = r.id, y.src = r.src, y.async = (u = r.async) !== null && u !== void 0 ? u : !1, y.defer = (h = r.defer) !== null && h !== void 0 ? h : !1;
  var k = function() {
    y.removeEventListener("load", k), y.removeEventListener("error", _), i(r.src);
  }, _ = function(D) {
    y.removeEventListener("load", k), y.removeEventListener("error", _), i(r.src, D);
  };
  y.addEventListener("load", k), y.addEventListener("error", _), o.head && o.head.appendChild(y);
}, UEe = function(o) {
  var r = {}, i = function(k, _) {
    var D = r[k];
    D.done = !0, D.error = _;
    for (var L = 0, W = D.handlers; L < W.length; L++) {
      var se = W[L];
      se(k, _);
    }
    D.handlers = [];
  }, u = function(k, _, D) {
    var L = function(ae) {
      return D !== void 0 ? D(ae) : console.error(ae);
    };
    if (k.length === 0) {
      L(new Error("At least one script must be provided"));
      return;
    }
    for (var W = 0, se = !1, J = function(ae, G) {
      se || (G ? (se = !0, L(G)) : ++W === k.length && _());
    }, be = 0, ke = k; be < ke.length; be++) {
      var Ce = ke[be], Q = r[Ce.src];
      if (Q)
        Q.done ? J(Ce.src, Q.error) : Q.handlers.push(J);
      else {
        var oe = The("tiny-");
        r[Ce.src] = {
          id: oe,
          src: Ce.src,
          done: !1,
          error: null,
          handlers: [J]
        }, jEe(o, Uoe({ id: oe }, Ce), i);
      }
    }
  }, h = function() {
    for (var k, _ = 0, D = Object.values(r); _ < D.length; _++) {
      var L = D[_], W = o.getElementById(L.id);
      W != null && W.tagName === "SCRIPT" && ((k = W.parentNode) === null || k === void 0 || k.removeChild(W));
    }
    r = {};
  }, y = function() {
    return o;
  };
  return {
    loadScripts: u,
    deleteScripts: h,
    getDocument: y
  };
}, WEe = function() {
  var o = [], r = function(h) {
    var y = o.find(function(k) {
      return k.getDocument() === h;
    });
    return y === void 0 && (y = UEe(h), o.push(y)), y;
  }, i = function(h, y, k, _, D) {
    var L = function() {
      return r(h).loadScripts(y, _, D);
    };
    k > 0 ? setTimeout(L, k) : L();
  }, u = function() {
    for (var h = o.pop(); h != null; h = o.pop())
      h.deleteScripts();
  };
  return {
    loadList: i,
    reinitialize: u
  };
}, ZEe = WEe(), Yte = function(o) {
  var r = o;
  return r && r.tinymce ? r.tinymce : null;
}, GEe = /* @__PURE__ */ function() {
  var o = function(r, i) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(u, h) {
      u.__proto__ = h;
    } || function(u, h) {
      for (var y in h) Object.prototype.hasOwnProperty.call(h, y) && (u[y] = h[y]);
    }, o(r, i);
  };
  return function(r, i) {
    if (typeof i != "function" && i !== null)
      throw new TypeError("Class extends value " + String(i) + " is not a constructor or null");
    o(r, i);
    function u() {
      this.constructor = r;
    }
    r.prototype = i === null ? Object.create(i) : (u.prototype = i.prototype, new u());
  };
}(), u3 = function() {
  return u3 = Object.assign || function(o) {
    for (var r, i = 1, u = arguments.length; i < u; i++) {
      r = arguments[i];
      for (var h in r) Object.prototype.hasOwnProperty.call(r, h) && (o[h] = r[h]);
    }
    return o;
  }, u3.apply(this, arguments);
}, qEe = (
  /** @class */
  function(o) {
    GEe(r, o);
    function r(i) {
      var u, h, y, k = o.call(this, i) || this;
      return k.rollbackTimer = void 0, k.valueCursor = void 0, k.rollbackChange = function() {
        var _ = k.editor, D = k.props.value;
        _ && D && D !== k.currentContent && _.undoManager.ignore(function() {
          if (_.setContent(D), k.valueCursor && (!k.inline || _.hasFocus()))
            try {
              _.selection.moveToBookmark(k.valueCursor);
            } catch {
            }
        }), k.rollbackTimer = void 0;
      }, k.handleBeforeInput = function(_) {
        if (k.props.value !== void 0 && k.props.value === k.currentContent && k.editor && (!k.inline || k.editor.hasFocus()))
          try {
            k.valueCursor = k.editor.selection.getBookmark(3);
          } catch {
          }
      }, k.handleBeforeInputSpecial = function(_) {
        (_.key === "Enter" || _.key === "Backspace" || _.key === "Delete") && k.handleBeforeInput(_);
      }, k.handleEditorChange = function(_) {
        var D = k.editor;
        if (D && D.initialized) {
          var L = D.getContent();
          k.props.value !== void 0 && k.props.value !== L && k.props.rollback !== !1 && (k.rollbackTimer || (k.rollbackTimer = window.setTimeout(k.rollbackChange, typeof k.props.rollback == "number" ? k.props.rollback : 200))), L !== k.currentContent && (k.currentContent = L, Kte(k.props.onEditorChange) && k.props.onEditorChange(L, D));
        }
      }, k.handleEditorChangeSpecial = function(_) {
        (_.key === "Backspace" || _.key === "Delete") && k.handleEditorChange(_);
      }, k.initialise = function(_) {
        var D, L, W;
        _ === void 0 && (_ = 0);
        var se = k.elementRef.current;
        if (se) {
          if (!VEe(se)) {
            if (_ === 0)
              setTimeout(function() {
                return k.initialise(1);
              }, 1);
            else if (_ < 100)
              setTimeout(function() {
                return k.initialise(_ + 1);
              }, 100);
            else
              throw new Error("tinymce can only be initialised when in a document");
            return;
          }
          var J = Yte(k.view);
          if (!J)
            throw new Error("tinymce should have been loaded into global scope");
          var be = u3(u3(u3(u3({}, k.props.init), { selector: void 0, target: se, readonly: k.props.disabled, inline: k.inline, plugins: HEe((D = k.props.init) === null || D === void 0 ? void 0 : D.plugins, k.props.plugins), toolbar: (L = k.props.toolbar) !== null && L !== void 0 ? L : (W = k.props.init) === null || W === void 0 ? void 0 : W.toolbar }), k.props.licenseKey ? { license_key: k.props.licenseKey } : {}), { setup: function(ke) {
            k.editor = ke, k.bindHandlers({}), k.inline && !Jue(se) && ke.once("PostRender", function(Ce) {
              ke.setContent(k.getInitialValue(), { no_events: !0 });
            }), k.props.init && Kte(k.props.init.setup) && k.props.init.setup(ke);
          }, init_instance_callback: function(ke) {
            var Ce, Q, oe = k.getInitialValue();
            k.currentContent = (Ce = k.currentContent) !== null && Ce !== void 0 ? Ce : ke.getContent(), k.currentContent !== oe && (k.currentContent = oe, ke.setContent(oe), ke.undoManager.clear(), ke.undoManager.add(), ke.setDirty(!1));
            var ae = (Q = k.props.disabled) !== null && Q !== void 0 ? Q : !1;
            tde(k.editor, ae ? "readonly" : "design"), k.props.init && Kte(k.props.init.init_instance_callback) && k.props.init.init_instance_callback(ke);
          } });
          k.inline || (se.style.visibility = ""), Jue(se) && (se.value = k.getInitialValue()), J.init(be);
        }
      }, k.id = k.props.id || The("tiny-react"), k.elementRef = et.createRef(), k.inline = (y = (u = k.props.inline) !== null && u !== void 0 ? u : (h = k.props.init) === null || h === void 0 ? void 0 : h.inline) !== null && y !== void 0 ? y : !1, k.boundHandlers = {}, k;
    }
    return Object.defineProperty(r.prototype, "view", {
      get: function() {
        var i, u;
        return (u = (i = this.elementRef.current) === null || i === void 0 ? void 0 : i.ownerDocument.defaultView) !== null && u !== void 0 ? u : window;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.componentDidUpdate = function(i) {
      var u = this, h, y;
      if (this.rollbackTimer && (clearTimeout(this.rollbackTimer), this.rollbackTimer = void 0), this.editor && (this.bindHandlers(i), this.editor.initialized)) {
        if (this.currentContent = (h = this.currentContent) !== null && h !== void 0 ? h : this.editor.getContent(), typeof this.props.initialValue == "string" && this.props.initialValue !== i.initialValue)
          this.editor.setContent(this.props.initialValue), this.editor.undoManager.clear(), this.editor.undoManager.add(), this.editor.setDirty(!1);
        else if (typeof this.props.value == "string" && this.props.value !== this.currentContent) {
          var k = this.editor;
          k.undoManager.transact(function() {
            var D;
            if (!u.inline || k.hasFocus())
              try {
                D = k.selection.getBookmark(3);
              } catch {
              }
            var L = u.valueCursor;
            if (k.setContent(u.props.value), !u.inline || k.hasFocus())
              for (var W = 0, se = [D, L]; W < se.length; W++) {
                var J = se[W];
                if (J)
                  try {
                    k.selection.moveToBookmark(J), u.valueCursor = J;
                    break;
                  } catch {
                  }
              }
          });
        }
        if (this.props.disabled !== i.disabled) {
          var _ = (y = this.props.disabled) !== null && y !== void 0 ? y : !1;
          tde(this.editor, _ ? "readonly" : "design");
        }
      }
    }, r.prototype.componentDidMount = function() {
      var i = this, u, h, y, k, _;
      if (Yte(this.view) !== null)
        this.initialise();
      else if (Array.isArray(this.props.tinymceScriptSrc) && this.props.tinymceScriptSrc.length === 0)
        (h = (u = this.props).onScriptsLoadError) === null || h === void 0 || h.call(u, new Error("No `tinymce` global is present but the `tinymceScriptSrc` prop was an empty array."));
      else if (!((y = this.elementRef.current) === null || y === void 0) && y.ownerDocument) {
        var D = function() {
          var W, se;
          (se = (W = i.props).onScriptsLoad) === null || se === void 0 || se.call(W), i.initialise();
        }, L = function(W) {
          var se, J;
          (J = (se = i.props).onScriptsLoadError) === null || J === void 0 || J.call(se, W);
        };
        ZEe.loadList(this.elementRef.current.ownerDocument, this.getScriptSources(), (_ = (k = this.props.scriptLoading) === null || k === void 0 ? void 0 : k.delay) !== null && _ !== void 0 ? _ : 0, D, L);
      }
    }, r.prototype.componentWillUnmount = function() {
      var i = this, u = this.editor;
      u && (u.off(this.changeEvents(), this.handleEditorChange), u.off(this.beforeInputEvent(), this.handleBeforeInput), u.off("keypress", this.handleEditorChangeSpecial), u.off("keydown", this.handleBeforeInputSpecial), u.off("NewBlock", this.handleEditorChange), Object.keys(this.boundHandlers).forEach(function(h) {
        u.off(h, i.boundHandlers[h]);
      }), this.boundHandlers = {}, u.remove(), this.editor = void 0);
    }, r.prototype.render = function() {
      return this.inline ? this.renderInline() : this.renderIframe();
    }, r.prototype.changeEvents = function() {
      var i, u, h, y = (h = (u = (i = Yte(this.view)) === null || i === void 0 ? void 0 : i.Env) === null || u === void 0 ? void 0 : u.browser) === null || h === void 0 ? void 0 : h.isIE();
      return y ? "change keyup compositionend setcontent CommentChange" : "change input compositionend setcontent CommentChange";
    }, r.prototype.beforeInputEvent = function() {
      return zEe() ? "beforeinput SelectionChange" : "SelectionChange";
    }, r.prototype.renderInline = function() {
      var i = this.props.tagName, u = i === void 0 ? "div" : i;
      return et.createElement(u, {
        ref: this.elementRef,
        id: this.id,
        tabIndex: this.props.tabIndex
      });
    }, r.prototype.renderIframe = function() {
      return et.createElement("textarea", {
        ref: this.elementRef,
        style: { visibility: "hidden" },
        name: this.props.textareaName,
        id: this.id,
        tabIndex: this.props.tabIndex
      });
    }, r.prototype.getScriptSources = function() {
      var i, u, h = (i = this.props.scriptLoading) === null || i === void 0 ? void 0 : i.async, y = (u = this.props.scriptLoading) === null || u === void 0 ? void 0 : u.defer;
      if (this.props.tinymceScriptSrc !== void 0)
        return typeof this.props.tinymceScriptSrc == "string" ? [{ src: this.props.tinymceScriptSrc, async: h, defer: y }] : this.props.tinymceScriptSrc.map(function(L) {
          return typeof L == "string" ? { src: L, async: h, defer: y } : L;
        });
      var k = this.props.cloudChannel, _ = this.props.apiKey ? this.props.apiKey : "no-api-key", D = "https://cdn.tiny.cloud/1/".concat(_, "/tinymce/").concat(k, "/tinymce.min.js");
      return [{ src: D, async: h, defer: y }];
    }, r.prototype.getInitialValue = function() {
      return typeof this.props.initialValue == "string" ? this.props.initialValue : typeof this.props.value == "string" ? this.props.value : "";
    }, r.prototype.bindHandlers = function(i) {
      var u = this;
      if (this.editor !== void 0) {
        LEe(this.editor, i, this.props, this.boundHandlers, function(_) {
          return u.props[_];
        });
        var h = function(_) {
          return _.onEditorChange !== void 0 || _.value !== void 0;
        }, y = h(i), k = h(this.props);
        !y && k ? (this.editor.on(this.changeEvents(), this.handleEditorChange), this.editor.on(this.beforeInputEvent(), this.handleBeforeInput), this.editor.on("keydown", this.handleBeforeInputSpecial), this.editor.on("keyup", this.handleEditorChangeSpecial), this.editor.on("NewBlock", this.handleEditorChange)) : y && !k && (this.editor.off(this.changeEvents(), this.handleEditorChange), this.editor.off(this.beforeInputEvent(), this.handleBeforeInput), this.editor.off("keydown", this.handleBeforeInputSpecial), this.editor.off("keyup", this.handleEditorChangeSpecial), this.editor.off("NewBlock", this.handleEditorChange));
      }
    }, r.propTypes = BEe, r.defaultProps = {
      cloudChannel: "7"
    }, r;
  }(et.Component)
), KEe = { exports: {} };
(function(o) {
  (function() {
    var r = function(e) {
      if (e === null)
        return "null";
      if (e === void 0)
        return "undefined";
      var n = typeof e;
      return n === "object" && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === "Array") ? "array" : n === "object" && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === "String") ? "string" : n;
    }, i = function(e) {
      return [
        "undefined",
        "boolean",
        "number",
        "string",
        "function",
        "xml",
        "null"
      ].indexOf(e) !== -1;
    }, u = function(e, n) {
      var s = Array.prototype.slice.call(e);
      return s.sort(n);
    }, h = function(e, n) {
      return y(function(s, l) {
        return e.eq(n(s), n(l));
      });
    }, y = function(e) {
      return { eq: e };
    }, k = y(function(e, n) {
      return e === n;
    }), _ = k, D = function(e) {
      return y(function(n, s) {
        if (n.length !== s.length)
          return !1;
        for (var l = n.length, d = 0; d < l; d++)
          if (!e.eq(n[d], s[d]))
            return !1;
        return !0;
      });
    }, L = function(e, n) {
      return h(D(e), function(s) {
        return u(s, n);
      });
    }, W = function(e) {
      return y(function(n, s) {
        var l = Object.keys(n), d = Object.keys(s);
        if (!L(_).eq(l, d))
          return !1;
        for (var p = l.length, v = 0; v < p; v++) {
          var S = l[v];
          if (!e.eq(n[S], s[S]))
            return !1;
        }
        return !0;
      });
    }, se = y(function(e, n) {
      if (e === n)
        return !0;
      var s = r(e), l = r(n);
      return s !== l ? !1 : i(s) ? e === n : s === "array" ? D(se).eq(e, n) : s === "object" ? W(se).eq(e, n) : !1;
    });
    const J = Object.getPrototypeOf, be = (e, n, s) => {
      var l;
      return s(e, n.prototype) ? !0 : ((l = e.constructor) === null || l === void 0 ? void 0 : l.name) === n.name;
    }, ke = (e) => {
      const n = typeof e;
      return e === null ? "null" : n === "object" && Array.isArray(e) ? "array" : n === "object" && be(e, String, (s, l) => l.isPrototypeOf(s)) ? "string" : n;
    }, Ce = (e) => (n) => ke(n) === e, Q = (e) => (n) => typeof n === e, oe = (e) => (n) => e === n, ae = (e, n) => ve(e) && be(e, n, (s, l) => J(s) === l), G = Ce("string"), ve = Ce("object"), nt = (e) => ae(e, Object), Xe = Ce("array"), te = oe(null), lt = Q("boolean"), ot = oe(void 0), Kt = (e) => e == null, je = (e) => !Kt(e), ye = Q("function"), dn = Q("number"), wt = (e, n) => {
      if (Xe(e)) {
        for (let s = 0, l = e.length; s < l; ++s)
          if (!n(e[s]))
            return !1;
        return !0;
      }
      return !1;
    }, qe = () => {
    }, B = (e, n) => (...s) => e(n.apply(null, s)), mn = (e, n) => (s) => e(n(s)), dt = (e) => () => e, En = (e) => e, tn = (e, n) => e === n;
    function Le(e, ...n) {
      return (...s) => {
        const l = n.concat(s);
        return e.apply(null, l);
      };
    }
    const jt = (e) => (n) => !e(n), Fn = (e) => () => {
      throw new Error(e);
    }, St = (e) => e(), on = (e) => {
      e();
    }, tt = dt(!1), mt = dt(!0);
    class Y {
      constructor(n, s) {
        this.tag = n, this.value = s;
      }
      static some(n) {
        return new Y(!0, n);
      }
      static none() {
        return Y.singletonNone;
      }
      fold(n, s) {
        return this.tag ? s(this.value) : n();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(n) {
        return this.tag ? Y.some(n(this.value)) : Y.none();
      }
      bind(n) {
        return this.tag ? n(this.value) : Y.none();
      }
      exists(n) {
        return this.tag && n(this.value);
      }
      forall(n) {
        return !this.tag || n(this.value);
      }
      filter(n) {
        return !this.tag || n(this.value) ? this : Y.none();
      }
      getOr(n) {
        return this.tag ? this.value : n;
      }
      or(n) {
        return this.tag ? this : n;
      }
      getOrThunk(n) {
        return this.tag ? this.value : n();
      }
      orThunk(n) {
        return this.tag ? this : n();
      }
      getOrDie(n) {
        if (this.tag)
          return this.value;
        throw new Error(n ?? "Called getOrDie on None");
      }
      static from(n) {
        return je(n) ? Y.some(n) : Y.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(n) {
        this.tag && n(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    Y.singletonNone = new Y(!1);
    const Wo = Array.prototype.slice, To = Array.prototype.indexOf, Ot = Array.prototype.push, Mt = (e, n) => To.call(e, n), zn = (e, n) => {
      const s = Mt(e, n);
      return s === -1 ? Y.none() : Y.some(s);
    }, At = (e, n) => Mt(e, n) > -1, $n = (e, n) => {
      for (let s = 0, l = e.length; s < l; s++) {
        const d = e[s];
        if (n(d, s))
          return !0;
      }
      return !1;
    }, en = (e, n) => {
      const s = e.length, l = new Array(s);
      for (let d = 0; d < s; d++) {
        const p = e[d];
        l[d] = n(p, d);
      }
      return l;
    }, Ue = (e, n) => {
      for (let s = 0, l = e.length; s < l; s++) {
        const d = e[s];
        n(d, s);
      }
    }, jn = (e, n) => {
      for (let s = e.length - 1; s >= 0; s--) {
        const l = e[s];
        n(l, s);
      }
    }, mo = (e, n) => {
      const s = [], l = [];
      for (let d = 0, p = e.length; d < p; d++) {
        const v = e[d];
        (n(v, d) ? s : l).push(v);
      }
      return {
        pass: s,
        fail: l
      };
    }, xn = (e, n) => {
      const s = [];
      for (let l = 0, d = e.length; l < d; l++) {
        const p = e[l];
        n(p, l) && s.push(p);
      }
      return s;
    }, Vt = (e, n, s) => (jn(e, (l, d) => {
      s = n(s, l, d);
    }), s), Ct = (e, n, s) => (Ue(e, (l, d) => {
      s = n(s, l, d);
    }), s), Jn = (e, n, s) => {
      for (let l = 0, d = e.length; l < d; l++) {
        const p = e[l];
        if (n(p, l))
          return Y.some(p);
        if (s(p, l))
          break;
      }
      return Y.none();
    }, Pn = (e, n) => Jn(e, n, tt), so = (e, n) => {
      for (let s = 0, l = e.length; s < l; s++) {
        const d = e[s];
        if (n(d, s))
          return Y.some(s);
      }
      return Y.none();
    }, pr = (e) => {
      const n = [];
      for (let s = 0, l = e.length; s < l; ++s) {
        if (!Xe(e[s]))
          throw new Error("Arr.flatten item " + s + " was not an array, input: " + e);
        Ot.apply(n, e[s]);
      }
      return n;
    }, nr = (e, n) => pr(en(e, n)), Ko = (e, n) => {
      for (let s = 0, l = e.length; s < l; ++s) {
        const d = e[s];
        if (n(d, s) !== !0)
          return !1;
      }
      return !0;
    }, Qo = (e) => {
      const n = Wo.call(e, 0);
      return n.reverse(), n;
    }, Mr = (e, n) => xn(e, (s) => !At(n, s)), at = (e, n) => {
      const s = {};
      for (let l = 0, d = e.length; l < d; l++) {
        const p = e[l];
        s[String(p)] = n(p, l);
      }
      return s;
    }, kt = (e, n) => {
      const s = Wo.call(e, 0);
      return s.sort(n), s;
    }, yn = (e, n) => n >= 0 && n < e.length ? Y.some(e[n]) : Y.none(), pn = (e) => yn(e, 0), Oo = (e) => yn(e, e.length - 1), hr = ye(Array.from) ? Array.from : (e) => Wo.call(e), or = (e, n) => {
      for (let s = 0; s < e.length; s++) {
        const l = n(e[s], s);
        if (l.isSome())
          return l;
      }
      return Y.none();
    }, Ir = (e, n) => {
      const s = [], l = ye(n) ? (d) => $n(s, (p) => n(p, d)) : (d) => At(s, d);
      for (let d = 0, p = e.length; d < p; d++) {
        const v = e[d];
        l(v) || s.push(v);
      }
      return s;
    }, Zo = Object.keys, Tr = Object.hasOwnProperty, Ht = (e, n) => {
      const s = Zo(e);
      for (let l = 0, d = s.length; l < d; l++) {
        const p = s[l], v = e[p];
        n(v, p);
      }
    }, Ho = (e, n) => As(e, (s, l) => ({
      k: l,
      v: n(s, l)
    })), As = (e, n) => {
      const s = {};
      return Ht(e, (l, d) => {
        const p = n(l, d);
        s[p.k] = p.v;
      }), s;
    }, ra = (e) => (n, s) => {
      e[s] = n;
    }, qs = (e, n, s, l) => {
      Ht(e, (d, p) => {
        (n(d, p) ? s : l)(d, p);
      });
    }, Ks = (e, n) => {
      const s = {}, l = {};
      return qs(e, n, ra(s), ra(l)), {
        t: s,
        f: l
      };
    }, kr = (e, n) => {
      const s = {};
      return qs(e, n, ra(s), qe), s;
    }, xa = (e, n) => {
      const s = [];
      return Ht(e, (l, d) => {
        s.push(n(l, d));
      }), s;
    }, ca = (e) => xa(e, En), Or = (e, n) => Xn(e, n) ? Y.from(e[n]) : Y.none(), Xn = (e, n) => Tr.call(e, n), Ss = (e, n) => Xn(e, n) && e[n] !== void 0 && e[n] !== null, Ke = (e, n, s = se) => W(s).eq(e, n), bt = (e) => {
      const n = {};
      return Ue(e, (s) => {
        n[s] = {};
      }), Zo(n);
    }, gn = (e) => e.length !== void 0, Tn = Array.isArray, Po = (e) => {
      if (Tn(e))
        return e;
      {
        const n = [];
        for (let s = 0, l = e.length; s < l; s++)
          n[s] = e[s];
        return n;
      }
    }, cr = (e, n, s) => {
      if (!e)
        return !1;
      if (s = s || e, gn(e)) {
        for (let l = 0, d = e.length; l < d; l++)
          if (n.call(s, e[l], l, e) === !1)
            return !1;
      } else
        for (const l in e)
          if (Xn(e, l) && n.call(s, e[l], l, e) === !1)
            return !1;
      return !0;
    }, ea = (e, n) => {
      const s = [];
      return cr(e, (l, d) => {
        s.push(n(l, d, e));
      }), s;
    }, ta = (e, n) => {
      const s = [];
      return cr(e, (l, d) => {
        (!n || n(l, d, e)) && s.push(l);
      }), s;
    }, Ps = (e, n) => {
      if (e) {
        for (let s = 0, l = e.length; s < l; s++)
          if (e[s] === n)
            return s;
      }
      return -1;
    }, Re = (e, n, s, l) => {
      let d = ot(s) ? e[0] : s;
      for (let p = 0; p < e.length; p++)
        d = n.call(l, d, e[p], p);
      return d;
    }, Oe = (e, n, s) => {
      for (let l = 0, d = e.length; l < d; l++)
        if (n.call(s, e[l], l, e))
          return l;
      return -1;
    }, ct = (e) => e[e.length - 1], _t = (e) => {
      let n = !1, s;
      return (...l) => (n || (n = !0, s = e.apply(null, l)), s);
    }, Kn = (e, n, s, l) => {
      const d = e.isiOS() && /ipad/i.test(s) === !0, p = e.isiOS() && !d, v = e.isiOS() || e.isAndroid(), S = v || l("(pointer:coarse)"), O = d || !p && v && l("(min-device-width:768px)"), M = p || v && !O, j = n.isSafari() && e.isiOS() && /safari/i.test(s) === !1, U = !M && !O && !j;
      return {
        isiPad: dt(d),
        isiPhone: dt(p),
        isTablet: dt(O),
        isPhone: dt(M),
        isTouch: dt(S),
        isAndroid: e.isAndroid,
        isiOS: e.isiOS,
        isWebView: dt(j),
        isDesktop: dt(U)
      };
    }, io = (e, n) => {
      for (let s = 0; s < e.length; s++) {
        const l = e[s];
        if (l.test(n))
          return l;
      }
    }, Bo = (e, n) => {
      const s = io(e, n);
      if (!s)
        return {
          major: 0,
          minor: 0
        };
      const l = (d) => Number(n.replace(s, "$" + d));
      return Do(l(1), l(2));
    }, Jr = (e, n) => {
      const s = String(n).toLowerCase();
      return e.length === 0 ? He() : Bo(e, s);
    }, He = () => Do(0, 0), Do = (e, n) => ({
      major: e,
      minor: n
    }), Ne = {
      nu: Do,
      detect: Jr,
      unknown: He
    }, Ie = (e, n) => or(n.brands, (s) => {
      const l = s.brand.toLowerCase();
      return Pn(e, (d) => {
        var p;
        return l === ((p = d.brand) === null || p === void 0 ? void 0 : p.toLowerCase());
      }).map((d) => ({
        current: d.name,
        version: Ne.nu(parseInt(s.version, 10), 0)
      }));
    }), Bt = (e, n) => {
      const s = String(n).toLowerCase();
      return Pn(e, (l) => l.search(s));
    }, Wt = (e, n) => Bt(e, n).map((s) => {
      const l = Ne.detect(s.versionRegexes, n);
      return {
        current: s.name,
        version: l
      };
    }), kn = (e, n) => Bt(e, n).map((s) => {
      const l = Ne.detect(s.versionRegexes, n);
      return {
        current: s.name,
        version: l
      };
    }), eo = (e, n) => e.substring(n), Gn = (e, n, s) => n === "" || e.length >= n.length && e.substr(s, s + n.length) === n, qn = (e, n) => lo(e, n) ? eo(e, n.length) : e, Qn = (e, n, s = 0, l) => {
      const d = e.indexOf(n, s);
      return d !== -1 ? ot(l) ? !0 : d + n.length <= l : !1;
    }, lo = (e, n) => Gn(e, n, 0), rr = (e, n) => Gn(e, n, e.length - n.length), Kr = (e) => (n) => n.replace(e, ""), Wa = Kr(/^\s+|\s+$/g), Ei = Kr(/^\s+/g), Ti = Kr(/\s+$/g), ko = (e) => e.length > 0, Yo = (e) => !ko(e), Fr = (e, n) => n <= 0 ? "" : new Array(n + 1).join(e), Ba = (e, n = 10) => {
      const s = parseInt(e, n);
      return isNaN(s) ? Y.none() : Y.some(s);
    }, ua = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, vs = (e) => (n) => Qn(n, e), es = [
      {
        name: "Edge",
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: (e) => Qn(e, "edge/") && Qn(e, "chrome") && Qn(e, "safari") && Qn(e, "applewebkit")
      },
      {
        name: "Chromium",
        brand: "Chromium",
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          ua
        ],
        search: (e) => Qn(e, "chrome") && !Qn(e, "chromeframe")
      },
      {
        name: "IE",
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: (e) => Qn(e, "msie") || Qn(e, "trident")
      },
      {
        name: "Opera",
        versionRegexes: [
          ua,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: vs("opera")
      },
      {
        name: "Firefox",
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: vs("firefox")
      },
      {
        name: "Safari",
        versionRegexes: [
          ua,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: (e) => (Qn(e, "safari") || Qn(e, "mobile/")) && Qn(e, "applewebkit")
      }
    ], ai = [
      {
        name: "Windows",
        search: vs("win"),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "iOS",
        search: (e) => Qn(e, "iphone") || Qn(e, "ipad"),
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: "Android",
        search: vs("android"),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "macOS",
        search: vs("mac os x"),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: "Linux",
        search: vs("linux"),
        versionRegexes: []
      },
      {
        name: "Solaris",
        search: vs("sunos"),
        versionRegexes: []
      },
      {
        name: "FreeBSD",
        search: vs("freebsd"),
        versionRegexes: []
      },
      {
        name: "ChromeOS",
        search: vs("cros"),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ], vc = {
      browsers: dt(es),
      oses: dt(ai)
    }, Lr = "Edge", ka = "Chromium", ii = "IE", na = "Opera", Oi = "Firefox", cl = "Safari", Za = () => Ai({
      current: void 0,
      version: Ne.unknown()
    }), Ai = (e) => {
      const n = e.current, s = e.version, l = (d) => () => n === d;
      return {
        current: n,
        version: s,
        isEdge: l(Lr),
        isChromium: l(ka),
        isIE: l(ii),
        isOpera: l(na),
        isFirefox: l(Oi),
        isSafari: l(cl)
      };
    }, Ui = {
      unknown: Za,
      nu: Ai,
      edge: dt(Lr),
      chromium: dt(ka),
      ie: dt(ii),
      opera: dt(na),
      firefox: dt(Oi),
      safari: dt(cl)
    }, au = "Windows", gi = "iOS", Ml = "Android", $a = "Linux", Wi = "macOS", Kl = "Solaris", yc = "FreeBSD", ld = "ChromeOS", iu = () => bi({
      current: void 0,
      version: Ne.unknown()
    }), bi = (e) => {
      const n = e.current, s = e.version, l = (d) => () => n === d;
      return {
        current: n,
        version: s,
        isWindows: l(au),
        isiOS: l(gi),
        isAndroid: l(Ml),
        isMacOS: l(Wi),
        isLinux: l($a),
        isSolaris: l(Kl),
        isFreeBSD: l(yc),
        isChromeOS: l(ld)
      };
    }, Ru = {
      unknown: iu,
      nu: bi,
      windows: dt(au),
      ios: dt(gi),
      android: dt(Ml),
      linux: dt($a),
      macos: dt(Wi),
      solaris: dt(Kl),
      freebsd: dt(yc),
      chromeos: dt(ld)
    }, Ae = { detect: (e, n, s) => {
      const l = vc.browsers(), d = vc.oses(), p = n.bind((O) => Ie(l, O)).orThunk(() => Wt(l, e)).fold(Ui.unknown, Ui.nu), v = kn(d, e).fold(Ru.unknown, Ru.nu), S = Kn(v, p, e, s);
      return {
        browser: p,
        os: v,
        deviceType: S
      };
    } }, Ze = (e) => window.matchMedia(e).matches;
    let Dt = _t(() => Ae.detect(navigator.userAgent, Y.from(navigator.userAgentData), Ze));
    const Yt = () => Dt(), Wn = navigator.userAgent, lr = Yt(), yr = lr.browser, Uo = lr.os, Yr = lr.deviceType, Ds = Wn.indexOf("Windows Phone") !== -1, rn = {
      transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
      documentMode: yr.isIE() ? document.documentMode || 7 : 10,
      cacheSuffix: null,
      container: null,
      canHaveCSP: !yr.isIE(),
      windowsPhone: Ds,
      browser: {
        current: yr.current,
        version: yr.version,
        isChromium: yr.isChromium,
        isEdge: yr.isEdge,
        isFirefox: yr.isFirefox,
        isIE: yr.isIE,
        isOpera: yr.isOpera,
        isSafari: yr.isSafari
      },
      os: {
        current: Uo.current,
        version: Uo.version,
        isAndroid: Uo.isAndroid,
        isChromeOS: Uo.isChromeOS,
        isFreeBSD: Uo.isFreeBSD,
        isiOS: Uo.isiOS,
        isLinux: Uo.isLinux,
        isMacOS: Uo.isMacOS,
        isSolaris: Uo.isSolaris,
        isWindows: Uo.isWindows
      },
      deviceType: {
        isDesktop: Yr.isDesktop,
        isiPad: Yr.isiPad,
        isiPhone: Yr.isiPhone,
        isPhone: Yr.isPhone,
        isTablet: Yr.isTablet,
        isTouch: Yr.isTouch,
        isWebView: Yr.isWebView
      }
    }, cd = /^\s*|\s*$/g, os = (e) => Kt(e) ? "" : ("" + e).replace(cd, ""), K = (e, n) => n ? n === "array" && Tn(e) ? !0 : typeof e === n : e !== void 0, ge = (e, n, s = {}) => {
      const l = G(e) ? e.split(n || ",") : e || [];
      let d = l.length;
      for (; d--; )
        s[l[d]] = {};
      return s;
    }, Ee = Xn, ft = (e, ...n) => {
      for (let s = 0; s < n.length; s++) {
        const l = n[s];
        for (const d in l)
          if (Xn(l, d)) {
            const p = l[d];
            p !== void 0 && (e[d] = p);
          }
      }
      return e;
    }, Cn = function(e, n, s, l) {
      l = l || this, e && (s && (e = e[s]), cr(e, (d, p) => n.call(l, d, p, s) === !1 ? !1 : (Cn(d, n, s, l), !0)));
    }, Gt = {
      trim: os,
      isArray: Tn,
      is: K,
      toArray: Po,
      makeMap: ge,
      each: cr,
      map: ea,
      grep: ta,
      inArray: Ps,
      hasOwn: Ee,
      extend: ft,
      walk: Cn,
      resolve: (e, n = window) => {
        const s = e.split(".");
        for (let l = 0, d = s.length; l < d && (n = n[s[l]], !!n); l++)
          ;
        return n;
      },
      explode: (e, n) => Xe(e) ? e : e === "" ? [] : ea(e.split(n || ","), os),
      _addCacheSuffix: (e) => {
        const n = rn.cacheSuffix;
        return n && (e += (e.indexOf("?") === -1 ? "?" : "&") + n), e;
      }
    }, fs = (e, n, s = tn) => e.exists((l) => s(l, n)), vi = (e, n, s = tn) => ga(e, n, s).getOr(e.isNone() && n.isNone()), ks = (e) => {
      const n = [], s = (l) => {
        n.push(l);
      };
      for (let l = 0; l < e.length; l++)
        e[l].each(s);
      return n;
    }, ga = (e, n, s) => e.isSome() && n.isSome() ? Y.some(s(e.getOrDie(), n.getOrDie())) : Y.none(), Il = (e, n, s, l) => e.isSome() && n.isSome() && s.isSome() ? Y.some(l(e.getOrDie(), n.getOrDie(), s.getOrDie())) : Y.none(), xr = (e, n) => e ? Y.some(n) : Y.none(), yi = typeof window < "u" ? window : Function("return this;")(), Ns = (e, n) => {
      let s = n ?? yi;
      for (let l = 0; l < e.length && s !== void 0 && s !== null; ++l)
        s = s[e[l]];
      return s;
    }, xc = (e, n) => {
      const s = e.split(".");
      return Ns(s, n);
    }, Bs = (e, n) => xc(e, n), ud = (e, n) => {
      const s = Bs(e, n);
      if (s == null)
        throw new Error(e + " not available on this browser");
      return s;
    }, vm = Object.getPrototypeOf, Oh = (e) => ud("HTMLElement", e), zs = (e) => {
      const n = xc("ownerDocument.defaultView", e);
      return ve(e) && (Oh(n).prototype.isPrototypeOf(e) || /^HTML\w*Element$/.test(vm(e).constructor.name));
    }, Yl = 8, La = 9, Ga = 11, xi = 1, Of = 3, gr = (e) => e.dom.nodeName.toLowerCase(), Pi = (e) => e.dom.nodeType, li = (e) => (n) => Pi(n) === e, pe = (e) => Pi(e) === Yl || gr(e) === "#comment", Te = (e) => rt(e) && zs(e.dom), rt = li(xi), pt = li(Of), to = li(La), sr = li(Ga), _s = (e) => (n) => rt(n) && gr(n) === e, Ha = (e, n, s) => {
      if (G(s) || lt(s) || dn(s))
        e.setAttribute(n, s + "");
      else
        throw console.error("Invalid call to Attribute.set. Key ", n, ":: Value ", s, ":: Element ", e), new Error("Attribute value was not simple");
    }, ur = (e, n, s) => {
      Ha(e.dom, n, s);
    }, _a = (e, n) => {
      const s = e.dom;
      Ht(n, (l, d) => {
        Ha(s, d, l);
      });
    }, Ms = (e, n) => {
      const s = e.dom.getAttribute(n);
      return s === null ? void 0 : s;
    }, da = (e, n) => Y.from(Ms(e, n)), sa = (e, n) => {
      const s = e.dom;
      return s && s.hasAttribute ? s.hasAttribute(n) : !1;
    }, oa = (e, n) => {
      e.dom.removeAttribute(n);
    }, ul = (e) => {
      const n = e.dom.attributes;
      return n == null || n.length === 0;
    }, wc = (e) => Ct(e.dom.attributes, (n, s) => (n[s.name] = s.value, n), {}), qa = (e, n) => {
      const s = Ms(e, n);
      return s === void 0 || s === "" ? [] : s.split(" ");
    }, dl = (e, n, s) => {
      const d = qa(e, n).concat([s]);
      return ur(e, n, d.join(" ")), !0;
    }, Mc = (e, n, s) => {
      const l = xn(qa(e, n), (d) => d !== s);
      return l.length > 0 ? ur(e, n, l.join(" ")) : oa(e, n), !1;
    }, Ic = (e) => e.dom.classList !== void 0, ip = (e) => qa(e, "class"), dd = (e, n) => dl(e, "class", n), Cc = (e, n) => Mc(e, "class", n), Zi = (e, n) => At(ip(e), n) ? Cc(e, n) : dd(e, n), fd = (e, n) => {
      Ic(e) ? e.dom.classList.add(n) : dd(e, n);
    }, Af = (e) => {
      (Ic(e) ? e.dom.classList : ip(e)).length === 0 && oa(e, "class");
    }, lu = (e, n) => {
      Ic(e) ? e.dom.classList.remove(n) : Cc(e, n), Af(e);
    }, Ah = (e, n) => {
      const s = Ic(e) ? e.dom.classList.toggle(n) : Zi(e, n);
      return Af(e), s;
    }, Pf = (e, n) => Ic(e) && e.dom.classList.contains(n), Ph = (e, n) => {
      const l = (n || document).createElement("div");
      if (l.innerHTML = e, !l.hasChildNodes() || l.childNodes.length > 1) {
        const d = "HTML does not have a single root node";
        throw console.error(d, e), new Error(d);
      }
      return Zd(l.childNodes[0]);
    }, Wd = (e, n) => {
      const l = (n || document).createElement(e);
      return Zd(l);
    }, Dh = (e, n) => {
      const l = (n || document).createTextNode(e);
      return Zd(l);
    }, Zd = (e) => {
      if (e == null)
        throw new Error("Node cannot be null or undefined");
      return { dom: e };
    }, Me = {
      fromHtml: Ph,
      fromTag: Wd,
      fromText: Dh,
      fromDom: Zd,
      fromPoint: (e, n, s) => Y.from(e.dom.elementFromPoint(n, s)).map(Zd)
    }, ym = (e, n) => {
      const s = [], l = (p) => (s.push(p), n(p));
      let d = n(e);
      do
        d = d.bind(l);
      while (d.isSome());
      return s;
    }, wl = (e, n) => {
      const s = e.dom;
      if (s.nodeType !== xi)
        return !1;
      {
        const l = s;
        if (l.matches !== void 0)
          return l.matches(n);
        if (l.msMatchesSelector !== void 0)
          return l.msMatchesSelector(n);
        if (l.webkitMatchesSelector !== void 0)
          return l.webkitMatchesSelector(n);
        if (l.mozMatchesSelector !== void 0)
          return l.mozMatchesSelector(n);
        throw new Error("Browser lacks native selectors");
      }
    }, Nu = (e) => e.nodeType !== xi && e.nodeType !== La && e.nodeType !== Ga || e.childElementCount === 0, Rh = (e, n) => {
      const s = n === void 0 ? document : n.dom;
      return Nu(s) ? [] : en(s.querySelectorAll(e), Me.fromDom);
    }, Wg = (e, n) => {
      const s = n === void 0 ? document : n.dom;
      return Nu(s) ? Y.none() : Y.from(s.querySelector(e)).map(Me.fromDom);
    }, zr = (e, n) => e.dom === n.dom, Gi = (e, n) => {
      const s = e.dom, l = n.dom;
      return s === l ? !1 : s.contains(l);
    }, Fl = (e) => Me.fromDom(e.dom.ownerDocument), Ka = (e) => to(e) ? e : Fl(e), Gd = (e) => Me.fromDom(Ka(e).dom.documentElement), Fc = (e) => Me.fromDom(Ka(e).dom.defaultView), Di = (e) => Y.from(e.dom.parentNode).map(Me.fromDom), Bc = (e) => Y.from(e.dom.parentElement).map(Me.fromDom), Nh = (e, n) => {
      const s = ye(n) ? n : tt;
      let l = e.dom;
      const d = [];
      for (; l.parentNode !== null && l.parentNode !== void 0; ) {
        const p = l.parentNode, v = Me.fromDom(p);
        if (d.push(v), s(v) === !0)
          break;
        l = p;
      }
      return d;
    }, Zg = (e) => {
      const n = (s) => xn(s, (l) => !zr(e, l));
      return Di(e).map(Ya).map(n).getOr([]);
    }, Xl = (e) => Y.from(e.dom.previousSibling).map(Me.fromDom), $c = (e) => Y.from(e.dom.nextSibling).map(Me.fromDom), lp = (e) => Qo(ym(e, Xl)), qi = (e) => ym(e, $c), Ya = (e) => en(e.dom.childNodes, Me.fromDom), md = (e, n) => {
      const s = e.dom.childNodes;
      return Y.from(s[n]).map(Me.fromDom);
    }, Df = (e) => md(e, 0), Sc = (e) => md(e, e.dom.childNodes.length - 1), wi = (e) => e.dom.childNodes.length, cp = (e) => {
      const n = e.dom.head;
      if (n == null)
        throw new Error("Head is not available yet");
      return Me.fromDom(n);
    }, up = (e) => sr(e) && je(e.dom.host), dp = ye(Element.prototype.attachShadow) && ye(Node.prototype.getRootNode), xm = dt(dp), Ql = dp ? (e) => Me.fromDom(e.dom.getRootNode()) : Ka, fp = (e) => up(e) ? e : cp(Ka(e)), Gg = (e) => up(e) ? e : Me.fromDom(Ka(e).dom.body), kv = (e) => {
      const n = Ql(e);
      return up(n) ? Y.some(n) : Y.none();
    }, qg = (e) => Me.fromDom(e.dom.host), mp = (e) => {
      if (xm() && je(e.target)) {
        const n = Me.fromDom(e.target);
        if (rt(n) && wm(n) && e.composed && e.composedPath) {
          const s = e.composedPath();
          if (s)
            return pn(s);
        }
      }
      return Y.from(e.target);
    }, wm = (e) => je(e.dom.shadowRoot), Mu = (e) => {
      const n = pt(e) ? e.dom.parentNode : e.dom;
      if (n == null || n.ownerDocument === null)
        return !1;
      const s = n.ownerDocument;
      return kv(Me.fromDom(n)).fold(() => s.body.contains(n), mn(Mu, qg));
    };
    var Mh = (e, n, s, l, d) => e(s, l) ? Y.some(s) : ye(d) && d(s) ? Y.none() : n(s, l, d);
    const Is = (e, n, s) => {
      let l = e.dom;
      const d = ye(s) ? s : tt;
      for (; l.parentNode; ) {
        l = l.parentNode;
        const p = Me.fromDom(l);
        if (n(p))
          return Y.some(p);
        if (d(p))
          break;
      }
      return Y.none();
    }, aa = (e, n, s) => Mh((d, p) => p(d), Is, e, n, s), Cl = (e, n) => {
      const s = e.dom;
      return s.parentNode ? Ih(Me.fromDom(s.parentNode), (l) => !zr(e, l) && n(l)) : Y.none();
    }, Ih = (e, n) => {
      const s = (d) => n(Me.fromDom(d));
      return Pn(e.dom.childNodes, s).map(Me.fromDom);
    }, Fh = (e, n) => {
      const s = (l) => {
        for (let d = 0; d < l.childNodes.length; d++) {
          const p = Me.fromDom(l.childNodes[d]);
          if (n(p))
            return Y.some(p);
          const v = s(l.childNodes[d]);
          if (v.isSome())
            return v;
        }
        return Y.none();
      };
      return s(e.dom);
    }, Ra = (e, n, s) => Is(e, (l) => wl(l, n), s), no = (e, n) => Wg(n, e), cu = (e, n, s) => Mh((d, p) => wl(d, p), Ra, e, n, s), Kg = (e) => cu(e, "[contenteditable]"), za = (e, n = !1) => Mu(e) ? e.dom.isContentEditable : Kg(e).fold(dt(n), (s) => ms(s) === "true"), ms = (e) => e.dom.contentEditable, qd = (e) => e.style !== void 0 && ye(e.style.getPropertyValue), Bh = (e, n, s) => {
      if (!G(s))
        throw console.error("Invalid call to CSS.set. Property ", n, ":: Value ", s, ":: Element ", e), new Error("CSS value must be a string: " + s);
      qd(e) && e.style.setProperty(n, s);
    }, pp = (e, n) => {
      qd(e) && e.style.removeProperty(n);
    }, hp = (e, n, s) => {
      const l = e.dom;
      Bh(l, n, s);
    }, zo = (e, n) => {
      const s = e.dom;
      Ht(n, (l, d) => {
        Bh(s, d, l);
      });
    }, fa = (e, n) => {
      const s = e.dom, d = window.getComputedStyle(s).getPropertyValue(n);
      return d === "" && !Mu(e) ? Rf(s, n) : d;
    }, Rf = (e, n) => qd(e) ? e.style.getPropertyValue(n) : "", Sl = (e, n) => {
      const s = e.dom, l = Rf(s, n);
      return Y.from(l).filter((d) => d.length > 0);
    }, fl = (e) => {
      const n = {}, s = e.dom;
      if (qd(s))
        for (let l = 0; l < s.style.length; l++) {
          const d = s.style.item(l);
          n[d] = s.style[d];
        }
      return n;
    }, kl = (e, n) => {
      const s = e.dom;
      pp(s, n), fs(da(e, "style").map(Wa), "") && oa(e, "style");
    }, Na = (e) => e.dom.offsetWidth, Ki = (e, n) => {
      Di(e).each((l) => {
        l.dom.insertBefore(n.dom, e.dom);
      });
    }, Jl = (e, n) => {
      $c(e).fold(() => {
        Di(e).each((d) => {
          Ys(d, n);
        });
      }, (l) => {
        Ki(l, n);
      });
    }, Cm = (e, n) => {
      Df(e).fold(() => {
        Ys(e, n);
      }, (l) => {
        e.dom.insertBefore(n.dom, l.dom);
      });
    }, Ys = (e, n) => {
      e.dom.appendChild(n.dom);
    }, $h = (e, n) => {
      Ki(e, n), Ys(n, e);
    }, wa = (e, n) => {
      Ue(n, (s, l) => {
        const d = l === 0 ? e : n[l - 1];
        Jl(d, s);
      });
    }, pd = (e, n) => {
      Ue(n, (s) => {
        Ys(e, s);
      });
    }, Lc = (e) => {
      e.dom.textContent = "", Ue(Ya(e), (n) => {
        ys(n);
      });
    }, ys = (e) => {
      const n = e.dom;
      n.parentNode !== null && n.parentNode.removeChild(n);
    }, Hc = (e) => {
      const n = Ya(e);
      n.length > 0 && wa(e, n), ys(e);
    }, Nf = (e, n) => {
      const l = (n || document).createElement("div");
      return l.innerHTML = e, Ya(Me.fromDom(l));
    }, Iu = (e) => en(e, Me.fromDom), Fs = (e) => e.dom.innerHTML, hd = (e, n) => {
      const l = Fl(e).dom, d = Me.fromDom(l.createDocumentFragment()), p = Nf(n, l);
      pd(d, p), Lc(e), Ys(e, d);
    }, ec = (e) => {
      const n = Me.fromTag("div"), s = Me.fromDom(e.dom.cloneNode(!0));
      return Ys(n, s), Fs(n);
    }, dr = (e, n, s, l, d, p, v) => ({
      target: e,
      x: n,
      y: s,
      stop: l,
      prevent: d,
      kill: p,
      raw: v
    }), Kd = (e) => {
      const n = Me.fromDom(mp(e).getOr(e.target)), s = () => e.stopPropagation(), l = () => e.preventDefault(), d = B(l, s);
      return dr(n, e.clientX, e.clientY, s, l, d, e);
    }, Sm = (e, n) => (s) => {
      e(s) && n(Kd(s));
    }, gp = (e, n, s, l, d) => {
      const p = Sm(s, l);
      return e.dom.addEventListener(n, p, d), { unbind: Le(bp, e, n, p, d) };
    }, Yg = (e, n, s, l) => gp(e, n, s, l, !1), bp = (e, n, s, l) => {
      e.dom.removeEventListener(n, s, l);
    }, Xg = (e, n) => ({
      left: e,
      top: n,
      translate: (l, d) => Xg(e + l, n + d)
    }), R = Xg, V = (e) => {
      const n = e.getBoundingClientRect();
      return R(n.left, n.top);
    }, re = (e, n) => e !== void 0 ? e : n !== void 0 ? n : 0, Pe = (e) => {
      const n = e.dom.ownerDocument, s = n.body, l = n.defaultView, d = n.documentElement;
      if (s === e.dom)
        return R(s.offsetLeft, s.offsetTop);
      const p = re(l == null ? void 0 : l.pageYOffset, d.scrollTop), v = re(l == null ? void 0 : l.pageXOffset, d.scrollLeft), S = re(d.clientTop, s.clientTop), O = re(d.clientLeft, s.clientLeft);
      return $e(e).translate(v - O, p - S);
    }, $e = (e) => {
      const n = e.dom, l = n.ownerDocument.body;
      return l === n ? R(l.offsetLeft, l.offsetTop) : Mu(e) ? V(n) : R(0, 0);
    }, $t = (e) => {
      const n = e !== void 0 ? e.dom : document, s = n.body.scrollLeft || n.documentElement.scrollLeft, l = n.body.scrollTop || n.documentElement.scrollTop;
      return R(s, l);
    }, vo = (e, n, s) => {
      const d = (s !== void 0 ? s.dom : document).defaultView;
      d && d.scrollTo(e, n);
    }, $o = (e, n) => {
      Yt().browser.isSafari() && ye(e.dom.scrollIntoViewIfNeeded) ? e.dom.scrollIntoViewIfNeeded(!1) : e.dom.scrollIntoView(n);
    }, Mo = (e) => {
      const n = e === void 0 ? window : e;
      return Yt().browser.isFirefox() ? Y.none() : Y.from(n.visualViewport);
    }, bo = (e, n, s, l) => ({
      x: e,
      y: n,
      width: s,
      height: l,
      right: e + s,
      bottom: n + l
    }), Vs = (e) => {
      const n = e === void 0 ? window : e, s = n.document, l = $t(Me.fromDom(s));
      return Mo(n).fold(() => {
        const d = n.document.documentElement, p = d.clientWidth, v = d.clientHeight;
        return bo(l.left, l.top, p, v);
      }, (d) => bo(Math.max(d.pageLeft, l.left), Math.max(d.pageTop, l.top), d.width, d.height));
    }, ma = (e, n) => xn(Ya(e), n), _l = (e, n) => {
      let s = [];
      return Ue(Ya(e), (l) => {
        n(l) && (s = s.concat([l])), s = s.concat(_l(l, n));
      }), s;
    }, ba = (e, n) => Rh(n, e), Qg = (e, n, s) => Is(e, n, s).isSome(), P0 = (e, n) => Cl(e, n).isSome(), _v = (e, n) => Fh(e, n).isSome();
    class Ri {
      constructor(n, s) {
        this.node = n, this.rootNode = s, this.current = this.current.bind(this), this.next = this.next.bind(this), this.prev = this.prev.bind(this), this.prev2 = this.prev2.bind(this);
      }
      current() {
        return this.node;
      }
      next(n) {
        return this.node = this.findSibling(this.node, "firstChild", "nextSibling", n), this.node;
      }
      prev(n) {
        return this.node = this.findSibling(this.node, "lastChild", "previousSibling", n), this.node;
      }
      prev2(n) {
        return this.node = this.findPreviousNode(this.node, n), this.node;
      }
      findSibling(n, s, l, d) {
        if (n) {
          if (!d && n[s])
            return n[s];
          if (n !== this.rootNode) {
            let p = n[l];
            if (p)
              return p;
            for (let v = n.parentNode; v && v !== this.rootNode; v = v.parentNode)
              if (p = v[l], p)
                return p;
          }
        }
      }
      findPreviousNode(n, s) {
        if (n) {
          const l = n.previousSibling;
          if (this.rootNode && l === this.rootNode)
            return;
          if (l) {
            if (!s) {
              for (let p = l.lastChild; p; p = p.lastChild)
                if (!p.lastChild)
                  return p;
            }
            return l;
          }
          const d = n.parentNode;
          if (d && d !== this.rootNode)
            return d;
        }
      }
    }
    const Jg = "\uFEFF", Xa = "", Ev = (e) => e === Jg, Ni = (e) => e.replace(/\uFEFF/g, ""), wo = /^[ \t\r\n]*$/, zc = (e) => wo.test(e), vp = (e) => {
      for (const n of e)
        if (!Ev(n))
          return !1;
      return !0;
    }, yp = (e) => " \f	\v".indexOf(e) !== -1, D0 = (e) => e === `
` || e === "\r", Tv = (e, n) => n < e.length && n >= 0 ? D0(e[n]) : !1, uu = (e, n = 4, s = !0, l = !0) => {
      const d = Fr(" ", n), p = e.replace(/\t/g, d);
      return Ct(p, (S, O) => yp(O) || O === Xa ? S.pcIsSpace || S.str === "" && s || S.str.length === p.length - 1 && l || Tv(p, S.str.length + 1) ? {
        pcIsSpace: !1,
        str: S.str + Xa
      } : {
        pcIsSpace: !0,
        str: S.str + " "
      } : {
        pcIsSpace: D0(O),
        str: S.str + O
      }, {
        pcIsSpace: !1,
        str: ""
      }).str;
    }, gd = (e) => (n) => !!n && n.nodeType === e, Mf = (e) => !!e && !Object.getPrototypeOf(e), On = gd(1), kc = (e) => On(e) && Te(Me.fromDom(e)), Ov = (e) => On(e) && e.namespaceURI === "http://www.w3.org/2000/svg", km = (e) => {
      const n = e.toLowerCase();
      return (s) => je(s) && s.nodeName.toLowerCase() === n;
    }, du = (e) => {
      const n = e.map((s) => s.toLowerCase());
      return (s) => {
        if (s && s.nodeName) {
          const l = s.nodeName.toLowerCase();
          return At(n, l);
        }
        return !1;
      };
    }, Lh = (e, n) => {
      const s = n.toLowerCase().split(" ");
      return (l) => {
        if (On(l)) {
          const d = l.ownerDocument.defaultView;
          if (d)
            for (let p = 0; p < s.length; p++) {
              const v = d.getComputedStyle(l, null);
              if ((v ? v.getPropertyValue(e) : null) === s[p])
                return !0;
            }
        }
        return !1;
      };
    }, If = (e) => (n) => On(n) && n.hasAttribute(e), _m = (e) => On(e) && e.hasAttribute("data-mce-bogus"), Hh = (e) => On(e) && e.getAttribute("data-mce-bogus") === "all", Fu = (e) => On(e) && e.tagName === "TABLE", R0 = (e) => (n) => !!(kc(n) && (n.contentEditable === e || n.getAttribute("data-mce-contenteditable") === e)), ia = du([
      "textarea",
      "input"
    ]), Zt = gd(3), El = gd(4), Bu = gd(7), ci = gd(8), xp = gd(9), Qa = gd(11), Wr = km("br"), eb = km("img"), Rt = R0("true"), Vr = R0("false"), tb = du([
      "td",
      "th"
    ]), Va = du([
      "td",
      "th",
      "caption"
    ]), Yi = du([
      "video",
      "audio",
      "object",
      "embed"
    ]), Nw = km("li"), _c = km("details"), Mw = km("summary"), Yd = {
      skipBogus: !0,
      includeZwsp: !1,
      checkRootAsContent: !1
    }, N0 = (e, n, s) => {
      const l = Me.fromDom(n), d = Me.fromDom(e), p = s.getWhitespaceElements();
      return Qg(d, (S) => Xn(p, gr(S)), Le(zr, l));
    }, Ec = (e) => On(e) && e.nodeName === "A" && !e.hasAttribute("href") && (e.hasAttribute("name") || e.hasAttribute("id")), jr = (e, n) => On(e) && Xn(n.getNonEmptyElements(), e.nodeName), bd = If("data-mce-bookmark"), Em = (e) => Bc(Me.fromDom(e)).exists((n) => !za(n)), ja = (e, n, s) => zc(e.data) && !N0(e, n, s), Av = (e, n, s, l) => Zt(e) && !ja(e, n, s) && (!l.includeZwsp || !vp(e.data)), vd = (e, n, s, l) => ye(l.isContent) && l.isContent(n) || jr(n, e) || bd(n) || Ec(n) || Av(n, s, e, l) || Vr(n) || Rt(n) && Em(n), $u = (e, n, s) => {
      const l = {
        ...Yd,
        ...s
      };
      if (l.checkRootAsContent && vd(e, n, n, l))
        return !1;
      let d = n.firstChild, p = 0;
      if (!d)
        return !0;
      const v = new Ri(d, n);
      do {
        if (l.skipBogus && On(d)) {
          const S = d.getAttribute("data-mce-bogus");
          if (S) {
            d = v.next(S === "all");
            continue;
          }
        }
        if (ci(d)) {
          d = v.next(!0);
          continue;
        }
        if (Wr(d)) {
          p++, d = v.next();
          continue;
        }
        if (vd(e, d, n, l))
          return !1;
        d = v.next();
      } while (d);
      return p <= 1;
    }, Es = (e, n, s) => $u(e, n.dom, {
      checkRootAsContent: !0,
      ...s
    }), wp = (e, n, s) => vd(e, n, n, {
      includeZwsp: Yd.includeZwsp,
      ...s
    }), Qe = (e) => {
      let n = e;
      return {
        get: () => n,
        set: (d) => {
          n = d;
        }
      };
    }, Vc = (e) => {
      const n = Qe(Y.none()), s = () => n.get().each(e);
      return {
        clear: () => {
          s(), n.set(Y.none());
        },
        isSet: () => n.get().isSome(),
        get: () => n.get(),
        set: (S) => {
          s(), n.set(Y.some(S));
        }
      };
    }, Cp = (e) => {
      const n = Qe(Y.none()), s = () => n.get().each((S) => clearInterval(S));
      return {
        clear: () => {
          s(), n.set(Y.none());
        },
        isSet: () => n.get().isSome(),
        get: () => n.get(),
        set: (S) => {
          s(), n.set(Y.some(setInterval(S, e)));
        }
      };
    }, Mi = () => {
      const e = Vc(qe);
      return {
        ...e,
        on: (s) => e.get().each(s)
      };
    }, fu = (e) => {
      const n = e.toLowerCase();
      return n === "svg" ? "svg" : n === "math" ? "math" : "html";
    }, Ea = (e) => fu(e) !== "html", Ca = (e) => Ea(e.nodeName), P = (e) => fu(e.nodeName), I = [
      "svg",
      "math"
    ], ee = () => {
      const e = Mi(), n = () => e.get().map(P).getOr("html");
      return {
        track: (d) => (Ca(d) ? e.set(d) : e.get().exists((p) => !p.contains(d)) && e.clear(), n()),
        current: n,
        reset: () => {
          e.clear();
        }
      };
    }, he = "data-mce-block", Be = (e) => xn(Zo(e), (n) => !/[A-Z]/.test(n)), Pt = (e) => en(Be(e), (n) => {
      const s = CSS.escape(n);
      return `${s}:` + en(I, (l) => `not(${l} ${s})`).join(":");
    }).join(","), sn = (e, n) => je(n.querySelector(e)) ? (n.setAttribute(he, "true"), n.getAttribute("data-mce-selected") === "inline-boundary" && n.removeAttribute("data-mce-selected"), !0) : (n.removeAttribute(he), !1), Hn = (e, n) => {
      const s = Pt(e.getTransparentElements()), l = Pt(e.getBlockElements());
      return xn(n.querySelectorAll(s), (d) => sn(l, d));
    }, Ro = (e, n, s) => {
      var l;
      const d = s ? "lastChild" : "firstChild";
      for (let p = n[d]; p; p = p[d])
        if ($u(e, p, { checkRootAsContent: !0 })) {
          (l = p.parentNode) === null || l === void 0 || l.removeChild(p);
          return;
        }
    }, ar = (e, n, s) => {
      const l = document.createRange(), d = n.parentNode;
      if (d) {
        l.setStartBefore(n), l.setEndBefore(s);
        const p = l.extractContents();
        Ro(e, p, !0), l.setStartAfter(s), l.setEndAfter(n);
        const v = l.extractContents();
        Ro(e, v, !1), $u(e, p, { checkRootAsContent: !0 }) || d.insertBefore(p, n), $u(e, s, { checkRootAsContent: !0 }) || d.insertBefore(s, n), $u(e, v, { checkRootAsContent: !0 }) || d.insertBefore(v, n), d.removeChild(n);
      }
    }, rs = (e, n, s) => {
      const l = e.getBlockElements(), d = Me.fromDom(n), p = (S) => gr(S) in l, v = (S) => zr(S, d);
      Ue(Iu(s), (S) => {
        Is(S, p, v).each((O) => {
          const M = ma(S, (j) => p(j) && !e.isValidChild(gr(O), gr(j)));
          if (M.length > 0) {
            const j = Bc(O);
            Ue(M, (U) => {
              Is(U, p, v).each((Z) => {
                ar(e, Z.dom, U.dom);
              });
            }), j.each((U) => Hn(e, U.dom));
          }
        });
      });
    }, Zr = (e, n, s) => {
      Ue([
        ...s,
        ...Lu(e, n) ? [n] : []
      ], (l) => Ue(ba(Me.fromDom(l), l.nodeName.toLowerCase()), (d) => {
        Sp(e, d.dom) && Hc(d);
      }));
    }, $s = (e, n) => {
      const s = Hn(e, n);
      rs(e, n, s), Zr(e, n, s);
    }, tc = (e, n) => {
      if (Ff(e, n)) {
        const s = Pt(e.getBlockElements());
        sn(s, n);
      }
    }, yd = (e, n, s) => {
      const l = (p) => zr(p, Me.fromDom(n)), d = Nh(Me.fromDom(s), l);
      yn(d, d.length - 2).filter(rt).fold(() => $s(e, n), (p) => $s(e, p.dom));
    }, ml = (e) => e.hasAttribute(he), xd = (e, n) => Xn(e.getTransparentElements(), n), Ff = (e, n) => On(n) && xd(e, n.nodeName), Lu = (e, n) => Ff(e, n) && ml(n), Sp = (e, n) => Ff(e, n) && !ml(n), jc = (e, n) => n.type === 1 && xd(e, n.name) && G(n.attr(he)), nb = Yt().browser, zh = (e) => Pn(e, rt), ob = (e) => nb.isFirefox() && gr(e) === "table" ? zh(Ya(e)).filter((n) => gr(n) === "caption").bind((n) => zh(qi(n)).map((s) => {
      const l = s.dom.offsetTop, d = n.dom.offsetTop, p = n.dom.offsetHeight;
      return l <= d ? -p : 0;
    })).getOr(0) : 0, rb = (e, n) => e.children && At(e.children, n), ui = (e, n, s) => {
      let l = 0, d = 0;
      const p = e.ownerDocument;
      if (s = s || e, n) {
        if (s === e && n.getBoundingClientRect && fa(Me.fromDom(e), "position") === "static") {
          const S = n.getBoundingClientRect();
          return l = S.left + (p.documentElement.scrollLeft || e.scrollLeft) - p.documentElement.clientLeft, d = S.top + (p.documentElement.scrollTop || e.scrollTop) - p.documentElement.clientTop, {
            x: l,
            y: d
          };
        }
        let v = n;
        for (; v && v !== s && v.nodeType && !rb(v, s); ) {
          const S = v;
          l += S.offsetLeft || 0, d += S.offsetTop || 0, v = S.offsetParent;
        }
        for (v = n.parentNode; v && v !== s && v.nodeType && !rb(v, s); )
          l -= v.scrollLeft || 0, d -= v.scrollTop || 0, v = v.parentNode;
        d += ob(Me.fromDom(n));
      }
      return {
        x: l,
        y: d
      };
    }, wr = (e, n = {}) => {
      let s = 0;
      const l = {}, d = Me.fromDom(e), p = Ka(d), v = (ze) => {
        n.referrerPolicy = ze;
      }, S = (ze) => {
        n.contentCssCors = ze;
      }, O = (ze) => {
        Ys(fp(d), ze);
      }, M = (ze) => {
        const Ye = fp(d);
        no(Ye, "#" + ze).each(ys);
      }, j = (ze) => Or(l, ze).getOrThunk(() => ({
        id: "mce-u" + s++,
        passed: [],
        failed: [],
        count: 0
      })), U = (ze) => new Promise((Ye, We) => {
        let ut;
        const zt = Gt._addCacheSuffix(ze), an = j(zt);
        l[zt] = an, an.count++;
        const Dn = (Vn, co) => {
          Ue(Vn, on), an.status = co, an.passed = [], an.failed = [], ut && (ut.onload = null, ut.onerror = null, ut = null);
        }, Tt = () => Dn(an.passed, 2), yt = () => Dn(an.failed, 3);
        if (Ye && an.passed.push(Ye), We && an.failed.push(We), an.status === 1)
          return;
        if (an.status === 2) {
          Tt();
          return;
        }
        if (an.status === 3) {
          yt();
          return;
        }
        an.status = 1;
        const Lt = Me.fromTag("link", p.dom);
        _a(Lt, {
          rel: "stylesheet",
          type: "text/css",
          id: an.id
        }), n.contentCssCors && ur(Lt, "crossOrigin", "anonymous"), n.referrerPolicy && ur(Lt, "referrerpolicy", n.referrerPolicy), ut = Lt.dom, ut.onload = Tt, ut.onerror = yt, O(Lt), ur(Lt, "href", zt);
      }), Z = (ze, Ye) => {
        const We = j(ze);
        l[ze] = We, We.count++;
        const ut = Me.fromTag("style", p.dom);
        _a(ut, {
          rel: "stylesheet",
          type: "text/css",
          id: We.id
        }), ut.dom.innerHTML = Ye, O(ut);
      }, de = (ze) => Promise.allSettled(en(ze, (We) => U(We).then(dt(We)))).then((We) => {
        const ut = mo(We, (zt) => zt.status === "fulfilled");
        return ut.fail.length > 0 ? Promise.reject(en(ut.fail, (zt) => zt.reason)) : en(ut.pass, (zt) => zt.value);
      }), we = (ze) => {
        const Ye = Gt._addCacheSuffix(ze);
        Or(l, Ye).each((We) => {
          --We.count === 0 && (delete l[Ye], M(We.id));
        });
      };
      return {
        load: U,
        loadRawCss: Z,
        loadAll: de,
        unload: we,
        unloadRawCss: (ze) => {
          Or(l, ze).each((Ye) => {
            --Ye.count === 0 && (delete l[ze], M(Ye.id));
          });
        },
        unloadAll: (ze) => {
          Ue(ze, (Ye) => {
            we(Ye);
          });
        },
        _setReferrerPolicy: v,
        _setContentCssCors: S
      };
    }, Ja = (() => {
      const e = /* @__PURE__ */ new WeakMap();
      return { forElement: (s, l) => {
        const p = Ql(s).dom;
        return Y.from(e.get(p)).getOrThunk(() => {
          const v = wr(p, l);
          return e.set(p, v), v;
        });
      } };
    })(), Tc = (e) => e.nodeName.toLowerCase() === "span", nc = (e, n) => je(e) && (wp(n, e) || n.isInline(e.nodeName.toLowerCase())), sb = (e, n, s) => {
      const l = new Ri(e, n).prev(!1), d = new Ri(e, n).next(!1), p = ot(l) || nc(l, s), v = ot(d) || nc(d, s);
      return p && v;
    }, wd = (e) => Tc(e) && e.getAttribute("data-mce-type") === "bookmark", Tm = (e, n, s) => Zt(e) && e.data.length > 0 && sb(e, n, s), Bf = (e) => On(e) ? e.childNodes.length > 0 : !1, Xd = (e) => Qa(e) || xp(e), $f = (e, n, s, l) => {
      var d;
      const p = l || n;
      if (On(n) && wd(n))
        return n;
      const v = n.childNodes;
      for (let S = v.length - 1; S >= 0; S--)
        $f(e, v[S], s, p);
      if (On(n)) {
        const S = n.childNodes;
        S.length === 1 && wd(S[0]) && ((d = n.parentNode) === null || d === void 0 || d.insertBefore(S[0], n));
      }
      return !Xd(n) && !wp(s, n) && !Bf(n) && !Tm(n, p, s) && e.remove(n), n;
    }, Cd = Gt.makeMap, Pv = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Lf = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, ab = /[<>&\"\']/g, Vh = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi, zk = {
      128: "",
      130: "",
      131: "",
      132: "",
      133: "",
      134: "",
      135: "",
      136: "",
      137: "",
      138: "",
      139: "",
      140: "",
      142: "",
      145: "",
      146: "",
      147: "",
      148: "",
      149: "",
      150: "",
      151: "",
      152: "",
      153: "",
      154: "",
      155: "",
      156: "",
      158: "",
      159: ""
    }, Qd = {
      '"': "&quot;",
      "'": "&#39;",
      "<": "&lt;",
      ">": "&gt;",
      "&": "&amp;",
      "`": "&#96;"
    }, Vk = {
      "&lt;": "<",
      "&gt;": ">",
      "&amp;": "&",
      "&quot;": '"',
      "&apos;": "'"
    }, Iw = (e) => {
      const n = Me.fromTag("div").dom;
      return n.innerHTML = e, n.textContent || n.innerText || e;
    }, Ta = (e, n) => {
      const s = {};
      if (e) {
        const l = e.split(",");
        n = n || 10;
        for (let d = 0; d < l.length; d += 2) {
          const p = String.fromCharCode(parseInt(l[d], n));
          if (!Qd[p]) {
            const v = "&" + l[d + 1] + ";";
            s[p] = v, s[v] = p;
          }
        }
        return s;
      } else
        return;
    }, M0 = Ta("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32), Jd = (e, n) => e.replace(n ? Pv : Lf, (s) => Qd[s] || s), kp = (e) => ("" + e).replace(ab, (n) => Qd[n] || n), Om = (e, n) => e.replace(n ? Pv : Lf, (s) => s.length > 1 ? "&#" + ((s.charCodeAt(0) - 55296) * 1024 + (s.charCodeAt(1) - 56320) + 65536) + ";" : Qd[s] || "&#" + s.charCodeAt(0) + ";"), Hu = (e, n, s) => {
      const l = s || M0;
      return e.replace(n ? Pv : Lf, (d) => Qd[d] || l[d] || d);
    }, ef = {
      encodeRaw: Jd,
      encodeAllRaw: kp,
      encodeNumeric: Om,
      encodeNamed: Hu,
      getEncodeFunc: (e, n) => {
        const s = Ta(n) || M0, l = (v, S) => v.replace(S ? Pv : Lf, (O) => Qd[O] !== void 0 ? Qd[O] : s[O] !== void 0 ? s[O] : O.length > 1 ? "&#" + ((O.charCodeAt(0) - 55296) * 1024 + (O.charCodeAt(1) - 56320) + 65536) + ";" : "&#" + O.charCodeAt(0) + ";"), d = (v, S) => Hu(v, S, s), p = Cd(e.replace(/\+/g, ","));
        return p.named && p.numeric ? l : p.named ? n ? d : Hu : p.numeric ? Om : Jd;
      },
      decode: (e) => e.replace(Vh, (n, s) => s ? (s.charAt(0).toLowerCase() === "x" ? s = parseInt(s.substr(1), 16) : s = parseInt(s, 10), s > 65535 ? (s -= 65536, String.fromCharCode(55296 + (s >> 10), 56320 + (s & 1023))) : zk[s] || String.fromCharCode(s)) : Vk[n] || M0[n] || Iw(n))
    }, Tl = (e, n) => (e = Gt.trim(e), e ? e.split(n || " ") : []), Rv = (e) => new RegExp("^" + e.replace(/([?+*])/g, ".$1") + "$"), Fw = (e) => ve(e) && e.source && Object.prototype.toString.call(e) === "[object RegExp]", Nv = (e) => {
      const n = (s) => Xe(s) ? en(s, n) : Fw(s) ? new RegExp(s.source, s.flags) : ve(s) ? Ho(s, n) : s;
      return n(e);
    }, Mv = (e) => {
      const n = /^(~)?(.+)$/;
      return nr(Tl(e, ","), (s) => {
        const l = n.exec(s);
        if (l) {
          const p = l[1] === "~" ? "span" : "div", v = l[2];
          return [{
            cloneName: p,
            name: v
          }];
        } else
          return [];
      });
    }, Bw = (e) => Object.freeze([
      "id",
      "accesskey",
      "class",
      "dir",
      "lang",
      "style",
      "tabindex",
      "title",
      "role",
      ...e !== "html4" ? [
        "contenteditable",
        "contextmenu",
        "draggable",
        "dropzone",
        "hidden",
        "spellcheck",
        "translate",
        "itemprop",
        "itemscope",
        "itemtype"
      ] : [],
      ...e !== "html5-strict" ? ["xml:lang"] : []
    ]), jh = (e) => {
      let n, s;
      n = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul", s = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment", e !== "html4" && (n += " article aside details dialog figure main header footer hgroup section nav " + "a ins del canvas map", s += " audio canvas command data datalist mark meter output picture progress time wbr video ruby bdi keygen svg"), e !== "html5-strict" && (s = [
        s,
        "acronym applet basefont big font strike tt"
      ].join(" "), n = [
        n,
        "center dir isindex noframes"
      ].join(" "));
      const l = [
        n,
        s
      ].join(" ");
      return {
        blockContent: n,
        phrasingContent: s,
        flowContent: l
      };
    }, tf = (e) => {
      const { blockContent: n, phrasingContent: s, flowContent: l } = jh(e), d = (p) => Object.freeze(p.split(" "));
      return Object.freeze({
        blockContent: d(n),
        phrasingContent: d(s),
        flowContent: d(l)
      });
    }, oc = {
      html4: _t(() => tf("html4")),
      html5: _t(() => tf("html5")),
      "html5-strict": _t(() => tf("html5-strict"))
    }, Vu = (e, n) => {
      const { blockContent: s, phrasingContent: l, flowContent: d } = oc[e]();
      return n === "blocks" ? Y.some(s) : n === "phrasing" ? Y.some(l) : n === "flow" ? Y.some(d) : Y.none();
    }, _p = (e) => {
      const n = Bw(e), { phrasingContent: s, flowContent: l } = jh(e), d = {}, p = (O, M, j) => {
        d[O] = {
          attributes: at(M, dt({})),
          attributesOrder: M,
          children: at(j, dt({}))
        };
      }, v = (O, M = "", j = "") => {
        const U = Tl(j), Z = Tl(O);
        let de = Z.length;
        const we = [
          ...n,
          ...Tl(M)
        ];
        for (; de--; )
          p(Z[de], we.slice(), U);
      }, S = (O, M) => {
        const j = Tl(O), U = Tl(M);
        let Z = j.length;
        for (; Z--; ) {
          const de = d[j[Z]];
          for (let we = 0, me = U.length; we < me; we++)
            de.attributes[U[we]] = {}, de.attributesOrder.push(U[we]);
        }
      };
      return e !== "html5-strict" && (Ue(Tl("acronym applet basefont big font strike tt"), (j) => {
        v(j, "", s);
      }), Ue(Tl("center dir isindex noframes"), (j) => {
        v(j, "", l);
      })), v("html", "manifest", "head body"), v("head", "", "base command link meta noscript script style title"), v("title hr noscript br"), v("base", "href target"), v("link", "href rel media hreflang type sizes hreflang"), v("meta", "name http-equiv content charset"), v("style", "media type scoped"), v("script", "src async defer type charset"), v("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", l), v("dd div", "", l), v("address dt caption", "", e === "html4" ? s : l), v("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", s), v("blockquote", "cite", l), v("ol", "reversed start type", "li"), v("ul", "", "li"), v("li", "value", l), v("dl", "", "dt dd"), v("a", "href target rel media hreflang type", e === "html4" ? s : l), v("q", "cite", s), v("ins del", "cite datetime", l), v("img", "src sizes srcset alt usemap ismap width height"), v("iframe", "src name width height", l), v("embed", "src type width height"), v("object", "data type typemustmatch name usemap form width height", [
        l,
        "param"
      ].join(" ")), v("param", "name value"), v("map", "name", [
        l,
        "area"
      ].join(" ")), v("area", "alt coords shape href target rel media hreflang type"), v("table", "border", "caption colgroup thead tfoot tbody tr" + (e === "html4" ? " col" : "")), v("colgroup", "span", "col"), v("col", "span"), v("tbody thead tfoot", "", "tr"), v("tr", "", "td th"), v("td", "colspan rowspan headers", l), v("th", "colspan rowspan headers scope abbr", l), v("form", "accept-charset action autocomplete enctype method name novalidate target", l), v("fieldset", "disabled form name", [
        l,
        "legend"
      ].join(" ")), v("label", "form for", s), v("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"), v("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", e === "html4" ? l : s), v("select", "disabled form multiple name required size", "option optgroup"), v("optgroup", "disabled label", "option"), v("option", "disabled label selected value"), v("textarea", "cols dirname disabled form maxlength name readonly required rows wrap"), v("menu", "type label", [
        l,
        "li"
      ].join(" ")), v("noscript", "", l), e !== "html4" && (v("wbr"), v("ruby", "", [
        s,
        "rt rp"
      ].join(" ")), v("figcaption", "", l), v("mark rt rp bdi", "", s), v("summary", "", [
        s,
        "h1 h2 h3 h4 h5 h6"
      ].join(" ")), v("canvas", "width height", l), v("data", "value", s), v("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", [
        l,
        "track source"
      ].join(" ")), v("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [
        l,
        "track source"
      ].join(" ")), v("picture", "", "img source"), v("source", "src srcset type media sizes"), v("track", "kind src srclang label default"), v("datalist", "", [
        s,
        "option"
      ].join(" ")), v("article section nav aside main header footer", "", l), v("hgroup", "", "h1 h2 h3 h4 h5 h6"), v("figure", "", [
        l,
        "figcaption"
      ].join(" ")), v("time", "datetime", s), v("dialog", "open", l), v("command", "type label icon disabled checked radiogroup command"), v("output", "for form name", s), v("progress", "value max", s), v("meter", "value min max low high optimum", s), v("details", "open", [
        l,
        "summary"
      ].join(" ")), v("keygen", "autofocus challenge disabled form keytype name"), p("svg", "id tabindex lang xml:space class style x y width height viewBox preserveAspectRatio zoomAndPan transform".split(" "), [])), e !== "html5-strict" && (S("script", "language xml:space"), S("style", "xml:space"), S("object", "declare classid code codebase codetype archive standby align border hspace vspace"), S("embed", "align name hspace vspace"), S("param", "valuetype type"), S("a", "charset name rev shape coords"), S("br", "clear"), S("applet", "codebase archive code object alt name width height align hspace vspace"), S("img", "name longdesc align border hspace vspace"), S("iframe", "longdesc frameborder marginwidth marginheight scrolling align"), S("font basefont", "size color face"), S("input", "usemap align"), S("select"), S("textarea"), S("h1 h2 h3 h4 h5 h6 div p legend caption", "align"), S("ul", "type compact"), S("li", "type"), S("ol dl menu dir", "compact"), S("pre", "width xml:space"), S("hr", "align noshade size width"), S("isindex", "prompt"), S("table", "summary width frame rules cellspacing cellpadding align bgcolor"), S("col", "width align char charoff valign"), S("colgroup", "width align char charoff valign"), S("thead", "align char charoff valign"), S("tr", "align char charoff valign bgcolor"), S("th", "axis align char charoff valign nowrap bgcolor width height"), S("form", "accept"), S("td", "abbr axis scope align char charoff valign nowrap bgcolor width height"), S("tfoot", "align char charoff valign"), S("tbody", "align char charoff valign"), S("area", "nohref"), S("body", "background bgcolor text link vlink alink")), e !== "html4" && (S("input button select textarea", "autofocus"), S("input textarea", "placeholder"), S("a", "download"), S("link script img", "crossorigin"), S("img", "loading"), S("iframe", "sandbox seamless allow allowfullscreen loading referrerpolicy")), e !== "html4" && Ue([
        d.video,
        d.audio
      ], (O) => {
        delete O.children.audio, delete O.children.video;
      }), Ue(Tl("a form meter progress dfn"), (O) => {
        d[O] && delete d[O].children[O];
      }), delete d.caption.children.table, delete d.script, d;
    }, $w = (e) => e === "-" ? "remove" : "add", Uh = (e) => {
      const n = /^(@?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)$/;
      return Y.from(n.exec(e)).map((s) => ({
        preset: s[1] === "@",
        name: s[2]
      }));
    }, Lw = (e) => {
      const n = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
      return nr(Tl(e, ","), (s) => {
        const l = n.exec(s);
        if (l) {
          const d = l[1], p = d ? $w(d) : "replace", v = l[2], S = nr(Tl(l[3], "|"), (O) => Uh(O).toArray());
          return [{
            operation: p,
            name: v,
            validChildren: S
          }];
        } else
          return [];
      });
    }, jk = (e, n) => {
      const s = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/, l = /[*?+]/, { attributes: d, attributesOrder: p } = n;
      return Ue(Tl(e, "|"), (v) => {
        const S = s.exec(v);
        if (S) {
          const O = {}, M = S[1], j = S[2].replace(/[\\:]:/g, ":"), U = S[3], Z = S[4];
          if (M === "!" && (n.attributesRequired = n.attributesRequired || [], n.attributesRequired.push(j), O.required = !0), M === "-") {
            delete d[j], p.splice(Gt.inArray(p, j), 1);
            return;
          }
          if (U && (U === "=" ? (n.attributesDefault = n.attributesDefault || [], n.attributesDefault.push({
            name: j,
            value: Z
          }), O.defaultValue = Z) : U === "~" ? (n.attributesForced = n.attributesForced || [], n.attributesForced.push({
            name: j,
            value: Z
          }), O.forcedValue = Z) : U === "<" && (O.validValues = Gt.makeMap(Z, "?"))), l.test(j)) {
            const de = O;
            n.attributePatterns = n.attributePatterns || [], de.pattern = Rv(j), n.attributePatterns.push(de);
          } else
            d[j] || p.push(j), d[j] = O;
        }
      });
    }, Uk = (e, n) => {
      Ht(e.attributes, (s, l) => {
        n.attributes[l] = s;
      }), n.attributesOrder.push(...e.attributesOrder);
    }, Wk = (e, n) => {
      const s = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/;
      return nr(Tl(n, ","), (l) => {
        const d = s.exec(l);
        if (d) {
          const p = d[1], v = d[2], S = d[3], O = d[4], M = d[5], j = {
            attributes: {},
            attributesOrder: []
          };
          if (e.each((U) => Uk(U, j)), p === "#" ? j.paddEmpty = !0 : p === "-" && (j.removeEmpty = !0), O === "!" && (j.removeEmptyAttrs = !0), M && jk(M, j), S && (j.outputName = v), v === "@")
            if (e.isNone())
              e = Y.some(j);
            else
              return [];
          return [S ? {
            name: v,
            element: j,
            aliasName: S
          } : {
            name: v,
            element: j
          }];
        } else
          return [];
      });
    }, Ep = {}, Wh = Gt.makeMap, tr = Gt.each, po = Gt.extend, Tp = Gt.explode, Iv = (e, n = {}) => {
      const s = Wh(e, " ", Wh(e.toUpperCase(), " "));
      return po(s, n);
    }, I0 = (e) => Iv("td th li dt dd figcaption caption details summary", e.getTextBlockElements()), Hw = (e, n) => {
      if (e) {
        const s = {};
        return G(e) && (e = { "*": e }), tr(e, (l, d) => {
          s[d] = s[d.toUpperCase()] = n === "map" ? Wh(l, /[, ]/) : Tp(l, /[, ]/);
        }), s;
      } else
        return;
    }, Hf = (e = {}) => {
      var n;
      const s = {}, l = {};
      let d = [];
      const p = {}, v = {}, S = (uo, $r, ya) => {
        const Da = e[uo];
        if (Da)
          return Wh(Da, /[, ]/, Wh(Da.toUpperCase(), /[, ]/));
        {
          let ri = Ep[uo];
          return ri || (ri = Iv($r, ya), Ep[uo] = ri), ri;
        }
      }, O = (n = e.schema) !== null && n !== void 0 ? n : "html5", M = _p(O);
      e.verify_html === !1 && (e.valid_elements = "*[*]");
      const j = Hw(e.valid_styles), U = Hw(e.invalid_styles, "map"), Z = Hw(e.valid_classes, "map"), de = S("whitespace_elements", "pre script noscript style textarea video audio iframe object code"), we = S("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr"), me = S("void_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track"), Se = S("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls allowfullscreen"), ze = "td th iframe video audio object script code", Ye = S("non_empty_elements", ze + " pre svg textarea summary", me), We = S("move_caret_before_on_enter_elements", ze + " table", me), ut = "h1 h2 h3 h4 h5 h6", zt = S("text_block_elements", ut + " p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure"), an = S("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary html body multicol listing", zt), Dn = S("text_inline_elements", "span strong b em i font s strike u var cite dfn code mark q sup sub samp"), Tt = S("transparent_elements", "a ins del canvas map"), yt = S("wrap_block_elements", "pre " + ut);
      tr("script noscript iframe noframes noembed title style textarea xmp plaintext".split(" "), (uo) => {
        v[uo] = new RegExp("</" + uo + "[^>]*>", "gi");
      });
      const Lt = (uo) => {
        const $r = Y.from(s["@"]), ya = /[*?+]/;
        Ue(Wk($r, uo ?? ""), ({ name: Da, element: ri, aliasName: rl }) => {
          if (rl && (s[rl] = ri), ya.test(Da)) {
            const Ua = ri;
            Ua.pattern = Rv(Da), d.push(Ua);
          } else
            s[Da] = ri;
        });
      }, Vn = (uo) => {
        d = [], Ue(Zo(s), ($r) => {
          delete s[$r];
        }), Lt(uo);
      }, co = (uo, $r) => {
        var ya, Da;
        delete Ep.text_block_elements, delete Ep.block_elements;
        const ri = $r.extends ? !ku($r.extends) : !1, rl = $r.extends;
        if (l[uo] = rl ? l[rl] : {}, p[uo] = rl ?? uo, Ye[uo.toUpperCase()] = {}, Ye[uo] = {}, ri || (an[uo.toUpperCase()] = {}, an[uo] = {}), rl && !s[uo] && s[rl]) {
          const Ua = Nv(s[rl]);
          delete Ua.removeEmptyAttrs, delete Ua.removeEmpty, s[uo] = Ua;
        } else
          s[uo] = {
            attributesOrder: [],
            attributes: {}
          };
        if (Xe($r.attributes)) {
          const Ua = (Ul) => {
            Fa.attributesOrder.push(Ul), Fa.attributes[Ul] = {};
          }, Fa = (ya = s[uo]) !== null && ya !== void 0 ? ya : {};
          delete Fa.attributesDefault, delete Fa.attributesForced, delete Fa.attributePatterns, delete Fa.attributesRequired, Fa.attributesOrder = [], Fa.attributes = {}, Ue($r.attributes, (Ul) => {
            const nd = Bw(O);
            Uh(Ul).each(({ preset: Cf, name: Sf }) => {
              Cf ? Sf === "global" && Ue(nd, Ua) : Ua(Sf);
            });
          }), s[uo] = Fa;
        }
        if (lt($r.padEmpty)) {
          const Ua = (Da = s[uo]) !== null && Da !== void 0 ? Da : {};
          Ua.paddEmpty = $r.padEmpty, s[uo] = Ua;
        }
        if (Xe($r.children)) {
          const Ua = {}, Fa = (nd) => {
            Ua[nd] = {};
          }, Ul = (nd) => {
            Vu(O, nd).each((Cf) => {
              Ue(Cf, Fa);
            });
          };
          Ue($r.children, (nd) => {
            Uh(nd).each(({ preset: Cf, name: Sf }) => {
              Cf ? Ul(Sf) : Fa(Sf);
            });
          }), l[uo] = Ua;
        }
        rl && Ht(l, (Ua, Fa) => {
          Ua[rl] && (l[Fa] = Ua = po({}, l[Fa]), Ua[uo] = Ua[rl]);
        });
      }, Xo = (uo) => {
        Ue(Mv(uo ?? ""), ({ name: $r, cloneName: ya }) => {
          co($r, { extends: ya });
        });
      }, Sr = (uo) => {
        ve(uo) ? Ht(uo, ($r, ya) => co(ya, $r)) : G(uo) && Xo(uo);
      }, ts = (uo) => {
        Ue(Lw(uo ?? ""), ({ operation: $r, name: ya, validChildren: Da }) => {
          const ri = $r === "replace" ? { "#comment": {} } : l[ya], rl = (Fa) => {
            $r === "remove" ? delete ri[Fa] : ri[Fa] = {};
          }, Ua = (Fa) => {
            Vu(O, Fa).each((Ul) => {
              Ue(Ul, rl);
            });
          };
          Ue(Da, ({ preset: Fa, name: Ul }) => {
            Fa ? Ua(Ul) : rl(Ul);
          }), l[ya] = ri;
        });
      }, Cs = (uo) => {
        const $r = s[uo];
        if ($r)
          return $r;
        let ya = d.length;
        for (; ya--; ) {
          const Da = d[ya];
          if (Da.pattern.test(uo))
            return Da;
        }
      }, Pa = () => {
        e.valid_elements ? (Vn(e.valid_elements), tr(M, (uo, $r) => {
          l[$r] = uo.children;
        })) : (tr(M, (uo, $r) => {
          s[$r] = {
            attributes: uo.attributes,
            attributesOrder: uo.attributesOrder
          }, l[$r] = uo.children;
        }), tr(Tl("strong/b em/i"), (uo) => {
          const $r = Tl(uo, "/");
          s[$r[1]].outputName = $r[0];
        }), tr(Dn, (uo, $r) => {
          s[$r] && (e.padd_empty_block_inline_children && (s[$r].paddInEmptyBlock = !0), s[$r].removeEmpty = !0);
        }), tr(Tl("ol ul blockquote a table tbody"), (uo) => {
          s[uo] && (s[uo].removeEmpty = !0);
        }), tr(Tl("p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary"), (uo) => {
          s[uo] && (s[uo].paddEmpty = !0);
        }), tr(Tl("span"), (uo) => {
          s[uo].removeEmptyAttrs = !0;
        })), delete s.svg, Sr(e.custom_elements), ts(e.valid_children), Lt(e.extended_valid_elements), ts("+ol[ul|ol],+ul[ul|ol]"), tr({
          dd: "dl",
          dt: "dl",
          li: "ul ol",
          td: "tr",
          th: "tr",
          tr: "tbody thead tfoot",
          tbody: "table",
          thead: "table",
          tfoot: "table",
          legend: "fieldset",
          area: "map",
          param: "video audio object"
        }, (uo, $r) => {
          s[$r] && (s[$r].parentsRequired = Tl(uo));
        }), e.invalid_elements && tr(Tp(e.invalid_elements), (uo) => {
          s[uo] && delete s[uo];
        }), Cs("span") || Lt("span[!data-mce-type|*]");
      }, yl = dt(j), bs = dt(U), hn = dt(Z), ro = dt(Se), Ur = dt(an), Sn = dt(zt), yo = dt(Dn), fr = dt(Object.seal(me)), An = dt(we), mr = dt(Ye), _r = dt(We), zi = dt(de), ls = dt(Tt), pi = dt(yt), Nd = dt(Object.seal(v)), um = (uo, $r) => {
        const ya = l[uo.toLowerCase()];
        return !!(ya && ya[$r.toLowerCase()]);
      }, pc = (uo, $r) => {
        const ya = Cs(uo);
        if (ya)
          if ($r) {
            if (ya.attributes[$r])
              return !0;
            const Da = ya.attributePatterns;
            if (Da) {
              let ri = Da.length;
              for (; ri--; )
                if (Da[ri].pattern.test($r))
                  return !0;
            }
          } else
            return !0;
        return !1;
      }, ku = (uo) => Xn(Ur(), uo), td = (uo) => !lo(uo, "#") && pc(uo) && !ku(uo), _u = (uo) => Xn(pi(), uo) || td(uo), Md = dt(p);
      return Pa(), {
        type: O,
        children: l,
        elements: s,
        getValidStyles: yl,
        getValidClasses: hn,
        getBlockElements: Ur,
        getInvalidStyles: bs,
        getVoidElements: fr,
        getTextBlockElements: Sn,
        getTextInlineElements: yo,
        getBoolAttrs: ro,
        getElementRule: Cs,
        getSelfClosingElements: An,
        getNonEmptyElements: mr,
        getMoveCaretBeforeOnEnterElements: _r,
        getWhitespaceElements: zi,
        getTransparentElements: ls,
        getSpecialElements: Nd,
        isValidChild: um,
        isValid: pc,
        isBlock: ku,
        isInline: td,
        isWrapper: _u,
        getCustomElements: Md,
        addValidElements: Lt,
        setValidElements: Vn,
        addCustomElements: Sr,
        addValidChildren: ts
      };
    }, js = (e) => ({ value: Zk(e) }), Zk = (e) => qn(e, "#").toUpperCase(), zw = (e) => {
      const n = e.toString(16);
      return (n.length === 1 ? "0" + n : n).toUpperCase();
    }, F0 = (e) => {
      const n = zw(e.red) + zw(e.green) + zw(e.blue);
      return js(n);
    }, It = /^\s*rgb\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*\)\s*$/i, Zh = /^\s*rgba\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*((?:\d?\.\d+|\d+)%?)\s*\)\s*$/i, X3 = (e, n, s, l) => ({
      red: e,
      green: n,
      blue: s,
      alpha: l
    }), Op = (e, n, s, l) => {
      const d = parseInt(e, 10), p = parseInt(n, 10), v = parseInt(s, 10), S = parseFloat(l);
      return X3(d, p, v, S);
    }, Q3 = (e) => It.test(e) ? "rgb" : Zh.test(e) ? "rgba" : "other", Gh = (e) => {
      const n = It.exec(e);
      if (n !== null)
        return Y.some(Op(n[1], n[2], n[3], "1"));
      const s = Zh.exec(e);
      return s !== null ? Y.some(Op(s[1], s[2], s[3], s[4])) : Y.none();
    }, Vw = (e) => `rgba(${e.red},${e.green},${e.blue},${e.alpha})`, nf = (e) => Gh(e).map(F0).map((n) => "#" + n.value).getOr(e), jw = (e = {}, n) => {
      const s = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi, l = /\s*([^:]+):\s*([^;]+);?/g, d = /\s+$/, p = {};
      let v, S;
      const O = Jg;
      n && (v = n.getValidStyles(), S = n.getInvalidStyles());
      const M = (`\\" \\' \\; \\: ; : ` + O).split(" ");
      for (let U = 0; U < M.length; U++)
        p[M[U]] = O + U, p[O + U] = M[U];
      const j = {
        parse: (U) => {
          const Z = {};
          let de = !1;
          const we = e.url_converter, me = e.url_converter_scope || j, Se = (Tt, yt, Lt) => {
            const Vn = Z[Tt + "-top" + yt];
            if (!Vn)
              return;
            const co = Z[Tt + "-right" + yt];
            if (!co)
              return;
            const Xo = Z[Tt + "-bottom" + yt];
            if (!Xo)
              return;
            const Sr = Z[Tt + "-left" + yt];
            if (!Sr)
              return;
            const ts = [
              Vn,
              co,
              Xo,
              Sr
            ];
            let Cs = ts.length - 1;
            for (; Cs-- && ts[Cs] === ts[Cs + 1]; )
              ;
            Cs > -1 && Lt || (Z[Tt + yt] = Cs === -1 ? ts[0] : ts.join(" "), delete Z[Tt + "-top" + yt], delete Z[Tt + "-right" + yt], delete Z[Tt + "-bottom" + yt], delete Z[Tt + "-left" + yt]);
          }, ze = (Tt) => {
            const yt = Z[Tt];
            if (!yt)
              return;
            const Lt = yt.indexOf(",") > -1 ? [yt] : yt.split(" ");
            let Vn = Lt.length;
            for (; Vn--; )
              if (Lt[Vn] !== Lt[0])
                return !1;
            return Z[Tt] = Lt[0], !0;
          }, Ye = (Tt, yt, Lt, Vn) => {
            ze(yt) && ze(Lt) && ze(Vn) && (Z[Tt] = Z[yt] + " " + Z[Lt] + " " + Z[Vn], delete Z[yt], delete Z[Lt], delete Z[Vn]);
          }, We = (Tt) => (de = !0, p[Tt]), ut = (Tt, yt) => (de && (Tt = Tt.replace(/\uFEFF[0-9]/g, (Lt) => p[Lt])), yt || (Tt = Tt.replace(/\\([\'\";:])/g, "$1")), Tt), zt = (Tt) => String.fromCharCode(parseInt(Tt.slice(1), 16)), an = (Tt) => Tt.replace(/\\[0-9a-f]+/gi, zt), Dn = (Tt, yt, Lt, Vn, co, Xo) => {
            if (co = co || Xo, co)
              return co = ut(co), "'" + co.replace(/\'/g, "\\'") + "'";
            if (yt = ut(yt || Lt || Vn || ""), !e.allow_script_urls) {
              const Sr = yt.replace(/[\s\r\n]+/g, "");
              if (/(java|vb)script:/i.test(Sr) || !e.allow_svg_data_urls && /^data:image\/svg/i.test(Sr))
                return "";
            }
            return we && (yt = we.call(me, yt, "style")), "url('" + yt.replace(/\'/g, "\\'") + "')";
          };
          if (U) {
            U = U.replace(/[\u0000-\u001F]/g, ""), U = U.replace(/\\[\"\';:\uFEFF]/g, We).replace(/\"[^\"]+\"|\'[^\']+\'/g, (yt) => yt.replace(/[;:]/g, We));
            let Tt;
            for (; Tt = l.exec(U); ) {
              l.lastIndex = Tt.index + Tt[0].length;
              let yt = Tt[1].replace(d, "").toLowerCase(), Lt = Tt[2].replace(d, "");
              if (yt && Lt) {
                if (yt = an(yt), Lt = an(Lt), yt.indexOf(O) !== -1 || yt.indexOf('"') !== -1 || !e.allow_script_urls && (yt === "behavior" || /expression\s*\(|\/\*|\*\//.test(Lt)))
                  continue;
                yt === "font-weight" && Lt === "700" ? Lt = "bold" : (yt === "color" || yt === "background-color") && (Lt = Lt.toLowerCase()), Q3(Lt) === "rgb" && Gh(Lt).each((Vn) => {
                  Lt = nf(Vw(Vn)).toLowerCase();
                }), Lt = Lt.replace(s, Dn), Z[yt] = de ? ut(Lt, !0) : Lt;
              }
            }
            Se("border", "", !0), Se("border", "-width"), Se("border", "-color"), Se("border", "-style"), Se("padding", ""), Se("margin", ""), Ye("border", "border-width", "border-style", "border-color"), Z.border === "medium none" && delete Z.border, Z["border-image"] === "none" && delete Z["border-image"];
          }
          return Z;
        },
        serialize: (U, Z) => {
          let de = "";
          const we = (Se, ze) => {
            const Ye = ze[Se];
            if (Ye)
              for (let We = 0, ut = Ye.length; We < ut; We++) {
                const zt = Ye[We], an = U[zt];
                an && (de += (de.length > 0 ? " " : "") + zt + ": " + an + ";");
              }
          }, me = (Se, ze) => {
            if (!S || !ze)
              return !0;
            let Ye = S["*"];
            return Ye && Ye[Se] ? !1 : (Ye = S[ze], !(Ye && Ye[Se]));
          };
          return Z && v ? (we("*", v), we(Z, v)) : Ht(U, (Se, ze) => {
            Se && me(ze, Z) && (de += (de.length > 0 ? " " : "") + ze + ": " + Se + ";");
          }), de;
        }
      };
      return j;
    }, ib = {
      keyLocation: !0,
      layerX: !0,
      layerY: !0,
      returnValue: !0,
      webkitMovementX: !0,
      webkitMovementY: !0,
      keyIdentifier: !0,
      mozPressure: !0
    }, Qs = (e) => e instanceof Event || ye(e.initEvent), zf = (e) => e.isDefaultPrevented === mt || e.isDefaultPrevented === tt, Gk = (e) => Kt(e.preventDefault) || Qs(e), Sd = (e, n) => {
      const s = n ?? {};
      for (const l in e)
        Xn(ib, l) || (s[l] = e[l]);
      return je(e.composedPath) && (s.composedPath = () => e.composedPath()), je(e.getModifierState) && (s.getModifierState = (l) => e.getModifierState(l)), je(e.getTargetRanges) && (s.getTargetRanges = () => e.getTargetRanges()), s;
    }, Uw = (e, n, s, l) => {
      var d;
      const p = Sd(n, l);
      return p.type = e, Kt(p.target) && (p.target = (d = p.srcElement) !== null && d !== void 0 ? d : s), Gk(n) && (p.preventDefault = () => {
        p.defaultPrevented = !0, p.isDefaultPrevented = mt, ye(n.preventDefault) && n.preventDefault();
      }, p.stopPropagation = () => {
        p.cancelBubble = !0, p.isPropagationStopped = mt, ye(n.stopPropagation) && n.stopPropagation();
      }, p.stopImmediatePropagation = () => {
        p.isImmediatePropagationStopped = mt, p.stopPropagation();
      }, zf(p) || (p.isDefaultPrevented = p.defaultPrevented === !0 ? mt : tt, p.isPropagationStopped = p.cancelBubble === !0 ? mt : tt, p.isImmediatePropagationStopped = tt)), p;
    }, Fv = "mce-data-", lb = /^(?:mouse|contextmenu)|click/, Bv = (e, n, s, l) => {
      e.addEventListener(n, s, l || !1);
    }, Uc = (e, n, s, l) => {
      e.removeEventListener(n, s, l || !1);
    }, qk = (e) => je(e) && lb.test(e.type), $v = (e, n) => {
      const s = Uw(e.type, e, document, n);
      if (qk(e) && ot(e.pageX) && !ot(e.clientX)) {
        const l = s.target.ownerDocument || document, d = l.documentElement, p = l.body, v = s;
        v.pageX = e.clientX + (d && d.scrollLeft || p && p.scrollLeft || 0) - (d && d.clientLeft || p && p.clientLeft || 0), v.pageY = e.clientY + (d && d.scrollTop || p && p.scrollTop || 0) - (d && d.clientTop || p && p.clientTop || 0);
      }
      return s;
    }, Ww = (e, n, s) => {
      const l = e.document, d = { type: "ready" };
      if (s.domLoaded) {
        n(d);
        return;
      }
      const p = () => l.readyState === "complete" || l.readyState === "interactive" && l.body, v = () => {
        Uc(e, "DOMContentLoaded", v), Uc(e, "load", v), s.domLoaded || (s.domLoaded = !0, n(d)), e = null;
      };
      p() ? v() : Bv(e, "DOMContentLoaded", v), s.domLoaded || Bv(e, "load", v);
    };
    class Ap {
      constructor() {
        this.domLoaded = !1, this.events = {}, this.count = 1, this.expando = Fv + (+/* @__PURE__ */ new Date()).toString(32), this.hasFocusIn = "onfocusin" in document.documentElement, this.count = 1;
      }
      bind(n, s, l, d) {
        const p = this;
        let v;
        const S = window, O = (Z) => {
          p.executeHandlers($v(Z || S.event), M);
        };
        if (!n || Zt(n) || ci(n))
          return l;
        let M;
        n[p.expando] ? M = n[p.expando] : (M = p.count++, n[p.expando] = M, p.events[M] = {}), d = d || n;
        const j = s.split(" ");
        let U = j.length;
        for (; U--; ) {
          let Z = j[U], de = O, we = !1, me = !1;
          if (Z === "DOMContentLoaded" && (Z = "ready"), p.domLoaded && Z === "ready" && n.readyState === "complete") {
            l.call(d, $v({ type: Z }));
            continue;
          }
          !p.hasFocusIn && (Z === "focusin" || Z === "focusout") && (we = !0, me = Z === "focusin" ? "focus" : "blur", de = (Se) => {
            const ze = $v(Se || S.event);
            ze.type = ze.type === "focus" ? "focusin" : "focusout", p.executeHandlers(ze, M);
          }), v = p.events[M][Z], v ? Z === "ready" && p.domLoaded ? l($v({ type: Z })) : v.push({
            func: l,
            scope: d
          }) : (p.events[M][Z] = v = [{
            func: l,
            scope: d
          }], v.fakeName = me, v.capture = we, v.nativeHandler = de, Z === "ready" ? Ww(n, de, p) : Bv(n, me || Z, de, we));
        }
        return n = v = null, l;
      }
      unbind(n, s, l) {
        if (!n || Zt(n) || ci(n))
          return this;
        const d = n[this.expando];
        if (d) {
          let p = this.events[d];
          if (s) {
            const v = s.split(" ");
            let S = v.length;
            for (; S--; ) {
              const O = v[S], M = p[O];
              if (M) {
                if (l) {
                  let j = M.length;
                  for (; j--; )
                    if (M[j].func === l) {
                      const U = M.nativeHandler, Z = M.fakeName, de = M.capture, we = M.slice(0, j).concat(M.slice(j + 1));
                      we.nativeHandler = U, we.fakeName = Z, we.capture = de, p[O] = we;
                    }
                }
                (!l || M.length === 0) && (delete p[O], Uc(n, M.fakeName || O, M.nativeHandler, M.capture));
              }
            }
          } else
            Ht(p, (v, S) => {
              Uc(n, v.fakeName || S, v.nativeHandler, v.capture);
            }), p = {};
          for (const v in p)
            if (Xn(p, v))
              return this;
          delete this.events[d];
          try {
            delete n[this.expando];
          } catch {
            n[this.expando] = null;
          }
        }
        return this;
      }
      fire(n, s, l) {
        return this.dispatch(n, s, l);
      }
      dispatch(n, s, l) {
        if (!n || Zt(n) || ci(n))
          return this;
        const d = $v({
          type: s,
          target: n
        }, l);
        do {
          const p = n[this.expando];
          p && this.executeHandlers(d, p), n = n.parentNode || n.ownerDocument || n.defaultView || n.parentWindow;
        } while (n && !d.isPropagationStopped());
        return this;
      }
      clean(n) {
        if (!n || Zt(n) || ci(n))
          return this;
        if (n[this.expando] && this.unbind(n), n.getElementsByTagName || (n = n.document), n && n.getElementsByTagName) {
          this.unbind(n);
          const s = n.getElementsByTagName("*");
          let l = s.length;
          for (; l--; )
            n = s[l], n[this.expando] && this.unbind(n);
        }
        return this;
      }
      destroy() {
        this.events = {};
      }
      cancel(n) {
        return n && (n.preventDefault(), n.stopImmediatePropagation()), !1;
      }
      executeHandlers(n, s) {
        const l = this.events[s], d = l && l[n.type];
        if (d)
          for (let p = 0, v = d.length; p < v; p++) {
            const S = d[p];
            if (S && S.func.call(S.scope, n) === !1 && n.preventDefault(), n.isImmediatePropagationStopped())
              return;
          }
      }
    }
    Ap.Event = new Ap();
    const Zw = Gt.each, Kk = Gt.grep, Gw = "data-mce-style", Yk = Gt.makeMap("fill-opacity font-weight line-height opacity orphans widows z-index zoom", " "), Bl = (e, n, s) => {
      Kt(s) || s === "" ? oa(e, n) : ur(e, n, s);
    }, Wc = (e) => e.replace(/[A-Z]/g, (n) => "-" + n.toLowerCase()), Qt = (e, n) => {
      let s = 0;
      if (e)
        for (let l = e.nodeType, d = e.previousSibling; d; d = d.previousSibling) {
          const p = d.nodeType;
          n && Zt(d) && (p === l || !d.data.length) || (s++, l = p);
        }
      return s;
    }, B0 = (e, n) => {
      const s = Ms(n, "style"), l = e.serialize(e.parse(s), gr(n));
      Bl(n, Gw, l);
    }, Xi = (e, n) => dn(e) ? Xn(Yk, n) ? e + "" : e + "px" : e, $0 = (e, n, s) => {
      const l = Wc(n);
      Kt(s) || s === "" ? kl(e, l) : hp(e, l, Xi(s, l));
    }, Xk = (e, n, s) => {
      const l = n.keep_values, d = {
        set: (v, S, O) => {
          const M = Me.fromDom(v);
          ye(n.url_converter) && je(S) && (S = n.url_converter.call(n.url_converter_scope || s(), String(S), O, v));
          const j = "data-mce-" + O;
          Bl(M, j, S), Bl(M, O, S);
        },
        get: (v, S) => {
          const O = Me.fromDom(v);
          return Ms(O, "data-mce-" + S) || Ms(O, S);
        }
      }, p = {
        style: {
          set: (v, S) => {
            const O = Me.fromDom(v);
            l && Bl(O, Gw, S), oa(O, "style"), G(S) && zo(O, e.parse(S));
          },
          get: (v) => {
            const S = Me.fromDom(v), O = Ms(S, Gw) || Ms(S, "style");
            return e.serialize(e.parse(O), gr(S));
          }
        }
      };
      return l && (p.href = p.src = d), p;
    }, Js = (e, n = {}) => {
      const s = {}, l = window, d = {};
      let p = 0;
      const v = !0, S = !0, O = Ja.forElement(Me.fromDom(e), {
        contentCssCors: n.contentCssCors,
        referrerPolicy: n.referrerPolicy
      }), M = [], j = n.schema ? n.schema : Hf({}), U = jw({
        url_converter: n.url_converter,
        url_converter_scope: n.url_converter_scope
      }, n.schema), Z = n.ownEvents ? new Ap() : Ap.Event, de = j.getBlockElements(), we = (ht) => G(ht) ? Xn(de, ht) : On(ht) && (Xn(de, ht.nodeName) || Lu(j, ht)), me = (ht) => ht && e && G(ht) ? e.getElementById(ht) : ht, Se = (ht) => {
        const xt = me(ht);
        return je(xt) ? Me.fromDom(xt) : null;
      }, ze = (ht, xt, fn = "") => {
        let nn;
        const Eo = Se(ht);
        if (je(Eo) && rt(Eo)) {
          const Ar = ik[xt];
          Ar && Ar.get ? nn = Ar.get(Eo.dom, xt) : nn = Ms(Eo, xt);
        }
        return je(nn) ? nn : fn;
      }, Ye = (ht) => {
        const xt = me(ht);
        return Kt(xt) ? [] : xt.attributes;
      }, We = (ht, xt, fn) => {
        ro(ht, (nn) => {
          if (On(nn)) {
            const Eo = Me.fromDom(nn), Ar = fn === "" ? null : fn, ha = Ms(Eo, xt), dm = ik[xt];
            dm && dm.set ? dm.set(Eo.dom, Ar, xt) : Bl(Eo, xt, Ar), ha !== Ar && n.onSetAttrib && n.onSetAttrib({
              attrElm: Eo.dom,
              attrName: xt,
              attrValue: Ar
            });
          }
        });
      }, ut = (ht, xt) => ht.cloneNode(xt), zt = () => n.root_element || e.body, an = (ht) => {
        const xt = Vs(ht);
        return {
          x: xt.x,
          y: xt.y,
          w: xt.width,
          h: xt.height
        };
      }, Dn = (ht, xt) => ui(e.body, me(ht), xt), Tt = (ht, xt, fn) => {
        ro(ht, (nn) => {
          const Eo = Me.fromDom(nn);
          $0(Eo, xt, fn), n.update_styles && B0(U, Eo);
        });
      }, yt = (ht, xt) => {
        ro(ht, (fn) => {
          const nn = Me.fromDom(fn);
          Ht(xt, (Eo, Ar) => {
            $0(nn, Ar, Eo);
          }), n.update_styles && B0(U, nn);
        });
      }, Lt = (ht, xt, fn) => {
        const nn = me(ht);
        if (!(Kt(nn) || !kc(nn) && !Ov(nn)))
          return fn ? fa(Me.fromDom(nn), Wc(xt)) : (xt = xt.replace(/-(\D)/g, (Eo, Ar) => Ar.toUpperCase()), xt === "float" && (xt = "cssFloat"), nn.style ? nn.style[xt] : void 0);
      }, Vn = (ht) => {
        const xt = me(ht);
        if (!xt)
          return {
            w: 0,
            h: 0
          };
        let fn = Lt(xt, "width"), nn = Lt(xt, "height");
        return (!fn || fn.indexOf("px") === -1) && (fn = "0"), (!nn || nn.indexOf("px") === -1) && (nn = "0"), {
          w: parseInt(fn, 10) || xt.offsetWidth || xt.clientWidth,
          h: parseInt(nn, 10) || xt.offsetHeight || xt.clientHeight
        };
      }, co = (ht) => {
        const xt = me(ht), fn = Dn(xt), nn = Vn(xt);
        return {
          x: fn.x,
          y: fn.y,
          w: nn.w,
          h: nn.h
        };
      }, Xo = (ht, xt) => {
        if (!ht)
          return !1;
        const fn = Xe(ht) ? ht : [ht];
        return $n(fn, (nn) => wl(Me.fromDom(nn), xt));
      }, Sr = (ht, xt, fn, nn) => {
        const Eo = [];
        let Ar = me(ht);
        nn = nn === void 0;
        const ha = fn || (zt().nodeName !== "BODY" ? zt().parentNode : null);
        if (G(xt))
          if (xt === "*")
            xt = On;
          else {
            const dm = xt;
            xt = ($A) => Xo($A, dm);
          }
        for (; Ar && !(Ar === ha || Kt(Ar.nodeType) || xp(Ar) || Qa(Ar)); ) {
          if (!xt || xt(Ar))
            if (nn)
              Eo.push(Ar);
            else
              return [Ar];
          Ar = Ar.parentNode;
        }
        return nn ? Eo : null;
      }, ts = (ht, xt, fn) => {
        const nn = Sr(ht, xt, fn, !1);
        return nn && nn.length > 0 ? nn[0] : null;
      }, Cs = (ht, xt, fn) => {
        let nn = xt;
        if (ht) {
          G(xt) && (nn = (Eo) => Xo(Eo, xt));
          for (let Eo = ht[fn]; Eo; Eo = Eo[fn])
            if (ye(nn) && nn(Eo))
              return Eo;
        }
        return null;
      }, Pa = (ht, xt) => Cs(ht, xt, "nextSibling"), yl = (ht, xt) => Cs(ht, xt, "previousSibling"), bs = (ht) => ye(ht.querySelectorAll), hn = (ht, xt) => {
        var fn, nn;
        const Eo = (nn = (fn = me(xt)) !== null && fn !== void 0 ? fn : n.root_element) !== null && nn !== void 0 ? nn : e;
        return bs(Eo) ? hr(Eo.querySelectorAll(ht)) : [];
      }, ro = function(ht, xt, fn) {
        const nn = fn ?? this;
        if (Xe(ht)) {
          const Eo = [];
          return Zw(ht, (Ar, ha) => {
            const dm = me(Ar);
            dm && Eo.push(xt.call(nn, dm, ha));
          }), Eo;
        } else {
          const Eo = me(ht);
          return Eo ? xt.call(nn, Eo) : !1;
        }
      }, Ur = (ht, xt) => {
        ro(ht, (fn) => {
          Ht(xt, (nn, Eo) => {
            We(fn, Eo, nn);
          });
        });
      }, Sn = (ht, xt) => {
        ro(ht, (fn) => {
          const nn = Me.fromDom(fn);
          hd(nn, xt);
        });
      }, yo = (ht, xt, fn, nn, Eo) => ro(ht, (Ar) => {
        const ha = G(xt) ? e.createElement(xt) : xt;
        return je(fn) && Ur(ha, fn), nn && (!G(nn) && nn.nodeType ? ha.appendChild(nn) : G(nn) && Sn(ha, nn)), Eo ? ha : Ar.appendChild(ha);
      }), fr = (ht, xt, fn) => yo(e.createElement(ht), ht, xt, fn, !0), An = ef.decode, mr = ef.encodeAllRaw, _r = (ht, xt, fn = "") => {
        let nn = "<" + ht;
        for (const Eo in xt)
          Ss(xt, Eo) && (nn += " " + Eo + '="' + mr(xt[Eo]) + '"');
        return Yo(fn) && Xn(j.getVoidElements(), ht) ? nn + " />" : nn + ">" + fn + "</" + ht + ">";
      }, zi = (ht) => {
        const xt = e.createElement("div"), fn = e.createDocumentFragment();
        fn.appendChild(xt), ht && (xt.innerHTML = ht);
        let nn;
        for (; nn = xt.firstChild; )
          fn.appendChild(nn);
        return fn.removeChild(xt), fn;
      }, ls = (ht, xt) => ro(ht, (fn) => {
        const nn = Me.fromDom(fn);
        return xt && Ue(Ya(nn), (Eo) => {
          pt(Eo) && Eo.dom.length === 0 ? ys(Eo) : Ki(nn, Eo);
        }), ys(nn), nn.dom;
      }), pi = (ht) => ro(ht, (xt) => {
        const fn = xt.attributes;
        for (let nn = fn.length - 1; nn >= 0; nn--)
          xt.removeAttributeNode(fn.item(nn));
      }), Nd = (ht) => U.parse(ht), um = (ht, xt) => U.serialize(ht, xt), pc = (ht) => {
        if (kf !== Js.DOM && e === document) {
          if (s[ht])
            return;
          s[ht] = !0;
        }
        let xt = e.getElementById("mceDefaultStyles");
        if (!xt) {
          xt = e.createElement("style"), xt.id = "mceDefaultStyles", xt.type = "text/css";
          const fn = e.head;
          fn.firstChild ? fn.insertBefore(xt, fn.firstChild) : fn.appendChild(xt);
        }
        xt.styleSheet ? xt.styleSheet.cssText += ht : xt.appendChild(e.createTextNode(ht));
      }, ku = (ht) => {
        ht || (ht = ""), Ue(ht.split(","), (xt) => {
          d[xt] = !0, O.load(xt).catch(qe);
        });
      }, td = (ht, xt, fn) => {
        ro(ht, (nn) => {
          if (On(nn)) {
            const Eo = Me.fromDom(nn), Ar = xt.split(" ");
            Ue(Ar, (ha) => {
              je(fn) ? (fn ? fd : lu)(Eo, ha) : Ah(Eo, ha);
            });
          }
        });
      }, _u = (ht, xt) => {
        td(ht, xt, !0);
      }, Md = (ht, xt) => {
        td(ht, xt, !1);
      }, uo = (ht, xt) => {
        const fn = Se(ht), nn = xt.split(" ");
        return je(fn) && Ko(nn, (Eo) => Pf(fn, Eo));
      }, $r = (ht) => {
        ro(ht, (xt) => kl(Me.fromDom(xt), "display"));
      }, ya = (ht) => {
        ro(ht, (xt) => hp(Me.fromDom(xt), "display", "none"));
      }, Da = (ht) => {
        const xt = Se(ht);
        return je(xt) && fs(Sl(xt, "display"), "none");
      }, ri = (ht) => (ht || "mce_") + p++, rl = (ht) => {
        const xt = Se(ht);
        return je(xt) ? On(xt.dom) ? xt.dom.outerHTML : ec(xt) : "";
      }, Ua = (ht, xt) => {
        ro(ht, (fn) => {
          On(fn) && (fn.outerHTML = xt);
        });
      }, Fa = (ht, xt) => {
        const fn = me(xt);
        return ro(ht, (nn) => {
          const Eo = fn == null ? void 0 : fn.parentNode, Ar = fn == null ? void 0 : fn.nextSibling;
          return Eo && (Ar ? Eo.insertBefore(nn, Ar) : Eo.appendChild(nn)), nn;
        });
      }, Ul = (ht, xt, fn) => ro(xt, (nn) => {
        var Eo;
        const Ar = Xe(xt) ? ht.cloneNode(!0) : ht;
        return fn && Zw(Kk(nn.childNodes), (ha) => {
          Ar.appendChild(ha);
        }), (Eo = nn.parentNode) === null || Eo === void 0 || Eo.replaceChild(Ar, nn), nn;
      }), nd = (ht, xt) => {
        if (ht.nodeName !== xt.toUpperCase()) {
          const fn = fr(xt);
          return Zw(Ye(ht), (nn) => {
            We(fn, nn.nodeName, ze(ht, nn.nodeName));
          }), Ul(fn, ht, !0), fn;
        } else
          return ht;
      }, Cf = (ht, xt) => {
        let fn = ht;
        for (; fn; ) {
          let nn = xt;
          for (; nn && fn !== nn; )
            nn = nn.parentNode;
          if (fn === nn)
            break;
          fn = fn.parentNode;
        }
        return !fn && ht.ownerDocument ? ht.ownerDocument.documentElement : fn;
      }, Sf = (ht, xt, fn) => nt(xt) ? $u(j, ht, {
        ...fn,
        isContent: (Eo) => {
          const Ar = Eo.nodeName.toLowerCase();
          return !!xt[Ar];
        }
      }) : $u(j, ht, fn), Id = () => e.createRange(), mh = (ht, xt, fn) => {
        let nn = Id(), Eo, Ar;
        if (ht && xt && ht.parentNode && xt.parentNode) {
          const ha = ht.parentNode;
          return nn.setStart(ha, Qt(ht)), nn.setEnd(xt.parentNode, Qt(xt)), Eo = nn.extractContents(), nn = Id(), nn.setStart(xt.parentNode, Qt(xt) + 1), nn.setEnd(ha, Qt(ht) + 1), Ar = nn.extractContents(), ha.insertBefore($f(kf, Eo, j), ht), fn ? ha.insertBefore(fn, ht) : ha.insertBefore(xt, ht), ha.insertBefore($f(kf, Ar, j), ht), ls(ht), fn || xt;
        } else
          return;
      }, l0 = (ht, xt, fn, nn) => {
        if (Xe(ht)) {
          let Eo = ht.length;
          const Ar = [];
          for (; Eo--; )
            Ar[Eo] = l0(ht[Eo], xt, fn, nn);
          return Ar;
        } else
          return n.collect && (ht === e || ht === l) && M.push([
            ht,
            xt,
            fn,
            nn
          ]), Z.bind(ht, xt, fn, nn || kf);
      }, c0 = (ht, xt, fn) => {
        if (Xe(ht)) {
          let nn = ht.length;
          const Eo = [];
          for (; nn--; )
            Eo[nn] = c0(ht[nn], xt, fn);
          return Eo;
        } else {
          if (M.length > 0 && (ht === e || ht === l)) {
            let nn = M.length;
            for (; nn--; ) {
              const [Eo, Ar, ha] = M[nn];
              ht === Eo && (!xt || xt === Ar) && (!fn || fn === ha) && Z.unbind(Eo, Ar, ha);
            }
          }
          return Z.unbind(ht, xt, fn);
        }
      }, iI = (ht, xt, fn) => Z.dispatch(ht, xt, fn), ph = (ht, xt, fn) => Z.dispatch(ht, xt, fn), FA = (ht) => {
        if (ht && kc(ht)) {
          const xt = ht.getAttribute("data-mce-contenteditable");
          return xt && xt !== "inherit" ? xt : ht.contentEditable !== "inherit" ? ht.contentEditable : null;
        } else
          return null;
      }, kf = {
        doc: e,
        settings: n,
        win: l,
        files: d,
        stdMode: v,
        boxModel: S,
        styleSheetLoader: O,
        boundEvents: M,
        styles: U,
        schema: j,
        events: Z,
        isBlock: we,
        root: null,
        clone: ut,
        getRoot: zt,
        getViewPort: an,
        getRect: co,
        getSize: Vn,
        getParent: ts,
        getParents: Sr,
        get: me,
        getNext: Pa,
        getPrev: yl,
        select: hn,
        is: Xo,
        add: yo,
        create: fr,
        createHTML: _r,
        createFragment: zi,
        remove: ls,
        setStyle: Tt,
        getStyle: Lt,
        setStyles: yt,
        removeAllAttribs: pi,
        setAttrib: We,
        setAttribs: Ur,
        getAttrib: ze,
        getPos: Dn,
        parseStyle: Nd,
        serializeStyle: um,
        addStyle: pc,
        loadCSS: ku,
        addClass: _u,
        removeClass: Md,
        hasClass: uo,
        toggleClass: td,
        show: $r,
        hide: ya,
        isHidden: Da,
        uniqueId: ri,
        setHTML: Sn,
        getOuterHTML: rl,
        setOuterHTML: Ua,
        decode: An,
        encode: mr,
        insertAfter: Fa,
        replace: Ul,
        rename: nd,
        findCommonAncestor: Cf,
        run: ro,
        getAttribs: Ye,
        isEmpty: Sf,
        createRng: Id,
        nodeIndex: Qt,
        split: mh,
        bind: l0,
        unbind: c0,
        fire: ph,
        dispatch: iI,
        getContentEditable: FA,
        getContentEditableParent: (ht) => {
          const xt = zt();
          let fn = null;
          for (let nn = ht; nn && nn !== xt && (fn = FA(nn), fn === null); nn = nn.parentNode)
            ;
          return fn;
        },
        isEditable: (ht) => {
          if (je(ht)) {
            const xt = On(ht) ? ht : ht.parentElement;
            return je(xt) && kc(xt) && za(Me.fromDom(xt));
          } else
            return !1;
        },
        destroy: () => {
          if (M.length > 0) {
            let ht = M.length;
            for (; ht--; ) {
              const [xt, fn, nn] = M[ht];
              Z.unbind(xt, fn, nn);
            }
          }
          Ht(d, (ht, xt) => {
            O.unload(xt), delete d[xt];
          });
        },
        isChildOf: (ht, xt) => ht === xt || xt.contains(ht),
        dumpRng: (ht) => "startContainer: " + ht.startContainer.nodeName + ", startOffset: " + ht.startOffset + ", endContainer: " + ht.endContainer.nodeName + ", endOffset: " + ht.endOffset
      }, ik = Xk(U, n, dt(kf));
      return kf;
    };
    Js.DOM = Js(document), Js.nodeIndex = Qt;
    const Am = Js.DOM, L0 = 0, J3 = 1, Pm = 2, H0 = 3;
    class of {
      constructor(n = {}) {
        this.states = {}, this.queue = [], this.scriptLoadedCallbacks = {}, this.queueLoadedCallbacks = [], this.loading = !1, this.settings = n;
      }
      _setReferrerPolicy(n) {
        this.settings.referrerPolicy = n;
      }
      loadScript(n) {
        return new Promise((s, l) => {
          const d = Am;
          let p;
          const v = () => {
            d.remove(M), p && (p.onerror = p.onload = p = null);
          }, S = () => {
            v(), s();
          }, O = () => {
            v(), l("Failed to load script: " + n);
          }, M = d.uniqueId();
          p = document.createElement("script"), p.id = M, p.type = "text/javascript", p.src = Gt._addCacheSuffix(n), this.settings.referrerPolicy && d.setAttrib(p, "referrerpolicy", this.settings.referrerPolicy), p.onload = S, p.onerror = O, (document.getElementsByTagName("head")[0] || document.body).appendChild(p);
        });
      }
      isDone(n) {
        return this.states[n] === Pm;
      }
      markDone(n) {
        this.states[n] = Pm;
      }
      add(n) {
        const s = this;
        return s.queue.push(n), s.states[n] === void 0 && (s.states[n] = L0), new Promise((d, p) => {
          s.scriptLoadedCallbacks[n] || (s.scriptLoadedCallbacks[n] = []), s.scriptLoadedCallbacks[n].push({
            resolve: d,
            reject: p
          });
        });
      }
      load(n) {
        return this.add(n);
      }
      remove(n) {
        delete this.states[n], delete this.scriptLoadedCallbacks[n];
      }
      loadQueue() {
        const n = this.queue;
        return this.queue = [], this.loadScripts(n);
      }
      loadScripts(n) {
        const s = this, l = (O, M) => {
          Or(s.scriptLoadedCallbacks, M).each((j) => {
            Ue(j, (U) => U[O](M));
          }), delete s.scriptLoadedCallbacks[M];
        }, d = (O) => {
          const M = xn(O, (j) => j.status === "rejected");
          return M.length > 0 ? Promise.reject(nr(M, ({ reason: j }) => Xe(j) ? j : [j])) : Promise.resolve();
        }, p = (O) => Promise.allSettled(en(O, (M) => s.states[M] === Pm ? (l("resolve", M), Promise.resolve()) : s.states[M] === H0 ? (l("reject", M), Promise.reject(M)) : (s.states[M] = J3, s.loadScript(M).then(() => {
          s.states[M] = Pm, l("resolve", M);
          const j = s.queue;
          return j.length > 0 ? (s.queue = [], p(j).then(d)) : Promise.resolve();
        }, () => (s.states[M] = H0, l("reject", M), Promise.reject(M)))))), v = (O) => (s.loading = !0, p(O).then((M) => {
          s.loading = !1;
          const j = s.queueLoadedCallbacks.shift();
          return Y.from(j).each(on), d(M);
        })), S = bt(n);
        return s.loading ? new Promise((O, M) => {
          s.queueLoadedCallbacks.push(() => {
            v(S).then(O, M);
          });
        }) : v(S);
      }
    }
    of.ScriptLoader = new of();
    const Qk = (e, n) => {
      const s = e.indexOf(n);
      return s !== -1 && e.indexOf(n, s + 1) > s;
    }, qw = (e) => ve(e) && Xn(e, "raw"), Us = (e) => Xe(e) && e.length > 1, cb = {}, va = Qe("en"), Jk = () => Or(cb, va.get()), Ii = {
      getData: () => Ho(cb, (e) => ({ ...e })),
      setCode: (e) => {
        e && va.set(e);
      },
      getCode: () => va.get(),
      add: (e, n) => {
        let s = cb[e];
        s || (cb[e] = s = {});
        const l = en(Zo(n), (d) => d.toLowerCase());
        Ht(n, (d, p) => {
          const v = p.toLowerCase();
          v !== p && Qk(l, v) ? (Xn(n, v) || (s[v] = d), s[p] = d) : s[v] = d;
        });
      },
      translate: (e) => {
        const n = Jk().getOr({}), s = (v) => ye(v) ? Object.prototype.toString.call(v) : l(v) ? "" : "" + v, l = (v) => v === "" || v === null || v === void 0, d = (v) => {
          const S = s(v);
          return Xn(n, S) ? s(n[S]) : Or(n, S.toLowerCase()).map(s).getOr(S);
        }, p = (v) => v.replace(/{context:\w+}$/, "");
        if (l(e))
          return "";
        if (qw(e))
          return s(e.raw);
        if (Us(e)) {
          const v = e.slice(1), S = d(e[0]).replace(/\{([0-9]+)\}/g, (O, M) => Xn(v, M) ? s(v[M]) : O);
          return p(S);
        }
        return p(d(e));
      },
      isRtl: () => Jk().bind((e) => Or(e, "_dir")).exists((e) => e === "rtl"),
      hasCode: (e) => Xn(cb, e)
    }, rc = () => {
      const e = [], n = {}, s = {}, l = [], d = (me, Se) => {
        const ze = xn(l, (Ye) => Ye.name === me && Ye.state === Se);
        Ue(ze, (Ye) => Ye.resolve());
      }, p = (me) => Xn(n, me), v = (me) => Xn(s, me), S = (me) => {
        if (s[me])
          return s[me].instance;
      }, O = (me, Se) => {
        const ze = Ii.getCode(), Ye = "," + (Se || "") + ",";
        !ze || Se && Ye.indexOf("," + ze + ",") === -1 || of.ScriptLoader.add(n[me] + "/langs/" + ze + ".js");
      }, M = (me, Se) => {
        rc.languageLoad !== !1 && (p(me) ? O(me, Se) : we(me, "loaded").then(() => O(me, Se)));
      }, j = (me, Se) => (e.push(Se), s[me] = { instance: Se }, d(me, "added"), Se), U = (me) => {
        delete n[me], delete s[me];
      }, Z = (me, Se) => G(Se) ? G(me) ? {
        prefix: "",
        resource: Se,
        suffix: ""
      } : {
        prefix: me.prefix,
        resource: Se,
        suffix: me.suffix
      } : Se, de = (me, Se) => {
        if (n[me])
          return Promise.resolve();
        let ze = G(Se) ? Se : Se.prefix + Se.resource + Se.suffix;
        ze.indexOf("/") !== 0 && ze.indexOf("://") === -1 && (ze = rc.baseURL + "/" + ze), n[me] = ze.substring(0, ze.lastIndexOf("/"));
        const Ye = () => (d(me, "loaded"), Promise.resolve());
        return s[me] ? Ye() : of.ScriptLoader.add(ze).then(Ye);
      }, we = (me, Se = "added") => Se === "added" && v(me) || Se === "loaded" && p(me) ? Promise.resolve() : new Promise((ze) => {
        l.push({
          name: me,
          state: Se,
          resolve: ze
        });
      });
      return {
        items: e,
        urls: n,
        lookup: s,
        get: S,
        requireLangPack: M,
        add: j,
        remove: U,
        createUrl: Z,
        load: de,
        waitFor: we
      };
    };
    rc.languageLoad = !0, rc.baseURL = "", rc.PluginManager = rc(), rc.ThemeManager = rc(), rc.ModelManager = rc();
    const Lv = (e, n) => {
      let s = null;
      return {
        cancel: () => {
          te(s) || (clearTimeout(s), s = null);
        },
        throttle: (...p) => {
          te(s) && (s = setTimeout(() => {
            s = null, e.apply(null, p);
          }, n));
        }
      };
    }, Pp = (e, n) => {
      let s = null;
      const l = () => {
        te(s) || (clearTimeout(s), s = null);
      };
      return {
        cancel: l,
        throttle: (...p) => {
          l(), s = setTimeout(() => {
            s = null, e.apply(null, p);
          }, n);
        }
      };
    }, Kw = (e, n, s) => Ra(e, n, s).isSome(), db = dt("mce-annotation"), Vf = dt("data-mce-annotation"), fb = dt("data-mce-annotation-uid"), qh = dt("data-mce-annotation-active"), Dp = dt("data-mce-annotation-classes"), jf = dt("data-mce-annotation-attrs"), Kh = (e) => (n) => zr(n, e), Yh = (e, n) => {
      const s = e.selection.getRng(), l = Me.fromDom(s.startContainer), d = Me.fromDom(e.getBody()), p = n.fold(() => "." + db(), (O) => `[${Vf()}="${O}"]`), v = md(l, s.startOffset).getOr(l);
      return cu(v, p, Kh(d)).bind((O) => da(O, `${fb()}`).bind((M) => da(O, `${Vf()}`).map((j) => {
        const U = z0(e, M);
        return {
          uid: M,
          name: j,
          elements: U
        };
      })));
    }, r4 = (e) => rt(e) && Pf(e, db()), Yw = (e, n) => sa(e, "data-mce-bogus") || Kw(e, '[data-mce-bogus="all"]', Kh(n)), z0 = (e, n) => {
      const s = Me.fromDom(e.getBody()), l = ba(s, `[${fb()}="${n}"]`);
      return xn(l, (d) => !Yw(d, s));
    }, e_ = (e, n) => {
      const s = Me.fromDom(e.getBody()), l = ba(s, `[${Vf()}="${n}"]`), d = {};
      return Ue(l, (p) => {
        if (!Yw(p, s)) {
          const v = Ms(p, fb()), S = Or(d, v).getOr([]);
          d[v] = S.concat([p]);
        }
      }), d;
    }, Xw = (e, n) => {
      const s = Qe({}), l = () => ({
        listeners: [],
        previous: Mi()
      }), d = (U, Z) => {
        p(U, (de) => (Z(de), de));
      }, p = (U, Z) => {
        const de = s.get(), we = Or(de, U).getOrThunk(l), me = Z(we);
        de[U] = me, s.set(de);
      }, v = (U, Z, de) => {
        d(U, (we) => {
          Ue(we.listeners, (me) => me(!0, U, {
            uid: Z,
            nodes: en(de, (Se) => Se.dom)
          }));
        });
      }, S = (U) => {
        d(U, (Z) => {
          Ue(Z.listeners, (de) => de(!1, U));
        });
      }, O = (U, Z) => {
        Ue(z0(e, U), (de) => {
          Z ? ur(de, qh(), "true") : oa(de, qh());
        });
      }, M = Pp(() => {
        const U = kt(n.getNames());
        Ue(U, (Z) => {
          p(Z, (de) => {
            const we = de.previous.get();
            return Yh(e, Y.some(Z)).fold(() => {
              we.each((me) => {
                S(Z), de.previous.clear(), O(me, !1);
              });
            }, ({ uid: me, name: Se, elements: ze }) => {
              fs(we, me) || (we.each((Ye) => O(Ye, !1)), v(Se, me, ze), de.previous.set(me), O(me, !0));
            }), {
              previous: de.previous,
              listeners: de.listeners
            };
          });
        });
      }, 30);
      return e.on("remove", () => {
        M.cancel();
      }), e.on("NodeChange", () => {
        M.throttle();
      }), { addListener: (U, Z) => {
        p(U, (de) => ({
          previous: de.previous,
          listeners: de.listeners.concat([Z])
        }));
      } };
    }, V0 = (e, n) => {
      const s = Vf(), l = (p) => Y.from(p.attr(s)).bind(n.lookup), d = (p) => {
        var v, S;
        p.attr(fb(), null), p.attr(Vf(), null), p.attr(qh(), null);
        const O = Y.from(p.attr(jf())).map((Z) => Z.split(",")).getOr([]), M = Y.from(p.attr(Dp())).map((Z) => Z.split(",")).getOr([]);
        Ue(O, (Z) => p.attr(Z, null));
        const j = (S = (v = p.attr("class")) === null || v === void 0 ? void 0 : v.split(" ")) !== null && S !== void 0 ? S : [], U = Mr(j, [db()].concat(M));
        p.attr("class", U.length > 0 ? U.join(" ") : null), p.attr(Dp(), null), p.attr(jf(), null);
      };
      e.serializer.addTempAttr(qh()), e.serializer.addAttributeFilter(s, (p) => {
        for (const v of p)
          l(v).each((S) => {
            S.persistent === !1 && (v.name === "span" ? v.unwrap() : d(v));
          });
      });
    }, Qw = () => {
      const e = {};
      return {
        register: (d, p) => {
          e[d] = {
            name: d,
            settings: p
          };
        },
        lookup: (d) => Or(e, d).map((p) => p.settings),
        getNames: () => Zo(e)
      };
    };
    let j0 = 0;
    const mb = (e) => {
      const s = (/* @__PURE__ */ new Date()).getTime(), l = Math.floor(Math.random() * 1e9);
      return j0++, e + "_" + l + j0 + String(s);
    }, U0 = (e, n) => {
      Ue(n, (s) => {
        fd(e, s);
      });
    }, dF = (e, n) => {
      Ue(n, (s) => {
        lu(e, s);
      });
    }, s4 = (e, n) => Me.fromDom(e.dom.cloneNode(n)), rf = (e) => s4(e, !1), pb = (e) => s4(e, !0), t_ = (e, n) => {
      const s = Me.fromTag(n), l = wc(e);
      return _a(s, l), s;
    }, n_ = (e, n) => {
      const s = t_(e, n);
      Jl(e, s);
      const l = Ya(e);
      return pd(s, l), ys(e), s;
    }, W0 = (e, n, s = tt) => {
      const l = new Ri(e, n), d = (p) => {
        let v;
        do
          v = l[p]();
        while (v && !Zt(v) && !s(v));
        return Y.from(v).filter(Zt);
      };
      return {
        current: () => Y.from(l.current()).filter(Zt),
        next: () => d("next"),
        prev: () => d("prev"),
        prev2: () => d("prev2")
      };
    }, Rp = (e, n) => {
      const s = n || ((v) => e.isBlock(v) || Wr(v) || Vr(v)), l = (v, S, O, M) => {
        if (Zt(v)) {
          const j = M(v, S, v.data);
          if (j !== -1)
            return Y.some({
              container: v,
              offset: j
            });
        }
        return O().bind((j) => l(j.container, j.offset, O, M));
      };
      return {
        backwards: (v, S, O, M) => {
          const j = W0(v, M ?? e.getRoot(), s);
          return l(v, S, () => j.prev().map((U) => ({
            container: U,
            offset: U.length
          })), O).getOrNull();
        },
        forwards: (v, S, O, M) => {
          const j = W0(v, M ?? e.getRoot(), s);
          return l(v, S, () => j.next().map((U) => ({
            container: U,
            offset: 0
          })), O).getOrNull();
        }
      };
    }, Jw = ((e, n) => {
      const s = (p) => {
        if (!e(p))
          throw new Error("Can only get " + n + " value of a " + n + " node");
        return l(p).getOr("");
      }, l = (p) => e(p) ? Y.from(p.dom.nodeValue) : Y.none();
      return {
        get: s,
        getOption: l,
        set: (p, v) => {
          if (!e(p))
            throw new Error("Can only set raw " + n + " value of a " + n + " node");
          p.dom.nodeValue = v;
        }
      };
    })(pt, "text"), Hv = (e) => Jw.get(e), i4 = (e) => Jw.getOption(e), Z0 = (e, n) => Jw.set(e, n), hb = [
      "td",
      "th"
    ], o_ = [
      "thead",
      "tbody",
      "tfoot"
    ], G0 = [
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "p",
      "div",
      "address",
      "pre",
      "form",
      "blockquote",
      "center",
      "dir",
      "fieldset",
      "header",
      "footer",
      "article",
      "section",
      "hgroup",
      "aside",
      "nav",
      "figure"
    ], e2 = [
      "li",
      "dd",
      "dt"
    ], r_ = [
      "ul",
      "ol",
      "dl"
    ], Ol = [
      "pre",
      "script",
      "textarea",
      "style"
    ], zv = (e) => {
      let n;
      return (s) => (n = n || at(e, mt), Xn(n, gr(s)));
    }, t2 = (e) => gr(e) === "table", gb = (e) => rt(e) && gr(e) === "br", s_ = zv(G0), sf = zv(r_), Oc = zv(e2), bb = zv(o_), vb = zv(hb), Vv = zv(Ol), l4 = (e) => {
      const n = [];
      let s = e.dom;
      for (; s; )
        n.push(Me.fromDom(s)), s = s.lastChild;
      return n;
    }, c4 = (e) => {
      const n = ba(e, "br"), s = xn(l4(e).slice(-1), gb);
      n.length === s.length && Ue(s, ys);
    }, Xh = () => {
      const e = Me.fromTag("br");
      return ur(e, "data-mce-bogus", "1"), e;
    }, qc = (e) => {
      Lc(e), Ys(e, Xh());
    }, a_ = (e, n) => {
      Sc(e).each((s) => {
        Xl(s).each((l) => {
          n.isBlock(gr(e)) && gb(s) && n.isBlock(gr(l)) && ys(s);
        });
      });
    }, Ma = Jg, Qh = Ev, Kc = Ni, fF = (e) => e.insertContent(Ma, { preserve_zwsp: !0 }), q0 = On, yb = Zt, Jh = (e) => (yb(e) && (e = e.parentNode), q0(e) && e.hasAttribute("data-mce-caret")), af = (e) => yb(e) && Qh(e.data), Yc = (e) => Jh(e) || af(e), n2 = (e) => e.firstChild !== e.lastChild || !Wr(e.firstChild), o2 = (e, n) => {
      var s;
      const d = ((s = e.ownerDocument) !== null && s !== void 0 ? s : document).createTextNode(Ma), p = e.parentNode;
      if (n) {
        const v = e.previousSibling;
        if (yb(v)) {
          if (Yc(v))
            return v;
          if (Uf(v))
            return v.splitText(v.data.length - 1);
        }
        p == null || p.insertBefore(d, e);
      } else {
        const v = e.nextSibling;
        if (yb(v)) {
          if (Yc(v))
            return v;
          if (tg(v))
            return v.splitText(1), v;
        }
        e.nextSibling ? p == null || p.insertBefore(d, e.nextSibling) : p == null || p.appendChild(d);
      }
      return d;
    }, r2 = (e) => {
      const n = e.container();
      return Zt(n) ? n.data.charAt(e.offset()) === Ma || e.isAtStart() && af(n.previousSibling) : !1;
    }, eg = (e) => {
      const n = e.container();
      return Zt(n) ? n.data.charAt(e.offset() - 1) === Ma || e.isAtEnd() && af(n.nextSibling) : !1;
    }, u4 = (e, n, s) => {
      var l;
      const p = ((l = n.ownerDocument) !== null && l !== void 0 ? l : document).createElement(e);
      p.setAttribute("data-mce-caret", s ? "before" : "after"), p.setAttribute("data-mce-bogus", "all"), p.appendChild(Xh().dom);
      const v = n.parentNode;
      return s ? v == null || v.insertBefore(p, n) : n.nextSibling ? v == null || v.insertBefore(p, n.nextSibling) : v == null || v.appendChild(p), p;
    }, tg = (e) => yb(e) && e.data[0] === Ma, Uf = (e) => yb(e) && e.data[e.data.length - 1] === Ma, jv = (e) => {
      var n;
      const s = e.getElementsByTagName("br"), l = s[s.length - 1];
      _m(l) && ((n = l.parentNode) === null || n === void 0 || n.removeChild(l));
    }, Rr = (e) => e && e.hasAttribute("data-mce-caret") ? (jv(e), e.removeAttribute("data-mce-caret"), e.removeAttribute("data-mce-bogus"), e.removeAttribute("style"), e.removeAttribute("data-mce-style"), e.removeAttribute("_moz_abspos"), e) : null, sc = (e) => Jh(e.startContainer), ju = Math.round, Dm = (e) => e ? {
      left: ju(e.left),
      top: ju(e.top),
      bottom: ju(e.bottom),
      right: ju(e.right),
      width: ju(e.width),
      height: ju(e.height)
    } : {
      left: 0,
      top: 0,
      bottom: 0,
      right: 0,
      width: 0,
      height: 0
    }, Ws = (e, n) => (e = Dm(e), n || (e.left = e.left + e.width), e.right = e.left, e.width = 0, e), i_ = (e, n) => e.left === n.left && e.top === n.top && e.bottom === n.bottom && e.right === n.right, K0 = (e, n, s) => e >= 0 && e <= Math.min(n.height, s.height) / 2, Uv = (e, n) => {
      const s = Math.min(n.height / 2, e.height / 2);
      return e.bottom - s < n.top ? !0 : e.top > n.bottom ? !1 : K0(n.top - e.bottom, e, n);
    }, Y0 = (e, n) => e.top > n.bottom ? !0 : e.bottom < n.top ? !1 : K0(n.bottom - e.top, e, n), d4 = (e, n, s) => n >= e.left && n <= e.right && s >= e.top && s <= e.bottom, pa = (e) => Ct(e, (n, s) => n.fold(() => Y.some(s), (l) => {
      const d = Math.min(s.left, l.left), p = Math.min(s.top, l.top), v = Math.max(s.right, l.right), S = Math.max(s.bottom, l.bottom);
      return Y.some({
        top: p,
        right: v,
        bottom: S,
        left: d,
        width: v - d,
        height: S - p
      });
    }), Y.none()), s2 = (e, n, s) => {
      const l = Math.max(Math.min(n, e.left + e.width), e.left), d = Math.max(Math.min(s, e.top + e.height), e.top);
      return Math.sqrt((n - l) * (n - l) + (s - d) * (s - d));
    }, f4 = (e, n) => Math.max(0, Math.min(e.bottom, n.bottom) - Math.max(e.top, n.top)), m4 = (e, n, s) => Math.min(Math.max(e, n), s), xb = (e) => {
      const n = e.startContainer, s = e.startOffset;
      return n === e.endContainer && n.hasChildNodes() && e.endOffset === s + 1 ? n.childNodes[s] : null;
    }, Nn = (e, n) => {
      if (On(e) && e.hasChildNodes()) {
        const s = e.childNodes, l = m4(n, 0, s.length - 1);
        return s[l];
      } else
        return e;
    }, p4 = (e, n) => {
      if (!(n < 0 && On(e) && e.hasChildNodes()))
        return Nn(e, n);
    }, l_ = new RegExp("[-----------------------------------------------------------------------------------------------------------------------------------]"), X0 = (e) => G(e) && e.charCodeAt(0) >= 768 && l_.test(e), a2 = (...e) => (n) => {
      for (let s = 0; s < e.length; s++)
        if (e[s](n))
          return !0;
      return !1;
    }, h4 = (...e) => (n) => {
      for (let s = 0; s < e.length; s++)
        if (!e[s](n))
          return !1;
      return !0;
    }, Wv = Rt, Zv = Vr, ng = Wr, mF = Zt, Wf = du([
      "script",
      "style",
      "textarea"
    ]), g4 = du([
      "img",
      "input",
      "textarea",
      "hr",
      "iframe",
      "video",
      "audio",
      "object",
      "embed"
    ]), Rm = du(["table"]), c_ = Yc, lf = (e) => c_(e) ? !1 : mF(e) ? !Wf(e.parentNode) : g4(e) || ng(e) || Rm(e) || wb(e), u_ = (e) => On(e) && e.getAttribute("unselectable") === "true", wb = (e) => !u_(e) && Zv(e), b4 = (e, n) => {
      for (let s = e.parentNode; s && s !== n; s = s.parentNode) {
        if (wb(s))
          return !1;
        if (Wv(s))
          return !0;
      }
      return !0;
    }, v4 = (e) => wb(e) ? !Ct(hr(e.getElementsByTagName("*")), (n, s) => n || Wv(s), !1) : !1, y4 = (e) => g4(e) || v4(e), i2 = (e, n) => lf(e) && b4(e, n), Q0 = On, d_ = lf, l2 = Lh("display", "block table"), x4 = Lh("float", "left right"), Gv = h4(Q0, d_, jt(x4)), Np = jt(Lh("white-space", "pre pre-line pre-wrap")), Cb = Zt, J0 = Wr, c2 = Js.nodeIndex, ey = p4, u2 = (e) => e ? e.createRange() : Js.DOM.createRng(), d2 = (e) => G(e) && /[\r\n\t ]/.test(e), f2 = (e) => !!e.setStart && !!e.setEnd, f_ = (e) => {
      const n = e.startContainer, s = e.startOffset;
      if (d2(e.toString()) && Np(n.parentNode) && Zt(n)) {
        const l = n.data;
        if (d2(l[s - 1]) || d2(l[s + 1]))
          return !0;
      }
      return !1;
    }, Qi = (e) => {
      const n = e.ownerDocument, s = u2(n), l = n.createTextNode(Xa), d = e.parentNode;
      d.insertBefore(l, e), s.setStart(l, 0), s.setEnd(l, 1);
      const p = Dm(s.getBoundingClientRect());
      return d.removeChild(l), p;
    }, w4 = (e) => {
      const n = e.startContainer, s = e.endContainer, l = e.startOffset, d = e.endOffset;
      if (n === s && Zt(s) && l === 0 && d === 1) {
        const p = e.cloneRange();
        return p.setEndAfter(s), Mp(p);
      } else
        return null;
    }, m_ = (e) => e.left === 0 && e.right === 0 && e.top === 0 && e.bottom === 0, Mp = (e) => {
      var n;
      let s;
      const l = e.getClientRects();
      return l.length > 0 ? s = Dm(l[0]) : s = Dm(e.getBoundingClientRect()), !f2(e) && J0(e) && m_(s) ? Qi(e) : m_(s) && f2(e) && (n = w4(e)) !== null && n !== void 0 ? n : s;
    }, og = (e, n) => {
      const s = Ws(e, n);
      return s.width = 1, s.right = s.left + 1, s;
    }, m2 = (e) => {
      const n = [], s = (v) => {
        v.height !== 0 && (n.length > 0 && i_(v, n[n.length - 1]) || n.push(v));
      }, l = (v, S) => {
        const O = u2(v.ownerDocument);
        if (S < v.data.length) {
          if (X0(v.data[S]))
            return;
          if (X0(v.data[S - 1]) && (O.setStart(v, S), O.setEnd(v, S + 1), !f_(O))) {
            s(og(Mp(O), !1));
            return;
          }
        }
        S > 0 && (O.setStart(v, S - 1), O.setEnd(v, S), f_(O) || s(og(Mp(O), !1))), S < v.data.length && (O.setStart(v, S), O.setEnd(v, S + 1), f_(O) || s(og(Mp(O), !0)));
      }, d = e.container(), p = e.offset();
      if (Cb(d))
        return l(d, p), n;
      if (Q0(d))
        if (e.isAtEnd()) {
          const v = ey(d, p);
          Cb(v) && l(v, v.data.length), Gv(v) && !J0(v) && s(og(Mp(v), !1));
        } else {
          const v = ey(d, p);
          if (Cb(v) && l(v, 0), Gv(v) && e.isAtEnd())
            return s(og(Mp(v), !1)), n;
          const S = ey(e.container(), e.offset() - 1);
          Gv(S) && !J0(S) && (l2(S) || l2(v) || !Gv(v)) && s(og(Mp(S), !1)), Gv(v) && s(og(Mp(v), !0));
        }
      return n;
    }, vt = (e, n, s) => {
      const l = () => (Cb(e), n === 0), d = () => Cb(e) ? n >= e.data.length : n >= e.childNodes.length, p = () => {
        const j = u2(e.ownerDocument);
        return j.setStart(e, n), j.setEnd(e, n), j;
      }, v = () => (s || (s = m2(vt(e, n))), s), S = () => v().length > 0, O = (j) => j && e === j.container() && n === j.offset(), M = (j) => ey(e, j ? n - 1 : n);
      return {
        container: dt(e),
        offset: dt(n),
        toRange: p,
        getClientRects: v,
        isVisible: S,
        isAtStart: l,
        isAtEnd: d,
        isEqual: O,
        getNode: M
      };
    };
    vt.fromRangeStart = (e) => vt(e.startContainer, e.startOffset), vt.fromRangeEnd = (e) => vt(e.endContainer, e.endOffset), vt.after = (e) => vt(e.parentNode, c2(e) + 1), vt.before = (e) => vt(e.parentNode, c2(e)), vt.isAbove = (e, n) => ga(pn(n.getClientRects()), Oo(e.getClientRects()), Uv).getOr(!1), vt.isBelow = (e, n) => ga(Oo(n.getClientRects()), pn(e.getClientRects()), Y0).getOr(!1), vt.isAtStart = (e) => e ? e.isAtStart() : !1, vt.isAtEnd = (e) => e ? e.isAtEnd() : !1, vt.isTextPosition = (e) => e ? Zt(e.container()) : !1, vt.isElementPosition = (e) => !vt.isTextPosition(e);
    const Zf = (e, n) => {
      Zt(n) && n.data.length === 0 && e.remove(n);
    }, C4 = (e, n, s) => {
      n.insertNode(s), Zf(e, s.previousSibling), Zf(e, s.nextSibling);
    }, p_ = (e, n, s) => {
      const l = Y.from(s.firstChild), d = Y.from(s.lastChild);
      n.insertNode(s), l.each((p) => Zf(e, p.previousSibling)), d.each((p) => Zf(e, p.nextSibling));
    }, qv = (e, n, s) => {
      Qa(s) ? p_(e, n, s) : C4(e, n, s);
    }, Uu = Zt, Kv = _m, h_ = Js.nodeIndex, p2 = (e) => {
      const n = e.parentNode;
      return Kv(n) ? p2(n) : n;
    }, $l = (e) => e ? Re(e.childNodes, (n, s) => (Kv(s) && s.nodeName !== "BR" ? n = n.concat($l(s)) : n.push(s), n), []) : [], ty = (e, n) => {
      let s = e;
      for (; (s = s.previousSibling) && Uu(s); )
        n += s.data.length;
      return n;
    }, g_ = (e) => (n) => e === n, S4 = (e) => {
      let n, s;
      n = $l(p2(e)), s = Oe(n, g_(e), e), n = n.slice(0, s + 1);
      const l = Re(n, (d, p, v) => (Uu(p) && Uu(n[v - 1]) && d++, d), 0);
      return n = ta(n, du([e.nodeName])), s = Oe(n, g_(e), e), s - l;
    }, b_ = (e) => (Uu(e) ? "text()" : e.nodeName.toLowerCase()) + "[" + S4(e) + "]", k4 = (e, n, s) => {
      const l = [];
      for (let d = n.parentNode; d && d !== e; d = d.parentNode)
        l.push(d);
      return l;
    }, v_ = (e, n) => {
      let s = [], l = n.container(), d = n.offset(), p;
      if (Uu(l))
        p = ty(l, d);
      else {
        const S = l.childNodes;
        d >= S.length ? (p = "after", d = S.length - 1) : p = "before", l = S[d];
      }
      s.push(b_(l));
      let v = k4(e, l);
      return v = ta(v, jt(_m)), s = s.concat(ea(v, (S) => b_(S))), s.reverse().join("/") + "," + p;
    }, _4 = (e, n, s) => {
      let l = $l(e);
      return l = ta(l, (d, p) => !Uu(d) || !Uu(l[p - 1])), l = ta(l, du([n])), l[s];
    }, E4 = (e, n) => {
      let s = e, l = 0;
      for (; Uu(s); ) {
        const d = s.data.length;
        if (n >= l && n <= l + d) {
          e = s, n = n - l;
          break;
        }
        if (!Uu(s.nextSibling)) {
          e = s, n = d;
          break;
        }
        l += d, s = s.nextSibling;
      }
      return Uu(e) && n > e.data.length && (n = e.data.length), vt(e, n);
    }, y_ = (e, n) => {
      if (!n)
        return null;
      const s = n.split(","), l = s[0].split("/"), d = s.length > 1 ? s[1] : "before", p = Re(l, (v, S) => {
        const O = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(S);
        return O ? (O[1] === "text()" && (O[1] = "#text"), _4(v, O[1], parseInt(O[2], 10))) : null;
      }, e);
      if (!p)
        return null;
      if (!Uu(p) && p.parentNode) {
        let v;
        return d === "after" ? v = h_(p) + 1 : v = h_(p), vt(p.parentNode, v);
      }
      return E4(p, parseInt(d, 10));
    }, Sb = Vr, T4 = (e, n, s) => {
      let l = e(n.data.slice(0, s)).length;
      for (let d = n.previousSibling; d && Zt(d); d = d.previousSibling)
        l += e(d.data).length;
      return l;
    }, x_ = (e, n, s, l, d) => {
      const p = d ? l.startContainer : l.endContainer;
      let v = d ? l.startOffset : l.endOffset;
      const S = [], O = e.getRoot();
      if (Zt(p))
        S.push(s ? T4(n, p, v) : v);
      else {
        let M = 0;
        const j = p.childNodes;
        v >= j.length && j.length && (M = 1, v = Math.max(0, j.length - 1)), S.push(e.nodeIndex(j[v], s) + M);
      }
      for (let M = p; M && M !== O; M = M.parentNode)
        S.push(e.nodeIndex(M, s));
      return S;
    }, Oa = (e, n, s, l) => {
      const d = n.dom, p = x_(d, e, s, l, !0), v = n.isForward(), S = sc(l) ? { isFakeCaret: !0 } : {};
      if (n.isCollapsed())
        return {
          start: p,
          forward: v,
          ...S
        };
      {
        const O = x_(d, e, s, l, !1);
        return {
          start: p,
          end: O,
          forward: v,
          ...S
        };
      }
    }, ny = (e, n, s) => {
      let l = 0;
      return Gt.each(e.select(n), (d) => {
        if (d.getAttribute("data-mce-bogus") !== "all") {
          if (d === s)
            return !1;
          l++;
          return;
        }
      }), l;
    }, w_ = (e, n) => {
      let s = n ? e.startContainer : e.endContainer, l = n ? e.startOffset : e.endOffset;
      if (On(s) && s.nodeName === "TR") {
        const d = s.childNodes;
        s = d[Math.min(n ? l : l - 1, d.length - 1)], s && (l = n ? 0 : s.childNodes.length, n ? e.setStart(s, l) : e.setEnd(s, l));
      }
    }, C_ = (e) => (w_(e, !0), w_(e, !1), e), oy = (e, n) => {
      if (On(e) && (e = Nn(e, n), Sb(e)))
        return e;
      if (Yc(e)) {
        Zt(e) && Jh(e) && (e = e.parentNode);
        let s = e.previousSibling;
        if (Sb(s) || (s = e.nextSibling, Sb(s)))
          return s;
      }
    }, Al = (e) => oy(e.startContainer, e.startOffset) || oy(e.endContainer, e.endOffset), Ll = (e, n, s) => {
      const l = s.getNode(), d = s.getRng();
      if (l.nodeName === "IMG" || Sb(l)) {
        const v = l.nodeName;
        return {
          name: v,
          index: ny(s.dom, v, l)
        };
      }
      const p = Al(d);
      if (p) {
        const v = p.tagName;
        return {
          name: v,
          index: ny(s.dom, v, p)
        };
      }
      return Oa(e, s, n, d);
    }, S_ = (e) => {
      const n = e.getRng();
      return {
        start: v_(e.dom.getRoot(), vt.fromRangeStart(n)),
        end: v_(e.dom.getRoot(), vt.fromRangeEnd(n)),
        forward: e.isForward()
      };
    }, k_ = (e) => ({
      rng: e.getRng(),
      forward: e.isForward()
    }), h2 = (e, n, s) => {
      const l = {
        "data-mce-type": "bookmark",
        id: n,
        style: "overflow:hidden;line-height:0px"
      };
      return s ? e.create("span", l, "&#xFEFF;") : e.create("span", l);
    }, __ = (e, n) => {
      const s = e.dom;
      let l = e.getRng();
      const d = s.uniqueId(), p = e.isCollapsed(), v = e.getNode(), S = v.nodeName, O = e.isForward();
      if (S === "IMG")
        return {
          name: S,
          index: ny(s, S, v)
        };
      const M = C_(l.cloneRange());
      if (!p) {
        M.collapse(!1);
        const U = h2(s, d + "_end", n);
        qv(s, M, U);
      }
      l = C_(l), l.collapse(!0);
      const j = h2(s, d + "_start", n);
      return qv(s, l, j), e.moveToBookmark({
        id: d,
        keep: !0,
        forward: O
      }), {
        id: d,
        forward: O
      };
    }, E_ = (e, n, s = !1) => n === 2 ? Ll(Kc, s, e) : n === 3 ? S_(e) : n ? k_(e) : __(e, !1), g2 = Le(Ll, En, !0), b2 = (e) => {
      const n = (p) => p(e), s = dt(e), l = () => d, d = {
        tag: !0,
        inner: e,
        fold: (p, v) => v(e),
        isValue: mt,
        isError: tt,
        map: (p) => ac.value(p(e)),
        mapError: l,
        bind: n,
        exists: n,
        forall: n,
        getOr: s,
        or: l,
        getOrThunk: s,
        orThunk: l,
        getOrDie: s,
        each: (p) => {
          p(e);
        },
        toOptional: () => Y.some(e)
      };
      return d;
    }, ry = (e) => {
      const n = () => s, s = {
        tag: !1,
        inner: e,
        fold: (l, d) => l(e),
        isValue: tt,
        isError: mt,
        map: n,
        mapError: (l) => ac.error(l(e)),
        bind: n,
        exists: tt,
        forall: mt,
        getOr: En,
        or: En,
        getOrThunk: St,
        orThunk: St,
        getOrDie: Fn(String(e)),
        each: qe,
        toOptional: Y.none
      };
      return s;
    }, ac = {
      value: b2,
      error: ry,
      fromOption: (e, n) => e.fold(() => ry(n), b2)
    }, ss = { generate: (e) => {
      if (!Xe(e))
        throw new Error("cases must be an array");
      if (e.length === 0)
        throw new Error("there must be at least one case");
      const n = [], s = {};
      return Ue(e, (l, d) => {
        const p = Zo(l);
        if (p.length !== 1)
          throw new Error("one and only one name per case");
        const v = p[0], S = l[v];
        if (s[v] !== void 0)
          throw new Error("duplicate key detected:" + v);
        if (v === "cata")
          throw new Error("cannot have a case named cata (sorry)");
        if (!Xe(S))
          throw new Error("case arguments must be an array");
        n.push(v), s[v] = (...O) => {
          const M = O.length;
          if (M !== S.length)
            throw new Error("Wrong number of arguments to case " + v + ". Expected " + S.length + " (" + S + "), got " + M);
          return {
            fold: (...U) => {
              if (U.length !== e.length)
                throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + U.length);
              return U[d].apply(null, O);
            },
            match: (U) => {
              const Z = Zo(U);
              if (n.length !== Z.length)
                throw new Error("Wrong number of arguments to match. Expected: " + n.join(",") + `
Actual: ` + Z.join(","));
              if (!Ko(n, (we) => At(Z, we)))
                throw new Error("Not all branches were specified when using match. Specified: " + Z.join(", ") + `
Required: ` + n.join(", "));
              return U[v].apply(null, O);
            },
            log: (U) => {
              console.log(U, {
                constructors: n,
                constructor: v,
                params: O
              });
            }
          };
        };
      }), s;
    } };
    ss.generate([
      {
        bothErrors: [
          "error1",
          "error2"
        ]
      },
      {
        firstError: [
          "error1",
          "value2"
        ]
      },
      {
        secondError: [
          "value1",
          "error2"
        ]
      },
      {
        bothValues: [
          "value1",
          "value2"
        ]
      }
    ]);
    const cf = (e) => {
      const n = [], s = [];
      return Ue(e, (l) => {
        l.fold((d) => {
          n.push(d);
        }, (d) => {
          s.push(d);
        });
      }), {
        errors: n,
        values: s
      };
    }, Yv = (e) => e.type === "inline-command" || e.type === "inline-format", T_ = (e) => e.type === "block-command" || e.type === "block-format", sy = (e, n) => (e.type === "block-command" || e.type === "block-format") && e.trigger === n, ay = (e) => {
      var n;
      const s = (d) => ac.error({
        message: d,
        pattern: e
      }), l = (d, p, v) => {
        if (e.format !== void 0) {
          let S;
          if (Xe(e.format)) {
            if (!Ko(e.format, G))
              return s(d + " pattern has non-string items in the `format` array");
            S = e.format;
          } else if (G(e.format))
            S = [e.format];
          else
            return s(d + " pattern has non-string `format` parameter");
          return ac.value(p(S));
        } else return e.cmd !== void 0 ? G(e.cmd) ? ac.value(v(e.cmd, e.value)) : s(d + " pattern has non-string `cmd` parameter") : s(d + " pattern is missing both `format` and `cmd` parameters");
      };
      if (!ve(e))
        return s("Raw pattern is not an object");
      if (!G(e.start))
        return s("Raw pattern is missing `start` parameter");
      if (e.end !== void 0) {
        if (!G(e.end))
          return s("Inline pattern has non-string `end` parameter");
        if (e.start.length === 0 && e.end.length === 0)
          return s("Inline pattern has empty `start` and `end` parameters");
        let d = e.start, p = e.end;
        return p.length === 0 && (p = d, d = ""), l("Inline", (v) => ({
          type: "inline-format",
          start: d,
          end: p,
          format: v
        }), (v, S) => ({
          type: "inline-command",
          start: d,
          end: p,
          cmd: v,
          value: S
        }));
      } else {
        if (e.replacement !== void 0)
          return G(e.replacement) ? e.start.length === 0 ? s("Replacement pattern has empty `start` parameter") : ac.value({
            type: "inline-command",
            start: "",
            end: e.start,
            cmd: "mceInsertContent",
            value: e.replacement
          }) : s("Replacement pattern has non-string `replacement` parameter");
        {
          const d = (n = e.trigger) !== null && n !== void 0 ? n : "space";
          return e.start.length === 0 ? s("Block pattern has empty `start` parameter") : l("Block", (p) => ({
            type: "block-format",
            start: e.start,
            format: p[0],
            trigger: d
          }), (p, v) => ({
            type: "block-command",
            start: e.start,
            cmd: p,
            value: v,
            trigger: d
          }));
        }
      }
    }, Ip = (e) => xn(e, T_), Ji = (e) => xn(e, Yv), Fp = (e, n) => ({
      inlinePatterns: Ji(e),
      blockPatterns: Ip(e),
      dynamicPatternsLookup: n
    }), y2 = (e, n) => ({
      ...e,
      blockPatterns: xn(e.blockPatterns, (s) => sy(s, n))
    }), O_ = (e) => {
      const n = cf(en(e, ay));
      return Ue(n.errors, (s) => console.error(s.message, s.pattern)), n.values;
    }, O4 = (e) => (n) => {
      const s = e(n);
      return O_(s);
    }, kb = Yt().deviceType, x2 = kb.isTouch(), w2 = Js.DOM, C2 = (e) => {
      const n = e.indexOf("=") > 0 ? e.split(/[;,](?![^=;,]*(?:[;,]|$))/) : e.split(",");
      return Ct(n, (s, l) => {
        const d = l.split("="), p = d[0], v = d.length > 1 ? d[1] : p;
        return s[Wa(p)] = Wa(v), s;
      }, {});
    }, S2 = (e) => ae(e, RegExp), Bn = (e) => (n) => n.options.get(e), Xv = (e) => G(e) || ve(e), k2 = (e, n = "") => (s) => {
      const l = G(s);
      if (l)
        if (s.indexOf("=") !== -1) {
          const d = C2(s);
          return {
            value: Or(d, e.id).getOr(n),
            valid: l
          };
        } else
          return {
            value: s,
            valid: l
          };
      else
        return {
          valid: !1,
          message: "Must be a string."
        };
    }, _b = (e) => {
      const n = e.options.register;
      n("id", {
        processor: "string",
        default: e.id
      }), n("selector", { processor: "string" }), n("target", { processor: "object" }), n("suffix", { processor: "string" }), n("cache_suffix", { processor: "string" }), n("base_url", { processor: "string" }), n("referrer_policy", {
        processor: "string",
        default: ""
      }), n("language_load", {
        processor: "boolean",
        default: !0
      }), n("inline", {
        processor: "boolean",
        default: !1
      }), n("iframe_attrs", {
        processor: "object",
        default: {}
      }), n("doctype", {
        processor: "string",
        default: "<!DOCTYPE html>"
      }), n("document_base_url", {
        processor: "string",
        default: e.documentBaseUrl
      }), n("body_id", {
        processor: k2(e, "tinymce"),
        default: "tinymce"
      }), n("body_class", {
        processor: k2(e),
        default: ""
      }), n("content_security_policy", {
        processor: "string",
        default: ""
      }), n("br_in_pre", {
        processor: "boolean",
        default: !0
      }), n("forced_root_block", {
        processor: (s) => {
          const l = G(s) && ko(s);
          return l ? {
            value: s,
            valid: l
          } : {
            valid: !1,
            message: "Must be a non-empty string."
          };
        },
        default: "p"
      }), n("forced_root_block_attrs", {
        processor: "object",
        default: {}
      }), n("newline_behavior", {
        processor: (s) => {
          const l = At([
            "block",
            "linebreak",
            "invert",
            "default"
          ], s);
          return l ? {
            value: s,
            valid: l
          } : {
            valid: !1,
            message: "Must be one of: block, linebreak, invert or default."
          };
        },
        default: "default"
      }), n("br_newline_selector", {
        processor: "string",
        default: ".mce-toc h2,figcaption,caption"
      }), n("no_newline_selector", {
        processor: "string",
        default: ""
      }), n("keep_styles", {
        processor: "boolean",
        default: !0
      }), n("end_container_on_empty_block", {
        processor: (s) => lt(s) ? {
          valid: !0,
          value: s
        } : G(s) ? {
          valid: !0,
          value: s
        } : {
          valid: !1,
          message: "Must be boolean or a string"
        },
        default: "blockquote"
      }), n("font_size_style_values", {
        processor: "string",
        default: "xx-small,x-small,small,medium,large,x-large,xx-large"
      }), n("font_size_legacy_values", {
        processor: "string",
        default: "xx-small,small,medium,large,x-large,xx-large,300%"
      }), n("font_size_classes", {
        processor: "string",
        default: ""
      }), n("automatic_uploads", {
        processor: "boolean",
        default: !0
      }), n("images_reuse_filename", {
        processor: "boolean",
        default: !1
      }), n("images_replace_blob_uris", {
        processor: "boolean",
        default: !0
      }), n("icons", {
        processor: "string",
        default: ""
      }), n("icons_url", {
        processor: "string",
        default: ""
      }), n("images_upload_url", {
        processor: "string",
        default: ""
      }), n("images_upload_base_path", {
        processor: "string",
        default: ""
      }), n("images_upload_credentials", {
        processor: "boolean",
        default: !1
      }), n("images_upload_handler", { processor: "function" }), n("language", {
        processor: "string",
        default: "en"
      }), n("language_url", {
        processor: "string",
        default: ""
      }), n("entity_encoding", {
        processor: "string",
        default: "named"
      }), n("indent", {
        processor: "boolean",
        default: !0
      }), n("indent_before", {
        processor: "string",
        default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
      }), n("indent_after", {
        processor: "string",
        default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
      }), n("indent_use_margin", {
        processor: "boolean",
        default: !1
      }), n("indentation", {
        processor: "string",
        default: "40px"
      }), n("content_css", {
        processor: (s) => {
          const l = s === !1 || G(s) || wt(s, G);
          return l ? G(s) ? {
            value: en(s.split(","), Wa),
            valid: l
          } : Xe(s) ? {
            value: s,
            valid: l
          } : s === !1 ? {
            value: [],
            valid: l
          } : {
            value: s,
            valid: l
          } : {
            valid: !1,
            message: "Must be false, a string or an array of strings."
          };
        },
        default: ig(e) ? [] : ["default"]
      }), n("content_style", { processor: "string" }), n("content_css_cors", {
        processor: "boolean",
        default: !1
      }), n("font_css", {
        processor: (s) => {
          const l = G(s) || wt(s, G);
          return l ? {
            value: Xe(s) ? s : en(s.split(","), Wa),
            valid: l
          } : {
            valid: !1,
            message: "Must be a string or an array of strings."
          };
        },
        default: []
      }), n("inline_boundaries", {
        processor: "boolean",
        default: !0
      }), n("inline_boundaries_selector", {
        processor: "string",
        default: "a[href],code,span.mce-annotation"
      }), n("object_resizing", {
        processor: (s) => {
          const l = lt(s) || G(s);
          return l ? s === !1 || kb.isiPhone() || kb.isiPad() ? {
            value: "",
            valid: l
          } : {
            value: s === !0 ? "table,img,figure.image,div,video,iframe" : s,
            valid: l
          } : {
            valid: !1,
            message: "Must be boolean or a string"
          };
        },
        default: !x2
      }), n("resize_img_proportional", {
        processor: "boolean",
        default: !0
      }), n("event_root", { processor: "string" }), n("service_message", { processor: "string" }), n("theme", {
        processor: (s) => s === !1 || G(s) || ye(s),
        default: "silver"
      }), n("theme_url", { processor: "string" }), n("formats", { processor: "object" }), n("format_empty_lines", {
        processor: "boolean",
        default: !1
      }), n("format_noneditable_selector", {
        processor: "string",
        default: ""
      }), n("preview_styles", {
        processor: (s) => {
          const l = s === !1 || G(s);
          return l ? {
            value: s === !1 ? "" : s,
            valid: l
          } : {
            valid: !1,
            message: "Must be false or a string"
          };
        },
        default: "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow"
      }), n("custom_ui_selector", {
        processor: "string",
        default: ""
      }), n("hidden_input", {
        processor: "boolean",
        default: !0
      }), n("submit_patch", {
        processor: "boolean",
        default: !0
      }), n("encoding", { processor: "string" }), n("add_form_submit_trigger", {
        processor: "boolean",
        default: !0
      }), n("add_unload_trigger", {
        processor: "boolean",
        default: !0
      }), n("custom_undo_redo_levels", {
        processor: "number",
        default: 0
      }), n("disable_nodechange", {
        processor: "boolean",
        default: !1
      }), n("readonly", {
        processor: "boolean",
        default: !1
      }), n("editable_root", {
        processor: "boolean",
        default: !0
      }), n("plugins", {
        processor: "string[]",
        default: []
      }), n("external_plugins", { processor: "object" }), n("forced_plugins", { processor: "string[]" }), n("model", {
        processor: "string",
        default: e.hasPlugin("rtc") ? "plugin" : "dom"
      }), n("model_url", { processor: "string" }), n("block_unsupported_drop", {
        processor: "boolean",
        default: !0
      }), n("visual", {
        processor: "boolean",
        default: !0
      }), n("visual_table_class", {
        processor: "string",
        default: "mce-item-table"
      }), n("visual_anchor_class", {
        processor: "string",
        default: "mce-item-anchor"
      }), n("iframe_aria_text", {
        processor: "string",
        default: "Rich Text Area. Press ALT-0 for help."
      }), n("setup", { processor: "function" }), n("init_instance_callback", { processor: "function" }), n("url_converter", {
        processor: "function",
        default: e.convertURL
      }), n("url_converter_scope", {
        processor: "object",
        default: e
      }), n("urlconverter_callback", { processor: "function" }), n("allow_conditional_comments", {
        processor: "boolean",
        default: !1
      }), n("allow_html_data_urls", {
        processor: "boolean",
        default: !1
      }), n("allow_svg_data_urls", { processor: "boolean" }), n("allow_html_in_named_anchor", {
        processor: "boolean",
        default: !1
      }), n("allow_script_urls", {
        processor: "boolean",
        default: !1
      }), n("allow_unsafe_link_target", {
        processor: "boolean",
        default: !1
      }), n("convert_fonts_to_spans", {
        processor: "boolean",
        default: !0,
        deprecated: !0
      }), n("fix_list_elements", {
        processor: "boolean",
        default: !1
      }), n("preserve_cdata", {
        processor: "boolean",
        default: !1
      }), n("remove_trailing_brs", {
        processor: "boolean",
        default: !0
      }), n("pad_empty_with_br", {
        processor: "boolean",
        default: !1
      }), n("inline_styles", {
        processor: "boolean",
        default: !0,
        deprecated: !0
      }), n("element_format", {
        processor: "string",
        default: "html"
      }), n("entities", { processor: "string" }), n("schema", {
        processor: "string",
        default: "html5"
      }), n("convert_urls", {
        processor: "boolean",
        default: !0
      }), n("relative_urls", {
        processor: "boolean",
        default: !0
      }), n("remove_script_host", {
        processor: "boolean",
        default: !0
      }), n("custom_elements", { processor: Xv }), n("extended_valid_elements", { processor: "string" }), n("invalid_elements", { processor: "string" }), n("invalid_styles", { processor: Xv }), n("valid_children", { processor: "string" }), n("valid_classes", { processor: Xv }), n("valid_elements", { processor: "string" }), n("valid_styles", { processor: Xv }), n("verify_html", {
        processor: "boolean",
        default: !0
      }), n("auto_focus", { processor: (s) => G(s) || s === !0 }), n("browser_spellcheck", {
        processor: "boolean",
        default: !1
      }), n("protect", { processor: "array" }), n("images_file_types", {
        processor: "string",
        default: "jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp"
      }), n("deprecation_warnings", {
        processor: "boolean",
        default: !0
      }), n("a11y_advanced_options", {
        processor: "boolean",
        default: !1
      }), n("api_key", { processor: "string" }), n("license_key", { processor: "string" }), n("paste_block_drop", {
        processor: "boolean",
        default: !1
      }), n("paste_data_images", {
        processor: "boolean",
        default: !0
      }), n("paste_preprocess", { processor: "function" }), n("paste_postprocess", { processor: "function" }), n("paste_webkit_styles", {
        processor: "string",
        default: "none"
      }), n("paste_remove_styles_if_webkit", {
        processor: "boolean",
        default: !0
      }), n("paste_merge_formats", {
        processor: "boolean",
        default: !0
      }), n("smart_paste", {
        processor: "boolean",
        default: !0
      }), n("paste_as_text", {
        processor: "boolean",
        default: !1
      }), n("paste_tab_spaces", {
        processor: "number",
        default: 4
      }), n("text_patterns", {
        processor: (s) => wt(s, ve) || s === !1 ? {
          value: O_(s === !1 ? [] : s),
          valid: !0
        } : {
          valid: !1,
          message: "Must be an array of objects or false."
        },
        default: [
          {
            start: "*",
            end: "*",
            format: "italic"
          },
          {
            start: "**",
            end: "**",
            format: "bold"
          },
          {
            start: "#",
            format: "h1",
            trigger: "space"
          },
          {
            start: "##",
            format: "h2",
            trigger: "space"
          },
          {
            start: "###",
            format: "h3",
            trigger: "space"
          },
          {
            start: "####",
            format: "h4",
            trigger: "space"
          },
          {
            start: "#####",
            format: "h5",
            trigger: "space"
          },
          {
            start: "######",
            format: "h6",
            trigger: "space"
          },
          {
            start: "1.",
            cmd: "InsertOrderedList",
            trigger: "space"
          },
          {
            start: "*",
            cmd: "InsertUnorderedList",
            trigger: "space"
          },
          {
            start: "-",
            cmd: "InsertUnorderedList",
            trigger: "space"
          },
          {
            start: ">",
            cmd: "mceBlockQuote",
            trigger: "space"
          },
          {
            start: "---",
            cmd: "InsertHorizontalRule",
            trigger: "space"
          }
        ]
      }), n("text_patterns_lookup", {
        processor: (s) => ye(s) ? {
          value: O4(s),
          valid: !0
        } : {
          valid: !1,
          message: "Must be a single function"
        },
        default: (s) => []
      }), n("noneditable_class", {
        processor: "string",
        default: "mceNonEditable"
      }), n("editable_class", {
        processor: "string",
        default: "mceEditable"
      }), n("noneditable_regexp", {
        processor: (s) => wt(s, S2) ? {
          value: s,
          valid: !0
        } : S2(s) ? {
          value: [s],
          valid: !0
        } : {
          valid: !1,
          message: "Must be a RegExp or an array of RegExp."
        },
        default: []
      }), n("table_tab_navigation", {
        processor: "boolean",
        default: !0
      }), n("highlight_on_focus", {
        processor: "boolean",
        default: !0
      }), n("xss_sanitization", {
        processor: "boolean",
        default: !0
      }), n("details_initial_state", {
        processor: (s) => {
          const l = At([
            "inherited",
            "collapsed",
            "expanded"
          ], s);
          return l ? {
            value: s,
            valid: l
          } : {
            valid: !1,
            message: "Must be one of: inherited, collapsed, or expanded."
          };
        },
        default: "inherited"
      }), n("details_serialized_state", {
        processor: (s) => {
          const l = At([
            "inherited",
            "collapsed",
            "expanded"
          ], s);
          return l ? {
            value: s,
            valid: l
          } : {
            valid: !1,
            message: "Must be one of: inherited, collapsed, or expanded."
          };
        },
        default: "inherited"
      }), n("init_content_sync", {
        processor: "boolean",
        default: !1
      }), n("newdocument_content", {
        processor: "string",
        default: ""
      }), n("sandbox_iframes", {
        processor: "boolean",
        default: !0
      }), n("sandbox_iframes_exclusions", {
        processor: "string[]",
        default: [
          "youtube.com",
          "youtu.be",
          "vimeo.com",
          "player.vimeo.com",
          "dailymotion.com",
          "embed.music.apple.com",
          "open.spotify.com",
          "giphy.com",
          "dai.ly",
          "codepen.io"
        ]
      }), n("convert_unsafe_embeds", {
        processor: "boolean",
        default: !0
      }), e.on("ScriptsLoaded", () => {
        n("directionality", {
          processor: "string",
          default: Ii.isRtl() ? "rtl" : void 0
        }), n("placeholder", {
          processor: "string",
          default: w2.getAttrib(e.getElement(), "placeholder")
        });
      });
    }, kd = Bn("iframe_attrs"), A4 = Bn("doctype"), el = Bn("document_base_url"), P4 = Bn("body_id"), Bp = Bn("body_class"), _2 = Bn("content_security_policy"), A_ = Bn("br_in_pre"), Pl = Bn("forced_root_block"), $p = Bn("forced_root_block_attrs"), iy = Bn("newline_behavior"), Lp = Bn("br_newline_selector"), D4 = Bn("no_newline_selector"), R4 = Bn("keep_styles"), di = Bn("end_container_on_empty_block"), ei = Bn("automatic_uploads"), fi = Bn("images_reuse_filename"), xs = Bn("images_replace_blob_uris"), Ci = Bn("icons"), ti = Bn("icons_url"), E2 = Bn("images_upload_url"), ly = Bn("images_upload_base_path"), T2 = Bn("images_upload_credentials"), P_ = Bn("images_upload_handler"), D_ = Bn("content_css_cors"), cy = Bn("referrer_policy"), uy = Bn("language"), rg = Bn("language_url"), O2 = Bn("indent_use_margin"), Hj = Bn("indentation"), sg = Bn("content_css"), N4 = Bn("content_style"), Ac = Bn("font_css"), pF = Bn("directionality"), M4 = Bn("inline_boundaries_selector"), mu = Bn("object_resizing"), Qv = Bn("resize_img_proportional"), Jv = Bn("placeholder"), uf = Bn("event_root"), ic = Bn("service_message"), Hp = Bn("theme"), A2 = Bn("theme_url"), dy = Bn("model"), R_ = Bn("model_url"), ag = Bn("inline_boundaries"), P2 = Bn("formats"), D2 = Bn("preview_styles"), N_ = Bn("format_empty_lines"), M_ = Bn("format_noneditable_selector"), e1 = Bn("custom_ui_selector"), ig = Bn("inline"), R2 = Bn("hidden_input"), N2 = Bn("submit_patch"), I_ = Bn("add_form_submit_trigger"), F_ = Bn("add_unload_trigger"), I4 = Bn("custom_undo_redo_levels"), fy = Bn("disable_nodechange"), B_ = Bn("readonly"), F4 = Bn("editable_root"), $_ = Bn("content_css_cors"), t1 = Bn("plugins"), B4 = Bn("external_plugins"), L_ = Bn("block_unsupported_drop"), lc = Bn("visual"), M2 = Bn("visual_table_class"), I2 = Bn("visual_anchor_class"), F2 = Bn("iframe_aria_text"), my = Bn("setup"), $4 = Bn("init_instance_callback"), L4 = Bn("urlconverter_callback"), py = Bn("auto_focus"), H_ = Bn("browser_spellcheck"), B2 = Bn("protect"), $2 = Bn("paste_block_drop"), n1 = Bn("paste_data_images"), L2 = Bn("paste_preprocess"), z_ = Bn("paste_postprocess"), V_ = Bn("newdocument_content"), j_ = Bn("paste_webkit_styles"), H4 = Bn("paste_remove_styles_if_webkit"), U_ = Bn("paste_merge_formats"), W_ = Bn("smart_paste"), Z_ = Bn("paste_as_text"), hy = Bn("paste_tab_spaces"), Eb = Bn("allow_html_data_urls"), G_ = Bn("text_patterns"), z4 = Bn("text_patterns_lookup"), gy = Bn("noneditable_class"), V4 = Bn("editable_class"), _d = Bn("noneditable_regexp"), by = Bn("preserve_cdata"), vy = Bn("highlight_on_focus"), yy = Bn("xss_sanitization"), cc = Bn("init_content_sync"), zp = (e) => e.options.isSet("text_patterns_lookup"), Vp = (e) => Gt.explode(e.options.get("font_size_style_values")), j4 = (e) => Gt.explode(e.options.get("font_size_classes")), jp = (e) => e.options.get("encoding") === "xml", o1 = (e) => Gt.explode(e.options.get("images_file_types")), U4 = Bn("table_tab_navigation"), W4 = Bn("details_initial_state"), q_ = Bn("details_serialized_state"), xy = Bn("sandbox_iframes"), wy = (e) => e.options.get("sandbox_iframes_exclusions"), Z4 = Bn("convert_unsafe_embeds"), r1 = Bn("license_key"), H2 = Bn("api_key"), G4 = On, z2 = Zt, V2 = (e) => {
      const n = e.parentNode;
      n && n.removeChild(e);
    }, Cy = (e) => {
      const n = Kc(e);
      return {
        count: e.length - n.length,
        text: n
      };
    }, q4 = (e) => {
      let n;
      for (; (n = e.data.lastIndexOf(Ma)) !== -1; )
        e.deleteData(n, 1);
    }, lg = (e, n) => (Up(e), n), K_ = (e, n) => {
      const s = Cy(e.data.substr(0, n.offset())), l = Cy(e.data.substr(n.offset()));
      return (s.text + l.text).length > 0 ? (q4(e), vt(e, n.offset() - s.count)) : n;
    }, j2 = (e, n) => {
      const s = n.container(), l = zn(hr(s.childNodes), e).map((d) => d < n.offset() ? vt(s, n.offset() - 1) : n).getOr(n);
      return Up(e), l;
    }, Y_ = (e, n) => z2(e) && n.container() === e ? K_(e, n) : lg(e, n), Sy = (e, n) => n.container() === e.parentNode ? j2(e, n) : lg(e, n), K4 = (e, n) => vt.isTextPosition(n) ? Y_(e, n) : Sy(e, n), Up = (e) => {
      G4(e) && Yc(e) && (n2(e) ? e.removeAttribute("data-mce-caret") : V2(e)), z2(e) && (q4(e), e.data.length === 0 && V2(e));
    }, hF = Vr, Tb = Yi, ky = tb, Ob = "*[contentEditable=false],video,audio,embed,object", Ab = (e, n, s) => {
      const l = Ws(n.getBoundingClientRect(), s);
      let d, p;
      if (e.tagName === "BODY") {
        const S = e.ownerDocument.documentElement;
        d = e.scrollLeft || S.scrollLeft, p = e.scrollTop || S.scrollTop;
      } else {
        const S = e.getBoundingClientRect();
        d = e.scrollLeft - S.left, p = e.scrollTop - S.top;
      }
      l.left += d, l.right += d, l.top += p, l.bottom += p, l.width = 1;
      let v = n.offsetWidth - n.clientWidth;
      return v > 0 && (s && (v *= -1), l.left += v, l.right += v), l;
    }, Y4 = (e) => {
      var n, s;
      const l = ba(Me.fromDom(e), Ob);
      for (let d = 0; d < l.length; d++) {
        const p = l[d].dom;
        let v = p.previousSibling;
        if (Uf(v)) {
          const S = v.data;
          S.length === 1 ? (n = v.parentNode) === null || n === void 0 || n.removeChild(v) : v.deleteData(S.length - 1, 1);
        }
        v = p.nextSibling, tg(v) && (v.data.length === 1 ? (s = v.parentNode) === null || s === void 0 || s.removeChild(v) : v.deleteData(0, 1));
      }
    }, X_ = (e, n, s, l) => {
      const d = Mi();
      let p, v;
      const S = Pl(e), O = e.dom, M = (me, Se) => {
        let ze;
        if (j(), ky(Se))
          return null;
        if (s(Se)) {
          const Ye = u4(S, Se, me), We = Ab(n, Se, me);
          O.setStyle(Ye, "top", We.top), O.setStyle(Ye, "caret-color", "transparent"), v = Ye;
          const ut = O.create("div", {
            class: "mce-visual-caret",
            "data-mce-bogus": "all"
          });
          O.setStyles(ut, { ...We }), O.add(n, ut), d.set({
            caret: ut,
            element: Se,
            before: me
          }), me && O.addClass(ut, "mce-visual-caret-before"), U(), ze = Se.ownerDocument.createRange(), ze.setStart(Ye, 0), ze.setEnd(Ye, 0);
        } else
          return v = o2(Se, me), ze = Se.ownerDocument.createRange(), _y(v.nextSibling) ? (ze.setStart(v, 0), ze.setEnd(v, 0)) : (ze.setStart(v, 1), ze.setEnd(v, 1)), ze;
        return ze;
      }, j = () => {
        Y4(n), v && (Up(v), v = null), d.on((me) => {
          O.remove(me.caret), d.clear();
        }), p && (clearInterval(p), p = void 0);
      }, U = () => {
        p = setInterval(() => {
          d.on((me) => {
            l() ? O.toggleClass(me.caret, "mce-visual-caret-hidden") : O.addClass(me.caret, "mce-visual-caret-hidden");
          });
        }, 500);
      };
      return {
        show: M,
        hide: j,
        getCss: () => ".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}",
        reposition: () => {
          d.on((me) => {
            const Se = Ab(n, me.element, me.before);
            O.setStyles(me.caret, { ...Se });
          });
        },
        destroy: () => clearInterval(p)
      };
    }, X4 = () => rn.browser.isFirefox(), _y = (e) => hF(e) || Tb(e), Mm = (e) => (_y(e) || Fu(e) && X4()) && Bc(Me.fromDom(e)).exists(za), U2 = Rt, W2 = Vr, Q4 = Yi, Z2 = Lh("display", "block table table-cell table-caption list-item"), Q_ = Yc, J_ = Jh, eE = On, Pb = Zt, Ey = lf, cg = (e) => e > 0, Im = (e) => e < 0, s1 = (e, n) => {
      let s;
      for (; s = e(n); )
        if (!J_(s))
          return s;
      return null;
    }, Db = (e, n, s, l, d) => {
      const p = new Ri(e, l), v = W2(e) || J_(e);
      let S;
      if (Im(n)) {
        if (v && (S = s1(p.prev.bind(p), !0), s(S)))
          return S;
        for (; S = s1(p.prev.bind(p), d); )
          if (s(S))
            return S;
      }
      if (cg(n)) {
        if (v && (S = s1(p.next.bind(p), !0), s(S)))
          return S;
        for (; S = s1(p.next.bind(p), d); )
          if (s(S))
            return S;
      }
      return null;
    }, J4 = (e, n) => {
      const s = (d) => U2(d.dom), l = (d) => d.dom === n;
      return Is(Me.fromDom(e), s, l).map((d) => d.dom).getOr(n);
    }, df = (e, n) => {
      for (; e && e !== n; ) {
        if (Z2(e))
          return e;
        e = e.parentNode;
      }
      return null;
    }, pu = (e, n, s) => df(e.container(), s) === df(n.container(), s), Ty = (e, n) => {
      if (!n)
        return Y.none();
      const s = n.container(), l = n.offset();
      return eE(s) ? Y.from(s.childNodes[l + e]) : Y.none();
    }, eP = (e, n) => {
      var s;
      const d = ((s = n.ownerDocument) !== null && s !== void 0 ? s : document).createRange();
      return e ? (d.setStartBefore(n), d.setEndBefore(n)) : (d.setStartAfter(n), d.setEndAfter(n)), d;
    }, gF = (e, n, s) => df(n, e) === df(s, e), ug = (e, n, s) => {
      const l = e ? "previousSibling" : "nextSibling";
      let d = s;
      for (; d && d !== n; ) {
        let p = d[l];
        if (p && Q_(p) && (p = p[l]), W2(p) || Q4(p)) {
          if (gF(n, p, d))
            return p;
          break;
        }
        if (Ey(p))
          break;
        d = d.parentNode;
      }
      return null;
    }, Rb = Le(eP, !0), Nb = Le(eP, !1), Dl = (e, n, s) => {
      let l;
      const d = Le(ug, !0, n), p = Le(ug, !1, n), v = s.startContainer, S = s.startOffset;
      if (Jh(v)) {
        const O = Pb(v) ? v.parentNode : v, M = O.getAttribute("data-mce-caret");
        if (M === "before" && (l = O.nextSibling, Mm(l)))
          return Rb(l);
        if (M === "after" && (l = O.previousSibling, Mm(l)))
          return Nb(l);
      }
      if (!s.collapsed)
        return s;
      if (Zt(v)) {
        if (Q_(v)) {
          if (e === 1) {
            if (l = p(v), l)
              return Rb(l);
            if (l = d(v), l)
              return Nb(l);
          }
          if (e === -1) {
            if (l = d(v), l)
              return Nb(l);
            if (l = p(v), l)
              return Rb(l);
          }
          return s;
        }
        if (Uf(v) && S >= v.data.length - 1)
          return e === 1 && (l = p(v), l) ? Rb(l) : s;
        if (tg(v) && S <= 1)
          return e === -1 && (l = d(v), l) ? Nb(l) : s;
        if (S === v.data.length)
          return l = p(v), l ? Rb(l) : s;
        if (S === 0)
          return l = d(v), l ? Nb(l) : s;
      }
      return s;
    }, Oy = (e, n) => Ty(e ? 0 : -1, n).filter(W2), dg = (e, n, s) => {
      const l = Dl(e, n, s);
      return e === -1 ? vt.fromRangeStart(l) : vt.fromRangeEnd(l);
    }, Ay = (e) => Y.from(e.getNode()).map(Me.fromDom), tE = (e) => Y.from(e.getNode(!0)).map(Me.fromDom), G2 = (e, n) => {
      let s = n;
      for (; s = e(s); )
        if (s.isVisible())
          return s;
      return s;
    }, Py = (e, n) => {
      const s = pu(e, n);
      return !s && Wr(e.getNode()) ? !0 : s;
    };
    var Fi;
    (function(e) {
      e[e.Backwards = -1] = "Backwards", e[e.Forwards = 1] = "Forwards";
    })(Fi || (Fi = {}));
    const Dy = Vr, Ed = Zt, q2 = On, K2 = Wr, Fm = lf, nE = y4, Wp = i2, Ry = (e, n) => {
      const s = [];
      let l = e;
      for (; l && l !== n; )
        s.push(l), l = l.parentNode;
      return s;
    }, Ny = (e, n) => e.hasChildNodes() && n < e.childNodes.length ? e.childNodes[n] : null, Y2 = (e, n) => {
      if (cg(e)) {
        if (Fm(n.previousSibling) && !Ed(n.previousSibling))
          return vt.before(n);
        if (Ed(n))
          return vt(n, 0);
      }
      if (Im(e)) {
        if (Fm(n.nextSibling) && !Ed(n.nextSibling))
          return vt.after(n);
        if (Ed(n))
          return vt(n, n.data.length);
      }
      return Im(e) ? K2(n) ? vt.before(n) : vt.after(n) : vt.before(n);
    }, fg = (e, n) => {
      const s = n.nextSibling;
      return s && Fm(s) ? Ed(s) ? vt(s, 0) : vt.before(s) : Mb(Fi.Forwards, vt.after(n), e);
    }, Mb = (e, n, s) => {
      let l, d, p, v;
      if (!q2(s) || !n)
        return null;
      if (n.isEqual(vt.after(s)) && s.lastChild) {
        if (v = vt.after(s.lastChild), Im(e) && Fm(s.lastChild) && q2(s.lastChild))
          return K2(s.lastChild) ? vt.before(s.lastChild) : v;
      } else
        v = n;
      const S = v.container();
      let O = v.offset();
      if (Ed(S)) {
        if (Im(e) && O > 0)
          return vt(S, --O);
        if (cg(e) && O < S.length)
          return vt(S, ++O);
        l = S;
      } else {
        if (Im(e) && O > 0 && (d = Ny(S, O - 1), Fm(d)))
          return !nE(d) && (p = Db(d, e, Wp, d), p) ? Ed(p) ? vt(p, p.data.length) : vt.after(p) : Ed(d) ? vt(d, d.data.length) : vt.before(d);
        if (cg(e) && O < S.childNodes.length && (d = Ny(S, O), Fm(d)))
          return K2(d) ? fg(s, d) : !nE(d) && (p = Db(d, e, Wp, d), p) ? Ed(p) ? vt(p, 0) : vt.before(p) : Ed(d) ? vt(d, 0) : vt.after(d);
        l = d || v.getNode();
      }
      if (l && (cg(e) && v.isAtEnd() || Im(e) && v.isAtStart()) && (l = Db(l, e, mt, s, !0), Wp(l, s)))
        return Y2(e, l);
      d = l && Db(l, e, Wp, s);
      const M = ct(xn(Ry(S, s), Dy));
      return M && (!d || !M.contains(d)) ? (cg(e) ? v = vt.after(M) : v = vt.before(M), v) : d ? Y2(e, d) : null;
    }, pl = (e) => ({
      next: (n) => Mb(Fi.Forwards, n, e),
      prev: (n) => Mb(Fi.Backwards, n, e)
    }), oE = (e, n, s) => {
      const l = e ? vt.before(s) : vt.after(s);
      return hu(e, n, l);
    }, X2 = (e) => Wr(e) ? vt.before(e) : vt.after(e), Q2 = (e) => vt.isTextPosition(e) ? e.offset() === 0 : lf(e.getNode()), rE = (e) => {
      if (vt.isTextPosition(e)) {
        const n = e.container();
        return e.offset() === n.data.length;
      } else
        return lf(e.getNode(!0));
    }, J2 = (e, n) => !vt.isTextPosition(e) && !vt.isTextPosition(n) && e.getNode() === n.getNode(!0), sE = (e) => !vt.isTextPosition(e) && Wr(e.getNode()), aE = (e, n, s) => e ? !J2(n, s) && !sE(n) && rE(n) && Q2(s) : !J2(s, n) && Q2(n) && rE(s), hu = (e, n, s) => {
      const l = pl(n);
      return Y.from(e ? l.next(s) : l.prev(s));
    }, Bm = (e, n, s) => hu(e, n, s).bind((l) => pu(s, l, n) && aE(e, s, l) ? hu(e, n, l) : Y.some(l)), iE = (e, n, s, l) => Bm(e, n, s).bind((d) => l(d) ? iE(e, n, d, l) : Y.some(d)), mg = (e, n) => {
      const s = e ? n.firstChild : n.lastChild;
      return Zt(s) ? Y.some(vt(s, e ? 0 : s.data.length)) : s ? lf(s) ? Y.some(e ? vt.before(s) : X2(s)) : oE(e, n, s) : Y.none();
    }, Hl = Le(hu, !0), Xc = Le(hu, !1), zl = Le(mg, !0), gu = Le(mg, !1), My = "_mce_caret", bu = (e) => On(e) && e.id === My, pg = (e, n) => {
      let s = n;
      for (; s && s !== e; ) {
        if (bu(s))
          return s;
        s = s.parentNode;
      }
      return null;
    }, tP = (e) => G(e.start), lE = (e) => Xn(e, "rng"), nP = (e) => Xn(e, "id"), cE = (e) => Xn(e, "name"), uE = (e) => Gt.isArray(e.start), eC = (e) => !cE(e) && lt(e.forward) ? e.forward : !0, tC = (e, n) => (On(n) && e.isBlock(n) && !n.innerHTML && (n.innerHTML = '<br data-mce-bogus="1" />'), n), tl = (e, n) => {
      const s = Y.from(y_(e.getRoot(), n.start)), l = Y.from(y_(e.getRoot(), n.end));
      return ga(s, l, (d, p) => {
        const v = e.createRng();
        return v.setStart(d.container(), d.offset()), v.setEnd(p.container(), p.offset()), {
          range: v,
          forward: eC(n)
        };
      });
    }, nC = (e, n) => {
      var s;
      const d = ((s = e.ownerDocument) !== null && s !== void 0 ? s : document).createTextNode(Ma);
      e.appendChild(d), n.setStart(d, 0), n.setEnd(d, 0);
    }, Zp = (e) => !e.hasChildNodes(), Ib = (e, n) => gu(e).fold(tt, (s) => (n.setStart(s.container(), s.offset()), n.setEnd(s.container(), s.offset()), !0)), oC = (e, n, s) => Zp(n) && pg(e, n) ? (nC(n, s), !0) : !1, Iy = (e, n, s, l) => {
      const d = s[n ? "start" : "end"], p = e.getRoot();
      if (d) {
        let v = p, S = d[0];
        for (let O = d.length - 1; v && O >= 1; O--) {
          const M = v.childNodes;
          if (oC(p, v, l))
            return !0;
          if (d[O] > M.length - 1)
            return oC(p, v, l) ? !0 : Ib(v, l);
          v = M[d[O]];
        }
        Zt(v) && (S = Math.min(d[0], v.data.length)), On(v) && (S = Math.min(d[0], v.childNodes.length)), n ? l.setStart(v, S) : l.setEnd(v, S);
      }
      return !0;
    }, a1 = (e) => Zt(e) && e.data.length > 0, rC = (e, n, s) => {
      const l = e.get(s.id + "_" + n), d = l == null ? void 0 : l.parentNode, p = s.keep;
      if (l && d) {
        let v, S;
        if (n === "start" ? p ? l.hasChildNodes() ? (v = l.firstChild, S = 1) : a1(l.nextSibling) ? (v = l.nextSibling, S = 0) : a1(l.previousSibling) ? (v = l.previousSibling, S = l.previousSibling.data.length) : (v = d, S = e.nodeIndex(l) + 1) : (v = d, S = e.nodeIndex(l)) : p ? l.hasChildNodes() ? (v = l.firstChild, S = 1) : a1(l.previousSibling) ? (v = l.previousSibling, S = l.previousSibling.data.length) : (v = d, S = e.nodeIndex(l)) : (v = d, S = e.nodeIndex(l)), !p) {
          const O = l.previousSibling, M = l.nextSibling;
          Gt.each(Gt.grep(l.childNodes), (U) => {
            Zt(U) && (U.data = U.data.replace(/\uFEFF/g, ""));
          });
          let j;
          for (; j = e.get(s.id + "_" + n); )
            e.remove(j, !0);
          if (Zt(M) && Zt(O) && !rn.browser.isOpera()) {
            const U = O.data.length;
            O.appendData(M.data), e.remove(M), v = O, S = U;
          }
        }
        return Y.some(vt(v, S));
      } else
        return Y.none();
    }, Fb = (e, n) => {
      const s = e.createRng();
      return Iy(e, !0, n, s) && Iy(e, !1, n, s) ? Y.some({
        range: s,
        forward: eC(n)
      }) : Y.none();
    }, sC = (e, n) => {
      const s = rC(e, "start", n), l = rC(e, "end", n);
      return ga(s, l.or(s), (d, p) => {
        const v = e.createRng();
        return v.setStart(tC(e, d.container()), d.offset()), v.setEnd(tC(e, p.container()), p.offset()), {
          range: v,
          forward: eC(n)
        };
      });
    }, Gf = (e, n) => Y.from(e.select(n.name)[n.index]).map((s) => {
      const l = e.createRng();
      return l.selectNode(s), {
        range: l,
        forward: !0
      };
    }), hg = (e, n) => {
      const s = e.dom;
      if (n) {
        if (uE(n))
          return Fb(s, n);
        if (tP(n))
          return tl(s, n);
        if (nP(n))
          return sC(s, n);
        if (cE(n))
          return Gf(s, n);
        if (lE(n))
          return Y.some({
            range: n.rng,
            forward: eC(n)
          });
      }
      return Y.none();
    }, dE = (e, n, s) => E_(e, n, s), $m = (e, n) => {
      hg(e, n).each(({ range: s, forward: l }) => {
        e.setRng(s, l);
      });
    }, vu = (e) => On(e) && e.tagName === "SPAN" && e.getAttribute("data-mce-type") === "bookmark", qf = ((e) => (n) => e === n)(Xa), gg = (e) => e !== "" && ` \f
\r	\v`.indexOf(e) !== -1, aC = (e) => !gg(e) && !qf(e) && !Ev(e), Fy = (e) => {
      const n = [];
      if (e)
        for (let s = 0; s < e.rangeCount; s++)
          n.push(e.getRangeAt(s));
      return n;
    }, mE = (e) => nr(e, (n) => {
      const s = xb(n);
      return s ? [Me.fromDom(s)] : [];
    }), oP = (e) => Fy(e).length > 1, rP = (e) => xn(mE(e), vb), pE = (e) => ba(e, "td[data-mce-selected],th[data-mce-selected]"), Gp = (e, n) => {
      const s = pE(n);
      return s.length > 0 ? s : rP(e);
    }, Bb = (e) => Gp(Fy(e.selection.getSel()), Me.fromDom(e.getBody())), i1 = (e, n) => Ra(e, "table", n), sP = (e) => {
      const n = e.startContainer, s = e.startOffset;
      return Zt(n) ? s === 0 ? Y.some(Me.fromDom(n)) : Y.none() : Y.from(n.childNodes[s]).map(Me.fromDom);
    }, aP = (e) => {
      const n = e.endContainer, s = e.endOffset;
      return Zt(n) ? s === n.data.length ? Y.some(Me.fromDom(n)) : Y.none() : Y.from(n.childNodes[s - 1]).map(Me.fromDom);
    }, $b = (e) => Df(e).fold(dt([e]), (n) => [e].concat($b(n))), iC = (e) => Sc(e).fold(dt([e]), (n) => gr(n) === "br" ? Xl(n).map((s) => [e].concat(iC(s))).getOr([]) : [e].concat(iC(n))), By = (e, n) => ga(sP(n), aP(n), (s, l) => {
      const d = Pn($b(e), Le(zr, s)), p = Pn(iC(e), Le(zr, l));
      return d.isSome() && p.isSome();
    }).getOr(!1), lC = (e, n, s, l) => {
      const d = s, p = new Ri(s, d), v = kr(e.schema.getMoveCaretBeforeOnEnterElements(), (O, M) => !At([
        "td",
        "th",
        "table"
      ], M.toLowerCase()));
      let S = s;
      do {
        if (Zt(S) && Gt.trim(S.data).length !== 0) {
          l ? n.setStart(S, 0) : n.setEnd(S, S.data.length);
          return;
        }
        if (v[S.nodeName]) {
          l ? n.setStartBefore(S) : S.nodeName === "BR" ? n.setEndBefore(S) : n.setEndAfter(S);
          return;
        }
      } while (S = l ? p.next() : p.prev());
      d.nodeName === "BODY" && (l ? n.setStart(d, 0) : n.setEnd(d, d.childNodes.length));
    }, cC = (e) => {
      const n = e.selection.getSel();
      return je(n) && n.rangeCount > 0;
    }, Lb = (e, n) => {
      const s = Bb(e);
      s.length > 0 ? Ue(s, (l) => {
        const d = l.dom, p = e.dom.createRng();
        p.setStartBefore(d), p.setEndAfter(d), n(p, !0);
      }) : n(e.selection.getRng(), !1);
    }, uC = (e, n, s) => {
      const l = __(e, n);
      s(l), e.moveToBookmark(l);
    }, Hb = (e) => dn(e == null ? void 0 : e.nodeType), dC = (e) => On(e) && !vu(e) && !bu(e) && !_m(e), Br = (e, n) => {
      if (dC(n) && !/^(TD|TH)$/.test(n.nodeName)) {
        const s = e.getAttrib(n, "data-mce-selected"), l = parseInt(s, 10);
        return !isNaN(l) && l > 0;
      } else
        return !1;
    }, Kf = (e, n, s) => {
      const { selection: l, dom: d } = e, p = l.getNode(), v = Vr(p);
      uC(l, !0, () => {
        n();
      }), v && Vr(p) && d.isChildOf(p, e.getBody()) ? e.selection.select(p) : s(l.getStart()) && bg(d, l);
    }, bg = (e, n) => {
      var s, l;
      const d = n.getRng(), { startContainer: p, startOffset: v } = d, S = n.getNode();
      if (!Br(e, S) && On(p)) {
        const O = p.childNodes, M = e.getRoot();
        let j;
        if (v < O.length) {
          const U = O[v];
          j = new Ri(U, (s = e.getParent(U, e.isBlock)) !== null && s !== void 0 ? s : M);
        } else {
          const U = O[O.length - 1];
          j = new Ri(U, (l = e.getParent(U, e.isBlock)) !== null && l !== void 0 ? l : M), j.next(!0);
        }
        for (let U = j.current(); U; U = j.next()) {
          if (e.getContentEditable(U) === "false")
            return;
          if (Zt(U) && !mC(U)) {
            d.setStart(U, 0), n.setRng(d);
            return;
          }
        }
      }
    }, l1 = (e, n, s) => {
      if (e) {
        const l = n ? "nextSibling" : "previousSibling";
        for (e = e[l]; e; e = e[l])
          if (On(e) || !mC(e))
            return e;
      }
    }, fC = (e, n) => !!e.getTextBlockElements()[n.nodeName.toLowerCase()] || Lu(e, n), Lm = (e, n, s) => e.schema.isValidChild(n, s), mC = (e, n = !1) => {
      if (je(e) && Zt(e)) {
        const s = n ? e.data.replace(/ /g, "") : e.data;
        return zc(s);
      } else
        return !1;
    }, $y = (e) => je(e) && Zt(e) && e.length === 0, pC = (e, n) => {
      const s = "[data-mce-cef-wrappable]", l = M_(e), d = Yo(l) ? s : `${s},${l}`;
      return wl(Me.fromDom(n), d);
    }, hC = (e, n) => {
      const s = e.dom;
      return dC(n) && s.getContentEditable(n) === "false" && pC(e, n) && s.select('[contenteditable="true"]', n).length === 0;
    }, vg = (e, n) => ye(e) ? e(n) : (je(n) && (e = e.replace(/%(\w+)/g, (s, l) => n[l] || s)), e), Ly = (e, n) => (e = e || "", n = n || "", e = "" + (e.nodeName || e), n = "" + (n.nodeName || n), e.toLowerCase() === n.toLowerCase()), yg = (e, n) => {
      if (Kt(e))
        return null;
      {
        let s = String(e);
        return (n === "color" || n === "backgroundColor") && (s = nf(s)), n === "fontWeight" && e === 700 && (s = "bold"), n === "fontFamily" && (s = s.replace(/[\'\"]/g, "").replace(/,\s+/g, ",")), s;
      }
    }, Hy = (e, n, s) => {
      const l = e.getStyle(n, s);
      return yg(l, s);
    }, hE = (e, n) => {
      let s;
      return e.getParent(n, (l) => On(l) ? (s = e.getStyle(l, "text-decoration"), !!s && s !== "none") : !1), s;
    }, zb = (e, n, s) => e.getParents(n, s, e.getRoot()), zy = (e, n, s) => {
      const l = e.formatter.get(n);
      return je(l) && $n(l, s);
    }, iP = (e, n) => zy(e, n, (l) => {
      const d = (p) => ye(p) || p.length > 1 && p.charAt(0) === "%";
      return $n([
        "styles",
        "attributes"
      ], (p) => Or(l, p).exists((v) => {
        const S = Xe(v) ? v : ca(v);
        return $n(S, d);
      }));
    }), Vy = (e, n, s) => {
      const l = [
        "inline",
        "block",
        "selector",
        "attributes",
        "styles",
        "classes"
      ], d = (p) => kr(p, (v, S) => $n(l, (O) => O === S));
      return zy(e, n, (p) => {
        const v = d(p);
        return zy(e, s, (S) => {
          const O = d(S);
          return Ke(v, O);
        });
      });
    }, Hm = (e) => Ss(e, "block"), lP = (e) => Hm(e) && e.wrapper === !0, c1 = (e) => Hm(e) && e.wrapper !== !0, Wu = (e) => Ss(e, "selector"), Bi = (e) => Ss(e, "inline"), cP = (e) => Wu(e) && Bi(e) && fs(Or(e, "mixed"), !0), ff = (e) => Wu(e) && e.expand !== !1 && !Bi(e), uP = (e) => {
      const n = [];
      let s = e;
      for (; s; ) {
        if (Zt(s) && s.data !== Ma || s.childNodes.length > 1)
          return [];
        On(s) && n.push(s), s = s.firstChild;
      }
      return n;
    }, gE = (e) => uP(e).length > 0, u1 = (e) => bu(e.dom) && gE(e.dom), Vb = vu, bE = zb, vE = mC, bF = fC, vF = (e) => Wr(e) && e.getAttribute("data-mce-bogus") && !e.nextSibling, yE = (e, n) => {
      let s = n;
      for (; s; ) {
        if (On(s) && e.getContentEditable(s))
          return e.getContentEditable(s) === "false" ? s : n;
        s = s.parentNode;
      }
      return n;
    }, xE = (e, n, s, l) => {
      const d = n.data;
      if (e) {
        for (let p = s; p > 0; p--)
          if (l(d.charAt(p - 1)))
            return p;
      } else
        for (let p = s; p < d.length; p++)
          if (l(d.charAt(p)))
            return p;
      return -1;
    }, Mn = (e, n, s) => xE(e, n, s, (l) => qf(l) || gg(l)), $i = (e, n, s) => xE(e, n, s, aC), d1 = (e, n, s, l, d, p) => {
      let v;
      const S = e.getParent(s, e.isBlock) || n, O = (j, U, Z) => {
        const de = Rp(e), we = d ? de.backwards : de.forwards;
        return Y.from(we(j, U, (me, Se) => Vb(me.parentNode) ? -1 : (v = me, Z(d, me, Se)), S));
      };
      return O(s, l, Mn).bind((j) => p ? O(j.container, j.offset + (d ? -1 : 0), $i) : Y.some(j)).orThunk(() => v ? Y.some({
        container: v,
        offset: d ? 0 : v.length
      }) : Y.none());
    }, Li = (e, n, s, l, d) => {
      const p = l[d];
      Zt(l) && Yo(l.data) && p && (l = p);
      const v = bE(e, l);
      for (let S = 0; S < v.length; S++)
        for (let O = 0; O < n.length; O++) {
          const M = n[O];
          if (!(je(M.collapsed) && M.collapsed !== s.collapsed) && Wu(M) && e.is(v[S], M.selector))
            return v[S];
        }
      return l;
    }, Zu = (e, n, s, l) => {
      var d;
      let p = s;
      const v = e.getRoot(), S = n[0];
      if (Hm(S) && (p = S.wrapper ? null : e.getParent(s, S.block, v)), !p) {
        const O = (d = e.getParent(s, "LI,TD,TH,SUMMARY")) !== null && d !== void 0 ? d : v;
        p = e.getParent(Zt(s) ? s.parentNode : s, (M) => M !== v && bF(e.schema, M), O);
      }
      if (p && Hm(S) && S.wrapper && (p = bE(e, p, "ul,ol").reverse()[0] || p), !p)
        for (p = s; p && p[l] && !e.isBlock(p[l]) && (p = p[l], !Ly(p, "br")); )
          ;
      return p || s;
    }, gC = (e, n, s, l) => {
      const d = s.parentNode;
      return je(s[l]) ? !1 : d === n || Kt(d) || e.isBlock(d) ? !0 : gC(e, n, d, l);
    }, xg = (e, n, s, l, d) => {
      let p = s;
      const v = d ? "previousSibling" : "nextSibling", S = e.getRoot();
      if (Zt(s) && !vE(s) && (d ? l > 0 : l < s.data.length))
        return s;
      for (; p; ) {
        if (!n[0].block_expand && e.isBlock(p))
          return p;
        for (let O = p[v]; O; O = O[v]) {
          const M = Zt(O) && !gC(e, S, O, v);
          if (!Vb(O) && !vF(O) && !vE(O, M))
            return p;
        }
        if (p === S || p.parentNode === S) {
          s = p;
          break;
        }
        p = p.parentNode;
      }
      return s;
    }, jy = (e) => Vb(e.parentNode) || Vb(e), qp = (e, n, s, l = !1) => {
      let { startContainer: d, startOffset: p, endContainer: v, endOffset: S } = n;
      const O = s[0];
      return On(d) && d.hasChildNodes() && (d = Nn(d, p), Zt(d) && (p = 0)), On(v) && v.hasChildNodes() && (v = Nn(v, n.collapsed ? S : S - 1), Zt(v) && (S = v.data.length)), d = yE(e, d), v = yE(e, v), jy(d) && (d = Vb(d) ? d : d.parentNode, n.collapsed ? d = d.previousSibling || d : d = d.nextSibling || d, Zt(d) && (p = n.collapsed ? d.length : 0)), jy(v) && (v = Vb(v) ? v : v.parentNode, n.collapsed ? v = v.nextSibling || v : v = v.previousSibling || v, Zt(v) && (S = n.collapsed ? 0 : v.length)), n.collapsed && (d1(e, e.getRoot(), d, p, !0, l).each(({ container: U, offset: Z }) => {
        d = U, p = Z;
      }), d1(e, e.getRoot(), v, S, !1, l).each(({ container: U, offset: Z }) => {
        v = U, S = Z;
      })), (Bi(O) || O.block_expand) && ((!Bi(O) || !Zt(d) || p === 0) && (d = xg(e, s, d, p, !0)), (!Bi(O) || !Zt(v) || S === v.data.length) && (v = xg(e, s, v, S, !1))), ff(O) && (d = Li(e, s, n, d, "previousSibling"), v = Li(e, s, n, v, "nextSibling")), (Hm(O) || Wu(O)) && (d = Zu(e, s, d, "previousSibling"), v = Zu(e, s, v, "nextSibling"), Hm(O) && (e.isBlock(d) || (d = xg(e, s, d, p, !0), Zt(d) && (p = 0)), e.isBlock(v) || (v = xg(e, s, v, S, !1), Zt(v) && (S = v.data.length)))), On(d) && d.parentNode && (p = e.nodeIndex(d), d = d.parentNode), On(v) && v.parentNode && (S = e.nodeIndex(v) + 1, v = v.parentNode), {
        startContainer: d,
        startOffset: p,
        endContainer: v,
        endOffset: S
      };
    }, f1 = (e, n, s) => {
      var l;
      const d = n.startOffset, p = Nn(n.startContainer, d), v = n.endOffset, S = Nn(n.endContainer, v - 1), O = (Se) => {
        const ze = Se[0];
        Zt(ze) && ze === p && d >= ze.data.length && Se.splice(0, 1);
        const Ye = Se[Se.length - 1];
        return v === 0 && Se.length > 0 && Ye === S && Zt(Ye) && Se.splice(Se.length - 1, 1), Se;
      }, M = (Se, ze, Ye) => {
        const We = [];
        for (; Se && Se !== Ye; Se = Se[ze])
          We.push(Se);
        return We;
      }, j = (Se, ze) => e.getParent(Se, (Ye) => Ye.parentNode === ze, ze), U = (Se, ze, Ye) => {
        const We = Ye ? "nextSibling" : "previousSibling";
        for (let ut = Se, zt = ut.parentNode; ut && ut !== ze; ut = zt) {
          zt = ut.parentNode;
          const an = M(ut === Se ? ut : ut[We], We);
          an.length && (Ye || an.reverse(), s(O(an)));
        }
      };
      if (p === S)
        return s(O([p]));
      const Z = (l = e.findCommonAncestor(p, S)) !== null && l !== void 0 ? l : e.getRoot();
      if (e.isChildOf(p, S))
        return U(p, Z, !0);
      if (e.isChildOf(S, p))
        return U(S, Z);
      const de = j(p, Z) || p, we = j(S, Z) || S;
      U(p, de, !0);
      const me = M(de === p ? de : de.nextSibling, "nextSibling", we === S ? we.nextSibling : we);
      me.length && s(O(me)), U(S, we);
    }, wE = [
      'pre[class*=language-][contenteditable="false"]',
      "figure.image",
      "div[data-ephox-embed-iri]",
      "div.tiny-pageembed",
      "div.mce-toc",
      "div[data-mce-toc]"
    ], dP = (e) => pt(e) && Hv(e) === Ma, fP = (e, n, s, l) => Di(n).fold(() => "skipping", (d) => l === "br" || dP(n) ? "valid" : r4(n) ? "existing" : bu(n.dom) ? "caret" : $n(wE, (p) => wl(n, p)) ? "valid-block" : !Lm(e, s, l) || !Lm(e, gr(d), s) ? "invalid-child" : "valid"), mP = (e, n) => {
      const s = qp(e.dom, n, [{ inline: "span" }]);
      n.setStart(s.startContainer, s.startOffset), n.setEnd(s.endContainer, s.endOffset), e.selection.setRng(n);
    }, Kp = (e, n, s, l, d, p) => {
      const { uid: v = n, ...S } = s;
      fd(e, db()), ur(e, `${fb()}`, v), ur(e, `${Vf()}`, l);
      const { attributes: O = {}, classes: M = [] } = d(v, S);
      if (_a(e, O), U0(e, M), p) {
        M.length > 0 && ur(e, `${Dp()}`, M.join(","));
        const j = Zo(O);
        j.length > 0 && ur(e, `${jf()}`, j.join(","));
      }
    }, m1 = (e) => {
      lu(e, db()), oa(e, `${fb()}`), oa(e, `${Vf()}`), oa(e, `${qh()}`);
      const n = da(e, `${jf()}`).map((l) => l.split(",")).getOr([]), s = da(e, `${Dp()}`).map((l) => l.split(",")).getOr([]);
      Ue(n, (l) => oa(e, l)), dF(e, s), oa(e, `${Dp()}`), oa(e, `${jf()}`);
    }, p1 = (e, n, s, l, d) => {
      const p = Me.fromTag("span", e);
      return Kp(p, n, s, l, d, !1), p;
    }, Uy = (e, n, s, l, d, p) => {
      const v = [], S = p1(e.getDoc(), s, p, l, d), O = Mi(), M = () => {
        O.clear();
      }, j = () => O.get().getOrThunk(() => {
        const we = rf(S);
        return v.push(we), O.set(we), we;
      }), U = (we) => {
        Ue(we, Z);
      }, Z = (we) => {
        switch (fP(e, we, "span", gr(we))) {
          case "invalid-child": {
            M();
            const Se = Ya(we);
            U(Se), M();
            break;
          }
          case "valid-block": {
            M(), Kp(we, s, p, l, d, !0);
            break;
          }
          case "valid": {
            const Se = j();
            $h(we, Se);
            break;
          }
        }
      }, de = (we) => {
        const me = en(we, Me.fromDom);
        U(me);
      };
      return f1(e.dom, n, (we) => {
        M(), de(we);
      }), v;
    }, Qc = (e, n, s, l) => {
      e.undoManager.transact(() => {
        const d = e.selection, p = d.getRng(), v = Bb(e).length > 0, S = mb("mce-annotation");
        if (p.collapsed && !v && mP(e, p), d.getRng().collapsed && !v) {
          const O = p1(e.getDoc(), S, l, n, s.decorate);
          hd(O, Xa), d.getRng().insertNode(O.dom), d.select(O.dom);
        } else
          uC(d, !1, () => {
            Lb(e, (O) => {
              Uy(e, O, S, n, s.decorate, l);
            });
          });
      });
    }, Yf = (e) => {
      const n = Qw();
      V0(e, n);
      const s = Xw(e, n), l = _s("span"), d = (p) => {
        Ue(p, (v) => {
          l(v) ? Hc(v) : m1(v);
        });
      };
      return {
        register: (p, v) => {
          n.register(p, v);
        },
        annotate: (p, v) => {
          n.lookup(p).each((S) => {
            Qc(e, p, S, v);
          });
        },
        annotationChanged: (p, v) => {
          s.addListener(p, v);
        },
        remove: (p) => {
          Yh(e, Y.some(p)).each(({ elements: v }) => {
            const S = e.selection.getBookmark();
            d(v), e.selection.moveToBookmark(S);
          });
        },
        removeAll: (p) => {
          const v = e.selection.getBookmark();
          Ht(e_(e, p), (S, O) => {
            d(S);
          }), e.selection.moveToBookmark(v);
        },
        getAll: (p) => {
          const v = e_(e, p);
          return Ho(v, (S) => en(S, (O) => O.dom));
        }
      };
    }, Yp = (e) => ({
      getBookmark: Le(dE, e),
      moveToBookmark: Le($m, e)
    });
    Yp.isBookmarkNode = vu;
    const Xp = (e, n, s) => s.collapsed ? !1 : $n(s.getClientRects(), (l) => d4(l, e, n)), pP = (e, n) => e.dispatch("PreProcess", n), Wy = (e, n) => e.dispatch("PostProcess", n), Zy = (e) => {
      e.dispatch("remove");
    }, hP = (e) => {
      e.dispatch("detach");
    }, gP = (e, n) => {
      e.dispatch("SwitchMode", { mode: n });
    }, bP = (e, n, s, l, d) => {
      e.dispatch("ObjectResizeStart", {
        target: n,
        width: s,
        height: l,
        origin: d
      });
    }, vP = (e, n, s, l, d) => {
      e.dispatch("ObjectResized", {
        target: n,
        width: s,
        height: l,
        origin: d
      });
    }, CE = (e) => {
      e.dispatch("PreInit");
    }, Gy = (e) => {
      e.dispatch("PostRender");
    }, yP = (e) => {
      e.dispatch("Init");
    }, qy = (e, n) => {
      e.dispatch("PlaceholderToggle", { state: n });
    }, hl = (e, n, s) => {
      e.dispatch(n, s);
    }, Gu = (e, n, s, l) => {
      e.dispatch("FormatApply", {
        format: n,
        node: s,
        vars: l
      });
    }, yu = (e, n, s, l) => {
      e.dispatch("FormatRemove", {
        format: n,
        node: s,
        vars: l
      });
    }, Ky = (e, n) => e.dispatch("BeforeSetContent", n), Yy = (e, n) => e.dispatch("SetContent", n), SE = (e, n) => e.dispatch("BeforeGetContent", n), bC = (e, n) => e.dispatch("GetContent", n), kE = (e, n) => {
      e.dispatch("AutocompleterStart", n);
    }, vC = (e, n) => {
      e.dispatch("AutocompleterUpdate", n);
    }, _E = (e, n) => {
      e.dispatch("AutocompleterUpdateActiveRange", n);
    }, EE = (e) => {
      e.dispatch("AutocompleterEnd");
    }, xP = (e, n, s) => e.dispatch("PastePreProcess", {
      content: n,
      internal: s
    }), wP = (e, n, s) => e.dispatch("PastePostProcess", {
      node: n,
      internal: s
    }), Xy = (e, n) => e.dispatch("PastePlainTextToggle", { state: n }), yC = (e, n) => e.dispatch("EditableRootStateChange", { state: n }), Xt = {
      BACKSPACE: 8,
      DELETE: 46,
      DOWN: 40,
      ENTER: 13,
      ESC: 27,
      LEFT: 37,
      RIGHT: 39,
      SPACEBAR: 32,
      TAB: 9,
      UP: 38,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      modifierPressed: (e) => e.shiftKey || e.ctrlKey || e.altKey || Xt.metaKeyPressed(e),
      metaKeyPressed: (e) => rn.os.isMacOS() || rn.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey
    }, uc = "data-mce-selected", TE = "table,img,figure.image,hr,video,span.mce-preview-object,details", xC = Math.abs, h1 = Math.round, g1 = {
      nw: [
        0,
        0,
        -1,
        -1
      ],
      ne: [
        1,
        0,
        1,
        -1
      ],
      se: [
        1,
        1,
        1,
        1
      ],
      sw: [
        0,
        1,
        -1,
        1
      ]
    }, Qy = (e) => e.type === "longpress" || e.type.indexOf("touch") === 0, b1 = (e, n) => {
      const s = n.dom, l = n.getDoc(), d = document, p = n.getBody();
      let v, S, O, M, j, U, Z, de, we, me, Se, ze, Ye, We, ut, zt, an;
      const Dn = (An) => je(An) && (eb(An) || s.is(An, "figure.image")), Tt = (An) => Yi(An) || s.hasClass(An, "mce-preview-object"), yt = (An, mr) => {
        if (Qy(An)) {
          const _r = An.touches[0];
          return Dn(An.target) && !Xp(_r.clientX, _r.clientY, mr);
        } else
          return Dn(An.target) && !Xp(An.clientX, An.clientY, mr);
      }, Lt = (An) => {
        const mr = An.target;
        yt(An, n.selection.getRng()) && !An.isDefaultPrevented() && n.selection.select(mr);
      }, Vn = (An) => s.hasClass(An, "mce-preview-object") && je(An.firstElementChild) ? [
        An,
        An.firstElementChild
      ] : s.is(An, "figure.image") ? [An.querySelector("img")] : [An], co = (An) => {
        const mr = mu(n);
        return !mr || An.getAttribute("data-mce-resize") === "false" || An === n.getBody() ? !1 : s.hasClass(An, "mce-preview-object") && je(An.firstElementChild) ? wl(Me.fromDom(An.firstElementChild), mr) : wl(Me.fromDom(An), mr);
      }, Xo = (An, mr) => {
        if (Tt(mr))
          return An.create("img", { src: rn.transparentSrc });
        if (Fu(mr)) {
          const zi = lo(M.name, "n") ? pn : Oo, ls = mr.cloneNode(!0);
          return zi(An.select("tr", ls)).each((pi) => {
            const Nd = An.select("td,th", pi);
            An.setStyle(pi, "height", null), Ue(Nd, (um) => An.setStyle(um, "height", null));
          }), ls;
        } else
          return mr.cloneNode(!0);
      }, Sr = (An, mr, _r) => {
        if (je(_r)) {
          const zi = Vn(An);
          Ue(zi, (ls) => {
            ls.style[mr] || !n.schema.isValid(ls.nodeName.toLowerCase(), mr) ? s.setStyle(ls, mr, _r) : s.setAttrib(ls, mr, "" + _r);
          });
        }
      }, ts = (An, mr, _r) => {
        Sr(An, "width", mr), Sr(An, "height", _r);
      }, Cs = (An) => {
        let mr, _r, zi, ls, pi;
        mr = An.screenX - U, _r = An.screenY - Z, We = mr * M[2] + me, ut = _r * M[3] + Se, We = We < 5 ? 5 : We, ut = ut < 5 ? 5 : ut, (Dn(v) || Tt(v)) && Qv(n) !== !1 ? zi = !Xt.modifierPressed(An) : zi = Xt.modifierPressed(An), zi && (xC(mr) > xC(_r) ? (ut = h1(We * ze), We = h1(ut / ze)) : (We = h1(ut / ze), ut = h1(We * ze))), ts(S, We, ut), ls = M.startPos.x + mr, pi = M.startPos.y + _r, ls = ls > 0 ? ls : 0, pi = pi > 0 ? pi : 0, s.setStyles(O, {
          left: ls,
          top: pi,
          display: "block"
        }), O.innerHTML = We + " &times; " + ut, M[2] < 0 && S.clientWidth <= We && s.setStyle(S, "left", de + (me - We)), M[3] < 0 && S.clientHeight <= ut && s.setStyle(S, "top", we + (Se - ut)), mr = p.scrollWidth - zt, _r = p.scrollHeight - an, mr + _r !== 0 && s.setStyles(O, {
          left: ls - mr,
          top: pi - _r
        }), Ye || (bP(n, v, me, Se, "corner-" + M.name), Ye = !0);
      }, Pa = () => {
        const An = Ye;
        Ye = !1, An && (Sr(v, "width", We), Sr(v, "height", ut)), s.unbind(l, "mousemove", Cs), s.unbind(l, "mouseup", Pa), d !== l && (s.unbind(d, "mousemove", Cs), s.unbind(d, "mouseup", Pa)), s.remove(S), s.remove(O), s.remove(j), yl(v), An && (vP(n, v, We, ut, "corner-" + M.name), s.setAttrib(v, "style", s.getAttrib(v, "style"))), n.nodeChanged();
      }, yl = (An) => {
        Sn();
        const mr = s.getPos(An, p), _r = mr.x, zi = mr.y, ls = An.getBoundingClientRect(), pi = ls.width || ls.right - ls.left, Nd = ls.height || ls.bottom - ls.top;
        v !== An && (hn(), v = An, We = ut = 0);
        const um = n.dispatch("ObjectSelected", { target: An });
        co(An) && !um.isDefaultPrevented() ? Ht(g1, (pc, ku) => {
          const td = (Md) => {
            const uo = Vn(v)[0];
            U = Md.screenX, Z = Md.screenY, me = uo.clientWidth, Se = uo.clientHeight, ze = Se / me, M = pc, M.name = ku, M.startPos = {
              x: pi * pc[0] + _r,
              y: Nd * pc[1] + zi
            }, zt = p.scrollWidth, an = p.scrollHeight, j = s.add(p, "div", {
              class: "mce-resize-backdrop",
              "data-mce-bogus": "all"
            }), s.setStyles(j, {
              position: "fixed",
              left: "0",
              top: "0",
              width: "100%",
              height: "100%"
            }), S = Xo(s, v), s.addClass(S, "mce-clonedresizable"), s.setAttrib(S, "data-mce-bogus", "all"), S.contentEditable = "false", s.setStyles(S, {
              left: _r,
              top: zi,
              margin: 0
            }), ts(S, pi, Nd), S.removeAttribute(uc), p.appendChild(S), s.bind(l, "mousemove", Cs), s.bind(l, "mouseup", Pa), d !== l && (s.bind(d, "mousemove", Cs), s.bind(d, "mouseup", Pa)), O = s.add(p, "div", {
              class: "mce-resize-helper",
              "data-mce-bogus": "all"
            }, me + " &times; " + Se);
          };
          let _u = s.get("mceResizeHandle" + ku);
          _u && s.remove(_u), _u = s.add(p, "div", {
            id: "mceResizeHandle" + ku,
            "data-mce-bogus": "all",
            class: "mce-resizehandle",
            unselectable: !0,
            style: "cursor:" + ku + "-resize; margin:0; padding:0"
          }), s.bind(_u, "mousedown", (Md) => {
            Md.stopImmediatePropagation(), Md.preventDefault(), td(Md);
          }), pc.elm = _u, s.setStyles(_u, {
            left: pi * pc[0] + _r - _u.offsetWidth / 2,
            top: Nd * pc[1] + zi - _u.offsetHeight / 2
          });
        }) : hn(!1);
      }, bs = Lv(yl, 0), hn = (An = !0) => {
        bs.cancel(), Sn(), v && An && v.removeAttribute(uc), Ht(g1, (mr, _r) => {
          const zi = s.get("mceResizeHandle" + _r);
          zi && (s.unbind(zi), s.remove(zi));
        });
      }, ro = (An, mr) => s.isChildOf(An, mr), Ur = (An) => {
        if (Ye || n.removed || n.composing)
          return;
        const mr = An.type === "mousedown" ? An.target : e.getNode(), _r = cu(Me.fromDom(mr), TE).map((ls) => ls.dom).filter((ls) => s.isEditable(ls.parentElement) || ls.nodeName === "IMG" && s.isEditable(ls)).getOrUndefined(), zi = je(_r) ? s.getAttrib(_r, uc, "1") : "1";
        if (Ue(s.select(`img[${uc}],hr[${uc}]`), (ls) => {
          ls.removeAttribute(uc);
        }), je(_r) && ro(_r, p) && n.hasFocus()) {
          yo();
          const ls = e.getStart(!0);
          if (ro(ls, _r) && ro(e.getEnd(!0), _r)) {
            s.setAttrib(_r, uc, zi), bs.throttle(_r);
            return;
          }
        }
        hn();
      }, Sn = () => {
        Ht(g1, (An) => {
          An.elm && (s.unbind(An.elm), delete An.elm);
        });
      }, yo = () => {
        try {
          n.getDoc().execCommand("enableObjectResizing", !1, "false");
        } catch {
        }
      };
      return n.on("init", () => {
        yo(), n.on("NodeChange ResizeEditor ResizeWindow ResizeContent drop", Ur), n.on("keyup compositionend", (An) => {
          v && v.nodeName === "TABLE" && Ur(An);
        }), n.on("hide blur", hn), n.on("contextmenu longpress", Lt, !0);
      }), n.on("remove", Sn), {
        isResizable: co,
        showResizeRect: yl,
        hideResizeRect: hn,
        updateResizeRect: Ur,
        destroy: () => {
          bs.cancel(), v = S = j = null;
        }
      };
    }, OE = (e, n) => {
      n.fold((s) => {
        e.setStartBefore(s.dom);
      }, (s, l) => {
        e.setStart(s.dom, l);
      }, (s) => {
        e.setStartAfter(s.dom);
      });
    }, AE = (e, n) => {
      n.fold((s) => {
        e.setEndBefore(s.dom);
      }, (s, l) => {
        e.setEnd(s.dom, l);
      }, (s) => {
        e.setEndAfter(s.dom);
      });
    }, wC = (e, n, s) => {
      const l = e.document.createRange();
      return OE(l, n), AE(l, s), l;
    }, CC = (e, n, s, l, d) => {
      const p = e.document.createRange();
      return p.setStart(n.dom, s), p.setEnd(l.dom, d), p;
    }, zm = ss.generate([
      {
        ltr: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      },
      {
        rtl: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]), SC = (e, n, s) => n(Me.fromDom(s.startContainer), s.startOffset, Me.fromDom(s.endContainer), s.endOffset), PE = (e, n) => n.match({
      domRange: (s) => ({
        ltr: dt(s),
        rtl: Y.none
      }),
      relative: (s, l) => ({
        ltr: _t(() => wC(e, s, l)),
        rtl: _t(() => Y.some(wC(e, l, s)))
      }),
      exact: (s, l, d, p) => ({
        ltr: _t(() => CC(e, s, l, d, p)),
        rtl: _t(() => Y.some(CC(e, d, p, s, l)))
      })
    }), CP = (e, n) => {
      const s = n.ltr();
      return s.collapsed ? n.rtl().filter((d) => d.collapsed === !1).map((d) => zm.rtl(Me.fromDom(d.endContainer), d.endOffset, Me.fromDom(d.startContainer), d.startOffset)).getOrThunk(() => SC(e, zm.ltr, s)) : SC(e, zm.ltr, s);
    }, SP = (e, n) => {
      const s = PE(e, n);
      return CP(e, s);
    };
    zm.ltr, zm.rtl;
    const Pc = { create: (e, n, s, l) => ({
      start: e,
      soffset: n,
      finish: s,
      foffset: l
    }) }, Vl = (e, n, s) => {
      var l, d;
      return Y.from((d = (l = e.dom).caretPositionFromPoint) === null || d === void 0 ? void 0 : d.call(l, n, s)).bind((p) => {
        if (p.offsetNode === null)
          return Y.none();
        const v = e.dom.createRange();
        return v.setStart(p.offsetNode, p.offset), v.collapse(), Y.some(v);
      });
    }, jb = (e, n, s) => {
      var l, d;
      return Y.from((d = (l = e.dom).caretRangeFromPoint) === null || d === void 0 ? void 0 : d.call(l, n, s));
    }, yF = document.caretPositionFromPoint ? Vl : document.caretRangeFromPoint ? jb : Y.none, kP = (e, n, s) => {
      const l = Me.fromDom(e.document);
      return yF(l, n, s).map((d) => Pc.create(Me.fromDom(d.startContainer), d.startOffset, Me.fromDom(d.endContainer), d.endOffset));
    }, kC = ss.generate([
      { before: ["element"] },
      {
        on: [
          "element",
          "offset"
        ]
      },
      { after: ["element"] }
    ]), Nr = (e, n, s, l) => e.fold(n, s, l), xF = (e) => e.fold(En, En, En), RE = kC.before, NE = kC.on, wF = kC.after, Qp = {
      before: RE,
      on: NE,
      after: wF,
      cata: Nr,
      getStart: xF
    }, v1 = ss.generate([
      { domRange: ["rng"] },
      {
        relative: [
          "startSitu",
          "finishSitu"
        ]
      },
      {
        exact: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]), _P = (e) => v1.exact(e.start, e.soffset, e.finish, e.foffset), EP = (e) => e.match({
      domRange: (n) => Me.fromDom(n.startContainer),
      relative: (n, s) => Qp.getStart(n),
      exact: (n, s, l, d) => n
    }), TP = v1.domRange, Jy = v1.relative, y1 = v1.exact, ME = (e) => {
      const n = EP(e);
      return Fc(n);
    }, CF = Pc.create, Ub = {
      domRange: TP,
      relative: Jy,
      exact: y1,
      exactFromRange: _P,
      getWin: ME,
      range: CF
    }, _C = (e, n) => {
      const s = gr(e);
      return s === "input" ? Qp.after(e) : At([
        "br",
        "img"
      ], s) ? n === 0 ? Qp.before(e) : Qp.after(e) : Qp.on(e, n);
    }, SF = (e, n) => {
      const s = e.fold(Qp.before, _C, Qp.after), l = n.fold(Qp.before, _C, Qp.after);
      return Ub.relative(s, l);
    }, IE = (e, n, s, l) => {
      const d = _C(e, n), p = _C(s, l);
      return Ub.relative(d, p);
    }, OP = (e) => e.match({
      domRange: (n) => {
        const s = Me.fromDom(n.startContainer), l = Me.fromDom(n.endContainer);
        return IE(s, n.startOffset, l, n.endOffset);
      },
      relative: SF,
      exact: IE
    }), _o = (e, n) => {
      const l = document.createDocumentFragment();
      return Ue(e, (d) => {
        l.appendChild(d.dom);
      }), Me.fromDom(l);
    }, m = (e) => {
      const n = Ub.getWin(e).dom, s = (d, p, v, S) => CC(n, d, p, v, S), l = OP(e);
      return SP(n, l).match({
        ltr: s,
        rtl: s
      });
    }, b = (e, n, s) => kP(e, n, s), C = (e, n, s) => {
      const l = Fc(Me.fromDom(s));
      return b(l.dom, e, n).map((d) => {
        const p = s.createRange();
        return p.setStart(d.start.dom, d.soffset), p.setEnd(d.finish.dom, d.foffset), p;
      }).getOrUndefined();
    }, E = (e, n) => je(e) && je(n) && e.startContainer === n.startContainer && e.startOffset === n.startOffset && e.endContainer === n.endContainer && e.endOffset === n.endOffset, N = (e, n, s) => {
      let l = e;
      for (; l && l !== n; ) {
        if (s(l))
          return l;
        l = l.parentNode;
      }
      return null;
    }, z = (e, n, s) => N(e, n, s) !== null, X = (e, n, s) => z(e, n, (l) => l.nodeName === s), ue = (e, n) => Yc(e) && !z(e, n, bu), xe = (e, n, s) => {
      const l = n.parentNode;
      if (l) {
        const d = new Ri(n, e.getParent(l, e.isBlock) || e.getRoot());
        let p;
        for (; p = d[s ? "prev" : "next"](); )
          if (Wr(p))
            return !0;
      }
      return !1;
    }, Fe = (e, n) => {
      var s;
      return ((s = e.previousSibling) === null || s === void 0 ? void 0 : s.nodeName) === n;
    }, it = (e, n) => {
      let s = n;
      for (; s && s !== e; ) {
        if (Vr(s))
          return !0;
        s = s.parentNode;
      }
      return !1;
    }, qt = (e, n, s, l, d) => {
      const p = e.getRoot(), v = e.schema.getNonEmptyElements(), S = d.parentNode;
      let O, M;
      if (!S)
        return Y.none();
      const j = e.getParent(S, e.isBlock) || p;
      if (l && Wr(d) && n && e.isEmpty(j))
        return Y.some(vt(S, e.nodeIndex(d)));
      const U = new Ri(d, j);
      for (; M = U[l ? "prev" : "next"](); ) {
        if (e.getContentEditableParent(M) === "false" || ue(M, p))
          return Y.none();
        if (Zt(M) && M.data.length > 0)
          return X(M, p, "A") ? Y.none() : Y.some(vt(M, l ? M.data.length : 0));
        if (e.isBlock(M) || v[M.nodeName.toLowerCase()])
          return Y.none();
        O = M;
      }
      return ci(O) ? Y.none() : s && O ? Y.some(vt(O, 0)) : Y.none();
    }, _n = (e, n, s, l) => {
      const d = e.getRoot();
      let p, v = !1, S = s ? l.startContainer : l.endContainer, O = s ? l.startOffset : l.endOffset;
      const M = On(S) && O === S.childNodes.length, j = e.schema.getNonEmptyElements();
      let U = s;
      if (Yc(S))
        return Y.none();
      if (On(S) && O > S.childNodes.length - 1 && (U = !1), xp(S) && (S = d, O = 0), S === d) {
        if (U && (p = S.childNodes[O > 0 ? O - 1 : 0], p && (Yc(p) || j[p.nodeName] || Fu(p))))
          return Y.none();
        if (S.hasChildNodes()) {
          if (O = Math.min(!U && O > 0 ? O - 1 : O, S.childNodes.length - 1), S = S.childNodes[O], O = Zt(S) && M ? S.data.length : 0, !n && S === d.lastChild && Fu(S) || it(d, S) || Yc(S) || _c(S))
            return Y.none();
          if (S.hasChildNodes() && !Fu(S)) {
            p = S;
            const Z = new Ri(S, d);
            do {
              if (Vr(p) || Yc(p)) {
                v = !1;
                break;
              }
              if (Zt(p) && p.data.length > 0) {
                O = U ? 0 : p.data.length, S = p, v = !0;
                break;
              }
              if (j[p.nodeName.toLowerCase()] && !Va(p)) {
                O = e.nodeIndex(p), S = p.parentNode, U || O++, v = !0;
                break;
              }
            } while (p = U ? Z.next() : Z.prev());
          }
        }
      }
      return n && (Zt(S) && O === 0 && qt(e, M, n, !0, S).each((Z) => {
        S = Z.container(), O = Z.offset(), v = !0;
      }), On(S) && (p = S.childNodes[O], p || (p = S.childNodes[O - 1]), p && Wr(p) && !Fe(p, "A") && !xe(e, p, !1) && !xe(e, p, !0) && qt(e, M, n, !0, p).each((Z) => {
        S = Z.container(), O = Z.offset(), v = !0;
      }))), U && !n && Zt(S) && O === S.data.length && qt(e, M, n, !1, S).each((Z) => {
        S = Z.container(), O = Z.offset(), v = !0;
      }), v && S ? Y.some(vt(S, O)) : Y.none();
    }, bn = (e, n) => {
      const s = n.collapsed, l = n.cloneRange(), d = vt.fromRangeStart(n);
      return _n(e, s, !0, l).each((p) => {
        (!s || !vt.isAbove(d, p)) && l.setStart(p.container(), p.offset());
      }), s || _n(e, s, !1, l).each((p) => {
        l.setEnd(p.container(), p.offset());
      }), s && l.collapse(!0), E(n, l) ? Y.none() : Y.some(l);
    }, ln = (e, n) => e.splitText(n), Zn = (e) => {
      let n = e.startContainer, s = e.startOffset, l = e.endContainer, d = e.endOffset;
      if (n === l && Zt(n)) {
        if (s > 0 && s < n.data.length)
          if (l = ln(n, s), n = l.previousSibling, d > s) {
            d = d - s;
            const p = ln(l, d).previousSibling;
            n = l = p, d = p.data.length, s = 0;
          } else
            d = 0;
      } else if (Zt(n) && s > 0 && s < n.data.length && (n = ln(n, s), s = 0), Zt(l) && d > 0 && d < l.data.length) {
        const p = ln(l, d).previousSibling;
        l = p, d = p.data.length;
      }
      return {
        startContainer: n,
        startOffset: s,
        endContainer: l,
        endOffset: d
      };
    }, Ut = (e) => ({
      walk: (p, v) => f1(e, p, v),
      split: Zn,
      expand: (p, v = { type: "word" }) => {
        if (v.type === "word") {
          const S = qp(e, p, [{ inline: "span" }]), O = e.createRng();
          return O.setStart(S.startContainer, S.startOffset), O.setEnd(S.endContainer, S.endOffset), O;
        }
        return p;
      },
      normalize: (p) => bn(e, p).fold(tt, (v) => (p.setStart(v.startContainer, v.startOffset), p.setEnd(v.endContainer, v.endOffset), !0))
    });
    Ut.compareRanges = E, Ut.getCaretRangeFromPoint = C, Ut.getSelectedNode = xb, Ut.getNode = Nn;
    const Co = ((e, n) => {
      const s = (S, O) => {
        if (!dn(O) && !O.match(/^[0-9]+$/))
          throw new Error(e + ".set accepts only positive integer values. Value was " + O);
        const M = S.dom;
        qd(M) && (M.style[e] = O + "px");
      }, l = (S) => {
        const O = n(S);
        if (O <= 0 || O === null) {
          const M = fa(S, e);
          return parseFloat(M) || 0;
        }
        return O;
      }, d = l, p = (S, O) => Ct(O, (M, j) => {
        const U = fa(S, j), Z = U === void 0 ? 0 : parseInt(U, 10);
        return isNaN(Z) ? M : M + Z;
      }, 0);
      return {
        set: s,
        get: l,
        getOuter: d,
        aggregate: p,
        max: (S, O, M) => {
          const j = p(S, M);
          return O > j ? O - j : 0;
        }
      };
    })("height", (e) => {
      const n = e.dom;
      return Mu(e) ? n.getBoundingClientRect().height : n.offsetHeight;
    }), wn = (e) => Co.get(e), Xr = () => Me.fromDom(document), ws = (e, n) => e.view(n).fold(dt([]), (l) => {
      const d = e.owner(l), p = ws(e, d);
      return [l].concat(p);
    }), ps = (e, n) => {
      const s = n.owner(e);
      return ws(n, s);
    };
    var Xf = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      view: (e) => {
        var n;
        return (e.dom === document ? Y.none() : Y.from((n = e.dom.defaultView) === null || n === void 0 ? void 0 : n.frameElement)).map(Me.fromDom);
      },
      owner: (e) => Ka(e)
    });
    const Jp = (e) => {
      const n = Xr(), s = $t(n), l = ps(e, Xf), d = $e(e), p = Vt(l, (v, S) => {
        const O = $e(S);
        return {
          left: v.left + O.left,
          top: v.top + O.top
        };
      }, {
        left: 0,
        top: 0
      });
      return R(p.left + d.left + s.left, p.top + d.top + s.top);
    }, eh = (e) => gr(e) === "textarea", as = (e, n) => e.dispatch("ScrollIntoView", n).isDefaultPrevented(), dc = (e, n) => {
      e.dispatch("AfterScrollIntoView", n);
    }, fc = (e, n) => {
      const s = Ya(e);
      if (s.length === 0 || eh(e))
        return {
          element: e,
          offset: n
        };
      if (n < s.length && !eh(s[n]))
        return {
          element: s[n],
          offset: 0
        };
      {
        const l = s[s.length - 1];
        return eh(l) ? {
          element: e,
          offset: n
        } : gr(l) === "img" ? {
          element: l,
          offset: 1
        } : pt(l) ? {
          element: l,
          offset: Hv(l).length
        } : {
          element: l,
          offset: Ya(l).length
        };
      }
    }, qu = (e, n) => {
      const s = Pe(e), l = wn(e);
      return {
        element: e,
        bottom: s.top + l,
        height: l,
        pos: s,
        cleanup: n
      };
    }, Ku = (e, n) => {
      const s = fc(e, n), l = Me.fromHtml('<span data-mce-bogus="all" style="display: inline-block;">' + Ma + "</span>");
      return Ki(s.element, l), qu(l, () => ys(l));
    }, Cr = (e) => qu(Me.fromDom(e), qe), Aa = (e, n, s, l) => {
      Vo(e, (d, p) => x1(e, n, s, l), s);
    }, Qf = (e, n, s, l, d) => {
      const p = {
        elm: l.element.dom,
        alignToTop: d
      };
      if (as(e, p))
        return;
      const v = $t(n).top;
      s(e, n, v, l, d), dc(e, p);
    }, x1 = (e, n, s, l) => {
      const d = Me.fromDom(e.getBody()), p = Me.fromDom(e.getDoc());
      Na(d);
      const v = Ku(Me.fromDom(s.startContainer), s.startOffset);
      Qf(e, p, n, v, l), v.cleanup();
    }, Jc = (e, n, s, l) => {
      const d = Me.fromDom(e.getDoc());
      Qf(e, d, s, Cr(n), l);
    }, Vo = (e, n, s) => {
      const l = s.startContainer, d = s.startOffset, p = s.endContainer, v = s.endOffset;
      n(Me.fromDom(l), Me.fromDom(p));
      const S = e.dom.createRng();
      S.setStart(l, d), S.setEnd(p, v), e.selection.setRng(s);
    }, EC = (e, n, s, l, d) => {
      const p = n.pos;
      if (l)
        vo(p.left, p.top, d);
      else {
        const v = p.top - s + n.height;
        vo(-e.getBody().getBoundingClientRect().left, v, d);
      }
    }, TC = (e, n, s, l, d, p) => {
      const v = l + s, S = d.pos.top, O = d.bottom, M = O - S >= l;
      S < s ? EC(e, d, l, p !== !1, n) : S > v ? EC(e, d, l, M ? p !== !1 : p === !0, n) : O > v && !M && EC(e, d, l, p === !0, n);
    }, ex = (e, n, s, l, d) => {
      const p = Fc(n).dom.innerHeight;
      TC(e, n, s, p, l, d);
    }, FE = (e, n, s, l, d) => {
      const p = Fc(n).dom.innerHeight;
      TC(e, n, s, p, l, d);
      const v = Jp(l.element), S = Vs(window);
      v.top < S.y ? $o(l.element, d !== !1) : v.top > S.bottom && $o(l.element, d === !0);
    }, wg = (e, n, s) => Aa(e, ex, n, s), Vm = (e, n, s) => Jc(e, n, ex, s), BE = (e, n, s) => Aa(e, FE, n, s), w1 = (e, n, s) => Jc(e, n, FE, s), zj = (e, n, s) => {
      (e.inline ? Vm : w1)(e, n, s);
    }, OC = (e, n, s) => {
      (e.inline ? wg : BE)(e, n, s);
    }, tx = (e, n = !1) => e.dom.focus({ preventScroll: n }), C1 = (e) => {
      const n = Ql(e).dom;
      return e.dom === n.activeElement;
    }, AP = (e = Xr()) => Y.from(e.dom.activeElement).map(Me.fromDom), kF = (e) => AP(Ql(e)).filter((n) => e.dom.contains(n.dom)), _F = (e, n) => {
      const s = pt(n) ? Hv(n).length : Ya(n).length + 1;
      return e > s ? s : e < 0 ? 0 : e;
    }, Vj = (e) => Ub.range(e.start, _F(e.soffset, e.start), e.finish, _F(e.foffset, e.finish)), EF = (e, n) => !Mf(n.dom) && (Gi(e, n) || zr(e, n)), PP = (e) => (n) => EF(e, n.start) && EF(e, n.finish), uae = (e) => e.inline || rn.browser.isFirefox(), jj = (e) => Ub.range(Me.fromDom(e.startContainer), e.startOffset, Me.fromDom(e.endContainer), e.endOffset), TF = (e) => {
      const n = e.getSelection();
      return (!n || n.rangeCount === 0 ? Y.none() : Y.from(n.getRangeAt(0))).map(jj);
    }, DP = (e) => {
      const n = Fc(e);
      return TF(n.dom).filter(PP(e));
    }, RP = (e, n) => Y.from(n).filter(PP(e)).map(Vj), NP = (e) => {
      const n = document.createRange();
      try {
        return n.setStart(e.start.dom, e.soffset), n.setEnd(e.finish.dom, e.foffset), Y.some(n);
      } catch {
        return Y.none();
      }
    }, AC = (e) => {
      const n = uae(e) ? DP(Me.fromDom(e.getBody())) : Y.none();
      e.bookmark = n.isSome() ? n : e.bookmark;
    }, $E = (e) => (e.bookmark ? e.bookmark : Y.none()).bind((s) => RP(Me.fromDom(e.getBody()), s)).bind(NP), OF = (e) => {
      $E(e).each((n) => e.selection.setRng(n));
    }, AF = { isEditorUIElement: (e) => {
      const n = e.className.toString();
      return n.indexOf("tox-") !== -1 || n.indexOf("mce-") !== -1;
    } }, PF = (e, n) => (dn(n) || (n = 0), setTimeout(e, n)), Uj = (e, n) => (dn(n) || (n = 0), setInterval(e, n)), Td = {
      setEditorTimeout: (e, n, s) => PF(() => {
        e.removed || n();
      }, s),
      setEditorInterval: (e, n, s) => {
        const l = Uj(() => {
          e.removed ? clearInterval(l) : n();
        }, s);
        return l;
      }
    }, DF = (e) => e.type === "nodechange" && e.selectionChange, RF = (e, n) => {
      const s = () => {
        n.throttle();
      };
      Js.DOM.bind(document, "mouseup", s), e.on("remove", () => {
        Js.DOM.unbind(document, "mouseup", s);
      });
    }, NF = (e, n) => {
      e.on("mouseup touchend", (s) => {
        n.throttle();
      });
    }, MF = (e, n) => {
      NF(e, n), e.on("keyup NodeChange AfterSetSelectionRange", (s) => {
        DF(s) || AC(e);
      });
    }, Wj = (e) => {
      const n = Lv(() => {
        AC(e);
      }, 0);
      e.on("init", () => {
        e.inline && RF(e, n), MF(e, n);
      }), e.on("remove", () => {
        n.cancel();
      });
    };
    let nx;
    const IP = Js.DOM, Zj = (e) => On(e) && AF.isEditorUIElement(e), FP = (e) => {
      const n = e.classList;
      return n !== void 0 ? n.contains("tox-edit-area") || n.contains("tox-edit-area__iframe") || n.contains("mce-content-body") : !1;
    }, LE = (e, n) => {
      const s = e1(e);
      return IP.getParent(n, (d) => Zj(d) || (s ? e.dom.is(d, s) : !1)) !== null;
    }, BP = (e) => {
      try {
        const n = Ql(Me.fromDom(e.getElement()));
        return AP(n).fold(() => document.body, (s) => s.dom);
      } catch {
        return document.body;
      }
    }, Gj = (e, n) => {
      const s = n.editor;
      Wj(s);
      const l = (d, p) => {
        if (vy(d) && d.inline !== !0) {
          const v = Me.fromDom(d.getContainer());
          p(v, "tox-edit-focus");
        }
      };
      s.on("focusin", () => {
        const d = e.focusedEditor;
        FP(BP(s)) && l(s, fd), d !== s && (d && d.dispatch("blur", { focusedEditor: s }), e.setActive(s), e.focusedEditor = s, s.dispatch("focus", { blurredEditor: d }), s.focus(!0));
      }), s.on("focusout", () => {
        Td.setEditorTimeout(s, () => {
          const d = e.focusedEditor;
          (!FP(BP(s)) || d !== s) && l(s, lu), !LE(s, BP(s)) && d === s && (s.dispatch("blur", { focusedEditor: null }), e.focusedEditor = null);
        });
      }), nx || (nx = (d) => {
        const p = e.activeEditor;
        p && mp(d).each((v) => {
          const S = v;
          S.ownerDocument === document && S !== document.body && !LE(p, S) && e.focusedEditor === p && (p.dispatch("blur", { focusedEditor: null }), e.focusedEditor = null);
        });
      }, IP.bind(document, "focusin", nx));
    }, HE = (e, n) => {
      e.focusedEditor === n.editor && (e.focusedEditor = null), !e.activeEditor && nx && (IP.unbind(document, "focusin", nx), nx = null);
    }, IF = (e) => {
      e.on("AddEditor", Le(Gj, e)), e.on("RemoveEditor", Le(HE, e));
    }, qj = (e, n) => e.dom.getParent(n, (s) => e.dom.getContentEditable(s) === "true"), FF = (e) => e.collapsed ? Y.from(Nn(e.startContainer, e.startOffset)).map(Me.fromDom) : Y.none(), BF = (e, n) => FF(n).bind((s) => bb(s) ? Y.some(s) : Gi(e, s) ? Y.none() : Y.some(e)), $F = (e, n) => {
      BF(Me.fromDom(e.getBody()), n).bind((s) => zl(s.dom)).fold(() => {
        e.selection.normalize();
      }, (s) => e.selection.setRng(s.toRange()));
    }, $P = (e) => {
      if (e.setActive)
        try {
          e.setActive();
        } catch {
          e.focus();
        }
      else
        e.focus();
    }, Kj = (e) => C1(e) || kF(e).isSome(), Yj = (e) => je(e.iframeElement) && C1(Me.fromDom(e.iframeElement)), Xj = (e) => {
      const n = e.getBody();
      return n && Kj(Me.fromDom(n));
    }, LF = (e) => {
      const n = Ql(Me.fromDom(e.getElement()));
      return AP(n).filter((s) => !FP(s.dom) && LE(e, s.dom)).isSome();
    }, S1 = (e) => e.inline ? Xj(e) : Yj(e), PC = (e) => S1(e) || LF(e), Qj = (e) => {
      const n = e.selection, s = e.getBody();
      let l = n.getRng();
      e.quirks.refreshContentEditable();
      const d = (v) => {
        $E(v).each((S) => {
          v.selection.setRng(S), l = S;
        });
      };
      !S1(e) && e.hasEditableRoot() && d(e);
      const p = qj(e, n.getNode());
      if (p && e.dom.isChildOf(p, s)) {
        $P(p), e.hasEditableRoot() || d(e), $F(e, l), LP(e);
        return;
      }
      e.inline || (rn.browser.isOpera() || $P(s), e.getWin().focus()), (rn.browser.isFirefox() || e.inline) && ($P(s), $F(e, l)), LP(e);
    }, LP = (e) => e.editorManager.setActive(e), HP = (e, n) => {
      e.removed || (n ? LP(e) : Qj(e));
    }, HF = (e, n) => n.collapsed ? e.isEditable(n.startContainer) : e.isEditable(n.startContainer) && e.isEditable(n.endContainer), zP = (e, n, s, l, d) => {
      const p = s ? n.startContainer : n.endContainer, v = s ? n.startOffset : n.endOffset;
      return Y.from(p).map(Me.fromDom).map((S) => !l || !n.collapsed ? md(S, d(S, v)).getOr(S) : S).bind((S) => rt(S) ? Y.some(S) : Di(S).filter(rt)).map((S) => S.dom).getOr(e);
    }, VP = (e, n, s = !1) => zP(e, n, !0, s, (l, d) => Math.min(wi(l), d)), jP = (e, n, s = !1) => zP(e, n, !1, s, (l, d) => d > 0 ? d - 1 : d), zF = (e, n) => {
      const s = e;
      for (; e && Zt(e) && e.length === 0; )
        e = n ? e.nextSibling : e.previousSibling;
      return e || s;
    }, Jj = (e, n) => {
      if (!n)
        return e;
      let s = n.startContainer, l = n.endContainer;
      const d = n.startOffset, p = n.endOffset;
      let v = n.commonAncestorContainer;
      n.collapsed || (s === l && p - d < 2 && s.hasChildNodes() && (v = s.childNodes[d]), Zt(s) && Zt(l) && (s.length === d ? s = zF(s.nextSibling, !0) : s = s.parentNode, p === 0 ? l = zF(l.previousSibling, !1) : l = l.parentNode, s && s === l && (v = s)));
      const S = Zt(v) ? v.parentNode : v;
      return kc(S) ? S : e;
    }, eU = (e, n, s, l) => {
      const d = [], p = e.getRoot(), v = e.getParent(s || VP(p, n, n.collapsed), e.isBlock), S = e.getParent(l || jP(p, n, n.collapsed), e.isBlock);
      if (v && v !== p && d.push(v), v && S && v !== S) {
        let O;
        const M = new Ri(v, p);
        for (; (O = M.next()) && O !== S; )
          e.isBlock(O) && d.push(O);
      }
      return S && v !== S && S !== p && d.push(S), d;
    }, tU = (e, n, s) => Y.from(n).bind((l) => Y.from(l.parentNode).map((d) => {
      const p = e.nodeIndex(l), v = e.createRng();
      return v.setStart(d, p), v.setEnd(d, p + 1), s && (lC(e, v, l, !0), lC(e, v, l, !1)), v;
    })), ox = (e, n) => en(n, (s) => {
      const l = e.dispatch("GetSelectionRange", { range: s });
      return l.range !== s ? l.range : s;
    }), VF = {
      "#text": 3,
      "#comment": 8,
      "#cdata": 4,
      "#pi": 7,
      "#doctype": 10,
      "#document-fragment": 11
    }, DC = (e, n, s) => {
      const l = s ? "lastChild" : "firstChild", d = s ? "prev" : "next";
      if (e[l])
        return e[l];
      if (e !== n) {
        let p = e[d];
        if (p)
          return p;
        for (let v = e.parent; v && v !== n; v = v.parent)
          if (p = v[d], p)
            return p;
      }
    }, jF = (e) => {
      var n;
      const s = (n = e.value) !== null && n !== void 0 ? n : "";
      if (!zc(s))
        return !1;
      const l = e.parent;
      return !(l && (l.name !== "span" || l.attr("style")) && /^[ ]+$/.test(s));
    }, UP = (e) => {
      const n = e.name === "a" && !e.attr("href") && e.attr("id");
      return e.attr("name") || e.attr("id") && !e.firstChild || e.attr("data-mce-bookmark") || n;
    };
    class eu {
      static create(n, s) {
        const l = new eu(n, VF[n] || 1);
        return s && Ht(s, (d, p) => {
          l.attr(p, d);
        }), l;
      }
      constructor(n, s) {
        this.name = n, this.type = s, s === 1 && (this.attributes = [], this.attributes.map = {});
      }
      replace(n) {
        const s = this;
        return n.parent && n.remove(), s.insert(n, s), s.remove(), s;
      }
      attr(n, s) {
        const l = this;
        if (!G(n))
          return je(n) && Ht(n, (p, v) => {
            l.attr(v, p);
          }), l;
        const d = l.attributes;
        if (d) {
          if (s !== void 0) {
            if (s === null) {
              if (n in d.map) {
                delete d.map[n];
                let p = d.length;
                for (; p--; )
                  if (d[p].name === n)
                    return d.splice(p, 1), l;
              }
              return l;
            }
            if (n in d.map) {
              let p = d.length;
              for (; p--; )
                if (d[p].name === n) {
                  d[p].value = s;
                  break;
                }
            } else
              d.push({
                name: n,
                value: s
              });
            return d.map[n] = s, l;
          }
          return d.map[n];
        }
      }
      clone() {
        const n = this, s = new eu(n.name, n.type), l = n.attributes;
        if (l) {
          const d = [];
          d.map = {};
          for (let p = 0, v = l.length; p < v; p++) {
            const S = l[p];
            S.name !== "id" && (d[d.length] = {
              name: S.name,
              value: S.value
            }, d.map[S.name] = S.value);
          }
          s.attributes = d;
        }
        return s.value = n.value, s;
      }
      wrap(n) {
        const s = this;
        return s.parent && (s.parent.insert(n, s), n.append(s)), s;
      }
      unwrap() {
        const n = this;
        for (let s = n.firstChild; s; ) {
          const l = s.next;
          n.insert(s, n, !0), s = l;
        }
        n.remove();
      }
      remove() {
        const n = this, s = n.parent, l = n.next, d = n.prev;
        return s && (s.firstChild === n ? (s.firstChild = l, l && (l.prev = null)) : d && (d.next = l), s.lastChild === n ? (s.lastChild = d, d && (d.next = null)) : l && (l.prev = d), n.parent = n.next = n.prev = null), n;
      }
      append(n) {
        const s = this;
        n.parent && n.remove();
        const l = s.lastChild;
        return l ? (l.next = n, n.prev = l, s.lastChild = n) : s.lastChild = s.firstChild = n, n.parent = s, n;
      }
      insert(n, s, l) {
        n.parent && n.remove();
        const d = s.parent || this;
        return l ? (s === d.firstChild ? d.firstChild = n : s.prev && (s.prev.next = n), n.prev = s.prev, n.next = s, s.prev = n) : (s === d.lastChild ? d.lastChild = n : s.next && (s.next.prev = n), n.next = s.next, n.prev = s, s.next = n), n.parent = d, n;
      }
      getAll(n) {
        const s = this, l = [];
        for (let d = s.firstChild; d; d = DC(d, s))
          d.name === n && l.push(d);
        return l;
      }
      children() {
        const n = this, s = [];
        for (let l = n.firstChild; l; l = l.next)
          s.push(l);
        return s;
      }
      empty() {
        const n = this;
        if (n.firstChild) {
          const s = [];
          for (let d = n.firstChild; d; d = DC(d, n))
            s.push(d);
          let l = s.length;
          for (; l--; ) {
            const d = s[l];
            d.parent = d.firstChild = d.lastChild = d.next = d.prev = null;
          }
        }
        return n.firstChild = n.lastChild = null, n;
      }
      isEmpty(n, s = {}, l) {
        var d;
        const p = this;
        let v = p.firstChild;
        if (UP(p))
          return !1;
        if (v)
          do {
            if (v.type === 1) {
              if (v.attr("data-mce-bogus"))
                continue;
              if (n[v.name] || UP(v))
                return !1;
            }
            if (v.type === 8 || v.type === 3 && !jF(v) || v.type === 3 && v.parent && s[v.parent.name] && zc((d = v.value) !== null && d !== void 0 ? d : "") || l && l(v))
              return !1;
          } while (v = DC(v, p));
        return !0;
      }
      walk(n) {
        return DC(this, null, n);
      }
    }
    const nU = Gt.makeMap("NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT", " "), UF = (e) => G(e.nodeValue) && e.nodeValue.includes(Ma), WF = (e) => `${e.length === 0 ? "" : `${en(e, (n) => `[${n}]`).join(",")},`}[data-mce-bogus="all"]`, oU = (e, n) => n.querySelectorAll(WF(e)), ZF = (e) => document.createTreeWalker(e, NodeFilter.SHOW_COMMENT, (n) => UF(n) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP), GF = (e) => document.createTreeWalker(e, NodeFilter.SHOW_TEXT, (n) => {
      if (UF(n)) {
        const s = n.parentNode;
        return s && Xn(nU, s.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      } else
        return NodeFilter.FILTER_SKIP;
    }), rU = (e) => ZF(e).nextNode() !== null, sU = (e) => GF(e).nextNode() !== null, aU = (e, n) => n.querySelector(WF(e)) !== null, iU = (e, n) => {
      Ue(oU(e, n), (s) => {
        const l = Me.fromDom(s);
        Ms(l, "data-mce-bogus") === "all" ? ys(l) : Ue(e, (d) => {
          sa(l, d) && oa(l, d);
        });
      });
    }, qF = (e) => {
      let n = e.nextNode();
      for (; n !== null; )
        n.nodeValue = null, n = e.nextNode();
    }, zE = B(qF, ZF), KF = B(qF, GF), WP = (e, n) => {
      const s = [
        {
          condition: Le(aU, n),
          action: Le(iU, n)
        },
        {
          condition: rU,
          action: zE
        },
        {
          condition: sU,
          action: KF
        }
      ];
      let l = e, d = !1;
      return Ue(s, ({ condition: p, action: v }) => {
        p(l) && (d || (l = e.cloneNode(!0), d = !0), v(l));
      }), l;
    }, YF = (e) => {
      const n = ba(e, "[data-mce-bogus]");
      Ue(n, (s) => {
        Ms(s, "data-mce-bogus") === "all" ? ys(s) : gb(s) ? (Ki(s, Me.fromText(Jg)), ys(s)) : Hc(s);
      });
    }, XF = (e) => {
      const n = ba(e, "input");
      Ue(n, (s) => {
        oa(s, "name");
      });
    }, lU = (e, n) => {
      const s = Pl(e), l = new RegExp(`^(<${s}[^>]*>(&nbsp;|&#160;|\\s||<br \\/>|)<\\/${s}>[\r
]*|<br \\/>[\r
]*)$`);
      return n.replace(l, "");
    }, cU = (e, n) => {
      const s = e.getDoc(), l = Ql(Me.fromDom(e.getBody())), d = Me.fromTag("div", s);
      ur(d, "data-mce-bogus", "all"), zo(d, {
        position: "fixed",
        left: "-9999999px",
        top: "0"
      }), hd(d, n.innerHTML), YF(d), XF(d);
      const p = Gg(l);
      Ys(p, d);
      const v = Kc(d.dom.innerText);
      return ys(d), v;
    }, uU = (e, n, s) => {
      let l;
      return n.format === "raw" ? l = Gt.trim(Kc(WP(s, e.serializer.getTempAttrs()).innerHTML)) : n.format === "text" ? l = cU(e, s) : n.format === "tree" ? l = e.serializer.serialize(s, n) : l = lU(e, e.serializer.serialize(s, n)), n.format !== "text" && !Vv(Me.fromDom(s)) && G(l) ? Gt.trim(l) : l;
    }, dU = (e, n) => Y.from(e.getBody()).fold(dt(n.format === "tree" ? new eu("body", 11) : ""), (s) => uU(e, n, s)), ZP = Gt.makeMap, QF = (e) => {
      const n = [];
      e = e || {};
      const s = e.indent, l = ZP(e.indent_before || ""), d = ZP(e.indent_after || ""), p = ef.getEncodeFunc(e.entity_encoding || "raw", e.entities), v = e.element_format !== "xhtml";
      return {
        start: (S, O, M) => {
          if (s && l[S] && n.length > 0) {
            const j = n[n.length - 1];
            j.length > 0 && j !== `
` && n.push(`
`);
          }
          if (n.push("<", S), O)
            for (let j = 0, U = O.length; j < U; j++) {
              const Z = O[j];
              n.push(" ", Z.name, '="', p(Z.value, !0), '"');
            }
          if (!M || v ? n[n.length] = ">" : n[n.length] = " />", M && s && d[S] && n.length > 0) {
            const j = n[n.length - 1];
            j.length > 0 && j !== `
` && n.push(`
`);
          }
        },
        end: (S) => {
          let O;
          n.push("</", S, ">"), s && d[S] && n.length > 0 && (O = n[n.length - 1], O.length > 0 && O !== `
` && n.push(`
`));
        },
        text: (S, O) => {
          S.length > 0 && (n[n.length] = O ? S : p(S));
        },
        cdata: (S) => {
          n.push("<![CDATA[", S, "]]>");
        },
        comment: (S) => {
          n.push("<!--", S, "-->");
        },
        pi: (S, O) => {
          O ? n.push("<?", S, " ", p(O), "?>") : n.push("<?", S, "?>"), s && n.push(`
`);
        },
        doctype: (S) => {
          n.push("<!DOCTYPE", S, ">", s ? `
` : "");
        },
        reset: () => {
          n.length = 0;
        },
        getContent: () => n.join("").replace(/\n$/, "")
      };
    }, Cg = (e = {}, n = Hf()) => {
      const s = QF(e);
      return e.validate = "validate" in e ? e.validate : !0, { serialize: (d) => {
        const p = e.validate, v = {
          3: (O) => {
            var M;
            s.text((M = O.value) !== null && M !== void 0 ? M : "", O.raw);
          },
          8: (O) => {
            var M;
            s.comment((M = O.value) !== null && M !== void 0 ? M : "");
          },
          7: (O) => {
            s.pi(O.name, O.value);
          },
          10: (O) => {
            var M;
            s.doctype((M = O.value) !== null && M !== void 0 ? M : "");
          },
          4: (O) => {
            var M;
            s.cdata((M = O.value) !== null && M !== void 0 ? M : "");
          },
          11: (O) => {
            let M = O;
            if (M = M.firstChild)
              do
                S(M);
              while (M = M.next);
          }
        };
        s.reset();
        const S = (O) => {
          var M;
          const j = v[O.type];
          if (j)
            j(O);
          else {
            const U = O.name, Z = U in n.getVoidElements();
            let de = O.attributes;
            if (p && de && de.length > 1) {
              const we = [];
              we.map = {};
              const me = n.getElementRule(O.name);
              if (me) {
                for (let Se = 0, ze = me.attributesOrder.length; Se < ze; Se++) {
                  const Ye = me.attributesOrder[Se];
                  if (Ye in de.map) {
                    const We = de.map[Ye];
                    we.map[Ye] = We, we.push({
                      name: Ye,
                      value: We
                    });
                  }
                }
                for (let Se = 0, ze = de.length; Se < ze; Se++) {
                  const Ye = de[Se].name;
                  if (!(Ye in we.map)) {
                    const We = de.map[Ye];
                    we.map[Ye] = We, we.push({
                      name: Ye,
                      value: We
                    });
                  }
                }
                de = we;
              }
            }
            if (s.start(U, de, Z), Ea(U))
              G(O.value) && s.text(O.value, !0), s.end(U);
            else if (!Z) {
              let we = O.firstChild;
              if (we) {
                (U === "pre" || U === "textarea") && we.type === 3 && ((M = we.value) === null || M === void 0 ? void 0 : M[0]) === `
` && s.text(`
`, !0);
                do
                  S(we);
                while (we = we.next);
              }
              s.end(U);
            }
          }
        };
        return d.type === 1 && !e.inner ? S(d) : d.type === 3 ? v[3](d) : v[11](d), s.getContent();
      } };
    }, GP = /* @__PURE__ */ new Set();
    Ue([
      "margin",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-bottom",
      "padding",
      "padding-left",
      "padding-right",
      "padding-top",
      "padding-bottom",
      "border",
      "border-width",
      "border-style",
      "border-color",
      "background",
      "background-attachment",
      "background-clip",
      "background-image",
      "background-origin",
      "background-position",
      "background-repeat",
      "background-size",
      "float",
      "position",
      "left",
      "right",
      "top",
      "bottom",
      "z-index",
      "display",
      "transform",
      "width",
      "max-width",
      "min-width",
      "height",
      "max-height",
      "min-height",
      "overflow",
      "overflow-x",
      "overflow-y",
      "text-overflow",
      "vertical-align",
      "transition",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function"
    ], (n) => {
      GP.add(n);
    });
    const JF = /* @__PURE__ */ new Set();
    Ue(["background-color"], (n) => {
      JF.add(n);
    });
    const eB = [
      "font",
      "text-decoration",
      "text-emphasis"
    ], fU = (e, n) => e.parseStyle(e.getAttrib(n, "style")), rx = (e, n) => Zo(fU(e, n)), mU = (e) => GP.has(e), pU = (e) => JF.has(e), tB = (e, n) => $n(rx(e, n), (s) => mU(s)), hU = (e, n) => tB(e, n) && $n(rx(e, n), (s) => pU(s)), gU = (e) => xn(e, (n) => $n(eB, (s) => lo(n, s))), bU = (e, n, s) => {
      const l = rx(e, n), d = rx(e, s), p = (v) => {
        var S, O;
        const M = (S = e.getStyle(n, v)) !== null && S !== void 0 ? S : "", j = (O = e.getStyle(s, v)) !== null && O !== void 0 ? O : "";
        return ko(M) && ko(j) && M !== j;
      };
      return $n(l, (v) => {
        const S = (O) => $n(O, (M) => M === v);
        if (!S(d) && S(eB)) {
          const O = gU(d);
          return $n(O, p);
        } else
          return p(v);
      });
    }, nB = (e, n, s) => Y.from(s.container()).filter(Zt).exists((l) => {
      const d = e ? 0 : -1;
      return n(l.data.charAt(s.offset() + d));
    }), qP = Le(nB, !0, gg), KP = Le(nB, !1, gg), vU = (e) => {
      const n = e.container();
      return Zt(n) && (n.data.length === 0 || Qh(n.data) && Yp.isBookmarkNode(n.parentNode));
    }, Wb = (e, n) => (s) => Ty(e ? 0 : -1, s).filter(n).isSome(), oB = (e) => eb(e) && fa(Me.fromDom(e), "display") === "block", rB = (e) => Vr(e) && !Hh(e), yU = Wb(!0, oB), xU = Wb(!1, oB), oo = Wb(!0, Yi), sx = Wb(!1, Yi), YP = Wb(!0, Fu), XP = Wb(!1, Fu), th = Wb(!0, rB), Zb = Wb(!1, rB), wU = (e) => e.slice(0, -1), CU = (e, n, s) => Gi(n, e) ? wU(Nh(e, (l) => s(l) || zr(l, n))) : [], sB = (e, n) => CU(e, n, tt), Sg = (e, n) => [e].concat(sB(e, n)), ax = (e, n, s) => iE(e, n, s, vU), aB = (e) => (n) => e.isBlock(gr(n)), SU = (e, n, s) => Pn(Sg(Me.fromDom(n.container()), e), aB(s)), iB = (e, n, s, l) => ax(e, n.dom, s).forall((d) => SU(n, s, l).fold(() => !pu(d, s, n.dom), (p) => !pu(d, s, n.dom) && Gi(p, Me.fromDom(d.container())))), No = (e, n, s, l) => SU(n, s, l).fold(() => ax(e, n.dom, s).forall((d) => !pu(d, s, n.dom)), (d) => ax(e, d.dom, s).isNone()), QP = Le(No, !1), Go = Le(No, !0), lB = Le(iB, !1), dae = Le(iB, !0), fae = (e) => Ay(e).exists(gb), VE = (e, n, s, l) => {
      const d = xn(Sg(Me.fromDom(s.container()), n), (v) => l.isBlock(gr(v))), p = pn(d).getOr(n);
      return hu(e, p.dom, s).filter(fae);
    }, cB = (e, n, s) => Ay(n).exists(gb) || VE(!0, e, n, s).isSome(), JP = (e, n, s) => tE(n).exists(gb) || VE(!1, e, n, s).isSome(), uB = Le(VE, !1), kU = Le(VE, !0), Ao = (e) => vt.isTextPosition(e) && !e.isAtStart() && !e.isAtEnd(), dB = (e, n, s) => {
      const l = xn(Sg(Me.fromDom(n.container()), e), (d) => s.isBlock(gr(d)));
      return pn(l).getOr(e);
    }, fB = (e, n, s) => Ao(n) ? KP(n) : KP(n) || Xc(dB(e, n, s).dom, n).exists(KP), mB = (e, n, s) => Ao(n) ? qP(n) : qP(n) || Hl(dB(e, n, s).dom, n).exists(qP), RC = (e) => At([
      "pre",
      "pre-wrap"
    ], e), jE = (e) => Ay(e).bind((n) => aa(n, rt)).exists((n) => RC(fa(n, "white-space"))), _U = (e, n) => Xc(e.dom, n).isNone(), EU = (e, n) => Hl(e.dom, n).isNone(), TU = (e, n, s) => _U(e, n) || EU(e, n) || QP(e, n, s) || Go(e, n, s) || JP(e, n, s) || cB(e, n, s), pB = (e) => je(e) && Vr(e) && Z2(e), hB = (e, n) => (s) => pB(new Ri(s, e)[n]()), mae = (e, n) => {
      const s = Hl(e.dom, n).getOr(n), l = hB(e.dom, "next");
      return n.isAtEnd() && (l(n.container()) || l(s.container()));
    }, pae = (e, n) => {
      const s = Xc(e.dom, n).getOr(n), l = hB(e.dom, "prev");
      return n.isAtStart() && (l(n.container()) || l(s.container()));
    }, gB = (e, n, s) => jE(n) ? !1 : TU(e, n, s) || fB(e, n, s) || mB(e, n, s), NC = (e, n, s) => jE(n) ? !1 : QP(e, n, s) || lB(e, n, s) || JP(e, n, s) || fB(e, n, s) || pae(e, n), OU = (e) => {
      const n = e.container(), s = e.offset();
      return Zt(n) && s < n.data.length ? vt(n, s + 1) : e;
    }, MC = (e, n, s) => jE(n) ? !1 : Go(e, n, s) || dae(e, n, s) || cB(e, n, s) || mB(e, n, s) || mae(e, n), UE = (e, n, s) => NC(e, n, s) || MC(e, OU(n), s), bB = (e, n) => qf(e.charAt(n)), ir = (e, n) => gg(e.charAt(n)), vB = (e) => {
      const n = e.container();
      return Zt(n) && Qn(n.data, Xa);
    }, WE = (e) => {
      const n = e.split("");
      return en(n, (s, l) => qf(s) && l > 0 && l < n.length - 1 && aC(n[l - 1]) && aC(n[l + 1]) ? " " : s).join("");
    }, eD = (e, n, s, l) => {
      const d = n.data, p = vt(n, 0);
      return !s && bB(d, 0) && !UE(e, p, l) ? (n.data = " " + d.slice(1), !0) : s && ir(d, 0) && NC(e, p, l) ? (n.data = Xa + d.slice(1), !0) : !1;
    }, yB = (e) => {
      const n = e.data, s = WE(n);
      return s !== n ? (e.data = s, !0) : !1;
    }, tD = (e, n, s, l) => {
      const d = n.data, p = vt(n, d.length - 1);
      return !s && bB(d, d.length - 1) && !UE(e, p, l) ? (n.data = d.slice(0, -1) + " ", !0) : s && ir(d, d.length - 1) && MC(e, p, l) ? (n.data = d.slice(0, -1) + Xa, !0) : !1;
    }, xB = (e, n, s) => {
      const l = n.container();
      if (!Zt(l))
        return Y.none();
      if (vB(n)) {
        const d = eD(e, l, !1, s) || yB(l) || tD(e, l, !1, s);
        return xr(d, n);
      } else if (UE(e, n, s)) {
        const d = eD(e, l, !0, s) || tD(e, l, !0, s);
        return xr(d, n);
      } else
        return Y.none();
    }, wB = (e) => {
      const n = Me.fromDom(e.getBody());
      e.selection.isCollapsed() && xB(n, vt.fromRangeStart(e.selection.getRng()), e.schema).each((s) => {
        e.selection.setRng(s.toRange());
      });
    }, CB = (e, n, s, l) => {
      if (s === 0)
        return;
      const d = Me.fromDom(e), p = Is(d, (M) => l.isBlock(gr(M))).getOr(d), v = e.data.slice(n, n + s), S = n + s >= e.data.length && MC(p, vt(e, e.data.length), l), O = n === 0 && NC(p, vt(e, 0), l);
      e.replaceData(n, s, uu(v, 4, O, S));
    }, IC = (e, n, s) => {
      const l = e.data.slice(n), d = l.length - Ei(l).length;
      CB(e, n, d, s);
    }, nD = (e, n, s) => {
      const l = e.data.slice(0, n), d = l.length - Ti(l).length;
      CB(e, n - d, d, s);
    }, oD = (e, n, s, l, d = !0) => {
      const p = Ti(e.data).length, v = d ? e : n, S = d ? n : e;
      return d ? v.appendData(S.data) : v.insertData(0, S.data), ys(Me.fromDom(S)), l && IC(v, p, s), v;
    }, AU = (e, n) => {
      const s = e.container(), l = e.offset();
      return !vt.isTextPosition(e) && s === n.parentNode && l > vt.before(n).offset();
    }, PU = (e, n) => AU(n, e) ? vt(n.container(), n.offset() - 1) : n, DU = (e) => Zt(e) ? vt(e, 0) : vt.before(e), RU = (e) => Zt(e) ? vt(e, e.data.length) : vt.after(e), SB = (e) => lf(e.previousSibling) ? Y.some(RU(e.previousSibling)) : e.previousSibling ? gu(e.previousSibling) : Y.none(), kB = (e) => lf(e.nextSibling) ? Y.some(DU(e.nextSibling)) : e.nextSibling ? zl(e.nextSibling) : Y.none(), rD = (e, n) => Y.from(n.previousSibling ? n.previousSibling : n.parentNode).bind((s) => Xc(e, vt.before(s))).orThunk(() => Hl(e, vt.after(n))), sD = (e, n) => Hl(e, vt.after(n)).orThunk(() => Xc(e, vt.before(n))), NU = (e, n) => SB(n).orThunk(() => kB(n)).orThunk(() => rD(e, n)), MU = (e, n) => kB(n).orThunk(() => SB(n)).orThunk(() => sD(e, n)), IU = (e, n, s) => e ? MU(n, s) : NU(n, s), FU = (e, n, s) => IU(e, n, s).map(Le(PU, s)), _B = (e, n, s) => {
      s.fold(() => {
        e.focus();
      }, (l) => {
        e.selection.setRng(l.toRange(), n);
      });
    }, BU = (e) => (n) => n.dom === e, $U = (e, n) => n && Xn(e.schema.getBlockElements(), gr(n)), LU = (e, n, s) => {
      if (Es(e, n)) {
        const l = Me.fromHtml('<br data-mce-bogus="1">');
        return s ? Ue(Ya(n), (d) => {
          u1(d) || ys(d);
        }) : Lc(n), Ys(n, l), Y.some(vt.before(l.dom));
      } else
        return Y.none();
    }, EB = (e, n, s, l) => {
      const d = Xl(e).filter(pt), p = $c(e).filter(pt);
      return ys(e), Il(d, p, n, (v, S, O) => {
        const M = v.dom, j = S.dom, U = M.data.length;
        return oD(M, j, s, l), O.container() === j ? vt(M, U) : O;
      }).orThunk(() => (l && (d.each((v) => nD(v.dom, v.dom.length, s)), p.each((v) => IC(v.dom, 0, s))), n));
    }, HU = (e, n) => Xn(e.schema.getTextInlineElements(), gr(n)), k1 = (e, n, s, l = !0, d = !1) => {
      const p = FU(n, e.getBody(), s.dom), v = Is(s, Le($U, e), BU(e.getBody())), S = EB(s, p, e.schema, HU(e, s));
      e.dom.isEmpty(e.getBody()) ? (e.setContent(""), e.selection.setCursorLocation()) : v.bind((O) => LU(e.schema, O, d)).fold(() => {
        l && _B(e, n, S);
      }, (O) => {
        l && _B(e, n, Y.some(O));
      });
    }, _1 = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/, zU = (e) => _1.test(e), Gb = (e, n) => wl(Me.fromDom(n), M4(e)) && !Lu(e.schema, n) && e.dom.isEditable(n), TB = (e) => {
      var n;
      return Js.DOM.getStyle(e, "direction", !0) === "rtl" || zU((n = e.textContent) !== null && n !== void 0 ? n : "");
    }, VU = (e, n, s) => xn(Js.DOM.getParents(s.container(), "*", n), e), kg = (e, n, s) => {
      const l = VU(e, n, s);
      return Y.from(l[l.length - 1]);
    }, OB = (e, n, s) => {
      const l = df(n, e), d = df(s, e);
      return je(l) && l === d;
    }, AB = (e) => r2(e) || eg(e), Od = (e, n) => {
      const s = n.container(), l = n.offset();
      return e ? af(s) ? Zt(s.nextSibling) ? vt(s.nextSibling, 0) : vt.after(s) : r2(n) ? vt(s, l + 1) : n : af(s) ? Zt(s.previousSibling) ? vt(s.previousSibling, s.previousSibling.data.length) : vt.before(s) : eg(n) ? vt(s, l - 1) : n;
    }, Dc = Le(Od, !0), PB = Le(Od, !1), DB = (e, n) => {
      const s = (l) => l.stopImmediatePropagation();
      e.on("beforeinput input", s, !0), e.getDoc().execCommand(n), e.off("beforeinput input", s);
    }, jU = (e) => {
      e.execCommand("delete");
    }, ZE = (e) => DB(e, "Delete"), RB = (e) => DB(e, "ForwardDelete"), E1 = (e) => (n) => fs(Di(n), e, zr), UU = (e) => s_(e) || Oc(e), GE = (e, n) => Gi(e, n) ? aa(n, UU, E1(e)) : Y.none(), la = (e, n = !0) => {
      e.dom.isEmpty(e.getBody()) && e.setContent("", { no_selection: !n });
    }, FC = (e, n, s) => ga(zl(s), gu(s), (l, d) => {
      const p = Od(!0, l), v = Od(!1, d), S = Od(!1, n);
      return e ? Hl(s, S).exists((O) => O.isEqual(v) && n.isEqual(p)) : Xc(s, S).exists((O) => O.isEqual(p) && n.isEqual(v));
    }).getOr(!0), T1 = (e) => (pe(e) ? Xl(e) : Sc(e)).bind(T1).orThunk(() => Y.some(e)), NB = (e, n, s, l = !0) => {
      var d;
      n.deleteContents();
      const p = T1(s).getOr(s), v = Me.fromDom((d = e.dom.getParent(p.dom, e.dom.isBlock)) !== null && d !== void 0 ? d : s.dom);
      if (v.dom === e.getBody() ? la(e, l) : Es(e.schema, v, { checkRootAsContent: !1 }) && (qc(v), l && e.selection.setCursorLocation(v.dom, 0)), !zr(s, v)) {
        const S = fs(Di(v), s) ? [] : Zg(v);
        Ue(S.concat(Ya(s)), (O) => {
          !zr(O, v) && !Gi(O, v) && Es(e.schema, O) && ys(O);
        });
      }
    }, ix = (e) => (n) => zr(e, n), Yu = (e) => ba(e, "td,th"), lx = (e, n) => i1(Me.fromDom(e), n), Ls = (e) => ga(e.startTable, e.endTable, (n, s) => {
      const l = _v(n, (p) => zr(p, s)), d = _v(s, (p) => zr(p, n));
      return !l && !d ? e : {
        ...e,
        startTable: l ? Y.none() : e.startTable,
        endTable: d ? Y.none() : e.endTable,
        isSameTable: !1,
        isMultiTable: !1
      };
    }).getOr(e), BC = (e) => Ls(e), MB = (e, n) => {
      const s = lx(e.startContainer, n), l = lx(e.endContainer, n), d = s.isSome(), p = l.isSome(), v = ga(s, l, zr).getOr(!1);
      return BC({
        startTable: s,
        endTable: l,
        isStartInTable: d,
        isEndInTable: p,
        isSameTable: v,
        isMultiTable: !v && d && p
      });
    }, qE = (e, n) => ({
      start: e,
      end: n
    }), aD = (e, n, s) => ({
      rng: e,
      table: n,
      cells: s
    }), O1 = ss.generate([
      {
        singleCellTable: [
          "rng",
          "cell"
        ]
      },
      { fullTable: ["table"] },
      {
        partialTable: [
          "cells",
          "outsideDetails"
        ]
      },
      {
        multiTable: [
          "startTableCells",
          "endTableCells",
          "betweenRng"
        ]
      }
    ]), cx = (e, n) => cu(Me.fromDom(e), "td,th", n), KE = (e) => !zr(e.start, e.end), $C = (e, n) => i1(e.start, n).bind((s) => i1(e.end, n).bind((l) => xr(zr(s, l), s))), iD = (e, n) => !KE(e) && $C(e, n).exists((s) => {
      const l = s.dom.rows;
      return l.length === 1 && l[0].cells.length === 1;
    }), IB = (e, n) => {
      const s = cx(e.startContainer, n), l = cx(e.endContainer, n);
      return ga(s, l, qE);
    }, FB = (e) => (n) => i1(n, e).bind((s) => Oo(Yu(s)).map((l) => qE(n, l))), BB = (e) => (n) => i1(n, e).bind((s) => pn(Yu(s)).map((l) => qE(l, n))), YE = (e) => (n) => $C(n, e).map((s) => aD(n, s, Yu(s))), lD = (e, n, s, l) => {
      if (s.collapsed || !e.forall(KE))
        return Y.none();
      if (n.isSameTable) {
        const d = e.bind(YE(l));
        return Y.some({
          start: d,
          end: d
        });
      } else {
        const d = cx(s.startContainer, l), p = cx(s.endContainer, l), v = d.bind(FB(l)).bind(YE(l)), S = p.bind(BB(l)).bind(YE(l));
        return Y.some({
          start: v,
          end: S
        });
      }
    }, A1 = (e, n) => so(e, (s) => zr(s, n)), XE = (e) => ga(A1(e.cells, e.rng.start), A1(e.cells, e.rng.end), (n, s) => e.cells.slice(n, s + 1)), cD = (e, n, s) => e.exists((l) => iD(l, s) && By(l.start, n)), $B = (e, n) => {
      const { startTable: s, endTable: l } = n, d = e.cloneRange();
      return s.each((p) => d.setStartAfter(p.dom)), l.each((p) => d.setEndBefore(p.dom)), d;
    }, WU = (e, n, s, l) => lD(e, n, s, l).bind(({ start: d, end: p }) => d.or(p)).bind((d) => {
      const { isSameTable: p } = n, v = XE(d).getOr([]);
      if (p && d.cells.length === v.length)
        return Y.some(O1.fullTable(d.table));
      if (v.length > 0) {
        if (p)
          return Y.some(O1.partialTable(v, Y.none()));
        {
          const S = $B(s, n);
          return Y.some(O1.partialTable(v, Y.some({
            ...n,
            rng: S
          })));
        }
      } else
        return Y.none();
    }), LB = (e, n, s, l) => lD(e, n, s, l).bind(({ start: d, end: p }) => {
      const v = d.bind(XE).getOr([]), S = p.bind(XE).getOr([]);
      if (v.length > 0 && S.length > 0) {
        const O = $B(s, n);
        return Y.some(O1.multiTable(v, S, O));
      } else
        return Y.none();
    }), HB = (e, n) => {
      const s = ix(e), l = IB(n, s), d = MB(n, s);
      return cD(l, n, s) ? l.map((p) => O1.singleCellTable(n, p.start)) : d.isMultiTable ? LB(l, d, n, s) : WU(l, d, n, s);
    }, uD = (e) => Ue(e, (n) => {
      oa(n, "contenteditable"), qc(n);
    }), QE = (e, n) => Y.from(e.dom.getParent(n, e.dom.isBlock)).map(Me.fromDom), zB = (e, n, s) => {
      s.each((l) => {
        n ? ys(l) : (qc(l), e.selection.setCursorLocation(l.dom, 0));
      });
    }, JE = (e, n, s, l) => {
      const d = s.cloneRange();
      l ? (d.setStart(s.startContainer, s.startOffset), d.setEndAfter(n.dom.lastChild)) : (d.setStartBefore(n.dom.firstChild), d.setEnd(s.endContainer, s.endOffset)), eT(e, d, n, !1).each((p) => p());
    }, dD = (e) => {
      const n = Bb(e), s = Me.fromDom(e.selection.getNode());
      tb(s.dom) && Es(e.schema, s) ? e.selection.setCursorLocation(s.dom, 0) : e.selection.collapse(!0), n.length > 1 && $n(n, (l) => zr(l, s)) && ur(s, "data-mce-selected", "1");
    }, fD = (e, n, s) => Y.some(() => {
      const l = e.selection.getRng(), d = s.bind(({ rng: p, isStartInTable: v }) => {
        const S = QE(e, v ? p.endContainer : p.startContainer);
        p.deleteContents(), zB(e, v, S.filter(Le(Es, e.schema)));
        const O = v ? n[0] : n[n.length - 1];
        return JE(e, O, l, v), Es(e.schema, O) ? Y.none() : Y.some(v ? n.slice(1) : n.slice(0, -1));
      }).getOr(n);
      uD(d), dD(e);
    }), VB = (e, n, s, l) => Y.some(() => {
      const d = e.selection.getRng(), p = n[0], v = s[s.length - 1];
      JE(e, p, d, !0), JE(e, v, d, !1);
      const S = Es(e.schema, p) ? n : n.slice(1), O = Es(e.schema, v) ? s : s.slice(0, -1);
      uD(S.concat(O)), l.deleteContents(), dD(e);
    }), eT = (e, n, s, l = !0) => Y.some(() => {
      NB(e, n, s, l);
    }), jB = (e, n) => Y.some(() => k1(e, !1, n)), UB = (e, n, s) => HB(n, s).bind((l) => l.fold(Le(eT, e), Le(jB, e), Le(fD, e), Le(VB, e))), WB = (e, n) => LC(e, n), ZB = (e, n, s, l) => tT(n, l).fold(() => UB(e, n, s), (d) => WB(e, d)), mD = (e, n, s) => {
      const l = Me.fromDom(e.getBody()), d = e.selection.getRng();
      return s.length !== 0 ? fD(e, s, Y.none()) : ZB(e, l, d, n);
    }, pD = (e, n) => Pn(Sg(n, e), vb), tT = (e, n) => Pn(Sg(n, e), _s("caption")), GB = (e, n, s, l, d) => Bm(s, e.getBody(), d).bind((p) => pD(n, Me.fromDom(p.getNode())).bind((v) => zr(v, l) ? Y.none() : Y.some(qe))), LC = (e, n) => Y.some(() => {
      qc(n), e.selection.setCursorLocation(n.dom, 0);
    }), qB = (e, n, s, l) => zl(e.dom).bind((d) => gu(e.dom).map((p) => n ? s.isEqual(d) && l.isEqual(p) : s.isEqual(p) && l.isEqual(d))).getOr(!0), KB = (e, n) => LC(e, n), hD = (e, n, s) => tT(e, Me.fromDom(s.getNode())).fold(() => Y.some(qe), (l) => xr(!zr(l, n), qe)), nT = (e, n, s, l, d) => Bm(s, e.getBody(), d).fold(() => Y.some(qe), (p) => qB(l, s, d, p) ? KB(e, l) : hD(n, l, p)), gD = (e, n, s, l) => {
      const d = vt.fromRangeStart(e.selection.getRng());
      return pD(s, l).bind((p) => Es(e.schema, p, { checkRootAsContent: !1 }) ? LC(e, p) : GB(e, s, n, p, d));
    }, oT = (e, n, s, l) => {
      const d = vt.fromRangeStart(e.selection.getRng());
      return Es(e.schema, l) ? LC(e, l) : nT(e, s, n, l, d);
    }, bD = (e, n) => e ? YP(n) : XP(n), rT = (e, n) => {
      const s = vt.fromRangeStart(e.selection.getRng());
      return bD(n, s) || hu(n, e.getBody(), s).exists((l) => bD(n, l));
    }, vD = (e, n, s) => {
      const l = Me.fromDom(e.getBody());
      return tT(l, s).fold(() => gD(e, n, l, s).orThunk(() => xr(rT(e, n), qe)), (d) => oT(e, n, l, d));
    }, P1 = (e, n) => {
      const s = Me.fromDom(e.selection.getStart(!0)), l = Bb(e);
      return e.selection.isCollapsed() && l.length === 0 ? vD(e, n, s) : mD(e, s, l);
    }, _g = (e, n) => {
      let s = n;
      for (; s && s !== e; ) {
        if (Rt(s) || Vr(s))
          return s;
        s = s.parentNode;
      }
      return null;
    }, YB = [
      "data-ephox-",
      "data-mce-",
      "data-alloy-",
      "data-snooker-",
      "_"
    ], ux = Gt.each, HC = (e) => {
      const n = e.dom, s = new Set(e.serializer.getTempAttrs()), l = (p, v) => {
        if (p.nodeName !== v.nodeName || p.nodeType !== v.nodeType)
          return !1;
        const S = (M) => {
          const j = {};
          return ux(n.getAttribs(M), (U) => {
            const Z = U.nodeName.toLowerCase();
            Z !== "style" && !d(Z) && (j[Z] = n.getAttrib(M, Z));
          }), j;
        }, O = (M, j) => {
          for (const U in M)
            if (Xn(M, U)) {
              const Z = j[U];
              if (ot(Z) || M[U] !== Z)
                return !1;
              delete j[U];
            }
          for (const U in j)
            if (Xn(j, U))
              return !1;
          return !0;
        };
        return On(p) && On(v) && (!O(S(p), S(v)) || !O(n.parseStyle(n.getAttrib(p, "style")), n.parseStyle(n.getAttrib(v, "style")))) ? !1 : !vu(p) && !vu(v);
      }, d = (p) => $n(YB, (v) => lo(p, v)) || s.has(p);
      return {
        compare: l,
        isAttributeInternal: d
      };
    }, sT = (e) => [
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6"
    ].includes(e.name), dx = (e) => e.name === "summary", qb = (e, n) => {
      let s = e;
      for (; s = s.walk(); )
        n(s);
    }, yD = (e, n, s, l) => {
      const d = s.name;
      for (let p = 0, v = e.length; p < v; p++) {
        const S = e[p];
        if (S.name === d) {
          const O = l.nodes[d];
          O ? O.nodes.push(s) : l.nodes[d] = {
            filter: S,
            nodes: [s]
          };
        }
      }
      if (s.attributes)
        for (let p = 0, v = n.length; p < v; p++) {
          const S = n[p], O = S.name;
          if (O in s.attributes.map) {
            const M = l.attributes[O];
            M ? M.nodes.push(s) : l.attributes[O] = {
              filter: S,
              nodes: [s]
            };
          }
        }
    }, ZU = (e, n, s) => {
      const l = {
        nodes: {},
        attributes: {}
      };
      return s.firstChild && qb(s, (d) => {
        yD(e, n, d, l);
      }), l;
    }, XB = (e, n) => {
      const s = (l, d) => {
        Ht(l, (p) => {
          const v = hr(p.nodes);
          Ue(p.filter.callbacks, (S) => {
            for (let O = v.length - 1; O >= 0; O--) {
              const M = v[O];
              (!(d ? M.attr(p.filter.name) !== void 0 : M.name === p.filter.name) || Kt(M.parent)) && v.splice(O, 1);
            }
            v.length > 0 && S(v, p.filter.name, n);
          });
        });
      };
      s(e.nodes, !1), s(e.attributes, !0);
    }, xD = (e, n, s, l = {}) => {
      const d = ZU(e, n, s);
      XB(d, l);
    }, aT = (e, n, s, l) => {
      if ((e.pad_empty_with_br || n.insert) && s(l)) {
        const p = new eu("br", 1);
        n.insert && p.attr("data-mce-bogus", "1"), l.empty().append(p);
      } else
        l.empty().append(new eu("#text", 3)).value = Xa;
    }, GU = (e) => {
      var n;
      return Eg(e, "#text") && ((n = e == null ? void 0 : e.firstChild) === null || n === void 0 ? void 0 : n.value) === Xa;
    }, Eg = (e, n) => {
      const s = e == null ? void 0 : e.firstChild;
      return je(s) && s === e.lastChild && s.name === n;
    }, D1 = (e, n) => {
      const s = e.getElementRule(n.name);
      return (s == null ? void 0 : s.paddEmpty) === !0;
    }, iT = (e, n, s, l) => l.isEmpty(n, s, (d) => D1(e, d)), Rl = (e, n) => je(e) && (n(e) || e.name === "br"), qU = (e) => {
      let n;
      for (let s = e; s; s = s.parent) {
        const l = s.attr("contenteditable");
        if (l === "false")
          break;
        l === "true" && (n = s);
      }
      return Y.from(n);
    }, wD = (e, n, s = e.parent) => {
      if (n.getSpecialElements()[e.name])
        e.empty().remove();
      else {
        const l = e.children();
        for (const d of l)
          s && !n.isValidChild(s.name, d.name) && wD(d, n, s);
        e.unwrap();
      }
    }, jm = (e, n, s, l = qe) => {
      const d = n.getTextBlockElements(), p = n.getNonEmptyElements(), v = n.getWhitespaceElements(), S = Gt.makeMap("tr,td,th,tbody,thead,tfoot,table,summary"), O = /* @__PURE__ */ new Set(), M = (j) => j !== s && !S[j.name];
      for (let j = 0; j < e.length; j++) {
        const U = e[j];
        let Z, de, we;
        if (!U.parent || O.has(U))
          continue;
        if (d[U.name] && U.parent.name === "li") {
          let Se = U.next;
          for (; Se && d[Se.name]; ) {
            Se.name = "li", O.add(Se), U.parent.insert(Se, U.parent);
            Se = Se.next;
          }
          U.unwrap();
          continue;
        }
        const me = [U];
        for (Z = U.parent; Z && !n.isValidChild(Z.name, U.name) && M(Z); Z = Z.parent)
          me.push(Z);
        if (Z && me.length > 1)
          if (QB(n, U, Z))
            wD(U, n);
          else {
            me.reverse(), de = me[0].clone(), l(de);
            let Se = de;
            for (let ze = 0; ze < me.length - 1; ze++) {
              n.isValidChild(Se.name, me[ze].name) && ze > 0 ? (we = me[ze].clone(), l(we), Se.append(we)) : we = Se;
              for (let Ye = me[ze].firstChild; Ye && Ye !== me[ze + 1]; ) {
                const We = Ye.next;
                we.append(Ye), Ye = We;
              }
              Se = we;
            }
            iT(n, p, v, de) ? Z.insert(U, me[0], !0) : (Z.insert(de, me[0], !0), Z.insert(U, de)), Z = me[0], (iT(n, p, v, Z) || Eg(Z, "br")) && Z.empty().remove();
          }
        else if (U.parent) {
          if (U.name === "li") {
            let Se = U.prev;
            if (Se && (Se.name === "ul" || Se.name === "ol")) {
              Se.append(U);
              continue;
            }
            if (Se = U.next, Se && (Se.name === "ul" || Se.name === "ol") && Se.firstChild) {
              Se.insert(U, Se.firstChild, !0);
              continue;
            }
            const ze = new eu("ul", 1);
            l(ze), U.wrap(ze);
            continue;
          }
          if (n.isValidChild(U.parent.name, "div") && n.isValidChild("div", U.name)) {
            const Se = new eu("div", 1);
            l(Se), U.wrap(Se);
          } else
            wD(U, n);
        }
      }
    }, is = (e, n) => {
      let s = e;
      for (; s; ) {
        if (s.name === n)
          return !0;
        s = s.parent;
      }
      return !1;
    }, QB = (e, n, s = n.parent) => s ? e.children[n.name] && !e.isValidChild(s.name, n.name) || n.name === "a" && is(s, "a") ? !0 : dx(s) && sT(n) ? !((s == null ? void 0 : s.firstChild) === n && (s == null ? void 0 : s.lastChild) === n) : !1 : !1, KU = (e, n, s, l) => {
      const d = document.createRange();
      return d.setStart(e, n), d.setEnd(s, l), d;
    }, YU = (e) => {
      const n = vt.fromRangeStart(e), s = vt.fromRangeEnd(e), l = e.commonAncestorContainer;
      return hu(!1, l, s).map((d) => !pu(n, s, l) && pu(n, d, l) ? KU(n.container(), n.offset(), d.container(), d.offset()) : e).getOr(e);
    }, Zs = (e) => e.collapsed ? e : YU(e), JB = (e) => je(e.firstChild) && e.firstChild === e.lastChild, zC = (e) => e.name === "br" || e.value === Xa, VC = (e, n) => e.getBlockElements()[n.name] && JB(n) && zC(n.firstChild), lT = (e, n) => {
      const s = e.getNonEmptyElements();
      return je(n) && (n.isEmpty(s) || VC(e, n));
    }, cT = (e, n) => {
      let s = n.firstChild, l = n.lastChild;
      return s && s.name === "meta" && (s = s.next), l && l.attr("id") === "mce_marker" && (l = l.prev), lT(e, l) && (l = l == null ? void 0 : l.prev), !s || s !== l ? !1 : s.name === "ul" || s.name === "ol";
    }, e$ = (e) => {
      var n, s;
      const l = e.firstChild, d = e.lastChild;
      return l && l.nodeName === "META" && ((n = l.parentNode) === null || n === void 0 || n.removeChild(l)), d && d.id === "mce_marker" && ((s = d.parentNode) === null || s === void 0 || s.removeChild(d)), e;
    }, hae = (e, n, s) => {
      const l = n.serialize(s), d = e.createFragment(l);
      return e$(d);
    }, XU = (e) => {
      var n;
      return xn((n = e == null ? void 0 : e.childNodes) !== null && n !== void 0 ? n : [], (s) => s.nodeName === "LI");
    }, gae = (e) => e.data === Xa || Wr(e), QU = (e) => je(e == null ? void 0 : e.firstChild) && e.firstChild === e.lastChild && gae(e.firstChild), JU = (e) => !e.firstChild || QU(e), bae = (e) => e.length > 0 && JU(e[e.length - 1]) ? e.slice(0, -1) : e, CD = (e, n) => {
      const s = e.getParent(n, e.isBlock);
      return s && s.nodeName === "LI" ? s : null;
    }, gl = (e, n) => !!CD(e, n), t$ = (e, n) => {
      const s = n.cloneRange(), l = n.cloneRange();
      return s.setStartBefore(e), l.setEndAfter(e), [
        s.cloneContents(),
        l.cloneContents()
      ];
    }, n$ = (e, n) => {
      const s = vt.before(e), d = pl(n).next(s);
      return d ? d.toRange() : null;
    }, o$ = (e, n) => {
      const s = vt.after(e), d = pl(n).prev(s);
      return d ? d.toRange() : null;
    }, eW = (e, n, s, l) => {
      const d = t$(e, l), p = e.parentNode;
      return p && (p.insertBefore(d[0], e), Gt.each(n, (v) => {
        p.insertBefore(v, e);
      }), p.insertBefore(d[1], e), p.removeChild(e)), o$(n[n.length - 1], s);
    }, tW = (e, n, s) => {
      const l = e.parentNode;
      return l && Gt.each(n, (d) => {
        l.insertBefore(d, e);
      }), n$(e, s);
    }, Xu = (e, n, s, l) => (l.insertAfter(n.reverse(), e), o$(n[0], s)), Um = (e, n, s, l) => {
      const d = hae(n, e, l), p = CD(n, s.startContainer), v = bae(XU(d.firstChild)), S = 1, O = 2, M = n.getRoot(), j = (U) => {
        const Z = vt.fromRangeStart(s), de = pl(n.getRoot()), we = U === S ? de.prev(Z) : de.next(Z), me = we == null ? void 0 : we.getNode();
        return me ? CD(n, me) !== p : !0;
      };
      return p ? j(S) ? tW(p, v, M) : j(O) ? Xu(p, v, M, n) : eW(p, v, M, s) : null;
    }, nW = ["pre"], SD = (e, n, s, l) => {
      var d;
      const p = n.firstChild, v = n.lastChild, S = v.attr("data-mce-type") === "bookmark" ? v.prev : v, O = p === S, M = At(nW, p.name);
      if (O && M) {
        const j = p.attr("contenteditable") !== "false", U = ((d = e.getParent(s, e.isBlock)) === null || d === void 0 ? void 0 : d.nodeName.toLowerCase()) === p.name, Z = Y.from(_g(l, s)).forall(Rt);
        return j && U && Z;
      } else
        return !1;
    }, jC = tb, oW = (e, n, s) => {
      if (je(s)) {
        const l = e.getParent(n.endContainer, jC);
        return s === l && By(Me.fromDom(s), n);
      } else
        return !1;
    }, rW = (e, n, s) => {
      var l;
      if (s.getAttribute("data-mce-bogus") === "all")
        (l = s.parentNode) === null || l === void 0 || l.insertBefore(e.dom.createFragment(n), s);
      else {
        const d = s.firstChild, p = s.lastChild;
        !d || d === p && d.nodeName === "BR" ? e.dom.setHTML(s, n) : e.selection.setContent(n, { no_events: !0 });
      }
    }, UC = (e, n, s) => {
      Y.from(e.getParent(n, "td,th")).map(Me.fromDom).each((l) => a_(l, s));
    }, uT = (e, n) => {
      const s = e.schema.getTextInlineElements(), l = e.dom;
      if (n) {
        const d = e.getBody(), p = HC(e), v = "*[data-mce-fragment]", S = l.select(v);
        Gt.each(S, (O) => {
          const M = (Z) => je(s[Z.nodeName.toLowerCase()]), j = (Z) => Z.childNodes.length === 1;
          if (((Z) => !(tB(l, Z) || hU(l, Z)))(O) && M(O) && j(O)) {
            const Z = rx(l, O), de = (ze, Ye) => Ko(ze, (We) => At(Ye, We)), we = (ze) => j(O) && l.is(ze, v) && M(ze) && (ze.nodeName === O.nodeName && de(Z, rx(l, ze)) || we(ze.children[0])), me = (ze) => je(ze) && ze !== d && (p.compare(O, ze) || me(ze.parentElement)), Se = (ze) => je(ze) && ze !== d && l.is(ze, v) && (bU(l, O, ze) || Se(ze.parentElement));
            (we(O.children[0]) || me(O.parentElement) && !Se(O.parentElement)) && l.remove(O, !0);
          }
        });
      }
    }, kD = (e) => {
      let n = e;
      for (; n = n.walk(); )
        n.type === 1 && n.attr("data-mce-fragment", "1");
    }, sW = (e) => {
      Gt.each(e.getElementsByTagName("*"), (n) => {
        n.removeAttribute("data-mce-fragment");
      });
    }, Wm = (e) => !!e.getAttribute("data-mce-fragment"), aW = (e, n) => je(n) && !e.schema.getVoidElements()[n.nodeName], iW = (e, n) => {
      var s, l, d;
      let p;
      const v = e.dom, S = e.selection;
      if (!n)
        return;
      S.scrollIntoView(n);
      const O = _g(e.getBody(), n);
      if (O && v.getContentEditable(O) === "false") {
        v.remove(n), S.select(O);
        return;
      }
      let M = v.createRng();
      const j = n.previousSibling;
      if (Zt(j)) {
        M.setStart(j, (l = (s = j.nodeValue) === null || s === void 0 ? void 0 : s.length) !== null && l !== void 0 ? l : 0);
        const de = n.nextSibling;
        Zt(de) && (j.appendData(de.data), (d = de.parentNode) === null || d === void 0 || d.removeChild(de));
      } else
        M.setStartBefore(n), M.setEndBefore(n);
      const U = (de) => {
        let we = vt.fromRangeStart(de);
        return we = pl(e.getBody()).next(we), we == null ? void 0 : we.toRange();
      }, Z = v.getParent(n, v.isBlock);
      if (v.remove(n), Z && v.isEmpty(Z)) {
        const de = jC(Z);
        Lc(Me.fromDom(Z)), M.setStart(Z, 0), M.setEnd(Z, 0), !de && !Wm(Z) && (p = U(M)) ? (M = p, v.remove(Z)) : v.add(Z, v.create("br", de ? {} : { "data-mce-bogus": "1" }));
      }
      S.setRng(M);
    }, mf = (e) => {
      const n = e.dom, s = Zs(e.selection.getRng());
      e.selection.setRng(s);
      const l = n.getParent(s.startContainer, jC);
      oW(n, s, l) ? eT(e, s, Me.fromDom(l)) : s.startContainer === s.endContainer && s.endOffset - s.startOffset === 1 && Zt(s.startContainer.childNodes[s.startOffset]) ? s.deleteContents() : e.getDoc().execCommand("Delete", !1);
    }, WC = (e) => {
      for (let n = e; n; n = n.walk())
        if (n.attr("id") === "mce_marker")
          return Y.some(n);
      return Y.none();
    }, Jf = (e, n, s) => {
      var l;
      return $n(s.children(), sT) && ((l = e.getParent(n, e.isBlock)) === null || l === void 0 ? void 0 : l.nodeName) === "SUMMARY";
    }, lW = (e, n, s) => {
      var l, d;
      const p = e.selection, v = e.dom, S = e.parser, O = s.merge, M = Cg({ validate: !0 }, e.schema), j = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
      s.preserve_zwsp || (n = Kc(n)), n.indexOf("{$caret}") === -1 && (n += "{$caret}"), n = n.replace(/\{\$caret\}/, j);
      let U = p.getRng();
      const Z = U.startContainer, de = e.getBody();
      Z === de && p.isCollapsed() && v.isBlock(de.firstChild) && aW(e, de.firstChild) && v.isEmpty(de.firstChild) && (U = v.createRng(), U.setStart(de.firstChild, 0), U.setEnd(de.firstChild, 0), p.setRng(U)), p.isCollapsed() || mf(e);
      const we = p.getNode(), me = {
        context: we.nodeName.toLowerCase(),
        data: s.data,
        insert: !0
      }, Se = S.parse(n, me);
      if (s.paste === !0 && cT(e.schema, Se) && gl(v, we))
        return U = Um(M, v, p.getRng(), Se), U && p.setRng(U), n;
      s.paste === !0 && SD(v, Se, we, e.getBody()) && ((l = Se.firstChild) === null || l === void 0 || l.unwrap()), kD(Se);
      let ze = Se.lastChild;
      if (ze && ze.attr("id") === "mce_marker") {
        const Ye = ze;
        for (ze = ze.prev; ze; ze = ze.walk(!0))
          if (ze.type === 3 || !v.isBlock(ze.name)) {
            ze.parent && e.schema.isValidChild(ze.parent.name, "span") && ze.parent.insert(Ye, ze, ze.name === "br");
            break;
          }
      }
      if (e._selectionOverrides.showBlockCaretContainer(we), !me.invalid && !Jf(v, we, Se))
        n = M.serialize(Se), rW(e, n, we);
      else {
        e.selection.setContent(j);
        let Ye = p.getNode(), We;
        const ut = e.getBody();
        for (xp(Ye) ? Ye = We = ut : We = Ye; We && We !== ut; )
          Ye = We, We = We.parentNode;
        n = Ye === ut ? ut.innerHTML : v.getOuterHTML(Ye);
        const zt = S.parse(n), an = WC(zt), Dn = an.bind(qU).getOr(zt);
        an.each((Vn) => Vn.replace(Se));
        const Tt = Se.children(), yt = (d = Se.parent) !== null && d !== void 0 ? d : zt;
        Se.unwrap();
        const Lt = xn(Tt, (Vn) => QB(e.schema, Vn, yt));
        jm(Lt, e.schema, Dn), xD(S.getNodeFilters(), S.getAttributeFilters(), zt), n = M.serialize(zt), Ye === ut ? v.setHTML(ut, n) : v.setOuterHTML(Ye, n);
      }
      return uT(e, O), iW(e, v.get("mce_marker")), sW(e.getBody()), UC(v, p.getStart(), e.schema), yd(e.schema, e.getBody(), p.getStart()), n;
    }, hs = (e) => e instanceof eu, fx = (e) => {
      S1(e) && zl(e.getBody()).each((n) => {
        const s = n.getNode(), l = Fu(s) ? zl(s).getOr(n) : n;
        e.selection.setRng(l.toRange());
      });
    }, mx = (e, n, s) => {
      e.dom.setHTML(e.getBody(), n), s !== !0 && fx(e);
    }, r$ = (e, n, s, l) => {
      if (s = Kc(s), s.length === 0 || /^\s+$/.test(s)) {
        const d = '<br data-mce-bogus="1">';
        n.nodeName === "TABLE" ? s = "<tr><td>" + d + "</td></tr>" : /^(UL|OL)$/.test(n.nodeName) && (s = "<li>" + d + "</li>");
        const p = Pl(e);
        return e.schema.isValidChild(n.nodeName.toLowerCase(), p.toLowerCase()) ? (s = d, s = e.dom.createHTML(p, $p(e), s)) : s || (s = d), mx(e, s, l.no_selection), {
          content: s,
          html: s
        };
      } else {
        l.format !== "raw" && (s = Cg({ validate: !1 }, e.schema).serialize(e.parser.parse(s, {
          isRootContent: !0,
          insert: !0
        })));
        const d = Vv(Me.fromDom(n)) ? s : Gt.trim(s);
        return mx(e, d, l.no_selection), {
          content: d,
          html: d
        };
      }
    }, _D = (e, n, s, l) => {
      xD(e.parser.getNodeFilters(), e.parser.getAttributeFilters(), s);
      const d = Cg({ validate: !1 }, e.schema).serialize(s), p = Kc(Vv(Me.fromDom(n)) ? d : Gt.trim(d));
      return mx(e, p, l.no_selection), {
        content: s,
        html: p
      };
    }, ED = (e, n, s) => Y.from(e.getBody()).map((l) => hs(n) ? _D(e, l, n, s) : r$(e, l, n, s)).getOr({
      content: n,
      html: hs(s.content) ? "" : s.content
    }), s$ = (e) => ye(e) ? e : tt, TD = (e, n, s) => {
      let l = e.dom;
      const d = s$(s);
      for (; l.parentNode; ) {
        l = l.parentNode;
        const p = Me.fromDom(l), v = n(p);
        if (v.isSome())
          return v;
        if (d(p))
          break;
      }
      return Y.none();
    }, OD = (e, n, s) => {
      const l = n(e), d = s$(s);
      return l.orThunk(() => d(e) ? Y.none() : TD(e, n, d));
    }, dT = Ly, AD = (e, n, s) => {
      const l = e.formatter.get(s);
      if (l)
        for (let d = 0; d < l.length; d++) {
          const p = l[d];
          if (Wu(p) && p.inherit === !1 && e.dom.is(n, p.selector))
            return !0;
        }
      return !1;
    }, ZC = (e, n, s, l, d) => {
      const p = e.dom.getRoot();
      if (n === p)
        return !1;
      const v = e.dom.getParent(n, (S) => AD(e, S, s) ? !0 : S.parentNode === p || !!nh(e, S, s, l, !0));
      return !!nh(e, v, s, l, d);
    }, GC = (e, n, s) => Bi(s) && dT(n, s.inline) || Hm(s) && dT(n, s.block) ? !0 : Wu(s) ? On(n) && e.is(n, s.selector) : !1, qC = (e, n, s, l, d, p) => {
      const v = s[l], S = l === "attributes";
      if (ye(s.onmatch))
        return s.onmatch(n, s, l);
      if (v) {
        if (gn(v)) {
          for (let O = 0; O < v.length; O++)
            if (S ? e.getAttrib(n, v[O]) : Hy(e, n, v[O]))
              return !0;
        } else
          for (const O in v)
            if (Xn(v, O)) {
              const M = S ? e.getAttrib(n, O) : Hy(e, n, O), j = vg(v[O], p), U = Kt(M) || Yo(M);
              if (U && Kt(j))
                continue;
              if (d && U && !s.exact || (!d || s.exact) && !dT(M, yg(j, O)))
                return !1;
            }
      }
      return !0;
    }, nh = (e, n, s, l, d) => {
      const p = e.formatter.get(s), v = e.dom;
      if (p && On(n))
        for (let S = 0; S < p.length; S++) {
          const O = p[S];
          if (GC(e.dom, n, O) && qC(v, n, O, "attributes", d, l) && qC(v, n, O, "styles", d, l)) {
            const M = O.classes;
            if (M) {
              for (let j = 0; j < M.length; j++)
                if (!e.dom.hasClass(n, vg(M[j], l)))
                  return;
            }
            return O;
          }
        }
    }, PD = (e, n, s, l, d) => {
      if (l)
        return ZC(e, l, n, s, d);
      if (l = e.selection.getNode(), ZC(e, l, n, s, d))
        return !0;
      const p = e.selection.getStart();
      return !!(p !== l && ZC(e, p, n, s, d));
    }, cW = (e, n, s) => {
      const l = [], d = {}, p = e.selection.getStart();
      return e.dom.getParent(p, (v) => {
        for (let S = 0; S < n.length; S++) {
          const O = n[S];
          !d[O] && nh(e, v, O, s) && (d[O] = !0, l.push(O));
        }
      }, e.dom.getRoot()), l;
    }, uW = (e, n) => {
      const s = (d) => zr(d, Me.fromDom(e.getBody())), l = (d, p) => nh(e, d.dom, p) ? Y.some(p) : Y.none();
      return Y.from(e.selection.getStart(!0)).bind((d) => OD(Me.fromDom(d), (p) => or(n, (v) => l(p, v)), s)).getOrNull();
    }, dW = (e, n) => {
      const s = e.formatter.get(n), l = e.dom;
      if (s && e.selection.isEditable()) {
        const d = e.selection.getStart(), p = zb(l, d);
        for (let v = s.length - 1; v >= 0; v--) {
          const S = s[v];
          if (!Wu(S))
            return !0;
          for (let O = p.length - 1; O >= 0; O--)
            if (l.is(p[O], S.selector))
              return !0;
        }
      }
      return !1;
    }, a$ = (e, n, s) => Ct(s, (l, d) => {
      const p = iP(e, d);
      return e.formatter.matchNode(n, d, {}, p) ? l.concat([d]) : l;
    }, []), KC = Ma, fW = (e, n) => e.importNode(n, !0), DD = (e) => {
      if (e) {
        const n = new Ri(e, e);
        for (let s = n.current(); s; s = n.next())
          if (Zt(s))
            return s;
      }
      return null;
    }, fT = (e) => {
      const n = Me.fromTag("span");
      return _a(n, {
        id: My,
        "data-mce-bogus": "1",
        "data-mce-type": "format-caret"
      }), e && Ys(n, Me.fromText(KC)), n;
    }, mW = (e) => {
      const n = DD(e);
      return n && n.data.charAt(0) === KC && n.deleteData(0, 1), n;
    }, RD = (e, n, s) => {
      const l = e.dom, d = e.selection;
      if (gE(n))
        k1(e, !1, Me.fromDom(n), s, !0);
      else {
        const p = d.getRng(), v = l.getParent(n, l.isBlock), S = p.startContainer, O = p.startOffset, M = p.endContainer, j = p.endOffset, U = mW(n);
        l.remove(n, !0), S === U && O > 0 && p.setStart(U, O - 1), M === U && j > 0 && p.setEnd(U, j - 1), v && l.isEmpty(v) && qc(Me.fromDom(v)), d.setRng(p);
      }
    }, mT = (e, n, s) => {
      const l = e.dom, d = e.selection;
      if (n)
        RD(e, n, s);
      else if (n = pg(e.getBody(), d.getStart()), !n)
        for (; n = l.get(My); )
          RD(e, n, s);
    }, pW = (e, n, s) => {
      var l, d;
      const p = e.dom, v = p.getParent(s, Le(fC, e.schema));
      v && p.isEmpty(v) ? (l = s.parentNode) === null || l === void 0 || l.replaceChild(n, s) : (c4(Me.fromDom(s)), p.isEmpty(s) ? (d = s.parentNode) === null || d === void 0 || d.replaceChild(n, s) : p.insertAfter(n, s));
    }, ND = (e, n) => (e.appendChild(n), n), Ad = (e, n) => {
      var s;
      const l = Vt(e, (p, v) => ND(p, v.cloneNode(!1)), n), d = (s = l.ownerDocument) !== null && s !== void 0 ? s : document;
      return ND(l, d.createTextNode(KC));
    }, hW = (e, n, s, l, d, p) => {
      const v = e.formatter, S = e.dom, O = xn(Zo(v.get()), (U) => U !== l && !Qn(U, "removeformat")), M = a$(e, s, O);
      if (xn(M, (U) => !Vy(e, U, l)).length > 0) {
        const U = s.cloneNode(!1);
        return S.add(n, U), v.remove(l, d, U, p), S.remove(U), Y.some(U);
      } else
        return Y.none();
    }, i$ = (e, n, s) => {
      let l;
      const d = e.selection, p = e.formatter.get(n);
      if (!p)
        return;
      const v = d.getRng();
      let S = v.startOffset;
      const M = v.startContainer.nodeValue;
      l = pg(e.getBody(), d.getStart());
      const j = /[^\s\u00a0\u00ad\u200b\ufeff]/;
      if (M && S > 0 && S < M.length && j.test(M.charAt(S)) && j.test(M.charAt(S - 1))) {
        const U = d.getBookmark();
        v.collapse(!0);
        let Z = qp(e.dom, v, p);
        Z = Zn(Z), e.formatter.apply(n, s, Z), d.moveToBookmark(U);
      } else {
        let U = l ? DD(l) : null;
        (!l || (U == null ? void 0 : U.data) !== KC) && (l = fW(e.getDoc(), fT(!0).dom), U = l.firstChild, v.insertNode(l), S = 1), e.formatter.apply(n, s, l), d.setCursorLocation(U, S);
      }
    }, MD = (e, n, s, l) => {
      const d = e.dom, p = e.selection;
      let v = !1;
      const S = e.formatter.get(n);
      if (!S)
        return;
      const O = p.getRng(), M = O.startContainer, j = O.startOffset;
      let U = M;
      Zt(M) && (j !== M.data.length && (v = !0), U = U.parentNode);
      const Z = [];
      let de;
      for (; U; ) {
        if (nh(e, U, n, s, l)) {
          de = U;
          break;
        }
        U.nextSibling && (v = !0), Z.push(U), U = U.parentNode;
      }
      if (de)
        if (v) {
          const we = p.getBookmark();
          O.collapse(!0);
          let me = qp(d, O, S, !0);
          me = Zn(me), e.formatter.remove(n, s, me, l), p.moveToBookmark(we);
        } else {
          const we = pg(e.getBody(), de), me = je(we) ? d.getParents(de.parentNode, mt, we) : [], Se = fT(!1).dom;
          pW(e, Se, we ?? de);
          const ze = hW(e, Se, de, n, s, l), Ye = Ad([
            ...Z,
            ...ze.toArray(),
            ...me
          ], Se);
          we && RD(e, we, je(we)), p.setCursorLocation(Ye, 1), d.isEmpty(de) && d.remove(de);
        }
    }, ID = (e, n, s) => {
      const l = e.selection, d = e.getBody();
      mT(e, null, s), (n === 8 || n === 46) && l.isCollapsed() && l.getStart().innerHTML === KC && mT(e, pg(d, l.getStart()), !0), (n === 37 || n === 39) && mT(e, pg(d, l.getStart()), !0);
    }, l$ = (e) => Zt(e) && rr(e.data, Xa), c$ = (e) => {
      e.on("mouseup keydown", (n) => {
        ID(e, n.keyCode, l$(e.selection.getRng().endContainer));
      });
    }, u$ = (e) => {
      const n = fT(!1), s = Ad(e, n.dom);
      return {
        caretContainer: n,
        caretPosition: vt(s, 0)
      };
    }, d$ = (e, n) => {
      const { caretContainer: s, caretPosition: l } = u$(n);
      return Ki(Me.fromDom(e), s), ys(Me.fromDom(e)), l;
    }, FD = (e, n) => {
      const { caretContainer: s, caretPosition: l } = u$(n);
      return e.insertNode(s.dom), l;
    }, BD = (e, n) => {
      if (bu(n.dom))
        return !1;
      const s = e.schema.getTextInlineElements();
      return Xn(s, gr(n)) && !bu(n.dom) && !_m(n.dom);
    }, xu = {}, f$ = du(["pre"]), gW = (e, n) => {
      xu[e] || (xu[e] = []), xu[e].push(n);
    }, vae = (e, n) => {
      Xn(xu, e) && Ue(xu[e], (s) => {
        s(n);
      });
    };
    gW("pre", (e) => {
      const n = e.selection.getRng(), s = (d) => (p) => {
        const v = p.previousSibling;
        return f$(v) && At(d, v);
      }, l = (d, p) => {
        const v = Me.fromDom(p), S = Ka(v).dom;
        ys(v), pd(Me.fromDom(d), [
          Me.fromTag("br", S),
          Me.fromTag("br", S),
          ...Ya(v)
        ]);
      };
      if (!n.collapsed) {
        const d = e.selection.getSelectedBlocks(), p = xn(xn(d, f$), s(d));
        Ue(p, (v) => {
          l(v.previousSibling, v);
        });
      }
    });
    const pT = [
      "fontWeight",
      "fontStyle",
      "color",
      "fontSize",
      "fontFamily"
    ], bW = (e) => ve(e.styles) && $n(Zo(e.styles), (n) => At(pT, n)), yae = (e) => Pn(e, (n) => Bi(n) && n.inline === "span" && bW(n)), m$ = (e, n) => {
      const s = e.get(n);
      return Xe(s) ? yae(s) : Y.none();
    }, hT = (e, n) => Xc(n, vt.fromRangeStart(e)).isNone(), em = (e, n) => Hl(n, vt.fromRangeEnd(e)).exists((s) => !Wr(s.getNode()) || Hl(n, s).isSome()) === !1, gT = (e) => (n) => Nw(n) && e.isEditable(n), bT = (e) => {
      const n = e.getSelectedBlocks(), s = e.getRng();
      if (e.isCollapsed())
        return [];
      if (n.length === 1)
        return hT(s, n[0]) && em(s, n[0]) ? n : [];
      {
        const l = pn(n).filter((v) => hT(s, v)).toArray(), d = Oo(n).filter((v) => em(s, v)).toArray(), p = n.slice(1, -1);
        return l.concat(p).concat(d);
      }
    }, $D = (e) => xn(bT(e), gT(e.dom)), p$ = (e) => xn(e.getSelectedBlocks(), gT(e.dom)), vT = Gt.each, LD = (e) => On(e) && !vu(e) && !bu(e) && !_m(e), HD = (e, n) => {
      for (let s = e; s; s = s[n]) {
        if (Zt(s) && ko(s.data))
          return e;
        if (On(s) && !vu(s))
          return s;
      }
      return e;
    }, yT = (e, n, s) => {
      const l = HC(e), d = kc(n) && e.dom.isEditable(n), p = kc(s) && e.dom.isEditable(s);
      if (d && p) {
        const v = HD(n, "previousSibling"), S = HD(s, "nextSibling");
        if (l.compare(v, S)) {
          for (let O = v.nextSibling; O && O !== S; ) {
            const M = O;
            O = O.nextSibling, v.appendChild(M);
          }
          return e.dom.remove(S), Gt.each(Gt.grep(S.childNodes), (O) => {
            v.appendChild(O);
          }), v;
        }
      }
      return s;
    }, h$ = (e, n, s, l) => {
      var d;
      if (l && n.merge_siblings !== !1) {
        const p = (d = yT(e, l1(l), l)) !== null && d !== void 0 ? d : l;
        yT(e, p, l1(p, !0));
      }
    }, g$ = (e, n, s) => {
      if (n.clear_child_styles) {
        const l = n.links ? "*:not(a)" : "*";
        vT(e.select(l, s), (d) => {
          LD(d) && e.isEditable(d) && vT(n.styles, (p, v) => {
            e.setStyle(d, v, "");
          });
        });
      }
    }, zD = (e, n, s) => {
      vT(e.childNodes, (l) => {
        LD(l) && (n(l) && s(l), l.hasChildNodes() && zD(l, n, s));
      });
    }, R1 = (e, n) => {
      n.nodeName === "SPAN" && e.getAttribs(n).length === 0 && e.remove(n, !0);
    }, VD = (e, n) => (s) => !!(s && Hy(e, s, n)), b$ = (e, n, s) => (l) => {
      e.setStyle(l, n, s), l.getAttribute("style") === "" && l.removeAttribute("style"), R1(e, l);
    }, Kb = ss.generate([
      { keep: [] },
      { rename: ["name"] },
      { removed: [] }
    ]), vW = /^(src|href|style)$/, jD = Gt.each, xT = Ly, yW = (e) => /^(TR|TH|TD)$/.test(e.nodeName), v$ = (e, n, s) => e.isChildOf(n, s) && n !== s && !e.isBlock(s), UD = (e, n, s) => {
      let l = n[s ? "startContainer" : "endContainer"], d = n[s ? "startOffset" : "endOffset"];
      if (On(l)) {
        const p = l.childNodes.length - 1;
        !s && d && d--, l = l.childNodes[d > p ? p : d];
      }
      return Zt(l) && s && d >= l.data.length && (l = new Ri(l, e.getBody()).next() || l), Zt(l) && !s && d === 0 && (l = new Ri(l, e.getBody()).prev() || l), l;
    }, y$ = (e, n) => {
      const s = n ? "firstChild" : "lastChild", l = e[s];
      return yW(e) && l ? e.nodeName === "TR" && l[s] || l : e;
    }, YC = (e, n, s, l) => {
      var d;
      const p = e.create(s, l);
      return (d = n.parentNode) === null || d === void 0 || d.insertBefore(p, n), p.appendChild(n), p;
    }, Yb = (e, n, s, l, d) => {
      const p = Me.fromDom(n), v = Me.fromDom(e.create(l, d)), S = s ? qi(p) : lp(p);
      return pd(v, S), s ? (Ki(p, v), Cm(v, p)) : (Jl(p, v), Ys(v, p)), v.dom;
    }, xW = (e, n) => n.links && e.nodeName === "A", x$ = (e, n, s) => {
      const l = n.parentNode;
      let d;
      const p = e.dom, v = Pl(e);
      Hm(s) && l === p.getRoot() && (!s.list_block || !xT(n, s.list_block)) && Ue(hr(n.childNodes), (S) => {
        Lm(e, v, S.nodeName.toLowerCase()) ? d ? d.appendChild(S) : (d = YC(p, S, v), p.setAttribs(d, $p(e))) : d = null;
      }), !(cP(s) && !xT(s.inline, n)) && p.remove(n, !0);
    }, XC = (e, n, s) => dn(e) ? {
      name: n,
      value: null
    } : {
      name: e,
      value: vg(n, s)
    }, WD = (e, n) => {
      e.getAttrib(n, "style") === "" && (n.removeAttribute("style"), n.removeAttribute("data-mce-style"));
    }, ZD = (e, n, s, l, d) => {
      let p = !1;
      jD(s.styles, (v, S) => {
        const {
          name: O,
          value: M
        } = XC(S, v, l), j = yg(M, O);
        (s.remove_similar || te(M) || !On(d) || xT(Hy(e, d, O), j)) && e.setStyle(n, O, ""), p = !0;
      }), p && WD(e, n);
    }, wW = (e, n, s) => {
      n === "removeformat" ? Ue(p$(e.selection), (l) => {
        Ue(pT, (d) => e.dom.setStyle(l, d, "")), WD(e.dom, l);
      }) : m$(e.formatter, n).each((l) => {
        Ue(p$(e.selection), (d) => ZD(e.dom, d, l, s, null));
      });
    }, GD = (e, n, s, l, d) => {
      const p = e.dom, v = HC(e), S = e.schema;
      if (Bi(n) && xd(S, n.inline) && Lu(S, l) && l.parentElement === e.getBody())
        return x$(e, l, n), Kb.removed();
      if (!n.ceFalseOverride && l && p.getContentEditableParent(l) === "false" || l && !GC(p, l, n) && !xW(l, n))
        return Kb.keep();
      const O = l, M = n.preserve_attributes;
      if (Bi(n) && n.remove === "all" && Xe(M)) {
        const j = xn(p.getAttribs(O), (U) => At(M, U.name.toLowerCase()));
        if (p.removeAllAttribs(O), Ue(j, (U) => p.setAttrib(O, U.name, U.value)), j.length > 0)
          return Kb.rename("span");
      }
      if (n.remove !== "all") {
        ZD(p, O, n, s, d), jD(n.attributes, (U, Z) => {
          const {
            name: de,
            value: we
          } = XC(Z, U, s);
          if (n.remove_similar || te(we) || !On(d) || xT(p.getAttrib(d, de), we)) {
            if (de === "class") {
              const me = p.getAttrib(O, de);
              if (me) {
                let Se = "";
                if (Ue(me.split(/\s+/), (ze) => {
                  /mce\-\w+/.test(ze) && (Se += (Se ? " " : "") + ze);
                }), Se) {
                  p.setAttrib(O, de, Se);
                  return;
                }
              }
            }
            if (vW.test(de) && O.removeAttribute("data-mce-" + de), de === "style" && du(["li"])(O) && p.getStyle(O, "list-style-type") === "none") {
              O.removeAttribute(de), p.setStyle(O, "list-style-type", "none");
              return;
            }
            de === "class" && O.removeAttribute("className"), O.removeAttribute(de);
          }
        }), jD(n.classes, (U) => {
          U = vg(U, s), (!On(d) || p.hasClass(d, U)) && p.removeClass(O, U);
        });
        const j = p.getAttribs(O);
        for (let U = 0; U < j.length; U++) {
          const Z = j[U].nodeName;
          if (!v.isAttributeInternal(Z))
            return Kb.keep();
        }
      }
      return n.remove !== "none" ? (x$(e, O, n), Kb.removed()) : Kb.keep();
    }, CW = (e, n, s, l, d) => {
      let p;
      return n.parentNode && Ue(zb(e.dom, n.parentNode).reverse(), (v) => {
        if (!p && On(v) && v.id !== "_start" && v.id !== "_end") {
          const S = nh(e, v, s, l, d);
          S && S.split !== !1 && (p = v);
        }
      }), p;
    }, N1 = (e, n, s, l) => GD(e, n, s, l, l).fold(dt(l), (d) => (e.dom.createFragment().appendChild(l), e.dom.rename(l, d)), dt(null)), w$ = (e, n, s, l, d, p, v, S) => {
      var O, M;
      let j, U;
      const Z = e.dom;
      if (s) {
        const de = s.parentNode;
        for (let we = l.parentNode; we && we !== de; we = we.parentNode) {
          let me = Z.clone(we, !1);
          for (let Se = 0; Se < n.length && (me = N1(e, n[Se], S, me), me !== null); Se++)
            ;
          me && (j && me.appendChild(j), U || (U = me), j = me);
        }
        (!v.mixed || !Z.isBlock(s)) && (l = (O = Z.split(s, l)) !== null && O !== void 0 ? O : l), j && U && ((M = d.parentNode) === null || M === void 0 || M.insertBefore(j, d), U.appendChild(d), Bi(v) && h$(e, v, S, j));
      }
      return l;
    }, C$ = (e, n, s, l, d) => {
      const p = e.formatter.get(n), v = p[0], S = e.dom, O = e.selection, M = (me) => {
        const Se = CW(e, me, n, s, d);
        return w$(e, p, Se, me, me, !0, v, s);
      }, j = (me) => vu(me) && On(me) && (me.id === "_start" || me.id === "_end"), U = (me) => $n(p, (Se) => Xb(e, Se, s, me, me)), Z = (me) => {
        const Se = hr(me.childNodes), Ye = U(me) || $n(p, (zt) => GC(S, me, zt)), We = me.parentNode;
        if (!Ye && je(We) && ff(v) && U(We), v.deep && Se.length)
          for (let zt = 0; zt < Se.length; zt++)
            Z(Se[zt]);
        Ue([
          "underline",
          "line-through",
          "overline"
        ], (zt) => {
          On(me) && e.dom.getStyle(me, "text-decoration") === zt && me.parentNode && hE(S, me.parentNode) === zt && Xb(e, {
            deep: !1,
            exact: !0,
            inline: "span",
            styles: { textDecoration: zt }
          }, void 0, me);
        });
      }, de = (me) => {
        const Se = S.get(me ? "_start" : "_end");
        if (Se) {
          let ze = Se[me ? "firstChild" : "lastChild"];
          return j(ze) && (ze = ze[me ? "firstChild" : "lastChild"]), Zt(ze) && ze.data.length === 0 && (ze = me ? Se.previousSibling || Se.nextSibling : Se.nextSibling || Se.previousSibling), S.remove(Se, !0), ze;
        } else
          return null;
      }, we = (me) => {
        let Se, ze, Ye = qp(S, me, p, me.collapsed);
        if (v.split) {
          if (Ye = Zn(Ye), Se = UD(e, Ye, !0), ze = UD(e, Ye), Se !== ze) {
            if (Se = y$(Se, !0), ze = y$(ze, !1), v$(S, Se, ze)) {
              const ut = Y.from(Se.firstChild).getOr(Se);
              M(Yb(S, ut, !0, "span", {
                id: "_start",
                "data-mce-type": "bookmark"
              })), de(!0);
              return;
            }
            if (v$(S, ze, Se)) {
              const ut = Y.from(ze.lastChild).getOr(ze);
              M(Yb(S, ut, !1, "span", {
                id: "_end",
                "data-mce-type": "bookmark"
              })), de(!1);
              return;
            }
            Se = YC(S, Se, "span", {
              id: "_start",
              "data-mce-type": "bookmark"
            }), ze = YC(S, ze, "span", {
              id: "_end",
              "data-mce-type": "bookmark"
            });
            const We = S.createRng();
            We.setStartAfter(Se), We.setEndBefore(ze), f1(S, We, (ut) => {
              Ue(ut, (zt) => {
                !vu(zt) && !vu(zt.parentNode) && M(zt);
              });
            }), M(Se), M(ze), Se = de(!0), ze = de();
          } else
            Se = ze = M(Se);
          Ye.startContainer = Se.parentNode ? Se.parentNode : Se, Ye.startOffset = S.nodeIndex(Se), Ye.endContainer = ze.parentNode ? ze.parentNode : ze, Ye.endOffset = S.nodeIndex(ze) + 1;
        }
        f1(S, Ye, (We) => {
          Ue(We, Z);
        });
      };
      if (l) {
        if (Hb(l)) {
          const me = S.createRng();
          me.setStartBefore(l), me.setEndAfter(l), we(me);
        } else
          we(l);
        yu(e, n, l, s);
        return;
      }
      !O.isCollapsed() || !Bi(v) || Bb(e).length ? (Kf(e, () => Lb(e, we), (me) => Bi(v) && PD(e, n, s, me)), e.nodeChanged()) : MD(e, n, s, d), wW(e, n, s), yu(e, n, l, s);
    }, qD = (e, n, s, l, d) => {
      (l || e.selection.isEditable()) && C$(e, n, s, l, d);
    }, Xb = (e, n, s, l, d) => GD(e, n, s, l, d).fold(tt, (p) => (e.dom.rename(l, p), !0), mt), KD = Gt.each, SW = (e, n, s, l) => {
      const d = (p) => {
        if (kc(p) && On(p.parentNode) && e.isEditable(p)) {
          const v = hE(e, p.parentNode);
          e.getStyle(p, "color") && v ? e.setStyle(p, "text-decoration", v) : e.getStyle(p, "text-decoration") === v && e.setStyle(p, "text-decoration", null);
        }
      };
      n.styles && (n.styles.color || n.styles.textDecoration) && (Gt.walk(l, d, "childNodes"), d(l));
    }, S$ = (e, n, s, l) => {
      if (n.styles && n.styles.backgroundColor) {
        const d = VD(e, "fontSize");
        zD(l, (p) => d(p) && e.isEditable(p), b$(e, "backgroundColor", vg(n.styles.backgroundColor, s)));
      }
    }, kW = (e, n, s, l) => {
      if (Bi(n) && (n.inline === "sub" || n.inline === "sup")) {
        const d = VD(e, "fontSize");
        zD(l, (v) => d(v) && e.isEditable(v), b$(e, "fontSize", ""));
        const p = xn(e.select(n.inline === "sup" ? "sub" : "sup", l), e.isEditable);
        e.remove(p, !0);
      }
    }, _W = (e, n, s, l) => {
      KD(n, (d) => {
        Bi(d) && KD(e.dom.select(d.inline, l), (p) => {
          LD(p) && Xb(e, d, s, p, d.exact ? p : null);
        }), g$(e.dom, d, l);
      });
    }, wT = (e, n, s, l, d) => {
      const p = d.parentNode;
      nh(e, p, s, l) && Xb(e, n, l, d) || n.merge_with_parents && p && e.dom.getParent(p, (v) => nh(e, v, s, l) ? (Xb(e, n, l, d), !0) : !1);
    }, QC = Gt.each, YD = (e, n, s, l) => {
      if (N_(e) && Bi(n) && s.parentNode) {
        const d = I0(e.schema), p = P0(Me.fromDom(s), (v) => bu(v.dom));
        return Ss(d, l) && $u(e.schema, s.parentNode, {
          skipBogus: !1,
          includeZwsp: !0
        }) && !p;
      } else
        return !1;
    }, k$ = (e, n, s, l) => {
      if (QC(s.styles, (d, p) => {
        e.setStyle(n, p, vg(d, l));
      }), s.styles) {
        const d = e.getAttrib(n, "style");
        d && e.setAttrib(n, "data-mce-style", d);
      }
    }, EW = (e, n, s, l) => {
      const d = e.formatter.get(n), p = d[0], v = !l && e.selection.isCollapsed(), S = e.dom, O = e.selection, M = (we, me = p) => {
        ye(me.onformat) && me.onformat(we, me, s, l), k$(S, we, me, s), QC(me.attributes, (Se, ze) => {
          S.setAttrib(we, ze, vg(Se, s));
        }), QC(me.classes, (Se) => {
          const ze = vg(Se, s);
          S.hasClass(we, ze) || S.addClass(we, ze);
        });
      }, j = (we, me) => {
        let Se = !1;
        return QC(we, (ze) => Wu(ze) ? S.getContentEditable(me) === "false" && !ze.ceFalseOverride || je(ze.collapsed) && ze.collapsed !== v ? !0 : S.is(me, ze.selector) && !bu(me) ? (M(me, ze), Se = !0, !1) : !0 : !1), Se;
      }, U = (we) => {
        if (G(we)) {
          const me = S.create(we);
          return M(me), me;
        } else
          return null;
      }, Z = (we, me, Se) => {
        const ze = [];
        let Ye = !0;
        const We = p.inline || p.block, ut = U(We), zt = (Tt) => lP(p) && nh(e, Tt, n, s), an = (Tt, yt, Lt) => {
          const Vn = c1(p) && fC(e.schema, Tt) && Lm(e, yt, We);
          return Lt && Vn;
        }, Dn = (Tt, yt, Lt, Vn) => {
          const co = Tt.nodeName.toLowerCase(), Xo = Lm(e, We, co) && Lm(e, yt, We), Sr = !Se && Zt(Tt) && Qh(Tt.data), ts = bu(Tt), Cs = !Bi(p) || !we.isBlock(Tt);
          return (Lt || Vn) && Xo && !Sr && !ts && Cs;
        };
        f1(we, me, (Tt) => {
          let yt;
          const Lt = (Vn) => {
            let co = !1, Xo = Ye, Sr = !1;
            const ts = Vn.parentNode, Cs = ts.nodeName.toLowerCase(), Pa = we.getContentEditable(Vn);
            je(Pa) && (Xo = Ye, Ye = Pa === "true", co = !0, Sr = hC(e, Vn));
            const yl = Ye && !co;
            if (Wr(Vn) && !YD(e, p, Vn, Cs)) {
              yt = null, Hm(p) && we.remove(Vn);
              return;
            }
            if (zt(Vn)) {
              yt = null;
              return;
            }
            if (an(Vn, Cs, yl)) {
              const bs = we.rename(Vn, We);
              M(bs), ze.push(bs), yt = null;
              return;
            }
            if (Wu(p)) {
              let bs = j(d, Vn);
              if (!bs && je(ts) && ff(p) && (bs = j(d, ts)), !Bi(p) || bs) {
                yt = null;
                return;
              }
            }
            je(ut) && Dn(Vn, Cs, yl, Sr) ? (yt || (yt = we.clone(ut, !1), ts.insertBefore(yt, Vn), ze.push(yt)), Sr && co && (Ye = Xo), yt.appendChild(Vn)) : (yt = null, Ue(hr(Vn.childNodes), Lt), co && (Ye = Xo), yt = null);
          };
          Ue(Tt, Lt);
        }), p.links === !0 && Ue(ze, (Tt) => {
          const yt = (Lt) => {
            Lt.nodeName === "A" && M(Lt, p), Ue(hr(Lt.childNodes), yt);
          };
          yt(Tt);
        }), Ue(ze, (Tt) => {
          const yt = (co) => {
            let Xo = 0;
            return Ue(co.childNodes, (Sr) => {
              !$y(Sr) && !vu(Sr) && Xo++;
            }), Xo;
          }, Lt = (co) => Pn(co.childNodes, dC).filter((Sr) => we.getContentEditable(Sr) !== "false" && GC(we, Sr, p)).map((Sr) => {
            const ts = we.clone(Sr, !1);
            return M(ts), we.replace(ts, co, !0), we.remove(Sr, !0), ts;
          }).getOr(co), Vn = yt(Tt);
          if ((ze.length > 1 || !we.isBlock(Tt)) && Vn === 0) {
            we.remove(Tt, !0);
            return;
          }
          (Bi(p) || Hm(p) && p.wrapper) && (!p.exact && Vn === 1 && (Tt = Lt(Tt)), _W(e, d, s, Tt), wT(e, p, n, s, Tt), S$(we, p, s, Tt), SW(we, p, s, Tt), kW(we, p, s, Tt), h$(e, p, s, Tt));
        });
      }, de = Hb(l) ? l : O.getNode();
      if (S.getContentEditable(de) === "false" && !hC(e, de)) {
        l = de, j(d, l), Gu(e, n, l, s);
        return;
      }
      if (p) {
        if (l)
          if (Hb(l)) {
            if (!j(d, l)) {
              const we = S.createRng();
              we.setStartBefore(l), we.setEndAfter(l), Z(S, qp(S, we, d), !0);
            }
          } else
            Z(S, l, !0);
        else
          !v || !Bi(p) || Bb(e).length ? (O.setRng(Zs(O.getRng())), Kf(e, () => {
            Lb(e, (we, me) => {
              const Se = me ? we : qp(S, we, d);
              Z(S, Se, !1);
            });
          }, mt), e.nodeChanged()) : i$(e, n, s), m$(e.formatter, n).each((we) => {
            Ue($D(e.selection), (me) => k$(S, me, we, s));
          });
        vae(n, e);
      }
      Gu(e, n, l, s);
    }, XD = (e, n, s, l) => {
      (l || e.selection.isEditable()) && EW(e, n, s, l);
    }, CT = (e) => Xn(e, "vars"), _$ = (e, n) => {
      e.set({}), n.on("NodeChange", (s) => {
        JC(n, s.element, e.get());
      }), n.on("FormatApply FormatRemove", (s) => {
        const l = Y.from(s.node).map((d) => Hb(d) ? d : d.startContainer).bind((d) => On(d) ? Y.some(d) : Y.from(d.parentElement)).getOrThunk(() => E$(n));
        JC(n, l, e.get());
      });
    }, E$ = (e) => e.selection.getStart(), T$ = (e, n, s, l, d) => Jn(n, (S) => {
      const O = e.formatter.matchNode(S, s, d ?? {}, l);
      return !ot(O);
    }, (S) => AD(e, S, s) ? !0 : l ? !1 : je(e.formatter.matchNode(S, s, d, !0))), O$ = (e, n) => {
      const s = n ?? E$(e);
      return xn(zb(e.dom, s), (l) => On(l) && !_m(l));
    }, JC = (e, n, s) => {
      const l = O$(e, n);
      Ht(s, (d, p) => {
        const v = (S) => {
          const O = T$(e, l, p, S.similar, CT(S) ? S.vars : void 0), M = O.isSome();
          if (S.state.get() !== M) {
            S.state.set(M);
            const j = O.getOr(n);
            CT(S) ? S.callback(M, {
              node: j,
              format: p,
              parents: l
            }) : Ue(S.callbacks, (U) => U(M, {
              node: j,
              format: p,
              parents: l
            }));
          }
        };
        Ue([
          d.withSimilar,
          d.withoutSimilar
        ], v), Ue(d.withVars, v);
      });
    }, Tg = (e, n, s, l, d, p) => {
      const v = n.get();
      Ue(s.split(","), (S) => {
        const O = Or(v, S).getOrThunk(() => {
          const j = {
            withSimilar: {
              state: Qe(!1),
              similar: !0,
              callbacks: []
            },
            withoutSimilar: {
              state: Qe(!1),
              similar: !1,
              callbacks: []
            },
            withVars: []
          };
          return v[S] = j, j;
        }), M = () => {
          const j = O$(e);
          return T$(e, j, S, d, p).isSome();
        };
        if (ot(p)) {
          const j = d ? O.withSimilar : O.withoutSimilar;
          j.callbacks.push(l), j.callbacks.length === 1 && j.state.set(M());
        } else
          O.withVars.push({
            state: Qe(M()),
            similar: d,
            vars: p,
            callback: l
          });
      }), n.set(v);
    }, TW = (e, n, s) => {
      const l = e.get();
      Ue(n.split(","), (d) => Or(l, d).each((p) => {
        l[d] = {
          withSimilar: {
            ...p.withSimilar,
            callbacks: xn(p.withSimilar.callbacks, (v) => v !== s)
          },
          withoutSimilar: {
            ...p.withoutSimilar,
            callbacks: xn(p.withoutSimilar.callbacks, (v) => v !== s)
          },
          withVars: xn(p.withVars, (v) => v.callback !== s)
        };
      })), e.set(l);
    }, QD = (e, n, s, l, d, p) => (Tg(e, n, s, l, d, p), { unbind: () => TW(n, s, l) }), oi = (e, n, s, l) => {
      const d = e.formatter.get(n);
      d && (PD(e, n, s, l) && (!("toggle" in d[0]) || d[0].toggle) ? qD(e, n, s, l) : XD(e, n, s, l));
    }, ST = Gt.explode, kT = () => {
      const e = {};
      return {
        addFilter: (d, p) => {
          Ue(ST(d), (v) => {
            Xn(e, v) || (e[v] = {
              name: v,
              callbacks: []
            }), e[v].callbacks.push(p);
          });
        },
        getFilters: () => ca(e),
        removeFilter: (d, p) => {
          Ue(ST(d), (v) => {
            if (Xn(e, v))
              if (je(p)) {
                const S = e[v], O = xn(S.callbacks, (M) => M !== p);
                O.length > 0 ? S.callbacks = O : delete e[v];
              } else
                delete e[v];
          });
        }
      };
    }, Og = (e, n) => {
      Ue(n, (s) => {
        e.attr(s, null);
      });
    }, A$ = (e, n, s) => {
      e.addNodeFilter("font", (l) => {
        Ue(l, (d) => {
          const p = n.parse(d.attr("style")), v = d.attr("color"), S = d.attr("face"), O = d.attr("size");
          v && (p.color = v), S && (p["font-family"] = S), O && Ba(O).each((M) => {
            p["font-size"] = s[M - 1];
          }), d.name = "span", d.attr("style", n.serialize(p)), Og(d, [
            "color",
            "face",
            "size"
          ]);
        });
      });
    }, P$ = (e, n, s) => {
      e.addNodeFilter("strike", (l) => {
        const d = n.type !== "html4";
        Ue(l, (p) => {
          if (d)
            p.name = "s";
          else {
            const v = s.parse(p.attr("style"));
            v["text-decoration"] = "line-through", p.name = "span", p.attr("style", s.serialize(v));
          }
        });
      });
    }, eS = (e, n, s) => {
      var l;
      const d = jw();
      n.convert_fonts_to_spans && A$(e, d, Gt.explode((l = n.font_size_legacy_values) !== null && l !== void 0 ? l : "")), P$(e, s, d);
    }, OW = (e, n, s) => {
      n.inline_styles && eS(e, n, s);
    }, AW = (e) => fetch(e).then((n) => n.ok ? n.blob() : Promise.reject()).catch(() => Promise.reject({
      message: `Cannot convert ${e} to Blob. Resource might not exist or is inaccessible.`,
      uriType: "blob"
    })), px = (e) => {
      const n = /([a-z0-9+\/=\s]+)/i.exec(e);
      return n ? n[1] : "";
    }, JD = (e) => {
      const [n, ...s] = e.split(","), l = s.join(","), d = /data:([^/]+\/[^;]+)(;.+)?/.exec(n);
      if (d) {
        const p = d[2] === ";base64", v = p ? px(l) : decodeURIComponent(l);
        return Y.some({
          type: d[1],
          data: v,
          base64Encoded: p
        });
      } else
        return Y.none();
    }, Qb = (e, n, s = !0) => {
      let l = n;
      if (s)
        try {
          l = atob(n);
        } catch {
          return Y.none();
        }
      const d = new Uint8Array(l.length);
      for (let p = 0; p < d.length; p++)
        d[p] = l.charCodeAt(p);
      return Y.some(new Blob([d], { type: e }));
    }, PW = (e) => new Promise((n, s) => {
      JD(e).bind(({ type: l, data: d, base64Encoded: p }) => Qb(l, d, p)).fold(() => s("Invalid data URI"), n);
    }), Jb = (e) => lo(e, "blob:") ? AW(e) : lo(e, "data:") ? PW(e) : Promise.reject("Unknown URI format"), D$ = (e) => new Promise((n, s) => {
      const l = new FileReader();
      l.onloadend = () => {
        n(l.result);
      }, l.onerror = () => {
        var d;
        s((d = l.error) === null || d === void 0 ? void 0 : d.message);
      }, l.readAsDataURL(e);
    });
    let pf = 0;
    const tS = (e) => "blobid" + pf++, _T = (e, n, s) => JD(e).bind(({ data: l, type: d, base64Encoded: p }) => {
      if (n && !p)
        return Y.none();
      {
        const v = p ? l : btoa(l);
        return s(v, d);
      }
    }), ET = (e, n, s) => {
      const l = e.create(tS(), n, s);
      return e.add(l), l;
    }, R$ = (e, n, s = !1) => _T(n, s, (l, d) => Y.from(e.getByData(l, d)).orThunk(() => Qb(d, l).map((p) => ET(e, p, l)))), TT = (e, n) => {
      const s = () => Promise.reject("Invalid data URI");
      if (lo(n, "blob:")) {
        const l = e.getByUri(n);
        return je(l) ? Promise.resolve(l) : Jb(n).then((d) => D$(d).then((p) => _T(p, !1, (v) => Y.some(ET(e, d, v))).getOrThunk(s)));
      } else return lo(n, "data:") ? R$(e, n).fold(s, (l) => Promise.resolve(l)) : Promise.reject("Unknown image data format");
    }, DW = /^(?:(?:(?:[A-Za-z][A-Za-z\d.+-]{0,14}:\/\/(?:[-.~*+=!&;:'%@?^${}(),\w]+@)?|www\.|[-;:&=+$,.\w]+@)([A-Za-z\d-]+(?:\.[A-Za-z\d-]+)*))(?::\d+)?(?:\/(?:[-.~*+=!;:'%@$(),\/\w]*[-~*+=%@$()\/\w])?)?(?:\?(?:[-.~*+=!&;:'%@?^${}(),\/\w]+)?)?(?:#(?:[-.~*+=!&;:'%@?^${}(),\/\w]+)?)?)$/, tm = (e) => Y.from(e.match(DW)).bind((n) => yn(n, 1)).map((n) => lo(n, "www.") ? n.substring(4) : n), nS = (e, n) => {
      Y.from(e.attr("src")).bind(tm).forall((s) => !At(n, s)) && e.attr("sandbox", "");
    }, OT = (e, n) => lo(e, `${n}/`), eR = (e) => ot(e) ? "iframe" : OT(e, "image") ? "img" : OT(e, "video") ? "video" : OT(e, "audio") ? "audio" : "iframe", tR = ({ type: e, src: n, width: s, height: l } = {}, d, p) => {
      const v = eR(e), S = new eu(v, 1);
      return S.attr(v === "audio" ? { src: n } : {
        src: n,
        width: s,
        height: l
      }), (v === "audio" || v === "video") && S.attr("controls", ""), v === "iframe" && d && nS(S, p), S;
    }, M1 = (e) => je(e.attr("data-mce-bogus")), nR = (e) => e.attr("src") === rn.transparentSrc || je(e.attr("data-mce-placeholder")), RW = (e, n) => {
      const { blob_cache: s } = n;
      if (s) {
        const l = (d) => {
          const p = d.attr("src");
          nR(d) || M1(d) || Kt(p) || R$(s, p, !0).each((v) => {
            d.attr("src", v.blobUri());
          });
        };
        e.addAttributeFilter("src", (d) => Ue(d, l));
      }
    }, N$ = (e, n) => {
      var s, l;
      const d = e.schema;
      e.addAttributeFilter("href", (O) => {
        let M = O.length;
        const j = (Z) => Z.split(" ").filter((we) => we.length > 0).concat(["noopener"]).sort().join(" "), U = (Z) => {
          const de = Z ? Gt.trim(Z) : "";
          return /\b(noopener)\b/g.test(de) ? de : j(de);
        };
        if (!n.allow_unsafe_link_target)
          for (; M--; ) {
            const Z = O[M];
            Z.name === "a" && Z.attr("target") === "_blank" && Z.attr("rel", U(Z.attr("rel")));
          }
      }), n.allow_html_in_named_anchor || e.addAttributeFilter("id,name", (O) => {
        let M = O.length, j, U, Z, de;
        for (; M--; )
          if (de = O[M], de.name === "a" && de.firstChild && !de.attr("href"))
            for (Z = de.parent, j = de.lastChild; j && Z; )
              U = j.prev, Z.insert(j, de), j = U;
      }), n.fix_list_elements && e.addNodeFilter("ul,ol", (O) => {
        let M = O.length, j, U;
        for (; M--; )
          if (j = O[M], U = j.parent, U && (U.name === "ul" || U.name === "ol"))
            if (j.prev && j.prev.name === "li")
              j.prev.append(j);
            else {
              const Z = new eu("li", 1);
              Z.attr("style", "list-style-type: none"), j.wrap(Z);
            }
      });
      const p = d.getValidClasses();
      n.validate && p && e.addAttributeFilter("class", (O) => {
        var M;
        let j = O.length;
        for (; j--; ) {
          const U = O[j], Z = (M = U.attr("class")) !== null && M !== void 0 ? M : "", de = Gt.explode(Z, " ");
          let we = "";
          for (let me = 0; me < de.length; me++) {
            const Se = de[me];
            let ze = !1, Ye = p["*"];
            Ye && Ye[Se] && (ze = !0), Ye = p[U.name], !ze && Ye && Ye[Se] && (ze = !0), ze && (we && (we += " "), we += Se);
          }
          we.length || (we = null), U.attr("class", we);
        }
      }), RW(e, n);
      const v = (s = n.sandbox_iframes) !== null && s !== void 0 ? s : !1, S = Ir((l = n.sandbox_iframes_exclusions) !== null && l !== void 0 ? l : []);
      n.convert_unsafe_embeds && e.addNodeFilter("object,embed", (O) => Ue(O, (M) => {
        M.replace(tR({
          type: M.attr("type"),
          src: M.name === "object" ? M.attr("data") : M.attr("src"),
          width: M.attr("width"),
          height: M.attr("height")
        }, v, S));
      })), v && e.addNodeFilter("iframe", (O) => Ue(O, (M) => nS(M, S)));
    }, { entries: M$, setPrototypeOf: I$, isFrozen: NW, getPrototypeOf: MW, getOwnPropertyDescriptor: oS } = Object;
    let { freeze: Qu, seal: nm, create: oR } = Object, { apply: rR, construct: AT } = typeof Reflect < "u" && Reflect;
    rR || (rR = function(n, s, l) {
      return n.apply(s, l);
    }), Qu || (Qu = function(n) {
      return n;
    }), nm || (nm = function(n) {
      return n;
    }), AT || (AT = function(n, s) {
      return new n(...s);
    });
    const F$ = om(Array.prototype.forEach), IW = om(Array.prototype.pop), rS = om(Array.prototype.push), PT = om(String.prototype.toLowerCase), sR = om(String.prototype.toString), FW = om(String.prototype.match), Zm = om(String.prototype.replace), BW = om(String.prototype.indexOf), $W = om(String.prototype.trim), hf = om(RegExp.prototype.test), sS = LW(TypeError);
    function om(e) {
      return function(n) {
        for (var s = arguments.length, l = new Array(s > 1 ? s - 1 : 0), d = 1; d < s; d++)
          l[d - 1] = arguments[d];
        return rR(e, n, l);
      };
    }
    function LW(e) {
      return function() {
        for (var n = arguments.length, s = new Array(n), l = 0; l < n; l++)
          s[l] = arguments[l];
        return AT(e, s);
      };
    }
    function Ts(e, n, s) {
      var l;
      s = (l = s) !== null && l !== void 0 ? l : PT, I$ && I$(e, null);
      let d = n.length;
      for (; d--; ) {
        let p = n[d];
        if (typeof p == "string") {
          const v = s(p);
          v !== p && (NW(n) || (n[d] = v), p = v);
        }
        e[p] = !0;
      }
      return e;
    }
    function I1(e) {
      const n = oR(null);
      for (const [s, l] of M$(e))
        n[s] = l;
      return n;
    }
    function DT(e, n) {
      for (; e !== null; ) {
        const l = oS(e, n);
        if (l) {
          if (l.get)
            return om(l.get);
          if (typeof l.value == "function")
            return om(l.value);
        }
        e = MW(e);
      }
      function s(l) {
        return console.warn("fallback value for", l), null;
      }
      return s;
    }
    const F1 = Qu([
      "a",
      "abbr",
      "acronym",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "bdi",
      "bdo",
      "big",
      "blink",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "center",
      "cite",
      "code",
      "col",
      "colgroup",
      "content",
      "data",
      "datalist",
      "dd",
      "decorator",
      "del",
      "details",
      "dfn",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "element",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "font",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "map",
      "mark",
      "marquee",
      "menu",
      "menuitem",
      "meter",
      "nav",
      "nobr",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "section",
      "select",
      "shadow",
      "small",
      "source",
      "spacer",
      "span",
      "strike",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "template",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "track",
      "tt",
      "u",
      "ul",
      "var",
      "video",
      "wbr"
    ]), aR = Qu([
      "svg",
      "a",
      "altglyph",
      "altglyphdef",
      "altglyphitem",
      "animatecolor",
      "animatemotion",
      "animatetransform",
      "circle",
      "clippath",
      "defs",
      "desc",
      "ellipse",
      "filter",
      "font",
      "g",
      "glyph",
      "glyphref",
      "hkern",
      "image",
      "line",
      "lineargradient",
      "marker",
      "mask",
      "metadata",
      "mpath",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialgradient",
      "rect",
      "stop",
      "style",
      "switch",
      "symbol",
      "text",
      "textpath",
      "title",
      "tref",
      "tspan",
      "view",
      "vkern"
    ]), iR = Qu([
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence"
    ]), HW = Qu([
      "animate",
      "color-profile",
      "cursor",
      "discard",
      "font-face",
      "font-face-format",
      "font-face-name",
      "font-face-src",
      "font-face-uri",
      "foreignobject",
      "hatch",
      "hatchpath",
      "mesh",
      "meshgradient",
      "meshpatch",
      "meshrow",
      "missing-glyph",
      "script",
      "set",
      "solidcolor",
      "unknown",
      "use"
    ]), lR = Qu([
      "math",
      "menclose",
      "merror",
      "mfenced",
      "mfrac",
      "mglyph",
      "mi",
      "mlabeledtr",
      "mmultiscripts",
      "mn",
      "mo",
      "mover",
      "mpadded",
      "mphantom",
      "mroot",
      "mrow",
      "ms",
      "mspace",
      "msqrt",
      "mstyle",
      "msub",
      "msup",
      "msubsup",
      "mtable",
      "mtd",
      "mtext",
      "mtr",
      "munder",
      "munderover",
      "mprescripts"
    ]), B$ = Qu([
      "maction",
      "maligngroup",
      "malignmark",
      "mlongdiv",
      "mscarries",
      "mscarry",
      "msgroup",
      "mstack",
      "msline",
      "msrow",
      "semantics",
      "annotation",
      "annotation-xml",
      "mprescripts",
      "none"
    ]), $$ = Qu(["#text"]), L$ = Qu([
      "accept",
      "action",
      "align",
      "alt",
      "autocapitalize",
      "autocomplete",
      "autopictureinpicture",
      "autoplay",
      "background",
      "bgcolor",
      "border",
      "capture",
      "cellpadding",
      "cellspacing",
      "checked",
      "cite",
      "class",
      "clear",
      "color",
      "cols",
      "colspan",
      "controls",
      "controlslist",
      "coords",
      "crossorigin",
      "datetime",
      "decoding",
      "default",
      "dir",
      "disabled",
      "disablepictureinpicture",
      "disableremoteplayback",
      "download",
      "draggable",
      "enctype",
      "enterkeyhint",
      "face",
      "for",
      "headers",
      "height",
      "hidden",
      "high",
      "href",
      "hreflang",
      "id",
      "inputmode",
      "integrity",
      "ismap",
      "kind",
      "label",
      "lang",
      "list",
      "loading",
      "loop",
      "low",
      "max",
      "maxlength",
      "media",
      "method",
      "min",
      "minlength",
      "multiple",
      "muted",
      "name",
      "nonce",
      "noshade",
      "novalidate",
      "nowrap",
      "open",
      "optimum",
      "pattern",
      "placeholder",
      "playsinline",
      "poster",
      "preload",
      "pubdate",
      "radiogroup",
      "readonly",
      "rel",
      "required",
      "rev",
      "reversed",
      "role",
      "rows",
      "rowspan",
      "spellcheck",
      "scope",
      "selected",
      "shape",
      "size",
      "sizes",
      "span",
      "srclang",
      "start",
      "src",
      "srcset",
      "step",
      "style",
      "summary",
      "tabindex",
      "title",
      "translate",
      "type",
      "usemap",
      "valign",
      "value",
      "width",
      "xmlns",
      "slot"
    ]), cR = Qu([
      "accent-height",
      "accumulate",
      "additive",
      "alignment-baseline",
      "ascent",
      "attributename",
      "attributetype",
      "azimuth",
      "basefrequency",
      "baseline-shift",
      "begin",
      "bias",
      "by",
      "class",
      "clip",
      "clippathunits",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "cx",
      "cy",
      "d",
      "dx",
      "dy",
      "diffuseconstant",
      "direction",
      "display",
      "divisor",
      "dur",
      "edgemode",
      "elevation",
      "end",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "filterunits",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "fx",
      "fy",
      "g1",
      "g2",
      "glyph-name",
      "glyphref",
      "gradientunits",
      "gradienttransform",
      "height",
      "href",
      "id",
      "image-rendering",
      "in",
      "in2",
      "k",
      "k1",
      "k2",
      "k3",
      "k4",
      "kerning",
      "keypoints",
      "keysplines",
      "keytimes",
      "lang",
      "lengthadjust",
      "letter-spacing",
      "kernelmatrix",
      "kernelunitlength",
      "lighting-color",
      "local",
      "marker-end",
      "marker-mid",
      "marker-start",
      "markerheight",
      "markerunits",
      "markerwidth",
      "maskcontentunits",
      "maskunits",
      "max",
      "mask",
      "media",
      "method",
      "mode",
      "min",
      "name",
      "numoctaves",
      "offset",
      "operator",
      "opacity",
      "order",
      "orient",
      "orientation",
      "origin",
      "overflow",
      "paint-order",
      "path",
      "pathlength",
      "patterncontentunits",
      "patterntransform",
      "patternunits",
      "points",
      "preservealpha",
      "preserveaspectratio",
      "primitiveunits",
      "r",
      "rx",
      "ry",
      "radius",
      "refx",
      "refy",
      "repeatcount",
      "repeatdur",
      "restart",
      "result",
      "rotate",
      "scale",
      "seed",
      "shape-rendering",
      "specularconstant",
      "specularexponent",
      "spreadmethod",
      "startoffset",
      "stddeviation",
      "stitchtiles",
      "stop-color",
      "stop-opacity",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke",
      "stroke-width",
      "style",
      "surfacescale",
      "systemlanguage",
      "tabindex",
      "targetx",
      "targety",
      "transform",
      "transform-origin",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "textlength",
      "type",
      "u1",
      "u2",
      "unicode",
      "values",
      "viewbox",
      "visibility",
      "version",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "width",
      "word-spacing",
      "wrap",
      "writing-mode",
      "xchannelselector",
      "ychannelselector",
      "x",
      "x1",
      "x2",
      "xmlns",
      "y",
      "y1",
      "y2",
      "z",
      "zoomandpan"
    ]), H$ = Qu([
      "accent",
      "accentunder",
      "align",
      "bevelled",
      "close",
      "columnsalign",
      "columnlines",
      "columnspan",
      "denomalign",
      "depth",
      "dir",
      "display",
      "displaystyle",
      "encoding",
      "fence",
      "frame",
      "height",
      "href",
      "id",
      "largeop",
      "length",
      "linethickness",
      "lspace",
      "lquote",
      "mathbackground",
      "mathcolor",
      "mathsize",
      "mathvariant",
      "maxsize",
      "minsize",
      "movablelimits",
      "notation",
      "numalign",
      "open",
      "rowalign",
      "rowlines",
      "rowspacing",
      "rowspan",
      "rspace",
      "rquote",
      "scriptlevel",
      "scriptminsize",
      "scriptsizemultiplier",
      "selection",
      "separator",
      "separators",
      "stretchy",
      "subscriptshift",
      "supscriptshift",
      "symmetric",
      "voffset",
      "width",
      "xmlns"
    ]), RT = Qu([
      "xlink:href",
      "xml:id",
      "xlink:title",
      "xml:space",
      "xmlns:xlink"
    ]), zW = nm(/\{\{[\w\W]*|[\w\W]*\}\}/gm), VW = nm(/<%[\w\W]*|[\w\W]*%>/gm), jW = nm(/\${[\w\W]*}/gm), UW = nm(/^data-[\-\w.\u00B7-\uFFFF]/), WW = nm(/^aria-[\-\w]+$/), NT = nm(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), z$ = nm(/^(?:\w+script|data):/i), xae = nm(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), hx = nm(/^html$/i);
    var V$ = Object.freeze({
      __proto__: null,
      MUSTACHE_EXPR: zW,
      ERB_EXPR: VW,
      TMPLIT_EXPR: jW,
      DATA_ATTR: UW,
      ARIA_ATTR: WW,
      IS_ALLOWED_URI: NT,
      IS_SCRIPT_OR_DATA: z$,
      ATTR_WHITESPACE: xae,
      DOCTYPE_NAME: hx
    });
    const j$ = () => typeof window > "u" ? null : window, ZW = function(n, s) {
      if (typeof n != "object" || typeof n.createPolicy != "function")
        return null;
      let l = null;
      const d = "data-tt-policy-suffix";
      s && s.hasAttribute(d) && (l = s.getAttribute(d));
      const p = "dompurify" + (l ? "#" + l : "");
      try {
        return n.createPolicy(p, {
          createHTML(v) {
            return v;
          },
          createScriptURL(v) {
            return v;
          }
        });
      } catch {
        return console.warn("TrustedTypes policy " + p + " could not be created."), null;
      }
    };
    function aS() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : j$();
      const n = (Er) => aS(Er);
      if (n.version = "3.0.5", n.removed = [], !e || !e.document || e.document.nodeType !== 9)
        return n.isSupported = !1, n;
      const s = e.document, l = s.currentScript;
      let { document: d } = e;
      const { DocumentFragment: p, HTMLTemplateElement: v, Node: S, Element: O, NodeFilter: M, NamedNodeMap: j = e.NamedNodeMap || e.MozNamedAttrMap, HTMLFormElement: U, DOMParser: Z, trustedTypes: de } = e, we = O.prototype, me = DT(we, "cloneNode"), Se = DT(we, "nextSibling"), ze = DT(we, "childNodes"), Ye = DT(we, "parentNode");
      if (typeof v == "function") {
        const Er = d.createElement("template");
        Er.content && Er.content.ownerDocument && (d = Er.content.ownerDocument);
      }
      let We, ut = "";
      const { implementation: zt, createNodeIterator: an, createDocumentFragment: Dn, getElementsByTagName: Tt } = d, { importNode: yt } = s;
      let Lt = {};
      n.isSupported = typeof M$ == "function" && typeof Ye == "function" && zt && zt.createHTMLDocument !== void 0;
      const { MUSTACHE_EXPR: Vn, ERB_EXPR: co, TMPLIT_EXPR: Xo, DATA_ATTR: Sr, ARIA_ATTR: ts, IS_SCRIPT_OR_DATA: Cs, ATTR_WHITESPACE: Pa } = V$;
      let { IS_ALLOWED_URI: yl } = V$, bs = null;
      const hn = Ts({}, [
        ...F1,
        ...aR,
        ...iR,
        ...lR,
        ...$$
      ]);
      let ro = null;
      const Ur = Ts({}, [
        ...L$,
        ...cR,
        ...H$,
        ...RT
      ]);
      let Sn = Object.seal(Object.create(null, {
        tagNameCheck: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: null
        },
        attributeNameCheck: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: null
        },
        allowCustomizedBuiltInElements: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: !1
        }
      })), yo = null, fr = null, An = !0, mr = !0, _r = !1, zi = !0, ls = !1, pi = !1, Nd = !1, um = !1, pc = !1, ku = !1, td = !1, _u = !0, Md = !1;
      const uo = "user-content-";
      let $r = !0, ya = !1, Da = {}, ri = null;
      const rl = Ts({}, [
        "annotation-xml",
        "audio",
        "colgroup",
        "desc",
        "foreignobject",
        "head",
        "iframe",
        "math",
        "mi",
        "mn",
        "mo",
        "ms",
        "mtext",
        "noembed",
        "noframes",
        "noscript",
        "plaintext",
        "script",
        "style",
        "svg",
        "template",
        "thead",
        "title",
        "video",
        "xmp"
      ]);
      let Ua = null;
      const Fa = Ts({}, [
        "audio",
        "video",
        "img",
        "source",
        "image",
        "track"
      ]);
      let Ul = null;
      const nd = Ts({}, [
        "alt",
        "class",
        "for",
        "id",
        "label",
        "name",
        "pattern",
        "placeholder",
        "role",
        "summary",
        "title",
        "value",
        "style",
        "xmlns"
      ]), Cf = "http://www.w3.org/1998/Math/MathML", Sf = "http://www.w3.org/2000/svg", Id = "http://www.w3.org/1999/xhtml";
      let mh = Id, l0 = !1, c0 = null;
      const iI = Ts({}, [
        Cf,
        Sf,
        Id
      ], sR);
      let ph;
      const FA = [
        "application/xhtml+xml",
        "text/html"
      ], o9 = "text/html";
      let hc, dv = null;
      const r9 = d.createElement("form"), BA = function(t) {
        return t instanceof RegExp || t instanceof Function;
      }, kf = function(t) {
        if (!(dv && dv === t)) {
          if ((!t || typeof t != "object") && (t = {}), t = I1(t), ph = FA.indexOf(t.PARSER_MEDIA_TYPE) === -1 ? ph = o9 : ph = t.PARSER_MEDIA_TYPE, hc = ph === "application/xhtml+xml" ? sR : PT, bs = "ALLOWED_TAGS" in t ? Ts({}, t.ALLOWED_TAGS, hc) : hn, ro = "ALLOWED_ATTR" in t ? Ts({}, t.ALLOWED_ATTR, hc) : Ur, c0 = "ALLOWED_NAMESPACES" in t ? Ts({}, t.ALLOWED_NAMESPACES, sR) : iI, Ul = "ADD_URI_SAFE_ATTR" in t ? Ts(I1(nd), t.ADD_URI_SAFE_ATTR, hc) : nd, Ua = "ADD_DATA_URI_TAGS" in t ? Ts(I1(Fa), t.ADD_DATA_URI_TAGS, hc) : Fa, ri = "FORBID_CONTENTS" in t ? Ts({}, t.FORBID_CONTENTS, hc) : rl, yo = "FORBID_TAGS" in t ? Ts({}, t.FORBID_TAGS, hc) : {}, fr = "FORBID_ATTR" in t ? Ts({}, t.FORBID_ATTR, hc) : {}, Da = "USE_PROFILES" in t ? t.USE_PROFILES : !1, An = t.ALLOW_ARIA_ATTR !== !1, mr = t.ALLOW_DATA_ATTR !== !1, _r = t.ALLOW_UNKNOWN_PROTOCOLS || !1, zi = t.ALLOW_SELF_CLOSE_IN_ATTR !== !1, ls = t.SAFE_FOR_TEMPLATES || !1, pi = t.WHOLE_DOCUMENT || !1, pc = t.RETURN_DOM || !1, ku = t.RETURN_DOM_FRAGMENT || !1, td = t.RETURN_TRUSTED_TYPE || !1, um = t.FORCE_BODY || !1, _u = t.SANITIZE_DOM !== !1, Md = t.SANITIZE_NAMED_PROPS || !1, $r = t.KEEP_CONTENT !== !1, ya = t.IN_PLACE || !1, yl = t.ALLOWED_URI_REGEXP || NT, mh = t.NAMESPACE || Id, Sn = t.CUSTOM_ELEMENT_HANDLING || {}, t.CUSTOM_ELEMENT_HANDLING && BA(t.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Sn.tagNameCheck = t.CUSTOM_ELEMENT_HANDLING.tagNameCheck), t.CUSTOM_ELEMENT_HANDLING && BA(t.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Sn.attributeNameCheck = t.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), t.CUSTOM_ELEMENT_HANDLING && typeof t.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Sn.allowCustomizedBuiltInElements = t.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), ls && (mr = !1), ku && (pc = !0), Da && (bs = Ts({}, [...$$]), ro = [], Da.html === !0 && (Ts(bs, F1), Ts(ro, L$)), Da.svg === !0 && (Ts(bs, aR), Ts(ro, cR), Ts(ro, RT)), Da.svgFilters === !0 && (Ts(bs, iR), Ts(ro, cR), Ts(ro, RT)), Da.mathMl === !0 && (Ts(bs, lR), Ts(ro, H$), Ts(ro, RT))), t.ADD_TAGS && (bs === hn && (bs = I1(bs)), Ts(bs, t.ADD_TAGS, hc)), t.ADD_ATTR && (ro === Ur && (ro = I1(ro)), Ts(ro, t.ADD_ATTR, hc)), t.ADD_URI_SAFE_ATTR && Ts(Ul, t.ADD_URI_SAFE_ATTR, hc), t.FORBID_CONTENTS && (ri === rl && (ri = I1(ri)), Ts(ri, t.FORBID_CONTENTS, hc)), $r && (bs["#text"] = !0), pi && Ts(bs, [
            "html",
            "head",
            "body"
          ]), bs.table && (Ts(bs, ["tbody"]), delete yo.tbody), t.TRUSTED_TYPES_POLICY) {
            if (typeof t.TRUSTED_TYPES_POLICY.createHTML != "function")
              throw sS('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
            if (typeof t.TRUSTED_TYPES_POLICY.createScriptURL != "function")
              throw sS('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
            We = t.TRUSTED_TYPES_POLICY, ut = We.createHTML("");
          } else
            We === void 0 && (We = ZW(de, l)), We !== null && typeof ut == "string" && (ut = We.createHTML(""));
          Qu && Qu(t), dv = t;
        }
      }, ik = Ts({}, [
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext"
      ]), ht = Ts({}, [
        "foreignobject",
        "desc",
        "title",
        "annotation-xml"
      ]), xt = Ts({}, [
        "title",
        "style",
        "font",
        "a",
        "script"
      ]), fn = Ts({}, aR);
      Ts(fn, iR), Ts(fn, HW);
      const nn = Ts({}, lR);
      Ts(nn, B$);
      const Eo = function(t) {
        let a = Ye(t);
        (!a || !a.tagName) && (a = {
          namespaceURI: mh,
          tagName: "template"
        });
        const c = PT(t.tagName), f = PT(a.tagName);
        return c0[t.namespaceURI] ? t.namespaceURI === Sf ? a.namespaceURI === Id ? c === "svg" : a.namespaceURI === Cf ? c === "svg" && (f === "annotation-xml" || ik[f]) : !!fn[c] : t.namespaceURI === Cf ? a.namespaceURI === Id ? c === "math" : a.namespaceURI === Sf ? c === "math" && ht[f] : !!nn[c] : t.namespaceURI === Id ? a.namespaceURI === Sf && !ht[f] || a.namespaceURI === Cf && !ik[f] ? !1 : !nn[c] && (xt[c] || !fn[c]) : !!(ph === "application/xhtml+xml" && c0[t.namespaceURI]) : !1;
      }, Ar = function(t) {
        rS(n.removed, { element: t });
        try {
          t.parentNode.removeChild(t);
        } catch {
          t.remove();
        }
      }, ha = function(t, a) {
        try {
          rS(n.removed, {
            attribute: a.getAttributeNode(t),
            from: a
          });
        } catch {
          rS(n.removed, {
            attribute: null,
            from: a
          });
        }
        if (a.removeAttribute(t), t === "is" && !ro[t])
          if (pc || ku)
            try {
              Ar(a);
            } catch {
            }
          else
            try {
              a.setAttribute(t, "");
            } catch {
            }
      }, dm = function(t) {
        let a, c;
        if (um)
          t = "<remove></remove>" + t;
        else {
          const x = FW(t, /^[\r\n\t ]+/);
          c = x && x[0];
        }
        ph === "application/xhtml+xml" && mh === Id && (t = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + t + "</body></html>");
        const f = We ? We.createHTML(t) : t;
        if (mh === Id)
          try {
            a = new Z().parseFromString(f, ph);
          } catch {
          }
        if (!a || !a.documentElement) {
          a = zt.createDocument(mh, "template", null);
          try {
            a.documentElement.innerHTML = l0 ? ut : f;
          } catch {
          }
        }
        const g = a.body || a.documentElement;
        return t && c && g.insertBefore(d.createTextNode(c), g.childNodes[0] || null), mh === Id ? Tt.call(a, pi ? "html" : "body")[0] : pi ? a.documentElement : g;
      }, $A = function(t) {
        return an.call(t.ownerDocument || t, t, M.SHOW_ELEMENT | M.SHOW_COMMENT | M.SHOW_TEXT, null, !1);
      }, Kee = function(t) {
        return t instanceof U && (typeof t.nodeName != "string" || typeof t.textContent != "string" || typeof t.removeChild != "function" || !(t.attributes instanceof j) || typeof t.removeAttribute != "function" || typeof t.setAttribute != "function" || typeof t.namespaceURI != "string" || typeof t.insertBefore != "function" || typeof t.hasChildNodes != "function");
      }, LA = function(t) {
        return typeof S == "object" ? t instanceof S : t && typeof t == "object" && typeof t.nodeType == "number" && typeof t.nodeName == "string";
      }, $g = function(t, a, c) {
        Lt[t] && F$(Lt[t], (f) => {
          f.call(n, a, c, dv);
        });
      }, lI = function(t) {
        let a;
        if ($g("beforeSanitizeElements", t, null), Kee(t))
          return Ar(t), !0;
        const c = hc(t.nodeName);
        if ($g("uponSanitizeElement", t, {
          tagName: c,
          allowedTags: bs
        }), t.hasChildNodes() && !LA(t.firstElementChild) && (!LA(t.content) || !LA(t.content.firstElementChild)) && hf(/<[/\w]/g, t.innerHTML) && hf(/<[/\w]/g, t.textContent))
          return Ar(t), !0;
        if (!bs[c] || yo[c]) {
          if (!yo[c] && s9(c) && (Sn.tagNameCheck instanceof RegExp && hf(Sn.tagNameCheck, c) || Sn.tagNameCheck instanceof Function && Sn.tagNameCheck(c)))
            return !1;
          if ($r && !ri[c]) {
            const f = Ye(t) || t.parentNode, g = ze(t) || t.childNodes;
            if (g && f) {
              const x = g.length;
              for (let w = x - 1; w >= 0; --w)
                f.insertBefore(me(g[w], !0), Se(t));
            }
          }
          return Ar(t), !0;
        }
        return t instanceof O && !Eo(t) || (c === "noscript" || c === "noembed" || c === "noframes") && hf(/<\/no(script|embed|frames)/i, t.innerHTML) ? (Ar(t), !0) : (ls && t.nodeType === 3 && (a = t.textContent, a = Zm(a, Vn, " "), a = Zm(a, co, " "), a = Zm(a, Xo, " "), t.textContent !== a && (rS(n.removed, { element: t.cloneNode() }), t.textContent = a)), $g("afterSanitizeElements", t, null), !1);
      }, cI = function(t, a, c) {
        if (_u && (a === "id" || a === "name") && (c in d || c in r9))
          return !1;
        if (!(mr && !fr[a] && hf(Sr, a))) {
          if (!(An && hf(ts, a))) {
            if (!ro[a] || fr[a]) {
              if (!(s9(t) && (Sn.tagNameCheck instanceof RegExp && hf(Sn.tagNameCheck, t) || Sn.tagNameCheck instanceof Function && Sn.tagNameCheck(t)) && (Sn.attributeNameCheck instanceof RegExp && hf(Sn.attributeNameCheck, a) || Sn.attributeNameCheck instanceof Function && Sn.attributeNameCheck(a)) || a === "is" && Sn.allowCustomizedBuiltInElements && (Sn.tagNameCheck instanceof RegExp && hf(Sn.tagNameCheck, c) || Sn.tagNameCheck instanceof Function && Sn.tagNameCheck(c)))) return !1;
            } else if (!Ul[a]) {
              if (!hf(yl, Zm(c, Pa, ""))) {
                if (!((a === "src" || a === "xlink:href" || a === "href") && t !== "script" && BW(c, "data:") === 0 && Ua[t])) {
                  if (!(_r && !hf(Cs, Zm(c, Pa, "")))) {
                    if (c)
                      return !1;
                  }
                }
              }
            }
          }
        }
        return !0;
      }, s9 = function(t) {
        return t.indexOf("-") > 0;
      }, a9 = function(t) {
        let a, c, f, g;
        $g("beforeSanitizeAttributes", t, null);
        const { attributes: x } = t;
        if (!x)
          return;
        const w = {
          attrName: "",
          attrValue: "",
          keepAttr: !0,
          allowedAttributes: ro
        };
        for (g = x.length; g--; ) {
          a = x[g];
          const { name: T, namespaceURI: A } = a;
          c = T === "value" ? a.value : $W(a.value);
          const F = c;
          if (f = hc(T), w.attrName = f, w.attrValue = c, w.keepAttr = !0, w.forceKeepAttr = void 0, $g("uponSanitizeAttribute", t, w), c = w.attrValue, w.forceKeepAttr)
            continue;
          if (!w.keepAttr) {
            ha(T, t);
            continue;
          }
          if (!zi && hf(/\/>/i, c)) {
            ha(T, t);
            continue;
          }
          ls && (c = Zm(c, Vn, " "), c = Zm(c, co, " "), c = Zm(c, Xo, " "));
          const H = hc(t.nodeName);
          if (!cI(H, f, c)) {
            ha(T, t);
            continue;
          }
          if (Md && (f === "id" || f === "name") && (ha(T, t), c = uo + c), We && typeof de == "object" && typeof de.getAttributeType == "function" && !A)
            switch (de.getAttributeType(H, f)) {
              case "TrustedHTML": {
                c = We.createHTML(c);
                break;
              }
              case "TrustedScriptURL": {
                c = We.createScriptURL(c);
                break;
              }
            }
          if (c !== F)
            try {
              A ? t.setAttributeNS(A, T, c) : t.setAttribute(T, c);
            } catch {
              ha(T, t);
            }
        }
        $g("afterSanitizeAttributes", t, null);
      }, Yee = function Er(t) {
        let a;
        const c = $A(t);
        for ($g("beforeSanitizeShadowDOM", t, null); a = c.nextNode(); )
          $g("uponSanitizeShadowNode", a, null), !lI(a) && (a.content instanceof p && Er(a.content), a9(a));
        $g("afterSanitizeShadowDOM", t, null);
      };
      return n.sanitize = function(Er) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a, c, f, g;
        if (l0 = !Er, l0 && (Er = "<!-->"), typeof Er != "string" && !LA(Er))
          if (typeof Er.toString == "function") {
            if (Er = Er.toString(), typeof Er != "string")
              throw sS("dirty is not a string, aborting");
          } else
            throw sS("toString is not a function");
        if (!n.isSupported)
          return Er;
        if (Nd || kf(t), n.removed = [], typeof Er == "string" && (ya = !1), ya) {
          if (Er.nodeName) {
            const T = hc(Er.nodeName);
            if (!bs[T] || yo[T])
              throw sS("root node is forbidden and cannot be sanitized in-place");
          }
        } else if (Er instanceof S)
          a = dm("<!---->"), c = a.ownerDocument.importNode(Er, !0), c.nodeType === 1 && c.nodeName === "BODY" || c.nodeName === "HTML" ? a = c : a.appendChild(c);
        else {
          if (!pc && !ls && !pi && Er.indexOf("<") === -1)
            return We && td ? We.createHTML(Er) : Er;
          if (a = dm(Er), !a)
            return pc ? null : td ? ut : "";
        }
        a && um && Ar(a.firstChild);
        const x = $A(ya ? Er : a);
        for (; f = x.nextNode(); )
          lI(f) || (f.content instanceof p && Yee(f.content), a9(f));
        if (ya)
          return Er;
        if (pc) {
          if (ku)
            for (g = Dn.call(a.ownerDocument); a.firstChild; )
              g.appendChild(a.firstChild);
          else
            g = a;
          return (ro.shadowroot || ro.shadowrootmode) && (g = yt.call(s, g, !0)), g;
        }
        let w = pi ? a.outerHTML : a.innerHTML;
        return pi && bs["!doctype"] && a.ownerDocument && a.ownerDocument.doctype && a.ownerDocument.doctype.name && hf(hx, a.ownerDocument.doctype.name) && (w = "<!DOCTYPE " + a.ownerDocument.doctype.name + `>
` + w), ls && (w = Zm(w, Vn, " "), w = Zm(w, co, " "), w = Zm(w, Xo, " ")), We && td ? We.createHTML(w) : w;
      }, n.setConfig = function(Er) {
        kf(Er), Nd = !0;
      }, n.clearConfig = function() {
        dv = null, Nd = !1;
      }, n.isValidAttribute = function(Er, t, a) {
        dv || kf({});
        const c = hc(Er), f = hc(t);
        return cI(c, f, a);
      }, n.addHook = function(Er, t) {
        typeof t == "function" && (Lt[Er] = Lt[Er] || [], rS(Lt[Er], t));
      }, n.removeHook = function(Er) {
        if (Lt[Er])
          return IW(Lt[Er]);
      }, n.removeHooks = function(Er) {
        Lt[Er] && (Lt[Er] = []);
      }, n.removeAllHooks = function() {
        Lt = {};
      }, n;
    }
    var MT = aS();
    const Si = Gt.each, wae = Gt.trim, Cae = [
      "source",
      "protocol",
      "authority",
      "userInfo",
      "user",
      "password",
      "host",
      "port",
      "relative",
      "path",
      "directory",
      "file",
      "query",
      "anchor"
    ], Sae = {
      ftp: 21,
      http: 80,
      https: 443,
      mailto: 25
    }, kae = [
      "img",
      "video"
    ], rm = (e, n) => je(e) ? !e : je(n) ? !At(kae, n) : !0, IT = (e) => {
      try {
        return decodeURIComponent(e);
      } catch {
        return unescape(e);
      }
    }, Ag = (e, n, s) => {
      const l = IT(n).replace(/\s/g, "");
      return e.allow_script_urls ? !1 : /((java|vb)script|mhtml):/i.test(l) ? !0 : e.allow_html_data_urls ? !1 : /^data:image\//i.test(l) ? rm(e.allow_svg_data_urls, s) && /^data:image\/svg\+xml/i.test(l) : /^data:/i.test(l);
    };
    class mc {
      static parseDataUri(n) {
        let s;
        const l = decodeURIComponent(n).split(","), d = /data:([^;]+)/.exec(l[0]);
        return d && (s = d[1]), {
          type: s,
          data: l[1]
        };
      }
      static isDomSafe(n, s, l = {}) {
        if (l.allow_script_urls)
          return !0;
        {
          const d = ef.decode(n).replace(/[\s\u0000-\u001F]+/g, "");
          return !Ag(l, d, s);
        }
      }
      static getDocumentBaseUrl(n) {
        var s;
        let l;
        return n.protocol.indexOf("http") !== 0 && n.protocol !== "file:" ? l = (s = n.href) !== null && s !== void 0 ? s : "" : l = n.protocol + "//" + n.host + n.pathname, /^[^:]+:\/\/\/?[^\/]+\//.test(l) && (l = l.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(l) || (l += "/")), l;
      }
      constructor(n, s = {}) {
        this.path = "", this.directory = "", n = wae(n), this.settings = s;
        const l = s.base_uri, d = this;
        if (/^([\w\-]+):([^\/]{2})/i.test(n) || /^\s*#/.test(n)) {
          d.source = n;
          return;
        }
        const p = n.indexOf("//") === 0;
        if (n.indexOf("/") === 0 && !p && (n = (l && l.protocol || "http") + "://mce_host" + n), !/^[\w\-]*:?\/\//.test(n)) {
          const S = l ? l.path : new mc(document.location.href).directory;
          if ((l == null ? void 0 : l.protocol) === "")
            n = "//mce_host" + d.toAbsPath(S, n);
          else {
            const O = /([^#?]*)([#?]?.*)/.exec(n);
            O && (n = (l && l.protocol || "http") + "://mce_host" + d.toAbsPath(S, O[1]) + O[2]);
          }
        }
        n = n.replace(/@@/g, "(mce_at)");
        const v = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(n);
        v && Si(Cae, (S, O) => {
          let M = v[O];
          M && (M = M.replace(/\(mce_at\)/g, "@@")), d[S] = M;
        }), l && (d.protocol || (d.protocol = l.protocol), d.userInfo || (d.userInfo = l.userInfo), !d.port && d.host === "mce_host" && (d.port = l.port), (!d.host || d.host === "mce_host") && (d.host = l.host), d.source = ""), p && (d.protocol = "");
      }
      setPath(n) {
        const s = /^(.*?)\/?(\w+)?$/.exec(n);
        s && (this.path = s[0], this.directory = s[1], this.file = s[2]), this.source = "", this.getURI();
      }
      toRelative(n) {
        if (n === "./")
          return n;
        const s = new mc(n, { base_uri: this });
        if (s.host !== "mce_host" && this.host !== s.host && s.host || this.port !== s.port || this.protocol !== s.protocol && s.protocol !== "")
          return s.getURI();
        const l = this.getURI(), d = s.getURI();
        if (l === d || l.charAt(l.length - 1) === "/" && l.substr(0, l.length - 1) === d)
          return l;
        let p = this.toRelPath(this.path, s.path);
        return s.query && (p += "?" + s.query), s.anchor && (p += "#" + s.anchor), p;
      }
      toAbsolute(n, s) {
        const l = new mc(n, { base_uri: this });
        return l.getURI(s && this.isSameOrigin(l));
      }
      isSameOrigin(n) {
        if (this.host == n.host && this.protocol == n.protocol) {
          if (this.port == n.port)
            return !0;
          const s = this.protocol ? Sae[this.protocol] : null;
          if (s && (this.port || s) == (n.port || s))
            return !0;
        }
        return !1;
      }
      toRelPath(n, s) {
        let l = 0, d = "", p, v;
        const S = n.substring(0, n.lastIndexOf("/")).split("/"), O = s.split("/");
        if (S.length >= O.length) {
          for (p = 0, v = S.length; p < v; p++)
            if (p >= O.length || S[p] !== O[p]) {
              l = p + 1;
              break;
            }
        }
        if (S.length < O.length) {
          for (p = 0, v = O.length; p < v; p++)
            if (p >= S.length || S[p] !== O[p]) {
              l = p + 1;
              break;
            }
        }
        if (l === 1)
          return s;
        for (p = 0, v = S.length - (l - 1); p < v; p++)
          d += "../";
        for (p = l - 1, v = O.length; p < v; p++)
          p !== l - 1 ? d += "/" + O[p] : d += O[p];
        return d;
      }
      toAbsPath(n, s) {
        let l = 0;
        const d = /\/$/.test(s) ? "/" : "", p = n.split("/"), v = s.split("/"), S = [];
        Si(p, (U) => {
          U && S.push(U);
        });
        const O = [];
        for (let U = v.length - 1; U >= 0; U--)
          if (!(v[U].length === 0 || v[U] === ".")) {
            if (v[U] === "..") {
              l++;
              continue;
            }
            if (l > 0) {
              l--;
              continue;
            }
            O.push(v[U]);
          }
        const M = S.length - l;
        let j;
        return M <= 0 ? j = Qo(O).join("/") : j = S.slice(0, M).join("/") + "/" + Qo(O).join("/"), j.indexOf("/") !== 0 && (j = "/" + j), d && j.lastIndexOf("/") !== j.length - 1 && (j += d), j;
      }
      getURI(n = !1) {
        let s;
        return (!this.source || n) && (s = "", n || (this.protocol ? s += this.protocol + "://" : s += "//", this.userInfo && (s += this.userInfo + "@"), this.host && (s += this.host), this.port && (s += ":" + this.port)), this.path && (s += this.path), this.query && (s += "?" + this.query), this.anchor && (s += "#" + this.anchor), this.source = s), this.source;
      }
    }
    const GW = Gt.makeMap("src,href,data,background,action,formaction,poster,xlink:href"), uR = "data-mce-type";
    let B1 = 0;
    const $1 = (e, n, s, l, d) => {
      var p, v, S, O;
      const M = n.validate, j = s.getSpecialElements();
      e.nodeType === Yl && !n.allow_conditional_comments && /^\[if/i.test((p = e.nodeValue) !== null && p !== void 0 ? p : "") && (e.nodeValue = " " + e.nodeValue);
      const U = (v = d == null ? void 0 : d.tagName) !== null && v !== void 0 ? v : e.nodeName.toLowerCase();
      if (l !== "html" && s.isValid(l)) {
        je(d) && (d.allowedTags[U] = !0);
        return;
      }
      if (e.nodeType !== xi || U === "body")
        return;
      const Z = Me.fromDom(e), de = sa(Z, uR), we = Ms(Z, "data-mce-bogus");
      if (!de && G(we)) {
        we === "all" ? ys(Z) : Hc(Z);
        return;
      }
      const me = s.getElementRule(U);
      if (M && !me) {
        Xn(j, U) ? ys(Z) : Hc(Z);
        return;
      } else
        je(d) && (d.allowedTags[U] = !0);
      if (M && me && !de) {
        if (Ue((S = me.attributesForced) !== null && S !== void 0 ? S : [], (Se) => {
          ur(Z, Se.name, Se.value === "{$uid}" ? `mce_${B1++}` : Se.value);
        }), Ue((O = me.attributesDefault) !== null && O !== void 0 ? O : [], (Se) => {
          sa(Z, Se.name) || ur(Z, Se.name, Se.value === "{$uid}" ? `mce_${B1++}` : Se.value);
        }), me.attributesRequired && !$n(me.attributesRequired, (Se) => sa(Z, Se))) {
          Hc(Z);
          return;
        }
        if (me.removeEmptyAttrs && ul(Z)) {
          Hc(Z);
          return;
        }
        me.outputName && me.outputName !== U && n_(Z, me.outputName);
      }
    }, gx = (e, n, s, l, d) => {
      const p = e.tagName.toLowerCase(), { attrName: v, attrValue: S } = d;
      d.keepAttr = FT(n, s, l, p, v, S), d.keepAttr ? (d.allowedAttributes[v] = !0, dR(v, s) && (d.attrValue = v), n.allow_svg_data_urls && lo(S, "data:image/svg+xml") && (d.forceKeepAttr = !0)) : BT(e, v) && (d.forceKeepAttr = !0);
    }, FT = (e, n, s, l, d, p) => s !== "html" && !Ea(l) ? !0 : !(d in GW && Ag(e, p, l)) && (!e.validate || n.isValid(l, d) || lo(d, "data-") || lo(d, "aria-")), BT = (e, n) => e.hasAttribute(uR) && (n === "id" || n === "class" || n === "style"), dR = (e, n) => e in n.getBoolAttrs(), U$ = (e, n, s, l) => {
      const { attributes: d } = e;
      for (let p = d.length - 1; p >= 0; p--) {
        const v = d[p], S = v.name, O = v.value;
        !FT(n, s, l, e.tagName.toLowerCase(), S, O) && !BT(e, S) ? e.removeAttribute(S) : dR(S, s) && e.setAttribute(S, S);
      }
    }, qW = (e, n, s) => {
      const l = MT();
      return l.addHook("uponSanitizeElement", (d, p) => {
        $1(d, e, n, s.track(d), p);
      }), l.addHook("uponSanitizeAttribute", (d, p) => {
        gx(d, e, n, s.current(), p);
      }), l;
    }, KW = (e, n) => {
      const l = { ...{
        IN_PLACE: !0,
        ALLOW_UNKNOWN_PROTOCOLS: !0,
        ALLOWED_TAGS: [
          "#comment",
          "#cdata-section",
          "body"
        ],
        ALLOWED_ATTR: []
      } };
      return l.PARSER_MEDIA_TYPE = n, e.allow_script_urls ? l.ALLOWED_URI_REGEXP = /.*/ : e.allow_html_data_urls && (l.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i), l;
    }, W$ = (e) => {
      const n = P(e);
      if (n === "svg") {
        const s = [
          "type",
          "href",
          "role",
          "arcrole",
          "title",
          "show",
          "actuate",
          "label",
          "from",
          "to"
        ].map((d) => `xlink:${d}`), l = {
          IN_PLACE: !0,
          USE_PROFILES: {
            html: !0,
            svg: !0,
            svgFilters: !0
          },
          ALLOWED_ATTR: s
        };
        MT().sanitize(e, l);
      } else if (n === "math") {
        const s = {
          IN_PLACE: !0,
          USE_PROFILES: { mathMl: !0 }
        };
        MT().sanitize(e, s);
      } else
        throw new Error("Not a namespace element");
    }, YW = (e, n) => {
      const s = ee();
      if (e.sanitize) {
        const l = qW(e, n, s);
        return {
          sanitizeHtmlElement: (p, v) => {
            l.sanitize(p, KW(e, v)), l.removed = [], s.reset();
          },
          sanitizeNamespaceElement: W$
        };
      } else
        return {
          sanitizeHtmlElement: (p, v) => {
            const S = document.createNodeIterator(p, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);
            let O;
            for (; O = S.nextNode(); ) {
              const M = s.track(O);
              $1(O, e, n, M), On(O) && U$(O, e, n, M);
            }
            s.reset();
          },
          sanitizeNamespaceElement: qe
        };
    }, Z$ = Gt.makeMap, G$ = Gt.extend, q$ = (e, n, s, l) => {
      const d = e.name, p = d in s && d !== "title" && d !== "textarea" && d !== "noscript", v = n.childNodes;
      for (let S = 0, O = v.length; S < O; S++) {
        const M = v[S], j = new eu(M.nodeName.toLowerCase(), M.nodeType);
        if (On(M)) {
          const U = M.attributes;
          for (let Z = 0, de = U.length; Z < de; Z++) {
            const we = U[Z];
            j.attr(we.name, we.value);
          }
          Ea(j.name) && (l(M), j.value = M.innerHTML);
        } else Zt(M) ? (j.value = M.data, p && (j.raw = !0)) : (ci(M) || El(M) || Bu(M)) && (j.value = M.data);
        Ea(j.name) || q$(j, M, s, l), e.append(j);
      }
    }, XW = (e, n, s) => {
      const l = [];
      for (let d = e, p = d; d; p = d, d = d.walk()) {
        const v = d;
        Ue(n, (S) => S(v)), Kt(v.parent) && v !== e ? d = p : l.push(v);
      }
      for (let d = l.length - 1; d >= 0; d--) {
        const p = l[d];
        Ue(s, (v) => v(p));
      }
    }, K$ = (e, n, s, l) => {
      const d = s.validate, p = n.getNonEmptyElements(), v = n.getWhitespaceElements(), S = G$(Z$("script,style,head,html,body,title,meta,param"), n.getBlockElements()), O = I0(n), M = /[ \t\r\n]+/g, j = /^[ \t\r\n]+/, U = /[ \t\r\n]+$/, Z = (Ye) => {
        let We = Ye.parent;
        for (; je(We); ) {
          if (We.name in v)
            return !0;
          We = We.parent;
        }
        return !1;
      }, de = (Ye) => {
        let We = Ye;
        for (; je(We); ) {
          if (We.name in O)
            return iT(n, p, v, We);
          We = We.parent;
        }
        return !1;
      }, we = (Ye) => Ye.name in S || jc(n, Ye) || Ea(Ye.name) && Ye.parent === e, me = (Ye, We) => {
        const ut = We ? Ye.prev : Ye.next;
        return je(ut) || Kt(Ye.parent) ? !1 : we(Ye.parent) && (Ye.parent !== e || l.isRootContent === !0);
      };
      return [
        (Ye) => {
          var We;
          if (Ye.type === 3 && !Z(Ye)) {
            let ut = (We = Ye.value) !== null && We !== void 0 ? We : "";
            ut = ut.replace(M, " "), (Rl(Ye.prev, we) || me(Ye, !0)) && (ut = ut.replace(j, "")), ut.length === 0 ? Ye.remove() : Ye.value = ut;
          }
        },
        (Ye) => {
          var We;
          if (Ye.type === 1) {
            const ut = n.getElementRule(Ye.name);
            if (d && ut) {
              const zt = iT(n, p, v, Ye);
              ut.paddInEmptyBlock && zt && de(Ye) ? aT(s, l, we, Ye) : ut.removeEmpty && zt ? we(Ye) ? Ye.remove() : Ye.unwrap() : ut.paddEmpty && (zt || GU(Ye)) && aT(s, l, we, Ye);
            }
          } else if (Ye.type === 3 && !Z(Ye)) {
            let ut = (We = Ye.value) !== null && We !== void 0 ? We : "";
            (Ye.next && we(Ye.next) || me(Ye, !1)) && (ut = ut.replace(U, "")), ut.length === 0 ? Ye.remove() : Ye.value = ut;
          }
        }
      ];
    }, QW = (e, n) => {
      var s;
      const l = (s = n.forced_root_block) !== null && s !== void 0 ? s : e.forced_root_block;
      return l === !1 ? "" : l === !0 ? "p" : l;
    }, oh = (e = {}, n = Hf()) => {
      const s = kT(), l = kT(), d = {
        validate: !0,
        root_name: "body",
        sanitize: !0,
        ...e
      }, p = new DOMParser(), v = YW(d, n), S = (We, ut, zt = "html") => {
        const an = zt === "xhtml" ? "application/xhtml+xml" : "text/html", Dn = Xn(n.getSpecialElements(), ut.toLowerCase()), Tt = Dn ? `<${ut}>${We}</${ut}>` : We, yt = zt === "xhtml" ? `<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>${Tt}</body></html>` : `<body>${Tt}</body>`, Lt = p.parseFromString(yt, an).body;
        return v.sanitizeHtmlElement(Lt, an), Dn ? Lt.firstChild : Lt;
      }, O = s.addFilter, M = s.getFilters, j = s.removeFilter, U = l.addFilter, Z = l.getFilters, de = l.removeFilter, we = (We, ut) => {
        QB(n, We) && ut.push(We);
      }, me = (We, ut) => {
        const zt = G(ut.attr(uR)), an = ut.type === 1 && !Xn(We, ut.name) && !jc(n, ut) && !Ea(ut.name);
        return ut.type === 3 || an && !zt;
      }, Se = (We, ut) => {
        const zt = G$(Z$("script,style,head,html,body,title,meta,param"), n.getBlockElements()), an = /^[ \t\r\n]+/, Dn = /[ \t\r\n]+$/;
        let Tt = We.firstChild, yt = null;
        const Lt = (Vn) => {
          var co, Xo;
          Vn && (Tt = Vn.firstChild, Tt && Tt.type === 3 && (Tt.value = (co = Tt.value) === null || co === void 0 ? void 0 : co.replace(an, "")), Tt = Vn.lastChild, Tt && Tt.type === 3 && (Tt.value = (Xo = Tt.value) === null || Xo === void 0 ? void 0 : Xo.replace(Dn, "")));
        };
        if (n.isValidChild(We.name, ut.toLowerCase())) {
          for (; Tt; ) {
            const Vn = Tt.next;
            me(zt, Tt) ? (yt || (yt = new eu(ut, 1), yt.attr(d.forced_root_block_attrs), We.insert(yt, Tt)), yt.append(Tt)) : (Lt(yt), yt = null), Tt = Vn;
          }
          Lt(yt);
        }
      }, Ye = {
        schema: n,
        addAttributeFilter: U,
        getAttributeFilters: Z,
        removeAttributeFilter: de,
        addNodeFilter: O,
        getNodeFilters: M,
        removeNodeFilter: j,
        parse: (We, ut = {}) => {
          var zt;
          const an = d.validate, Dn = (zt = ut.context) !== null && zt !== void 0 ? zt : d.root_name, Tt = S(We, Dn, ut.format);
          $s(n, Tt);
          const yt = new eu(Dn, 11);
          q$(yt, Tt, n.getSpecialElements(), v.sanitizeNamespaceElement), Tt.innerHTML = "";
          const [Lt, Vn] = K$(yt, n, d, ut), co = [], Xo = an ? (Pa) => we(Pa, co) : qe, Sr = {
            nodes: {},
            attributes: {}
          }, ts = (Pa) => yD(M(), Z(), Pa, Sr);
          if (XW(yt, [
            Lt,
            ts
          ], [
            Vn,
            Xo
          ]), co.reverse(), an && co.length > 0)
            if (ut.context) {
              const {
                pass: Pa,
                fail: yl
              } = mo(co, (bs) => bs.parent === yt);
              jm(yl, n, yt, ts), ut.invalid = Pa.length > 0;
            } else
              jm(co, n, yt, ts);
          const Cs = QW(d, ut);
          return Cs && (yt.name === "body" || ut.isRootContent) && Se(yt, Cs), ut.invalid || XB(Sr, ut), yt;
        }
      };
      return N$(Ye, d), OW(Ye, d, n), Ye;
    }, Y$ = (e) => hs(e) ? Cg({ validate: !1 }).serialize(e) : e, X$ = (e, n, s) => {
      const l = Y$(e), d = n(l);
      if (d.isDefaultPrevented())
        return d;
      if (hs(e))
        if (d.content !== l) {
          const p = oh({
            validate: !1,
            forced_root_block: !1,
            ...s
          }).parse(d.content, { context: e.name });
          return {
            ...d,
            content: p
          };
        } else
          return {
            ...d,
            content: e
          };
      else
        return d;
    }, fR = (e) => ({
      sanitize: yy(e),
      sandbox_iframes: xy(e),
      sandbox_iframes_exclusions: wy(e)
    }), Q$ = (e, n) => {
      if (n.no_events)
        return ac.value(n);
      {
        const s = SE(e, n);
        return s.isDefaultPrevented() ? ac.error(bC(e, {
          content: "",
          ...s
        }).content) : ac.value(s);
      }
    }, mR = (e, n, s) => s.no_events ? n : X$(n, (d) => bC(e, {
      ...s,
      content: d
    }), fR(e)).content, pR = (e, n) => {
      if (n.no_events)
        return ac.value(n);
      {
        const s = X$(n.content, (l) => Ky(e, {
          ...n,
          content: l
        }), fR(e));
        return s.isDefaultPrevented() ? (Yy(e, s), ac.error(void 0)) : ac.value(s);
      }
    }, hR = (e, n, s) => {
      s.no_events || Yy(e, {
        ...s,
        content: n
      });
    }, $T = (e, n, s) => ({
      element: e,
      width: n,
      rows: s
    }), gR = (e, n) => ({
      element: e,
      cells: n
    }), J$ = (e, n) => ({
      x: e,
      y: n
    }), bR = (e, n) => da(e, n).bind(Ba).getOr(1), eL = (e, n, s, l, d) => {
      const p = bR(d, "rowspan"), v = bR(d, "colspan"), S = e.rows;
      for (let O = s; O < s + p; O++) {
        S[O] || (S[O] = gR(pb(l), []));
        for (let M = n; M < n + v; M++) {
          const j = S[O].cells;
          j[M] = O === s && M === n ? d : rf(d);
        }
      }
    }, tL = (e, n, s) => {
      const l = e.rows;
      return !!(l[s] ? l[s].cells : [])[n];
    }, JW = (e, n, s) => {
      for (; tL(e, n, s); )
        n++;
      return n;
    }, nL = (e) => Ct(e, (n, s) => s.cells.length > n ? s.cells.length : n, 0), oL = (e, n) => {
      const s = e.rows;
      for (let l = 0; l < s.length; l++) {
        const d = s[l].cells;
        for (let p = 0; p < d.length; p++)
          if (zr(d[p], n))
            return Y.some(J$(p, l));
      }
      return Y.none();
    }, LT = (e, n, s, l, d) => {
      const p = [], v = e.rows;
      for (let S = s; S <= d; S++) {
        const O = v[S].cells, M = n < l ? O.slice(n, l + 1) : O.slice(l, n + 1);
        p.push(gR(v[S].element, M));
      }
      return p;
    }, iS = (e, n, s) => {
      const l = n.x, d = n.y, p = s.x, v = s.y, S = d < v ? LT(e, l, d, p, v) : LT(e, l, v, p, d);
      return $T(e.element, nL(S), S);
    }, rL = (e, n) => {
      const s = rf(e.element), l = Me.fromTag("tbody");
      return pd(l, n), Ys(s, l), s;
    }, sL = (e) => en(e.rows, (n) => {
      const s = en(n.cells, (d) => {
        const p = pb(d);
        return oa(p, "colspan"), oa(p, "rowspan"), p;
      }), l = rf(n.element);
      return pd(l, s), l;
    }), HT = (e) => {
      const n = $T(rf(e), 0, []);
      return Ue(ba(e, "tr"), (s, l) => {
        Ue(ba(s, "td,th"), (d, p) => {
          eL(n, JW(n, p, l), l, s, d);
        });
      }), $T(n.element, nL(n.rows), n.rows);
    }, eZ = (e) => rL(e, sL(e)), tZ = (e, n, s) => oL(e, n).bind((l) => oL(e, s).map((d) => iS(e, l, d))), L1 = (e) => Pn(e, (n) => gr(n) === "ul" || gr(n) === "ol"), vR = (e, n) => Pn(e, (s) => gr(s) === "li" && By(s, n)).fold(dt([]), (s) => L1(e).map((l) => {
      const d = Me.fromTag(gr(l)), p = kr(fl(l), (v, S) => lo(S, "list-style"));
      return zo(d, p), [
        Me.fromTag("li"),
        d
      ];
    }).getOr([])), aL = (e, n) => {
      const s = Ct(n, (l, d) => (Ys(d, l), d), e);
      return n.length > 0 ? _o([s]) : s;
    }, lS = (e) => Oc(e) ? Di(e).filter(sf).fold(dt([]), (n) => [
      e,
      n
    ]) : sf(e) ? [e] : [], iL = (e, n, s) => {
      const l = Me.fromDom(n.commonAncestorContainer), d = Sg(l, e), p = xn(d, (O) => s.isWrapper(gr(O))), v = vR(d, n), S = p.concat(v.length ? v : lS(l));
      return en(S, rf);
    }, zT = () => _o([]), lL = (e, n, s) => aL(Me.fromDom(n.cloneContents()), iL(e, n, s)), cL = (e, n) => Ra(n, "table", Le(zr, e)), nZ = (e, n) => cL(e, n[0]).bind((s) => {
      const l = n[0], d = n[n.length - 1], p = HT(s);
      return tZ(p, l, d).map((v) => _o([eZ(v)]));
    }).getOrThunk(zT), oZ = (e, n, s) => n.length > 0 && n[0].collapsed ? zT() : lL(e, n[0], s), rZ = (e, n, s) => {
      const l = Gp(n, e);
      return l.length > 0 ? nZ(e, l) : oZ(e, n, s);
    }, bx = (e, n) => n >= 0 && n < e.length && gg(e.charAt(n)), uL = (e) => Kc(e.innerText), dL = (e) => e.map((n) => n.nodeName).getOr("div").toLowerCase(), sZ = (e) => Y.from(e.selection.getRng()).map((n) => {
      var s;
      const l = Y.from(e.dom.getParent(n.commonAncestorContainer, e.dom.isBlock)), d = e.getBody(), p = dL(l), v = Me.fromDom(n.cloneContents());
      YF(v), XF(v);
      const S = e.dom.add(d, p, {
        "data-mce-bogus": "all",
        style: "overflow: hidden; opacity: 0;"
      }, v.dom), O = uL(S), M = Kc((s = S.textContent) !== null && s !== void 0 ? s : "");
      if (e.dom.remove(S), bx(M, 0) || bx(M, M.length - 1)) {
        const j = l.getOr(d), U = uL(j), Z = U.indexOf(O);
        if (Z === -1)
          return O;
        {
          const de = bx(U, Z - 1), we = bx(U, Z + O.length);
          return (de ? " " : "") + O + (we ? " " : "");
        }
      } else
        return O;
    }).getOr(""), aZ = (e, n) => {
      const s = e.selection.getRng(), l = e.dom.create("body"), d = e.selection.getSel(), p = ox(e, Fy(d)), v = n.contextual ? rZ(Me.fromDom(e.getBody()), p, e.schema).dom : s.cloneContents();
      return v && l.appendChild(v), e.selection.serializer.serialize(l, n);
    }, iZ = (e, n) => {
      if (n.format === "text")
        return sZ(e);
      {
        const s = aZ(e, n);
        return n.format === "tree" ? s : e.selection.isCollapsed() ? "" : s;
      }
    }, lZ = (e, n) => ({
      ...e,
      format: n,
      get: !0,
      selection: !0,
      getInner: !0
    }), cZ = (e, n, s = {}) => {
      const l = lZ(s, n);
      return Q$(e, l).fold(En, (d) => {
        const p = iZ(e, d);
        return mR(e, p, d);
      });
    }, yR = 0, fL = 1, mL = 2, uZ = (e, n) => {
      const s = e.length + n.length + 2, l = new Array(s), d = new Array(s), p = (j, U, Z) => ({
        start: j,
        end: U,
        diag: Z
      }), v = (j, U, Z, de, we) => {
        const me = O(j, U, Z, de);
        if (me === null || me.start === U && me.diag === U - de || me.end === j && me.diag === j - Z) {
          let Se = j, ze = Z;
          for (; Se < U || ze < de; )
            Se < U && ze < de && e[Se] === n[ze] ? (we.push([
              yR,
              e[Se]
            ]), ++Se, ++ze) : U - j > de - Z ? (we.push([
              mL,
              e[Se]
            ]), ++Se) : (we.push([
              fL,
              n[ze]
            ]), ++ze);
        } else {
          v(j, me.start, Z, me.start - me.diag, we);
          for (let Se = me.start; Se < me.end; ++Se)
            we.push([
              yR,
              e[Se]
            ]);
          v(me.end, U, me.end - me.diag, de, we);
        }
      }, S = (j, U, Z, de) => {
        let we = j;
        for (; we - U < de && we < Z && e[we] === n[we - U]; )
          ++we;
        return p(j, we, U);
      }, O = (j, U, Z, de) => {
        const we = U - j, me = de - Z;
        if (we === 0 || me === 0)
          return null;
        const Se = we - me, ze = me + we, Ye = (ze % 2 === 0 ? ze : ze + 1) / 2;
        l[1 + Ye] = j, d[1 + Ye] = U + 1;
        let We, ut, zt, an, Dn;
        for (We = 0; We <= Ye; ++We) {
          for (ut = -We; ut <= We; ut += 2) {
            for (zt = ut + Ye, ut === -We || ut !== We && l[zt - 1] < l[zt + 1] ? l[zt] = l[zt + 1] : l[zt] = l[zt - 1] + 1, an = l[zt], Dn = an - j + Z - ut; an < U && Dn < de && e[an] === n[Dn]; )
              l[zt] = ++an, ++Dn;
            if (Se % 2 !== 0 && Se - We <= ut && ut <= Se + We && d[zt - Se] <= l[zt])
              return S(d[zt - Se], ut + j - Z, U, de);
          }
          for (ut = Se - We; ut <= Se + We; ut += 2) {
            for (zt = ut + Ye - Se, ut === Se - We || ut !== Se + We && d[zt + 1] <= d[zt - 1] ? d[zt] = d[zt + 1] - 1 : d[zt] = d[zt - 1], an = d[zt] - 1, Dn = an - j + Z - ut; an >= j && Dn >= Z && e[an] === n[Dn]; )
              d[zt] = an--, Dn--;
            if (Se % 2 === 0 && -We <= ut && ut <= We && d[zt] <= l[zt + Se])
              return S(d[zt], ut + j - Z, U, de);
          }
        }
        return null;
      }, M = [];
      return v(0, e.length, 0, n.length, M), M;
    }, cS = (e) => On(e) ? e.outerHTML : Zt(e) ? ef.encodeRaw(e.data, !1) : ci(e) ? "<!--" + e.data + "-->" : "", Rc = (e) => {
      let n;
      const s = document.createElement("div"), l = document.createDocumentFragment();
      for (e && (s.innerHTML = e); n = s.firstChild; )
        l.appendChild(n);
      return l;
    }, dZ = (e, n, s) => {
      const l = Rc(n);
      if (e.hasChildNodes() && s < e.childNodes.length) {
        const d = e.childNodes[s];
        e.insertBefore(l, d);
      } else
        e.appendChild(l);
    }, VT = (e, n) => {
      if (e.hasChildNodes() && n < e.childNodes.length) {
        const s = e.childNodes[n];
        e.removeChild(s);
      }
    }, H1 = (e, n) => {
      let s = 0;
      Ue(e, (l) => {
        l[0] === yR ? s++ : l[0] === fL ? (dZ(n, l[1], s), s++) : l[0] === mL && VT(n, s);
      });
    }, pL = (e, n) => xn(en(hr(e.childNodes), B(Kc, cS)), (s) => s.length > 0), Ju = (e, n) => {
      const s = en(hr(n.childNodes), cS);
      return H1(uZ(s, e), n), n;
    }, z1 = _t(() => document.implementation.createHTMLDocument("undo")), hL = (e) => e.querySelector("iframe") !== null, fZ = (e) => ({
      type: "fragmented",
      fragments: e,
      content: "",
      bookmark: null,
      beforeBookmark: null
    }), gL = (e) => ({
      type: "complete",
      fragments: null,
      content: e,
      bookmark: null,
      beforeBookmark: null
    }), jT = (e) => {
      const n = e.serializer.getTempAttrs(), s = WP(e.getBody(), n);
      return hL(s) ? fZ(pL(s)) : gL(Kc(s.innerHTML));
    }, UT = (e, n, s) => {
      const l = s ? n.beforeBookmark : n.bookmark;
      n.type === "fragmented" ? Ju(n.fragments, e.getBody()) : e.setContent(n.content, {
        format: "raw",
        no_selection: je(l) && uE(l) ? !l.isFakeCaret : !0
      }), l && (e.selection.moveToBookmark(l), e.selection.scrollIntoView());
    }, V1 = (e) => e.type === "fragmented" ? e.fragments.join("") : e.content, WT = (e) => {
      const n = Me.fromTag("body", z1());
      return hd(n, V1(e)), Ue(ba(n, "*[data-mce-bogus]"), Hc), Fs(n);
    }, mZ = (e, n) => V1(e) === V1(n), bL = (e, n) => WT(e) === WT(n), xR = (e, n) => !e || !n ? !1 : mZ(e, n) ? !0 : bL(e, n), uS = (e) => e.get() === 0, vx = (e, n, s) => {
      uS(s) && (e.typing = n);
    }, vL = (e, n) => {
      e.typing && (vx(e, !1, n), e.add());
    }, pZ = (e) => {
      e.typing && (e.typing = !1, e.add());
    }, rh = (e, n, s) => {
      uS(n) && s.set(g2(e.selection));
    }, wR = (e, n, s, l, d, p, v) => {
      const S = jT(e), O = Gt.extend(p || {}, S);
      if (!uS(l) || e.removed)
        return null;
      const M = n.data[s.get()];
      if (e.dispatch("BeforeAddUndo", {
        level: O,
        lastLevel: M,
        originalEvent: v
      }).isDefaultPrevented() || M && xR(M, O))
        return null;
      n.data[s.get()] && d.get().each((Z) => {
        n.data[s.get()].beforeBookmark = Z;
      });
      const j = I4(e);
      if (j && n.data.length > j) {
        for (let Z = 0; Z < n.data.length - 1; Z++)
          n.data[Z] = n.data[Z + 1];
        n.data.length--, s.set(n.data.length);
      }
      O.bookmark = g2(e.selection), s.get() < n.data.length - 1 && (n.data.length = s.get() + 1), n.data.push(O), s.set(n.data.length - 1);
      const U = {
        level: O,
        lastLevel: M,
        originalEvent: v
      };
      return s.get() > 0 ? (e.setDirty(!0), e.dispatch("AddUndo", U), e.dispatch("change", U)) : e.dispatch("AddUndo", U), O;
    }, hZ = (e, n, s) => {
      n.data = [], s.set(0), n.typing = !1, e.dispatch("ClearUndos");
    }, ZT = (e, n, s, l, d) => {
      if (n.transact(l)) {
        const p = n.data[s.get()].bookmark, v = n.data[s.get() - 1];
        UT(e, v, !0), n.transact(d) && (n.data[s.get() - 1].beforeBookmark = p);
      }
    }, CR = (e, n, s) => {
      let l;
      return n.get() < s.length - 1 && (n.set(n.get() + 1), l = s[n.get()], UT(e, l, !1), e.setDirty(!0), e.dispatch("Redo", { level: l })), l;
    }, yL = (e, n, s, l) => {
      let d;
      return n.typing && (n.add(), n.typing = !1, vx(n, !1, s)), l.get() > 0 && (l.set(l.get() - 1), d = n.data[l.get()], UT(e, d, !0), e.setDirty(!0), e.dispatch("Undo", { level: d })), d;
    }, xL = (e) => {
      e.clear(), e.add();
    }, wL = (e, n, s) => s.get() > 0 || n.typing && n.data[0] && !xR(jT(e), n.data[0]), gZ = (e, n) => n.get() < e.data.length - 1 && !e.typing, bZ = (e, n, s) => (vL(e, n), e.beforeChange(), e.ignore(s), e.add()), vZ = (e, n) => {
      try {
        e.set(e.get() + 1), n();
      } finally {
        e.set(e.get() - 1);
      }
    }, yZ = (e, n) => {
      const s = e.dom, l = je(n) ? n : e.getBody();
      Ue(s.select("table,a", l), (d) => {
        switch (d.nodeName) {
          case "TABLE":
            const p = M2(e), v = s.getAttrib(d, "border");
            (!v || v === "0") && e.hasVisual ? s.addClass(d, p) : s.removeClass(d, p);
            break;
          case "A":
            if (!s.getAttrib(d, "href")) {
              const S = s.getAttrib(d, "name") || d.id, O = I2(e);
              S && e.hasVisual ? s.addClass(d, O) : s.removeClass(d, O);
            }
            break;
        }
      }), e.dispatch("VisualAid", {
        element: n,
        hasVisual: e.hasVisual
      });
    }, CL = (e) => ({
      init: { bindEvents: qe },
      undoManager: {
        beforeChange: (n, s) => rh(e, n, s),
        add: (n, s, l, d, p, v) => wR(e, n, s, l, d, p, v),
        undo: (n, s, l) => yL(e, n, s, l),
        redo: (n, s) => CR(e, n, s),
        clear: (n, s) => hZ(e, n, s),
        reset: (n) => xL(n),
        hasUndo: (n, s) => wL(e, n, s),
        hasRedo: (n, s) => gZ(n, s),
        transact: (n, s, l) => bZ(n, s, l),
        ignore: (n, s) => vZ(n, s),
        extra: (n, s, l, d) => ZT(e, n, s, l, d)
      },
      formatter: {
        match: (n, s, l, d) => PD(e, n, s, l, d),
        matchAll: (n, s) => cW(e, n, s),
        matchNode: (n, s, l, d) => nh(e, n, s, l, d),
        canApply: (n) => dW(e, n),
        closest: (n) => uW(e, n),
        apply: (n, s, l) => XD(e, n, s, l),
        remove: (n, s, l, d) => qD(e, n, s, l, d),
        toggle: (n, s, l) => oi(e, n, s, l),
        formatChanged: (n, s, l, d, p) => QD(e, n, s, l, d, p)
      },
      editor: {
        getContent: (n) => dU(e, n),
        setContent: (n, s) => ED(e, n, s),
        insertContent: (n, s) => lW(e, n, s),
        addVisual: (n) => yZ(e, n)
      },
      selection: { getContent: (n, s) => cZ(e, n, s) },
      autocompleter: {
        addDecoration: qe,
        removeDecoration: qe
      },
      raw: { getModel: () => Y.none() }
    }), SL = (e) => {
      const n = (M) => ve(M) ? M : {}, { init: s, undoManager: l, formatter: d, editor: p, selection: v, autocompleter: S, raw: O } = e;
      return {
        init: { bindEvents: s.bindEvents },
        undoManager: {
          beforeChange: l.beforeChange,
          add: l.add,
          undo: l.undo,
          redo: l.redo,
          clear: l.clear,
          reset: l.reset,
          hasUndo: l.hasUndo,
          hasRedo: l.hasRedo,
          transact: (M, j, U) => l.transact(U),
          ignore: (M, j) => l.ignore(j),
          extra: (M, j, U, Z) => l.extra(U, Z)
        },
        formatter: {
          match: (M, j, U, Z) => d.match(M, n(j), Z),
          matchAll: d.matchAll,
          matchNode: d.matchNode,
          canApply: (M) => d.canApply(M),
          closest: (M) => d.closest(M),
          apply: (M, j, U) => d.apply(M, n(j)),
          remove: (M, j, U, Z) => d.remove(M, n(j)),
          toggle: (M, j, U) => d.toggle(M, n(j)),
          formatChanged: (M, j, U, Z, de) => d.formatChanged(j, U, Z, de)
        },
        editor: {
          getContent: (M) => p.getContent(M),
          setContent: (M, j) => ({
            content: p.setContent(M, j),
            html: ""
          }),
          insertContent: (M, j) => (p.insertContent(M), ""),
          addVisual: p.addVisual
        },
        selection: { getContent: (M, j) => v.getContent(j) },
        autocompleter: {
          addDecoration: S.addDecoration,
          removeDecoration: S.removeDecoration
        },
        raw: { getModel: () => Y.some(O.getRawModel()) }
      };
    }, xZ = () => {
      const e = dt(null), n = dt("");
      return {
        init: { bindEvents: qe },
        undoManager: {
          beforeChange: qe,
          add: e,
          undo: e,
          redo: e,
          clear: qe,
          reset: qe,
          hasUndo: tt,
          hasRedo: tt,
          transact: e,
          ignore: qe,
          extra: qe
        },
        formatter: {
          match: tt,
          matchAll: dt([]),
          matchNode: dt(void 0),
          canApply: tt,
          closest: n,
          apply: qe,
          remove: qe,
          toggle: qe,
          formatChanged: dt({ unbind: qe })
        },
        editor: {
          getContent: n,
          setContent: dt({
            content: "",
            html: ""
          }),
          insertContent: dt(""),
          addVisual: qe
        },
        selection: { getContent: n },
        autocompleter: {
          addDecoration: qe,
          removeDecoration: qe
        },
        raw: { getModel: dt(Y.none()) }
      };
    }, sh = (e) => Xn(e.plugins, "rtc"), wZ = (e) => Or(e.plugins, "rtc").bind((n) => Y.from(n.setup)), kL = (e) => {
      const n = e;
      return wZ(e).fold(() => (n.rtcInstance = CL(e), Y.none()), (s) => (n.rtcInstance = xZ(), Y.some(() => s().then((l) => (n.rtcInstance = SL(l), l.rtc.isRemote)))));
    }, dS = (e) => e.rtcInstance ? e.rtcInstance : CL(e), ki = (e) => {
      const n = e.rtcInstance;
      if (n)
        return n;
      throw new Error("Failed to get RTC instance not yet initialized.");
    }, _L = (e, n, s) => {
      ki(e).undoManager.beforeChange(n, s);
    }, SR = (e, n, s, l, d, p, v) => ki(e).undoManager.add(n, s, l, d, p, v), EL = (e, n, s, l) => ki(e).undoManager.undo(n, s, l), TL = (e, n, s) => ki(e).undoManager.redo(n, s), kR = (e, n, s) => {
      ki(e).undoManager.clear(n, s);
    }, OL = (e, n) => {
      ki(e).undoManager.reset(n);
    }, AL = (e, n, s) => ki(e).undoManager.hasUndo(n, s), PL = (e, n, s) => ki(e).undoManager.hasRedo(n, s), CZ = (e, n, s, l) => ki(e).undoManager.transact(n, s, l), _R = (e, n, s) => {
      ki(e).undoManager.ignore(n, s);
    }, SZ = (e, n, s, l, d) => {
      ki(e).undoManager.extra(n, s, l, d);
    }, GT = (e, n, s, l, d) => ki(e).formatter.match(n, s, l, d), kZ = (e, n, s) => ki(e).formatter.matchAll(n, s), _Z = (e, n, s, l, d) => ki(e).formatter.matchNode(n, s, l, d), EZ = (e, n) => ki(e).formatter.canApply(n), DL = (e, n) => ki(e).formatter.closest(n), RL = (e, n, s, l) => {
      ki(e).formatter.apply(n, s, l);
    }, TZ = (e, n, s, l, d) => {
      ki(e).formatter.remove(n, s, l, d);
    }, OZ = (e, n, s, l) => {
      ki(e).formatter.toggle(n, s, l);
    }, AZ = (e, n, s, l, d, p) => ki(e).formatter.formatChanged(n, s, l, d, p), PZ = (e, n) => dS(e).editor.getContent(n), DZ = (e, n, s) => dS(e).editor.setContent(n, s), NL = (e, n, s) => dS(e).editor.insertContent(n, s), _ae = (e, n, s) => ki(e).selection.getContent(n, s), RZ = (e, n) => ki(e).editor.addVisual(n), ML = (e) => ki(e).init.bindEvents(), NZ = (e, n = {}) => {
      const s = n.format ? n.format : "html";
      return _ae(e, s, n);
    }, IL = (e) => e.dom.length === 0 ? (ys(e), Y.none()) : Y.some(e), MZ = (e, n) => e.filter((s) => Yp.isBookmarkNode(s.dom)).bind(n ? $c : Xl), IZ = (e, n, s, l, d) => {
      const p = e.dom, v = n.dom, S = l ? p.length : v.length;
      l ? (oD(p, v, d, !1, !l), s.setStart(v, S)) : (oD(v, p, d, !1, !l), s.setEnd(v, S));
    }, FZ = (e, n, s) => {
      Di(e).each((l) => {
        const d = e.dom;
        n && NC(l, vt(d, 0), s) ? IC(d, 0, s) : !n && MC(l, vt(d, d.length), s) && nD(d, d.length, s);
      });
    }, ER = (e, n, s, l, d) => {
      e.bind((p) => ((l ? nD : IC)(p.dom, l ? p.dom.length : 0, d), n.filter(pt).map((S) => IZ(p, S, s, l, d)))).orThunk(() => MZ(n, l).or(n).filter(pt).map((v) => FZ(v, l, d)));
    }, BZ = (e, n, s) => {
      const l = Y.from(n.firstChild).map(Me.fromDom), d = Y.from(n.lastChild).map(Me.fromDom);
      e.deleteContents(), e.insertNode(n);
      const p = l.bind(Xl).filter(pt).bind(IL), v = d.bind($c).filter(pt).bind(IL);
      ER(p, l, e, !0, s), ER(v, d, e, !1, s), e.collapse(!1);
    }, $Z = (e, n) => ({
      format: "html",
      ...e,
      set: !0,
      selection: !0,
      content: n
    }), LZ = (e, n) => {
      if (n.format !== "raw") {
        const s = e.selection.getRng(), l = e.dom.getParent(s.commonAncestorContainer, e.dom.isBlock), d = l ? { context: l.nodeName.toLowerCase() } : {}, p = e.parser.parse(n.content, {
          forced_root_block: !1,
          ...d,
          ...n
        });
        return Cg({ validate: !1 }, e.schema).serialize(p);
      } else
        return n.content;
    }, HZ = (e, n, s = {}) => {
      const l = $Z(s, n);
      pR(e, l).each((d) => {
        const p = LZ(e, d), v = e.selection.getRng();
        BZ(v, v.createContextualFragment(p), e.schema), e.selection.setRng(v), OC(e, v), hR(e, p, d);
      });
    }, FL = (e, n, s) => {
      if (Xn(e, n)) {
        const l = xn(e[n], (d) => d !== s);
        l.length === 0 ? delete e[n] : e[n] = l;
      }
    };
    var Eae = (e, n) => {
      let s, l;
      const d = (S, O) => Pn(O, (M) => e.is(M, S)), p = (S) => e.getParents(S, void 0, e.getRoot()), v = () => {
        s = {}, l = {}, n.on("NodeChange", (S) => {
          const O = S.element, M = p(O), j = {};
          Ht(s, (U, Z) => {
            d(Z, M).each((de) => {
              l[Z] || (Ue(U, (we) => {
                we(!0, {
                  node: de,
                  selector: Z,
                  parents: M
                });
              }), l[Z] = U), j[Z] = U;
            });
          }), Ht(l, (U, Z) => {
            j[Z] || (delete l[Z], Ue(U, (de) => {
              de(!1, {
                node: O,
                selector: Z,
                parents: M
              });
            }));
          });
        });
      };
      return {
        selectorChangedWithUnbind: (S, O) => (s || v(), s[S] || (s[S] = []), s[S].push(O), d(S, p(n.selection.getStart())).each(() => {
          l[S] = s[S];
        }), {
          unbind: () => {
            FL(s, S, O), FL(l, S, O);
          }
        })
      };
    };
    const zZ = (e) => !!(e && e.ownerDocument) && Gi(Me.fromDom(e.ownerDocument), Me.fromDom(e)), VZ = (e) => e ? zZ(e.startContainer) && zZ(e.endContainer) : !1, BL = (e, n, s, l) => {
      let d, p;
      const { selectorChangedWithUnbind: v } = Eae(e, l), S = (hn, ro) => {
        const Ur = e.createRng();
        je(hn) && je(ro) ? (Ur.setStart(hn, ro), Ur.setEnd(hn, ro), ut(Ur), ze(!1)) : (lC(e, Ur, l.getBody(), !0), ut(Ur));
      }, O = (hn) => NZ(l, hn), M = (hn, ro) => HZ(l, hn, ro), j = (hn) => VP(l.getBody(), We(), hn), U = (hn) => jP(l.getBody(), We(), hn), Z = (hn, ro) => yl.getBookmark(hn, ro), de = (hn) => yl.moveToBookmark(hn), we = (hn, ro) => (tU(e, hn, ro).each(ut), hn), me = () => {
        const hn = We(), ro = Ye();
        return !hn || hn.item ? !1 : hn.compareEndPoints ? hn.compareEndPoints("StartToEnd", hn) === 0 : !ro || hn.collapsed;
      }, Se = () => {
        const hn = We(), ro = l.getBody().querySelectorAll('[data-mce-selected="1"]');
        return ro.length > 0 ? Ko(ro, (Ur) => e.isEditable(Ur.parentElement)) : HF(e, hn);
      }, ze = (hn) => {
        const ro = We();
        ro.collapse(!!hn), ut(ro);
      }, Ye = () => n.getSelection ? n.getSelection() : n.document.selection, We = () => {
        let hn;
        const ro = (Sn, yo, fr) => {
          try {
            return yo.compareBoundaryPoints(Sn, fr);
          } catch {
            return -1;
          }
        }, Ur = n.document;
        if (je(l.bookmark) && !S1(l)) {
          const Sn = $E(l);
          if (Sn.isSome())
            return Sn.map((yo) => ox(l, [yo])[0]).getOr(Ur.createRange());
        }
        try {
          const Sn = Ye();
          Sn && !Mf(Sn.anchorNode) && (Sn.rangeCount > 0 ? hn = Sn.getRangeAt(0) : hn = Ur.createRange(), hn = ox(l, [hn])[0]);
        } catch {
        }
        if (hn || (hn = Ur.createRange()), xp(hn.startContainer) && hn.collapsed) {
          const Sn = e.getRoot();
          hn.setStart(Sn, 0), hn.setEnd(Sn, 0);
        }
        return d && p && (ro(hn.START_TO_START, hn, d) === 0 && ro(hn.END_TO_END, hn, d) === 0 ? hn = p : (d = null, p = null)), hn;
      }, ut = (hn, ro) => {
        if (!VZ(hn))
          return;
        const Ur = Ye();
        if (hn = l.dispatch("SetSelectionRange", {
          range: hn,
          forward: ro
        }).range, Ur) {
          p = hn;
          try {
            Ur.removeAllRanges(), Ur.addRange(hn);
          } catch {
          }
          ro === !1 && Ur.extend && (Ur.collapse(hn.endContainer, hn.endOffset), Ur.extend(hn.startContainer, hn.startOffset)), d = Ur.rangeCount > 0 ? Ur.getRangeAt(0) : null;
        }
        if (!hn.collapsed && hn.startContainer === hn.endContainer && (Ur != null && Ur.setBaseAndExtent) && hn.endOffset - hn.startOffset < 2 && hn.startContainer.hasChildNodes()) {
          const yo = hn.startContainer.childNodes[hn.startOffset];
          yo && yo.nodeName === "IMG" && (Ur.setBaseAndExtent(hn.startContainer, hn.startOffset, hn.endContainer, hn.endOffset), (Ur.anchorNode !== hn.startContainer || Ur.focusNode !== hn.endContainer) && Ur.setBaseAndExtent(yo, 0, yo, 1));
        }
        l.dispatch("AfterSetSelectionRange", {
          range: hn,
          forward: ro
        });
      }, zt = (hn) => (M(e.getOuterHTML(hn)), hn), an = () => Jj(l.getBody(), We()), Dn = (hn, ro) => eU(e, We(), hn, ro), Tt = () => {
        const hn = Ye(), ro = hn == null ? void 0 : hn.anchorNode, Ur = hn == null ? void 0 : hn.focusNode;
        if (!hn || !ro || !Ur || Mf(ro) || Mf(Ur))
          return !0;
        const Sn = e.createRng(), yo = e.createRng();
        try {
          Sn.setStart(ro, hn.anchorOffset), Sn.collapse(!0), yo.setStart(Ur, hn.focusOffset), yo.collapse(!0);
        } catch {
          return !0;
        }
        return Sn.compareBoundaryPoints(Sn.START_TO_START, yo) <= 0;
      }, Pa = {
        dom: e,
        win: n,
        serializer: s,
        editor: l,
        expand: (hn = { type: "word" }) => ut(Ut(e).expand(We(), hn)),
        collapse: ze,
        setCursorLocation: S,
        getContent: O,
        setContent: M,
        getBookmark: Z,
        moveToBookmark: de,
        select: we,
        isCollapsed: me,
        isEditable: Se,
        isForward: Tt,
        setNode: zt,
        getNode: an,
        getSel: Ye,
        setRng: ut,
        getRng: We,
        getStart: j,
        getEnd: U,
        getSelectedBlocks: Dn,
        normalize: () => {
          const hn = We(), ro = Ye();
          if (!oP(ro) && cC(l)) {
            const Ur = bn(e, hn);
            return Ur.each((Sn) => {
              ut(Sn, Tt());
            }), Ur.getOr(hn);
          }
          return hn;
        },
        selectorChanged: (hn, ro) => (v(hn, ro), Pa),
        selectorChangedWithUnbind: v,
        getScrollContainer: () => {
          let hn, ro = e.getRoot();
          for (; ro && ro.nodeName !== "BODY"; ) {
            if (ro.scrollHeight > ro.clientHeight) {
              hn = ro;
              break;
            }
            ro = ro.parentNode;
          }
          return hn;
        },
        scrollIntoView: (hn, ro) => {
          je(hn) ? zj(l, hn, ro) : OC(l, We(), ro);
        },
        placeCaretAt: (hn, ro) => ut(C(hn, ro, l.getDoc())),
        getBoundingClientRect: () => {
          const hn = We();
          return hn.collapsed ? vt.fromRangeStart(hn).getClientRects()[0] : hn.getBoundingClientRect();
        },
        destroy: () => {
          n = d = p = null, bs.destroy();
        }
      }, yl = Yp(Pa), bs = b1(Pa, l);
      return Pa.bookmarkManager = yl, Pa.controlSelection = bs, Pa;
    }, Tae = (e, n, s) => {
      n.addNodeFilter("br", (l, d, p) => {
        const v = Gt.extend({}, s.getBlockElements()), S = s.getNonEmptyElements(), O = s.getWhitespaceElements();
        v.body = 1;
        const M = (j) => j.name in v || jc(s, j);
        for (let j = 0, U = l.length; j < U; j++) {
          let Z = l[j], de = Z.parent;
          if (de && M(de) && Z === de.lastChild) {
            let we = Z.prev;
            for (; we; ) {
              const me = we.name;
              if (me !== "span" || we.attr("data-mce-type") !== "bookmark") {
                me === "br" && (Z = null);
                break;
              }
              we = we.prev;
            }
            if (Z && (Z.remove(), iT(s, S, O, de))) {
              const me = s.getElementRule(de.name);
              me && (me.removeEmpty ? de.remove() : me.paddEmpty && aT(e, p, M, de));
            }
          } else {
            let we = Z;
            for (; de && de.firstChild === we && de.lastChild === we && (we = de, !v[de.name]); )
              de = de.parent;
            if (we === de) {
              const me = new eu("#text", 3);
              me.value = Xa, Z.replace(me);
            }
          }
        }
      });
    }, jZ = (e, n, s) => {
      e.addAttributeFilter("data-mce-tabindex", (l, d) => {
        let p = l.length;
        for (; p--; ) {
          const v = l[p];
          v.attr("tabindex", v.attr("data-mce-tabindex")), v.attr(d, null);
        }
      }), e.addAttributeFilter("src,href,style", (l, d) => {
        const p = "data-mce-" + d, v = n.url_converter, S = n.url_converter_scope;
        let O = l.length;
        for (; O--; ) {
          const M = l[O];
          let j = M.attr(p);
          j !== void 0 ? (M.attr(d, j.length > 0 ? j : null), M.attr(p, null)) : (j = M.attr(d), d === "style" ? j = s.serializeStyle(s.parseStyle(j), M.name) : v && (j = v.call(S, j, d, M.name)), M.attr(d, j.length > 0 ? j : null));
        }
      }), e.addAttributeFilter("class", (l) => {
        let d = l.length;
        for (; d--; ) {
          const p = l[d];
          let v = p.attr("class");
          v && (v = v.replace(/(?:^|\s)mce-item-\w+(?!\S)/g, ""), p.attr("class", v.length > 0 ? v : null));
        }
      }), e.addAttributeFilter("data-mce-type", (l, d, p) => {
        let v = l.length;
        for (; v--; ) {
          const S = l[v];
          S.attr("data-mce-type") === "bookmark" && !p.cleanup && (Y.from(S.firstChild).exists((M) => {
            var j;
            return !Qh((j = M.value) !== null && j !== void 0 ? j : "");
          }) ? S.unwrap() : S.remove());
        }
      }), e.addNodeFilter("script,style", (l, d) => {
        var p;
        const v = (O) => O.replace(/(<!--\[CDATA\[|\]\]-->)/g, `
`).replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
        let S = l.length;
        for (; S--; ) {
          const O = l[S], M = O.firstChild, j = (p = M == null ? void 0 : M.value) !== null && p !== void 0 ? p : "";
          if (d === "script") {
            const U = O.attr("type");
            U && O.attr("type", U === "mce-no/type" ? null : U.replace(/^mce\-/, "")), n.element_format === "xhtml" && M && j.length > 0 && (M.value = `// <![CDATA[
` + v(j) + `
// ]]>`);
          } else
            n.element_format === "xhtml" && M && j.length > 0 && (M.value = `<!--
` + v(j) + `
-->`);
        }
      }), e.addNodeFilter("#comment", (l) => {
        let d = l.length;
        for (; d--; ) {
          const p = l[d], v = p.value;
          n.preserve_cdata && (v == null ? void 0 : v.indexOf("[CDATA[")) === 0 ? (p.name = "#cdata", p.type = 4, p.value = s.decode(v.replace(/^\[CDATA\[|\]\]$/g, ""))) : (v == null ? void 0 : v.indexOf("mce:protected ")) === 0 && (p.name = "#text", p.type = 3, p.raw = !0, p.value = unescape(v).substr(14));
        }
      }), e.addNodeFilter("xml:namespace,input", (l, d) => {
        let p = l.length;
        for (; p--; ) {
          const v = l[p];
          v.type === 7 ? v.remove() : v.type === 1 && d === "input" && !v.attr("type") && v.attr("type", "text");
        }
      }), e.addAttributeFilter("data-mce-type", (l) => {
        Ue(l, (d) => {
          d.attr("data-mce-type") === "format-caret" && (d.isEmpty(e.schema.getNonEmptyElements()) ? d.remove() : d.unwrap());
        });
      }), e.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-block,data-mce-type,data-mce-resize,data-mce-placeholder", (l, d) => {
        let p = l.length;
        for (; p--; )
          l[p].attr(d, null);
      }), n.remove_trailing_brs && Tae(n, e, e.schema);
    }, Ia = (e) => {
      const n = (l) => (l == null ? void 0 : l.name) === "br", s = e.lastChild;
      if (n(s)) {
        const l = s.prev;
        n(l) && (s.remove(), l.remove());
      }
    }, TR = (e, n, s) => {
      let l;
      const d = e.dom;
      let p = n.cloneNode(!0);
      const v = document.implementation;
      if (v.createHTMLDocument) {
        const S = v.createHTMLDocument("");
        Gt.each(p.nodeName === "BODY" ? p.childNodes : [p], (O) => {
          S.body.appendChild(S.importNode(O, !0));
        }), p.nodeName !== "BODY" ? p = S.body.firstChild : p = S.body, l = d.doc, d.doc = S;
      }
      return pP(e, {
        ...s,
        node: p
      }), l && (d.doc = l), p;
    }, Oae = (e, n) => je(e) && e.hasEventListeners("PreProcess") && !n.no_events, UZ = (e, n, s) => Oae(e, s) ? TR(e, n, s) : n, WZ = (e, n, s) => {
      Gt.inArray(n, s) === -1 && (e.addAttributeFilter(s, (l, d) => {
        let p = l.length;
        for (; p--; )
          l[p].attr(d, null);
      }), n.push(s));
    }, yx = (e, n, s) => !n.no_events && e ? Wy(e, {
      ...n,
      content: s
    }).content : s, Aae = (e, n, s) => {
      const l = Kc(s.getInner ? n.innerHTML : e.getOuterHTML(n));
      return s.selection || Vv(Me.fromDom(n)) ? l : Gt.trim(l);
    }, Pae = (e, n, s) => {
      const l = s.selection ? {
        forced_root_block: !1,
        ...s
      } : s, d = e.parse(n, l);
      return Ia(d), d;
    }, jl = (e, n, s) => Cg(e, n).serialize(s), $L = (e, n, s, l, d) => {
      const p = jl(n, s, l);
      return yx(e, d, p);
    }, LL = (e, n) => {
      const s = ["data-mce-selected"], l = {
        entity_encoding: "named",
        remove_trailing_brs: !0,
        pad_empty_with_br: !1,
        ...e
      }, d = n && n.dom ? n.dom : Js.DOM, p = n && n.schema ? n.schema : Hf(l), v = oh(l, p);
      jZ(v, l, d);
      const S = (O, M = {}) => {
        const j = {
          format: "html",
          ...M
        }, U = UZ(n, O, j), Z = Aae(d, U, j), de = Pae(v, Z, j);
        return j.format === "tree" ? de : $L(n, l, p, de, j);
      };
      return {
        schema: p,
        addNodeFilter: v.addNodeFilter,
        addAttributeFilter: v.addAttributeFilter,
        serialize: S,
        addRules: p.addValidElements,
        setRules: p.setValidElements,
        addTempAttr: Le(WZ, v, s),
        getTempAttrs: dt(s),
        getNodeFilters: v.getNodeFilters,
        getAttributeFilters: v.getAttributeFilters,
        removeNodeFilter: v.removeNodeFilter,
        removeAttributeFilter: v.removeAttributeFilter
      };
    }, OR = (e, n) => {
      const s = LL(e, n);
      return {
        schema: s.schema,
        addNodeFilter: s.addNodeFilter,
        addAttributeFilter: s.addAttributeFilter,
        serialize: s.serialize,
        addRules: s.addRules,
        setRules: s.setRules,
        addTempAttr: s.addTempAttr,
        getTempAttrs: s.getTempAttrs,
        getNodeFilters: s.getNodeFilters,
        getAttributeFilters: s.getAttributeFilters,
        removeNodeFilter: s.removeNodeFilter,
        removeAttributeFilter: s.removeAttributeFilter
      };
    }, ZZ = "html", GZ = (e, n) => ({
      ...e,
      format: n,
      get: !0,
      getInner: !0
    }), qT = (e, n = {}) => {
      const s = n.format ? n.format : ZZ, l = GZ(n, s);
      return Q$(e, l).fold(En, (d) => {
        const p = PZ(e, d);
        return mR(e, p, d);
      });
    }, qZ = "html", AR = (e, n) => ({
      format: qZ,
      ...e,
      set: !0,
      content: n
    }), PR = (e, n, s = {}) => {
      const l = AR(s, n);
      return pR(e, l).map((d) => {
        const p = DZ(e, d.content, d);
        return hR(e, p.html, d), p.content;
      }).getOr(n);
    }, HL = "autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists,template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format".split(","), zL = [], DR = "bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,template,textcolor,rtc".split(","), RR = [], KT = (e, n) => {
      const s = xn(n, (l) => Xn(e, l));
      return kt(s);
    }, KZ = (e) => {
      const n = KT(e, HL), s = e.forced_root_block;
      return (s === !1 || s === "") && n.push("forced_root_block (false only)"), kt(n);
    }, YZ = (e) => KT(e, zL), VL = (e, n) => {
      const s = Gt.makeMap(e.plugins, " "), d = xn(n, (p) => Xn(s, p));
      return kt(d);
    }, gf = (e) => VL(e, DR), XZ = (e) => VL(e, RR.map((n) => n.name)), QZ = (e, n) => {
      const s = KZ(e), l = gf(n), d = l.length > 0, p = s.length > 0, v = n.theme === "mobile";
      if (d || p || v) {
        const S = `
- `, O = v ? `

Themes:${S}mobile` : "", M = d ? `

Plugins:${S}${l.join(S)}` : "", j = p ? `

Options:${S}${s.join(S)}` : "";
        console.warn("The following deprecated features are currently enabled and have been removed in TinyMCE 7.0. These features will no longer work and should be removed from the TinyMCE configuration. See https://www.tiny.cloud/docs/tinymce/7/migration-from-6x/ for more information." + O + M + j);
      }
    }, JZ = (e) => Pn(RR, (n) => n.name === e).fold(() => e, (n) => n.replacedWith ? `${e}, replaced by ${n.replacedWith}` : e), eG = (e, n) => {
      const s = YZ(e), l = XZ(n), d = l.length > 0, p = s.length > 0;
      if (d || p) {
        const v = `
- `, S = d ? `

Plugins:${v}${l.map(JZ).join(v)}` : "", O = p ? `

Options:${v}${s.join(v)}` : "";
        console.warn("The following deprecated features are currently enabled but will be removed soon." + S + O);
      }
    }, tG = (e, n) => {
      QZ(e, n), eG(e, n);
    }, fS = Js.DOM, nG = (e) => {
      fS.setStyle(e.id, "display", e.orgDisplay);
    }, YT = (e) => Y.from(e).each((n) => n.destroy()), oG = (e) => {
      const n = e;
      n.contentAreaContainer = n.formElement = n.container = n.editorContainer = null, n.bodyElement = n.contentDocument = n.contentWindow = null, n.iframeElement = n.targetElm = null;
      const s = e.selection;
      if (s) {
        const l = s.dom;
        n.selection = s.win = s.dom = l.doc = null;
      }
    }, XT = (e) => {
      const n = e.formElement;
      n && (n._mceOldSubmit && (n.submit = n._mceOldSubmit, delete n._mceOldSubmit), fS.unbind(n, "submit reset", e.formEventDelegate));
    }, rG = (e) => {
      if (!e.removed) {
        const { _selectionOverrides: n, editorUpload: s } = e, l = e.getBody(), d = e.getElement();
        l && e.save({ is_removing: !0 }), e.removed = !0, e.unbindAllNativeEvents(), e.hasHiddenInput && je(d == null ? void 0 : d.nextSibling) && fS.remove(d.nextSibling), Zy(e), e.editorManager.remove(e), !e.inline && l && nG(e), hP(e), fS.remove(e.getContainer()), YT(n), YT(s), e.destroy();
      }
    }, sG = (e, n) => {
      const { selection: s, dom: l } = e;
      if (!e.destroyed) {
        if (!n && !e.removed) {
          e.remove();
          return;
        }
        n || (e.editorManager.off("beforeunload", e._beforeUnload), e.theme && e.theme.destroy && e.theme.destroy(), YT(s), YT(l)), XT(e), oG(e), e.destroyed = !0;
      }
    }, xx = (() => {
      const e = {};
      return {
        add: (d, p) => {
          e[d] = p;
        },
        get: (d) => e[d] ? e[d] : { icons: {} },
        has: (d) => Xn(e, d)
      };
    })(), wx = rc.ModelManager, jL = (e, n) => n.dom[e], iG = (e, n) => parseInt(fa(n, e), 10), lG = Le(jL, "clientWidth"), mS = Le(jL, "clientHeight"), UL = Le(iG, "margin-top"), WL = Le(iG, "margin-left"), cG = (e) => e.dom.getBoundingClientRect(), ZL = (e, n, s) => {
      const l = lG(e), d = mS(e);
      return n >= 0 && s >= 0 && n <= l && s <= d;
    }, uG = (e, n, s, l) => {
      const d = cG(n), p = e ? d.left + n.dom.clientLeft + WL(n) : 0, v = e ? d.top + n.dom.clientTop + UL(n) : 0, S = s - p, O = l - v;
      return {
        x: S,
        y: O
      };
    }, dG = (e, n, s) => {
      const l = Me.fromDom(e.getBody()), d = e.inline ? l : Gd(l), p = uG(e.inline, d, n, s);
      return ZL(d, p.x, p.y);
    }, fG = (e) => Y.from(e).map(Me.fromDom), mG = (e) => {
      const n = e.inline ? e.getBody() : e.getContentAreaContainer();
      return fG(n).map(Mu).getOr(!1);
    };
    var GL = () => {
      const e = () => {
        throw new Error("Theme did not provide a NotificationManager implementation.");
      };
      return {
        open: e,
        close: e,
        getArgs: e
      };
    };
    const qL = (e) => {
      const n = [], s = () => {
        const Z = e.theme;
        return Z && Z.getNotificationManagerImpl ? Z.getNotificationManagerImpl() : GL();
      }, l = () => Y.from(n[0]), d = (Z, de) => Z.type === de.type && Z.text === de.text && !Z.progressBar && !Z.timeout && !de.progressBar && !de.timeout, p = () => {
        l().each((Z) => {
          Z.reposition();
        });
      }, v = (Z) => {
        n.push(Z);
      }, S = (Z) => {
        so(n, (de) => de === Z).each((de) => {
          n.splice(de, 1);
        });
      }, O = (Z, de = !0) => e.removed || !mG(e) ? {} : (de && e.dispatch("BeforeOpenNotification", { notification: Z }), Pn(n, (we) => d(s().getArgs(we), Z)).getOrThunk(() => {
        e.editorManager.setActive(e);
        const we = s().open(Z, () => {
          S(we);
        }, () => PC(e));
        return v(we), p(), e.dispatch("OpenNotification", { notification: { ...we } }), we;
      })), M = () => {
        l().each((Z) => {
          s().close(Z), S(Z), p();
        });
      }, j = dt(n);
      return ((Z) => {
        Z.on("SkinLoaded", () => {
          const de = ic(Z);
          de && O({
            text: de,
            type: "warning",
            timeout: 0
          }, !1), p();
        }), Z.on("show ResizeEditor NodeChange", () => {
          requestAnimationFrame(p);
        }), Z.on("remove", () => {
          Ue(n.slice(), (de) => {
            s().close(de);
          });
        }), Z.addShortcut("alt+F12", "Focus to notification", () => l().map((de) => Me.fromDom(de.getEl())).each((de) => tx(de)));
      })(e), {
        open: O,
        close: M,
        getNotifications: j
      };
    }, Cx = rc.PluginManager, Gm = rc.ThemeManager;
    var KL = () => {
      const e = () => {
        throw new Error("Theme did not provide a WindowManager implementation.");
      };
      return {
        open: e,
        openUrl: e,
        alert: e,
        confirm: e,
        close: e
      };
    };
    const NR = (e) => {
      let n = [];
      const s = () => {
        const me = e.theme;
        return me && me.getWindowManagerImpl ? me.getWindowManagerImpl() : KL();
      }, l = (me, Se) => (...ze) => Se ? Se.apply(me, ze) : void 0, d = (me) => {
        e.dispatch("OpenWindow", { dialog: me });
      }, p = (me) => {
        e.dispatch("CloseWindow", { dialog: me });
      }, v = (me) => {
        n.push(me), d(me);
      }, S = (me) => {
        p(me), n = xn(n, (Se) => Se !== me), n.length === 0 && e.focus();
      }, O = () => Y.from(n[n.length - 1]), M = (me) => {
        e.editorManager.setActive(e), AC(e), e.ui.show();
        const Se = me();
        return v(Se), Se;
      }, j = (me, Se) => M(() => s().open(me, Se, S)), U = (me) => M(() => s().openUrl(me, S)), Z = (me, Se, ze) => {
        const Ye = s();
        Ye.alert(me, l(ze || Ye, Se));
      }, de = (me, Se, ze) => {
        const Ye = s();
        Ye.confirm(me, l(ze || Ye, Se));
      }, we = () => {
        O().each((me) => {
          s().close(me), S(me);
        });
      };
      return e.on("remove", () => {
        Ue(n, (me) => {
          s().close(me);
        });
      }), {
        open: j,
        openUrl: U,
        alert: Z,
        confirm: de,
        close: we
      };
    }, YL = (e, n) => {
      e.notificationManager.open({
        type: "error",
        text: n
      });
    }, QT = (e, n) => {
      e._skinLoaded ? YL(e, n) : e.on("SkinLoaded", () => {
        YL(e, n);
      });
    }, pG = (e, n) => {
      QT(e, Ii.translate([
        "Failed to upload image: {0}",
        n
      ]));
    }, Sx = (e, n, s) => {
      hl(e, n, { message: s }), console.error(s);
    }, pS = (e, n, s) => s ? `Failed to load ${e}: ${s} from url ${n}` : `Failed to load ${e} url: ${n}`, hG = (e, n, s) => {
      Sx(e, "PluginLoadError", pS("plugin", n, s));
    }, gG = (e, n, s) => {
      Sx(e, "IconsLoadError", pS("icons", n, s));
    }, bG = (e, n, s) => {
      Sx(e, "LanguageLoadError", pS("language", n, s));
    }, Dae = (e, n, s) => {
      Sx(e, "ThemeLoadError", pS("theme", n, s));
    }, qm = (e, n, s) => {
      Sx(e, "ModelLoadError", pS("model", n, s));
    }, MR = (e, n, s) => {
      const l = Ii.translate([
        "Failed to initialize plugin: {0}",
        n
      ]);
      hl(e, "PluginLoadError", { message: l }), JT(l, s), QT(e, l);
    }, JT = (e, ...n) => {
      const s = window.console;
      s && (s.error ? s.error(e, ...n) : s.log(e, ...n));
    }, vG = (e) => /^[a-z0-9\-]+$/i.test(e), IR = (e) => "content/" + e + "/content.css", yG = (e) => tinymce.Resource.has(IR(e)), gs = (e) => kx(e, sg(e)), xG = (e) => kx(e, Ac(e)), kx = (e, n) => {
      const s = e.editorManager.baseURL + "/skins/content", d = `content${e.editorManager.suffix}.css`;
      return en(n, (p) => yG(p) ? p : vG(p) && !e.inline ? `${s}/${p}/${d}` : e.documentBaseURI.toAbsolute(p));
    }, wG = (e) => {
      e.contentCSS = e.contentCSS.concat(gs(e), xG(e));
    }, CG = (e) => e ? hr(e.getElementsByTagName("img")) : [], SG = (e, n) => {
      const s = {};
      return { findAll: (d, p = mt) => {
        const v = xn(CG(d), (O) => {
          const M = O.src;
          return O.hasAttribute("data-mce-bogus") || O.hasAttribute("data-mce-placeholder") || !M || M === rn.transparentSrc ? !1 : lo(M, "blob:") ? !e.isUploaded(M) && p(O) : lo(M, "data:") ? p(O) : !1;
        }), S = en(v, (O) => {
          const M = O.src;
          if (Xn(s, M))
            return s[M].then((j) => G(j) ? j : {
              image: O,
              blobInfo: j.blobInfo
            });
          {
            const j = TT(n, M).then((U) => (delete s[M], {
              image: O,
              blobInfo: U
            })).catch((U) => (delete s[M], U));
            return s[M] = j, j;
          }
        });
        return Promise.all(S);
      } };
    }, FR = () => {
      let s = {};
      const l = (Z, de) => ({
        status: Z,
        resultUri: de
      }), d = (Z) => Z in s;
      return {
        hasBlobUri: d,
        getResultUri: (Z) => {
          const de = s[Z];
          return de ? de.resultUri : null;
        },
        isPending: (Z) => d(Z) ? s[Z].status === 1 : !1,
        isUploaded: (Z) => d(Z) ? s[Z].status === 2 : !1,
        markPending: (Z) => {
          s[Z] = l(1, null);
        },
        markUploaded: (Z, de) => {
          s[Z] = l(2, de);
        },
        removeFailed: (Z) => {
          delete s[Z];
        },
        destroy: () => {
          s = {};
        }
      };
    };
    let ev = 0;
    const wu = () => {
      const e = () => Math.round(Math.random() * 4294967295).toString(36);
      return "s" + (/* @__PURE__ */ new Date()).getTime().toString(36) + e() + e() + e();
    }, hS = (e) => e + ev++ + wu(), tv = () => {
      let e = [];
      const n = (U) => ({
        "image/jpeg": "jpg",
        "image/jpg": "jpg",
        "image/gif": "gif",
        "image/png": "png",
        "image/apng": "apng",
        "image/avif": "avif",
        "image/svg+xml": "svg",
        "image/webp": "webp",
        "image/bmp": "bmp",
        "image/tiff": "tiff"
      })[U.toLowerCase()] || "dat", s = (U, Z, de, we, me) => {
        if (G(U))
          return l({
            id: U,
            name: we,
            filename: me,
            blob: Z,
            base64: de
          });
        if (ve(U))
          return l(U);
        throw new Error("Unknown input type");
      }, l = (U) => {
        if (!U.blob || !U.base64)
          throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
        const Z = U.id || hS("blobid"), de = U.name || Z, we = U.blob;
        return {
          id: dt(Z),
          name: dt(de),
          filename: dt(U.filename || de + "." + n(we.type)),
          blob: dt(we),
          base64: dt(U.base64),
          blobUri: dt(U.blobUri || URL.createObjectURL(we)),
          uri: dt(U.uri)
        };
      }, d = (U) => {
        v(U.id()) || e.push(U);
      }, p = (U) => Pn(e, U).getOrUndefined(), v = (U) => p((Z) => Z.id() === U);
      return {
        create: s,
        add: d,
        get: v,
        getByUri: (U) => p((Z) => Z.blobUri() === U),
        getByData: (U, Z) => p((de) => de.base64() === U && de.blob().type === Z),
        findFirst: p,
        removeByUri: (U) => {
          e = xn(e, (Z) => Z.blobUri() === U ? (URL.revokeObjectURL(Z.blobUri()), !1) : !0);
        },
        destroy: () => {
          Ue(e, (U) => {
            URL.revokeObjectURL(U.blobUri());
          }), e = [];
        }
      };
    }, ah = (e, n) => {
      const s = {}, l = (me, Se) => me ? me.replace(/\/$/, "") + "/" + Se.replace(/^\//, "") : Se, d = (me, Se) => new Promise((ze, Ye) => {
        const We = new XMLHttpRequest();
        We.open("POST", n.url), We.withCredentials = n.credentials, We.upload.onprogress = (zt) => {
          Se(zt.loaded / zt.total * 100);
        }, We.onerror = () => {
          Ye("Image upload failed due to a XHR Transport error. Code: " + We.status);
        }, We.onload = () => {
          if (We.status < 200 || We.status >= 300) {
            Ye("HTTP Error: " + We.status);
            return;
          }
          const zt = JSON.parse(We.responseText);
          if (!zt || !G(zt.location)) {
            Ye("Invalid JSON: " + We.responseText);
            return;
          }
          ze(l(n.basePath, zt.location));
        };
        const ut = new FormData();
        ut.append("file", me.blob(), me.filename()), We.send(ut);
      }), p = ye(n.handler) ? n.handler : d, v = () => new Promise((me) => {
        me([]);
      }), S = (me, Se) => ({
        url: Se,
        blobInfo: me,
        status: !0
      }), O = (me, Se) => ({
        url: "",
        blobInfo: me,
        status: !1,
        error: Se
      }), M = (me, Se) => {
        Gt.each(s[me], (ze) => {
          ze(Se);
        }), delete s[me];
      }, j = (me, Se, ze) => (e.markPending(me.blobUri()), new Promise((Ye) => {
        let We, ut;
        try {
          const zt = () => {
            We && (We.close(), ut = qe);
          }, an = (Tt) => {
            zt(), e.markUploaded(me.blobUri(), Tt), M(me.blobUri(), S(me, Tt)), Ye(S(me, Tt));
          }, Dn = (Tt) => {
            zt(), e.removeFailed(me.blobUri()), M(me.blobUri(), O(me, Tt)), Ye(O(me, Tt));
          };
          ut = (Tt) => {
            Tt < 0 || Tt > 100 || Y.from(We).orThunk(() => Y.from(ze).map(St)).each((yt) => {
              We = yt, yt.progressBar.value(Tt);
            });
          }, Se(me, ut).then(an, (Tt) => {
            Dn(G(Tt) ? { message: Tt } : Tt);
          });
        } catch (zt) {
          Ye(O(me, zt));
        }
      })), U = (me) => me === d, Z = (me) => {
        const Se = me.blobUri();
        return new Promise((ze) => {
          s[Se] = s[Se] || [], s[Se].push(ze);
        });
      }, de = (me, Se) => (me = Gt.grep(me, (ze) => !e.isUploaded(ze.blobUri())), Promise.all(Gt.map(me, (ze) => e.isPending(ze.blobUri()) ? Z(ze) : j(ze, p, Se))));
      return { upload: (me, Se) => !n.url && U(p) ? v() : de(me, Se) };
    }, _x = (e) => () => e.notificationManager.open({
      text: e.translate("Image uploading..."),
      type: "info",
      timeout: -1,
      progressBar: !0
    }), eO = (e, n) => ah(n, {
      url: E2(e),
      basePath: ly(e),
      credentials: T2(e),
      handler: P_(e)
    }), BR = (e) => {
      const n = FR(), s = eO(e, n);
      return { upload: (l, d = !0) => s.upload(l, d ? _x(e) : void 0) };
    }, XL = (e, n) => e.dom.isEmpty(n.dom) && je(e.schema.getTextBlockElements()[gr(n)]), QL = (e) => (n) => {
      XL(e, n) && Ys(n, Me.fromHtml('<br data-mce-bogus="1" />'));
    }, kG = (e) => {
      const n = tv();
      let s, l;
      const d = FR(), p = [], v = (We) => (ut) => e.selection ? We(ut) : [], S = (We) => We + (We.indexOf("?") === -1 ? "?" : "&") + (/* @__PURE__ */ new Date()).getTime(), O = (We, ut, zt) => {
        let an = 0;
        do
          an = We.indexOf(ut, an), an !== -1 && (We = We.substring(0, an) + zt + We.substr(an + ut.length), an += zt.length - ut.length + 1);
        while (an !== -1);
        return We;
      }, M = (We, ut, zt) => {
        const an = `src="${zt}"${zt === rn.transparentSrc ? ' data-mce-placeholder="1"' : ""}`;
        return We = O(We, `src="${ut}"`, an), We = O(We, 'data-mce-src="' + ut + '"', 'data-mce-src="' + zt + '"'), We;
      }, j = (We, ut) => {
        Ue(e.undoManager.data, (zt) => {
          zt.type === "fragmented" ? zt.fragments = en(zt.fragments, (an) => M(an, We, ut)) : zt.content = M(zt.content, We, ut);
        });
      }, U = (We, ut) => {
        const zt = e.convertURL(ut, "src");
        j(We.src, ut), _a(Me.fromDom(We), {
          src: fi(e) ? S(ut) : ut,
          "data-mce-src": zt
        });
      }, Z = () => (s || (s = eO(e, d)), Se().then(v((We) => {
        const ut = en(We, (zt) => zt.blobInfo);
        return s.upload(ut, _x(e)).then(v((zt) => {
          const an = [];
          let Dn = !1;
          const Tt = en(zt, (yt, Lt) => {
            const { blobInfo: Vn, image: co } = We[Lt];
            let Xo = !1;
            return yt.status && xs(e) ? (yt.url && !Qn(co.src, yt.url) && (Dn = !0), n.removeByUri(co.src), sh(e) || U(co, yt.url)) : yt.error && (yt.error.remove && (j(co.src, rn.transparentSrc), an.push(co), Xo = !0), pG(e, yt.error.message)), {
              element: co,
              status: yt.status,
              uploadUri: yt.url,
              blobInfo: Vn,
              removed: Xo
            };
          });
          return an.length > 0 && !sh(e) ? e.undoManager.transact(() => {
            Ue(Iu(an), (yt) => {
              const Lt = Di(yt);
              ys(yt), Lt.each(QL(e)), n.removeByUri(yt.dom.src);
            });
          }) : Dn && e.undoManager.dispatchChange(), Tt;
        }));
      }))), de = () => ei(e) ? Z() : Promise.resolve([]), we = (We) => Ko(p, (ut) => ut(We)), me = (We) => {
        p.push(We);
      }, Se = () => (l || (l = SG(d, n)), l.findAll(e.getBody(), we).then(v((We) => {
        const ut = xn(We, (zt) => G(zt) ? (QT(e, zt), !1) : zt.uriType !== "blob");
        return sh(e) || Ue(ut, (zt) => {
          j(zt.image.src, zt.blobInfo.blobUri()), zt.image.src = zt.blobInfo.blobUri(), zt.image.removeAttribute("data-mce-src");
        }), ut;
      }))), ze = () => {
        n.destroy(), d.destroy(), l = s = null;
      }, Ye = (We) => We.replace(/src="(blob:[^"]+)"/g, (ut, zt) => {
        const an = d.getResultUri(zt);
        if (an)
          return 'src="' + an + '"';
        let Dn = n.getByUri(zt);
        return Dn || (Dn = Ct(e.editorManager.get(), (Tt, yt) => Tt || yt.editorUpload && yt.editorUpload.blobCache.getByUri(zt), void 0)), Dn ? 'src="data:' + Dn.blob().type + ";base64," + Dn.base64() + '"' : ut;
      });
      return e.on("SetContent", () => {
        ei(e) ? de() : Se();
      }), e.on("RawSaveContent", (We) => {
        We.content = Ye(We.content);
      }), e.on("GetContent", (We) => {
        We.source_view || We.format === "raw" || We.format === "tree" || (We.content = Ye(We.content));
      }), e.on("PostRender", () => {
        e.parser.addNodeFilter("img", (We) => {
          Ue(We, (ut) => {
            const zt = ut.attr("src");
            if (!zt || n.getByUri(zt))
              return;
            const an = d.getResultUri(zt);
            an && ut.attr("src", an);
          });
        });
      }), {
        blobCache: n,
        addFilter: me,
        uploadImages: Z,
        uploadImagesAuto: de,
        scanForImages: Se,
        destroy: ze
      };
    }, _G = (e) => {
      const n = e.dom, s = e.schema.type, l = {
        valigntop: [{
          selector: "td,th",
          styles: { verticalAlign: "top" }
        }],
        valignmiddle: [{
          selector: "td,th",
          styles: { verticalAlign: "middle" }
        }],
        valignbottom: [{
          selector: "td,th",
          styles: { verticalAlign: "bottom" }
        }],
        alignleft: [
          {
            selector: "figure.image",
            collapsed: !1,
            classes: "align-left",
            ceFalseOverride: !0,
            preview: "font-family font-size"
          },
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "left" },
            inherit: !1,
            preview: !1
          },
          {
            selector: "img,audio,video",
            collapsed: !1,
            styles: { float: "left" },
            preview: "font-family font-size"
          },
          {
            selector: "table",
            collapsed: !1,
            styles: {
              marginLeft: "0px",
              marginRight: "auto"
            },
            onformat: (d) => {
              n.setStyle(d, "float", null);
            },
            preview: "font-family font-size"
          },
          {
            selector: ".mce-preview-object,[data-ephox-embed-iri]",
            ceFalseOverride: !0,
            styles: { float: "left" }
          }
        ],
        aligncenter: [
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "center" },
            inherit: !1,
            preview: "font-family font-size"
          },
          {
            selector: "figure.image",
            collapsed: !1,
            classes: "align-center",
            ceFalseOverride: !0,
            preview: "font-family font-size"
          },
          {
            selector: "img,audio,video",
            collapsed: !1,
            styles: {
              display: "block",
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: !1
          },
          {
            selector: "table",
            collapsed: !1,
            styles: {
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: "font-family font-size"
          },
          {
            selector: ".mce-preview-object",
            ceFalseOverride: !0,
            styles: {
              display: "table",
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: !1
          },
          {
            selector: "[data-ephox-embed-iri]",
            ceFalseOverride: !0,
            styles: {
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: !1
          }
        ],
        alignright: [
          {
            selector: "figure.image",
            collapsed: !1,
            classes: "align-right",
            ceFalseOverride: !0,
            preview: "font-family font-size"
          },
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "right" },
            inherit: !1,
            preview: "font-family font-size"
          },
          {
            selector: "img,audio,video",
            collapsed: !1,
            styles: { float: "right" },
            preview: "font-family font-size"
          },
          {
            selector: "table",
            collapsed: !1,
            styles: {
              marginRight: "0px",
              marginLeft: "auto"
            },
            onformat: (d) => {
              n.setStyle(d, "float", null);
            },
            preview: "font-family font-size"
          },
          {
            selector: ".mce-preview-object,[data-ephox-embed-iri]",
            ceFalseOverride: !0,
            styles: { float: "right" },
            preview: !1
          }
        ],
        alignjustify: [{
          selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
          styles: { textAlign: "justify" },
          inherit: !1,
          preview: "font-family font-size"
        }],
        bold: [
          {
            inline: "strong",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          },
          {
            inline: "span",
            styles: { fontWeight: "bold" }
          },
          {
            inline: "b",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        italic: [
          {
            inline: "em",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          },
          {
            inline: "span",
            styles: { fontStyle: "italic" }
          },
          {
            inline: "i",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        underline: [
          {
            inline: "span",
            styles: { textDecoration: "underline" },
            exact: !0
          },
          {
            inline: "u",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        strikethrough: /* @__PURE__ */ (() => {
          const d = {
            inline: "span",
            styles: { textDecoration: "line-through" },
            exact: !0
          }, p = {
            inline: "strike",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }, v = {
            inline: "s",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          };
          return s !== "html4" ? [
            v,
            d,
            p
          ] : [
            d,
            v,
            p
          ];
        })(),
        forecolor: {
          inline: "span",
          styles: { color: "%value" },
          links: !0,
          remove_similar: !0,
          clear_child_styles: !0
        },
        hilitecolor: {
          inline: "span",
          styles: { backgroundColor: "%value" },
          links: !0,
          remove_similar: !0,
          clear_child_styles: !0
        },
        fontname: {
          inline: "span",
          toggle: !1,
          styles: { fontFamily: "%value" },
          clear_child_styles: !0
        },
        fontsize: {
          inline: "span",
          toggle: !1,
          styles: { fontSize: "%value" },
          clear_child_styles: !0
        },
        lineheight: {
          selector: "h1,h2,h3,h4,h5,h6,p,li,td,th,div",
          styles: { lineHeight: "%value" }
        },
        fontsize_class: {
          inline: "span",
          attributes: { class: "%value" }
        },
        blockquote: {
          block: "blockquote",
          wrapper: !0,
          remove: "all"
        },
        subscript: { inline: "sub" },
        superscript: { inline: "sup" },
        code: { inline: "code" },
        link: {
          inline: "a",
          selector: "a",
          remove: "all",
          split: !0,
          deep: !0,
          onmatch: (d, p, v) => On(d) && d.hasAttribute("href"),
          onformat: (d, p, v) => {
            Gt.each(v, (S, O) => {
              n.setAttrib(d, O, S);
            });
          }
        },
        lang: {
          inline: "span",
          clear_child_styles: !0,
          remove_similar: !0,
          attributes: {
            lang: "%value",
            "data-mce-lang": (d) => {
              var p;
              return (p = d == null ? void 0 : d.customValue) !== null && p !== void 0 ? p : null;
            }
          }
        },
        removeformat: [
          {
            selector: "b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small",
            remove: "all",
            split: !0,
            expand: !1,
            block_expand: !0,
            deep: !0
          },
          {
            selector: "span",
            attributes: [
              "style",
              "class"
            ],
            remove: "empty",
            split: !0,
            expand: !1,
            deep: !0
          },
          {
            selector: "*",
            attributes: [
              "style",
              "class"
            ],
            split: !1,
            expand: !1,
            deep: !0
          }
        ]
      };
      return Gt.each("p h1 h2 h3 h4 h5 h6 div address pre dt dd samp".split(/\s/), (d) => {
        l[d] = {
          block: d,
          remove: "all"
        };
      }), l;
    }, $R = {
      remove_similar: !0,
      inherit: !1
    }, j1 = {
      selector: "td,th",
      ...$R
    }, JL = {
      tablecellbackgroundcolor: {
        styles: { backgroundColor: "%value" },
        ...j1
      },
      tablecellverticalalign: {
        styles: { "vertical-align": "%value" },
        ...j1
      },
      tablecellbordercolor: {
        styles: { borderColor: "%value" },
        ...j1
      },
      tablecellclass: {
        classes: ["%value"],
        ...j1
      },
      tableclass: {
        selector: "table",
        classes: ["%value"],
        ...$R
      },
      tablecellborderstyle: {
        styles: { borderStyle: "%value" },
        ...j1
      },
      tablecellborderwidth: {
        styles: { borderWidth: "%value" },
        ...j1
      }
    }, e6 = dt(JL), LR = (e) => {
      const n = {}, s = (v) => je(v) ? n[v] : n, l = (v) => Xn(n, v), d = (v, S) => {
        v && (G(v) ? (Xe(S) || (S = [S]), Ue(S, (O) => {
          ot(O.deep) && (O.deep = !Wu(O)), ot(O.split) && (O.split = !Wu(O) || Bi(O)), ot(O.remove) && Wu(O) && !Bi(O) && (O.remove = "none"), Wu(O) && Bi(O) && (O.mixed = !0, O.block_expand = !0), G(O.classes) && (O.classes = O.classes.split(/\s+/));
        }), n[v] = S) : Ht(v, (O, M) => {
          d(M, O);
        }));
      }, p = (v) => (v && n[v] && delete n[v], n);
      return d(_G(e)), d(e6()), d(P2(e)), {
        get: s,
        has: l,
        register: d,
        unregister: p
      };
    }, HR = Gt.each, bf = Js.DOM, t6 = (e) => je(e) && ve(e), n6 = (e, n) => {
      const s = n && n.schema || Hf({}), l = (O, M) => {
        M.classes.length > 0 && bf.addClass(O, M.classes.join(" ")), bf.setAttribs(O, M.attrs);
      }, d = (O) => {
        const M = G(O) ? {
          name: O,
          classes: [],
          attrs: {}
        } : O, j = bf.create(M.name);
        return l(j, M), j;
      }, p = (O, M) => {
        const j = s.getElementRule(O.nodeName.toLowerCase()), U = j == null ? void 0 : j.parentsRequired;
        return U && U.length ? M && At(U, M) ? M : U[0] : !1;
      }, v = (O, M, j) => {
        let U;
        const Z = M[0], de = t6(Z) ? Z.name : void 0, we = p(O, de);
        if (we)
          de === we ? (U = Z, M = M.slice(1)) : U = we;
        else if (Z)
          U = Z, M = M.slice(1);
        else if (!j)
          return O;
        const me = U ? d(U) : bf.create("div");
        me.appendChild(O), j && Gt.each(j, (ze) => {
          const Ye = d(ze);
          me.insertBefore(Ye, O);
        });
        const Se = t6(U) ? U.siblings : void 0;
        return v(me, M, Se);
      }, S = bf.create("div");
      if (e.length > 0) {
        const O = e[0], M = d(O), j = t6(O) ? O.siblings : void 0;
        S.appendChild(v(M, e.slice(1), j));
      }
      return S;
    }, EG = (e) => {
      e = Gt.trim(e);
      let n = "div";
      const s = {
        name: n,
        classes: [],
        attrs: {},
        selector: e
      };
      return e !== "*" && (n = e.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, (l, d, p, v, S) => {
        switch (d) {
          case "#":
            s.attrs.id = p;
            break;
          case ".":
            s.classes.push(p);
            break;
          case ":":
            Gt.inArray("checked disabled enabled read-only required".split(" "), p) !== -1 && (s.attrs[p] = p);
            break;
        }
        if (v === "[") {
          const O = S.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
          O && (s.attrs[O[1]] = O[2]);
        }
        return "";
      })), s.name = n || "div", s;
    }, ih = (e) => G(e) ? (e = e.split(/\s*,\s*/)[0], e = e.replace(/\s*(~\+|~|\+|>)\s*/g, "$1"), Gt.map(e.split(/(?:>|\s+(?![^\[\]]+\]))/), (n) => {
      const s = Gt.map(n.split(/(?:~\+|~|\+)/), EG), l = s.pop();
      return s.length && (l.siblings = s), l;
    }).reverse()) : [], Rae = (e, n) => {
      let s = "", l = D2(e);
      if (l === "")
        return "";
      const d = (Z) => G(Z) ? Z.replace(/%(\w+)/g, "") : "", p = (Z, de) => bf.getStyle(de ?? e.getBody(), Z, !0);
      if (G(n)) {
        const Z = e.formatter.get(n);
        if (!Z)
          return "";
        n = Z[0];
      }
      if ("preview" in n) {
        const Z = n.preview;
        if (Z === !1)
          return "";
        l = Z || l;
      }
      let v = n.block || n.inline || "span", S;
      const O = ih(n.selector);
      O.length > 0 ? (O[0].name || (O[0].name = v), v = n.selector, S = n6(O, e)) : S = n6([v], e);
      const M = bf.select(v, S)[0] || S.firstChild;
      HR(n.styles, (Z, de) => {
        const we = d(Z);
        we && bf.setStyle(M, de, we);
      }), HR(n.attributes, (Z, de) => {
        const we = d(Z);
        we && bf.setAttrib(M, de, we);
      }), HR(n.classes, (Z) => {
        const de = d(Z);
        bf.hasClass(M, de) || bf.addClass(M, de);
      }), e.dispatch("PreviewFormats"), bf.setStyles(S, {
        position: "absolute",
        left: -65535
      }), e.getBody().appendChild(S);
      const j = p("fontSize"), U = /px$/.test(j) ? parseInt(j, 10) : 0;
      return HR(l.split(" "), (Z) => {
        let de = p(Z, M);
        if (!(Z === "background-color" && /transparent|rgba\s*\([^)]+,\s*0\)/.test(de) && (de = p(Z), nf(de).toLowerCase() === "#ffffff")) && !(Z === "color" && nf(de).toLowerCase() === "#000000")) {
          if (Z === "font-size" && /em|%$/.test(de)) {
            if (U === 0)
              return;
            de = parseFloat(de) / (/%$/.test(de) ? 100 : 1) * U + "px";
          }
          Z === "border" && de && (s += "padding:0 2px;"), s += Z + ":" + de + ";";
        }
      }), e.dispatch("AfterPreviewFormats"), bf.remove(S), s;
    }, Nae = (e) => {
      e.addShortcut("meta+b", "", "Bold"), e.addShortcut("meta+i", "", "Italic"), e.addShortcut("meta+u", "", "Underline");
      for (let n = 1; n <= 6; n++)
        e.addShortcut("access+" + n, "", [
          "FormatBlock",
          !1,
          "h" + n
        ]);
      e.addShortcut("access+7", "", [
        "FormatBlock",
        !1,
        "p"
      ]), e.addShortcut("access+8", "", [
        "FormatBlock",
        !1,
        "div"
      ]), e.addShortcut("access+9", "", [
        "FormatBlock",
        !1,
        "address"
      ]);
    }, o6 = (e) => {
      const n = LR(e), s = Qe({});
      return Nae(e), c$(e), sh(e) || _$(s, e), {
        get: n.get,
        has: n.has,
        register: n.register,
        unregister: n.unregister,
        apply: (l, d, p) => {
          RL(e, l, d, p);
        },
        remove: (l, d, p, v) => {
          TZ(e, l, d, p, v);
        },
        toggle: (l, d, p) => {
          OZ(e, l, d, p);
        },
        match: (l, d, p, v) => GT(e, l, d, p, v),
        closest: (l) => DL(e, l),
        matchAll: (l, d) => kZ(e, l, d),
        matchNode: (l, d, p, v) => _Z(e, l, d, p, v),
        canApply: (l) => EZ(e, l),
        formatChanged: (l, d, p, v) => AZ(e, s, l, d, p, v),
        getCssText: Le(Rae, e)
      };
    }, Ex = (e) => {
      switch (e.toLowerCase()) {
        case "undo":
        case "redo":
        case "mcefocus":
          return !0;
        default:
          return !1;
      }
    }, TG = (e, n, s) => {
      const l = Qe(!1), d = (O) => {
        vx(n, !1, s), n.add({}, O);
      };
      e.on("init", () => {
        n.add();
      }), e.on("BeforeExecCommand", (O) => {
        const M = O.command;
        Ex(M) || (vL(n, s), n.beforeChange());
      }), e.on("ExecCommand", (O) => {
        const M = O.command;
        Ex(M) || d(O);
      }), e.on("ObjectResizeStart cut", () => {
        n.beforeChange();
      }), e.on("SaveContent ObjectResized blur", d), e.on("dragend", d), e.on("keyup", (O) => {
        const M = O.keyCode;
        if (O.isDefaultPrevented())
          return;
        const j = rn.os.isMacOS() && O.key === "Meta";
        (M >= 33 && M <= 36 || M >= 37 && M <= 40 || M === 45 || O.ctrlKey || j) && (d(), e.nodeChanged()), (M === 46 || M === 8) && e.nodeChanged(), l.get() && n.typing && !xR(jT(e), n.data[0]) && (e.isDirty() || e.setDirty(!0), e.dispatch("TypingUndo"), l.set(!1), e.nodeChanged());
      }), e.on("keydown", (O) => {
        const M = O.keyCode;
        if (O.isDefaultPrevented())
          return;
        if (M >= 33 && M <= 36 || M >= 37 && M <= 40 || M === 45) {
          n.typing && d(O);
          return;
        }
        const j = O.ctrlKey && !O.altKey || O.metaKey;
        if ((M < 16 || M > 20) && M !== 224 && M !== 91 && !n.typing && !j) {
          n.beforeChange(), vx(n, !0, s), n.add({}, O), l.set(!0);
          return;
        }
        (rn.os.isMacOS() ? O.metaKey : O.ctrlKey && !O.altKey) && n.beforeChange();
      }), e.on("mousedown", (O) => {
        n.typing && d(O);
      });
      const p = (O) => O.inputType === "insertReplacementText", v = (O) => O.inputType === "insertText" && O.data === null, S = (O) => O.inputType === "insertFromPaste" || O.inputType === "insertFromDrop";
      e.on("input", (O) => {
        O.inputType && (p(O) || v(O) || S(O)) && d(O);
      }), e.on("AddUndo Undo Redo ClearUndos", (O) => {
        O.isDefaultPrevented() || e.nodeChanged();
      });
    }, r6 = (e) => {
      e.addShortcut("meta+z", "", "Undo"), e.addShortcut("meta+y,meta+shift+z", "", "Redo");
    }, zR = (e) => {
      const n = Mi(), s = Qe(0), l = Qe(0), d = {
        data: [],
        typing: !1,
        beforeChange: () => {
          _L(e, s, n);
        },
        add: (p, v) => SR(e, d, l, s, n, p, v),
        dispatchChange: () => {
          e.setDirty(!0);
          const p = jT(e);
          p.bookmark = g2(e.selection), e.dispatch("change", {
            level: p,
            lastLevel: yn(d.data, l.get()).getOrUndefined()
          });
        },
        undo: () => EL(e, d, s, l),
        redo: () => TL(e, l, d.data),
        clear: () => {
          kR(e, d, l);
        },
        reset: () => {
          OL(e, d);
        },
        hasUndo: () => AL(e, d, l),
        hasRedo: () => PL(e, d, l),
        transact: (p) => CZ(e, d, s, p),
        ignore: (p) => {
          _R(e, s, p);
        },
        extra: (p, v) => {
          SZ(e, d, l, p, v);
        }
      };
      return sh(e) || TG(e, d, s), r6(e), d;
    }, s6 = [
      9,
      27,
      Xt.HOME,
      Xt.END,
      19,
      20,
      44,
      144,
      145,
      33,
      34,
      45,
      16,
      17,
      18,
      91,
      92,
      93,
      Xt.DOWN,
      Xt.UP,
      Xt.LEFT,
      Xt.RIGHT
    ].concat(rn.browser.isFirefox() ? [224] : []), a6 = "data-mce-placeholder", i6 = (e) => e.type === "keydown" || e.type === "keyup", Pg = (e) => {
      const n = e.keyCode;
      return n === Xt.BACKSPACE || n === Xt.DELETE;
    }, OG = (e) => {
      if (i6(e)) {
        const n = e.keyCode;
        return !Pg(e) && (Xt.metaKeyPressed(e) || e.altKey || n >= 112 && n <= 123 || At(s6, n));
      } else
        return !1;
    }, AG = (e) => i6(e) && !(Pg(e) || e.type === "keyup" && e.keyCode === 229), PG = (e, n, s) => {
      if (e.isEmpty(n, void 0, {
        skipBogus: !1,
        includeZwsp: !0
      })) {
        const l = n.firstElementChild;
        return l ? e.getStyle(n.firstElementChild, "padding-left") || e.getStyle(n.firstElementChild, "padding-right") ? !1 : s === l.nodeName.toLowerCase() : !0;
      } else
        return !1;
    }, DG = (e) => {
      var n;
      const s = e.dom, l = Pl(e), d = (n = Jv(e)) !== null && n !== void 0 ? n : "", p = (v, S) => {
        if (OG(v))
          return;
        const O = e.getBody(), M = AG(v) ? !1 : PG(s, O, l);
        (s.getAttrib(O, a6) !== "" !== M || S) && (s.setAttrib(O, a6, M ? d : null), qy(e, M), e.on(M ? "keydown" : "keyup", p), e.off(M ? "keyup" : "keydown", p));
      };
      ko(d) && e.on("init", (v) => {
        p(v, !0), e.on("change SetContent ExecCommand", p), e.on("paste", (S) => Td.setEditorTimeout(e, () => p(S)));
      });
    }, RG = (e, n) => ({
      block: e,
      position: n
    }), NG = (e, n) => ({
      from: e,
      to: n
    }), VR = (e, n) => {
      const s = Me.fromDom(e), l = Me.fromDom(n.container());
      return GE(s, l).map((d) => RG(d, n));
    }, MG = (e) => !(Gi(e.to.block, e.from.block) || Gi(e.from.block, e.to.block)), IG = (e) => !zr(e.from.block, e.to.block), gS = (e, n) => aa(n, (d) => vb(d) || Rt(d.dom), (d) => zr(d, e)).filter(rt).getOr(e), FG = (e, n) => {
      const s = Me.fromDom(e);
      return zr(gS(s, n.from.block), gS(s, n.to.block));
    }, BG = (e) => Vr(e.from.block.dom) === !1 && Vr(e.to.block.dom) === !1, Mae = (e) => {
      const n = (s) => s_(s) || ml(s.dom) || Oc(s);
      return n(e.from.block) && n(e.to.block);
    }, bS = (e, n, s, l) => Wr(l.position.getNode()) && !Es(e, l.block) ? mg(!1, l.block.dom).bind((d) => d.isEqual(l.position) ? hu(s, n, d).bind((p) => VR(n, p)) : Y.some(l)).getOr(l) : l, $G = (e, n, s, l) => {
      const d = VR(n, vt.fromRangeStart(l)), p = d.bind((v) => hu(s, n, v.position).bind((S) => VR(n, S).map((O) => bS(e, n, s, O))));
      return ga(d, p, NG).filter((v) => IG(v) && FG(n, v) && BG(v) && Mae(v) && MG(v));
    }, jR = (e, n, s, l) => l.collapsed ? $G(e, n, s, l) : Y.none(), l6 = (e, n, s) => {
      const l = s ? lp(e).reverse() : qi(e), d = so(l, (p) => n.isBlock(gr(p))).fold(dt(l), (p) => l.slice(0, p));
      return s ? d.reverse() : d;
    }, LG = (e, n, s, l, d) => {
      if (d && Gi(e, n))
        return l6(n, s, l);
      if (d && Gi(n, e))
        return l6(e, s, l);
      {
        const p = Ya(n);
        return so(p, (v) => s.isBlock(gr(v))).fold(dt(p), (v) => p.slice(0, v));
      }
    }, c6 = (e, n, s, l, d) => {
      const p = LG(e, n, s, l, d);
      return Ue(p, ys), p;
    }, u6 = (e, n, s) => {
      const l = Sg(s, n);
      return Pn(l.reverse(), (d) => Es(e, d)).each(ys);
    }, U1 = (e, n) => xn(lp(n), (s) => !Es(e, s)).length === 0, W1 = (e, n, s, l, d, p) => {
      if (Es(l, s))
        return qc(s), zl(s.dom);
      U1(l, p) && Es(l, n) && Ki(p, Me.fromTag("br"));
      const v = Xc(s.dom, vt.before(p.dom));
      return Ue(c6(s, n, l, d, !1), (S) => {
        Ki(p, S);
      }), u6(l, e, n), v;
    }, tO = (e, n) => e.isInline(gr(n)), nO = (e, n, s, l, d) => {
      if (Es(l, s)) {
        if (Es(l, n)) {
          const S = Vt(((O) => {
            const M = (j, U) => Df(j).fold(() => U, (Z) => tO(l, Z) ? M(Z, U.concat(rf(Z))) : U);
            return M(O, []);
          })(s), (O, M) => ($h(O, M), M), Xh());
          Lc(n), Ys(n, S);
        }
        return ys(s), zl(n.dom);
      }
      const p = gu(s.dom);
      return Ue(c6(s, n, l, d, !0), (v) => {
        d && Gi(n, s) ? Cm(s, v) : Ys(s, v);
      }), u6(l, e, n), p;
    }, Z1 = (e, n) => {
      const s = Sg(n, e);
      return Y.from(s[s.length - 1]);
    }, G1 = (e, n) => Gi(n, e) ? Z1(n, e) : Y.none(), vS = (e, n) => {
      mg(e, n.dom).bind((s) => Y.from(s.getNode())).map(Me.fromDom).filter(gb).each(ys);
    }, q1 = (e, n, s, l, d) => (vS(!0, n), vS(!1, s), G1(n, s).fold(Le(nO, e, n, s, l, d), Le(W1, e, n, s, l, d))), UR = (e, n, s, l, d, p = !1) => {
      if (p) {
        if (Gi(l, s))
          return q1(e, l, s, d, !n);
        if (Gi(s, l))
          return q1(e, s, l, d, n);
      }
      return n ? q1(e, l, s, d, n) : q1(e, s, l, d, !n);
    }, yS = (e, n) => {
      const s = Me.fromDom(e.getBody());
      return jR(e.schema, s.dom, n, e.selection.getRng()).map((d) => () => {
        UR(s, n, d.from.block, d.to.block, e.schema, !0).each((p) => {
          e.selection.setRng(p.toRange());
        });
      });
    }, WR = (e, n, s) => {
      const l = n.getRng();
      return ga(GE(e, Me.fromDom(l.startContainer)), GE(e, Me.fromDom(l.endContainer)), (d, p) => zr(d, p) ? Y.none() : Y.some(() => {
        l.deleteContents(), UR(e, !0, d, p, s).each((v) => {
          n.setRng(v.toRange());
        });
      })).getOr(Y.none());
    }, ZR = (e, n) => {
      const s = Me.fromDom(n), l = Le(zr, e);
      return Is(s, vb, l).isSome();
    }, d6 = (e, n) => ZR(e, n.startContainer) || ZR(e, n.endContainer), Tx = (e, n) => {
      const s = Xc(e.dom, vt.fromRangeStart(n)).isNone(), l = Hl(e.dom, vt.fromRangeEnd(n)).isNone();
      return !d6(e, n) && s && l;
    }, f6 = (e) => Y.some(() => {
      e.setContent(""), e.selection.setCursorLocation();
    }), m6 = (e) => {
      const n = Me.fromDom(e.getBody()), s = e.selection.getRng();
      return Tx(n, s) ? f6(e) : WR(n, e.selection, e.schema);
    }, oO = (e, n) => e.selection.isCollapsed() ? Y.none() : m6(e), sm = (e, n, s, l, d) => Y.from(n._selectionOverrides.showCaret(e, s, l, d)), p6 = (e) => {
      const n = e.ownerDocument.createRange();
      return n.selectNode(e), n;
    }, Ox = (e, n) => e.dispatch("BeforeObjectSelected", { target: n }).isDefaultPrevented() ? Y.none() : Y.some(p6(n)), h6 = (e, n, s) => {
      const l = Dl(1, e.getBody(), n), d = vt.fromRangeStart(l), p = d.getNode();
      if (_y(p))
        return sm(1, e, p, !d.isAtEnd(), !1);
      const v = d.getNode(!0);
      if (_y(v))
        return sm(1, e, v, !1, !1);
      const S = _g(e.dom.getRoot(), d.getNode());
      return _y(S) ? sm(1, e, S, !1, s) : Y.none();
    }, rO = (e, n, s) => n.collapsed ? h6(e, n, s).getOr(n) : n, Dg = (e) => th(e) || oo(e), nv = (e) => Zb(e) || sx(e), am = (e, n) => {
      Zt(n) && n.data.length === 0 && e.remove(n);
    }, g6 = (e, n, s, l, d, p) => {
      sm(l, e, p.getNode(!d), d, !0).each((v) => {
        if (n.collapsed) {
          const S = n.cloneRange();
          d ? S.setEnd(v.startContainer, v.startOffset) : S.setStart(v.endContainer, v.endOffset), S.deleteContents();
        } else
          n.deleteContents();
        e.selection.setRng(v);
      }), am(e.dom, s);
    }, HG = (e, n) => {
      const s = e.selection.getRng();
      if (!Zt(s.commonAncestorContainer))
        return Y.none();
      const l = n ? Fi.Forwards : Fi.Backwards, d = pl(e.getBody()), p = Le(G2, n ? d.next : d.prev), v = n ? Dg : nv, S = dg(l, e.getBody(), s), O = p(S), M = O && Od(n, O);
      if (!M || !Py(S, M))
        return Y.none();
      if (v(M))
        return Y.some(() => g6(e, s, S.getNode(), l, n, M));
      const j = p(M);
      return j && v(j) && Py(M, j) ? Y.some(() => g6(e, s, S.getNode(), l, n, j)) : Y.none();
    }, GR = (e, n) => HG(e, n), qR = (e, n) => {
      const s = e.getBody();
      return n ? zl(s).filter(th) : gu(s).filter(Zb);
    }, KR = (e) => {
      const n = e.selection.getRng();
      return !n.collapsed && (qR(e, !0).exists((s) => s.isEqual(vt.fromRangeStart(n))) || qR(e, !1).exists((s) => s.isEqual(vt.fromRangeEnd(n))));
    }, zG = (e) => je(e) && (vb(Me.fromDom(e)) || Oc(Me.fromDom(e))), Pd = ss.generate([
      { remove: ["element"] },
      { moveToElement: ["element"] },
      { moveToPosition: ["position"] }
    ]), VG = (e, n) => {
      const s = n.getNode(!e), l = e ? "after" : "before";
      return On(s) && s.getAttribute("data-mce-caret") === l;
    }, jG = (e, n, s, l, d) => {
      const p = (v) => d.isInline(v.nodeName.toLowerCase()) && !pu(s, l, e);
      return Oy(!n, s).fold(() => Oy(n, l).fold(tt, p), p);
    }, b6 = (e, n, s, l, d) => {
      const p = d.getNode(!s);
      return GE(Me.fromDom(n), Me.fromDom(l.getNode())).map((v) => Es(e, v) ? Pd.remove(v.dom) : Pd.moveToElement(p)).orThunk(() => Y.some(Pd.moveToElement(p)));
    }, v6 = (e, n, s, l) => hu(n, e, s).bind((d) => zG(d.getNode()) || jG(e, n, s, d, l) ? Y.none() : n && Vr(d.getNode()) || !n && Vr(d.getNode(!0)) ? b6(l, e, n, s, d) : n && Zb(s) || !n && th(s) ? Y.some(Pd.moveToPosition(d)) : Y.none()), UG = (e, n) => Kt(n) ? Y.none() : e && Vr(n.nextSibling) ? Y.some(Pd.moveToElement(n.nextSibling)) : !e && Vr(n.previousSibling) ? Y.some(Pd.moveToElement(n.previousSibling)) : Y.none(), YR = (e, n, s) => s.fold((l) => Y.some(Pd.remove(l)), (l) => Y.some(Pd.moveToElement(l)), (l) => pu(n, l, e) ? Y.none() : Y.some(Pd.moveToPosition(l))), XR = (e, n, s, l) => VG(n, s) ? UG(n, s.getNode(!n)).orThunk(() => v6(e, n, s, l)) : v6(e, n, s, l).bind((d) => YR(e, s, d)), y6 = (e, n, s, l) => {
      const d = Dl(n ? 1 : -1, e, s), p = vt.fromRangeStart(d), v = Me.fromDom(e);
      return !n && Zb(p) ? Y.some(Pd.remove(p.getNode(!0))) : n && th(p) ? Y.some(Pd.remove(p.getNode())) : !n && th(p) && JP(v, p, l) ? uB(v, p, l).map((S) => Pd.remove(S.getNode())) : n && Zb(p) && cB(v, p, l) ? kU(v, p, l).map((S) => Pd.remove(S.getNode())) : XR(e, n, p, l);
    }, WG = (e, n) => (s) => (e._selectionOverrides.hideFakeCaret(), k1(e, n, Me.fromDom(s)), !0), ZG = (e, n) => (s) => {
      const l = n ? vt.before(s) : vt.after(s);
      return e.selection.setRng(l.toRange()), !0;
    }, x6 = (e) => (n) => (e.selection.setRng(n.toRange()), !0), QR = (e, n) => Y.from(_g(e.getBody(), n)), JR = (e, n) => {
      const s = e.selection.getNode();
      return QR(e, s).filter(Vr).fold(() => y6(e.getBody(), n, e.selection.getRng(), e.schema).map((l) => () => l.fold(WG(e, n), ZG(e, n), x6(e))), () => Y.some(qe));
    }, w6 = (e) => {
      Ue(ba(e, ".mce-offscreen-selection"), ys);
    }, C6 = (e, n) => {
      const s = e.selection.getNode();
      return Vr(s) && !tb(s) ? QR(e, s.parentNode).filter(Vr).fold(() => Y.some(() => {
        w6(Me.fromDom(e.getBody())), k1(e, n, Me.fromDom(e.selection.getNode())), la(e);
      }), () => Y.some(qe)) : KR(e) ? Y.some(() => {
        NB(e, e.selection.getRng(), Me.fromDom(e.getBody()));
      }) : Y.none();
    }, sO = (e) => {
      const n = e.dom, s = e.selection, l = _g(e.getBody(), s.getNode());
      if (Rt(l) && n.isBlock(l) && n.isEmpty(l)) {
        const d = n.create("br", { "data-mce-bogus": "1" });
        n.setHTML(l, ""), l.appendChild(d), s.setRng(vt.before(d).toRange());
      }
      return !0;
    }, eN = (e, n) => e.selection.isCollapsed() ? JR(e, n) : C6(e, n), S6 = (e) => e.hasOwnProperty("text"), Km = (e) => e.hasOwnProperty("marker"), vf = (e, n) => {
      const s = (p, v) => {
        if (Zt(p))
          return {
            text: p,
            offset: v
          };
        {
          const S = n(), O = p.childNodes;
          return v < O.length ? (p.insertBefore(S, O[v]), {
            marker: S,
            before: !0
          }) : (p.appendChild(S), {
            marker: S,
            before: !1
          });
        }
      }, l = s(e.endContainer, e.endOffset);
      return {
        start: s(e.startContainer, e.startOffset),
        end: l
      };
    }, xS = (e) => {
      var n, s;
      const { start: l, end: d } = e, p = new window.Range();
      return S6(l) ? p.setStart(l.text, l.offset) : Km(l) && (l.before ? p.setStartBefore(l.marker) : p.setStartAfter(l.marker), (n = l.marker.parentNode) === null || n === void 0 || n.removeChild(l.marker)), S6(d) ? p.setEnd(d.text, d.offset) : Km(d) && (d.before ? p.setEndBefore(d.marker) : p.setEndAfter(d.marker), (s = d.marker.parentNode) === null || s === void 0 || s.removeChild(d.marker)), p;
    }, aO = (e, n) => {
      var s;
      const l = e.dom, d = l.getParent(e.selection.getStart(), l.isBlock), p = l.getParent(e.selection.getEnd(), l.isBlock), v = e.getBody();
      if (((s = d == null ? void 0 : d.nodeName) === null || s === void 0 ? void 0 : s.toLowerCase()) === "div" && d && p && d === v.firstChild && p === v.lastChild && !l.isEmpty(v)) {
        const O = d.cloneNode(!1), M = () => {
          if (n ? RB(e) : ZE(e), v.firstChild !== d) {
            const j = vf(e.selection.getRng(), () => document.createElement("span"));
            Array.from(v.childNodes).forEach((U) => O.appendChild(U)), v.appendChild(O), e.selection.setRng(xS(j));
          }
        };
        return Y.some(M);
      }
      return Y.none();
    }, iO = (e, n) => {
      const s = vt.fromRangeStart(e.selection.getRng());
      return hu(n, e.getBody(), s).filter((l) => n ? yU(l) : xU(l)).bind((l) => Ty(n ? 0 : -1, l)).map((l) => () => e.selection.select(l));
    }, lO = (e, n) => e.selection.isCollapsed() ? iO(e, n) : Y.none(), K1 = Zt, tN = (e) => K1(e) && e.data[0] === Ma, nN = (e) => K1(e) && e.data[e.data.length - 1] === Ma, oN = (e) => {
      var n;
      return ((n = e.ownerDocument) !== null && n !== void 0 ? n : document).createTextNode(Ma);
    }, k6 = (e) => {
      var n;
      if (K1(e.previousSibling))
        return nN(e.previousSibling) || e.previousSibling.appendData(Ma), e.previousSibling;
      if (K1(e))
        return tN(e) || e.insertData(0, Ma), e;
      {
        const s = oN(e);
        return (n = e.parentNode) === null || n === void 0 || n.insertBefore(s, e), s;
      }
    }, cO = (e) => {
      var n, s;
      if (K1(e.nextSibling))
        return tN(e.nextSibling) || e.nextSibling.insertData(0, Ma), e.nextSibling;
      if (K1(e))
        return nN(e) || e.appendData(Ma), e;
      {
        const l = oN(e);
        return e.nextSibling ? (n = e.parentNode) === null || n === void 0 || n.insertBefore(l, e.nextSibling) : (s = e.parentNode) === null || s === void 0 || s.appendChild(l), l;
      }
    }, Ax = (e, n) => e ? k6(n) : cO(n), GG = Le(Ax, !0), qG = Le(Ax, !1), _6 = (e, n) => Zt(e.container()) ? Ax(n, e.container()) : Ax(n, e.getNode()), E6 = (e, n) => {
      const s = n.get();
      return s && e.container() === s && af(s);
    }, uO = (e, n) => n.fold((s) => {
      Up(e.get());
      const l = GG(s);
      return e.set(l), Y.some(vt(l, l.length - 1));
    }, (s) => zl(s).map((l) => {
      if (E6(l, e)) {
        const d = e.get();
        return vt(d, 1);
      } else {
        Up(e.get());
        const d = _6(l, !0);
        return e.set(d), vt(d, 1);
      }
    }), (s) => gu(s).map((l) => {
      if (E6(l, e)) {
        const d = e.get();
        return vt(d, d.length - 1);
      } else {
        Up(e.get());
        const d = _6(l, !1);
        return e.set(d), vt(d, d.length - 1);
      }
    }), (s) => {
      Up(e.get());
      const l = qG(s);
      return e.set(l), Y.some(vt(l, 1));
    }), T6 = (e, n) => {
      for (let s = 0; s < e.length; s++) {
        const l = e[s].apply(null, n);
        if (l.isSome())
          return l;
      }
      return Y.none();
    }, tu = ss.generate([
      { before: ["element"] },
      { start: ["element"] },
      { end: ["element"] },
      { after: ["element"] }
    ]), dO = (e, n) => {
      const s = df(n, e);
      return s || e;
    }, KG = (e, n, s) => {
      const l = Dc(s), d = dO(n, l.container());
      return kg(e, d, l).fold(() => Hl(d, l).bind(Le(kg, e, d)).map((p) => tu.before(p)), Y.none);
    }, YG = (e, n) => pg(e, n) === null, O6 = (e, n, s) => kg(e, n, s).filter(Le(YG, n)), XG = (e, n, s) => {
      const l = PB(s);
      return O6(e, n, l).bind((d) => Xc(d, l).isNone() ? Y.some(tu.start(d)) : Y.none());
    }, QG = (e, n, s) => {
      const l = Dc(s);
      return O6(e, n, l).bind((d) => Hl(d, l).isNone() ? Y.some(tu.end(d)) : Y.none());
    }, JG = (e, n, s) => {
      const l = PB(s), d = dO(n, l.container());
      return kg(e, d, l).fold(() => Xc(d, l).bind(Le(kg, e, d)).map((p) => tu.after(p)), Y.none);
    }, A6 = (e) => !TB(wS(e)), yf = (e, n, s) => T6([
      KG,
      XG,
      QG,
      JG
    ], [
      e,
      n,
      s
    ]).filter(A6), wS = (e) => e.fold(En, En, En, En), P6 = (e) => e.fold(dt("before"), dt("start"), dt("end"), dt("after")), fO = (e) => e.fold(tu.before, tu.before, tu.after, tu.after), rN = (e) => e.fold(tu.start, tu.start, tu.end, tu.end), eq = (e, n) => P6(e) === P6(n) && wS(e) === wS(n), D6 = (e, n, s, l, d, p) => ga(kg(n, s, l), kg(n, s, d), (v, S) => v !== S && OB(s, v, S) ? tu.after(e ? v : S) : p).getOr(p), tq = (e, n) => e.fold(mt, (s) => !eq(s, n)), nq = (e, n, s, l, d) => {
      const p = Od(e, d);
      return hu(e, s, p).map(Le(Od, e)).fold(() => l.map(fO), (O) => yf(n, s, O).map(Le(D6, e, n, s, p, O)).filter(Le(tq, l))).filter(A6);
    }, sN = (e, n) => e ? n.fold(B(Y.some, tu.start), Y.none, B(Y.some, tu.after), Y.none) : n.fold(Y.none, B(Y.some, tu.before), Y.none, B(Y.some, tu.end)), oq = (e, n, s, l) => {
      const d = Od(e, l), p = yf(n, s, d);
      return yf(n, s, d).bind(Le(sN, e)).orThunk(() => nq(e, n, s, p, l));
    }, rq = (e) => ye(e.selection.getSel().modify), R6 = (e, n, s) => {
      const l = e ? 1 : -1;
      return n.setRng(vt(s.container(), s.offset() + l).toRange()), n.getSel().modify("move", e ? "forward" : "backward", "word"), !0;
    }, sq = (e, n) => {
      const s = n.selection.getRng(), l = e ? vt.fromRangeEnd(s) : vt.fromRangeStart(s);
      return rq(n) ? e && r2(l) ? R6(!0, n.selection, l) : !e && eg(l) ? R6(!1, n.selection, l) : !1 : !1;
    };
    var lh;
    (function(e) {
      e[e.Br = 0] = "Br", e[e.Block = 1] = "Block", e[e.Wrap = 2] = "Wrap", e[e.Eol = 3] = "Eol";
    })(lh || (lh = {}));
    const mO = (e, n) => e === Fi.Backwards ? Qo(n) : n, aq = (e, n, s) => e === Fi.Forwards ? n.next(s) : n.prev(s), pO = (e, n, s, l) => Wr(l.getNode(n === Fi.Forwards)) ? lh.Br : pu(s, l) === !1 ? lh.Block : lh.Wrap, CS = (e, n, s, l) => {
      const d = pl(s);
      let p = l;
      const v = [];
      for (; p; ) {
        const S = aq(n, d, p);
        if (!S)
          break;
        if (Wr(S.getNode(!1)))
          return n === Fi.Forwards ? {
            positions: mO(n, v).concat([S]),
            breakType: lh.Br,
            breakAt: Y.some(S)
          } : {
            positions: mO(n, v),
            breakType: lh.Br,
            breakAt: Y.some(S)
          };
        if (!S.isVisible()) {
          p = S;
          continue;
        }
        if (e(p, S)) {
          const O = pO(s, n, p, S);
          return {
            positions: mO(n, v),
            breakType: O,
            breakAt: Y.some(S)
          };
        }
        v.push(S), p = S;
      }
      return {
        positions: mO(n, v),
        breakType: lh.Eol,
        breakAt: Y.none()
      };
    }, N6 = (e, n, s, l) => n(s, l).breakAt.map((d) => {
      const p = n(s, d).positions;
      return e === Fi.Backwards ? p.concat(d) : [d].concat(p);
    }).getOr([]), aN = (e, n) => Ct(e, (s, l) => s.fold(() => Y.some(l), (d) => ga(pn(d.getClientRects()), pn(l.getClientRects()), (p, v) => {
      const S = Math.abs(n - p.left);
      return Math.abs(n - v.left) <= S ? l : d;
    }).or(s)), Y.none()), Y1 = (e, n) => pn(n.getClientRects()).bind((s) => aN(e, s.left)), SS = Le(CS, vt.isAbove, -1), kS = Le(CS, vt.isBelow, 1), M6 = Le(N6, -1, SS), I6 = Le(N6, 1, kS), F6 = (e, n) => SS(e, n).breakAt.isNone(), B6 = (e, n) => kS(e, n).breakAt.isNone(), iq = (e) => zl(e).map((n) => [n].concat(kS(e, n).positions)).getOr([]), lq = (e) => gu(e).map((n) => SS(e, n).positions.concat(n)).getOr([]), cq = (e, n) => Y1(M6(e, n), n), uq = (e, n) => Y1(I6(e, n), n), dq = Vr, fq = (e, n) => Math.abs(e.left - n), xf = (e, n) => Math.abs(e.right - n), iN = (e) => Ss(e, "node"), lN = (e, n) => Re(e, (s, l) => {
      const d = Math.min(fq(s, n), xf(s, n)), p = Math.min(fq(l, n), xf(l, n));
      return p === d && iN(l) && dq(l.node) || p < d ? l : s;
    }), $6 = (e) => {
      const n = (s) => en(s, (l) => {
        const d = Dm(l);
        return d.node = e, d;
      });
      if (On(e))
        return n(e.getClientRects());
      if (Zt(e)) {
        const s = e.ownerDocument.createRange();
        return s.setStart(e, 0), s.setEnd(e, e.data.length), n(s.getClientRects());
      } else
        return [];
    }, L6 = (e) => nr(e, $6);
    var Px;
    (function(e) {
      e[e.Up = -1] = "Up", e[e.Down = 1] = "Down";
    })(Px || (Px = {}));
    const mq = (e, n, s, l) => {
      let d = l;
      for (; d = Db(d, e, i2, n); )
        if (s(d))
          return;
    }, cN = (e, n, s, l, d, p) => {
      let v = 0;
      const S = [], O = (U) => {
        let Z = L6([U]);
        e === -1 && (Z = Z.reverse());
        for (let de = 0; de < Z.length; de++) {
          const we = Z[de];
          if (!s(we, M)) {
            if (S.length > 0 && n(we, ct(S)) && v++, we.line = v, d(we))
              return !0;
            S.push(we);
          }
        }
        return !1;
      }, M = ct(p.getClientRects());
      if (!M)
        return S;
      const j = p.getNode();
      return j && (O(j), mq(e, l, O, j)), S;
    }, pq = (e, n) => n.line > e, hq = (e, n) => n.line === e, gq = Le(cN, Px.Up, Uv, Y0), Dx = Le(cN, Px.Down, Y0, Uv), uN = (e) => ct(e.getClientRects()), H6 = (e, n, s, l) => {
      const d = pl(n);
      let p, v, S, O;
      const M = [];
      let j = 0;
      e === 1 ? (p = d.next, v = Y0, S = Uv, O = vt.after(l)) : (p = d.prev, v = Uv, S = Y0, O = vt.before(l));
      const U = uN(O);
      do {
        if (!O.isVisible())
          continue;
        const Z = uN(O);
        if (S(Z, U))
          continue;
        M.length > 0 && v(Z, ct(M)) && j++;
        const de = Dm(Z);
        if (de.position = O, de.line = j, s(de))
          return M;
        M.push(de);
      } while (O = p(O));
      return M;
    }, dN = (e) => (n) => pq(e, n), _S = (e) => (n) => hq(e, n), Rg = (e, n) => {
      e.selection.setRng(n), OC(e, e.selection.getRng());
    }, fN = (e, n, s) => Y.some(rO(e, n, s)), z6 = (e, n, s, l, d, p) => {
      const v = n === Fi.Forwards, S = pl(e.getBody()), O = Le(G2, v ? S.next : S.prev), M = v ? l : d;
      if (!s.collapsed) {
        const we = xb(s);
        if (p(we))
          return sm(n, e, we, n === Fi.Backwards, !1);
        if (KR(e)) {
          const me = s.cloneRange();
          return me.collapse(n === Fi.Backwards), Y.from(me);
        }
      }
      const j = dg(n, e.getBody(), s);
      if (M(j))
        return Ox(e, j.getNode(!v));
      let U = O(j);
      const Z = sc(s);
      if (U)
        U = Od(v, U);
      else
        return Z ? Y.some(s) : Y.none();
      if (M(U))
        return sm(n, e, U.getNode(!v), v, !1);
      const de = O(U);
      return de && M(de) && Py(U, de) ? sm(n, e, de.getNode(!v), v, !1) : Z ? fN(e, U.toRange(), !1) : Y.none();
    }, bq = (e, n, s, l, d, p) => {
      const v = dg(n, e.getBody(), s), S = ct(v.getClientRects()), O = n === Px.Down, M = e.getBody();
      if (!S)
        return Y.none();
      if (KR(e)) {
        const Se = O ? vt.fromRangeEnd(s) : vt.fromRangeStart(s);
        return (O ? uq : cq)(M, Se).orThunk(() => Y.from(Se)).map((Ye) => Ye.toRange());
      }
      const U = (O ? Dx : gq)(M, dN(1), v), Z = xn(U, _S(1)), de = S.left, we = lN(Z, de);
      if (we && p(we.node)) {
        const Se = Math.abs(de - we.left), ze = Math.abs(de - we.right);
        return sm(n, e, we.node, Se < ze, !1);
      }
      let me;
      if (l(v) ? me = v.getNode() : d(v) ? me = v.getNode(!0) : me = xb(s), me) {
        const Se = H6(n, M, dN(1), me);
        let ze = lN(xn(Se, _S(1)), de);
        if (ze || (ze = ct(xn(Se, _S(0))), ze))
          return fN(e, ze.position.toRange(), !1);
      }
      return Z.length === 0 ? V6(e, O).filter(O ? d : l).map((Se) => rO(e, Se.toRange(), !1)) : Y.none();
    }, V6 = (e, n) => {
      const s = e.selection.getRng(), l = n ? vt.fromRangeEnd(s) : vt.fromRangeStart(s), d = J4(l.container(), e.getBody());
      if (n) {
        const p = kS(d, l);
        return Oo(p.positions);
      } else {
        const p = SS(d, l);
        return pn(p.positions);
      }
    }, vq = (e, n, s) => V6(e, n).filter(s).exists((l) => (e.selection.setRng(l.toRange()), !0)), ed = (e, n) => {
      const s = e.dom.createRng();
      s.setStart(n.container(), n.offset()), s.setEnd(n.container(), n.offset()), e.selection.setRng(s);
    }, j6 = (e, n) => {
      e ? n.setAttribute("data-mce-selected", "inline-boundary") : n.removeAttribute("data-mce-selected");
    }, U6 = (e, n, s) => uO(n, s).map((l) => (ed(e, l), s)), X1 = (e, n, s) => {
      const l = vt.fromRangeStart(e);
      if (e.collapsed)
        return l;
      {
        const d = vt.fromRangeEnd(e);
        return s ? Xc(n, d).getOr(d) : Hl(n, l).getOr(l);
      }
    }, W6 = (e, n, s) => {
      const l = e.getBody(), d = X1(e.selection.getRng(), l, s), p = Le(Gb, e);
      return oq(s, p, l, d).bind((S) => U6(e, n, S));
    }, yq = (e, n, s) => {
      const l = en(ba(Me.fromDom(n.getRoot()), '*[data-mce-selected="inline-boundary"]'), (v) => v.dom), d = xn(l, e), p = xn(s, e);
      Ue(Mr(d, p), Le(j6, !1)), Ue(Mr(p, d), Le(j6, !0));
    }, hO = (e, n) => {
      const s = n.get();
      if (e.selection.isCollapsed() && !e.composing && s) {
        const l = vt.fromRangeStart(e.selection.getRng());
        vt.isTextPosition(l) && !AB(l) && (ed(e, K4(s, l)), n.set(null));
      }
    }, xq = (e, n, s, l) => {
      if (n.selection.isCollapsed()) {
        const d = xn(l, e);
        Ue(d, (p) => {
          const v = vt.fromRangeStart(n.selection.getRng());
          yf(e, n.getBody(), v).bind((S) => U6(n, s, S));
        });
      }
    }, Z6 = (e, n, s) => ag(e) ? W6(e, n, s).isSome() : !1, G6 = (e, n, s) => ag(n) ? sq(e, n) : !1, wq = (e) => {
      const n = Qe(null), s = Le(Gb, e);
      return e.on("NodeChange", (l) => {
        ag(e) && (yq(s, e.dom, l.parents), hO(e, n), xq(s, e, n, l.parents));
      }), n;
    }, q6 = Le(G6, !0), Cq = Le(G6, !1), im = (e, n, s) => {
      if (ag(e)) {
        const l = V6(e, n).getOrThunk(() => {
          const d = e.selection.getRng();
          return n ? vt.fromRangeEnd(d) : vt.fromRangeStart(d);
        });
        return yf(Le(Gb, e), e.getBody(), l).exists((d) => {
          const p = fO(d);
          return uO(s, p).exists((v) => (ed(e, v), !0));
        });
      } else
        return !1;
    }, Sq = (e, n) => {
      const s = document.createRange();
      return s.setStart(e.container(), e.offset()), s.setEnd(n.container(), n.offset()), s;
    }, kq = (e) => ga(zl(e), gu(e), (n, s) => {
      const l = Od(!0, n), d = Od(!1, s);
      return Hl(e, l).forall((p) => p.isEqual(d));
    }).getOr(!0), K6 = (e, n) => (s) => uO(n, s).map((l) => () => ed(e, l)), Y6 = (e, n, s, l) => {
      const d = e.getBody(), p = Le(Gb, e);
      e.undoManager.ignore(() => {
        e.selection.setRng(Sq(s, l)), ZE(e), yf(p, d, vt.fromRangeStart(e.selection.getRng())).map(rN).bind(K6(e, n)).each(on);
      }), e.nodeChanged();
    }, _q = (e, n) => {
      const s = df(n, e);
      return s || e;
    }, mN = (e, n, s, l) => {
      const d = _q(e.getBody(), l.container()), p = Le(Gb, e), v = yf(p, d, l);
      return v.bind((O) => s ? O.fold(dt(Y.some(rN(O))), Y.none, dt(Y.some(fO(O))), Y.none) : O.fold(Y.none, dt(Y.some(fO(O))), Y.none, dt(Y.some(rN(O))))).map(K6(e, n)).getOrThunk(() => {
        const O = Bm(s, d, l), M = O.bind((j) => yf(p, d, j));
        return ga(v, M, () => kg(p, d, l).bind((j) => kq(j) ? Y.some(() => {
          k1(e, s, Me.fromDom(j));
        }) : Y.none())).getOrThunk(() => M.bind(() => O.map((j) => () => {
          s ? Y6(e, n, l, j) : Y6(e, n, j, l);
        })));
      });
    }, ES = (e, n, s) => {
      if (e.selection.isCollapsed() && ag(e)) {
        const l = vt.fromRangeStart(e.selection.getRng());
        return mN(e, n, s, l);
      }
      return Y.none();
    }, pN = (e) => wi(e) > 1, hN = (e, n) => {
      const s = Me.fromDom(e.getBody()), l = Me.fromDom(e.selection.getStart()), d = Sg(l, s);
      return so(d, n).fold(dt(d), (p) => d.slice(0, p));
    }, X6 = (e) => wi(e) === 1, Q6 = (e) => hN(e, (n) => e.schema.isBlock(gr(n)) || pN(n)), Eq = (e) => hN(e, (n) => e.schema.isBlock(gr(n))), Rx = (e, n) => {
      const s = Le(BD, e);
      return nr(n, (l) => s(l) ? [l.dom] : []);
    }, TS = (e) => {
      const n = Eq(e);
      return Rx(e, n);
    }, J6 = (e, n, s, l) => {
      const d = Rx(n, l);
      if (d.length === 0)
        k1(n, e, s);
      else {
        const p = d$(s.dom, d);
        n.selection.setRng(p.toRange());
      }
    }, e8 = (e, n) => {
      const s = xn(Q6(e), X6);
      return Oo(s).bind((l) => {
        const d = vt.fromRangeStart(e.selection.getRng());
        return FC(n, d, l.dom) && !u1(l) ? Y.some(() => J6(n, e, l, s)) : Y.none();
      });
    }, t8 = (e, n) => {
      const s = n.parentElement;
      return Wr(n) && !te(s) && e.dom.isEmpty(s);
    }, n8 = (e) => u1(Me.fromDom(e)), OS = (e, n) => {
      const s = e.selection.getStart(), l = t8(e, s) || n8(s) ? d$(s, n) : FD(e.selection.getRng(), n);
      e.selection.setRng(l.toRange());
    }, gN = (e, n) => {
      const s = Mr(n, TS(e));
      s.length > 0 && OS(e, s);
    }, Nx = (e) => Zt(e.startContainer), Tq = (e) => e.startOffset === 0 && Nx(e), o8 = (e, n) => {
      const s = n.startContainer.parentElement;
      return !te(s) && BD(e, Me.fromDom(s));
    }, Oq = (e) => {
      const n = e.startContainer.parentNode, s = e.endContainer.parentNode;
      return !te(n) && !te(s) && n.isEqualNode(s);
    }, Aq = (e) => {
      const n = e.endContainer;
      return e.endOffset === (Zt(n) ? n.length : n.childNodes.length);
    }, r8 = (e) => Oq(e) && Aq(e), Pq = (e) => !e.endContainer.isEqualNode(e.commonAncestorContainer), s8 = (e) => r8(e) || Pq(e), Iae = (e) => {
      const n = e.selection.getRng();
      return Tq(n) && o8(e, n) && s8(n);
    }, Dq = (e) => {
      if (Iae(e)) {
        const n = TS(e);
        return Y.some(() => {
          ZE(e), gN(e, n);
        });
      } else
        return Y.none();
    }, bN = (e, n) => e.selection.isCollapsed() ? e8(e, n) : Dq(e), Rq = (e, n) => Qg(e, (s) => bu(s.dom), (s) => n.isBlock(gr(s))), Nq = (e) => Rq(Me.fromDom(e.selection.getStart()), e.schema), Mq = (e) => {
      const n = e.selection.getRng();
      return n.collapsed && (Nx(n) || e.dom.isEmpty(n.startContainer)) && !Nq(e);
    }, AS = (e) => (Mq(e) && OS(e, []), !0), vN = (e, n, s) => je(s) ? Y.some(() => {
      e._selectionOverrides.hideFakeCaret(), k1(e, n, Me.fromDom(s));
    }) : Y.none(), Iq = (e, n) => {
      const s = n ? oo : sx, l = n ? Fi.Forwards : Fi.Backwards, d = dg(l, e.getBody(), e.selection.getRng());
      return s(d) ? vN(e, n, d.getNode(!n)) : Y.from(Od(n, d)).filter((p) => s(p) && Py(d, p)).bind((p) => vN(e, n, p.getNode(!n)));
    }, a8 = (e, n) => {
      const s = e.selection.getNode();
      return Yi(s) ? vN(e, n, s) : Y.none();
    }, yN = (e, n) => e.selection.isCollapsed() ? Iq(e, n) : a8(e, n), Q1 = (e) => aa(e, (n) => Rt(n.dom) || Vr(n.dom)).exists((n) => Rt(n.dom)), gO = (e) => Ba(e ?? "").getOr(0), bO = (e, n) => {
      const s = e || t2(n) ? "margin" : "padding", l = fa(n, "direction") === "rtl" ? "-right" : "-left";
      return s + l;
    }, i8 = (e, n, s, l, d, p) => {
      const v = bO(s, Me.fromDom(p)), S = gO(e.getStyle(p, v));
      if (n === "outdent") {
        const O = Math.max(0, S - l);
        e.setStyle(p, v, O ? O + d : "");
      } else {
        const O = S + l + d;
        e.setStyle(p, v, O);
      }
    }, xN = (e, n) => Ko(n, (s) => {
      const l = bO(O2(e), s), d = Sl(s, l).map(gO).getOr(0);
      return e.dom.getContentEditable(s.dom) !== "false" && d > 0;
    }), Ng = (e) => {
      const n = ov(e);
      return !e.mode.isReadOnly() && (n.length > 1 || xN(e, n));
    }, wN = (e) => sf(e) || Oc(e), wf = (e) => Di(e).exists(wN), ov = (e) => xn(Iu(e.selection.getSelectedBlocks()), (n) => !wN(n) && !wf(n) && Q1(n)), vO = (e, n) => {
      var s, l;
      const { dom: d } = e, p = Hj(e), v = (l = (s = /[a-z%]+$/i.exec(p)) === null || s === void 0 ? void 0 : s[0]) !== null && l !== void 0 ? l : "px", S = gO(p), O = O2(e);
      Ue(ov(e), (M) => {
        i8(d, n, O, S, v, M.dom);
      });
    }, Fq = (e) => vO(e, "indent"), CN = (e) => vO(e, "outdent"), l8 = (e) => {
      if (e.selection.isCollapsed() && Ng(e)) {
        const n = e.dom, s = e.selection.getRng(), l = vt.fromRangeStart(s), d = n.getParent(s.startContainer, n.isBlock);
        if (d !== null && QP(Me.fromDom(d), l, e.schema))
          return Y.some(() => CN(e));
      }
      return Y.none();
    }, c8 = (e, n, s) => or([
      l8,
      eN,
      GR,
      (l, d) => ES(l, n, d),
      yS,
      P1,
      lO,
      yN,
      oO,
      bN,
      aO
    ], (l) => l(e, s)).filter((l) => e.selection.isEditable()), Bq = (e, n) => {
      c8(e, n, !1).fold(() => {
        e.selection.isEditable() && (ZE(e), la(e));
      }, on);
    }, $q = (e, n) => {
      c8(e, n, !0).fold(() => {
        e.selection.isEditable() && RB(e);
      }, on);
    }, Lq = (e, n) => {
      e.addCommand("delete", () => {
        Bq(e, n);
      }), e.addCommand("forwardDelete", () => {
        $q(e, n);
      });
    }, SN = 5, Hq = 400, u8 = (e) => e.touches === void 0 || e.touches.length !== 1 ? Y.none() : Y.some(e.touches[0]), Mx = (e, n) => {
      const s = Math.abs(e.clientX - n.x), l = Math.abs(e.clientY - n.y);
      return s > SN || l > SN;
    }, yO = (e) => {
      const n = Mi(), s = Qe(!1), l = Pp((d) => {
        e.dispatch("longpress", {
          ...d,
          type: "longpress"
        }), s.set(!0);
      }, Hq);
      e.on("touchstart", (d) => {
        u8(d).each((p) => {
          l.cancel();
          const v = {
            x: p.clientX,
            y: p.clientY,
            target: d.target
          };
          l.throttle(d), s.set(!1), n.set(v);
        });
      }, !0), e.on("touchmove", (d) => {
        l.cancel(), u8(d).each((p) => {
          n.on((v) => {
            Mx(p, v) && (n.clear(), s.set(!1), e.dispatch("longpresscancel"));
          });
        });
      }, !0), e.on("touchend touchcancel", (d) => {
        l.cancel(), d.type !== "touchcancel" && n.get().filter((p) => p.target.isEqualNode(d.target)).each(() => {
          s.get() ? d.preventDefault() : e.dispatch("tap", {
            ...d,
            type: "tap"
          });
        });
      }, !0);
    }, xO = (e, n) => Xn(e, n.nodeName), d8 = (e, n) => Zt(n) ? !0 : On(n) ? !xO(e.getBlockElements(), n) && !vu(n) && !Lu(e, n) && !Ca(n) : !1, kN = (e, n, s) => $n(sB(Me.fromDom(s), Me.fromDom(n)), (l) => xO(e, l.dom)), zq = (e, n) => {
      if (Zt(n)) {
        if (n.data.length === 0)
          return !0;
        if (/^\s+$/.test(n.data))
          return !n.nextSibling || xO(e, n.nextSibling) || Ca(n.nextSibling);
      }
      return !1;
    }, _N = (e) => e.dom.create(Pl(e), $p(e)), Vq = (e) => {
      const n = e.dom, s = e.selection, l = e.schema, d = l.getBlockElements(), p = s.getStart(), v = e.getBody();
      let S, O, M = null;
      const j = Pl(e);
      if (!p || !On(p))
        return;
      const U = v.nodeName.toLowerCase();
      if (!l.isValidChild(U, j.toLowerCase()) || kN(d, v, p))
        return;
      if (v.firstChild === v.lastChild && Wr(v.firstChild)) {
        S = _N(e), S.appendChild(Xh().dom), v.replaceChild(S, v.firstChild), e.selection.setCursorLocation(S, 0), e.nodeChanged();
        return;
      }
      let Z = v.firstChild;
      for (; Z; )
        if (On(Z) && tc(l, Z), d8(l, Z)) {
          if (zq(d, Z)) {
            O = Z, Z = Z.nextSibling, n.remove(O);
            continue;
          }
          if (!S) {
            if (!M && e.hasFocus() && (M = vf(e.selection.getRng(), () => document.createElement("span"))), !Z.parentNode) {
              Z = null;
              break;
            }
            S = _N(e), v.insertBefore(S, Z);
          }
          O = Z, Z = Z.nextSibling, S.appendChild(O);
        } else
          S = null, Z = Z.nextSibling;
      M && (e.selection.setRng(xS(M)), e.nodeChanged());
    }, f8 = (e, n, s) => {
      const l = Me.fromDom(_N(e)), d = Xh();
      Ys(l, d), s(n, l);
      const p = document.createRange();
      return p.setStartBefore(d.dom), p.setEndBefore(d.dom), p;
    }, jq = (e) => {
      e.on("NodeChange", () => Vq(e));
    }, m8 = (e) => (n) => (" " + n.attr("class") + " ").indexOf(e) !== -1, Uq = (e, n, s) => function(l) {
      const d = arguments, p = d[d.length - 2], v = p > 0 ? n.charAt(p - 1) : "";
      if (v === '"')
        return l;
      if (v === ">") {
        const S = n.lastIndexOf("<", p);
        if (S !== -1 && n.substring(S, p).indexOf('contenteditable="false"') !== -1)
          return l;
      }
      return '<span class="' + s + '" data-mce-content="' + e.dom.encode(d[0]) + '">' + e.dom.encode(typeof d[1] == "string" ? d[1] : d[0]) + "</span>";
    }, p8 = (e, n, s) => {
      let l = n.length, d = s.content;
      if (s.format !== "raw") {
        for (; l--; )
          d = d.replace(n[l], Uq(e, d, gy(e)));
        s.content = d;
      }
    }, Wq = (e, n) => Ko(e, (s) => {
      const l = n.match(s);
      return l !== null && l[0].length === n.length;
    }), Zq = (e) => {
      const n = "contenteditable", s = " " + Gt.trim(V4(e)) + " ", l = " " + Gt.trim(gy(e)) + " ", d = m8(s), p = m8(l), v = _d(e);
      v.length > 0 && e.on("BeforeSetContent", (S) => {
        p8(e, v, S);
      }), e.parser.addAttributeFilter("class", (S) => {
        let O = S.length;
        for (; O--; ) {
          const M = S[O];
          d(M) ? M.attr(n, "true") : p(M) && M.attr(n, "false");
        }
      }), e.serializer.addAttributeFilter(n, (S) => {
        let O = S.length;
        for (; O--; ) {
          const M = S[O];
          if (!d(M) && !p(M))
            continue;
          const j = M.attr("data-mce-content");
          v.length > 0 && j ? Wq(v, j) ? (M.name = "#text", M.type = 3, M.raw = !0, M.value = j) : M.remove() : M.attr(n, null);
        }
      });
    }, Dd = (e) => no(Me.fromDom(e.getBody()), "*[data-mce-caret]").map((n) => n.dom).getOrNull(), h8 = (e, n) => {
      n.hasAttribute("data-mce-caret") && (Rr(n), e.selection.setRng(e.selection.getRng()), e.selection.scrollIntoView(n));
    }, EN = (e, n) => {
      const s = Dd(e);
      if (s) {
        if (n.type === "compositionstart") {
          n.preventDefault(), n.stopPropagation(), h8(e, s);
          return;
        }
        n2(s) && (h8(e, s), e.undoManager.add());
      }
    }, g8 = (e) => {
      e.on("keyup compositionstart", Le(EN, e));
    }, wO = Vr, Gq = (e, n, s) => z6(n, e, s, th, Zb, wO), qq = (e, n, s) => bq(n, e, s, (p) => th(p) || YP(p), (p) => Zb(p) || XP(p), wO), Kq = (e) => {
      const n = e.dom.create(Pl(e));
      return n.innerHTML = '<br data-mce-bogus="1">', n;
    }, b8 = (e, n, s) => {
      const l = pl(e.getBody()), d = Le(G2, n === 1 ? l.next : l.prev);
      if (s.collapsed) {
        const p = e.dom.getParent(s.startContainer, "PRE");
        if (!p)
          return;
        if (!d(vt.fromRangeStart(s))) {
          const S = Me.fromDom(Kq(e));
          n === 1 ? Jl(Me.fromDom(p), S) : Ki(Me.fromDom(p), S), e.selection.select(S.dom, !0), e.selection.collapse();
        }
      }
    }, Yq = (e, n) => {
      const s = n ? Fi.Forwards : Fi.Backwards, l = e.selection.getRng();
      return Gq(s, e, l).orThunk(() => (b8(e, s, l), Y.none()));
    }, v8 = (e, n) => {
      const s = n ? 1 : -1, l = e.selection.getRng();
      return qq(s, e, l).orThunk(() => (b8(e, s, l), Y.none()));
    }, Xq = (e, n) => {
      const s = n ? e.getEnd(!0) : e.getStart(!0);
      return TB(s) ? !n : n;
    }, y8 = (e, n) => Yq(e, Xq(e.selection, n)).exists((s) => (Rg(e, s), !0)), Ix = (e, n) => v8(e, n).exists((s) => (Rg(e, s), !0)), ch = (e, n) => vq(e, n, n ? Zb : th), uh = (e, n) => qR(e, !n).map((s) => {
      const l = s.toRange(), d = e.selection.getRng();
      return n ? l.setStart(d.startContainer, d.startOffset) : l.setEnd(d.endContainer, d.endOffset), l;
    }).exists((s) => (Rg(e, s), !0)), CO = (e) => At(["figcaption"], gr(e)), TN = (e, n, s) => {
      const l = Le(zr, n);
      return aa(Me.fromDom(e.container()), (d) => s.isBlock(gr(d)), l).filter(CO);
    }, ON = (e, n, s) => n ? B6(e.dom, s) : F6(e.dom, s), x8 = (e, n) => {
      const s = Me.fromDom(e.getBody()), l = vt.fromRangeStart(e.selection.getRng());
      return TN(l, s, e.schema).exists(() => {
        if (ON(s, n, l)) {
          const p = f8(e, s, n ? Ys : Cm);
          return e.selection.setRng(p), !0;
        } else
          return !1;
      });
    }, w8 = (e, n) => e.selection.isCollapsed() ? x8(e, n) : !1, C8 = (e, n, s) => {
      const l = e.selection.getRng(), d = vt.fromRangeStart(l);
      return e.getBody().firstChild === n && F6(s, d) ? (e.execCommand("InsertNewBlockBefore"), !0) : !1;
    }, S8 = (e, n) => {
      const s = e.selection.getRng(), l = vt.fromRangeStart(s);
      return e.getBody().lastChild === n && B6(n, l) ? (e.execCommand("InsertNewBlockAfter"), !0) : !1;
    }, Qq = (e, n) => n ? Y.from(e.dom.getParent(e.selection.getNode(), "details")).map((s) => S8(e, s)).getOr(!1) : Y.from(e.dom.getParent(e.selection.getNode(), "summary")).bind((s) => Y.from(e.dom.getParent(s, "details")).map((l) => C8(e, l, s))).getOr(!1), k8 = (e, n) => Qq(e, n), _8 = {
      shiftKey: !1,
      altKey: !1,
      ctrlKey: !1,
      metaKey: !1,
      keyCode: 0
    }, Jq = (e) => en(e, (n) => ({
      ..._8,
      ...n
    })), eK = (e) => en(e, (n) => ({
      ..._8,
      ...n
    })), E8 = (e, n) => n.keyCode === e.keyCode && n.shiftKey === e.shiftKey && n.altKey === e.altKey && n.ctrlKey === e.ctrlKey && n.metaKey === e.metaKey, T8 = (e, n) => nr(Jq(e), (s) => E8(s, n) ? [s] : []), O8 = (e, n) => nr(eK(e), (s) => E8(s, n) ? [s] : []), Io = (e, ...n) => () => e.apply(null, n), SO = (e, n) => Pn(T8(e, n), (s) => s.action()), tK = (e, n) => or(O8(e, n), (s) => s.action()), A8 = (e, n) => {
      const s = n ? Fi.Forwards : Fi.Backwards, l = e.selection.getRng();
      return z6(e, s, l, oo, sx, Yi).exists((d) => (Rg(e, d), !0));
    }, nK = (e, n) => {
      const s = n ? 1 : -1, l = e.selection.getRng();
      return bq(e, s, l, oo, sx, Yi).exists((d) => (Rg(e, d), !0));
    }, oK = (e, n) => vq(e, n, n ? sx : oo), P8 = ss.generate([
      { none: ["current"] },
      { first: ["current"] },
      {
        middle: [
          "current",
          "target"
        ]
      },
      { last: ["current"] }
    ]), kO = {
      ...P8,
      none: (e) => P8.none(e)
    }, rK = (e, n) => nu(e, n, mt), nu = (e, n, s) => nr(Ya(e), (l) => wl(l, n) ? s(l) ? [l] : [] : nu(l, n, s)), D8 = (e, n, s = tt) => {
      if (s(n))
        return Y.none();
      if (At(e, gr(n)))
        return Y.some(n);
      const l = (d) => wl(d, "table") || s(d);
      return Ra(n, e.join(","), l);
    }, PS = (e, n) => D8([
      "td",
      "th"
    ], e, n), sK = (e) => rK(e, "th,td"), AN = (e, n) => cu(e, "table", n), _O = (e, n, s, l, d = mt) => {
      const p = l === 1;
      if (!p && s <= 0)
        return kO.first(e[0]);
      if (p && s >= e.length - 1)
        return kO.last(e[e.length - 1]);
      {
        const v = s + l, S = e[v];
        return d(S) ? kO.middle(n, S) : _O(e, n, v, l, d);
      }
    }, EO = (e, n) => AN(e, n).bind((s) => {
      const l = sK(s);
      return so(l, (p) => zr(e, p)).map((p) => ({
        index: p,
        all: l
      }));
    }), aK = (e, n, s) => EO(e, s).fold(() => kO.none(e), (d) => _O(d.all, e, d.index, 1, n)), iK = (e, n, s) => EO(e, s).fold(() => kO.none(), (d) => _O(d.all, e, d.index, -1, n)), R8 = (e) => i4(e).filter((n) => n.trim().length !== 0 || n.indexOf(Xa) > -1).isSome(), lK = (e) => Te(e) && Ms(e, "contenteditable") === "false", cK = [
      "img",
      "br"
    ], uK = (e) => R8(e) || At(cK, gr(e)) || lK(e), PN = (e) => Fh(e, uK), dK = (e, n) => ({
      left: e.left - n,
      top: e.top - n,
      right: e.right + n * 2,
      bottom: e.bottom + n * 2,
      width: e.width + n,
      height: e.height + n
    }), fK = (e, n) => nr(n, (s) => {
      const l = dK(Dm(s.getBoundingClientRect()), -1);
      return [
        {
          x: l.left,
          y: e(l),
          cell: s
        },
        {
          x: l.right,
          y: e(l),
          cell: s
        }
      ];
    }), Bae = (e, n, s) => Ct(e, (l, d) => l.fold(() => Y.some(d), (p) => {
      const v = Math.sqrt(Math.abs(p.x - n) + Math.abs(p.y - s)), S = Math.sqrt(Math.abs(d.x - n) + Math.abs(d.y - s));
      return Y.some(S < v ? d : p);
    }), Y.none()), N8 = (e, n, s, l, d) => {
      const p = ba(Me.fromDom(s), "td,th,caption").map((S) => S.dom), v = xn(fK(e, p), (S) => n(S, d));
      return Bae(v, l, d).map((S) => S.cell);
    }, M8 = (e) => e.bottom, $ae = (e) => e.top, mK = (e, n) => e.y < n, pK = (e, n) => e.y > n, hK = Le(N8, M8, mK), DN = Le(N8, $ae, pK), TO = (e, n) => pn(n.getClientRects()).bind((s) => hK(e, s.left, s.top)).bind((s) => Y1(lq(s), n)), I8 = (e, n) => Oo(n.getClientRects()).bind((s) => DN(e, s.left, s.top)).bind((s) => Y1(iq(s), n)), F8 = (e, n, s) => s.breakAt.exists((l) => e(n, l).breakAt.isSome()), gK = (e) => e.breakType === lh.Wrap && e.positions.length === 0, bK = (e) => e.breakType === lh.Br && e.positions.length === 1, OO = (e, n, s) => {
      const l = e(n, s);
      return gK(l) || !Wr(s.getNode()) && bK(l) ? !F8(e, n, l) : l.breakAt.isNone();
    }, vK = Le(OO, SS), yK = Le(OO, kS), xK = (e, n, s) => {
      const l = vt.fromRangeStart(n);
      return mg(!e, s).exists((d) => d.isEqual(l));
    }, wK = (e, n, s, l) => {
      const d = e.selection.getRng(), p = n ? 1 : -1;
      return X4() && xK(n, d, s) ? (sm(p, e, s, !n, !1).each((v) => {
        Rg(e, v);
      }), !0) : !1;
    }, lm = (e, n, s) => TO(n, s).orThunk(() => pn(s.getClientRects()).bind((l) => aN(M6(e, vt.before(n)), l.left))).getOr(vt.before(n)), B8 = (e, n, s) => I8(n, s).orThunk(() => pn(s.getClientRects()).bind((l) => aN(I6(e, vt.after(n)), l.left))).getOr(vt.after(n)), RN = (e, n) => {
      const s = n.getNode(e);
      return Fu(s) ? Y.some(s) : Y.none();
    }, Lae = (e, n, s) => {
      n.undoManager.transact(() => {
        const l = e ? Jl : Ki, d = f8(n, Me.fromDom(s), l);
        Rg(n, d);
      });
    }, CK = (e, n, s) => {
      const l = RN(!!n, s), d = n === !1;
      l.fold(() => Rg(e, s.toRange()), (p) => mg(d, e.getBody()).filter((v) => v.isEqual(s)).fold(() => Rg(e, s.toRange()), (v) => Lae(n, e, p)));
    }, Hae = (e, n, s, l) => {
      const d = e.selection.getRng(), p = vt.fromRangeStart(d), v = e.getBody();
      if (!n && vK(l, p)) {
        const S = lm(v, s, p);
        return CK(e, n, S), !0;
      } else if (n && yK(l, p)) {
        const S = B8(v, s, p);
        return CK(e, n, S), !0;
      } else
        return !1;
    }, SK = (e, n, s) => Y.from(e.dom.getParent(e.selection.getNode(), "td,th")).bind((l) => Y.from(e.dom.getParent(l, "table")).map((d) => s(e, n, d, l))).getOr(!1), $8 = (e, n) => SK(e, n, wK), Fx = (e, n) => SK(e, n, Hae), kK = (e) => {
      const n = Ub.exact(e, 0, e, 0);
      return m(n);
    }, AO = (e, n, s) => s.fold(Y.none, Y.none, (l, d) => PN(d).map((p) => kK(p)), (l) => (e.execCommand("mceTableInsertRowAfter"), NN(e, n, l))), NN = (e, n, s) => AO(e, n, aK(s, za)), L8 = (e, n, s) => AO(e, n, iK(s, za)), MN = (e, n) => {
      const s = [
        "table",
        "li",
        "dl"
      ], l = Me.fromDom(e.getBody()), d = (S) => {
        const O = gr(S);
        return zr(S, l) || At(s, O);
      }, p = e.selection.getRng(), v = Me.fromDom(n ? p.endContainer : p.startContainer);
      return PS(v, d).map((S) => (AN(S, d).each((j) => {
        e.model.table.clearSelectedCells(j.dom);
      }), e.selection.collapse(!n), (n ? NN : L8)(e, d, S).each((j) => {
        e.selection.setRng(j);
      }), !0)).getOr(!1);
    }, _K = (e, n, s) => {
      const l = rn.os.isMacOS() || rn.os.isiOS();
      SO([
        {
          keyCode: Xt.RIGHT,
          action: Io(y8, e, !0)
        },
        {
          keyCode: Xt.LEFT,
          action: Io(y8, e, !1)
        },
        {
          keyCode: Xt.UP,
          action: Io(Ix, e, !1)
        },
        {
          keyCode: Xt.DOWN,
          action: Io(Ix, e, !0)
        },
        ...l ? [
          {
            keyCode: Xt.UP,
            action: Io(uh, e, !1),
            metaKey: !0,
            shiftKey: !0
          },
          {
            keyCode: Xt.DOWN,
            action: Io(uh, e, !0),
            metaKey: !0,
            shiftKey: !0
          }
        ] : [],
        {
          keyCode: Xt.RIGHT,
          action: Io($8, e, !0)
        },
        {
          keyCode: Xt.LEFT,
          action: Io($8, e, !1)
        },
        {
          keyCode: Xt.UP,
          action: Io(Fx, e, !1)
        },
        {
          keyCode: Xt.DOWN,
          action: Io(Fx, e, !0)
        },
        {
          keyCode: Xt.UP,
          action: Io(Fx, e, !1)
        },
        {
          keyCode: Xt.UP,
          action: Io(k8, e, !1)
        },
        {
          keyCode: Xt.DOWN,
          action: Io(k8, e, !0)
        },
        {
          keyCode: Xt.RIGHT,
          action: Io(A8, e, !0)
        },
        {
          keyCode: Xt.LEFT,
          action: Io(A8, e, !1)
        },
        {
          keyCode: Xt.UP,
          action: Io(nK, e, !1)
        },
        {
          keyCode: Xt.DOWN,
          action: Io(nK, e, !0)
        },
        {
          keyCode: Xt.RIGHT,
          action: Io(Z6, e, n, !0)
        },
        {
          keyCode: Xt.LEFT,
          action: Io(Z6, e, n, !1)
        },
        {
          keyCode: Xt.RIGHT,
          ctrlKey: !l,
          altKey: l,
          action: Io(q6, e, n)
        },
        {
          keyCode: Xt.LEFT,
          ctrlKey: !l,
          altKey: l,
          action: Io(Cq, e, n)
        },
        {
          keyCode: Xt.UP,
          action: Io(w8, e, !1)
        },
        {
          keyCode: Xt.DOWN,
          action: Io(w8, e, !0)
        }
      ], s).each((d) => {
        s.preventDefault();
      });
    }, EK = (e, n) => {
      e.on("keydown", (s) => {
        s.isDefaultPrevented() || _K(e, n, s);
      });
    }, Ym = (e, n) => ({
      container: e,
      offset: n
    }), PO = Js.DOM, J1 = (e) => (n) => e === n ? -1 : 0, TK = (e) => (n) => e.isBlock(n) || At([
      "BR",
      "IMG",
      "HR",
      "INPUT"
    ], n.nodeName) || e.getContentEditable(n) === "false", IN = (e, n, s) => {
      if (Zt(e) && n >= 0)
        return Y.some(Ym(e, n));
      {
        const l = Rp(PO);
        return Y.from(l.backwards(e, n, J1(e), s)).map((d) => Ym(d.container, d.container.data.length));
      }
    }, OK = (e, n, s) => {
      if (Zt(e) && n >= e.length)
        return Y.some(Ym(e, n));
      {
        const l = Rp(PO);
        return Y.from(l.forwards(e, n, J1(e), s)).map((d) => Ym(d.container, 0));
      }
    }, DS = (e, n, s) => {
      if (!Zt(e))
        return Y.none();
      const l = e.data;
      if (n >= 0 && n <= l.length)
        return Y.some(Ym(e, n));
      {
        const d = Rp(PO);
        return Y.from(d.backwards(e, n, J1(e), s)).bind((p) => {
          const v = p.container.data;
          return DS(p.container, n + v.length, s);
        });
      }
    }, H8 = (e, n, s) => {
      if (!Zt(e))
        return Y.none();
      const l = e.data;
      if (n <= l.length)
        return Y.some(Ym(e, n));
      {
        const d = Rp(PO);
        return Y.from(d.forwards(e, n, J1(e), s)).bind((p) => H8(p.container, n - l.length, s));
      }
    }, FN = (e, n, s, l, d) => {
      const p = Rp(e, TK(e));
      return Y.from(p.backwards(n, s, l, d));
    }, z8 = (e) => e.collapsed && Zt(e.startContainer), AK = (e) => Kc(e.toString().replace(/\u00A0/g, " ")), V8 = (e) => e !== "" && ` \f
\r	\v`.indexOf(e) !== -1, PK = (e, n) => e.substring(n.length), DK = (e, n, s, l = !1) => {
      let d;
      const p = s.charAt(0);
      for (d = n - 1; d >= 0; d--) {
        const v = e.charAt(d);
        if (!l && V8(v))
          return Y.none();
        if (p === v && Qn(e, s, d, n))
          break;
      }
      return Y.some(d);
    }, BN = (e, n, s, l = !1) => {
      if (!z8(n))
        return Y.none();
      const d = {
        text: "",
        offset: 0
      }, p = (S, O, M) => (d.text = M + d.text, d.offset += O, DK(d.text, d.offset, s, l).getOr(O)), v = e.getParent(n.startContainer, e.isBlock) || e.getRoot();
      return FN(e, n.startContainer, n.startOffset, p, v).bind((S) => {
        const O = n.cloneRange();
        if (O.setStart(S.container, S.offset), O.setEnd(n.endContainer, n.endOffset), O.collapsed)
          return Y.none();
        const M = AK(O);
        return M.lastIndexOf(s) !== 0 ? Y.none() : Y.some({
          text: PK(M, s),
          range: O,
          trigger: s
        });
      });
    }, RK = (e) => e.nodeType === Of, $N = (e) => e.nodeType === xi, j8 = (e) => {
      if (RK(e))
        return Ym(e, e.data.length);
      {
        const n = e.childNodes;
        return n.length > 0 ? j8(n[n.length - 1]) : Ym(e, n.length);
      }
    }, LN = (e, n) => {
      const s = e.childNodes;
      return s.length > 0 && n < s.length ? LN(s[n], 0) : s.length > 0 && $N(e) && s.length === n ? j8(s[s.length - 1]) : Ym(e, n);
    }, NK = (e, n) => {
      var s;
      const l = (s = e.getParent(n.container, e.isBlock)) !== null && s !== void 0 ? s : e.getRoot();
      return FN(e, n.container, n.offset, (d, p) => p === 0 ? -1 : p, l).filter((d) => {
        const p = d.container.data.charAt(d.offset - 1);
        return !V8(p);
      }).isSome();
    }, MK = (e) => (n) => {
      const s = LN(n.startContainer, n.startOffset);
      return !NK(e, s);
    }, IK = (e, n, s) => or(s.triggers, (l) => BN(e, n, l)), FK = (e, n) => {
      const s = n(), l = e.selection.getRng();
      return IK(e.dom, l, s).bind((d) => U8(e, n, d));
    }, U8 = (e, n, s, l = {}) => {
      var d;
      const p = n(), S = (d = e.selection.getRng().startContainer.nodeValue) !== null && d !== void 0 ? d : "", O = xn(p.lookupByTrigger(s.trigger), (j) => s.text.length >= j.minChars && j.matches.getOrThunk(() => MK(e.dom))(s.range, S, s.text));
      if (O.length === 0)
        return Y.none();
      const M = Promise.all(en(O, (j) => j.fetch(s.text, j.maxResults, l).then((Z) => ({
        matchText: s.text,
        items: Z,
        columns: j.columns,
        onAction: j.onAction,
        highlightOn: j.highlightOn
      }))));
      return Y.some({
        lookupData: M,
        context: s
      });
    };
    var Xm;
    (function(e) {
      e[e.Error = 0] = "Error", e[e.Value = 1] = "Value";
    })(Xm || (Xm = {}));
    const mi = (e, n, s) => e.stype === Xm.Error ? n(e.serror) : s(e.svalue), BK = (e) => {
      const n = [], s = [];
      return Ue(e, (l) => {
        mi(l, (d) => s.push(d), (d) => n.push(d));
      }), {
        values: n,
        errors: s
      };
    }, $K = (e, n) => e.stype === Xm.Error ? {
      stype: Xm.Error,
      serror: n(e.serror)
    } : e, LK = (e, n) => e.stype === Xm.Value ? {
      stype: Xm.Value,
      svalue: n(e.svalue)
    } : e, W8 = (e, n) => e.stype === Xm.Value ? n(e.svalue) : e, HN = (e, n) => e.stype === Xm.Error ? n(e.serror) : e, zN = (e) => ({
      stype: Xm.Value,
      svalue: e
    }), Mg = (e) => ({
      stype: Xm.Error,
      serror: e
    }), bl = {
      fromResult: (e) => e.fold(Mg, zN),
      toResult: (e) => mi(e, ac.error, ac.value),
      svalue: zN,
      partition: BK,
      serror: Mg,
      bind: W8,
      bindError: HN,
      map: LK,
      mapError: $K,
      fold: mi
    }, RS = (e) => ve(e) && Zo(e).length > 100 ? " removed due to size" : JSON.stringify(e, null, 2), VN = (e) => {
      const n = e.length > 10 ? e.slice(0, 10).concat([{
        path: [],
        getErrorInfo: dt("... (only showing first ten failures)")
      }]) : e;
      return en(n, (s) => "Failed path: (" + s.path.join(" > ") + `)
` + s.getErrorInfo());
    }, NS = (e, n) => bl.serror([{
      path: e,
      getErrorInfo: n
    }]), DO = (e, n, s) => NS(e, () => 'Could not find valid *required* value for "' + n + '" in ' + RS(s)), RO = (e, n) => NS(e, () => 'Choice schema did not contain choice key: "' + n + '"'), MS = (e, n, s) => NS(e, () => 'The chosen schema: "' + s + '" did not exist in branches: ' + RS(n)), IS = (e, n) => NS(e, dt(n)), cm = (e, n, s, l) => Or(s, l).fold(() => MS(e, s, l), (p) => p.extract(e.concat(["branch: " + l]), n)), FS = (e, n) => ({
      extract: (d, p) => Or(p, e).fold(() => RO(d, e), (S) => cm(d, p, n, S)),
      toString: () => "chooseOn(" + e + "). Possible values: " + Zo(n)
    }), G8 = (e, n) => n, q8 = (e, n) => nt(e) && nt(n) ? BS(e, n) : n, K8 = (e) => (...n) => {
      if (n.length === 0)
        throw new Error("Can't merge zero objects");
      const s = {};
      for (let l = 0; l < n.length; l++) {
        const d = n[l];
        for (const p in d)
          Xn(d, p) && (s[p] = e(s[p], d[p]));
      }
      return s;
    }, BS = K8(q8), Y8 = K8(G8), X8 = () => ({
      tag: "required",
      process: {}
    }), $S = (e) => ({
      tag: "defaultedThunk",
      process: e
    }), Q8 = (e) => $S(dt(e)), zK = () => ({
      tag: "option",
      process: {}
    }), VK = (e, n) => e.length > 0 ? bl.svalue(BS(n, Y8.apply(void 0, e))) : bl.svalue(n), J8 = (e) => B(bl.serror, pr)(e), jK = {
      consolidateObj: (e, n) => {
        const s = bl.partition(e);
        return s.errors.length > 0 ? J8(s.errors) : VK(s.values, n);
      },
      consolidateArr: (e) => {
        const n = bl.partition(e);
        return n.errors.length > 0 ? J8(n.errors) : bl.svalue(n.values);
      }
    }, UK = (e, n, s, l) => ({
      tag: "field",
      key: e,
      newKey: n,
      presence: s,
      prop: l
    }), WK = (e, n) => ({
      tag: "custom",
      newKey: e,
      instantiator: n
    }), e7 = (e, n, s) => {
      switch (e.tag) {
        case "field":
          return n(e.key, e.newKey, e.presence, e.prop);
        case "custom":
          return s(e.newKey, e.instantiator);
      }
    }, jN = (e) => {
      const n = (l, d) => bl.bindError(e(d), (p) => IS(l, p)), s = dt("val");
      return {
        extract: n,
        toString: s
      };
    }, ZK = jN(bl.svalue), GK = (e, n, s, l) => Or(n, s).fold(() => DO(e, s, n), l), t7 = (e, n, s, l) => {
      const d = Or(e, n).getOrThunk(() => s(e));
      return l(d);
    }, n7 = (e, n, s) => s(Or(e, n)), o7 = (e, n, s, l) => {
      const d = Or(e, n).map((p) => p === !0 ? s(e) : p);
      return l(d);
    }, r7 = (e, n, s, l, d) => {
      const p = (S) => d.extract(n.concat([l]), S), v = (S) => S.fold(() => bl.svalue(Y.none()), (O) => {
        const M = d.extract(n.concat([l]), O);
        return bl.map(M, Y.some);
      });
      switch (e.tag) {
        case "required":
          return GK(n, s, l, p);
        case "defaultedThunk":
          return t7(s, l, e.process, p);
        case "option":
          return n7(s, l, v);
        case "defaultedOptionThunk":
          return o7(s, l, e.process, v);
        case "mergeWithThunk":
          return t7(s, l, dt({}), (S) => {
            const O = BS(e.process(s), S);
            return p(O);
          });
      }
    }, qK = (e, n, s) => {
      const l = {}, d = [];
      for (const p of s)
        e7(p, (v, S, O, M) => {
          const j = r7(O, e, n, v, M);
          bl.fold(j, (U) => {
            d.push(...U);
          }, (U) => {
            l[S] = U;
          });
        }, (v, S) => {
          l[v] = S(n);
        });
      return d.length > 0 ? bl.serror(d) : bl.svalue(l);
    }, UN = (e) => ({
      extract: (l, d) => qK(l, d, e),
      toString: () => `obj{
` + en(e, (d) => e7(d, (p, v, S, O) => p + " -> " + O.toString(), (p, v) => "state(" + p + ")")).join(`
`) + "}"
    }), s7 = (e) => ({
      extract: (l, d) => {
        const p = en(d, (v, S) => e.extract(l.concat(["[" + S + "]"]), v));
        return jK.consolidateArr(p);
      },
      toString: () => "array(" + e.toString() + ")"
    }), KK = (e) => jN((n) => e(n).fold(bl.serror, bl.svalue)), a7 = (e, n, s) => {
      const l = n.extract([e], s);
      return bl.mapError(l, (d) => ({
        input: s,
        errors: d
      }));
    }, YK = (e, n, s) => bl.toResult(a7(e, n, s)), i7 = (e) => `Errors: 
` + VN(e.errors).join(`
`) + `

Input object: ` + RS(e.input), l7 = (e, n) => FS(e, Ho(n, UN)), c7 = dt(ZK), LS = (e, n) => jN((s) => {
      const l = typeof s;
      return e(s) ? bl.svalue(s) : bl.serror(`Expected type: ${n} but got: ${l}`);
    }), XK = LS(dn, "number"), NO = LS(G, "string"), QK = LS(lt, "boolean"), WN = LS(ye, "function"), Bx = UK, u7 = WK, JK = (e) => KK((n) => At(e, n) ? ac.value(n) : ac.error(`Unsupported value: "${n}", choose one of "${e.join(", ")}".`)), ZN = (e, n) => Bx(e, e, X8(), n), d7 = (e) => ZN(e, NO), f7 = (e) => ZN(e, WN), m7 = (e, n) => Bx(e, e, X8(), s7(n)), GN = (e, n) => Bx(e, e, zK(), n), MO = (e) => GN(e, NO), eY = (e) => GN(e, WN), p7 = (e, n) => Bx(e, e, Q8(n), c7()), e0 = (e, n, s) => Bx(e, e, Q8(n), s), h7 = (e, n) => e0(e, n, XK), tY = (e, n) => e0(e, n, NO), g7 = (e, n, s) => e0(e, n, JK(s)), qN = (e, n) => e0(e, n, QK), KN = (e, n) => e0(e, n, WN), nY = (e, n, s) => e0(e, n, s7(s)), oY = d7("type"), rY = f7("fetch"), b7 = f7("onAction"), sY = KN("onSetup", () => qe), IO = MO("text"), v7 = MO("icon"), y7 = MO("tooltip"), aY = MO("label"), x7 = qN("active", !1), w7 = qN("enabled", !0), C7 = qN("primary", !1), iY = (e) => p7("columns", e), HS = (e) => tY("type", e), S7 = UN([
      oY,
      d7("trigger"),
      h7("minChars", 1),
      iY(1),
      h7("maxResults", 10),
      eY("matches"),
      rY,
      b7,
      nY("highlightOn", [], NO)
    ]), lY = (e) => YK("Autocompleter", S7, e), zS = [
      w7,
      y7,
      v7,
      IO,
      sY
    ], k7 = [x7].concat(zS), cY = [
      KN("predicate", tt),
      g7("scope", "node", [
        "node",
        "editor"
      ]),
      g7("position", "selection", [
        "node",
        "selection",
        "line"
      ])
    ], uY = zS.concat([
      HS("contextformbutton"),
      C7,
      b7,
      u7("original", En)
    ]), _7 = k7.concat([
      HS("contextformbutton"),
      C7,
      b7,
      u7("original", En)
    ]), dY = zS.concat([HS("contextformbutton")]), fY = k7.concat([HS("contextformtogglebutton")]), mY = l7("type", {
      contextformbutton: uY,
      contextformtogglebutton: _7
    });
    UN([
      HS("contextform"),
      KN("initValue", dt("")),
      aY,
      m7("commands", mY),
      GN("launch", l7("type", {
        contextformbutton: dY,
        contextformtogglebutton: fY
      }))
    ].concat(cY));
    const pY = (e) => {
      const n = e.ui.registry.getAll().popups, s = Ho(n, (v) => lY(v).fold((S) => {
        throw new Error(i7(S));
      }, En)), l = bt(xa(s, (v) => v.trigger)), d = ca(s);
      return {
        dataset: s,
        triggers: l,
        lookupByTrigger: (v) => xn(d, (S) => S.trigger === v)
      };
    }, hY = (e, n) => {
      const s = Pp(n.load, 50);
      e.on("input", (l) => {
        l.inputType === "insertCompositionText" && !e.composing || s.throttle();
      }), e.on("keydown", (l) => {
        const d = l.which;
        d === 8 ? s.throttle() : d === 27 ? (s.cancel(), n.cancelIfNecessary()) : (d === 38 || d === 40) && s.cancel();
      }, !0), e.on("remove", s.cancel);
    }, ol = (e) => {
      const n = Mi(), s = Qe(!1), l = n.isSet, d = () => {
        l() && (EE(e), s.set(!1), n.clear());
      }, p = (U) => {
        l() || n.set({
          trigger: U.trigger,
          matchLength: U.text.length
        });
      }, v = _t(() => pY(e)), S = (U) => n.get().map((Z) => BN(e.dom, e.selection.getRng(), Z.trigger, !0).bind((de) => U8(e, v, de, U))).getOrThunk(() => FK(e, v)), O = (U) => {
        S(U).fold(d, (Z) => {
          p(Z.context), Z.lookupData.then((de) => {
            n.get().map((we) => {
              const me = Z.context;
              we.trigger === me.trigger && (n.set({
                ...we,
                matchLength: me.text.length
              }), s.get() ? (_E(e, { range: me.range }), vC(e, { lookupData: de })) : (s.set(!0), _E(e, { range: me.range }), kE(e, { lookupData: de })));
            });
          });
        });
      }, M = (U, Z) => {
        const de = U.compareBoundaryPoints(window.Range.START_TO_START, Z), we = U.compareBoundaryPoints(window.Range.END_TO_END, Z);
        return de >= 0 && we <= 0;
      }, j = () => n.get().bind(({ trigger: U }) => {
        const Z = e.selection.getRng();
        return BN(e.dom, Z, U, s.get()).filter(({ range: de }) => M(Z, de)).map(({ range: de }) => de);
      });
      e.addCommand("mceAutocompleterReload", (U, Z) => {
        const de = ve(Z) ? Z.fetchOptions : {};
        O(de);
      }), e.addCommand("mceAutocompleterClose", d), e.addCommand("mceAutocompleterRefreshActiveRange", () => {
        j().each((U) => {
          _E(e, { range: U });
        });
      }), e.editorCommands.addQueryStateHandler("mceAutoCompleterInRange", () => j().isSome()), hY(e, {
        cancelIfNecessary: d,
        load: O
      });
    }, gY = Yt().browser.isSafari(), bY = (e) => qc(Me.fromDom(e)), E7 = (e, n) => {
      var s;
      return e.startOffset === 0 && e.endOffset === ((s = n.textContent) === null || s === void 0 ? void 0 : s.length);
    }, FO = (e, n) => Y.from(e.getParent(n.container(), "details")), T7 = (e, n) => FO(e, n).isSome(), vY = (e, n) => {
      const s = Y.from(e.getParent(n.startContainer, "details")), l = Y.from(e.getParent(n.endContainer, "details"));
      if (s.isSome() || l.isSome()) {
        const d = s.bind((p) => Y.from(e.select("summary", p)[0]));
        return Y.some({
          startSummary: d,
          startDetails: s,
          endDetails: l
        });
      } else
        return Y.none();
    }, O7 = (e, n) => zl(n).exists((s) => s.isEqual(e)), $x = (e, n) => gu(n).exists((s) => Wr(s.getNode()) && Xc(n, s).exists((l) => l.isEqual(e)) || s.isEqual(e)), jae = (e, n) => n.startSummary.exists((s) => O7(e, s)), yY = (e, n) => n.startSummary.exists((s) => $x(e, s)), xY = (e, n) => n.startDetails.exists((s) => Xc(s, e).forall((l) => n.startSummary.exists((d) => !d.contains(e.container()) && d.contains(l.container())))), Qm = (e, n, s) => s.startDetails.exists((l) => Hl(e, n).forall((d) => !l.contains(d.container()))), A7 = (e, n) => {
      const s = n.getNode();
      ot(s) || e.selection.setCursorLocation(s, n.offset());
    }, P7 = (e, n, s) => {
      const l = e.dom.getParent(n.container(), "details");
      if (l && !l.open) {
        const d = e.dom.select("summary", l)[0];
        d && (s ? zl(d) : gu(d)).each((v) => A7(e, v));
      } else
        A7(e, n);
    }, D7 = (e, n) => {
      const s = (O) => O.contains(e.startContainer), l = (O) => O.contains(e.endContainer), d = n.startSummary.exists(s), p = n.startSummary.exists(l), v = n.startDetails.forall((O) => n.endDetails.forall((M) => O !== M));
      return (d || p) && !(d && p) || v;
    }, R7 = (e, n, s) => {
      const { dom: l, selection: d } = e, p = e.getBody();
      if (s === "character") {
        const v = vt.fromRangeStart(d.getRng()), S = l.getParent(v.container(), l.isBlock), O = FO(l, v), M = S && l.isEmpty(S), j = te(S == null ? void 0 : S.previousSibling), U = te(S == null ? void 0 : S.nextSibling);
        return M && (n ? U : j) && Bm(!n, p, v).exists((we) => T7(l, we) && !vi(O, FO(l, we))) ? !0 : Bm(n, p, v).fold(tt, (Z) => {
          const de = FO(l, Z);
          if (T7(l, Z) && !vi(O, de)) {
            if (n || P7(e, Z, !1), S && M) {
              if (n && j)
                return !0;
              if (!n && U)
                return !0;
              P7(e, Z, n), e.dom.remove(S);
            }
            return !0;
          } else
            return !1;
        });
      } else
        return !1;
    }, YN = (e, n, s, l) => {
      const p = e.selection.getRng(), v = vt.fromRangeStart(p), S = e.getBody();
      return l === "selection" ? D7(p, n) : s ? yY(v, n) || Qm(S, v, n) : jae(v, n) || xY(v, n);
    }, dh = (e, n, s) => vY(e.dom, e.selection.getRng()).fold(() => R7(e, n, s), (l) => YN(e, l, n, s) || R7(e, n, s)), N7 = (e, n, s) => {
      const l = e.selection, d = l.getNode(), p = l.getRng(), v = vt.fromRangeStart(p);
      return Mw(d) ? (s === "selection" && E7(p, d) || FC(n, v, d) ? bY(d) : e.undoManager.transact(() => {
        const S = l.getSel();
        let { anchorNode: O, anchorOffset: M, focusNode: j, focusOffset: U } = S ?? {};
        const Z = () => {
          je(O) && je(M) && je(j) && je(U) && (S == null || S.setBaseAndExtent(O, M, j, U));
        }, de = () => {
          O = S == null ? void 0 : S.anchorNode, M = S == null ? void 0 : S.anchorOffset, j = S == null ? void 0 : S.focusNode, U = S == null ? void 0 : S.focusOffset;
        }, we = (Se, ze) => {
          Ue(Se.childNodes, (Ye) => {
            Hb(Ye) && ze.appendChild(Ye);
          });
        }, me = e.dom.create("span", { "data-mce-bogus": "1" });
        we(d, me), d.appendChild(me), Z(), (s === "word" || s === "line") && (S == null || S.modify("extend", n ? "right" : "left", s)), !l.isCollapsed() && E7(l.getRng(), me) ? bY(d) : (e.execCommand(n ? "ForwardDelete" : "Delete"), de(), we(me, d), Z()), e.dom.remove(me);
      }), !0) : !1;
    }, rv = (e, n, s) => dh(e, n, s) || gY && N7(e, n, s) ? Y.some(qe) : Y.none(), M7 = (e) => (n, s, l = {}) => {
      const d = n.getBody(), p = {
        bubbles: !0,
        composed: !0,
        data: null,
        isComposing: !1,
        detail: 0,
        view: null,
        target: d,
        currentTarget: d,
        eventPhase: Event.AT_TARGET,
        originalTarget: d,
        explicitOriginalTarget: d,
        isTrusted: !1,
        srcElement: d,
        cancelable: !1,
        preventDefault: qe,
        inputType: s
      }, v = Sd(new InputEvent(e));
      return n.dispatch(e, {
        ...v,
        ...p,
        ...l
      });
    }, sv = M7("input"), Lx = M7("beforeinput"), XN = Yt(), QN = XN.os, I7 = QN.isMacOS() || QN.isiOS(), wY = XN.browser.isFirefox(), CY = (e, n, s) => {
      const l = s.keyCode === Xt.BACKSPACE ? "deleteContentBackward" : "deleteContentForward", d = e.selection.isCollapsed(), p = d ? "character" : "selection", v = (S) => d ? S ? "word" : "line" : "selection";
      tK([
        {
          keyCode: Xt.BACKSPACE,
          action: Io(l8, e)
        },
        {
          keyCode: Xt.BACKSPACE,
          action: Io(eN, e, !1)
        },
        {
          keyCode: Xt.DELETE,
          action: Io(eN, e, !0)
        },
        {
          keyCode: Xt.BACKSPACE,
          action: Io(GR, e, !1)
        },
        {
          keyCode: Xt.DELETE,
          action: Io(GR, e, !0)
        },
        {
          keyCode: Xt.BACKSPACE,
          action: Io(ES, e, n, !1)
        },
        {
          keyCode: Xt.DELETE,
          action: Io(ES, e, n, !0)
        },
        {
          keyCode: Xt.BACKSPACE,
          action: Io(P1, e, !1)
        },
        {
          keyCode: Xt.DELETE,
          action: Io(P1, e, !0)
        },
        {
          keyCode: Xt.BACKSPACE,
          action: Io(rv, e, !1, p)
        },
        {
          keyCode: Xt.DELETE,
          action: Io(rv, e, !0, p)
        },
        ...I7 ? [
          {
            keyCode: Xt.BACKSPACE,
            altKey: !0,
            action: Io(rv, e, !1, v(!0))
          },
          {
            keyCode: Xt.DELETE,
            altKey: !0,
            action: Io(rv, e, !0, v(!0))
          },
          {
            keyCode: Xt.BACKSPACE,
            metaKey: !0,
            action: Io(rv, e, !1, v(!1))
          }
        ] : [
          {
            keyCode: Xt.BACKSPACE,
            ctrlKey: !0,
            action: Io(rv, e, !1, v(!0))
          },
          {
            keyCode: Xt.DELETE,
            ctrlKey: !0,
            action: Io(rv, e, !0, v(!0))
          }
        ],
        {
          keyCode: Xt.BACKSPACE,
          action: Io(lO, e, !1)
        },
        {
          keyCode: Xt.DELETE,
          action: Io(lO, e, !0)
        },
        {
          keyCode: Xt.BACKSPACE,
          action: Io(yN, e, !1)
        },
        {
          keyCode: Xt.DELETE,
          action: Io(yN, e, !0)
        },
        {
          keyCode: Xt.BACKSPACE,
          action: Io(oO, e, !1)
        },
        {
          keyCode: Xt.DELETE,
          action: Io(oO, e, !0)
        },
        {
          keyCode: Xt.BACKSPACE,
          action: Io(yS, e, !1)
        },
        {
          keyCode: Xt.DELETE,
          action: Io(yS, e, !0)
        },
        {
          keyCode: Xt.BACKSPACE,
          action: Io(bN, e, !1)
        },
        {
          keyCode: Xt.DELETE,
          action: Io(bN, e, !0)
        },
        {
          keyCode: Xt.BACKSPACE,
          action: Io(aO, e, !1)
        },
        {
          keyCode: Xt.DELETE,
          action: Io(aO, e, !0)
        }
      ], s).filter((S) => e.selection.isEditable()).each((S) => {
        s.preventDefault(), Lx(e, l).isDefaultPrevented() || (S(), sv(e, l));
      });
    }, SY = (e, n, s) => SO([
      {
        keyCode: Xt.BACKSPACE,
        action: Io(sO, e)
      },
      {
        keyCode: Xt.DELETE,
        action: Io(sO, e)
      },
      ...I7 ? [
        {
          keyCode: Xt.BACKSPACE,
          altKey: !0,
          action: Io(AS, e)
        },
        {
          keyCode: Xt.DELETE,
          altKey: !0,
          action: Io(AS, e)
        },
        ...s ? [{
          keyCode: wY ? 224 : 91,
          action: Io(AS, e)
        }] : []
      ] : [
        {
          keyCode: Xt.BACKSPACE,
          ctrlKey: !0,
          action: Io(AS, e)
        },
        {
          keyCode: Xt.DELETE,
          ctrlKey: !0,
          action: Io(AS, e)
        }
      ]
    ], n), F7 = (e, n) => {
      let s = !1;
      e.on("keydown", (l) => {
        s = l.keyCode === Xt.BACKSPACE, l.isDefaultPrevented() || CY(e, n, l);
      }), e.on("keyup", (l) => {
        l.isDefaultPrevented() || SY(e, l, s), s = !1;
      });
    }, kY = (e) => {
      for (; e; ) {
        if (On(e) || Zt(e) && e.data && /[\r\n\s]/.test(e.data))
          return e;
        e = e.nextSibling;
      }
      return null;
    }, Hx = (e, n) => {
      const s = e.dom, l = e.schema.getMoveCaretBeforeOnEnterElements();
      if (!n)
        return;
      if (/^(LI|DT|DD)$/.test(n.nodeName)) {
        const p = kY(n.firstChild);
        p && /^(UL|OL|DL)$/.test(p.nodeName) && n.insertBefore(s.doc.createTextNode(Xa), n.firstChild);
      }
      const d = s.createRng();
      if (n.normalize(), n.hasChildNodes()) {
        const p = new Ri(n, n);
        let v = n, S;
        for (; S = p.current(); ) {
          if (Zt(S)) {
            d.setStart(S, 0), d.setEnd(S, 0);
            break;
          }
          if (l[S.nodeName.toLowerCase()]) {
            d.setStartBefore(S), d.setEndBefore(S);
            break;
          }
          v = S, S = p.next();
        }
        S || (d.setStart(v, 0), d.setEnd(v, 0));
      } else
        Wr(n) ? n.nextSibling && s.isBlock(n.nextSibling) ? (d.setStartBefore(n), d.setEndBefore(n)) : (d.setStartAfter(n), d.setEndAfter(n)) : (d.setStart(n, 0), d.setEnd(n, 0));
      e.selection.setRng(d), OC(e, d);
    }, VS = (e, n) => {
      const s = e.getRoot();
      let l, d = n;
      for (; d !== s && d && e.getContentEditable(d) !== "false"; ) {
        if (e.getContentEditable(d) === "true") {
          l = d;
          break;
        }
        d = d.parentNode;
      }
      return d !== s ? l : s;
    }, JN = (e) => Y.from(e.dom.getParent(e.selection.getStart(!0), e.dom.isBlock)), _Y = (e) => JN(e).fold(dt(""), (n) => n.nodeName.toUpperCase()), B7 = (e) => JN(e).filter((n) => Oc(Me.fromDom(n))).isSome(), BO = (e) => {
      e.innerHTML = '<br data-mce-bogus="1">';
    }, EY = (e, n, s) => {
      const l = e.dom;
      Y.from(s.style).map(l.parseStyle).each((O) => {
        const j = {
          ...fl(Me.fromDom(n)),
          ...O
        };
        l.setStyles(n, j);
      });
      const d = Y.from(s.class).map((O) => O.split(/\s+/)), p = Y.from(n.className).map((O) => xn(O.split(/\s+/), (M) => M !== ""));
      ga(d, p, (O, M) => {
        const j = xn(M, (Z) => !At(O, Z)), U = [
          ...O,
          ...j
        ];
        l.setAttrib(n, "class", U.join(" "));
      });
      const v = [
        "style",
        "class"
      ], S = kr(s, (O, M) => !At(v, M));
      l.setAttribs(n, S);
    }, jS = (e, n) => {
      if (Pl(e).toLowerCase() === n.tagName.toLowerCase()) {
        const l = $p(e);
        EY(e, n, l);
      }
    }, TY = (e, n, s, l, d = !0, p, v) => {
      const S = e.dom, O = e.schema, M = Pl(e), j = s ? s.nodeName.toUpperCase() : "";
      let U = n;
      const Z = O.getTextInlineElements();
      let de;
      p || j === "TABLE" || j === "HR" ? de = S.create(p || M, v || {}) : de = s.cloneNode(!1);
      let we = de;
      if (!d)
        S.setAttrib(de, "style", null), S.setAttrib(de, "class", null);
      else
        do
          if (Z[U.nodeName]) {
            if (bu(U) || vu(U))
              continue;
            const me = U.cloneNode(!1);
            S.setAttrib(me, "id", ""), de.hasChildNodes() ? (me.appendChild(de.firstChild), de.appendChild(me)) : (we = me, de.appendChild(me));
          }
        while ((U = U.parentNode) && U !== l);
      return jS(e, de), BO(we), de;
    }, eM = (e, n) => e.dom.getParent(n, _c), OY = (e, n, s) => {
      let l = n;
      for (; l && l !== e && te(l.nextSibling); ) {
        const d = l.parentElement;
        if (!d || !s(d))
          return _c(d);
        l = d;
      }
      return !1;
    }, AY = (e, n, s) => !n && s.nodeName.toLowerCase() === Pl(e) && e.dom.isEmpty(s) && OY(e.getBody(), s, (l) => Xn(e.schema.getTextBlockElements(), l.nodeName.toLowerCase())), PY = (e, n, s) => {
      var l, d, p;
      const v = n(Pl(e)), S = eM(e, s);
      S && (e.dom.insertAfter(v, S), Hx(e, v), ((p = (d = (l = s.parentElement) === null || l === void 0 ? void 0 : l.childNodes) === null || d === void 0 ? void 0 : d.length) !== null && p !== void 0 ? p : 0) > 1 && e.dom.remove(s));
    }, $7 = (e, n) => e.firstChild && e.firstChild.nodeName === n, DY = (e) => {
      var n;
      return ((n = e.parentNode) === null || n === void 0 ? void 0 : n.firstChild) === e;
    }, tM = (e, n) => {
      const s = e == null ? void 0 : e.parentNode;
      return je(s) && s.nodeName === n;
    }, L7 = (e) => je(e) && /^(OL|UL|LI)$/.test(e.nodeName), nM = (e) => je(e) && /^(LI|DT|DD)$/.test(e.nodeName), Wae = (e) => L7(e) && L7(e.parentNode), vl = (e) => {
      const n = e.parentNode;
      return nM(n) ? n : e;
    }, $O = (e, n, s) => {
      let l = e[s ? "firstChild" : "lastChild"];
      for (; l && !On(l); )
        l = l[s ? "nextSibling" : "previousSibling"];
      return l === n;
    }, H7 = (e) => Ct(xa(fl(Me.fromDom(e)), (n, s) => `${s}: ${n};`), (n, s) => n + s, ""), RY = (e, n, s, l, d) => {
      const p = e.dom, v = e.selection.getRng(), S = s.parentNode;
      if (s === e.getBody() || !S)
        return;
      Wae(s) && (d = "LI");
      const O = nM(l) ? H7(l) : void 0;
      let M = nM(l) && O ? n(d, { style: H7(l) }) : n(d);
      if ($O(s, l, !0) && $O(s, l, !1))
        if (tM(s, "LI")) {
          const j = vl(s);
          p.insertAfter(M, j), DY(s) ? p.remove(j) : p.remove(s);
        } else
          p.replace(M, s);
      else if ($O(s, l, !0))
        tM(s, "LI") ? (p.insertAfter(M, vl(s)), M.appendChild(p.doc.createTextNode(" ")), M.appendChild(s)) : S.insertBefore(M, s), p.remove(l);
      else if ($O(s, l, !1))
        p.insertAfter(M, vl(s)), p.remove(l);
      else {
        s = vl(s);
        const j = v.cloneRange();
        j.setStartAfter(l), j.setEndAfter(s);
        const U = j.extractContents();
        if (d === "LI" && $7(U, "LI")) {
          const Z = xn(en(M.children, Me.fromDom), jt(_s("br")));
          M = U.firstChild, p.insertAfter(U, s), Ue(Z, (de) => Cm(Me.fromDom(M), de)), O && M.setAttribute("style", O);
        } else
          p.insertAfter(U, s), p.insertAfter(M, s);
        p.remove(l);
      }
      Hx(e, M);
    }, NY = (e) => {
      Ue(_l(Me.fromDom(e), pt), (n) => {
        const s = n.dom;
        s.nodeValue = Kc(s.data);
      });
    }, MY = (e, n) => {
      const s = e.dom.getParent(n, "ol,ul,dl");
      return s !== null && e.dom.getContentEditableParent(s) === "false";
    }, IY = (e, n) => n && n.nodeName === "A" && e.isEmpty(n), oM = (e, n) => e.nodeName === n || e.previousSibling && e.previousSibling.nodeName === n, zx = (e, n) => je(n) && e.isBlock(n) && !/^(TD|TH|CAPTION|FORM)$/.test(n.nodeName) && !/^(fixed|absolute)/i.test(n.style.position) && e.isEditable(n.parentNode) && e.getContentEditable(n) !== "false", FY = (e, n, s) => {
      var l;
      const d = [];
      if (!s)
        return;
      let p = s;
      for (; p = p.firstChild; ) {
        if (e.isBlock(p))
          return;
        On(p) && !n[p.nodeName.toLowerCase()] && d.push(p);
      }
      let v = d.length;
      for (; v--; )
        p = d[v], (!p.hasChildNodes() || p.firstChild === p.lastChild && ((l = p.firstChild) === null || l === void 0 ? void 0 : l.nodeValue) === "" || IY(e, p)) && e.remove(p);
    }, rM = (e, n, s) => Zt(n) ? e ? s === 1 && n.data.charAt(s - 1) === Ma ? 0 : s : s === n.data.length - 1 && n.data.charAt(s) === Ma ? n.data.length : s : s, sM = (e) => {
      const n = e.cloneRange();
      return n.setStart(e.startContainer, rM(!0, e.startContainer, e.startOffset)), n.setEnd(e.endContainer, rM(!1, e.endContainer, e.endOffset)), n;
    }, aM = (e) => {
      let n = e;
      do
        Zt(n) && (n.data = n.data.replace(/^[\r\n]+/, "")), n = n.firstChild;
      while (n);
    }, BY = (e, n, s, l, d) => {
      var p, v;
      const S = e.dom, O = (p = VS(S, l)) !== null && p !== void 0 ? p : S.getRoot();
      let M = S.getParent(l, S.isBlock);
      if (!M || !zx(S, M)) {
        if (M = M || O, !M.hasChildNodes()) {
          const de = S.create(n);
          return jS(e, de), M.appendChild(de), s.setStart(de, 0), s.setEnd(de, 0), de;
        }
        let j = l;
        for (; j && j.parentNode !== M; )
          j = j.parentNode;
        let U;
        for (; j && !S.isBlock(j); )
          U = j, j = j.previousSibling;
        const Z = (v = U == null ? void 0 : U.parentElement) === null || v === void 0 ? void 0 : v.nodeName;
        if (U && Z && e.schema.isValidChild(Z, n.toLowerCase())) {
          const de = U.parentNode, we = S.create(n);
          for (jS(e, we), de.insertBefore(we, U), j = U; j && !S.isBlock(j); ) {
            const me = j.nextSibling;
            we.appendChild(j), j = me;
          }
          s.setStart(l, d), s.setEnd(l, d);
        }
      }
      return l;
    }, Zae = (e, n) => {
      n.normalize();
      const s = n.lastChild;
      (!s || On(s) && /^(left|right)$/gi.test(e.getStyle(s, "float", !0))) && e.add(n, "br");
    }, Gae = (e, n) => {
      const s = di(e);
      return Kt(n) ? !1 : G(s) ? At(Gt.explode(s), n.nodeName.toLowerCase()) : s;
    }, z7 = {
      insert: (e, n) => {
        let s, l, d, p, v = !1;
        const S = e.dom, O = e.schema, M = O.getNonEmptyElements(), j = e.selection.getRng(), U = Pl(e), Z = Me.fromDom(j.startContainer), de = md(Z, j.startOffset), we = de.exists((Lt) => Te(Lt) && !za(Lt)), me = j.collapsed && we, Se = (Lt, Vn) => TY(e, s, an, zt, R4(e), Lt, Vn), ze = (Lt) => {
          const Vn = rM(Lt, s, l);
          if (Zt(s) && (Lt ? Vn > 0 : Vn < s.data.length))
            return !1;
          if ((s.parentNode === an || s === an) && v && !Lt || Lt && On(s) && s === an.firstChild)
            return !0;
          if (oM(s, "TABLE") || oM(s, "HR"))
            return v && !Lt || !v && Lt;
          const co = new Ri(s, an);
          Zt(s) && (Lt && Vn === 0 ? co.prev() : !Lt && Vn === s.data.length && co.next());
          let Xo;
          for (; Xo = co.current(); ) {
            if (On(Xo)) {
              if (!Xo.getAttribute("data-mce-bogus")) {
                const Sr = Xo.nodeName.toLowerCase();
                if (M[Sr] && Sr !== "br")
                  return !1;
              }
            } else if (Zt(Xo) && !zc(Xo.data))
              return !1;
            Lt ? co.prev() : co.next();
          }
          return !0;
        }, Ye = () => {
          let Lt;
          return /^(H[1-6]|PRE|FIGURE)$/.test(d) && Dn !== "HGROUP" ? Lt = Se(U) : Lt = Se(), Gae(e, p) && zx(S, p) && S.isEmpty(an, void 0, { includeZwsp: !0 }) ? Lt = S.split(p, an) : S.insertAfter(Lt, an), Hx(e, Lt), Lt;
        };
        bn(S, j).each((Lt) => {
          j.setStart(Lt.startContainer, Lt.startOffset), j.setEnd(Lt.endContainer, Lt.endOffset);
        }), s = j.startContainer, l = j.startOffset;
        const We = !!(n && n.shiftKey), ut = !!(n && n.ctrlKey);
        On(s) && s.hasChildNodes() && !me && (v = l > s.childNodes.length - 1, s = s.childNodes[Math.min(l, s.childNodes.length - 1)] || s, v && Zt(s) ? l = s.data.length : l = 0);
        const zt = VS(S, s);
        if (!zt || MY(e, s))
          return;
        We || (s = BY(e, U, j, s, l));
        let an = S.getParent(s, S.isBlock) || S.getRoot();
        p = je(an == null ? void 0 : an.parentNode) ? S.getParent(an.parentNode, S.isBlock) : null, d = an ? an.nodeName.toUpperCase() : "";
        const Dn = p ? p.nodeName.toUpperCase() : "";
        if (Dn === "LI" && !ut) {
          const Lt = p;
          an = Lt, p = Lt.parentNode, d = Dn;
        }
        if (On(p) && AY(e, We, an))
          return PY(e, Se, an);
        if (/^(LI|DT|DD)$/.test(d) && On(p) && S.isEmpty(an)) {
          RY(e, Se, p, an, U);
          return;
        }
        if (!me && (an === e.getBody() || !zx(S, an)))
          return;
        const Tt = an.parentNode;
        let yt;
        if (me)
          yt = Se(U), de.fold(() => {
            Ys(Z, Me.fromDom(yt));
          }, (Lt) => {
            Ki(Lt, Me.fromDom(yt));
          }), e.selection.setCursorLocation(yt, 0);
        else if (Jh(an))
          yt = Rr(an), S.isEmpty(an) && BO(an), jS(e, yt), Hx(e, yt);
        else if (ze(!1))
          yt = Ye();
        else if (ze(!0) && Tt) {
          const Lt = vt.fromRangeStart(j), Vn = XP(Lt), co = Me.fromDom(an), Sr = JP(co, Lt, e.schema) ? uB(co, Lt, e.schema).bind((Cs) => Y.from(Cs.getNode())) : Y.none();
          yt = Tt.insertBefore(Se(), an);
          const ts = oM(an, "HR") || Vn ? yt : Sr.getOr(an);
          Hx(e, ts);
        } else {
          const Lt = sM(j).cloneRange();
          Lt.setEndAfter(an);
          const Vn = Lt.extractContents();
          NY(Vn), aM(Vn), yt = Vn.firstChild, S.insertAfter(Vn, an), FY(S, M, yt), Zae(S, an), S.isEmpty(an) && BO(an), yt.normalize(), S.isEmpty(yt) ? (S.remove(yt), Ye()) : (jS(e, yt), Hx(e, yt));
        }
        S.setAttrib(yt, "id", ""), e.dispatch("NewBlock", { newBlock: yt });
      },
      fakeEventName: "insertParagraph"
    }, Kae = (e, n, s) => {
      const l = new Ri(n, s);
      let d;
      const p = e.getNonEmptyElements();
      for (; d = l.next(); )
        if (p[d.nodeName.toLowerCase()] || Zt(d) && d.length > 0)
          return !0;
      return !1;
    }, V7 = (e, n, s) => {
      const l = e.dom.createRng();
      s ? (l.setStartBefore(n), l.setEndBefore(n)) : (l.setStartAfter(n), l.setEndAfter(n)), e.selection.setRng(l), OC(e, l);
    }, Jm = (e, n) => {
      const s = e.selection, l = e.dom, d = s.getRng();
      let p, v = !1;
      bn(l, d).each((de) => {
        d.setStart(de.startContainer, de.startOffset), d.setEnd(de.endContainer, de.endOffset);
      });
      let S = d.startOffset, O = d.startContainer;
      if (On(O) && O.hasChildNodes()) {
        const de = S > O.childNodes.length - 1;
        O = O.childNodes[Math.min(S, O.childNodes.length - 1)] || O, de && Zt(O) ? S = O.data.length : S = 0;
      }
      let M = l.getParent(O, l.isBlock);
      const j = M && M.parentNode ? l.getParent(M.parentNode, l.isBlock) : null, U = j ? j.nodeName.toUpperCase() : "", Z = !!(n && n.ctrlKey);
      U === "LI" && !Z && (M = j), Zt(O) && S >= O.data.length && (Kae(e.schema, O, M || l.getRoot()) || (p = l.create("br"), d.insertNode(p), d.setStartAfter(p), d.setEndAfter(p), v = !0)), p = l.create("br"), qv(l, d, p), V7(e, p, v), e.undoManager.add();
    }, $Y = (e, n) => {
      const s = Me.fromTag("br");
      Ki(Me.fromDom(n), s), e.undoManager.add();
    }, j7 = (e, n) => {
      HY(e.getBody(), n) || Jl(Me.fromDom(n), Me.fromTag("br"));
      const s = Me.fromTag("br");
      Jl(Me.fromDom(n), s), V7(e, s.dom, !1), e.undoManager.add();
    }, LY = (e) => Wr(e.getNode()), HY = (e, n) => LY(vt.after(n)) ? !0 : Hl(e, vt.after(n)).map((s) => Wr(s.getNode())).getOr(!1), U7 = (e) => e && e.nodeName === "A" && "href" in e, zY = (e) => e.fold(tt, U7, U7, tt), VY = (e) => {
      const n = Le(Gb, e), s = vt.fromRangeStart(e.selection.getRng());
      return yf(n, e.getBody(), s).filter(zY);
    }, jY = (e, n) => {
      n.fold(qe, Le($Y, e), Le(j7, e), qe);
    }, iM = {
      insert: (e, n) => {
        const s = VY(e);
        s.isSome() ? s.each(Le(jY, e)) : Jm(e, n);
      },
      fakeEventName: "insertLineBreak"
    }, US = (e, n) => JN(e).filter((s) => n.length > 0 && wl(Me.fromDom(s), n)).isSome(), UY = (e) => US(e, Lp(e)), WY = (e) => US(e, D4(e)), Rd = ss.generate([
      { br: [] },
      { block: [] },
      { none: [] }
    ]), ZY = (e, n) => WY(e), Z7 = (e) => (n, s) => B7(n) === e, lM = (e, n) => (s, l) => _Y(s) === e.toUpperCase() === n, GY = (e) => {
      const n = VS(e.dom, e.selection.getStart());
      return Kt(n);
    }, Vx = (e) => lM("pre", e), G7 = () => lM("summary", !0), LO = (e) => (n, s) => A_(n) === e, qY = (e, n) => UY(e), jx = (e, n) => n, KY = (e) => {
      const n = Pl(e), s = VS(e.dom, e.selection.getStart());
      return je(s) && e.schema.isValidChild(s.nodeName, n);
    }, YY = (e) => {
      const n = e.selection.getRng(), s = Me.fromDom(n.startContainer), d = md(s, n.startOffset).map((p) => Te(p) && !za(p));
      return n.collapsed && d.getOr(!0);
    }, Cu = (e, n) => (s, l) => Ct(e, (p, v) => p && v(s, l), !0) ? Y.some(n) : Y.none(), XY = (e, n) => T6([
      Cu([ZY], Rd.none()),
      Cu([
        Vx(!0),
        GY
      ], Rd.none()),
      Cu([G7()], Rd.br()),
      Cu([
        Vx(!0),
        LO(!1),
        jx
      ], Rd.br()),
      Cu([
        Vx(!0),
        LO(!1)
      ], Rd.block()),
      Cu([
        Vx(!0),
        LO(!0),
        jx
      ], Rd.block()),
      Cu([
        Vx(!0),
        LO(!0)
      ], Rd.br()),
      Cu([
        Z7(!0),
        jx
      ], Rd.br()),
      Cu([Z7(!0)], Rd.block()),
      Cu([qY], Rd.br()),
      Cu([jx], Rd.br()),
      Cu([KY], Rd.block()),
      Cu([YY], Rd.block())
    ], [
      e,
      !!(n && n.shiftKey)
    ]).getOr(Rd.none()), Ux = (e, n, s) => {
      n.selection.isCollapsed() || jU(n), !(je(s) && Lx(n, e.fakeEventName).isDefaultPrevented()) && (e.insert(n, s), je(s) && sv(n, e.fakeEventName));
    }, HO = (e, n) => {
      const s = () => Ux(iM, e, n), l = () => Ux(z7, e, n), d = XY(e, n);
      switch (iy(e)) {
        case "linebreak":
          d.fold(s, s, qe);
          break;
        case "block":
          d.fold(l, l, qe);
          break;
        case "invert":
          d.fold(l, s, qe);
          break;
        default:
          d.fold(s, l, qe);
          break;
      }
    }, cM = Yt(), QY = cM.os.isiOS() && cM.browser.isSafari(), JY = (e, n) => {
      n.isDefaultPrevented() || (n.preventDefault(), pZ(e.undoManager), e.undoManager.transact(() => {
        HO(e, n);
      }));
    }, av = (e) => {
      if (!e.collapsed)
        return !1;
      const n = e.startContainer;
      if (Zt(n)) {
        const s = /^[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF]$/, l = n.data.charAt(e.startOffset - 1);
        return s.test(l);
      } else
        return !1;
    }, eX = (e) => {
      let n = Y.none();
      const s = (d) => {
        n = Y.some(d.selection.getBookmark()), d.undoManager.add();
      }, l = (d, p) => {
        d.undoManager.undo(), n.fold(qe, (v) => d.selection.moveToBookmark(v)), JY(d, p), n = Y.none();
      };
      e.on("keydown", (d) => {
        d.keyCode === Xt.ENTER && (QY && av(e.selection.getRng()) ? s(e) : JY(e, d));
      }), e.on("keyup", (d) => {
        d.keyCode === Xt.ENTER && n.each(() => l(e, d));
      });
    }, tX = (e, n, s) => {
      const l = rn.os.isMacOS() || rn.os.isiOS();
      SO([
        {
          keyCode: Xt.END,
          action: Io(ch, e, !0)
        },
        {
          keyCode: Xt.HOME,
          action: Io(ch, e, !1)
        },
        ...l ? [] : [
          {
            keyCode: Xt.HOME,
            action: Io(uh, e, !1),
            ctrlKey: !0,
            shiftKey: !0
          },
          {
            keyCode: Xt.END,
            action: Io(uh, e, !0),
            ctrlKey: !0,
            shiftKey: !0
          }
        ],
        {
          keyCode: Xt.END,
          action: Io(oK, e, !0)
        },
        {
          keyCode: Xt.HOME,
          action: Io(oK, e, !1)
        },
        {
          keyCode: Xt.END,
          action: Io(im, e, !0, n)
        },
        {
          keyCode: Xt.HOME,
          action: Io(im, e, !1, n)
        }
      ], s).each((d) => {
        s.preventDefault();
      });
    }, nX = (e, n) => {
      e.on("keydown", (s) => {
        s.isDefaultPrevented() || tX(e, n, s);
      });
    }, zO = (e) => {
      e.on("input", (n) => {
        n.isComposing || wB(e);
      });
    }, q7 = Yt(), K7 = (e, n, s) => {
      SO([
        {
          keyCode: Xt.PAGE_UP,
          action: Io(im, e, !1, n)
        },
        {
          keyCode: Xt.PAGE_DOWN,
          action: Io(im, e, !0, n)
        }
      ], s);
    }, Y7 = (e) => e.stopImmediatePropagation(), uM = (e) => e.keyCode === Xt.PAGE_UP || e.keyCode === Xt.PAGE_DOWN, X7 = (e, n, s) => {
      s && !e.get() ? n.on("NodeChange", Y7, !0) : !s && e.get() && n.off("NodeChange", Y7), e.set(s);
    }, oX = (e, n) => {
      if (q7.os.isMacOS())
        return;
      const s = Qe(!1);
      e.on("keydown", (l) => {
        uM(l) && X7(s, e, !0);
      }), e.on("keyup", (l) => {
        l.isDefaultPrevented() || K7(e, n, l), uM(l) && s.get() && (X7(s, e, !1), e.nodeChanged());
      });
    }, rX = (e) => {
      e.on("beforeinput", (n) => {
        (!e.selection.isEditable() || $n(n.getTargetRanges(), (s) => !HF(e.dom, s))) && n.preventDefault();
      });
    }, VO = (e, n) => {
      const s = n.container(), l = n.offset();
      return Zt(s) ? (s.insertData(l, e), Y.some(vt(s, l + e.length))) : Ay(n).map((d) => {
        const p = Me.fromText(e);
        return n.isAtEnd() ? Jl(d, p) : Ki(d, p), vt(p.dom, e.length);
      });
    }, jO = Le(VO, Xa), Q7 = Le(VO, " "), dM = (e, n, s) => gB(e, n, s) ? jO(n) : Q7(n), J7 = (e) => (n) => n.fold((s) => Xc(e.dom, vt.before(s)), (s) => zl(s), (s) => gu(s), (s) => Hl(e.dom, vt.after(s))), UO = (e, n, s) => (l) => gB(e, l, s) ? jO(n) : Q7(n), fM = (e) => (n) => {
      e.selection.setRng(n.toRange()), e.nodeChanged();
    }, eH = (e, n) => e.isEditable(e.getParent(n, "summary")), sX = (e) => {
      const n = vt.fromRangeStart(e.selection.getRng()), s = Me.fromDom(e.getBody());
      if (e.selection.isCollapsed()) {
        const l = Le(Gb, e), d = vt.fromRangeStart(e.selection.getRng());
        return yf(l, e.getBody(), d).bind(J7(s)).map((p) => () => UO(s, n, e.schema)(p).each(fM(e)));
      } else
        return Y.none();
    }, aX = (e) => {
      const n = () => {
        const s = Me.fromDom(e.getBody());
        e.selection.isCollapsed() || e.getDoc().execCommand("Delete");
        const l = vt.fromRangeStart(e.selection.getRng());
        dM(s, l, e.schema).each(fM(e));
      };
      return xr(rn.browser.isFirefox() && e.selection.isEditable() && eH(e.dom, e.selection.getRng().startContainer), n);
    }, WO = (e, n) => {
      tK([
        {
          keyCode: Xt.SPACEBAR,
          action: Io(sX, e)
        },
        {
          keyCode: Xt.SPACEBAR,
          action: Io(aX, e)
        }
      ], n).each((s) => {
        n.preventDefault(), Lx(e, "insertText", { data: " " }).isDefaultPrevented() || (s(), sv(e, "insertText", { data: " " }));
      });
    }, tH = (e) => {
      e.on("keydown", (n) => {
        n.isDefaultPrevented() || WO(e, n);
      });
    }, iX = (e) => U4(e) ? [
      {
        keyCode: Xt.TAB,
        action: Io(MN, e, !0)
      },
      {
        keyCode: Xt.TAB,
        shiftKey: !0,
        action: Io(MN, e, !1)
      }
    ] : [], lX = (e, n) => {
      SO([...iX(e)], n).each((s) => {
        n.preventDefault();
      });
    }, nH = (e) => {
      e.on("keydown", (n) => {
        n.isDefaultPrevented() || lX(e, n);
      });
    }, cX = (e) => {
      if (e.addShortcut("Meta+P", "", "mcePrint"), ol(e), sh(e))
        return Qe(null);
      {
        const n = wq(e);
        return rX(e), g8(e), EK(e, n), F7(e, n), eX(e), tH(e), zO(e), nH(e), nX(e, n), oX(e, n), n;
      }
    };
    class uX {
      constructor(n) {
        this.lastPath = [], this.editor = n;
        let s;
        const l = this;
        "onselectionchange" in n.getDoc() || n.on("NodeChange click mouseup keyup focus", (d) => {
          const p = n.selection.getRng(), v = {
            startContainer: p.startContainer,
            startOffset: p.startOffset,
            endContainer: p.endContainer,
            endOffset: p.endOffset
          };
          (d.type === "nodechange" || !E(v, s)) && n.dispatch("SelectionChange"), s = v;
        }), n.on("contextmenu", () => {
          AC(n), n.dispatch("SelectionChange");
        }), n.on("SelectionChange", () => {
          const d = n.selection.getStart(!0);
          d && cC(n) && !l.isSameElementPath(d) && n.dom.isChildOf(d, n.getBody()) && n.nodeChanged({ selectionChange: !0 });
        }), n.on("mouseup", (d) => {
          !d.isDefaultPrevented() && cC(n) && (n.selection.getNode().nodeName === "IMG" ? Td.setEditorTimeout(n, () => {
            n.nodeChanged();
          }) : n.nodeChanged());
        });
      }
      nodeChanged(n = {}) {
        const s = this.editor.selection;
        let l;
        if (this.editor.initialized && s && !fy(this.editor) && !this.editor.mode.isReadOnly()) {
          const d = this.editor.getBody();
          l = s.getStart(!0) || d, (l.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(l, d)) && (l = d);
          const p = [];
          this.editor.dom.getParent(l, (v) => v === d ? !0 : (p.push(v), !1)), this.editor.dispatch("NodeChange", {
            ...n,
            element: l,
            parents: p
          });
        }
      }
      isSameElementPath(n) {
        let s;
        const l = this.editor, d = Qo(l.dom.getParents(n, mt, l.getBody()));
        if (d.length === this.lastPath.length) {
          for (s = d.length; s >= 0 && d[s] === this.lastPath[s]; s--)
            ;
          if (s === -1)
            return this.lastPath = d, !0;
        }
        return this.lastPath = d, !1;
      }
    }
    const oH = mb("image"), dX = (e) => {
      const n = e;
      return Y.from(n[oH]);
    }, fX = (e, n) => {
      const s = e;
      s[oH] = n;
    }, ZO = mb("event"), mX = (e) => {
      const n = e;
      return Y.from(n[ZO]);
    }, WS = (e) => (n) => {
      const s = n;
      s[ZO] = e;
    }, pX = (e, n) => WS(n)(e), rH = WS(0), hX = WS(2), gX = WS(1), Wx = ((e) => (n) => {
      const s = n;
      return Y.from(s[ZO]).exists((l) => l === e);
    })(0), bX = () => Object.freeze({
      length: 0,
      item: (e) => null
    }), mM = mb("mode"), sH = (e) => {
      const n = e;
      return Y.from(n[mM]);
    }, GO = (e) => (n) => {
      const s = n;
      s[mM] = e;
    }, aH = (e, n) => GO(n)(e), iH = GO(0), qO = GO(2), vX = GO(1), lH = (e) => (n) => {
      const s = n;
      return Y.from(s[mM]).exists((l) => l === e);
    }, ZS = lH(0), GS = lH(1), yX = (e, n) => ({
      ...n,
      get length() {
        return n.length;
      },
      add: (s, l) => {
        if (ZS(e))
          if (G(s)) {
            if (!ot(l))
              return n.add(s, l);
          } else
            return n.add(s);
        return null;
      },
      remove: (s) => {
        ZS(e) && n.remove(s);
      },
      clear: () => {
        ZS(e) && n.clear();
      }
    }), xX = [
      "none",
      "copy",
      "link",
      "move"
    ], wX = [
      "none",
      "copy",
      "copyLink",
      "copyMove",
      "link",
      "linkMove",
      "move",
      "all",
      "uninitialized"
    ], pM = () => {
      const e = new window.DataTransfer();
      let n = "move", s = "all";
      const l = {
        get dropEffect() {
          return n;
        },
        set dropEffect(d) {
          At(xX, d) && (n = d);
        },
        get effectAllowed() {
          return s;
        },
        set effectAllowed(d) {
          Wx(l) && At(wX, d) && (s = d);
        },
        get items() {
          return yX(l, e.items);
        },
        get files() {
          return GS(l) ? bX() : e.files;
        },
        get types() {
          return e.types;
        },
        setDragImage: (d, p, v) => {
          ZS(l) && (fX(l, {
            image: d,
            x: p,
            y: v
          }), e.setDragImage(d, p, v));
        },
        getData: (d) => GS(l) ? "" : e.getData(d),
        setData: (d, p) => {
          ZS(l) && e.setData(d, p);
        },
        clearData: (d) => {
          ZS(l) && e.clearData(d);
        }
      };
      return iH(l), l;
    }, CX = (e) => {
      const n = pM(), s = sH(e);
      return qO(e), rH(n), n.dropEffect = e.dropEffect, n.effectAllowed = e.effectAllowed, dX(e).each((l) => n.setDragImage(l.image, l.x, l.y)), Ue(e.types, (l) => {
        l !== "Files" && n.setData(l, e.getData(l));
      }), Ue(e.files, (l) => n.items.add(l)), mX(e).each((l) => {
        pX(n, l);
      }), s.each((l) => {
        aH(e, l), aH(n, l);
      }), n;
    }, SX = (e) => {
      const n = e.getData("text/html");
      return n === "" ? Y.none() : Y.some(n);
    }, cH = (e, n) => e.setData("text/html", n), uH = "x-tinymce/html", KO = dt(uH), hM = "<!-- " + uH + " -->", kX = (e) => hM + e, _X = (e) => e.replace(hM, ""), dH = (e) => e.indexOf(hM) !== -1, Gs = (e) => !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(e), EX = (e, n) => {
      let s = "<" + e;
      const l = xa(n, (d, p) => p + '="' + ef.encodeAllRaw(d) + '"');
      return l.length && (s += " " + l.join(" ")), s + ">";
    }, fH = (e, n, s) => {
      const l = e.split(/\n\n/), d = EX(n, s), p = "</" + n + ">", v = en(l, (O) => O.split(/\n/).join("<br />")), S = (O) => d + O + p;
      return v.length === 1 ? v[0] : en(v, S).join("");
    }, mH = "%MCEPASTEBIN%", gM = (e, n) => {
      const { dom: s, selection: l } = e, d = e.getBody();
      n.set(l.getRng());
      const p = s.add(e.getBody(), "div", {
        id: "mcepastebin",
        class: "mce-pastebin",
        contentEditable: !0,
        "data-mce-bogus": "all",
        style: "position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0"
      }, mH);
      rn.browser.isFirefox() && s.setStyle(p, "left", s.getStyle(d, "direction", !0) === "rtl" ? 65535 : -65535), s.bind(p, "beforedeactivate focusin focusout", (v) => {
        v.stopPropagation();
      }), p.focus(), l.select(p, !0);
    }, pH = (e, n) => {
      const s = e.dom;
      if (bM(e)) {
        let l;
        const d = n.get();
        for (; l = bM(e); )
          s.remove(l), s.unbind(l);
        d && e.selection.setRng(d);
      }
      n.set(null);
    }, bM = (e) => e.dom.get("mcepastebin"), TX = (e) => je(e) && e.id === "mcepastebin", hH = (e) => {
      const n = e.dom, s = (v, S) => {
        v.appendChild(S), n.remove(S, !0);
      }, [l, ...d] = xn(e.getBody().childNodes, TX);
      Ue(d, (v) => {
        s(l, v);
      });
      const p = n.select("div[id=mcepastebin]", l);
      for (let v = p.length - 1; v >= 0; v--) {
        const S = n.create("div");
        l.insertBefore(S, p[v]), s(S, p[v]);
      }
      return l ? l.innerHTML : "";
    }, YO = (e) => e === mH, OX = (e) => {
      const n = Qe(null);
      return {
        create: () => gM(e, n),
        remove: () => pH(e, n),
        getEl: () => bM(e),
        getHtml: () => hH(e),
        getLastRng: n.get
      };
    }, gH = (e, n) => (Gt.each(n, (s) => {
      ae(s, RegExp) ? e = e.replace(s, "") : e = e.replace(s[0], s[1]);
    }), e), AX = (e) => {
      const n = Hf(), s = oh({}, n);
      let l = "";
      const d = n.getVoidElements(), p = Gt.makeMap("script noscript style textarea video audio iframe object", " "), v = n.getBlockElements(), S = (O) => {
        const M = O.name, j = O;
        if (M === "br") {
          l += `
`;
          return;
        }
        if (M !== "wbr") {
          if (d[M] && (l += " "), p[M]) {
            l += " ";
            return;
          }
          if (O.type === 3 && (l += O.value), !(O.name in n.getVoidElements())) {
            let U = O.firstChild;
            if (U)
              do
                S(U);
              while (U = U.next);
          }
          v[M] && j.next && (l += `
`, M === "p" && (l += `
`));
        }
      };
      return e = gH(e, [/<!\[[^\]]+\]>/g]), S(s.parse(e)), l;
    }, vM = (e) => (e = gH(e, [
      /^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/ig,
      /<!--StartFragment-->|<!--EndFragment-->/g,
      [
        /( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g,
        (s, l, d) => !l && !d ? " " : Xa
      ],
      /<br class="Apple-interchange-newline">/g,
      /<br>$/i
    ]), e), PX = (e) => {
      let n = 0;
      return () => e + n++;
    }, DX = (e) => {
      const n = e.toLowerCase(), s = {
        jpg: "jpeg",
        jpe: "jpeg",
        jfi: "jpeg",
        jif: "jpeg",
        jfif: "jpeg",
        pjpeg: "jpeg",
        pjp: "jpeg",
        svg: "svg+xml"
      };
      return Gt.hasOwn(s, n) ? "image/" + s[n] : "image/" + n;
    }, Zx = (e, n) => {
      const s = oh({
        sanitize: yy(e),
        sandbox_iframes: xy(e),
        sandbox_iframes_exclusions: wy(e),
        convert_unsafe_embeds: Z4(e)
      }, e.schema);
      s.addNodeFilter("meta", (d) => {
        Gt.each(d, (p) => {
          p.remove();
        });
      });
      const l = s.parse(n, {
        forced_root_block: !1,
        isRootContent: !0
      });
      return Cg({ validate: !0 }, e.schema).serialize(l);
    }, bH = (e, n) => ({
      content: e,
      cancelled: n
    }), Gx = (e, n, s) => {
      const l = e.dom.create("div", { style: "display:none" }, n), d = wP(e, l, s);
      return bH(d.node.innerHTML, d.isDefaultPrevented());
    }, qS = (e, n, s) => {
      const l = xP(e, n, s), d = Zx(e, l.content);
      return e.hasEventListeners("PastePostProcess") && !l.isDefaultPrevented() ? Gx(e, d, s) : bH(d, l.isDefaultPrevented());
    }, RX = (e, n, s) => qS(e, n, s), yM = (e, n) => (e.insertContent(n, {
      merge: U_(e),
      paste: !0
    }), !0), iv = (e) => /^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(e), NX = (e, n) => iv(n) && $n(o1(e), (s) => rr(n.toLowerCase(), `.${s.toLowerCase()}`)), xM = (e, n, s) => (e.undoManager.extra(() => {
      s(e, n);
    }, () => {
      e.insertContent('<img src="' + n + '">');
    }), !0), MX = (e, n, s) => (e.undoManager.extra(() => {
      s(e, n);
    }, () => {
      e.execCommand("mceInsertLink", !1, n);
    }), !0), vH = (e, n, s) => !e.selection.isCollapsed() && iv(n) ? MX(e, n, s) : !1, yH = (e, n, s) => NX(e, n) ? xM(e, n, s) : !1, wM = (e, n) => {
      Gt.each([
        vH,
        yH,
        yM
      ], (s) => !s(e, n, yM));
    }, xH = (e, n, s) => {
      s || !W_(e) ? yM(e, n) : wM(e, n);
    }, IX = PX("mceclip"), FX = (e) => {
      const n = pM();
      return cH(n, e), qO(n), n;
    }, CM = (e, n, s, l, d) => {
      const p = RX(e, n, s);
      if (!p.cancelled) {
        const v = p.content, S = () => xH(e, v, l);
        d ? Lx(e, "insertFromPaste", { dataTransfer: FX(v) }).isDefaultPrevented() || (S(), sv(e, "insertFromPaste")) : S();
      }
    }, XO = (e, n, s, l) => {
      const d = s || dH(n);
      CM(e, _X(n), d, !1, l);
    }, QO = (e, n, s) => {
      const l = e.dom.encode(n).replace(/\r\n/g, `
`), d = uu(l, hy(e)), p = fH(d, Pl(e), $p(e));
      CM(e, p, !1, !0, s);
    }, JO = (e) => {
      const n = {};
      if (e && e.types)
        for (let s = 0; s < e.types.length; s++) {
          const l = e.types[s];
          try {
            n[l] = e.getData(l);
          } catch {
            n[l] = "";
          }
        }
      return n;
    }, Fg = (e, n) => n in e && e[n].length > 0, wH = (e) => Fg(e, "text/html") || Fg(e, "text/plain"), BX = (e, n) => {
      const s = n.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
      return je(s) ? e.dom.encode(s[1]) : void 0;
    }, $X = (e, n, s, l) => {
      const d = IX(), p = fi(e) && je(s.name), v = p ? BX(e, s.name) : d, S = p ? s.name : void 0, O = n.create(d, s, l, v, S);
      return n.add(O), O;
    }, CH = (e, n) => {
      JD(n.uri).each(({ data: s, type: l, base64Encoded: d }) => {
        const p = d ? s : btoa(s), v = n.file, S = e.editorUpload.blobCache, O = S.getByData(p, l), M = O ?? $X(e, S, v, p);
        XO(e, `<img src="${M.blobUri()}">`, !1, !0);
      });
    }, SM = (e) => e.type === "paste", LX = (e) => Promise.all(en(e, (n) => D$(n).then((s) => ({
      file: n,
      uri: s
    })))), SH = (e) => {
      const n = o1(e);
      return (s) => lo(s.type, "image/") && $n(n, (l) => DX(l) === s.type);
    }, kH = (e, n) => {
      const s = n.items ? nr(hr(n.items), (d) => d.kind === "file" ? [d.getAsFile()] : []) : [], l = n.files ? hr(n.files) : [];
      return xn(s.length > 0 ? s : l, SH(e));
    }, _H = (e, n, s) => {
      const l = SM(n) ? n.clipboardData : n.dataTransfer;
      if (n1(e) && l) {
        const d = kH(e, l);
        if (d.length > 0)
          return n.preventDefault(), LX(d).then((p) => {
            s && e.selection.setRng(s), Ue(p, (v) => {
              CH(e, v);
            });
          }), !0;
      }
      return !1;
    }, EH = (e) => {
      var n, s;
      return rn.os.isAndroid() && ((s = (n = e.clipboardData) === null || n === void 0 ? void 0 : n.items) === null || s === void 0 ? void 0 : s.length) === 0;
    }, HX = (e) => Xt.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45, kM = (e, n, s, l, d) => {
      let p = vM(s);
      const v = Fg(n, KO()) || dH(s), S = !v && Gs(p), O = iv(p);
      (YO(p) || !p.length || S && !O) && (l = !0), (l || O) && (Fg(n, "text/plain") && S ? p = n["text/plain"] : p = AX(p)), !YO(p) && (l ? QO(e, p, d) : XO(e, p, v, d));
    }, zX = (e, n, s) => {
      let l;
      const d = () => n.getLastRng() || e.selection.getRng();
      e.on("keydown", (p) => {
        HX(p) && !p.isDefaultPrevented() && (l = p.shiftKey && p.keyCode === 86);
      }), e.on("paste", (p) => {
        if (p.isDefaultPrevented() || EH(p))
          return;
        const v = s.get() === "text" || l;
        l = !1;
        const S = JO(p.clipboardData);
        !wH(S) && _H(e, p, d()) || (Fg(S, "text/html") ? (p.preventDefault(), kM(e, S, S["text/html"], v, !0)) : Fg(S, "text/plain") && Fg(S, "text/uri-list") ? (p.preventDefault(), kM(e, S, S["text/plain"], v, !0)) : (n.create(), Td.setEditorTimeout(e, () => {
          const O = n.getHtml();
          n.remove(), kM(e, S, O, v, !1);
        }, 0)));
      });
    }, VX = (e) => {
      const n = (d) => lo(d, "webkit-fake-url"), s = (d) => lo(d, "data:"), l = (d) => {
        var p;
        return ((p = d.data) === null || p === void 0 ? void 0 : p.paste) === !0;
      };
      e.parser.addNodeFilter("img", (d, p, v) => {
        if (!n1(e) && l(v))
          for (const S of d) {
            const O = S.attr("src");
            G(O) && !S.attr("data-mce-object") && O !== rn.transparentSrc && (n(O) || !Eb(e) && s(O)) && S.remove();
          }
      });
    }, jX = (e, n, s) => {
      zX(e, n, s), VX(e);
    }, eA = (e, n) => {
      n.get() === "text" ? (n.set("html"), Xy(e, !1)) : (n.set("text"), Xy(e, !0)), e.focus();
    }, UX = (e, n) => {
      e.addCommand("mceTogglePlainTextPaste", () => {
        eA(e, n);
      }), e.addCommand("mceInsertClipboardContent", (s, l) => {
        l.html && XO(e, l.html, l.internal, !1), l.text && QO(e, l.text, !1);
      });
    }, TH = (e, n, s) => {
      if (e)
        try {
          return e.clearData(), e.setData("text/html", n), e.setData("text/plain", s), e.setData(KO(), n), !0;
        } catch {
          return !1;
        }
      else
        return !1;
    }, OH = (e, n, s, l) => {
      TH(e.clipboardData, n.html, n.text) ? (e.preventDefault(), l()) : s(n.html, l);
    }, AH = (e) => (n, s) => {
      const { dom: l, selection: d } = e, p = l.create("div", {
        contenteditable: "false",
        "data-mce-bogus": "all"
      }), v = l.create("div", { contenteditable: "true" }, n);
      l.setStyles(p, {
        position: "fixed",
        top: "0",
        left: "-3000px",
        width: "1000px",
        overflow: "hidden"
      }), p.appendChild(v), l.add(e.getBody(), p);
      const S = d.getRng();
      v.focus();
      const O = l.createRng();
      O.selectNodeContents(v), d.setRng(O), Td.setEditorTimeout(e, () => {
        d.setRng(S), l.remove(p), s();
      }, 0);
    }, _M = (e) => ({
      html: kX(e.selection.getContent({ contextual: !0 })),
      text: e.selection.getContent({ format: "text" })
    }), PH = (e) => !!e.dom.getParent(e.selection.getStart(), "td[data-mce-selected],th[data-mce-selected]", e.getBody()), DH = (e) => !e.selection.isCollapsed() || PH(e), WX = (e) => (n) => {
      !n.isDefaultPrevented() && DH(e) && e.selection.isEditable() && OH(n, _M(e), AH(e), () => {
        if (rn.browser.isChromium() || rn.browser.isFirefox()) {
          const s = e.selection.getRng();
          Td.setEditorTimeout(e, () => {
            e.selection.setRng(s), e.execCommand("Delete");
          }, 0);
        } else
          e.execCommand("Delete");
      });
    }, ZX = (e) => (n) => {
      !n.isDefaultPrevented() && DH(e) && OH(n, _M(e), AH(e), qe);
    }, GX = (e) => {
      e.on("cut", WX(e)), e.on("copy", ZX(e));
    }, RH = (e, n) => {
      var s, l;
      return Ut.getCaretRangeFromPoint((s = n.clientX) !== null && s !== void 0 ? s : 0, (l = n.clientY) !== null && l !== void 0 ? l : 0, e.getDoc());
    }, NH = (e) => {
      const n = e["text/plain"];
      return n ? n.indexOf("file://") === 0 : !1;
    }, MH = (e, n) => {
      e.focus(), n && e.selection.setRng(n);
    }, qX = (e) => $n(e.files, (n) => /^image\//.test(n.type)), KX = (e, n, s, l) => {
      const d = e.getParent(s, (v) => Lu(n, v));
      if (!te(e.getParent(s, "summary")))
        return !0;
      if (d && Xn(l, "text/html")) {
        const v = new DOMParser().parseFromString(l["text/html"], "text/html").body;
        return !te(v.querySelector(d.nodeName.toLowerCase()));
      } else
        return !1;
    }, YX = (e) => {
      e.on("input", (n) => {
        const s = (l) => te(l.querySelector("summary"));
        if (n.inputType === "deleteByDrag") {
          const l = xn(e.dom.select("details"), s);
          Ue(l, (d) => {
            Wr(d.firstChild) && d.firstChild.remove();
            const p = e.dom.create("summary");
            p.appendChild(Xh().dom), d.prepend(p);
          });
        }
      });
    }, XX = (e, n) => {
      $2(e) && e.on("dragend dragover draggesture dragdrop drop drag", (s) => {
        s.preventDefault(), s.stopPropagation();
      }), n1(e) || e.on("drop", (s) => {
        const l = s.dataTransfer;
        l && qX(l) && s.preventDefault();
      }), e.on("drop", (s) => {
        if (s.isDefaultPrevented())
          return;
        const l = RH(e, s);
        if (Kt(l))
          return;
        const d = JO(s.dataTransfer), p = Fg(d, KO());
        if ((!wH(d) || NH(d)) && _H(e, s, l))
          return;
        const v = d[KO()], S = v || d["text/html"] || d["text/plain"], O = KX(e.dom, e.schema, l.startContainer, d), M = n.get();
        M && !O || S && (s.preventDefault(), Td.setEditorTimeout(e, () => {
          e.undoManager.transact(() => {
            (v || M && O) && e.execCommand("Delete"), MH(e, l);
            const j = vM(S);
            d["text/html"] ? XO(e, j, p, !0) : QO(e, j, !0);
          });
        }));
      }), e.on("dragstart", (s) => {
        n.set(!0);
      }), e.on("dragover dragend", (s) => {
        n1(e) && !n.get() && (s.preventDefault(), MH(e, RH(e, s))), s.type === "dragend" && n.set(!1);
      }), YX(e);
    }, QX = (e) => {
      const n = (d) => (p) => {
        d(e, p);
      }, s = L2(e);
      ye(s) && e.on("PastePreProcess", n(s));
      const l = z_(e);
      ye(l) && e.on("PastePostProcess", n(l));
    }, JX = (e, n) => {
      e.on("PastePreProcess", (s) => {
        s.content = n(e, s.content, s.internal);
      });
    }, eQ = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi, EM = (e) => Gt.trim(e).replace(eQ, nf).toLowerCase(), IH = (e, n, s) => {
      const l = j_(e);
      if (s || l === "all" || !H4(e))
        return n;
      const d = l ? l.split(/[, ]/) : [];
      if (d && l !== "none") {
        const p = e.dom, v = e.selection.getNode();
        n = n.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, (S, O, M, j) => {
          const U = p.parseStyle(p.decode(M)), Z = {};
          for (let we = 0; we < d.length; we++) {
            const me = U[d[we]];
            let Se = me, ze = p.getStyle(v, d[we], !0);
            /color/.test(d[we]) && (Se = EM(Se), ze = EM(ze)), ze !== Se && (Z[d[we]] = me);
          }
          const de = p.serializeStyle(Z, "span");
          return de ? O + ' style="' + de + '"' + j : O + j;
        });
      } else
        n = n.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, "$1$3");
      return n = n.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, (p, v, S, O) => v + ' style="' + S + '"' + O), n;
    }, tQ = (e) => {
      (rn.browser.isChromium() || rn.browser.isSafari()) && JX(e, IH);
    }, nQ = (e) => {
      const n = Qe(!1), s = Qe(Z_(e) ? "text" : "html"), l = OX(e);
      tQ(e), UX(e, s), QX(e), e.addQueryStateHandler("mceTogglePlainTextPaste", () => s.get() === "text"), e.on("PreInit", () => {
        GX(e), XX(e, n), jX(e, l, s);
      });
    }, oQ = (e) => {
      e.on("click", (n) => {
        e.dom.getParent(n.target, "details") && n.preventDefault();
      });
    }, rQ = (e) => {
      e.parser.addNodeFilter("details", (n) => {
        const s = W4(e);
        Ue(n, (l) => {
          s === "expanded" ? l.attr("open", "open") : s === "collapsed" && l.attr("open", null);
        });
      }), e.serializer.addNodeFilter("details", (n) => {
        const s = q_(e);
        Ue(n, (l) => {
          s === "expanded" ? l.attr("open", "open") : s === "collapsed" && l.attr("open", null);
        });
      });
    }, sQ = (e) => {
      oQ(e), rQ(e);
    }, aQ = Wr, FH = Zt, tA = (e) => Vr(e.dom), BH = (e) => Rt(e.dom), $H = (e) => (n) => zr(Me.fromDom(e), n), LH = (e, n, s) => aa(Me.fromDom(e), (l) => BH(l) || s.isBlock(gr(l)), $H(n)).getOr(Me.fromDom(n)).dom, TM = (e, n) => aa(Me.fromDom(e), tA, $H(n)), nA = (e, n, s) => {
      const l = new Ri(e, n), d = s ? l.next.bind(l) : l.prev.bind(l);
      let p = e;
      for (let v = s ? e : d(); v && !aQ(v); v = d())
        lf(v) && (p = v);
      return p;
    }, iQ = (e, n, s) => {
      const d = vt.fromRangeStart(e).getNode(), p = LH(d, n, s), v = nA(d, p, !1), S = nA(d, p, !0), O = document.createRange();
      return TM(v, p).fold(() => {
        FH(v) ? O.setStart(v, 0) : O.setStartBefore(v);
      }, (M) => O.setStartBefore(M.dom)), TM(S, p).fold(() => {
        FH(S) ? O.setEnd(S, S.data.length) : O.setEndAfter(S);
      }, (M) => O.setEndAfter(M.dom)), O;
    }, HH = (e) => {
      const n = iQ(e.selection.getRng(), e.getBody(), e.schema);
      e.selection.setRng(Zs(n));
    }, lQ = (e) => {
      e.on("mousedown", (n) => {
        n.detail >= 3 && (n.preventDefault(), HH(e));
      });
    };
    var t0;
    (function(e) {
      e.Before = "before", e.After = "after";
    })(t0 || (t0 = {}));
    const cQ = (e, n) => Math.abs(e.left - n), zH = (e, n) => Math.abs(e.right - n), uQ = (e, n) => e >= n.top && e <= n.bottom, dQ = (e, n) => e.top < n.bottom && e.bottom > n.top, fQ = (e, n) => {
      const s = f4(e, n) / Math.min(e.height, n.height);
      return dQ(e, n) && s > 0.5;
    }, KS = (e, n) => {
      const s = xn(e, (l) => uQ(n, l));
      return pa(s).fold(() => [
        [],
        e
      ], (l) => {
        const {
          pass: d,
          fail: p
        } = mo(e, (v) => fQ(v, l));
        return [
          d,
          p
        ];
      });
    }, mQ = (e, n) => ({
      node: e.node,
      position: cQ(e, n) < zH(e, n) ? t0.Before : t0.After
    }), pQ = (e, n, s) => n > e.left && n < e.right ? 0 : Math.min(Math.abs(e.left - n), Math.abs(e.right - n)), oA = (e, n, s, l) => {
      const d = (U) => lf(U.node) ? Y.some(U) : On(U.node) ? oA(hr(U.node.childNodes), n, s, !1) : Y.none(), p = (U, Z, de) => d(Z).filter((we) => Math.abs(de(U, n, s) - de(we, n, s)) < 2 && Zt(we.node)), v = (U, Z) => {
        const de = kt(U, (we, me) => Z(we, n, s) - Z(me, n, s));
        return or(de, d).map((we) => l && !Zt(we.node) && de.length > 1 ? p(we, de[1], Z).getOr(we) : we);
      }, [S, O] = KS(L6(e), s), {
        pass: M,
        fail: j
      } = mo(O, (U) => U.top < s);
      return v(S, pQ).orThunk(() => v(j, s2)).orThunk(() => v(M, s2));
    }, hQ = (e, n, s, l) => {
      const d = (p, v) => {
        const S = (M) => On(M) && M.classList.contains("mce-drag-container"), O = xn(p.dom.childNodes, jt(S));
        return v.fold(() => oA(O, s, l, !0), (M) => {
          const j = xn(O, (U) => U !== M.dom);
          return oA(j, s, l, !0);
        }).orThunk(() => (zr(p, e) ? Y.none() : Bc(p)).bind((j) => d(j, Y.some(p))));
      };
      return d(n, Y.none());
    }, gQ = (e, n, s) => {
      const l = Me.fromDom(e), d = Ka(l), v = Me.fromPoint(d, n, s).filter((S) => Gi(l, S)).getOr(l);
      return hQ(l, v, n, s);
    }, VH = (e, n, s) => gQ(e, n, s).filter((l) => Mm(l.node)).map((l) => mQ(l, n)), jH = (e) => {
      var n, s;
      const l = e.getBoundingClientRect(), d = e.ownerDocument, p = d.documentElement, v = d.defaultView;
      return {
        top: l.top + ((n = v == null ? void 0 : v.scrollY) !== null && n !== void 0 ? n : 0) - p.clientTop,
        left: l.left + ((s = v == null ? void 0 : v.scrollX) !== null && s !== void 0 ? s : 0) - p.clientLeft
      };
    }, bQ = (e) => e.inline ? jH(e.getBody()) : {
      left: 0,
      top: 0
    }, rA = (e) => {
      const n = e.getBody();
      return e.inline ? {
        left: n.scrollLeft,
        top: n.scrollTop
      } : {
        left: 0,
        top: 0
      };
    }, UH = (e) => {
      const n = e.getBody(), s = e.getDoc().documentElement, l = {
        left: n.scrollLeft,
        top: n.scrollTop
      }, d = {
        left: n.scrollLeft || s.scrollLeft,
        top: n.scrollTop || s.scrollTop
      };
      return e.inline ? l : d;
    }, WH = (e, n) => {
      if (n.target.ownerDocument !== e.getDoc()) {
        const s = jH(e.getContentAreaContainer()), l = UH(e);
        return {
          left: n.pageX - s.left + l.left,
          top: n.pageY - s.top + l.top
        };
      }
      return {
        left: n.pageX,
        top: n.pageY
      };
    }, vQ = (e, n, s) => ({
      pageX: s.left - e.left + n.left,
      pageY: s.top - e.top + n.top
    }), yQ = (e, n) => vQ(bQ(e), rA(e), WH(e, n)), ZH = (e) => ({
      target: e,
      srcElement: e
    }), Qae = (e, n, s, l) => ({
      ...n,
      dataTransfer: l,
      type: e,
      ...ZH(s)
    }), xQ = (e, n, s) => {
      const l = Fn("Function not supported on simulated event.");
      return {
        bubbles: !0,
        cancelBubble: !1,
        cancelable: !0,
        composed: !1,
        currentTarget: null,
        defaultPrevented: !1,
        eventPhase: 0,
        isTrusted: !0,
        returnValue: !1,
        timeStamp: 0,
        type: e,
        composedPath: l,
        initEvent: l,
        preventDefault: qe,
        stopImmediatePropagation: qe,
        stopPropagation: qe,
        AT_TARGET: window.Event.AT_TARGET,
        BUBBLING_PHASE: window.Event.BUBBLING_PHASE,
        CAPTURING_PHASE: window.Event.CAPTURING_PHASE,
        NONE: window.Event.NONE,
        altKey: !1,
        button: 0,
        buttons: 0,
        clientX: 0,
        clientY: 0,
        ctrlKey: !1,
        metaKey: !1,
        movementX: 0,
        movementY: 0,
        offsetX: 0,
        offsetY: 0,
        pageX: 0,
        pageY: 0,
        relatedTarget: null,
        screenX: 0,
        screenY: 0,
        shiftKey: !1,
        x: 0,
        y: 0,
        detail: 0,
        view: null,
        which: 0,
        initUIEvent: l,
        initMouseEvent: l,
        getModifierState: l,
        dataTransfer: s,
        ...ZH(n)
      };
    }, GH = (e, n) => {
      const s = CX(e);
      return n === "dragstart" ? (rH(s), iH(s)) : n === "drop" ? (hX(s), qO(s)) : (gX(s), vX(s)), s;
    }, OM = (e, n, s, l) => {
      const d = GH(s, e);
      return ot(l) ? xQ(e, n, d) : Qae(e, l, n, d);
    }, n0 = 32, wQ = 100, sA = 8, YS = 16, qH = Vr, AM = a2(qH, Rt), KH = (e, n, s) => qH(s) && s !== n && e.isEditable(s.parentElement), CQ = (e, n, s) => Kt(n) || n === s || e.dom.isChildOf(n, s) ? !1 : e.dom.isEditable(n), SQ = (e, n, s, l) => {
      const d = e.dom, p = n.cloneNode(!0);
      d.setStyles(p, {
        width: s,
        height: l
      }), d.setAttrib(p, "data-mce-selected", null);
      const v = d.create("div", {
        class: "mce-drag-container",
        "data-mce-bogus": "all",
        unselectable: "on",
        contenteditable: "false"
      });
      return d.setStyles(v, {
        position: "absolute",
        opacity: 0.5,
        overflow: "hidden",
        border: 0,
        padding: 0,
        margin: 0,
        width: s,
        height: l
      }), d.setStyles(p, {
        margin: 0,
        boxSizing: "border-box"
      }), v.appendChild(p), v;
    }, YH = (e, n) => {
      e.parentNode !== n && n.appendChild(e);
    }, aA = (e, n) => (s) => () => {
      const l = e === "left" ? s.scrollX : s.scrollY;
      s.scroll({
        [e]: l + n,
        behavior: "smooth"
      });
    }, kQ = aA("left", -n0), XH = aA("left", n0), QH = aA("top", -n0), JH = aA("top", n0), ez = (e, n, s, l, d, p, v, S, O, M, j, U) => {
      let Z = 0, de = 0;
      e.style.left = n.pageX + "px", e.style.top = n.pageY + "px", n.pageX + s > d && (Z = n.pageX + s - d), n.pageY + l > p && (de = n.pageY + l - p), e.style.width = s - Z + "px", e.style.height = l - de + "px";
      const we = O.clientHeight, me = O.clientWidth, Se = v + O.getBoundingClientRect().top, ze = S + O.getBoundingClientRect().left;
      j.on((Ye) => {
        Ye.intervalId.clear(), Ye.dragging && U && (v + sA >= we ? Ye.intervalId.set(JH(M)) : v - sA <= 0 ? Ye.intervalId.set(QH(M)) : S + sA >= me ? Ye.intervalId.set(XH(M)) : S - sA <= 0 ? Ye.intervalId.set(kQ(M)) : Se + YS >= window.innerHeight ? Ye.intervalId.set(JH(window)) : Se - YS <= 0 ? Ye.intervalId.set(QH(window)) : ze + YS >= window.innerWidth ? Ye.intervalId.set(XH(window)) : ze - YS <= 0 && Ye.intervalId.set(kQ(window)));
      });
    }, tz = (e) => {
      e && e.parentNode && e.parentNode.removeChild(e);
    }, nz = (e, n) => {
      const s = e.getParent(n.parentNode, e.isBlock);
      tz(n), s && s !== e.getRoot() && e.isEmpty(s) && qc(Me.fromDom(s));
    }, _Q = (e) => e.button === 0, EQ = (e, n) => ({
      pageX: n.pageX - e.relX,
      pageY: n.pageY + 5
    }), TQ = (e, n) => (s) => {
      if (_Q(s)) {
        const l = Pn(n.dom.getParents(s.target), AM).getOr(null);
        if (je(l) && KH(n.dom, n.getBody(), l)) {
          const d = n.dom.getPos(l), p = n.getBody(), v = n.getDoc().documentElement;
          e.set({
            element: l,
            dataTransfer: pM(),
            dragging: !1,
            screenX: s.screenX,
            screenY: s.screenY,
            maxX: (n.inline ? p.scrollWidth : v.offsetWidth) - 2,
            maxY: (n.inline ? p.scrollHeight : v.offsetHeight) - 2,
            relX: s.pageX - d.x,
            relY: s.pageY - d.y,
            width: l.offsetWidth,
            height: l.offsetHeight,
            ghost: SQ(n, l, l.offsetWidth, l.offsetHeight),
            intervalId: Cp(wQ)
          });
        }
      }
    }, OQ = (e, n, s) => {
      e._selectionOverrides.hideFakeCaret(), VH(e.getBody(), n, s).fold(() => e.selection.placeCaretAt(n, s), (l) => {
        const d = e._selectionOverrides.showCaret(1, l.node, l.position === t0.Before, !1);
        d ? e.selection.setRng(d) : e.selection.placeCaretAt(n, s);
      });
    }, XS = (e, n, s, l, d) => {
      n === "dragstart" && cH(l, e.dom.getOuterHTML(s));
      const p = OM(n, s, l, d);
      return e.dispatch(n, p);
    }, oz = (e, n) => {
      const s = Lv((d, p) => OQ(n, d, p), 0);
      n.on("remove", s.cancel);
      const l = e;
      return (d) => e.on((p) => {
        const v = Math.max(Math.abs(d.screenX - p.screenX), Math.abs(d.screenY - p.screenY));
        if (!p.dragging && v > 10) {
          const S = XS(n, "dragstart", p.element, p.dataTransfer, d);
          if (je(S.dataTransfer) && (p.dataTransfer = S.dataTransfer), S.isDefaultPrevented())
            return;
          p.dragging = !0, n.focus();
        }
        if (p.dragging) {
          const S = d.currentTarget === n.getDoc().documentElement, O = EQ(p, yQ(n, d));
          YH(p.ghost, n.getBody()), ez(p.ghost, O, p.width, p.height, p.maxX, p.maxY, d.clientY, d.clientX, n.getContentAreaContainer(), n.getWin(), l, S), s.throttle(d.clientX, d.clientY);
        }
      });
    }, Jae = (e) => {
      const n = e.getSel();
      if (je(n)) {
        const l = n.getRangeAt(0).startContainer;
        return Zt(l) ? l.parentNode : l;
      } else
        return null;
    }, AQ = (e, n) => (s) => {
      e.on((l) => {
        var d;
        if (l.intervalId.clear(), l.dragging) {
          if (CQ(n, Jae(n.selection), l.element)) {
            const p = (d = n.getDoc().elementFromPoint(s.clientX, s.clientY)) !== null && d !== void 0 ? d : n.getBody();
            XS(n, "drop", p, l.dataTransfer, s).isDefaultPrevented() || n.undoManager.transact(() => {
              nz(n.dom, l.element), SX(l.dataTransfer).each((S) => n.insertContent(S)), n._selectionOverrides.hideFakeCaret();
            });
          }
          XS(n, "dragend", n.getBody(), l.dataTransfer, s);
        }
      }), iA(e);
    }, PM = (e, n, s) => {
      e.on((l) => {
        l.intervalId.clear(), l.dragging && s.fold(() => XS(n, "dragend", l.element, l.dataTransfer), (d) => XS(n, "dragend", l.element, l.dataTransfer, d));
      }), iA(e);
    }, PQ = (e, n) => (s) => PM(e, n, Y.some(s)), iA = (e) => {
      e.on((n) => {
        n.intervalId.clear(), tz(n.ghost);
      }), e.clear();
    }, DQ = (e) => {
      const n = Mi(), s = Js.DOM, l = document, d = TQ(n, e), p = oz(n, e), v = AQ(n, e), S = PQ(n, e);
      e.on("mousedown", d), e.on("mousemove", p), e.on("mouseup", v), s.bind(l, "mousemove", p), s.bind(l, "mouseup", S), e.on("remove", () => {
        s.unbind(l, "mousemove", p), s.unbind(l, "mouseup", S);
      }), e.on("keydown", (O) => {
        O.keyCode === Xt.ESC && PM(n, e, Y.none());
      });
    }, RQ = (e) => {
      const n = (d) => {
        if (!d.isDefaultPrevented()) {
          const p = d.dataTransfer;
          p && (At(p.types, "Files") || p.files.length > 0) && (d.preventDefault(), d.type === "drop" && QT(e, "Dropped file type is not supported"));
        }
      }, s = (d) => {
        LE(e, d.target) && n(d);
      }, l = () => {
        const d = Js.DOM, p = e.dom, v = document, S = e.inline ? e.getBody() : e.getDoc(), O = [
          "drop",
          "dragover"
        ];
        Ue(O, (M) => {
          d.bind(v, M, s), p.bind(S, M, n);
        }), e.on("remove", () => {
          Ue(O, (M) => {
            d.unbind(v, M, s), p.unbind(S, M, n);
          });
        });
      };
      e.on("init", () => {
        Td.setEditorTimeout(e, l, 0);
      });
    }, NQ = (e) => {
      DQ(e), L_(e) && RQ(e);
    }, rz = (e) => {
      const n = Lv(() => {
        if (!e.removed && e.getBody().contains(document.activeElement)) {
          const s = e.selection.getRng();
          if (s.collapsed) {
            const l = rO(e, s, !1);
            e.selection.setRng(l);
          }
        }
      }, 0);
      e.on("focus", () => {
        n.throttle();
      }), e.on("blur", () => {
        n.cancel();
      });
    }, lA = (e) => {
      e.on("init", () => {
        e.on("focusin", (n) => {
          const s = n.target;
          if (Yi(s)) {
            const l = _g(e.getBody(), s), d = Vr(l) ? l : s;
            e.selection.getNode() !== d && Ox(e, d).each((p) => e.selection.setRng(p));
          }
        });
      });
    }, qx = Vr, DM = (e, n) => _g(e.getBody(), n), MQ = (e) => {
      const n = e.selection, s = e.dom, l = e.getBody(), d = X_(e, l, s.isBlock, () => S1(e)), p = "sel-" + s.uniqueId(), v = "data-mce-selected";
      let S;
      const O = (Dn) => je(Dn) && s.hasClass(Dn, "mce-offscreen-selection"), M = (Dn) => Dn !== l && (qx(Dn) || Yi(Dn)) && s.isChildOf(Dn, l) && s.isEditable(Dn.parentNode), j = (Dn) => {
        Dn && n.setRng(Dn);
      }, U = (Dn, Tt, yt, Lt = !0) => e.dispatch("ShowCaret", {
        target: Tt,
        direction: Dn,
        before: yt
      }).isDefaultPrevented() ? null : (Lt && n.scrollIntoView(Tt, Dn === -1), d.show(yt, Tt)), Z = (Dn) => {
        Dn.hasAttribute("data-mce-caret") && (Rr(Dn), n.scrollIntoView(Dn));
      }, de = () => {
        e.on("click", (Tt) => {
          s.isEditable(Tt.target) || (Tt.preventDefault(), e.focus());
        }), e.on("blur NewBlock", ut), e.on("ResizeWindow FullscreenStateChanged", d.reposition), e.on("tap", (Tt) => {
          const yt = Tt.target, Lt = DM(e, yt);
          qx(Lt) ? (Tt.preventDefault(), Ox(e, Lt).each(We)) : M(yt) && Ox(e, yt).each(We);
        }, !0), e.on("mousedown", (Tt) => {
          const yt = Tt.target;
          if (yt !== l && yt.nodeName !== "HTML" && !s.isChildOf(yt, l) || !dG(e, Tt.clientX, Tt.clientY))
            return;
          ut(), an();
          const Lt = DM(e, yt);
          qx(Lt) ? (Tt.preventDefault(), Ox(e, Lt).each(We)) : VH(l, Tt.clientX, Tt.clientY).each((Vn) => {
            Tt.preventDefault();
            const co = U(1, Vn.node, Vn.position === t0.Before, !1);
            j(co), kc(Lt) ? Lt.focus() : e.getBody().focus();
          });
        }), e.on("keypress", (Tt) => {
          Xt.modifierPressed(Tt) || qx(n.getNode()) && Tt.preventDefault();
        }), e.on("GetSelectionRange", (Tt) => {
          let yt = Tt.range;
          if (S) {
            if (!S.parentNode) {
              S = null;
              return;
            }
            yt = yt.cloneRange(), yt.selectNode(S), Tt.range = yt;
          }
        }), e.on("SetSelectionRange", (Tt) => {
          Tt.range = Se(Tt.range);
          const yt = We(Tt.range, Tt.forward);
          yt && (Tt.range = yt);
        });
        const Dn = (Tt) => On(Tt) && Tt.id === "mcepastebin";
        e.on("AfterSetSelectionRange", (Tt) => {
          const yt = Tt.range, Lt = yt.startContainer.parentElement;
          !me(yt) && !Dn(Lt) && an(), O(Lt) || ut();
        }), NQ(e), rz(e), lA(e);
      }, we = (Dn) => Yc(Dn) || tg(Dn) || Uf(Dn), me = (Dn) => we(Dn.startContainer) || we(Dn.endContainer), Se = (Dn) => {
        const Tt = e.schema.getVoidElements(), yt = s.createRng(), Lt = Dn.startContainer, Vn = Dn.startOffset, co = Dn.endContainer, Xo = Dn.endOffset;
        return Xn(Tt, Lt.nodeName.toLowerCase()) ? Vn === 0 ? yt.setStartBefore(Lt) : yt.setStartAfter(Lt) : yt.setStart(Lt, Vn), Xn(Tt, co.nodeName.toLowerCase()) ? Xo === 0 ? yt.setEndBefore(co) : yt.setEndAfter(co) : yt.setEnd(co, Xo), yt;
      }, ze = (Dn, Tt) => {
        const yt = Me.fromDom(e.getBody()), Lt = e.getDoc(), Vn = no(yt, "#" + p).getOrThunk(() => {
          const Sr = Me.fromHtml('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>', Lt);
          return ur(Sr, "id", p), Ys(yt, Sr), Sr;
        }), co = s.createRng();
        Lc(Vn), pd(Vn, [
          Me.fromText(Xa, Lt),
          Me.fromDom(Tt),
          Me.fromText(Xa, Lt)
        ]), co.setStart(Vn.dom.firstChild, 1), co.setEnd(Vn.dom.lastChild, 0), zo(Vn, { top: s.getPos(Dn, e.getBody()).y + "px" }), tx(Vn);
        const Xo = n.getSel();
        return Xo && (Xo.removeAllRanges(), Xo.addRange(co)), co;
      }, Ye = (Dn) => {
        const Tt = Dn.cloneNode(!0), yt = e.dispatch("ObjectSelected", {
          target: Dn,
          targetClone: Tt
        });
        if (yt.isDefaultPrevented())
          return null;
        const Lt = ze(Dn, yt.targetClone), Vn = Me.fromDom(Dn);
        return Ue(ba(Me.fromDom(e.getBody()), `*[${v}]`), (co) => {
          zr(Vn, co) || oa(co, v);
        }), s.getAttrib(Dn, v) || Dn.setAttribute(v, "1"), S = Dn, an(), Lt;
      }, We = (Dn, Tt) => {
        if (!Dn)
          return null;
        if (Dn.collapsed) {
          if (!me(Dn)) {
            const co = Tt ? 1 : -1, Xo = dg(co, l, Dn), Sr = Xo.getNode(!Tt);
            if (je(Sr)) {
              if (Mm(Sr))
                return U(co, Sr, Tt ? !Xo.isAtEnd() : !1, !1);
              if (af(Sr) && Vr(Sr.nextSibling)) {
                const Cs = s.createRng();
                return Cs.setStart(Sr, 0), Cs.setEnd(Sr, 0), Cs;
              }
            }
            const ts = Xo.getNode(Tt);
            if (je(ts)) {
              if (Mm(ts))
                return U(co, ts, Tt ? !1 : !Xo.isAtEnd(), !1);
              if (af(ts) && Vr(ts.previousSibling)) {
                const Cs = s.createRng();
                return Cs.setStart(ts, 1), Cs.setEnd(ts, 1), Cs;
              }
            }
          }
          return null;
        }
        let yt = Dn.startContainer, Lt = Dn.startOffset;
        const Vn = Dn.endOffset;
        if (Zt(yt) && Lt === 0 && qx(yt.parentNode) && (yt = yt.parentNode, Lt = s.nodeIndex(yt), yt = yt.parentNode), !On(yt))
          return null;
        if (Vn === Lt + 1 && yt === Dn.endContainer) {
          const co = yt.childNodes[Lt];
          if (M(co))
            return Ye(co);
        }
        return null;
      }, ut = () => {
        S && S.removeAttribute(v), no(Me.fromDom(e.getBody()), "#" + p).each(ys), S = null;
      }, zt = () => {
        d.destroy(), S = null;
      }, an = () => {
        d.hide();
      };
      return sh(e) || de(), {
        showCaret: U,
        showBlockCaretContainer: Z,
        hideFakeCaret: an,
        destroy: zt
      };
    }, IQ = (e, n) => {
      let s = n;
      for (let l = e.previousSibling; Zt(l); l = l.previousSibling)
        s += l.data.length;
      return s;
    }, RM = (e, n, s, l, d) => {
      if (Zt(s) && (l < 0 || l > s.data.length))
        return [];
      const p = d && Zt(s) ? [IQ(s, l)] : [l];
      let v = s;
      for (; v !== n && v.parentNode; )
        p.push(e.nodeIndex(v, d)), v = v.parentNode;
      return v === n ? p.reverse() : [];
    }, NM = (e, n, s, l, d, p, v = !1) => {
      const S = RM(e, n, s, l, v), O = RM(e, n, d, p, v);
      return {
        start: S,
        end: O
      };
    }, sz = (e, n) => {
      const s = n.slice(), l = s.pop();
      return dn(l) ? Ct(s, (p, v) => p.bind((S) => Y.from(S.childNodes[v])), Y.some(e)).bind((p) => Zt(p) && (l < 0 || l > p.data.length) ? Y.none() : Y.some({
        node: p,
        offset: l
      })) : Y.none();
    }, az = (e, n) => sz(e, n.start).bind(({
      node: s,
      offset: l
    }) => sz(e, n.end).map(({
      node: d,
      offset: p
    }) => {
      const v = document.createRange();
      return v.setStart(s, l), v.setEnd(d, p), v;
    })), MM = (e, n, s, l = !1) => NM(e, n, s.startContainer, s.startOffset, s.endContainer, s.endOffset, l), Kx = (e, n, s) => {
      if (n && e.isEmpty(n) && !s(n)) {
        const l = n.parentNode;
        e.remove(n, Zt(n.firstChild) && zc(n.firstChild.data)), Kx(e, l, s);
      }
    }, cA = (e, n, s, l = !0) => {
      const d = n.startContainer.parentNode, p = n.endContainer.parentNode;
      n.deleteContents(), l && !s(n.startContainer) && (Zt(n.startContainer) && n.startContainer.data.length === 0 && e.remove(n.startContainer), Zt(n.endContainer) && n.endContainer.data.length === 0 && e.remove(n.endContainer), Kx(e, d, s), d !== p && Kx(e, p, s));
    }, uA = (e, n) => Y.from(e.dom.getParent(n.startContainer, e.dom.isBlock)), IM = (e, n, s) => {
      const l = e.dynamicPatternsLookup({
        text: s,
        block: n
      });
      return {
        ...e,
        blockPatterns: Ip(l).concat(e.blockPatterns),
        inlinePatterns: Ji(l).concat(e.inlinePatterns)
      };
    }, FM = (e, n, s, l) => {
      const d = e.createRng();
      return d.setStart(n, 0), d.setEnd(s, l), d.toString();
    }, iz = (e, n) => e.create("span", {
      "data-mce-type": "bookmark",
      id: n
    }), QS = (e, n) => {
      const s = e.createRng();
      return s.setStartAfter(n.start), s.setEndBefore(n.end), s;
    }, BM = (e, n, s) => {
      const l = az(e.getRoot(), s).getOrDie("Unable to resolve path range"), d = l.startContainer, p = l.endContainer, v = l.endOffset === 0 ? p : p.splitText(l.endOffset), S = l.startOffset === 0 ? d : d.splitText(l.startOffset), O = S.parentNode, M = v.parentNode;
      return {
        prefix: n,
        end: M.insertBefore(iz(e, n + "-end"), v),
        start: O.insertBefore(iz(e, n + "-start"), S)
      };
    }, dA = (e, n, s) => {
      Kx(e, e.get(n.prefix + "-end"), s), Kx(e, e.get(n.prefix + "-start"), s);
    }, JS = (e) => e.start.length === 0, FQ = (e) => (n, s) => {
      const d = n.data.substring(0, s), p = d.lastIndexOf(e.charAt(e.length - 1)), v = d.lastIndexOf(e);
      return v !== -1 ? v + e.length : p !== -1 ? p + 1 : -1;
    }, fA = (e, n, s, l) => {
      const d = n.start;
      return FN(e, l.container, l.offset, FQ(d), s).bind((v) => {
        var S, O;
        const M = (O = (S = s.textContent) === null || S === void 0 ? void 0 : S.indexOf(d)) !== null && O !== void 0 ? O : -1;
        if (M !== -1 && v.offset >= M + d.length) {
          const U = e.createRng();
          return U.setStart(v.container, v.offset - d.length), U.setEnd(v.container, v.offset), Y.some(U);
        } else {
          const U = v.offset - d.length;
          return DS(v.container, U, s).map((Z) => {
            const de = e.createRng();
            return de.setStart(Z.container, Z.offset), de.setEnd(v.container, v.offset), de;
          }).filter((Z) => Z.toString() === d).orThunk(() => fA(e, n, s, Ym(v.container, 0)));
        }
      });
    }, BQ = (e, n, s, l, d, p = !1) => {
      if (n.start.length === 0 && !p) {
        const v = e.createRng();
        return v.setStart(s, l), v.setEnd(s, l), Y.some(v);
      }
      return IN(s, l, d).bind((v) => fA(e, n, d, v).bind((O) => {
        var M;
        if (p) {
          if (O.endContainer === v.container && O.endOffset === v.offset)
            return Y.none();
          if (v.offset === 0 && ((M = O.endContainer.textContent) === null || M === void 0 ? void 0 : M.length) === O.endOffset)
            return Y.none();
        }
        return Y.some(O);
      }));
    }, $Q = (e, n, s, l) => {
      const d = e.dom, p = d.getRoot(), v = s.pattern, S = s.position.container, O = s.position.offset;
      return DS(S, O - s.pattern.end.length, n).bind((M) => {
        const j = NM(d, p, M.container, M.offset, S, O, l);
        if (JS(v))
          return Y.some({
            matches: [{
              pattern: v,
              startRng: j,
              endRng: j
            }],
            position: M
          });
        {
          const U = ek(e, s.remainingPatterns, M.container, M.offset, n, l), Z = U.getOr({
            matches: [],
            position: M
          }), de = Z.position;
          return BQ(d, v, de.container, de.offset, n, U.isNone()).map((me) => {
            const Se = MM(d, p, me, l);
            return {
              matches: Z.matches.concat([{
                pattern: v,
                startRng: Se,
                endRng: j
              }]),
              position: Ym(me.startContainer, me.startOffset)
            };
          });
        }
      });
    }, ek = (e, n, s, l, d, p) => {
      const v = e.dom;
      return IN(s, l, v.getRoot()).bind((S) => {
        const O = FM(v, d, s, l);
        for (let M = 0; M < n.length; M++) {
          const j = n[M];
          if (!rr(O, j.end))
            continue;
          const U = n.slice();
          U.splice(M, 1);
          const Z = $Q(e, d, {
            pattern: j,
            remainingPatterns: U,
            position: S
          }, p);
          if (Z.isNone() && l > 0)
            return ek(e, n, s, l - 1, d, p);
          if (Z.isSome())
            return Z;
        }
        return Y.none();
      });
    }, lz = (e, n, s) => {
      e.selection.setRng(s), n.type === "inline-format" ? Ue(n.format, (l) => {
        e.formatter.apply(l);
      }) : e.execCommand(n.cmd, !1, n.value);
    }, LQ = (e, n, s, l) => {
      const d = QS(e.dom, s);
      cA(e.dom, d, l), lz(e, n, d);
    }, HQ = (e, n, s, l, d) => {
      const p = e.dom, v = QS(p, l), S = QS(p, s);
      cA(p, S, d), cA(p, v, d);
      const O = {
        prefix: s.prefix,
        start: s.end,
        end: l.start
      }, M = QS(p, O);
      lz(e, n, M);
    }, zQ = (e, n) => {
      const s = mb("mce_textpattern"), l = Vt(n, (d, p) => {
        const v = BM(e, s + `_end${d.length}`, p.endRng);
        return d.concat([{
          ...p,
          endMarker: v
        }]);
      }, []);
      return Vt(l, (d, p) => {
        const v = l.length - d.length - 1, S = JS(p.pattern) ? p.endMarker : BM(e, s + `_start${v}`, p.startRng);
        return d.concat([{
          ...p,
          startMarker: S
        }]);
      }, []);
    }, VQ = (e) => kt(e, (n, s) => s.end.length - n.end.length), jQ = (e, n) => {
      const s = Ko(e, (l) => $n(n, (d) => l.pattern.start === d.pattern.start && l.pattern.end === d.pattern.end));
      return e.length === n.length ? s ? e : n : e.length > n.length ? e : n;
    }, cz = (e, n, s, l, d, p) => {
      const v = ek(e, d.inlinePatterns, s, l, n, p).fold(() => [], (O) => O.matches), S = ek(e, VQ(d.inlinePatterns), s, l, n, p).fold(() => [], (O) => O.matches);
      return jQ(v, S);
    }, $M = (e, n) => {
      if (n.length === 0)
        return;
      const s = e.dom, l = e.selection.getBookmark(), d = zQ(s, n);
      Ue(d, (p) => {
        const v = s.getParent(p.startMarker.start, s.isBlock), S = (O) => O === v;
        JS(p.pattern) ? LQ(e, p.pattern, p.endMarker, S) : HQ(e, p.pattern, p.startMarker, p.endMarker, S), dA(s, p.endMarker, S), dA(s, p.startMarker, S);
      }), e.selection.moveToBookmark(l);
    }, uz = (e, n, s) => OK(n, 0, n).map((l) => {
      const d = l.container;
      return H8(d, s.start.length, n).each((p) => {
        const v = e.createRng();
        v.setStart(d, 0), v.setEnd(p.container, p.offset), cA(e, v, (S) => S === n);
      }), d;
    }), mA = (e) => (n, s) => {
      const l = n.dom, d = s.pattern, p = az(l.getRoot(), s.range).getOrDie("Unable to resolve path range"), v = (S, O) => {
        const M = O.get(S);
        return Xe(M) && pn(M).exists((j) => Xn(j, "block"));
      };
      return uA(n, p).each((S) => {
        d.type === "block-format" ? v(d.format, n.formatter) && n.undoManager.transact(() => {
          e(n.dom, S, d), n.formatter.apply(d.format);
        }) : d.type === "block-command" && n.undoManager.transact(() => {
          e(n.dom, S, d), n.execCommand(d.cmd, !1, d.value);
        });
      }), !0;
    }, UQ = (e) => kt(e, (n, s) => s.start.length - n.start.length), dz = (e) => (n, s) => {
      const l = UQ(n), d = s.replace(Xa, " ");
      return Pn(l, (p) => e(p, s, d));
    }, fz = (e, n) => (s, l, d, p, v) => {
      var S;
      v === void 0 && (v = (S = l.textContent) !== null && S !== void 0 ? S : "");
      const O = s.dom, M = Pl(s);
      return O.is(l, M) ? e(d.blockPatterns, v).map((j) => n && Gt.trim(v).length === j.start.length ? [] : [{
        pattern: j,
        range: NM(O, O.getRoot(), l, 0, l, 0, p)
      }]).getOr([]) : [];
    }, WQ = (e) => /^\s[^\s]/.test(e), ZQ = mA((e, n, s) => {
      uz(e, n, s).each((l) => {
        const d = Me.fromDom(l), p = Hv(d);
        WQ(p) && Z0(d, p.slice(1));
      });
    }), pA = dz((e, n, s) => n.indexOf(e.start) === 0 || s.indexOf(e.start) === 0), GQ = fz(pA, !0), qQ = (e, n) => {
      const s = e.selection.getRng();
      return uA(e, s).map((l) => {
        var d;
        const p = Math.max(0, s.startOffset), v = IM(n, l, (d = l.textContent) !== null && d !== void 0 ? d : ""), S = cz(e, l, s.startContainer, p, v, !0), O = GQ(e, l, v, !0);
        return {
          inlineMatches: S,
          blockMatches: O
        };
      }).filter(({ inlineMatches: l, blockMatches: d }) => d.length > 0 || l.length > 0);
    }, KQ = (e, n) => {
      if (n.length === 0)
        return;
      const s = e.selection.getBookmark();
      Ue(n, (l) => ZQ(e, l)), e.selection.moveToBookmark(s);
    }, YQ = mA(uz), XQ = dz((e, n, s) => n === e.start || s === e.start), QQ = fz(XQ, !1), JQ = (e, n) => {
      const s = e.selection.getRng();
      return uA(e, s).map((l) => {
        const d = Math.max(0, s.startOffset), p = FM(e.dom, l, s.startContainer, d), v = IM(n, l, p);
        return QQ(e, l, v, !1, p);
      }).filter((l) => l.length > 0);
    }, eJ = (e, n) => {
      Ue(n, (s) => YQ(e, s));
    }, tJ = (e, n) => qQ(e, n).fold(tt, ({ inlineMatches: s, blockMatches: l }) => (e.undoManager.add(), e.undoManager.extra(() => {
      e.execCommand("mceInsertNewLine");
    }, () => {
      fF(e), $M(e, s), KQ(e, l);
      const d = e.selection.getRng(), p = IN(d.startContainer, d.startOffset, e.dom.getRoot());
      e.execCommand("mceInsertNewLine"), p.each((v) => {
        const S = v.container;
        S.data.charAt(v.offset - 1) === Jg && (S.deleteData(v.offset - 1, 1), Kx(e.dom, S.parentNode, (O) => O === e.dom.getRoot()));
      });
    }), !0)), mz = (e, n) => {
      const s = e.selection.getRng();
      uA(e, s).map((l) => {
        const d = Math.max(0, s.startOffset - 1), p = FM(e.dom, l, s.startContainer, d), v = IM(n, l, p), S = cz(e, l, s.startContainer, d, v, !1);
        S.length > 0 && e.undoManager.transact(() => {
          $M(e, S);
        });
      });
    }, nJ = (e, n) => JQ(e, n).fold(tt, (s) => (e.undoManager.transact(() => {
      eJ(e, s);
    }), !0)), LM = (e, n, s) => {
      for (let l = 0; l < e.length; l++)
        if (s(e[l], n))
          return !0;
      return !1;
    }, oJ = (e, n) => LM(e, n, (s, l) => s === l.keyCode && !Xt.modifierPressed(l)), rJ = (e, n) => LM(e, n, (s, l) => s.charCodeAt(0) === l.charCode), pz = (e) => {
      const n = [
        ",",
        ".",
        ";",
        ":",
        "!",
        "?"
      ], s = [32], l = () => Fp(G_(e), z4(e)), d = () => zp(e);
      e.on("keydown", (v) => {
        if (v.keyCode === 13 && !Xt.modifierPressed(v) && e.selection.isCollapsed()) {
          const S = y2(l(), "enter");
          (S.inlinePatterns.length > 0 || S.blockPatterns.length > 0 || d()) && tJ(e, S) && v.preventDefault();
        }
      }, !0), e.on("keydown", (v) => {
        if (v.keyCode === 32 && e.selection.isCollapsed()) {
          const S = y2(l(), "space");
          (S.blockPatterns.length > 0 || d()) && nJ(e, S) && v.preventDefault();
        }
      }, !0);
      const p = () => {
        if (e.selection.isCollapsed()) {
          const v = y2(l(), "space");
          (v.inlinePatterns.length > 0 || d()) && mz(e, v);
        }
      };
      e.on("keyup", (v) => {
        oJ(s, v) && p();
      }), e.on("keypress", (v) => {
        rJ(n, v) && Td.setEditorTimeout(e, p);
      });
    }, tk = (e) => {
      pz(e);
    }, sJ = (e) => {
      const n = Gt.each, s = Xt.BACKSPACE, l = Xt.DELETE, d = e.dom, p = e.selection, v = e.parser, S = rn.browser, O = S.isFirefox(), M = S.isChromium() || S.isSafari(), j = rn.deviceType.isiPhone() || rn.deviceType.isiPad(), U = rn.os.isMacOS() || rn.os.isiOS(), Z = (Sn, yo) => {
        try {
          e.getDoc().execCommand(Sn, !1, String(yo));
        } catch {
        }
      }, de = (Sn) => Sn.isDefaultPrevented(), we = () => {
        const Sn = (fr) => {
          const An = d.create("body"), mr = fr.cloneContents();
          return An.appendChild(mr), p.serializer.serialize(An, { format: "html" });
        }, yo = (fr) => {
          const An = Sn(fr), mr = d.createRng();
          mr.selectNode(e.getBody());
          const _r = Sn(mr);
          return An === _r;
        };
        e.on("keydown", (fr) => {
          const An = fr.keyCode;
          if (!de(fr) && (An === l || An === s) && e.selection.isEditable()) {
            const mr = e.selection.isCollapsed(), _r = e.getBody();
            if (mr && !$u(e.schema, _r) || !mr && !yo(e.selection.getRng()))
              return;
            fr.preventDefault(), e.setContent(""), _r.firstChild && d.isBlock(_r.firstChild) ? e.selection.setCursorLocation(_r.firstChild, 0) : e.selection.setCursorLocation(_r, 0), e.nodeChanged();
          }
        });
      }, me = () => {
        e.shortcuts.add("meta+a", null, "SelectAll");
      }, Se = () => {
        e.inline || d.bind(e.getDoc(), "mousedown mouseup", (Sn) => {
          let yo;
          if (Sn.target === e.getDoc().documentElement)
            if (yo = p.getRng(), e.getBody().focus(), Sn.type === "mousedown") {
              if (Yc(yo.startContainer))
                return;
              p.placeCaretAt(Sn.clientX, Sn.clientY);
            } else
              p.setRng(yo);
        });
      }, ze = () => {
        e.on("keydown", (Sn) => {
          if (!de(Sn) && Sn.keyCode === s) {
            if (!e.getBody().getElementsByTagName("hr").length)
              return;
            if (p.isCollapsed() && p.getRng().startOffset === 0) {
              const yo = p.getNode(), fr = yo.previousSibling;
              if (yo.nodeName === "HR") {
                d.remove(yo), Sn.preventDefault();
                return;
              }
              fr && fr.nodeName && fr.nodeName.toLowerCase() === "hr" && (d.remove(fr), Sn.preventDefault());
            }
          }
        });
      }, Ye = () => {
        Range.prototype.getClientRects || e.on("mousedown", (Sn) => {
          if (!de(Sn) && Sn.target.nodeName === "HTML") {
            const yo = e.getBody();
            yo.blur(), Td.setEditorTimeout(e, () => {
              yo.focus();
            });
          }
        });
      }, We = () => {
        const Sn = I2(e);
        e.on("click", (yo) => {
          const fr = yo.target;
          /^(IMG|HR)$/.test(fr.nodeName) && d.isEditable(fr) && (yo.preventDefault(), e.selection.select(fr), e.nodeChanged()), fr.nodeName === "A" && d.hasClass(fr, Sn) && fr.childNodes.length === 0 && d.isEditable(fr.parentNode) && (yo.preventDefault(), p.select(fr));
        });
      }, ut = () => {
        const Sn = () => {
          const fr = d.getAttribs(p.getStart().cloneNode(!1));
          return () => {
            const An = p.getStart();
            An !== e.getBody() && (d.setAttrib(An, "style", null), n(fr, (mr) => {
              An.setAttributeNode(mr.cloneNode(!0));
            }));
          };
        }, yo = () => !p.isCollapsed() && d.getParent(p.getStart(), d.isBlock) !== d.getParent(p.getEnd(), d.isBlock);
        e.on("keypress", (fr) => {
          let An;
          return !de(fr) && (fr.keyCode === 8 || fr.keyCode === 46) && yo() ? (An = Sn(), e.getDoc().execCommand("delete", !1), An(), fr.preventDefault(), !1) : !0;
        }), d.bind(e.getDoc(), "cut", (fr) => {
          if (!de(fr) && yo()) {
            const An = Sn();
            Td.setEditorTimeout(e, () => {
              An();
            });
          }
        });
      }, zt = () => {
        e.on("keydown", (Sn) => {
          if (!de(Sn) && Sn.keyCode === s && p.isCollapsed() && p.getRng().startOffset === 0) {
            const yo = p.getNode().previousSibling;
            if (yo && yo.nodeName && yo.nodeName.toLowerCase() === "table")
              return Sn.preventDefault(), !1;
          }
          return !0;
        });
      }, an = () => {
        e.on("keydown", (Sn) => {
          if (de(Sn) || Sn.keyCode !== Xt.BACKSPACE)
            return;
          let yo = p.getRng();
          const fr = yo.startContainer, An = yo.startOffset, mr = d.getRoot();
          let _r = fr;
          if (!(!yo.collapsed || An !== 0)) {
            for (; _r.parentNode && _r.parentNode.firstChild === _r && _r.parentNode !== mr; )
              _r = _r.parentNode;
            _r.nodeName === "BLOCKQUOTE" && (e.formatter.toggle("blockquote", void 0, _r), yo = d.createRng(), yo.setStart(fr, 0), yo.setEnd(fr, 0), p.setRng(yo));
          }
        });
      }, Dn = () => {
        const Sn = () => {
          Z("StyleWithCSS", !1), Z("enableInlineTableEditing", !1), mu(e) || Z("enableObjectResizing", !1);
        };
        B_(e) || e.on("BeforeExecCommand mousedown", Sn);
      }, Tt = () => {
        const Sn = () => {
          n(d.select("a:not([data-mce-block])"), (yo) => {
            var fr;
            let An = yo.parentNode;
            const mr = d.getRoot();
            if ((An == null ? void 0 : An.lastChild) === yo) {
              for (; An && !d.isBlock(An); ) {
                if (((fr = An.parentNode) === null || fr === void 0 ? void 0 : fr.lastChild) !== An || An === mr)
                  return;
                An = An.parentNode;
              }
              d.add(An, "br", { "data-mce-bogus": 1 });
            }
          });
        };
        e.on("SetContent ExecCommand", (yo) => {
          (yo.type === "setcontent" || yo.command === "mceInsertLink") && Sn();
        });
      }, yt = () => {
        e.on("init", () => {
          Z("DefaultParagraphSeparator", Pl(e));
        });
      }, Lt = (Sn) => {
        const yo = Sn.getBody(), fr = Sn.selection.getRng();
        return fr.startContainer === fr.endContainer && fr.startContainer === yo && fr.startOffset === 0 && fr.endOffset === yo.childNodes.length;
      }, Vn = () => {
        e.on("keyup focusin mouseup", (Sn) => {
          !Xt.modifierPressed(Sn) && !Lt(e) && p.normalize();
        }, !0);
      }, co = () => {
        e.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}");
      }, Xo = () => {
        e.inline || e.on("keydown", () => {
          document.activeElement === document.body && e.getWin().focus();
        });
      }, Sr = () => {
        e.inline || (e.contentStyles.push("body {min-height: 150px}"), e.on("click", (Sn) => {
          let yo;
          Sn.target.nodeName === "HTML" && (yo = e.selection.getRng(), e.getBody().focus(), e.selection.setRng(yo), e.selection.normalize(), e.nodeChanged());
        }));
      }, ts = () => {
        U && e.on("keydown", (Sn) => {
          Xt.metaKeyPressed(Sn) && !Sn.shiftKey && (Sn.keyCode === 37 || Sn.keyCode === 39) && (Sn.preventDefault(), e.selection.getSel().modify("move", Sn.keyCode === 37 ? "backward" : "forward", "lineboundary"));
        });
      }, Cs = () => {
        e.on("click", (Sn) => {
          let yo = Sn.target;
          do
            if (yo.tagName === "A") {
              Sn.preventDefault();
              return;
            }
          while (yo = yo.parentNode);
        }), e.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}");
      }, Pa = () => {
        e.on("init", () => {
          e.dom.bind(e.getBody(), "submit", (Sn) => {
            Sn.preventDefault();
          });
        });
      }, yl = () => {
        v.addNodeFilter("br", (Sn) => {
          let yo = Sn.length;
          for (; yo--; )
            Sn[yo].attr("class") === "Apple-interchange-newline" && Sn[yo].remove();
        });
      }, bs = qe, hn = () => {
        if (!O || e.removed)
          return !1;
        const Sn = e.selection.getSel();
        return !Sn || !Sn.rangeCount || Sn.rangeCount === 0;
      }, ro = () => {
        M && (Se(), We(), Pa(), me(), j && (Xo(), Sr(), Cs())), O && (Ye(), Dn(), co(), ts());
      }, Ur = () => {
        an(), we(), rn.windowsPhone || Vn(), M && (Se(), We(), yt(), Pa(), zt(), yl(), j ? (Xo(), Sr(), Cs()) : me()), O && (ze(), Ye(), ut(), Dn(), Tt(), co(), ts(), zt());
      };
      return sh(e) ? ro() : Ur(), {
        refreshContentEditable: bs,
        isHidden: hn
      };
    }, hz = (e) => e.toLowerCase() === "gpl", aJ = (e) => e.length >= 64 && e.length <= 255, iJ = (e) => hz(e) || aJ(e) ? "VALID" : "INVALID", lJ = (e) => {
      const n = r1(e);
      !G(H2(e)) && (ot(n) || iJ(n) === "INVALID") && console.warn("TinyMCE is running in evaluation mode. Provide a valid license key or add license_key: 'gpl' to the init config to agree to the open source license terms. Read more at https://www.tiny.cloud/license-key/");
    }, HM = Js.DOM, gz = (e, n) => {
      const s = Me.fromDom(e.getBody()), l = fp(Ql(s)), d = Me.fromTag("style");
      ur(d, "type", "text/css"), Ys(d, Me.fromText(n)), Ys(l, d), e.on("remove", () => {
        ys(d);
      });
    }, cJ = (e) => e.inline ? e.getElement().nodeName.toLowerCase() : void 0, hA = (e) => kr(e, (n) => ot(n) === !1), bz = (e) => {
      const n = e.options.get, s = e.editorUpload.blobCache;
      return hA({
        allow_conditional_comments: n("allow_conditional_comments"),
        allow_html_data_urls: n("allow_html_data_urls"),
        allow_svg_data_urls: n("allow_svg_data_urls"),
        allow_html_in_named_anchor: n("allow_html_in_named_anchor"),
        allow_script_urls: n("allow_script_urls"),
        allow_unsafe_link_target: n("allow_unsafe_link_target"),
        convert_unsafe_embeds: n("convert_unsafe_embeds"),
        convert_fonts_to_spans: n("convert_fonts_to_spans"),
        fix_list_elements: n("fix_list_elements"),
        font_size_legacy_values: n("font_size_legacy_values"),
        forced_root_block: n("forced_root_block"),
        forced_root_block_attrs: n("forced_root_block_attrs"),
        preserve_cdata: n("preserve_cdata"),
        inline_styles: n("inline_styles"),
        root_name: cJ(e),
        sandbox_iframes: n("sandbox_iframes"),
        sandbox_iframes_exclusions: wy(e),
        sanitize: n("xss_sanitization"),
        validate: !0,
        blob_cache: s,
        document: e.getDoc()
      });
    }, vz = (e) => {
      const n = e.options.get;
      return hA({
        custom_elements: n("custom_elements"),
        extended_valid_elements: n("extended_valid_elements"),
        invalid_elements: n("invalid_elements"),
        invalid_styles: n("invalid_styles"),
        schema: n("schema"),
        valid_children: n("valid_children"),
        valid_classes: n("valid_classes"),
        valid_elements: n("valid_elements"),
        valid_styles: n("valid_styles"),
        verify_html: n("verify_html"),
        padd_empty_block_inline_children: n("format_empty_lines")
      });
    }, uJ = (e) => {
      const n = e.options.get;
      return {
        ...bz(e),
        ...vz(e),
        ...hA({
          remove_trailing_brs: n("remove_trailing_brs"),
          pad_empty_with_br: n("pad_empty_with_br"),
          url_converter: n("url_converter"),
          url_converter_scope: n("url_converter_scope"),
          element_format: n("element_format"),
          entities: n("entities"),
          entity_encoding: n("entity_encoding"),
          indent: n("indent"),
          indent_after: n("indent_after"),
          indent_before: n("indent_before")
        })
      };
    }, dJ = (e) => {
      const n = oh(bz(e), e.schema);
      return n.addAttributeFilter("src,href,style,tabindex", (s, l) => {
        const d = e.dom, p = "data-mce-" + l;
        let v = s.length;
        for (; v--; ) {
          const S = s[v];
          let O = S.attr(l);
          if (O && !S.attr(p)) {
            if (O.indexOf("data:") === 0 || O.indexOf("blob:") === 0)
              continue;
            l === "style" ? (O = d.serializeStyle(d.parseStyle(O), S.name), O.length || (O = null), S.attr(p, O), S.attr(l, O)) : l === "tabindex" ? (S.attr(p, O), S.attr(l, null)) : S.attr(p, e.convertURL(O, l, S.name));
          }
        }
      }), n.addNodeFilter("script", (s) => {
        let l = s.length;
        for (; l--; ) {
          const d = s[l], p = d.attr("type") || "no/type";
          p.indexOf("mce-") !== 0 && d.attr("type", "mce-" + p);
        }
      }), by(e) && n.addNodeFilter("#cdata", (s) => {
        var l;
        let d = s.length;
        for (; d--; ) {
          const p = s[d];
          p.type = 8, p.name = "#comment", p.value = "[CDATA[" + e.dom.encode((l = p.value) !== null && l !== void 0 ? l : "") + "]]";
        }
      }), n.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", (s) => {
        let l = s.length;
        const d = e.schema.getNonEmptyElements();
        for (; l--; ) {
          const p = s[l];
          p.isEmpty(d) && p.getAll("br").length === 0 && p.append(new eu("br", 1));
        }
      }), n;
    }, fJ = (e) => {
      const n = py(e);
      n && Td.setEditorTimeout(e, () => {
        let s;
        n === !0 ? s = e : s = e.editorManager.get(n), s && !s.destroyed && (s.focus(), s.selection.scrollIntoView());
      }, 100);
    }, mJ = (e) => {
      const n = e.dom.getRoot();
      !e.inline && (!cC(e) || e.selection.getStart(!0) === n) && zl(n).each((s) => {
        const l = s.getNode(), d = Fu(l) ? zl(l).getOr(s) : s;
        e.selection.setRng(d.toRange());
      });
    }, pJ = (e) => {
      e.bindPendingEventDelegates(), e.initialized = !0, yP(e), e.focus(!0), mJ(e), e.nodeChanged({ initial: !0 });
      const n = $4(e);
      ye(n) && n.call(e, e), fJ(e);
    }, zM = (e) => e.inline ? e.ui.styleSheetLoader : e.dom.styleSheetLoader, hJ = (e, n, s) => {
      const {
        pass: l,
        fail: d
      } = mo(n, (S) => tinymce.Resource.has(IR(S))), v = [
        ...l.map((S) => {
          const O = tinymce.Resource.get(IR(S));
          return G(O) ? Promise.resolve(zM(e).loadRawCss(S, O)) : Promise.resolve();
        }),
        zM(e).loadAll(d)
      ];
      return e.inline ? v : v.concat([e.ui.styleSheetLoader.loadAll(s)]);
    }, VM = (e) => {
      const n = zM(e), s = Ac(e), l = e.contentCSS, d = () => {
        n.unloadAll(l), e.inline || e.ui.styleSheetLoader.unloadAll(s);
      }, p = () => {
        e.removed ? d() : e.on("remove", d);
      };
      if (e.contentStyles.length > 0) {
        let O = "";
        Gt.each(e.contentStyles, (M) => {
          O += M + `\r
`;
        }), e.dom.addStyle(O);
      }
      const v = Promise.all(hJ(e, l, s)).then(p).catch(p), S = N4(e);
      return S && gz(e, S), v;
    }, jM = (e) => {
      const n = e.getDoc(), s = e.getBody();
      CE(e), H_(e) || (n.body.spellcheck = !1, HM.setAttrib(s, "spellcheck", "false")), e.quirks = sJ(e), Gy(e);
      const l = pF(e);
      l !== void 0 && (s.dir = l);
      const d = B2(e);
      d && e.on("BeforeSetContent", (p) => {
        Gt.each(d, (v) => {
          p.content = p.content.replace(v, (S) => "<!--mce:protected " + escape(S) + "-->");
        });
      }), e.on("SetContent", () => {
        e.addVisual(e.getBody());
      }), e.on("compositionstart compositionend", (p) => {
        e.composing = p.type === "compositionstart";
      });
    }, yz = (e) => {
      sh(e) || e.load({
        initial: !0,
        format: "html"
      }), e.startContent = e.getContent({ format: "raw" });
    }, gA = (e) => {
      e.removed !== !0 && (yz(e), pJ(e));
    }, gJ = (e) => {
      let n = !1;
      const s = setTimeout(() => {
        n || e.setProgressState(!0);
      }, 500);
      return () => {
        clearTimeout(s), n = !0, e.setProgressState(!1);
      };
    }, xz = (e) => {
      const n = e.getElement();
      let s = e.getDoc();
      e.inline && (HM.addClass(n, "mce-content-body"), e.contentDocument = s = document, e.contentWindow = window, e.bodyElement = n, e.contentAreaContainer = n);
      const l = e.getBody();
      l.disabled = !0, e.readonly = B_(e), e._editableRoot = F4(e), !e.readonly && e.hasEditableRoot() && (e.inline && HM.getStyle(l, "position", !0) === "static" && (l.style.position = "relative"), l.contentEditable = "true"), l.disabled = !1, e.editorUpload = kG(e), e.schema = Hf(vz(e)), e.dom = Js(s, {
        keep_values: !0,
        url_converter: e.convertURL,
        url_converter_scope: e,
        update_styles: !0,
        root_element: e.inline ? e.getBody() : null,
        collect: e.inline,
        schema: e.schema,
        contentCssCors: D_(e),
        referrerPolicy: cy(e),
        onSetAttrib: (v) => {
          e.dispatch("SetAttrib", v);
        }
      }), e.parser = dJ(e), e.serializer = OR(uJ(e), e), e.selection = BL(e.dom, e.getWin(), e.serializer, e), e.annotator = Yf(e), e.formatter = o6(e), e.undoManager = zR(e), e._nodeChangeDispatcher = new uX(e), e._selectionOverrides = MQ(e), yO(e), sQ(e), Zq(e), sh(e) || (lQ(e), tk(e));
      const d = cX(e);
      Lq(e, d), jq(e), DG(e), nQ(e);
      const p = kL(e);
      jM(e), lJ(e), p.fold(() => {
        const v = gJ(e);
        VM(e).then(() => {
          gA(e), v();
        });
      }, (v) => {
        e.setProgressState(!0), VM(e).then(() => {
          v().then((S) => {
            e.setProgressState(!1), gA(e), ML(e);
          }, (S) => {
            e.notificationManager.open({
              type: "error",
              text: String(S)
            }), gA(e), ML(e);
          });
        });
      });
    }, bJ = mt, wz = (e, n, s) => Yg(e, n, bJ, s), bA = Js.DOM, vJ = (e, n, s, l) => {
      const d = Me.fromTag("iframe");
      return l.each((p) => ur(d, "tabindex", p)), _a(d, s), _a(d, {
        id: e + "_ifr",
        frameBorder: "0",
        allowTransparency: "true",
        title: n
      }), fd(d, "tox-edit-area__iframe"), d;
    }, yJ = (e) => {
      let n = A4(e) + "<html><head>";
      el(e) !== e.documentBaseUrl && (n += '<base href="' + e.documentBaseURI.getURI() + '" />'), n += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
      const s = P4(e), l = Bp(e), d = e.translate(F2(e));
      return _2(e) && (n += '<meta http-equiv="Content-Security-Policy" content="' + _2(e) + '" />'), n += `</head><body id="${s}" class="mce-content-body ${l}" data-id="${e.id}" aria-label="${d}"><br></body></html>`, n;
    }, UM = (e, n) => {
      const s = rn.browser.isFirefox() ? F2(e) : "Rich Text Area", l = e.translate(s), d = da(Me.fromDom(e.getElement()), "tabindex").bind(Ba), p = vJ(e.id, l, kd(e), d).dom;
      p.onload = () => {
        p.onload = null, e.dispatch("load");
      }, e.contentAreaContainer = n.iframeContainer, e.iframeElement = p, e.iframeHTML = yJ(e), bA.add(n.iframeContainer, p);
    }, vA = (e) => {
      const n = e.iframeElement, s = () => {
        e.contentDocument = n.contentDocument, xz(e);
      };
      if (cc(e) || rn.browser.isFirefox()) {
        const l = e.getDoc();
        l.open(), l.write(e.iframeHTML), l.close(), s();
      } else {
        const l = wz(Me.fromDom(n), "load", () => {
          l.unbind(), s();
        });
        n.srcdoc = e.iframeHTML;
      }
    }, yA = (e, n) => {
      UM(e, n), n.editorContainer && (n.editorContainer.style.display = e.orgDisplay, e.hidden = bA.isHidden(n.editorContainer)), e.getElement().style.display = "none", bA.setAttrib(e.id, "aria-hidden", "true"), e.getElement().style.visibility = e.orgVisibility, vA(e);
    }, fh = Js.DOM, xA = (e, n, s) => {
      const l = Cx.get(s), d = Cx.urls[s] || e.documentBaseUrl.replace(/\/$/, "");
      if (s = Gt.trim(s), l && Gt.inArray(n, s) === -1) {
        if (e.plugins[s])
          return;
        try {
          const p = l(e, d) || {};
          e.plugins[s] = p, ye(p.init) && (p.init(e, d), n.push(s));
        } catch (p) {
          MR(e, s, p);
        }
      }
    }, Yx = (e) => e.replace(/^\-/, ""), Cz = (e) => {
      const n = [];
      Ue(t1(e), (s) => {
        xA(e, n, Yx(s));
      });
    }, xJ = (e) => {
      const n = Gt.trim(Ci(e)), s = e.ui.registry.getAll().icons, l = {
        ...xx.get("default").icons,
        ...xx.get(n).icons
      };
      Ht(l, (d, p) => {
        Xn(s, p) || e.ui.registry.addIcon(p, d);
      });
    }, wJ = (e) => {
      const n = Hp(e);
      if (G(n)) {
        const s = Gm.get(n);
        e.theme = s(e, Gm.urls[n]) || {}, ye(e.theme.init) && e.theme.init(e, Gm.urls[n] || e.documentBaseUrl.replace(/\/$/, ""));
      } else
        e.theme = {};
    }, Sz = (e) => {
      const n = dy(e), s = wx.get(n);
      e.model = s(e, wx.urls[n]);
    }, CJ = (e) => {
      const n = e.theme.renderUI;
      return n ? n() : cv(e);
    }, WM = (e) => {
      const n = e.getElement(), l = Hp(e)(e, n);
      return l.editorContainer.nodeType && (l.editorContainer.id = l.editorContainer.id || e.id + "_parent"), l.iframeContainer && l.iframeContainer.nodeType && (l.iframeContainer.id = l.iframeContainer.id || e.id + "_iframecontainer"), l.height = l.iframeHeight ? l.iframeHeight : n.offsetHeight, l;
    }, nk = (e, n) => ({
      editorContainer: e,
      iframeContainer: n,
      api: {}
    }), lv = (e) => {
      const n = fh.create("div");
      return fh.insertAfter(n, e), nk(n, n);
    }, cv = (e) => {
      const n = e.getElement();
      return e.inline ? nk(null) : lv(n);
    }, kz = (e) => {
      const n = e.getElement();
      return e.orgDisplay = n.style.display, G(Hp(e)) ? CJ(e) : ye(Hp(e)) ? WM(e) : cv(e);
    }, SJ = (e, n) => {
      const s = {
        show: Y.from(n.show).getOr(qe),
        hide: Y.from(n.hide).getOr(qe),
        isEnabled: Y.from(n.isEnabled).getOr(mt),
        setEnabled: (l) => {
          e.mode.isReadOnly() || Y.from(n.setEnabled).each((d) => d(l));
        }
      };
      e.ui = {
        ...e.ui,
        ...s
      };
    }, kJ = async (e) => {
      e.dispatch("ScriptsLoaded"), xJ(e), wJ(e), Sz(e), Cz(e);
      const n = await kz(e);
      SJ(e, Y.from(n.api).getOr({})), e.editorContainer = n.editorContainer, wG(e), e.inline ? xz(e) : yA(e, {
        editorContainer: n.editorContainer,
        iframeContainer: n.iframeContainer
      });
    }, o0 = Js.DOM, _z = (e) => e.charAt(0) === "-", _J = (e, n) => {
      const s = uy(n), l = rg(n);
      if (!Ii.hasCode(s) && s !== "en") {
        const d = ko(l) ? l : `${n.editorManager.baseURL}/langs/${s}.js`;
        e.add(d).catch(() => {
          bG(n, d, s);
        });
      }
    }, EJ = (e, n) => {
      const s = Hp(e);
      if (G(s) && !_z(s) && !Xn(Gm.urls, s)) {
        const l = A2(e), d = l ? e.documentBaseURI.toAbsolute(l) : `themes/${s}/theme${n}.js`;
        Gm.load(s, d).catch(() => {
          Dae(e, d, s);
        });
      }
    }, Ez = (e, n) => {
      const s = dy(e);
      if (s !== "plugin" && !Xn(wx.urls, s)) {
        const l = R_(e), d = G(l) ? e.documentBaseURI.toAbsolute(l) : `models/${s}/model${n}.js`;
        wx.load(s, d).catch(() => {
          qm(e, d, s);
        });
      }
    }, TJ = (e) => Y.from(ti(e)).filter(ko).map((n) => ({
      url: n,
      name: Y.none()
    })), Tz = (e, n, s) => Y.from(n).filter((l) => ko(l) && !xx.has(l)).map((l) => ({
      url: `${e.editorManager.baseURL}/icons/${l}/icons${s}.js`,
      name: Y.some(l)
    })), OJ = (e, n, s) => {
      const l = Tz(n, "default", s), d = TJ(n).orThunk(() => Tz(n, Ci(n), ""));
      Ue(ks([
        l,
        d
      ]), (p) => {
        e.add(p.url).catch(() => {
          gG(n, p.url, p.name.getOrUndefined());
        });
      });
    }, tie = (e, n) => {
      const s = (l, d) => {
        Cx.load(l, d).catch(() => {
          hG(e, d, l);
        });
      };
      Ht(B4(e), (l, d) => {
        s(d, l), e.options.set("plugins", t1(e).concat(d));
      }), Ue(t1(e), (l) => {
        l = Gt.trim(l), l && !Cx.urls[l] && !_z(l) && s(l, `plugins/${l}/plugin${n}.js`);
      });
    }, AJ = (e) => {
      const n = Hp(e);
      return !G(n) || je(Gm.get(n));
    }, ZM = (e) => {
      const n = dy(e);
      return je(wx.get(n));
    }, PJ = (e, n) => {
      const s = of.ScriptLoader, l = () => {
        !e.removed && AJ(e) && ZM(e) && kJ(e);
      };
      EJ(e, n), Ez(e, n), _J(s, e), OJ(s, e, n), tie(e, n), s.loadQueue().then(l, l);
    }, DJ = (e, n) => Ja.forElement(e, {
      contentCssCors: $_(n),
      referrerPolicy: cy(n)
    }), Oz = (e) => {
      const n = e.id;
      Ii.setCode(uy(e));
      const s = () => {
        o0.unbind(window, "ready", s), e.render();
      };
      if (!Ap.Event.domLoaded) {
        o0.bind(window, "ready", s);
        return;
      }
      if (!e.getElement())
        return;
      const l = Me.fromDom(e.getElement()), d = wc(l);
      e.on("remove", () => {
        jn(l.dom.attributes, (v) => oa(l, v.name)), _a(l, d);
      }), e.ui.styleSheetLoader = DJ(l, e), ig(e) ? e.inline = !0 : (e.orgVisibility = e.getElement().style.visibility, e.getElement().style.visibility = "hidden");
      const p = e.getElement().form || o0.getParent(n, "form");
      p && (e.formElement = p, R2(e) && !ia(e.getElement()) && (o0.insertAfter(o0.create("input", {
        type: "hidden",
        name: n
      }), n), e.hasHiddenInput = !0), e.formEventDelegate = (v) => {
        e.dispatch(v.type, v);
      }, o0.bind(p, "submit reset", e.formEventDelegate), e.on("reset", () => {
        e.resetContent();
      }), N2(e) && !p.submit.nodeType && !p.submit.length && !p._mceOldSubmit && (p._mceOldSubmit = p.submit, p.submit = () => (e.editorManager.triggerSave(), e.setDirty(!1), p._mceOldSubmit(p)))), e.windowManager = NR(e), e.notificationManager = qL(e), jp(e) && e.on("GetContent", (v) => {
        v.save && (v.content = o0.encode(v.content));
      }), I_(e) && e.on("submit", () => {
        e.initialized && e.save();
      }), F_(e) && (e._beforeUnload = () => {
        e.initialized && !e.destroyed && !e.isHidden() && e.save({
          format: "raw",
          no_events: !0,
          set_dirty: !1
        });
      }, e.editorManager.on("BeforeUnload", e._beforeUnload)), e.editorManager.add(e), PJ(e, e.suffix);
    }, RJ = (e, n) => {
      e._editableRoot !== n && (e._editableRoot = n, e.readonly || (e.getBody().contentEditable = String(e.hasEditableRoot()), e.nodeChanged()), yC(e, n));
    }, Az = (e) => e._editableRoot, NJ = (e, n) => ({
      sections: dt(e),
      options: dt(n)
    }), wA = Yt().deviceType, Pz = wA.isPhone(), MJ = wA.isTablet(), ok = (e) => {
      if (Kt(e))
        return [];
      {
        const n = Xe(e) ? e : e.split(/[ ,]/), s = en(n, Wa);
        return xn(s, ko);
      }
    }, IJ = (e, n) => {
      const s = Ks(n, (l, d) => At(e, d));
      return NJ(s.t, s.f);
    }, Dz = (e, n, s = {}) => {
      const l = e.sections(), d = Or(l, n).getOr({});
      return Gt.extend({}, s, d);
    }, rk = (e, n) => Xn(e.sections(), n), Rz = (e, n) => rk(e, n) ? e.sections()[n] : {}, GM = (e, n) => ({
      ...{
        table_grid: !1,
        object_resizing: !1,
        resize: !1,
        toolbar_mode: Or(e, "toolbar_mode").getOr("scrolling"),
        toolbar_sticky: !1
      },
      ...n ? { menubar: !1 } : {}
    }), FJ = (e, n) => {
      var s;
      const l = (s = n.external_plugins) !== null && s !== void 0 ? s : {};
      return e && e.external_plugins ? Gt.extend({}, e.external_plugins, l) : l;
    }, nie = (e, n) => [
      ...ok(e),
      ...ok(n)
    ], oie = (e, n, s, l) => e && rk(n, "mobile") ? l : s, BJ = (e, n, s, l) => {
      const d = ok(s.forced_plugins), p = ok(l.plugins), v = Rz(n, "mobile"), S = v.plugins ? ok(v.plugins) : p, O = oie(e, n, p, S), M = nie(d, O);
      return Gt.extend(l, {
        forced_plugins: d,
        plugins: M
      });
    }, Nz = (e, n) => e && rk(n, "mobile"), $J = (e, n, s, l, d) => {
      var p;
      const v = e ? { mobile: GM((p = d.mobile) !== null && p !== void 0 ? p : {}, n) } : {}, S = IJ(["mobile"], BS(v, d)), O = Gt.extend(s, l, S.options(), Nz(e, S) ? Dz(S, "mobile") : {}, { external_plugins: FJ(l, S.options()) });
      return BJ(e, S, l, O);
    }, LJ = (e, n) => {
      const s = Y8(n);
      return $J(Pz || MJ, Pz, s, e, s);
    }, HJ = (e, n) => RZ(e, n), rie = (e) => {
      const n = (l, d) => {
        e.formatter.toggle(l, d), e.nodeChanged();
      }, s = (l) => () => {
        Ue("left,center,right,justify".split(","), (d) => {
          l !== d && e.formatter.remove("align" + d);
        }), l !== "none" && n("align" + l);
      };
      e.editorCommands.addCommands({
        JustifyLeft: s("left"),
        JustifyCenter: s("center"),
        JustifyRight: s("right"),
        JustifyFull: s("justify"),
        JustifyNone: s("none")
      });
    }, sie = (e) => {
      const n = (s) => () => {
        const l = e.selection, d = l.isCollapsed() ? [e.dom.getParent(l.getNode(), e.dom.isBlock)] : l.getSelectedBlocks();
        return $n(d, (p) => je(e.formatter.matchNode(p, s)));
      };
      e.editorCommands.addCommands({
        JustifyLeft: n("alignleft"),
        JustifyCenter: n("aligncenter"),
        JustifyRight: n("alignright"),
        JustifyFull: n("alignjustify")
      }, "state");
    }, Mz = (e) => {
      rie(e), sie(e);
    }, Iz = (e) => {
      e.editorCommands.addCommands({
        "Cut,Copy,Paste": (n) => {
          const s = e.getDoc();
          let l;
          try {
            s.execCommand(n);
          } catch {
            l = !0;
          }
          if (n === "paste" && !s.queryCommandEnabled(n) && (l = !0), l || !s.queryCommandSupported(n)) {
            let d = e.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.");
            (rn.os.isMacOS() || rn.os.isiOS()) && (d = d.replace(/Ctrl\+/g, "+")), e.notificationManager.open({
              text: d,
              type: "error"
            });
          }
        }
      });
    }, zJ = (e, n, s, l) => {
      const d = Me.fromDom(e.getRoot());
      return NC(d, vt.fromRangeStart(n), l) ? s = s.replace(/^ /, "&nbsp;") : s = s.replace(/^&nbsp;/, " "), MC(d, vt.fromRangeEnd(n), l) ? s = s.replace(/(&nbsp;| )(<br( \/)>)?$/, "&nbsp;") : s = s.replace(/&nbsp;(<br( \/)?>)?$/, " "), s;
    }, VJ = (e) => {
      if (typeof e != "string") {
        const n = Gt.extend({
          paste: e.paste,
          data: { paste: e.paste }
        }, e);
        return {
          content: e.content,
          details: n
        };
      }
      return {
        content: e,
        details: {}
      };
    }, jJ = (e, n) => {
      const s = e.selection, l = e.dom;
      return /^ | $/.test(n) ? zJ(l, s.getRng(), n, e.schema) : n;
    }, qM = (e, n) => {
      if (e.selection.isEditable()) {
        const { content: s, details: l } = VJ(n);
        pR(e, {
          ...l,
          content: jJ(e, s),
          format: "html",
          set: !1,
          selection: !0
        }).each((d) => {
          const p = NL(e, d.content, l);
          hR(e, p, d), e.addVisual();
        });
      }
    }, aie = (e) => {
      e.editorCommands.addCommands({
        mceCleanup: () => {
          const n = e.selection.getBookmark();
          e.setContent(e.getContent()), e.selection.moveToBookmark(n);
        },
        insertImage: (n, s, l) => {
          qM(e, e.dom.createHTML("img", { src: l }));
        },
        insertHorizontalRule: () => {
          e.execCommand("mceInsertContent", !1, "<hr>");
        },
        insertText: (n, s, l) => {
          qM(e, e.dom.encode(l));
        },
        insertHTML: (n, s, l) => {
          qM(e, l);
        },
        mceInsertContent: (n, s, l) => {
          qM(e, l);
        },
        mceSetContent: (n, s, l) => {
          e.setContent(l);
        },
        mceReplaceContent: (n, s, l) => {
          e.execCommand("mceInsertContent", !1, l.replace(/\{\$selection\}/g, e.selection.getContent({ format: "text" })));
        },
        mceNewDocument: () => {
          e.setContent(V_(e));
        }
      });
    }, iie = {
      "font-size": "size",
      "font-family": "face"
    }, UJ = _s("font"), lie = (e, n, s) => {
      const l = (p) => Sl(p, e).orThunk(() => UJ(p) ? Or(iie, e).bind((v) => da(p, v)) : Y.none()), d = (p) => zr(Me.fromDom(n), p);
      return OD(Me.fromDom(s), (p) => l(p), d);
    }, WJ = (e) => e.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ","), r0 = (e, n) => Y.from(Js.DOM.getStyle(n, e, !0)), CA = (e) => (n, s) => Y.from(s).map(Me.fromDom).filter(rt).bind((l) => lie(e, n, l.dom).or(r0(e, l.dom))).getOr(""), SA = CA("font-size"), Fz = B(WJ, CA("font-family")), Bz = (e) => zl(e.getBody()).bind((n) => {
      const s = n.container();
      return Y.from(Zt(s) ? s.parentNode : s);
    }), $z = (e) => Y.from(e.selection.getRng()).bind((n) => {
      const s = e.getBody();
      return n.startContainer === s && n.startOffset === 0 ? Y.none() : Y.from(e.selection.getStart(!0));
    }), ZJ = (e, n) => $z(e).orThunk(Le(Bz, e)).map(Me.fromDom).filter(rt).bind(n), KM = (e, n) => ZJ(e, mn(Y.some, n)), Lz = (e, n) => {
      if (/^[0-9.]+$/.test(n)) {
        const s = parseInt(n, 10);
        if (s >= 1 && s <= 7) {
          const l = Vp(e), d = j4(e);
          return d.length > 0 ? d[s - 1] || n : l[s - 1] || n;
        } else
          return n;
      } else
        return n;
    }, GJ = (e) => {
      const n = e.split(/\s*,\s*/);
      return en(n, (s) => s.indexOf(" ") !== -1 && !(lo(s, '"') || lo(s, "'")) ? `'${s}'` : s).join(",");
    }, qJ = (e, n) => {
      const s = Lz(e, n);
      e.formatter.toggle("fontname", { value: GJ(s) }), e.nodeChanged();
    }, KJ = (e) => KM(e, (n) => Fz(e.getBody(), n.dom)).getOr(""), uv = (e, n) => {
      e.formatter.toggle("fontsize", { value: Lz(e, n) }), e.nodeChanged();
    }, YJ = (e) => KM(e, (n) => SA(e.getBody(), n.dom)).getOr(""), Hz = (e) => KM(e, (n) => {
      const s = Me.fromDom(e.getBody()), l = OD(n, (p) => Sl(p, "line-height"), Le(zr, s)), d = () => {
        const p = parseFloat(fa(n, "line-height")), v = parseFloat(fa(n, "font-size"));
        return String(p / v);
      };
      return l.getOrThunk(d);
    }).getOr(""), XJ = (e, n) => {
      e.formatter.toggle("lineheight", { value: String(n) }), e.nodeChanged();
    }, kA = (e) => {
      const n = (s, l) => {
        e.formatter.toggle(s, l), e.nodeChanged();
      };
      e.editorCommands.addCommands({
        "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (s) => {
          n(s);
        },
        "ForeColor,HiliteColor": (s, l, d) => {
          n(s, { value: d });
        },
        BackColor: (s, l, d) => {
          n("hilitecolor", { value: d });
        },
        FontName: (s, l, d) => {
          qJ(e, d);
        },
        FontSize: (s, l, d) => {
          uv(e, d);
        },
        LineHeight: (s, l, d) => {
          XJ(e, d);
        },
        Lang: (s, l, d) => {
          var p;
          n(s, {
            value: d.code,
            customValue: (p = d.customCode) !== null && p !== void 0 ? p : null
          });
        },
        RemoveFormat: (s) => {
          e.formatter.remove(s);
        },
        mceBlockQuote: () => {
          n("blockquote");
        },
        FormatBlock: (s, l, d) => {
          n(G(d) ? d : "p");
        },
        mceToggleFormat: (s, l, d) => {
          n(d);
        }
      });
    }, QJ = (e) => {
      const n = (s) => e.formatter.match(s);
      e.editorCommands.addCommands({
        "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (s) => n(s),
        mceBlockQuote: () => n("blockquote")
      }, "state"), e.editorCommands.addQueryValueHandler("FontName", () => KJ(e)), e.editorCommands.addQueryValueHandler("FontSize", () => YJ(e)), e.editorCommands.addQueryValueHandler("LineHeight", () => Hz(e));
    }, JJ = (e) => {
      kA(e), QJ(e);
    }, eee = (e) => {
      e.editorCommands.addCommands({
        mceAddUndoLevel: () => {
          e.undoManager.add();
        },
        mceEndUndoLevel: () => {
          e.undoManager.add();
        },
        Undo: () => {
          e.undoManager.undo();
        },
        Redo: () => {
          e.undoManager.redo();
        }
      });
    }, zz = (e) => {
      e.editorCommands.addCommands({
        Indent: () => {
          Fq(e);
        },
        Outdent: () => {
          CN(e);
        }
      }), e.editorCommands.addCommands({ Outdent: () => Ng(e) }, "state");
    }, tee = (e) => {
      const n = (s, l, d) => {
        const p = G(d) ? { href: d } : d, v = e.dom.getParent(e.selection.getNode(), "a");
        ve(p) && G(p.href) && (p.href = p.href.replace(/ /g, "%20"), (!v || !p.href) && e.formatter.remove("link"), p.href && e.formatter.apply("link", p, v));
      };
      e.editorCommands.addCommands({
        unlink: () => {
          if (e.selection.isEditable()) {
            if (e.selection.isCollapsed()) {
              const s = e.dom.getParent(e.selection.getStart(), "a");
              s && e.dom.remove(s, !0);
              return;
            }
            e.formatter.remove("link");
          }
        },
        mceInsertLink: n,
        createLink: n
      });
    }, nee = (e, n, s, l) => {
      const d = e.dom, p = (S) => d.isBlock(S) && S.parentElement === s, v = p(n) ? n : d.getParent(l, p, s);
      return Y.from(v).map(Me.fromDom);
    }, Vz = (e, n) => {
      const s = e.dom, l = e.selection.getRng(), d = n ? e.selection.getStart() : e.selection.getEnd(), p = n ? l.startContainer : l.endContainer, v = VS(s, p);
      if (!v || !v.isContentEditable)
        return;
      const S = n ? Ki : Jl, O = Pl(e);
      nee(e, d, v, p).each((M) => {
        const j = TY(e, p, M.dom, v, !1, O);
        S(M, Me.fromDom(j)), e.selection.setCursorLocation(j, 0), e.dispatch("NewBlock", { newBlock: j }), sv(e, "insertParagraph");
      });
    }, oee = (e) => Vz(e, !0), YM = (e) => Vz(e, !1), ree = (e) => {
      e.editorCommands.addCommands({
        InsertNewBlockBefore: () => {
          oee(e);
        },
        InsertNewBlockAfter: () => {
          YM(e);
        }
      });
    }, see = (e) => {
      e.editorCommands.addCommands({
        insertParagraph: () => {
          Ux(z7, e);
        },
        mceInsertNewLine: (n, s, l) => {
          HO(e, l);
        },
        InsertLineBreak: (n, s, l) => {
          Ux(iM, e);
        }
      });
    }, Hi = (e) => {
      e.editorCommands.addCommands({
        mceSelectNodeDepth: (n, s, l) => {
          let d = 0;
          e.dom.getParent(e.selection.getNode(), (p) => On(p) && d++ === l ? (e.selection.select(p), !1) : !0, e.getBody());
        },
        mceSelectNode: (n, s, l) => {
          e.selection.select(l);
        },
        selectAll: () => {
          const n = e.dom.getParent(e.selection.getStart(), Rt);
          if (n) {
            const s = e.dom.createRng();
            s.selectNodeContents(n), e.selection.setRng(s);
          }
        }
      });
    }, aee = (e) => {
      e.editorCommands.addCommands({
        mceRemoveNode: (n, s, l) => {
          const d = l ?? e.selection.getNode();
          if (d !== e.getBody()) {
            const p = e.selection.getBookmark();
            e.dom.remove(d, !0), e.selection.moveToBookmark(p);
          }
        },
        mcePrint: () => {
          e.getWin().print();
        },
        mceFocus: (n, s, l) => {
          HP(e, l === !0);
        },
        mceToggleVisualAid: () => {
          e.hasVisual = !e.hasVisual, e.addVisual();
        }
      });
    }, iee = (e) => {
      Mz(e), Iz(e), eee(e), Hi(e), aie(e), tee(e), zz(e), ree(e), see(e), JJ(e), aee(e);
    }, XM = ["toggleview"], QM = (e) => At(XM, e.toLowerCase());
    class _A {
      constructor(n) {
        this.commands = {
          state: {},
          exec: {},
          value: {}
        }, this.editor = n;
      }
      execCommand(n, s = !1, l, d) {
        const p = this.editor, v = n.toLowerCase(), S = d == null ? void 0 : d.skip_focus;
        if (p.removed || (v !== "mcefocus" && (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(v) && !S ? p.focus() : OF(p)), p.dispatch("BeforeExecCommand", {
          command: n,
          ui: s,
          value: l
        }).isDefaultPrevented()))
          return !1;
        const M = this.commands.exec[v];
        return ye(M) ? (M(v, s, l), p.dispatch("ExecCommand", {
          command: n,
          ui: s,
          value: l
        }), !0) : !1;
      }
      queryCommandState(n) {
        if (!QM(n) && this.editor.quirks.isHidden() || this.editor.removed)
          return !1;
        const s = n.toLowerCase(), l = this.commands.state[s];
        return ye(l) ? l(s) : !1;
      }
      queryCommandValue(n) {
        if (!QM(n) && this.editor.quirks.isHidden() || this.editor.removed)
          return "";
        const s = n.toLowerCase(), l = this.commands.value[s];
        return ye(l) ? l(s) : "";
      }
      addCommands(n, s = "exec") {
        const l = this.commands;
        Ht(n, (d, p) => {
          Ue(p.toLowerCase().split(","), (v) => {
            l[s][v] = d;
          });
        });
      }
      addCommand(n, s, l) {
        const d = n.toLowerCase();
        this.commands.exec[d] = (p, v, S) => s.call(l ?? this.editor, v, S);
      }
      queryCommandSupported(n) {
        const s = n.toLowerCase();
        return !!this.commands.exec[s];
      }
      addQueryStateHandler(n, s, l) {
        this.commands.state[n.toLowerCase()] = () => s.call(l ?? this.editor);
      }
      addQueryValueHandler(n, s, l) {
        this.commands.value[n.toLowerCase()] = () => s.call(l ?? this.editor);
      }
    }
    const s0 = "data-mce-contenteditable", lee = (e, n, s) => {
      Pf(e, n) && !s ? lu(e, n) : s && fd(e, n);
    }, JM = (e, n, s) => {
      try {
        e.getDoc().execCommand(n, !1, String(s));
      } catch {
      }
    }, EA = (e, n) => {
      e.dom.contentEditable = n ? "true" : "false";
    }, cee = (e) => {
      Ue(ba(e, '*[contenteditable="true"]'), (n) => {
        ur(n, s0, "true"), EA(n, !1);
      });
    }, uee = (e) => {
      Ue(ba(e, `*[${s0}="true"]`), (n) => {
        oa(n, s0), EA(n, !0);
      });
    }, dee = (e) => {
      Y.from(e.selection.getNode()).each((n) => {
        n.removeAttribute("data-mce-selected");
      });
    }, fee = (e) => {
      e.selection.setRng(e.selection.getRng());
    }, Xx = (e, n) => {
      const s = Me.fromDom(e.getBody());
      lee(s, "mce-content-readonly", n), n ? (e.selection.controlSelection.hideResizeRect(), e._selectionOverrides.hideFakeCaret(), dee(e), e.readonly = !0, EA(s, !1), cee(s)) : (e.readonly = !1, e.hasEditableRoot() && EA(s, !0), uee(s), JM(e, "StyleWithCSS", !1), JM(e, "enableInlineTableEditing", !1), JM(e, "enableObjectResizing", !1), PC(e) && e.focus(), fee(e), e.nodeChanged());
    }, ou = (e) => e.readonly, jz = (e) => {
      e.parser.addAttributeFilter("contenteditable", (n) => {
        ou(e) && Ue(n, (s) => {
          s.attr(s0, s.attr("contenteditable")), s.attr("contenteditable", "false");
        });
      }), e.serializer.addAttributeFilter(s0, (n) => {
        ou(e) && Ue(n, (s) => {
          s.attr("contenteditable", s.attr(s0));
        });
      }), e.serializer.addTempAttr(s0);
    }, mee = (e) => {
      e.serializer ? jz(e) : e.on("PreInit", () => {
        jz(e);
      });
    }, pee = (e) => e.type === "click", hee = ["copy"], gee = (e) => At(hee, e.type), bee = (e, n) => cu(n, "a", (l) => zr(l, Me.fromDom(e.getBody()))).bind((l) => da(l, "href")), vee = (e, n) => {
      if (pee(n) && !Xt.metaKeyPressed(n)) {
        const s = Me.fromDom(n.target);
        bee(e, s).each((l) => {
          if (n.preventDefault(), /^#/.test(l)) {
            const d = e.dom.select(`${l},[name="${qn(l, "#")}"]`);
            d.length && e.selection.scrollIntoView(d[0], !0);
          } else
            window.open(l, "_blank", "rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes");
        });
      } else gee(n) && e.dispatch(n.type, n);
    }, yee = (e) => {
      e.on("ShowCaret", (n) => {
        ou(e) && n.preventDefault();
      }), e.on("ObjectSelected", (n) => {
        ou(e) && n.preventDefault();
      });
    }, xee = Gt.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel", " ");
    class Uz {
      static isNative(n) {
        return !!xee[n.toLowerCase()];
      }
      constructor(n) {
        this.bindings = {}, this.settings = n || {}, this.scope = this.settings.scope || this, this.toggleEvent = this.settings.toggleEvent || tt;
      }
      fire(n, s) {
        return this.dispatch(n, s);
      }
      dispatch(n, s) {
        const l = n.toLowerCase(), d = Uw(l, s ?? {}, this.scope);
        this.settings.beforeFire && this.settings.beforeFire(d);
        const p = this.bindings[l];
        if (p)
          for (let v = 0, S = p.length; v < S; v++) {
            const O = p[v];
            if (!O.removed) {
              if (O.once && this.off(l, O.func), d.isImmediatePropagationStopped())
                return d;
              if (O.func.call(this.scope, d) === !1)
                return d.preventDefault(), d;
            }
          }
        return d;
      }
      on(n, s, l, d) {
        if (s === !1 && (s = tt), s) {
          const p = {
            func: s,
            removed: !1
          };
          d && Gt.extend(p, d);
          const v = n.toLowerCase().split(" ");
          let S = v.length;
          for (; S--; ) {
            const O = v[S];
            let M = this.bindings[O];
            M || (M = [], this.toggleEvent(O, !0)), l ? M = [
              p,
              ...M
            ] : M = [
              ...M,
              p
            ], this.bindings[O] = M;
          }
        }
        return this;
      }
      off(n, s) {
        if (n) {
          const l = n.toLowerCase().split(" ");
          let d = l.length;
          for (; d--; ) {
            const p = l[d];
            let v = this.bindings[p];
            if (!p)
              return Ht(this.bindings, (S, O) => {
                this.toggleEvent(O, !1), delete this.bindings[O];
              }), this;
            if (v) {
              if (!s)
                v.length = 0;
              else {
                const S = mo(v, (O) => O.func === s);
                v = S.fail, this.bindings[p] = v, Ue(S.pass, (O) => {
                  O.removed = !0;
                });
              }
              v.length || (this.toggleEvent(n, !1), delete this.bindings[p]);
            }
          }
        } else
          Ht(this.bindings, (l, d) => {
            this.toggleEvent(d, !1);
          }), this.bindings = {};
        return this;
      }
      once(n, s, l) {
        return this.on(n, s, l, { once: !0 });
      }
      has(n) {
        n = n.toLowerCase();
        const s = this.bindings[n];
        return !(!s || s.length === 0);
      }
    }
    const sk = (e) => (e._eventDispatcher || (e._eventDispatcher = new Uz({
      scope: e,
      toggleEvent: (n, s) => {
        Uz.isNative(n) && e.toggleNativeEvent && e.toggleNativeEvent(n, s);
      }
    })), e._eventDispatcher), eI = {
      fire(e, n, s) {
        return this.dispatch(e, n, s);
      },
      dispatch(e, n, s) {
        const l = this;
        if (l.removed && e !== "remove" && e !== "detach")
          return Uw(e.toLowerCase(), n ?? {}, l);
        const d = sk(l).dispatch(e, n);
        if (s !== !1 && l.parent) {
          let p = l.parent();
          for (; p && !d.isPropagationStopped(); )
            p.dispatch(e, d, !1), p = p.parent ? p.parent() : void 0;
        }
        return d;
      },
      on(e, n, s) {
        return sk(this).on(e, n, s);
      },
      off(e, n) {
        return sk(this).off(e, n);
      },
      once(e, n) {
        return sk(this).once(e, n);
      },
      hasEventListeners(e) {
        return sk(this).has(e);
      }
    }, TA = Js.DOM;
    let a0;
    const OA = (e, n) => {
      if (n === "selectionchange")
        return e.getDoc();
      if (!e.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(n))
        return e.getDoc().documentElement;
      const s = uf(e);
      return s ? (e.eventRoot || (e.eventRoot = TA.select(s)[0]), e.eventRoot) : e.getBody();
    }, wee = (e) => !e.hidden && !ou(e), Cee = (e, n, s) => {
      wee(e) ? e.dispatch(n, s) : ou(e) && vee(e, s);
    }, Wz = (e, n) => {
      if (e.delegates || (e.delegates = {}), e.delegates[n] || e.removed)
        return;
      const s = OA(e, n);
      if (uf(e)) {
        if (a0 || (a0 = {}, e.editorManager.on("removeEditor", () => {
          e.editorManager.activeEditor || a0 && (Ht(a0, (d, p) => {
            e.dom.unbind(OA(e, p));
          }), a0 = null);
        })), a0[n])
          return;
        const l = (d) => {
          const p = d.target, v = e.editorManager.get();
          let S = v.length;
          for (; S--; ) {
            const O = v[S].getBody();
            (O === p || TA.isChildOf(p, O)) && Cee(v[S], n, d);
          }
        };
        a0[n] = l, TA.bind(s, n, l);
      } else {
        const l = (d) => {
          Cee(e, n, d);
        };
        TA.bind(s, n, l), e.delegates[n] = l;
      }
    }, Zz = {
      ...eI,
      bindPendingEventDelegates() {
        const e = this;
        Gt.each(e._pendingNativeEvents, (n) => {
          Wz(e, n);
        });
      },
      toggleNativeEvent(e, n) {
        const s = this;
        e === "focus" || e === "blur" || s.removed || (n ? s.initialized ? Wz(s, e) : s._pendingNativeEvents ? s._pendingNativeEvents.push(e) : s._pendingNativeEvents = [e] : s.initialized && s.delegates && (s.dom.unbind(OA(s, e), e, s.delegates[e]), delete s.delegates[e]));
      },
      unbindAllNativeEvents() {
        const e = this, n = e.getBody(), s = e.dom;
        e.delegates && (Ht(e.delegates, (l, d) => {
          e.dom.unbind(OA(e, d), d, l);
        }), delete e.delegates), !e.inline && n && s && (n.onload = null, s.unbind(e.getWin()), s.unbind(e.getDoc())), s && (s.unbind(n), s.unbind(e.getContainer()));
      }
    }, See = (e) => G(e) ? {
      value: e.split(/[ ,]/),
      valid: !0
    } : wt(e, G) ? {
      value: e,
      valid: !0
    } : {
      valid: !1,
      message: "The value must be a string[] or a comma/space separated string."
    }, kee = (e) => {
      const n = (() => {
        switch (e) {
          case "array":
            return Xe;
          case "boolean":
            return lt;
          case "function":
            return ye;
          case "number":
            return dn;
          case "object":
            return ve;
          case "string":
            return G;
          case "string[]":
            return See;
          case "object[]":
            return (s) => wt(s, ve);
          case "regexp":
            return (s) => ae(s, RegExp);
          default:
            return mt;
        }
      })();
      return (s) => tI(s, n, `The value must be a ${e}.`);
    }, _ee = (e) => G(e.processor), Gz = (e, n) => {
      const s = Yo(n.message) ? "" : `. ${n.message}`;
      return e + s;
    }, qz = (e) => e.valid, tI = (e, n, s = "") => {
      const l = n(e);
      return lt(l) ? l ? {
        value: e,
        valid: !0
      } : {
        valid: !1,
        message: s
      } : l;
    }, Eee = (e, n, s) => {
      if (!ot(n)) {
        const l = tI(n, s);
        if (qz(l))
          return l.value;
        console.error(Gz(`Invalid default value passed for the "${e}" option`, l));
      }
    }, Tee = (e, n, s = n) => {
      const l = {}, d = {}, p = (de, we, me) => {
        const Se = tI(we, me);
        return qz(Se) ? (d[de] = Se.value, !0) : (console.warn(Gz(`Invalid value passed for the ${de} option`, Se)), !1);
      }, v = (de, we) => {
        const me = _ee(we) ? kee(we.processor) : we.processor, Se = Eee(de, we.default, me);
        l[de] = {
          ...we,
          default: Se,
          processor: me
        }, Or(d, de).orThunk(() => Or(n, de)).each((Ye) => p(de, Ye, me));
      }, S = (de) => Xn(l, de);
      return {
        register: v,
        isRegistered: S,
        get: (de) => Or(d, de).orThunk(() => Or(l, de).map((we) => we.default)).getOrUndefined(),
        set: (de, we) => {
          if (S(de)) {
            const me = l[de];
            return me.immutable ? (console.error(`"${de}" is an immutable option and cannot be updated`), !1) : p(de, we, me.processor);
          } else
            return console.warn(`"${de}" is not a registered option. Ensure the option has been registered before setting a value.`), !1;
        },
        unset: (de) => {
          const we = S(de);
          return we && delete d[de], we;
        },
        isSet: (de) => Xn(d, de),
        debug: () => {
          try {
            console.log(JSON.parse(JSON.stringify(s, (de, we) => lt(we) || dn(we) || G(we) || te(we) || Xe(we) || nt(we) ? we : Object.prototype.toString.call(we))));
          } catch (de) {
            console.error(de);
          }
        }
      };
    }, Oee = [
      "design",
      "readonly"
    ], Kz = (e, n, s, l) => {
      const d = s[n.get()], p = s[l];
      try {
        p.activate();
      } catch (v) {
        console.error(`problem while activating editor mode ${l}:`, v);
        return;
      }
      d.deactivate(), d.editorReadOnly !== p.editorReadOnly && Xx(e, p.editorReadOnly), n.set(l), gP(e, l);
    }, Aee = (e, n, s, l) => {
      if (l !== s.get()) {
        if (!Xn(n, l))
          throw new Error(`Editor mode '${l}' is invalid`);
        e.initialized ? Kz(e, s, n, l) : e.on("init", () => Kz(e, s, n, l));
      }
    }, Pee = (e, n, s) => {
      if (At(Oee, n))
        throw new Error(`Cannot override default mode ${n}`);
      return {
        ...e,
        [n]: {
          ...s,
          deactivate: () => {
            try {
              s.deactivate();
            } catch (l) {
              console.error(`problem while deactivating editor mode ${n}:`, l);
            }
          }
        }
      };
    }, Dee = (e) => {
      const n = Qe("design"), s = Qe({
        design: {
          activate: qe,
          deactivate: qe,
          editorReadOnly: !1
        },
        readonly: {
          activate: qe,
          deactivate: qe,
          editorReadOnly: !0
        }
      });
      return mee(e), yee(e), {
        isReadOnly: () => ou(e),
        set: (l) => Aee(e, s.get(), n, l),
        get: () => n.get(),
        register: (l, d) => {
          s.set(Pee(s.get(), l, d));
        }
      };
    }, nI = Gt.each, AA = Gt.explode, Ree = {
      f1: 112,
      f2: 113,
      f3: 114,
      f4: 115,
      f5: 116,
      f6: 117,
      f7: 118,
      f8: 119,
      f9: 120,
      f10: 121,
      f11: 122,
      f12: 123
    }, Yz = Gt.makeMap("alt,ctrl,shift,meta,access"), Nee = (e) => e in Yz, Mee = (e) => {
      const n = {}, s = rn.os.isMacOS() || rn.os.isiOS();
      nI(AA(e.toLowerCase(), "+"), (p) => {
        Nee(p) ? n[p] = !0 : /^[0-9]{2,}$/.test(p) ? n.keyCode = parseInt(p, 10) : (n.charCode = p.charCodeAt(0), n.keyCode = Ree[p] || p.toUpperCase().charCodeAt(0));
      });
      const l = [n.keyCode];
      let d;
      for (d in Yz)
        n[d] ? l.push(d) : n[d] = !1;
      return n.id = l.join(","), n.access && (n.alt = !0, s ? n.ctrl = !0 : n.shift = !0), n.meta && (s ? n.meta = !0 : (n.ctrl = !0, n.meta = !1)), n;
    };
    class Xz {
      constructor(n) {
        this.shortcuts = {}, this.pendingPatterns = [], this.editor = n;
        const s = this;
        n.on("keyup keypress keydown", (l) => {
          (s.hasModifier(l) || s.isFunctionKey(l)) && !l.isDefaultPrevented() && (nI(s.shortcuts, (d) => {
            s.matchShortcut(l, d) && (s.pendingPatterns = d.subpatterns.slice(0), l.type === "keydown" && s.executeShortcutAction(d));
          }), s.matchShortcut(l, s.pendingPatterns[0]) && (s.pendingPatterns.length === 1 && l.type === "keydown" && s.executeShortcutAction(s.pendingPatterns[0]), s.pendingPatterns.shift()));
        });
      }
      add(n, s, l, d) {
        const p = this, v = p.normalizeCommandFunc(l);
        return nI(AA(Gt.trim(n)), (S) => {
          const O = p.createShortcut(S, s, v, d);
          p.shortcuts[O.id] = O;
        }), !0;
      }
      remove(n) {
        const s = this.createShortcut(n);
        return this.shortcuts[s.id] ? (delete this.shortcuts[s.id], !0) : !1;
      }
      normalizeCommandFunc(n) {
        const s = this, l = n;
        return typeof l == "string" ? () => {
          s.editor.execCommand(l, !1, null);
        } : Gt.isArray(l) ? () => {
          s.editor.execCommand(l[0], l[1], l[2]);
        } : l;
      }
      createShortcut(n, s, l, d) {
        const p = Gt.map(AA(n, ">"), Mee);
        return p[p.length - 1] = Gt.extend(p[p.length - 1], {
          func: l,
          scope: d || this.editor
        }), Gt.extend(p[0], {
          desc: this.editor.translate(s),
          subpatterns: p.slice(1)
        });
      }
      hasModifier(n) {
        return n.altKey || n.ctrlKey || n.metaKey;
      }
      isFunctionKey(n) {
        return n.type === "keydown" && n.keyCode >= 112 && n.keyCode <= 123;
      }
      matchShortcut(n, s) {
        return !s || s.ctrl !== n.ctrlKey || s.meta !== n.metaKey || s.alt !== n.altKey || s.shift !== n.shiftKey ? !1 : n.keyCode === s.keyCode || n.charCode && n.charCode === s.charCode ? (n.preventDefault(), !0) : !1;
      }
      executeShortcutAction(n) {
        return n.func ? n.func.call(n.scope) : null;
      }
    }
    const Iee = () => {
      const e = {}, n = {}, s = {}, l = {}, d = {}, p = {}, v = {}, S = {}, O = (j, U) => (Z, de) => {
        j[Z.toLowerCase()] = {
          ...de,
          type: U
        };
      }, M = (j, U) => l[j.toLowerCase()] = U;
      return {
        addButton: O(e, "button"),
        addGroupToolbarButton: O(e, "grouptoolbarbutton"),
        addToggleButton: O(e, "togglebutton"),
        addMenuButton: O(e, "menubutton"),
        addSplitButton: O(e, "splitbutton"),
        addMenuItem: O(n, "menuitem"),
        addNestedMenuItem: O(n, "nestedmenuitem"),
        addToggleMenuItem: O(n, "togglemenuitem"),
        addAutocompleter: O(s, "autocompleter"),
        addContextMenu: O(d, "contextmenu"),
        addContextToolbar: O(p, "contexttoolbar"),
        addContextForm: O(p, "contextform"),
        addSidebar: O(v, "sidebar"),
        addView: O(S, "views"),
        addIcon: M,
        getAll: () => ({
          buttons: e,
          menuItems: n,
          icons: l,
          popups: s,
          contextMenus: d,
          contextToolbars: p,
          sidebars: v,
          views: S
        })
      };
    }, Fee = () => {
      const e = Iee();
      return {
        addAutocompleter: e.addAutocompleter,
        addButton: e.addButton,
        addContextForm: e.addContextForm,
        addContextMenu: e.addContextMenu,
        addContextToolbar: e.addContextToolbar,
        addIcon: e.addIcon,
        addMenuButton: e.addMenuButton,
        addMenuItem: e.addMenuItem,
        addNestedMenuItem: e.addNestedMenuItem,
        addSidebar: e.addSidebar,
        addSplitButton: e.addSplitButton,
        addToggleButton: e.addToggleButton,
        addGroupToolbarButton: e.addGroupToolbarButton,
        addToggleMenuItem: e.addToggleMenuItem,
        addView: e.addView,
        getAll: e.getAll
      };
    }, i0 = Js.DOM, oI = Gt.extend, Bee = Gt.each;
    class PA {
      constructor(n, s, l) {
        this.plugins = {}, this.contentCSS = [], this.contentStyles = [], this.loadedCSS = {}, this.isNotDirty = !1, this.composing = !1, this.destroyed = !1, this.hasHiddenInput = !1, this.iframeElement = null, this.initialized = !1, this.readonly = !1, this.removed = !1, this.startContent = "", this._pendingNativeEvents = [], this._skinLoaded = !1, this._editableRoot = !0, this.editorManager = l, this.documentBaseUrl = l.documentBaseURL, oI(this, Zz);
        const d = this;
        this.id = n, this.hidden = !1;
        const p = LJ(l.defaultOptions, s);
        this.options = Tee(d, p, s), _b(d);
        const v = this.options.get;
        v("deprecation_warnings") && tG(s, p);
        const S = v("suffix");
        S && (l.suffix = S), this.suffix = l.suffix;
        const O = v("base_url");
        O && l._setBaseUrl(O), this.baseUri = l.baseURI;
        const M = cy(d);
        M && (of.ScriptLoader._setReferrerPolicy(M), Js.DOM.styleSheetLoader._setReferrerPolicy(M));
        const j = $_(d);
        je(j) && Js.DOM.styleSheetLoader._setContentCssCors(j), rc.languageLoad = v("language_load"), rc.baseURL = l.baseURL, this.setDirty(!1), this.documentBaseURI = new mc(el(d), { base_uri: this.baseUri }), this.baseURI = this.baseUri, this.inline = ig(d), this.hasVisual = lc(d), this.shortcuts = new Xz(this), this.editorCommands = new _A(this), iee(this);
        const U = v("cache_suffix");
        U && (rn.cacheSuffix = U.replace(/^[\?\&]+/, "")), this.ui = {
          registry: Fee(),
          styleSheetLoader: void 0,
          show: qe,
          hide: qe,
          setEnabled: qe,
          isEnabled: mt
        }, this.mode = Dee(d), l.dispatch("SetupEditor", { editor: this });
        const Z = my(d);
        ye(Z) && Z.call(d, d);
      }
      render() {
        Oz(this);
      }
      focus(n) {
        this.execCommand("mceFocus", !1, n);
      }
      hasFocus() {
        return S1(this);
      }
      translate(n) {
        return Ii.translate(n);
      }
      getParam(n, s, l) {
        const d = this.options;
        return d.isRegistered(n) || (je(l) ? d.register(n, {
          processor: l,
          default: s
        }) : d.register(n, {
          processor: mt,
          default: s
        })), !d.isSet(n) && !ot(s) ? s : d.get(n);
      }
      hasPlugin(n, s) {
        return At(t1(this), n) ? s ? Cx.get(n) !== void 0 : !0 : !1;
      }
      nodeChanged(n) {
        this._nodeChangeDispatcher.nodeChanged(n);
      }
      addCommand(n, s, l) {
        this.editorCommands.addCommand(n, s, l);
      }
      addQueryStateHandler(n, s, l) {
        this.editorCommands.addQueryStateHandler(n, s, l);
      }
      addQueryValueHandler(n, s, l) {
        this.editorCommands.addQueryValueHandler(n, s, l);
      }
      addShortcut(n, s, l, d) {
        this.shortcuts.add(n, s, l, d);
      }
      execCommand(n, s, l, d) {
        return this.editorCommands.execCommand(n, s, l, d);
      }
      queryCommandState(n) {
        return this.editorCommands.queryCommandState(n);
      }
      queryCommandValue(n) {
        return this.editorCommands.queryCommandValue(n);
      }
      queryCommandSupported(n) {
        return this.editorCommands.queryCommandSupported(n);
      }
      show() {
        const n = this;
        n.hidden && (n.hidden = !1, n.inline ? n.getBody().contentEditable = "true" : (i0.show(n.getContainer()), i0.hide(n.id)), n.load(), n.dispatch("show"));
      }
      hide() {
        const n = this;
        n.hidden || (n.save(), n.inline ? (n.getBody().contentEditable = "false", n === n.editorManager.focusedEditor && (n.editorManager.focusedEditor = null)) : (i0.hide(n.getContainer()), i0.setStyle(n.id, "display", n.orgDisplay)), n.hidden = !0, n.dispatch("hide"));
      }
      isHidden() {
        return this.hidden;
      }
      setProgressState(n, s) {
        this.dispatch("ProgressState", {
          state: n,
          time: s
        });
      }
      load(n = {}) {
        const s = this, l = s.getElement();
        if (s.removed)
          return "";
        if (l) {
          const d = {
            ...n,
            load: !0
          }, p = ia(l) ? l.value : l.innerHTML, v = s.setContent(p, d);
          return d.no_events || s.dispatch("LoadContent", {
            ...d,
            element: l
          }), v;
        } else
          return "";
      }
      save(n = {}) {
        const s = this;
        let l = s.getElement();
        if (!l || !s.initialized || s.removed)
          return "";
        const d = {
          ...n,
          save: !0,
          element: l
        };
        let p = s.getContent(d);
        const v = {
          ...d,
          content: p
        };
        if (v.no_events || s.dispatch("SaveContent", v), v.format === "raw" && s.dispatch("RawSaveContent", v), p = v.content, ia(l))
          l.value = p;
        else {
          (n.is_removing || !s.inline) && (l.innerHTML = p);
          const S = i0.getParent(s.id, "form");
          S && Bee(S.elements, (O) => O.name === s.id ? (O.value = p, !1) : !0);
        }
        return v.element = d.element = l = null, v.set_dirty !== !1 && s.setDirty(!1), p;
      }
      setContent(n, s) {
        return PR(this, n, s);
      }
      getContent(n) {
        return qT(this, n);
      }
      insertContent(n, s) {
        s && (n = oI({ content: n }, s)), this.execCommand("mceInsertContent", !1, n);
      }
      resetContent(n) {
        n === void 0 ? PR(this, this.startContent, { format: "raw" }) : PR(this, n), this.undoManager.reset(), this.setDirty(!1), this.nodeChanged();
      }
      isDirty() {
        return !this.isNotDirty;
      }
      setDirty(n) {
        const s = !this.isNotDirty;
        this.isNotDirty = !n, n && n !== s && this.dispatch("dirty");
      }
      getContainer() {
        const n = this;
        return n.container || (n.container = n.editorContainer || i0.get(n.id + "_parent")), n.container;
      }
      getContentAreaContainer() {
        return this.contentAreaContainer;
      }
      getElement() {
        return this.targetElm || (this.targetElm = i0.get(this.id)), this.targetElm;
      }
      getWin() {
        const n = this;
        if (!n.contentWindow) {
          const s = n.iframeElement;
          s && (n.contentWindow = s.contentWindow);
        }
        return n.contentWindow;
      }
      getDoc() {
        const n = this;
        if (!n.contentDocument) {
          const s = n.getWin();
          s && (n.contentDocument = s.document);
        }
        return n.contentDocument;
      }
      getBody() {
        var n, s;
        const l = this.getDoc();
        return (s = (n = this.bodyElement) !== null && n !== void 0 ? n : l == null ? void 0 : l.body) !== null && s !== void 0 ? s : null;
      }
      convertURL(n, s, l) {
        const d = this, p = d.options.get, v = L4(d);
        if (ye(v))
          return v.call(d, n, l, !0, s);
        if (!p("convert_urls") || l === "link" || ve(l) && l.nodeName === "LINK" || n.indexOf("file:") === 0 || n.length === 0)
          return n;
        const S = new mc(n);
        return S.protocol !== "http" && S.protocol !== "https" && S.protocol !== "" ? n : p("relative_urls") ? d.documentBaseURI.toRelative(n) : (n = d.documentBaseURI.toAbsolute(n, p("remove_script_host")), n);
      }
      addVisual(n) {
        HJ(this, n);
      }
      setEditableRoot(n) {
        RJ(this, n);
      }
      hasEditableRoot() {
        return Az(this);
      }
      remove() {
        rG(this);
      }
      destroy(n) {
        sG(this, n);
      }
      uploadImages() {
        return this.editorUpload.uploadImages();
      }
      _scanForImages() {
        return this.editorUpload.scanForImages();
      }
    }
    const Qx = Js.DOM, DA = Gt.each;
    let Qz = !1, RA, Su = [];
    const NA = (e) => {
      const n = e.type;
      DA(Bg.get(), (s) => {
        switch (n) {
          case "scroll":
            s.dispatch("ScrollWindow", e);
            break;
          case "resize":
            s.dispatch("ResizeWindow", e);
            break;
        }
      });
    }, rI = (e) => {
      if (e !== Qz) {
        const n = Js.DOM;
        e ? (n.bind(window, "resize", NA), n.bind(window, "scroll", NA)) : (n.unbind(window, "resize", NA), n.unbind(window, "scroll", NA)), Qz = e;
      }
    }, $ee = (e) => {
      const n = Su;
      return Su = xn(Su, (s) => e !== s), Bg.activeEditor === e && (Bg.activeEditor = Su.length > 0 ? Su[0] : null), Bg.focusedEditor === e && (Bg.focusedEditor = null), n.length !== Su.length;
    }, Jz = (e) => {
      e && e.initialized && !(e.getContainer() || e.getBody()).parentNode && ($ee(e), e.unbindAllNativeEvents(), e.destroy(!0), e.removed = !0);
    }, Lee = document.compatMode !== "CSS1Compat", Bg = {
      ...eI,
      baseURI: null,
      baseURL: null,
      defaultOptions: {},
      documentBaseURL: null,
      suffix: null,
      majorVersion: "7",
      minorVersion: "2.1",
      releaseDate: "2024-07-03",
      i18n: Ii,
      activeEditor: null,
      focusedEditor: null,
      setup() {
        const e = this;
        let n = "", s = "", l = mc.getDocumentBaseUrl(document.location);
        /^[^:]+:\/\/\/?[^\/]+\//.test(l) && (l = l.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(l) || (l += "/"));
        const d = window.tinymce || window.tinyMCEPreInit;
        if (d)
          n = d.base || d.baseURL, s = d.suffix;
        else {
          const p = document.getElementsByTagName("script");
          for (let v = 0; v < p.length; v++) {
            const S = p[v].src || "";
            if (S === "")
              continue;
            const O = S.substring(S.lastIndexOf("/"));
            if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(S)) {
              O.indexOf(".min") !== -1 && (s = ".min"), n = S.substring(0, S.lastIndexOf("/"));
              break;
            }
          }
          if (!n && document.currentScript) {
            const v = document.currentScript.src;
            v.indexOf(".min") !== -1 && (s = ".min"), n = v.substring(0, v.lastIndexOf("/"));
          }
        }
        e.baseURL = new mc(l).toAbsolute(n), e.documentBaseURL = l, e.baseURI = new mc(e.baseURL), e.suffix = s, IF(e);
      },
      overrideDefaults(e) {
        const n = e.base_url;
        n && this._setBaseUrl(n);
        const s = e.suffix;
        s && (this.suffix = s), this.defaultOptions = e;
        const l = e.plugin_base_urls;
        l !== void 0 && Ht(l, (d, p) => {
          rc.PluginManager.urls[p] = d;
        });
      },
      init(e) {
        const n = this;
        let s;
        const l = Gt.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu", " "), d = (j, U) => j.inline && U.tagName.toLowerCase() in l, p = (j) => {
          let U = j.id;
          return U || (U = Or(j, "name").filter((Z) => !Qx.get(Z)).getOrThunk(Qx.uniqueId), j.setAttribute("id", U)), U;
        }, v = (j) => {
          const U = e[j];
          if (U)
            return U.apply(n, []);
        }, S = (j) => rn.browser.isIE() || rn.browser.isEdge() ? (JT("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tiny.cloud/docs/tinymce/7/support/#supportedwebbrowsers"), []) : Lee ? (JT("Failed to initialize the editor as the document is not in standards mode. TinyMCE requires standards mode."), []) : G(j.selector) ? Qx.select(j.selector) : je(j.target) ? [j.target] : [];
        let O = (j) => {
          s = j;
        };
        const M = () => {
          let j = 0;
          const U = [];
          let Z;
          const de = (we, me, Se) => {
            const ze = new PA(we, me, n);
            U.push(ze), ze.on("init", () => {
              ++j === Z.length && O(U);
            }), ze.targetElm = ze.targetElm || Se, ze.render();
          };
          Qx.unbind(window, "ready", M), v("onpageload"), Z = Ir(S(e)), Gt.each(Z, (we) => {
            Jz(n.get(we.id));
          }), Z = Gt.grep(Z, (we) => !n.get(we.id)), Z.length === 0 ? O([]) : DA(Z, (we) => {
            d(e, we) ? JT("Could not initialize inline editor on invalid inline target element", we) : de(p(we), e, we);
          });
        };
        return Qx.bind(window, "ready", M), new Promise((j) => {
          s ? j(s) : O = (U) => {
            j(U);
          };
        });
      },
      get(e) {
        return arguments.length === 0 ? Su.slice(0) : G(e) ? Pn(Su, (n) => n.id === e).getOr(null) : dn(e) && Su[e] ? Su[e] : null;
      },
      add(e) {
        const n = this, s = n.get(e.id);
        return s === e || (s === null && Su.push(e), rI(!0), n.activeEditor = e, n.dispatch("AddEditor", { editor: e }), RA || (RA = (l) => {
          const d = n.dispatch("BeforeUnload");
          if (d.returnValue)
            return l.preventDefault(), l.returnValue = d.returnValue, d.returnValue;
        }, window.addEventListener("beforeunload", RA))), e;
      },
      createEditor(e, n) {
        return this.add(new PA(e, n, this));
      },
      remove(e) {
        const n = this;
        let s;
        if (!e) {
          for (let l = Su.length - 1; l >= 0; l--)
            n.remove(Su[l]);
          return;
        }
        if (G(e)) {
          DA(Qx.select(e), (l) => {
            s = n.get(l.id), s && n.remove(s);
          });
          return;
        }
        return s = e, te(n.get(s.id)) ? null : ($ee(s) && n.dispatch("RemoveEditor", { editor: s }), Su.length === 0 && window.removeEventListener("beforeunload", RA), s.remove(), rI(Su.length > 0), s);
      },
      execCommand(e, n, s) {
        var l;
        const d = this, p = ve(s) ? (l = s.id) !== null && l !== void 0 ? l : s.index : s;
        switch (e) {
          case "mceAddEditor": {
            if (!d.get(p)) {
              const v = s.options;
              new PA(p, v, d).render();
            }
            return !0;
          }
          case "mceRemoveEditor": {
            const v = d.get(p);
            return v && v.remove(), !0;
          }
          case "mceToggleEditor": {
            const v = d.get(p);
            return v ? (v.isHidden() ? v.show() : v.hide(), !0) : (d.execCommand("mceAddEditor", !1, s), !0);
          }
        }
        return d.activeEditor ? d.activeEditor.execCommand(e, n, s) : !1;
      },
      triggerSave: () => {
        DA(Su, (e) => {
          e.save();
        });
      },
      addI18n: (e, n) => {
        Ii.add(e, n);
      },
      translate: (e) => Ii.translate(e),
      setActive(e) {
        const n = this.activeEditor;
        this.activeEditor !== e && (n && n.dispatch("deactivate", { relatedTarget: e }), e.dispatch("activate", { relatedTarget: n })), this.activeEditor = e;
      },
      _setBaseUrl(e) {
        this.baseURL = new mc(this.documentBaseURL).toAbsolute(e.replace(/\/+$/, "")), this.baseURI = new mc(this.baseURL);
      }
    };
    Bg.setup();
    const Hee = (() => {
      const e = Mi(), n = (p) => ({
        items: p,
        types: Zo(p),
        getType: (v) => Or(p, v).getOrUndefined()
      }), s = (p) => {
        e.set(p);
      }, l = () => e.get().getOrUndefined(), d = e.clear;
      return {
        FakeClipboardItem: n,
        write: s,
        read: l,
        clear: d
      };
    })(), e9 = Math.min, Jx = Math.max, MA = Math.round, t9 = (e, n, s) => {
      let l = n.x, d = n.y;
      const p = e.w, v = e.h, S = n.w, O = n.h, M = (s || "").split("");
      return M[0] === "b" && (d += O), M[1] === "r" && (l += S), M[0] === "c" && (d += MA(O / 2)), M[1] === "c" && (l += MA(S / 2)), M[3] === "b" && (d -= v), M[4] === "r" && (l -= p), M[3] === "c" && (d -= MA(v / 2)), M[4] === "c" && (l -= MA(p / 2)), ew(l, d, p, v);
    }, sI = (e, n, s, l) => {
      for (let d = 0; d < l.length; d++) {
        const p = t9(e, n, l[d]);
        if (p.x >= s.x && p.x + p.w <= s.w + s.x && p.y >= s.y && p.y + p.h <= s.h + s.y)
          return l[d];
      }
      return null;
    }, aI = (e, n, s) => ew(e.x - n, e.y - s, e.w + n * 2, e.h + s * 2), zee = (e, n) => {
      const s = Jx(e.x, n.x), l = Jx(e.y, n.y), d = e9(e.x + e.w, n.x + n.w), p = e9(e.y + e.h, n.y + n.h);
      return d - s < 0 || p - l < 0 ? null : ew(s, l, d - s, p - l);
    }, n9 = (e, n, s) => {
      let l = e.x, d = e.y, p = e.x + e.w, v = e.y + e.h;
      const S = n.x + n.w, O = n.y + n.h, M = Jx(0, n.x - l), j = Jx(0, n.y - d), U = Jx(0, p - S), Z = Jx(0, v - O);
      return l += M, d += j, s && (p += M, v += j, l -= U, d -= Z), p -= U, v -= Z, ew(l, d, p - l, v - d);
    }, ew = (e, n, s, l) => ({
      x: e,
      y: n,
      w: s,
      h: l
    }), Vee = {
      inflate: aI,
      relativePosition: t9,
      findBestRelativePosition: sI,
      intersect: zee,
      clamp: n9,
      create: ew,
      fromClientRect: (e) => ew(e.left, e.top, e.width, e.height)
    }, jee = (e, n, s = 1e3) => {
      let l = !1, d = null;
      const p = (M) => (...j) => {
        l || (l = !0, d !== null && (clearTimeout(d), d = null), M.apply(null, j));
      }, v = p(e), S = p(n);
      return {
        start: (...M) => {
          !l && d === null && (d = setTimeout(() => S.apply(null, M), s));
        },
        resolve: v,
        reject: S
      };
    }, Uee = (() => {
      const e = {}, n = {}, s = {};
      return {
        load: (O, M) => {
          const j = `Script at URL "${M}" failed to load`, U = `Script at URL "${M}" did not call \`tinymce.Resource.add('${O}', data)\` within 1 second`;
          if (e[O] !== void 0)
            return e[O];
          {
            const Z = new Promise((de, we) => {
              const me = jee(de, we);
              n[O] = me.resolve, of.ScriptLoader.loadScript(M).then(() => me.start(U), () => me.reject(j));
            });
            return e[O] = Z, Z;
          }
        },
        add: (O, M) => {
          n[O] !== void 0 && (n[O](M), delete n[O]), e[O] = Promise.resolve(M), s[O] = M;
        },
        has: (O) => O in s,
        get: (O) => s[O],
        unload: (O) => {
          delete e[O], delete s[O];
        }
      };
    })(), Wee = () => (() => {
      let e = {}, n = [];
      const s = {
        getItem: (l) => {
          const d = e[l];
          return d || null;
        },
        setItem: (l, d) => {
          n.push(l), e[l] = String(d);
        },
        key: (l) => n[l],
        removeItem: (l) => {
          n = n.filter((d) => d === l), delete e[l];
        },
        clear: () => {
          n = [], e = {};
        },
        length: 0
      };
      return Object.defineProperty(s, "length", {
        get: () => n.length,
        configurable: !1,
        enumerable: !1
      }), s;
    })();
    let ak;
    try {
      const e = "__storage_test__";
      ak = window.localStorage, ak.setItem(e, e), ak.removeItem(e);
    } catch {
      ak = Wee();
    }
    var Zee = ak;
    const Gee = {
      geom: { Rect: Vee },
      util: {
        Delay: Td,
        Tools: Gt,
        VK: Xt,
        URI: mc,
        EventDispatcher: Uz,
        Observable: eI,
        I18n: Ii,
        LocalStorage: Zee,
        ImageUploader: BR
      },
      dom: {
        EventUtils: Ap,
        TreeWalker: Ri,
        TextSeeker: Rp,
        DOMUtils: Js,
        ScriptLoader: of,
        RangeUtils: Ut,
        Serializer: OR,
        StyleSheetLoader: wr,
        ControlSelection: b1,
        BookmarkManager: Yp,
        Selection: BL,
        Event: Ap.Event
      },
      html: {
        Styles: jw,
        Entities: ef,
        Node: eu,
        Schema: Hf,
        DomParser: oh,
        Writer: QF,
        Serializer: Cg
      },
      Env: rn,
      AddOnManager: rc,
      Annotator: Yf,
      Formatter: o6,
      UndoManager: zR,
      EditorCommands: _A,
      WindowManager: NR,
      NotificationManager: qL,
      EditorObservable: Zz,
      Shortcuts: Xz,
      Editor: PA,
      FocusManager: AF,
      EditorManager: Bg,
      DOM: Js.DOM,
      ScriptLoader: of.ScriptLoader,
      PluginManager: Cx,
      ThemeManager: Gm,
      ModelManager: wx,
      IconManager: xx,
      Resource: Uee,
      FakeClipboard: Hee,
      trim: Gt.trim,
      isArray: Gt.isArray,
      is: Gt.is,
      toArray: Gt.toArray,
      makeMap: Gt.makeMap,
      each: Gt.each,
      map: Gt.map,
      grep: Gt.grep,
      inArray: Gt.inArray,
      extend: Gt.extend,
      walk: Gt.walk,
      resolve: Gt.resolve,
      explode: Gt.explode,
      _addCacheSuffix: Gt._addCacheSuffix
    }, IA = Gt.extend(Bg, Gee), qee = (e) => {
      try {
        o.exports = e;
      } catch {
      }
    };
    ((e) => {
      window.tinymce = e, window.tinyMCE = e;
    })(IA), qee(IA);
  })();
})(KEe);
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.ModelManager");
  const r = (m, b, C) => {
    var E;
    return C(m, b.prototype) ? !0 : ((E = m.constructor) === null || E === void 0 ? void 0 : E.name) === b.name;
  }, i = (m) => {
    const b = typeof m;
    return m === null ? "null" : b === "object" && Array.isArray(m) ? "array" : b === "object" && r(m, String, (C, E) => E.isPrototypeOf(C)) ? "string" : b;
  }, u = (m) => (b) => i(b) === m, h = (m) => (b) => typeof b === m, y = (m) => (b) => m === b, k = u("string"), _ = u("object"), D = u("array"), L = y(null), W = h("boolean"), se = y(void 0), J = (m) => m == null, be = (m) => !J(m), ke = h("function"), Ce = h("number"), Q = () => {
  }, oe = (m, b) => (...C) => m(b.apply(null, C)), ae = (m, b) => (C) => m(b(C)), G = (m) => () => m, ve = (m) => m, nt = (m, b) => m === b;
  function Xe(m, ...b) {
    return (...C) => {
      const E = b.concat(C);
      return m.apply(null, E);
    };
  }
  const te = (m) => (b) => !m(b), lt = (m) => () => {
    throw new Error(m);
  }, ot = (m) => m(), Kt = G(!1), je = G(!0);
  class ye {
    constructor(b, C) {
      this.tag = b, this.value = C;
    }
    static some(b) {
      return new ye(!0, b);
    }
    static none() {
      return ye.singletonNone;
    }
    fold(b, C) {
      return this.tag ? C(this.value) : b();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(b) {
      return this.tag ? ye.some(b(this.value)) : ye.none();
    }
    bind(b) {
      return this.tag ? b(this.value) : ye.none();
    }
    exists(b) {
      return this.tag && b(this.value);
    }
    forall(b) {
      return !this.tag || b(this.value);
    }
    filter(b) {
      return !this.tag || b(this.value) ? this : ye.none();
    }
    getOr(b) {
      return this.tag ? this.value : b;
    }
    or(b) {
      return this.tag ? this : b;
    }
    getOrThunk(b) {
      return this.tag ? this.value : b();
    }
    orThunk(b) {
      return this.tag ? this : b();
    }
    getOrDie(b) {
      if (this.tag)
        return this.value;
      throw new Error(b ?? "Called getOrDie on None");
    }
    static from(b) {
      return be(b) ? ye.some(b) : ye.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(b) {
      this.tag && b(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  ye.singletonNone = new ye(!1);
  const dn = Array.prototype.slice, wt = Array.prototype.indexOf, qe = Array.prototype.push, B = (m, b) => wt.call(m, b), mn = (m, b) => B(m, b) > -1, dt = (m, b) => {
    for (let C = 0, E = m.length; C < E; C++) {
      const N = m[C];
      if (b(N, C))
        return !0;
    }
    return !1;
  }, En = (m, b) => {
    const C = [];
    for (let E = 0; E < m; E++)
      C.push(b(E));
    return C;
  }, tn = (m, b) => {
    const C = m.length, E = new Array(C);
    for (let N = 0; N < C; N++) {
      const z = m[N];
      E[N] = b(z, N);
    }
    return E;
  }, Le = (m, b) => {
    for (let C = 0, E = m.length; C < E; C++) {
      const N = m[C];
      b(N, C);
    }
  }, jt = (m, b) => {
    for (let C = m.length - 1; C >= 0; C--) {
      const E = m[C];
      b(E, C);
    }
  }, Fn = (m, b) => {
    const C = [], E = [];
    for (let N = 0, z = m.length; N < z; N++) {
      const X = m[N];
      (b(X, N) ? C : E).push(X);
    }
    return {
      pass: C,
      fail: E
    };
  }, St = (m, b) => {
    const C = [];
    for (let E = 0, N = m.length; E < N; E++) {
      const z = m[E];
      b(z, E) && C.push(z);
    }
    return C;
  }, on = (m, b, C) => (jt(m, (E, N) => {
    C = b(C, E, N);
  }), C), tt = (m, b, C) => (Le(m, (E, N) => {
    C = b(C, E, N);
  }), C), mt = (m, b, C) => {
    for (let E = 0, N = m.length; E < N; E++) {
      const z = m[E];
      if (b(z, E))
        return ye.some(z);
      if (C(z, E))
        break;
    }
    return ye.none();
  }, Y = (m, b) => mt(m, b, Kt), Wo = (m, b) => {
    for (let C = 0, E = m.length; C < E; C++) {
      const N = m[C];
      if (b(N, C))
        return ye.some(C);
    }
    return ye.none();
  }, To = (m) => {
    const b = [];
    for (let C = 0, E = m.length; C < E; ++C) {
      if (!D(m[C]))
        throw new Error("Arr.flatten item " + C + " was not an array, input: " + m);
      qe.apply(b, m[C]);
    }
    return b;
  }, Ot = (m, b) => To(tn(m, b)), Mt = (m, b) => {
    for (let C = 0, E = m.length; C < E; ++C) {
      const N = m[C];
      if (b(N, C) !== !0)
        return !1;
    }
    return !0;
  }, zn = (m) => {
    const b = dn.call(m, 0);
    return b.reverse(), b;
  }, At = (m, b) => {
    const C = {};
    for (let E = 0, N = m.length; E < N; E++) {
      const z = m[E];
      C[String(z)] = b(z, E);
    }
    return C;
  }, $n = (m, b) => {
    const C = dn.call(m, 0);
    return C.sort(b), C;
  }, en = (m, b) => b >= 0 && b < m.length ? ye.some(m[b]) : ye.none(), Ue = (m) => en(m, 0), jn = (m) => en(m, m.length - 1), mo = (m, b) => {
    for (let C = 0; C < m.length; C++) {
      const E = b(m[C], C);
      if (E.isSome())
        return E;
    }
    return ye.none();
  }, xn = Object.keys, Vt = Object.hasOwnProperty, Ct = (m, b) => {
    const C = xn(m);
    for (let E = 0, N = C.length; E < N; E++) {
      const z = C[E], X = m[z];
      b(X, z);
    }
  }, Jn = (m, b) => Pn(m, (C, E) => ({
    k: E,
    v: b(C, E)
  })), Pn = (m, b) => {
    const C = {};
    return Ct(m, (E, N) => {
      const z = b(E, N);
      C[z.k] = z.v;
    }), C;
  }, so = (m) => (b, C) => {
    m[C] = b;
  }, pr = (m, b, C, E) => {
    Ct(m, (N, z) => {
      (b(N, z) ? C : E)(N, z);
    });
  }, nr = (m, b) => {
    const C = {};
    return pr(m, b, so(C), Q), C;
  }, Ko = (m, b) => {
    const C = [];
    return Ct(m, (E, N) => {
      C.push(b(E, N));
    }), C;
  }, Qo = (m) => Ko(m, ve), Mr = (m, b) => at(m, b) ? ye.from(m[b]) : ye.none(), at = (m, b) => Vt.call(m, b), kt = (m, b) => at(m, b) && m[b] !== void 0 && m[b] !== null, yn = (m) => {
    for (const b in m)
      if (Vt.call(m, b))
        return !1;
    return !0;
  }, pn = typeof window < "u" ? window : Function("return this;")(), Oo = (m, b) => {
    let C = b ?? pn;
    for (let E = 0; E < m.length && C !== void 0 && C !== null; ++E)
      C = C[m[E]];
    return C;
  }, hr = (m, b) => {
    const C = m.split(".");
    return Oo(C, b);
  }, or = (m, b) => hr(m, b), Ir = (m, b) => {
    const C = or(m, b);
    if (C == null)
      throw new Error(m + " not available on this browser");
    return C;
  }, Zo = Object.getPrototypeOf, Tr = (m) => Ir("HTMLElement", m), Ht = (m) => {
    const b = hr("ownerDocument.defaultView", m);
    return _(m) && (Tr(b).prototype.isPrototypeOf(m) || /^HTML\w*Element$/.test(Zo(m).constructor.name));
  }, Ho = 8, As = 9, ra = 11, qs = 1, Ks = 3, kr = (m) => m.dom.nodeName.toLowerCase(), xa = (m) => m.dom.nodeType, ca = (m) => (b) => xa(b) === m, Or = (m) => xa(m) === Ho || kr(m) === "#comment", Xn = (m) => Ss(m) && Ht(m.dom), Ss = ca(qs), Ke = ca(Ks), bt = ca(As), gn = ca(ra), Tn = (m) => (b) => Ss(b) && kr(b) === m, Po = (m, b, C) => {
    if (k(C) || W(C) || Ce(C))
      m.setAttribute(b, C + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", b, ":: Value ", C, ":: Element ", m), new Error("Attribute value was not simple");
  }, cr = (m, b, C) => {
    Po(m.dom, b, C);
  }, ea = (m, b) => {
    const C = m.dom;
    Ct(b, (E, N) => {
      Po(C, N, E);
    });
  }, ta = (m, b) => {
    Ct(b, (C, E) => {
      C.fold(() => {
        Oe(m, E);
      }, (N) => {
        Po(m.dom, E, N);
      });
    });
  }, Ps = (m, b) => {
    const C = m.dom.getAttribute(b);
    return C === null ? void 0 : C;
  }, Re = (m, b) => ye.from(Ps(m, b)), Oe = (m, b) => {
    m.dom.removeAttribute(b);
  }, ct = (m) => tt(m.dom.attributes, (b, C) => (b[C.name] = C.value, b), {}), _t = (m, b) => {
    const E = (b || document).createElement("div");
    if (E.innerHTML = m, !E.hasChildNodes() || E.childNodes.length > 1) {
      const N = "HTML does not have a single root node";
      throw console.error(N, m), new Error(N);
    }
    return Bo(E.childNodes[0]);
  }, Kn = (m, b) => {
    const E = (b || document).createElement(m);
    return Bo(E);
  }, io = (m, b) => {
    const E = (b || document).createTextNode(m);
    return Bo(E);
  }, Bo = (m) => {
    if (m == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: m };
  }, He = {
    fromHtml: _t,
    fromTag: Kn,
    fromText: io,
    fromDom: Bo,
    fromPoint: (m, b, C) => ye.from(m.dom.elementFromPoint(b, C)).map(Bo)
  }, Do = (m, b) => {
    const C = m.dom;
    if (C.nodeType !== qs)
      return !1;
    {
      const E = C;
      if (E.matches !== void 0)
        return E.matches(b);
      if (E.msMatchesSelector !== void 0)
        return E.msMatchesSelector(b);
      if (E.webkitMatchesSelector !== void 0)
        return E.webkitMatchesSelector(b);
      if (E.mozMatchesSelector !== void 0)
        return E.mozMatchesSelector(b);
      throw new Error("Browser lacks native selectors");
    }
  }, Ne = (m) => m.nodeType !== qs && m.nodeType !== As && m.nodeType !== ra || m.childElementCount === 0, Ie = (m, b) => {
    const C = b === void 0 ? document : b.dom;
    return Ne(C) ? [] : tn(C.querySelectorAll(m), He.fromDom);
  }, Bt = (m, b) => {
    const C = b === void 0 ? document : b.dom;
    return Ne(C) ? ye.none() : ye.from(C.querySelector(m)).map(He.fromDom);
  }, Wt = (m, b) => m.dom === b.dom, kn = (m, b) => {
    const C = m.dom, E = b.dom;
    return C === E ? !1 : C.contains(E);
  }, eo = Do, Gn = (m) => He.fromDom(m.dom.ownerDocument), qn = (m) => bt(m) ? m : Gn(m), Qn = (m) => He.fromDom(qn(m).dom.documentElement), lo = (m) => He.fromDom(qn(m).dom.defaultView), rr = (m) => ye.from(m.dom.parentNode).map(He.fromDom), Kr = (m) => ye.from(m.dom.parentElement).map(He.fromDom), Wa = (m, b) => {
    const C = ke(b) ? b : Kt;
    let E = m.dom;
    const N = [];
    for (; E.parentNode !== null && E.parentNode !== void 0; ) {
      const z = E.parentNode, X = He.fromDom(z);
      if (N.push(X), C(X) === !0)
        break;
      E = z;
    }
    return N;
  }, Ei = (m) => ye.from(m.dom.previousSibling).map(He.fromDom), Ti = (m) => ye.from(m.dom.nextSibling).map(He.fromDom), ko = (m) => tn(m.dom.childNodes, He.fromDom), Yo = (m, b) => {
    const C = m.dom.childNodes;
    return ye.from(C[b]).map(He.fromDom);
  }, Fr = (m) => Yo(m, 0), Ba = (m, b) => {
    rr(m).each((E) => {
      E.dom.insertBefore(b.dom, m.dom);
    });
  }, ua = (m, b) => {
    Ti(m).fold(() => {
      rr(m).each((N) => {
        es(N, b);
      });
    }, (E) => {
      Ba(E, b);
    });
  }, vs = (m, b) => {
    Fr(m).fold(() => {
      es(m, b);
    }, (E) => {
      m.dom.insertBefore(b.dom, E.dom);
    });
  }, es = (m, b) => {
    m.dom.appendChild(b.dom);
  }, ai = (m, b, C) => {
    Yo(m, C).fold(() => {
      es(m, b);
    }, (E) => {
      Ba(E, b);
    });
  }, vc = (m, b) => {
    Ba(m, b), es(b, m);
  }, Lr = (m, b) => {
    Le(b, (C, E) => {
      const N = E === 0 ? m : b[E - 1];
      ua(N, C);
    });
  }, ka = (m, b) => {
    Le(b, (C) => {
      es(m, C);
    });
  }, ii = (m) => {
    m.dom.textContent = "", Le(ko(m), (b) => {
      na(b);
    });
  }, na = (m) => {
    const b = m.dom;
    b.parentNode !== null && b.parentNode.removeChild(b);
  }, Oi = (m) => {
    const b = ko(m);
    b.length > 0 && Lr(m, b), na(m);
  }, cl = (m, b) => He.fromDom(m.dom.cloneNode(b)), Za = (m) => cl(m, !1), Ai = (m) => cl(m, !0), Ui = (m, b) => {
    const C = He.fromTag(b), E = ct(m);
    return ea(C, E), C;
  }, au = (m, b) => {
    const C = Ui(m, b), E = ko(Ai(m));
    return ka(C, E), C;
  }, gi = (m, b) => {
    const C = Ui(m, b);
    ua(m, C);
    const E = ko(m);
    return ka(C, E), na(m), C;
  }, Ml = [
    "tfoot",
    "thead",
    "tbody",
    "colgroup"
  ], $a = (m) => mn(Ml, m), Wi = (m, b) => ({
    rows: m,
    columns: b
  }), Kl = (m, b) => ({
    row: m,
    column: b
  }), yc = (m, b, C) => ({
    element: m,
    rowspan: b,
    colspan: C
  }), ld = (m, b, C, E) => ({
    element: m,
    rowspan: b,
    colspan: C,
    isNew: E
  }), iu = (m, b, C, E, N, z) => ({
    element: m,
    rowspan: b,
    colspan: C,
    row: E,
    column: N,
    isLocked: z
  }), bi = (m, b, C) => ({
    element: m,
    cells: b,
    section: C
  }), Ru = (m, b, C, E) => ({
    element: m,
    cells: b,
    section: C,
    isNew: E
  }), le = (m, b, C) => ({
    element: m,
    isNew: b,
    isLocked: C
  }), Ae = (m, b, C, E) => ({
    element: m,
    cells: b,
    section: C,
    isNew: E
  }), Ze = (m, b, C, E) => ({
    startRow: m,
    startCol: b,
    finishRow: C,
    finishCol: E
  }), Dt = (m, b, C) => ({
    element: m,
    colspan: b,
    column: C
  }), Yt = (m, b) => ({
    element: m,
    columns: b
  }), Wn = (m) => gn(m) && be(m.dom.host), lr = ke(Element.prototype.attachShadow) && ke(Node.prototype.getRootNode), yr = G(lr), Uo = lr ? (m) => He.fromDom(m.dom.getRootNode()) : qn, Yr = (m) => {
    const b = Uo(m);
    return Wn(b) ? ye.some(b) : ye.none();
  }, Ds = (m) => He.fromDom(m.dom.host), rn = (m) => {
    if (yr() && be(m.target)) {
      const b = He.fromDom(m.target);
      if (Ss(b) && cd(b) && m.composed && m.composedPath) {
        const C = m.composedPath();
        if (C)
          return Ue(C);
      }
    }
    return ye.from(m.target);
  }, cd = (m) => be(m.dom.shadowRoot), os = (m) => {
    const b = Ke(m) ? m.dom.parentNode : m.dom;
    if (b == null || b.ownerDocument === null)
      return !1;
    const C = b.ownerDocument;
    return Yr(He.fromDom(b)).fold(() => C.body.contains(b), ae(os, Ds));
  }, K = () => ge(He.fromDom(document)), ge = (m) => {
    const b = m.dom.body;
    if (b == null)
      throw new Error("Body is not available yet");
    return He.fromDom(b);
  }, Ee = (m, b, C) => St(Wa(m, C), b), ft = (m, b) => St(ko(m), b), Cn = (m, b) => {
    let C = [];
    return Le(ko(m), (E) => {
      b(E) && (C = C.concat([E])), C = C.concat(Cn(E, b));
    }), C;
  }, Jo = (m, b, C) => Ee(m, (E) => Do(E, b), C), Ln = (m, b) => ft(m, (C) => Do(C, b)), Rs = (m, b) => Ie(b, m);
  var Gt = (m, b, C, E, N) => m(C, E) ? ye.some(C) : ke(N) && N(C) ? ye.none() : b(C, E, N);
  const fs = (m, b, C) => {
    let E = m.dom;
    const N = ke(C) ? C : Kt;
    for (; E.parentNode; ) {
      E = E.parentNode;
      const z = He.fromDom(E);
      if (b(z))
        return ye.some(z);
      if (N(z))
        break;
    }
    return ye.none();
  }, vi = (m, b, C) => Gt((N, z) => z(N), fs, m, b, C), ks = (m, b) => {
    const C = (N) => b(He.fromDom(N));
    return Y(m.dom.childNodes, C).map(He.fromDom);
  }, ga = (m, b) => {
    const C = (E) => {
      for (let N = 0; N < E.childNodes.length; N++) {
        const z = He.fromDom(E.childNodes[N]);
        if (b(z))
          return ye.some(z);
        const X = C(E.childNodes[N]);
        if (X.isSome())
          return X;
      }
      return ye.none();
    };
    return C(m.dom);
  }, Il = (m, b, C) => fs(m, (E) => Do(E, b), C), xr = (m, b) => ks(m, (C) => Do(C, b)), yi = (m, b) => Bt(b, m), Ns = (m, b, C) => Gt((N, z) => Do(N, z), Il, m, b, C), xc = (m, b, C = nt) => m.exists((E) => C(E, b)), Bs = (m) => {
    const b = [], C = (E) => {
      b.push(E);
    };
    for (let E = 0; E < m.length; E++)
      m[E].each(C);
    return b;
  }, ud = (m, b) => m != null ? b(m) : ye.none(), vm = (m, b) => m ? ye.some(b) : ye.none(), Oh = (m, b) => m.substring(b), zs = (m, b, C) => b === "" || m.length >= b.length && m.substr(C, C + b.length) === b, Yl = (m, b) => Ga(m, b) ? Oh(m, b.length) : m, La = (m, b, C = 0, E) => {
    const N = m.indexOf(b, C);
    return N !== -1 ? se(E) ? !0 : N + b.length <= E : !1;
  }, Ga = (m, b) => zs(m, b, 0), xi = (m, b) => zs(m, b, m.length - b.length), gr = ((m) => (b) => b.replace(m, ""))(/^\s+|\s+$/g), Pi = (m) => m.length > 0, li = (m) => {
    const b = parseFloat(m);
    return isNaN(b) ? ye.none() : ye.some(b);
  }, pe = (m) => m.style !== void 0 && ke(m.style.getPropertyValue), Te = (m, b, C) => {
    if (!k(C))
      throw console.error("Invalid call to CSS.set. Property ", b, ":: Value ", C, ":: Element ", m), new Error("CSS value must be a string: " + C);
    pe(m) && m.style.setProperty(b, C);
  }, rt = (m, b) => {
    pe(m) && m.style.removeProperty(b);
  }, pt = (m, b, C) => {
    const E = m.dom;
    Te(E, b, C);
  }, to = (m, b) => {
    const C = m.dom;
    Ct(b, (E, N) => {
      Te(C, N, E);
    });
  }, sr = (m, b) => {
    const C = m.dom, N = window.getComputedStyle(C).getPropertyValue(b);
    return N === "" && !os(m) ? _s(C, b) : N;
  }, _s = (m, b) => pe(m) ? m.style.getPropertyValue(b) : "", Ha = (m, b) => {
    const C = m.dom, E = _s(C, b);
    return ye.from(E).filter((N) => N.length > 0);
  }, ur = (m, b) => {
    const C = m.dom;
    rt(C, b), xc(Re(m, "style").map(gr), "") && Oe(m, "style");
  }, _a = (m, b) => {
    const C = m.dom, E = b.dom;
    pe(C) && pe(E) && (E.style.cssText = C.style.cssText);
  }, Ms = (m, b, C = 0) => Re(m, b).map((E) => parseInt(E, 10)).getOr(C), da = (m, b) => Ms(m, b, 1), sa = (m) => Tn("col")(m) ? Ms(m, "span", 1) > 1 : da(m, "colspan") > 1, oa = (m) => da(m, "rowspan") > 1, ul = (m, b) => parseInt(sr(m, b), 10), wc = G(10), qa = G(10), dl = (m, b) => Mc(m, b, je), Mc = (m, b, C) => Ot(ko(m), (E) => Do(E, b) ? C(E) ? [E] : [] : Mc(E, b, C)), Ic = (m, b, C = Kt) => {
    if (C(b))
      return ye.none();
    if (mn(m, kr(b)))
      return ye.some(b);
    const E = (N) => Do(N, "table") || C(N);
    return Il(b, m.join(","), E);
  }, ip = (m, b) => Ic([
    "td",
    "th"
  ], m, b), dd = (m) => dl(m, "th,td"), Cc = (m) => Do(m, "colgroup") ? Ln(m, "col") : Ot(Af(m), (b) => Ln(b, "col")), Zi = (m, b) => Ns(m, "table", b), fd = (m) => dl(m, "tr"), Af = (m) => Zi(m).fold(G([]), (b) => Ln(b, "colgroup")), lu = (m, b) => tn(m, (C) => {
    if (kr(C) === "colgroup") {
      const E = tn(Cc(C), (N) => {
        const z = Ms(N, "span", 1);
        return yc(N, 1, z);
      });
      return bi(C, E, "colgroup");
    } else {
      const E = tn(dd(C), (N) => {
        const z = Ms(N, "rowspan", 1), X = Ms(N, "colspan", 1);
        return yc(N, z, X);
      });
      return bi(C, E, b(C));
    }
  }), Ah = (m) => rr(m).map((b) => {
    const C = kr(b);
    return $a(C) ? C : "tbody";
  }).getOr("tbody"), Pf = (m) => {
    const b = fd(m), E = [
      ...Af(m),
      ...b
    ];
    return lu(E, Ah);
  }, Ph = (m, b) => lu(m, () => b), Wd = (m) => {
    let b = !1, C;
    return (...E) => (b || (b = !0, C = m.apply(null, E)), C);
  }, Dh = (m, b, C, E) => {
    const N = m.isiOS() && /ipad/i.test(C) === !0, z = m.isiOS() && !N, X = m.isiOS() || m.isAndroid(), ue = X || E("(pointer:coarse)"), xe = N || !z && X && E("(min-device-width:768px)"), Fe = z || X && !xe, it = b.isSafari() && m.isiOS() && /safari/i.test(C) === !1, qt = !Fe && !xe && !it;
    return {
      isiPad: G(N),
      isiPhone: G(z),
      isTablet: G(xe),
      isPhone: G(Fe),
      isTouch: G(ue),
      isAndroid: m.isAndroid,
      isiOS: m.isiOS,
      isWebView: G(it),
      isDesktop: G(qt)
    };
  }, Zd = (m, b) => {
    for (let C = 0; C < m.length; C++) {
      const E = m[C];
      if (E.test(b))
        return E;
    }
  }, Sv = (m, b) => {
    const C = Zd(m, b);
    if (!C)
      return {
        major: 0,
        minor: 0
      };
    const E = (N) => Number(b.replace(C, "$" + N));
    return wl(E(1), E(2));
  }, Me = (m, b) => {
    const C = String(b).toLowerCase();
    return m.length === 0 ? ym() : Sv(m, C);
  }, ym = () => wl(0, 0), wl = (m, b) => ({
    major: m,
    minor: b
  }), Nu = {
    nu: wl,
    detect: Me,
    unknown: ym
  }, Rh = (m, b) => mo(b.brands, (C) => {
    const E = C.brand.toLowerCase();
    return Y(m, (N) => {
      var z;
      return E === ((z = N.brand) === null || z === void 0 ? void 0 : z.toLowerCase());
    }).map((N) => ({
      current: N.name,
      version: Nu.nu(parseInt(C.version, 10), 0)
    }));
  }), Wg = (m, b) => {
    const C = String(b).toLowerCase();
    return Y(m, (E) => E.search(C));
  }, zr = (m, b) => Wg(m, b).map((C) => {
    const E = Nu.detect(C.versionRegexes, b);
    return {
      current: C.name,
      version: E
    };
  }), Gi = (m, b) => Wg(m, b).map((C) => {
    const E = Nu.detect(C.versionRegexes, b);
    return {
      current: C.name,
      version: E
    };
  }), Fl = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, Ka = (m) => (b) => La(b, m), Gd = [
    {
      name: "Edge",
      versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
      search: (m) => La(m, "edge/") && La(m, "chrome") && La(m, "safari") && La(m, "applewebkit")
    },
    {
      name: "Chromium",
      brand: "Chromium",
      versionRegexes: [
        /.*?chrome\/([0-9]+)\.([0-9]+).*/,
        Fl
      ],
      search: (m) => La(m, "chrome") && !La(m, "chromeframe")
    },
    {
      name: "IE",
      versionRegexes: [
        /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
        /.*?rv:([0-9]+)\.([0-9]+).*/
      ],
      search: (m) => La(m, "msie") || La(m, "trident")
    },
    {
      name: "Opera",
      versionRegexes: [
        Fl,
        /.*?opera\/([0-9]+)\.([0-9]+).*/
      ],
      search: Ka("opera")
    },
    {
      name: "Firefox",
      versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
      search: Ka("firefox")
    },
    {
      name: "Safari",
      versionRegexes: [
        Fl,
        /.*?cpu os ([0-9]+)_([0-9]+).*/
      ],
      search: (m) => (La(m, "safari") || La(m, "mobile/")) && La(m, "applewebkit")
    }
  ], Fc = [
    {
      name: "Windows",
      search: Ka("win"),
      versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "iOS",
      search: (m) => La(m, "iphone") || La(m, "ipad"),
      versionRegexes: [
        /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
        /.*cpu os ([0-9]+)_([0-9]+).*/,
        /.*cpu iphone os ([0-9]+)_([0-9]+).*/
      ]
    },
    {
      name: "Android",
      search: Ka("android"),
      versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "macOS",
      search: Ka("mac os x"),
      versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    },
    {
      name: "Linux",
      search: Ka("linux"),
      versionRegexes: []
    },
    {
      name: "Solaris",
      search: Ka("sunos"),
      versionRegexes: []
    },
    {
      name: "FreeBSD",
      search: Ka("freebsd"),
      versionRegexes: []
    },
    {
      name: "ChromeOS",
      search: Ka("cros"),
      versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }
  ], Di = {
    browsers: G(Gd),
    oses: G(Fc)
  }, Bc = "Edge", Nh = "Chromium", Zg = "IE", Xl = "Opera", $c = "Firefox", lp = "Safari", qi = () => Ya({
    current: void 0,
    version: Nu.unknown()
  }), Ya = (m) => {
    const b = m.current, C = m.version, E = (N) => () => b === N;
    return {
      current: b,
      version: C,
      isEdge: E(Bc),
      isChromium: E(Nh),
      isIE: E(Zg),
      isOpera: E(Xl),
      isFirefox: E($c),
      isSafari: E(lp)
    };
  }, md = {
    unknown: qi,
    nu: Ya,
    edge: G(Bc),
    chromium: G(Nh),
    ie: G(Zg),
    opera: G(Xl),
    firefox: G($c),
    safari: G(lp)
  }, Df = "Windows", Sc = "iOS", wi = "Android", cp = "Linux", up = "macOS", dp = "Solaris", xm = "FreeBSD", Ql = "ChromeOS", fp = () => Gg({
    current: void 0,
    version: Nu.unknown()
  }), Gg = (m) => {
    const b = m.current, C = m.version, E = (N) => () => b === N;
    return {
      current: b,
      version: C,
      isWindows: E(Df),
      isiOS: E(Sc),
      isAndroid: E(wi),
      isMacOS: E(up),
      isLinux: E(cp),
      isSolaris: E(dp),
      isFreeBSD: E(xm),
      isChromeOS: E(Ql)
    };
  }, kv = {
    unknown: fp,
    nu: Gg,
    windows: G(Df),
    ios: G(Sc),
    android: G(wi),
    linux: G(cp),
    macos: G(up),
    solaris: G(dp),
    freebsd: G(xm),
    chromeos: G(Ql)
  }, mp = { detect: (m, b, C) => {
    const E = Di.browsers(), N = Di.oses(), z = b.bind((xe) => Rh(E, xe)).orThunk(() => zr(E, m)).fold(md.unknown, md.nu), X = Gi(N, m).fold(kv.unknown, kv.nu), ue = Dh(X, z, m, C);
    return {
      browser: z,
      os: X,
      deviceType: ue
    };
  } }, wm = (m) => window.matchMedia(m).matches;
  let Mu = Wd(() => mp.detect(navigator.userAgent, ye.from(navigator.userAgentData), wm));
  const Mh = () => Mu(), Is = (m, b) => {
    const C = (ue, xe) => {
      if (!Ce(xe) && !xe.match(/^[0-9]+$/))
        throw new Error(m + ".set accepts only positive integer values. Value was " + xe);
      const Fe = ue.dom;
      pe(Fe) && (Fe.style[m] = xe + "px");
    }, E = (ue) => {
      const xe = b(ue);
      if (xe <= 0 || xe === null) {
        const Fe = sr(ue, m);
        return parseFloat(Fe) || 0;
      }
      return xe;
    }, N = E, z = (ue, xe) => tt(xe, (Fe, it) => {
      const qt = sr(ue, it), _n = qt === void 0 ? 0 : parseInt(qt, 10);
      return isNaN(_n) ? Fe : Fe + _n;
    }, 0);
    return {
      set: C,
      get: E,
      getOuter: N,
      aggregate: z,
      max: (ue, xe, Fe) => {
        const it = z(ue, Fe);
        return xe > it ? xe - it : 0;
      }
    };
  }, aa = (m, b) => li(m).getOr(b), Cl = (m, b, C) => aa(sr(m, b), C), Ih = (m, b, C, E) => {
    const N = Cl(m, `padding-${C}`, 0), z = Cl(m, `padding-${E}`, 0), X = Cl(m, `border-${C}-width`, 0), ue = Cl(m, `border-${E}-width`, 0);
    return b - N - z - X - ue;
  }, Fh = (m, b) => {
    const C = m.dom, E = C.getBoundingClientRect().width || C.offsetWidth;
    return b === "border-box" ? E : Ih(m, E, "left", "right");
  }, Ra = (m) => Cl(m, "height", m.dom.offsetHeight), no = (m) => Cl(m, "width", m.dom.offsetWidth), cu = (m) => Fh(m, "content-box"), Kg = Is("width", (m) => m.dom.offsetWidth), za = (m) => Kg.get(m), ms = (m) => Kg.getOuter(m), qd = cu, Bh = no, pp = (m, b, C) => {
    const E = m.cells, N = E.slice(0, b), z = E.slice(b), X = N.concat(C).concat(z);
    return fa(m, X);
  }, hp = (m, b, C) => pp(m, b, [C]), zo = (m, b, C) => {
    const E = m.cells;
    E[b] = C;
  }, fa = (m, b) => Ae(m.element, b, m.section, m.isNew), Rf = (m, b) => {
    const C = m.cells, E = tn(C, b);
    return Ae(m.element, E, m.section, m.isNew);
  }, Sl = (m, b) => m.cells[b], fl = (m, b) => Sl(m, b).element, kl = (m) => m.cells.length, Na = (m) => {
    const b = Fn(m, (C) => C.section === "colgroup");
    return {
      rows: b.fail,
      cols: b.pass
    };
  }, Ki = (m, b, C) => {
    const E = tn(m.cells, C);
    return Ae(b(m.element), E, m.section, !0);
  }, Jl = "data-snooker-locked-cols", Cm = (m) => Re(m, Jl).bind((b) => ye.from(b.match(/\d+/g))).map((b) => At(b, je)), Ys = (m) => {
    const b = tt(Na(m).rows, (E, N) => (Le(N.cells, (z, X) => {
      z.isLocked && (E[X] = !0);
    }), E), {}), C = Ko(b, (E, N) => parseInt(N, 10));
    return $n(C);
  }, $h = (m, b) => m + "," + b, wa = (m, b, C) => ye.from(m.access[$h(b, C)]), pd = (m, b, C) => {
    const E = Lc(m, (N) => C(b, N.element));
    return E.length > 0 ? ye.some(E[0]) : ye.none();
  }, Lc = (m, b) => {
    const C = Ot(m.all, (E) => E.cells);
    return St(C, b);
  }, ys = (m) => {
    const b = {};
    let C = 0;
    return Le(m.cells, (E) => {
      const N = E.colspan;
      En(N, (z) => {
        const X = C + z;
        b[X] = Dt(E.element, N, X);
      }), C += N;
    }), b;
  }, Hc = (m) => {
    const b = {}, C = [], N = Ue(m).map((bn) => bn.element).bind(Zi).bind(Cm).getOr({});
    let z = 0, X = 0, ue = 0;
    const {
      pass: xe,
      fail: Fe
    } = Fn(m, (bn) => bn.section === "colgroup");
    Le(Fe, (bn) => {
      const ln = [];
      Le(bn.cells, (Zn) => {
        let Ut = 0;
        for (; b[$h(ue, Ut)] !== void 0; )
          Ut++;
        const un = kt(N, Ut.toString()), Co = iu(Zn.element, Zn.rowspan, Zn.colspan, ue, Ut, un);
        for (let wn = 0; wn < Zn.colspan; wn++)
          for (let Xr = 0; Xr < Zn.rowspan; Xr++) {
            const ws = ue + Xr, ps = Ut + wn, nl = $h(ws, ps);
            b[nl] = Co, X = Math.max(X, ps + 1);
          }
        ln.push(Co);
      }), z++, C.push(bi(bn.element, ln, bn.section)), ue++;
    });
    const { columns: it, colgroups: qt } = jn(xe).map((bn) => {
      const ln = ys(bn);
      return {
        colgroups: [Yt(bn.element, Qo(ln))],
        columns: ln
      };
    }).getOrThunk(() => ({
      colgroups: [],
      columns: {}
    }));
    return {
      grid: Wi(z, X),
      access: b,
      all: C,
      columns: it,
      colgroups: qt
    };
  }, dr = {
    fromTable: (m) => {
      const b = Pf(m);
      return Hc(b);
    },
    generate: Hc,
    getAt: wa,
    findItem: pd,
    filterItems: Lc,
    justCells: (m) => Ot(m.all, (b) => b.cells),
    justColumns: (m) => Qo(m.columns),
    hasColumns: (m) => xn(m.columns).length > 0,
    getColumnAt: (m, b) => ye.from(m.columns[b])
  }, Kd = (m, b = je) => {
    const C = m.grid, E = En(C.columns, ve), N = En(C.rows, ve);
    return tn(E, (z) => Sm(() => Ot(N, (Fe) => dr.getAt(m, Fe, z).filter((it) => it.column === z).toArray()), (Fe) => Fe.colspan === 1 && b(Fe.element), () => dr.getAt(m, 0, z)));
  }, Sm = (m, b, C) => {
    const E = m();
    return Y(E, b).orThunk(() => ye.from(E[0]).orThunk(C)).map((X) => X.element);
  }, gp = (m) => {
    const b = m.grid, C = En(b.rows, ve), E = En(b.columns, ve);
    return tn(C, (N) => Sm(() => Ot(E, (xe) => dr.getAt(m, N, xe).filter((Fe) => Fe.row === N).fold(G([]), (Fe) => [Fe])), (xe) => xe.rowspan === 1, () => dr.getAt(m, N, 0)));
  }, Yg = (m, b) => {
    if (b < 0 || b >= m.length - 1)
      return ye.none();
    const C = m[b].fold(() => {
      const N = zn(m.slice(0, b));
      return mo(N, (z, X) => z.map((ue) => ({
        value: ue,
        delta: X + 1
      })));
    }, (N) => ye.some({
      value: N,
      delta: 0
    })), E = m[b + 1].fold(() => {
      const N = m.slice(b + 1);
      return mo(N, (z, X) => z.map((ue) => ({
        value: ue,
        delta: X + 1
      })));
    }, (N) => ye.some({
      value: N,
      delta: 1
    }));
    return C.bind((N) => E.map((z) => {
      const X = z.delta + N.delta;
      return Math.abs(z.value - N.value) / X;
    }));
  }, bp = (m, b) => (C) => Xg(C) === "rtl" ? b : m, Xg = (m) => sr(m, "direction") === "rtl" ? "rtl" : "ltr", R = Is("height", (m) => {
    const b = m.dom;
    return os(m) ? b.getBoundingClientRect().height : b.offsetHeight;
  }), V = (m) => R.get(m), re = (m) => R.getOuter(m), Pe = Ra, $e = (m, b) => ({
    left: m,
    top: b,
    translate: (E, N) => $e(m + E, b + N)
  }), $t = $e, vo = (m) => {
    const b = m.getBoundingClientRect();
    return $t(b.left, b.top);
  }, $o = (m, b) => m !== void 0 ? m : b !== void 0 ? b : 0, Mo = (m) => {
    const b = m.dom.ownerDocument, C = b.body, E = b.defaultView, N = b.documentElement;
    if (C === m.dom)
      return $t(C.offsetLeft, C.offsetTop);
    const z = $o(E == null ? void 0 : E.pageYOffset, N.scrollTop), X = $o(E == null ? void 0 : E.pageXOffset, N.scrollLeft), ue = $o(N.clientTop, C.clientTop), xe = $o(N.clientLeft, C.clientLeft);
    return bo(m).translate(X - xe, z - ue);
  }, bo = (m) => {
    const b = m.dom, E = b.ownerDocument.body;
    return E === b ? $t(E.offsetLeft, E.offsetTop) : os(m) ? vo(b) : $t(0, 0);
  }, Vs = (m, b) => ({
    row: m,
    y: b
  }), ma = (m, b) => ({
    col: m,
    x: b
  }), _l = (m) => Mo(m).left + ms(m), ba = (m) => Mo(m).left, Qg = (m, b) => ma(m, ba(b)), P0 = (m, b) => ma(m, _l(b)), _v = (m) => Mo(m).top, Ri = (m, b) => Vs(m, _v(b)), Jg = (m, b) => Vs(m, _v(b) + re(b)), Xa = (m, b, C) => {
    if (C.length === 0)
      return [];
    const E = tn(C.slice(1), (z, X) => z.map((ue) => m(X, ue))), N = C[C.length - 1].map((z) => b(C.length - 1, z));
    return E.concat([N]);
  }, Ev = (m) => -m, Ni = {
    delta: ve,
    positions: (m) => Xa(Ri, Jg, m),
    edge: _v
  }, vp = bp({
    delta: ve,
    edge: ba,
    positions: (m) => Xa(Qg, P0, m)
  }, {
    delta: Ev,
    edge: _l,
    positions: (m) => Xa(P0, Qg, m)
  }), yp = {
    delta: (m, b) => vp(b).delta(m, b),
    positions: (m, b) => vp(b).positions(m, b),
    edge: (m) => vp(m).edge(m)
  }, D0 = {
    unsupportedLength: [
      "em",
      "ex",
      "cap",
      "ch",
      "ic",
      "rem",
      "lh",
      "rlh",
      "vw",
      "vh",
      "vi",
      "vb",
      "vmin",
      "vmax",
      "cm",
      "mm",
      "Q",
      "in",
      "pc",
      "pt",
      "px"
    ],
    fixed: [
      "px",
      "pt"
    ],
    relative: ["%"],
    empty: [""]
  }, Tv = (() => {
    const m = "[0-9]+", C = "[eE]" + ("[+-]?" + m), E = "\\.", N = (ue) => `(?:${ue})?`, X = `[+-]?(?:${[
      "Infinity",
      m + E + N(m) + N(C),
      E + m + N(C),
      m + N(C)
    ].join("|")})`;
    return new RegExp(`^(${X})(.*)$`);
  })(), uu = (m, b) => dt(b, (C) => dt(D0[C], (E) => m === E)), gd = (m, b) => ye.from(Tv.exec(m)).bind((E) => {
    const N = Number(E[1]), z = E[2];
    return uu(z, b) ? ye.some({
      value: N,
      unit: z
    }) : ye.none();
  }), Mf = /(\d+(\.\d+)?)%/, On = /(\d+(\.\d+)?)px|em/, kc = Tn("col"), Ov = Tn("tr"), km = (m, b, C) => {
    const E = Kr(m).getOrThunk(() => ge(Gn(m)));
    return b(m) / C(E) * 100;
  }, du = (m, b) => {
    pt(m, "width", b + "px");
  }, Lh = (m, b) => {
    pt(m, "width", b + "%");
  }, If = (m, b) => {
    pt(m, "height", b + "px");
  }, _m = (m) => {
    ur(m, "height");
  }, Hh = (m) => Pe(m) + "px", Fu = (m, b, C, E) => {
    const N = Zi(m).map((z) => {
      const X = C(z);
      return Math.floor(b / 100 * X);
    }).getOr(b);
    return E(m, N), N;
  }, R0 = (m, b, C, E) => {
    const N = parseFloat(m);
    return xi(m, "%") && kr(b) !== "table" ? Fu(b, N, C, E) : N;
  }, ia = (m) => {
    const b = Hh(m);
    return b ? R0(b, m, V, If) : V(m);
  }, Zt = (m, b, C) => {
    const E = C(m), N = da(m, b);
    return E / N;
  }, El = (m, b) => Ha(m, b).orThunk(() => Re(m, b).map((C) => C + "px")), Bu = (m) => El(m, "width"), ci = (m) => El(m, "height"), xp = (m) => km(m, za, qd), Qa = (m) => kc(m) ? za(m) : Bh(m), Wr = (m) => Ov(m) ? V(m) : Zt(m, "rowspan", ia), eb = (m) => Bu(m).bind((C) => gd(C, [
    "fixed",
    "relative",
    "empty"
  ])), Rt = (m, b, C) => {
    pt(m, "width", b + C);
  }, Vr = (m) => za(m) + "px", tb = (m) => V(m) + "px", Va = (m) => km(m, za, qd) + "%", Yi = (m) => Bu(m).exists((b) => Mf.test(b)), Nw = (m) => Bu(m).exists((b) => On.test(b)), _c = (m) => Bu(m).isNone(), Mw = G(Mf), Yd = Tn("col"), N0 = (m) => Bu(m).getOrThunk(() => Qa(m) + "px"), Ec = (m) => ci(m).getOrThunk(() => Wr(m) + "px"), jr = (m) => tn(dr.justColumns(m), (b) => ye.from(b.element)), bd = (m) => {
    const b = Mh().browser, C = b.isChromium() || b.isFirefox();
    return Yd(m) ? C : !0;
  }, Em = (m, b, C, E, N, z) => m.filter(E).fold(() => z(Yg(C, b)), (X) => N(X)), ja = (m, b, C, E) => {
    const N = Kd(m), z = dr.hasColumns(m) ? jr(m) : N, X = [ye.some(yp.edge(b))].concat(tn(yp.positions(N, b), (xe) => xe.map((Fe) => Fe.x))), ue = te(sa);
    return tn(z, (xe, Fe) => Em(xe, Fe, X, ue, (it) => {
      if (bd(it))
        return C(it);
      {
        const qt = ud(N[Fe], ve);
        return Em(qt, Fe, X, ue, (_n) => E(ye.some(za(_n))), E);
      }
    }, E));
  }, Av = (m) => m.map((b) => b + "px").getOr(""), vd = (m, b) => ja(m, b, N0, Av), $u = (m, b, C) => ja(m, b, xp, (E) => E.fold(() => C.minCellWidth(), (N) => N / C.pixelWidth() * 100)), Es = (m, b, C) => ja(m, b, Qa, (E) => E.getOrThunk(C.minCellWidth)), wp = (m, b, C, E) => {
    const N = gp(m), z = tn(m.all, (ue) => ye.some(ue.element)), X = [ye.some(Ni.edge(b))].concat(tn(Ni.positions(N, b), (ue) => ue.map((xe) => xe.y)));
    return tn(z, (ue, xe) => Em(ue, xe, X, je, C, E));
  }, Qe = (m, b) => wp(m, b, Wr, (C) => C.getOrThunk(qa)), Vc = (m, b) => wp(m, b, Ec, Av), Cp = (m, b) => () => os(m) ? b(m) : parseFloat(Ha(m, "width").getOr("0")), Mi = (m) => {
    const b = Cp(m, za), C = G(0);
    return {
      width: b,
      pixelWidth: b,
      getWidths: (N, z) => Es(N, m, z),
      getCellDelta: C,
      singleColumnWidth: G([0]),
      minCellWidth: C,
      setElementWidth: Q,
      adjustTableWidth: Q,
      isRelative: !0,
      label: "none"
    };
  }, fu = (m) => {
    const b = Cp(m, (xe) => parseFloat(Va(xe))), C = Cp(m, za);
    return {
      width: b,
      pixelWidth: C,
      getWidths: (xe, Fe) => $u(xe, m, Fe),
      getCellDelta: (xe) => xe / C() * 100,
      singleColumnWidth: (xe, Fe) => [100 - xe],
      minCellWidth: () => wc() / C() * 100,
      setElementWidth: Lh,
      adjustTableWidth: (xe) => {
        const Fe = b(), it = xe / 100 * Fe, qt = Fe + it;
        Lh(m, qt);
      },
      isRelative: !0,
      label: "percent"
    };
  }, Ea = (m) => {
    const b = Cp(m, za);
    return {
      width: b,
      pixelWidth: b,
      getWidths: (X, ue) => Es(X, m, ue),
      getCellDelta: ve,
      singleColumnWidth: (X, ue) => [Math.max(wc(), X + ue) - X],
      minCellWidth: wc,
      setElementWidth: du,
      adjustTableWidth: (X) => {
        const ue = b() + X;
        du(m, ue);
      },
      isRelative: !1,
      label: "pixel"
    };
  }, Ca = (m, b) => Mw().exec(b) !== null ? fu(m) : Ea(m), I = {
    getTableSize: (m) => Bu(m).fold(() => Mi(m), (C) => Ca(m, C)),
    pixelSize: Ea,
    percentageSize: fu,
    noneSize: Mi
  }, ee = (m, b, C, E, N, z) => ({
    minRow: m,
    minCol: b,
    maxRow: C,
    maxCol: E,
    allCells: N,
    selectedCells: z
  }), he = (m, b) => {
    const C = m.grid.columns;
    let N = m.grid.rows, z = C, X = 0, ue = 0;
    const xe = [], Fe = [];
    return Ct(m.access, (it) => {
      if (xe.push(it), b(it)) {
        Fe.push(it);
        const qt = it.row, _n = qt + it.rowspan - 1, bn = it.column, ln = bn + it.colspan - 1;
        qt < N ? N = qt : _n > X && (X = _n), bn < z ? z = bn : ln > ue && (ue = ln);
      }
    }), ee(N, z, X, ue, xe, Fe);
  }, Be = (m, b, C) => {
    const E = m[C].element, N = He.fromTag("td");
    es(N, He.fromTag("br")), (b ? es : vs)(E, N);
  }, Pt = (m, b, C, E) => {
    const N = St(m, (ue) => ue.section !== "colgroup"), z = b.grid.columns, X = b.grid.rows;
    for (let ue = 0; ue < X; ue++) {
      let xe = !1;
      for (let Fe = 0; Fe < z; Fe++)
        ue < C.minRow || ue > C.maxRow || Fe < C.minCol || Fe > C.maxCol || (dr.getAt(b, ue, Fe).filter(E).isNone() ? Be(N, xe, ue) : xe = !0);
    }
  }, sn = (m, b, C, E) => {
    Ct(C.columns, (X) => {
      (X.column < b.minCol || X.column > b.maxCol) && na(X.element);
    });
    const N = St(dl(m, "tr"), (X) => X.dom.childElementCount === 0);
    Le(N, na), (b.minCol === b.maxCol || b.minRow === b.maxRow) && Le(dl(m, "th,td"), (X) => {
      Oe(X, "rowspan"), Oe(X, "colspan");
    }), Oe(m, Jl), Oe(m, "data-snooker-col-series"), I.getTableSize(m).adjustTableWidth(E);
  }, Hn = (m, b, C, E) => {
    if (E.minCol === 0 && b.grid.columns === E.maxCol + 1)
      return 0;
    const N = Es(b, m, C), z = tt(N, (Fe, it) => Fe + it, 0), xe = tt(N.slice(E.minCol, E.maxCol + 1), (Fe, it) => Fe + it, 0) / z * C.pixelWidth() - C.pixelWidth();
    return C.getCellDelta(xe);
  }, Ro = (m, b) => {
    const C = (_n) => Do(_n.element, b), E = Ai(m), N = Pf(E), z = I.getTableSize(m), X = dr.generate(N), ue = he(X, C), xe = "th:not(" + b + "),td:not(" + b + ")", Fe = Mc(E, "th,td", (_n) => Do(_n, xe));
    Le(Fe, na), Pt(N, X, ue, C);
    const it = dr.fromTable(m), qt = Hn(m, it, z, ue);
    return sn(E, ue, X, qt), E;
  }, ar = "", Zr = ((m, b) => {
    const C = (z) => {
      if (!m(z))
        throw new Error("Can only get " + b + " value of a " + b + " node");
      return E(z).getOr("");
    }, E = (z) => m(z) ? ye.from(z.dom.nodeValue) : ye.none();
    return {
      get: C,
      getOption: E,
      set: (z, X) => {
        if (!m(z))
          throw new Error("Can only set raw " + b + " value of a " + b + " node");
        z.dom.nodeValue = X;
      }
    };
  })(Ke, "text"), $s = (m) => Zr.get(m), tc = (m) => Zr.getOption(m), yd = (m, b) => Zr.set(m, b), ml = (m) => kr(m) === "img" ? 1 : tc(m).fold(() => ko(m).length, (b) => b.length), xd = (m) => tc(m).filter((b) => b.trim().length !== 0 || b.indexOf(ar) > -1).isSome(), Ff = (m) => Xn(m) && Ps(m, "contenteditable") === "false", Lu = [
    "img",
    "br"
  ], Sp = (m) => xd(m) || mn(Lu, kr(m)) || Ff(m), jc = (m) => ga(m, Sp), nb = (m) => zh(m, Sp), zh = (m, b) => {
    const C = (E) => {
      const N = ko(E);
      for (let z = N.length - 1; z >= 0; z--) {
        const X = N[z];
        if (b(X))
          return ye.some(X);
        const ue = C(X);
        if (ue.isSome())
          return ue;
      }
      return ye.none();
    };
    return C(m);
  }, ob = {
    scope: [
      "row",
      "col"
    ]
  }, rb = (m) => () => {
    const b = He.fromTag("td", m.dom);
    return es(b, He.fromTag("br", m.dom)), b;
  }, ui = (m) => () => He.fromTag("col", m.dom), wr = (m) => () => He.fromTag("colgroup", m.dom), Xs = (m) => () => He.fromTag("tr", m.dom), Ja = (m, b, C) => {
    const E = au(m, b);
    return Ct(C, (N, z) => {
      N === null ? Oe(E, z) : cr(E, z, N);
    }), E;
  }, Tc = (m) => m, nc = (m, b, C) => jc(m).map((N) => {
    const z = C.join(","), X = Jo(N, z, (ue) => Wt(ue, m));
    return on(X, (ue, xe) => {
      const Fe = Za(xe);
      return es(ue, Fe), Fe;
    }, b);
  }).getOr(b), sb = (m, b) => {
    Ct(ob, (C, E) => Re(m, E).filter((N) => mn(C, N)).each((N) => cr(b, E, N)));
  }, wd = (m, b, C) => {
    const E = (X, ue) => {
      _a(X.element, ue), ur(ue, "height"), X.colspan !== 1 && ur(ue, "width");
    }, N = (X) => {
      const ue = He.fromTag(kr(X.element), b.dom), xe = C.getOr([
        "strong",
        "em",
        "b",
        "i",
        "span",
        "font",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "p",
        "div"
      ]), Fe = xe.length > 0 ? nc(X.element, ue, xe) : ue;
      return es(Fe, He.fromTag("br")), E(X, ue), sb(X.element, ue), m(X.element, ue), ue;
    };
    return {
      col: (X) => {
        const ue = He.fromTag(kr(X.element), b.dom);
        return E(X, ue), m(X.element, ue), ue;
      },
      colgroup: wr(b),
      row: Xs(b),
      cell: N,
      replace: Ja,
      colGap: ui(b),
      gap: rb(b)
    };
  }, Tm = (m) => ({
    col: ui(m),
    colgroup: wr(m),
    row: Xs(m),
    cell: rb(m),
    replace: Tc,
    colGap: ui(m),
    gap: rb(m)
  }), Bf = (m, b) => {
    const E = document.createElement("div");
    return E.innerHTML = m, ko(He.fromDom(E));
  }, Xd = (m) => tn(m, He.fromDom), $f = (m) => (b) => b.options.get(m), Cd = "100%", Pv = (m) => {
    var b;
    const C = m.dom, E = (b = C.getParent(m.selection.getStart(), C.isBlock)) !== null && b !== void 0 ? b : m.getBody();
    return qd(He.fromDom(E)) + "px";
  }, Lf = (m, b) => Hu(m) || !Dv(m) ? b : Om(m) ? {
    ...b,
    width: Pv(m)
  } : {
    ...b,
    width: Cd
  }, ab = (m, b) => Hu(m) || Dv(m) ? b : Om(m) ? {
    ...b,
    width: Pv(m)
  } : {
    ...b,
    width: Cd
  }, Vh = (m) => {
    const b = m.options.register;
    b("table_clone_elements", { processor: "string[]" }), b("table_use_colgroups", {
      processor: "boolean",
      default: !0
    }), b("table_header_type", {
      processor: (C) => {
        const E = mn([
          "section",
          "cells",
          "sectionCells",
          "auto"
        ], C);
        return E ? {
          value: C,
          valid: E
        } : {
          valid: !1,
          message: "Must be one of: section, cells, sectionCells or auto."
        };
      },
      default: "section"
    }), b("table_sizing_mode", {
      processor: "string",
      default: "auto"
    }), b("table_default_attributes", {
      processor: "object",
      default: { border: "1" }
    }), b("table_default_styles", {
      processor: "object",
      default: { "border-collapse": "collapse" }
    }), b("table_column_resizing", {
      processor: (C) => {
        const E = mn([
          "preservetable",
          "resizetable"
        ], C);
        return E ? {
          value: C,
          valid: E
        } : {
          valid: !1,
          message: "Must be preservetable, or resizetable."
        };
      },
      default: "preservetable"
    }), b("table_resize_bars", {
      processor: "boolean",
      default: !0
    }), b("table_style_by_css", {
      processor: "boolean",
      default: !0
    }), b("table_merge_content_on_paste", {
      processor: "boolean",
      default: !0
    });
  }, zk = (m) => ye.from(m.options.get("table_clone_elements")), Qd = (m) => {
    const b = m.options.get("object_resizing");
    return mn(b.split(","), "table");
  }, Vk = $f("table_header_type"), Iw = $f("table_column_resizing"), Ta = (m) => Iw(m) === "preservetable", M0 = (m) => Iw(m) === "resizetable", Jd = $f("table_sizing_mode"), kp = (m) => Jd(m) === "relative", Om = (m) => Jd(m) === "fixed", Hu = (m) => Jd(m) === "responsive", zu = $f("table_resize_bars"), Dv = $f("table_style_by_css"), ef = $f("table_merge_content_on_paste"), Tl = (m) => {
    const b = m.options, C = b.get("table_default_attributes");
    return b.isSet("table_default_attributes") ? C : ab(m, C);
  }, Rv = (m) => {
    const b = m.options, C = b.get("table_default_styles");
    return b.isSet("table_default_styles") ? C : Lf(m, C);
  }, Fw = $f("table_use_colgroups"), Nv = (m) => Ns(m, "[contenteditable]"), Mv = (m, b = !1) => os(m) ? m.dom.isContentEditable : Nv(m).fold(G(b), (C) => Bw(C) === "true"), Bw = (m) => m.dom.contentEditable, jh = (m) => He.fromDom(m.getBody()), tf = (m) => (b) => Wt(b, jh(m)), oc = (m) => {
    Oe(m, "data-mce-style");
    const b = (C) => Oe(C, "data-mce-style");
    Le(dd(m), b), Le(Cc(m), b), Le(fd(m), b);
  }, Vu = (m) => He.fromDom(m.selection.getStart()), _p = (m) => m.getBoundingClientRect().width, $w = (m) => m.getBoundingClientRect().height, Uh = (m) => (b, C) => {
    const E = b.dom.getStyle(C, m) || b.dom.getAttrib(C, m);
    return ye.from(E).filter(Pi);
  }, Lw = Uh("width"), jk = Uh("height"), Uk = (m) => /^(\d+(\.\d+)?)%$/.test(m), Wk = (m) => /^(\d+(\.\d+)?)px$/.test(m), Ep = (m) => vi(m, Tn("table")).exists(Mv), Wh = (m, b) => {
    const C = b.column, E = b.column + b.colspan - 1, N = b.row, z = b.row + b.rowspan - 1;
    return C <= m.finishCol && E >= m.startCol && N <= m.finishRow && z >= m.startRow;
  }, tr = (m, b) => b.column >= m.startCol && b.column + b.colspan - 1 <= m.finishCol && b.row >= m.startRow && b.row + b.rowspan - 1 <= m.finishRow, po = (m, b) => {
    let C = !0;
    const E = Xe(tr, b);
    for (let N = b.startRow; N <= b.finishRow; N++)
      for (let z = b.startCol; z <= b.finishCol; z++)
        C = C && dr.getAt(m, N, z).exists(E);
    return C ? ye.some(b) : ye.none();
  }, Tp = (m, b) => Ze(Math.min(m.row, b.row), Math.min(m.column, b.column), Math.max(m.row + m.rowspan - 1, b.row + b.rowspan - 1), Math.max(m.column + m.colspan - 1, b.column + b.colspan - 1)), Iv = (m, b, C) => {
    const E = dr.findItem(m, b, Wt), N = dr.findItem(m, C, Wt);
    return E.bind((z) => N.map((X) => Tp(z, X)));
  }, I0 = (m, b, C) => Iv(m, b, C).bind((E) => po(m, E)), Hw = (m, b, C, E) => dr.findItem(m, b, Wt).bind((N) => {
    const z = C > 0 ? N.row + N.rowspan - 1 : N.row, X = E > 0 ? N.column + N.colspan - 1 : N.column;
    return dr.getAt(m, z + C, X + E).map((xe) => xe.element);
  }), Hf = (m, b, C) => Iv(m, b, C).map((E) => {
    const N = dr.filterItems(m, Xe(Wh, E));
    return tn(N, (z) => z.element);
  }), js = (m, b) => {
    const C = (E, N) => kn(N, E);
    return dr.findItem(m, b, C).map((E) => E.element);
  }, Zk = (m, b, C) => Zi(m).bind((E) => {
    const N = Zh(E);
    return Hw(N, m, b, C);
  }), zw = (m, b, C) => {
    const E = Zh(m);
    return Hf(E, b, C);
  }, F0 = (m, b, C, E, N) => {
    const z = Zh(m), X = Wt(m, C) ? ye.some(b) : js(z, b), ue = Wt(m, N) ? ye.some(E) : js(z, E);
    return X.bind((xe) => ue.bind((Fe) => Hf(z, xe, Fe)));
  }, It = (m, b, C) => {
    const E = Zh(m);
    return I0(E, b, C);
  }, Zh = dr.fromTable;
  var X3 = [
    "body",
    "p",
    "div",
    "article",
    "aside",
    "figcaption",
    "figure",
    "footer",
    "header",
    "nav",
    "section",
    "ol",
    "ul",
    "li",
    "table",
    "thead",
    "tbody",
    "tfoot",
    "caption",
    "tr",
    "td",
    "th",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "blockquote",
    "pre",
    "address"
  ], Op = () => {
    const m = (Fe) => He.fromDom(Fe.dom.cloneNode(!1)), b = (Fe) => qn(Fe).dom, C = (Fe) => Ss(Fe) ? kr(Fe) === "body" ? !0 : mn(X3, kr(Fe)) : !1, E = (Fe) => Ss(Fe) ? mn([
      "br",
      "img",
      "hr",
      "input"
    ], kr(Fe)) : !1, N = (Fe) => Ss(Fe) && Ps(Fe, "contenteditable") === "false", z = (Fe, it) => Fe.dom.compareDocumentPosition(it.dom), X = (Fe, it) => {
      const qt = ct(Fe);
      ea(it, qt);
    }, ue = (Fe) => {
      const it = kr(Fe);
      return mn([
        "script",
        "noscript",
        "iframe",
        "noframes",
        "noembed",
        "title",
        "style",
        "textarea",
        "xmp"
      ], it);
    }, xe = (Fe) => Ss(Fe) ? Re(Fe, "lang") : ye.none();
    return {
      up: G({
        selector: Il,
        closest: Ns,
        predicate: fs,
        all: Wa
      }),
      down: G({
        selector: Rs,
        predicate: Cn
      }),
      styles: G({
        get: sr,
        getRaw: Ha,
        set: pt,
        remove: ur
      }),
      attrs: G({
        get: Ps,
        set: cr,
        remove: Oe,
        copyTo: X
      }),
      insert: G({
        before: Ba,
        after: ua,
        afterAll: Lr,
        append: es,
        appendAll: ka,
        prepend: vs,
        wrap: vc
      }),
      remove: G({
        unwrap: Oi,
        remove: na
      }),
      create: G({
        nu: He.fromTag,
        clone: m,
        text: He.fromText
      }),
      query: G({
        comparePosition: z,
        prevSibling: Ei,
        nextSibling: Ti
      }),
      property: G({
        children: ko,
        name: kr,
        parent: rr,
        document: b,
        isText: Ke,
        isComment: Or,
        isElement: Ss,
        isSpecial: ue,
        getLanguage: xe,
        getText: $s,
        setText: yd,
        isBoundary: C,
        isEmptyTag: E,
        isNonEditable: N
      }),
      eq: Wt,
      is: eo
    };
  };
  const Q3 = (m, b, C, E) => {
    const N = C[0], z = C.slice(1);
    return E(m, b, N, z);
  }, Gh = (m, b, C) => C.length > 0 ? Q3(m, b, C, Vw) : ye.none(), Vw = (m, b, C, E) => {
    const N = b(m, C);
    return on(E, (z, X) => {
      const ue = b(m, X);
      return nf(m, z, ue);
    }, N);
  }, nf = (m, b, C) => b.bind((E) => C.filter(Xe(m.eq, E))), jw = (m, b) => Xe(m.eq, b), ib = (m, b, C, E = Kt) => {
    const N = [b].concat(m.up().all(b)), z = [C].concat(m.up().all(C)), X = (it) => Wo(it, E).fold(() => it, (_n) => it.slice(0, _n + 1)), ue = X(N), xe = X(z), Fe = Y(ue, (it) => dt(xe, jw(m, it)));
    return {
      firstpath: ue,
      secondpath: xe,
      shared: Fe
    };
  }, Qs = Gh, zf = ib, Gk = Op(), Sd = (m, b) => Qs(Gk, (C, E) => m(E), b), Uw = (m, b, C) => zf(Gk, m, b, C), Fv = (m) => Il(m, "table"), lb = (m, b, C) => {
    const E = (N) => (z) => C !== void 0 && C(z) || Wt(z, N);
    return Wt(m, b) ? ye.some({
      boxes: ye.some([m]),
      start: m,
      finish: b
    }) : Fv(m).bind((N) => Fv(b).bind((z) => {
      if (Wt(N, z))
        return ye.some({
          boxes: zw(N, m, b),
          start: m,
          finish: b
        });
      if (kn(N, z)) {
        const X = Jo(b, "td,th", E(N)), ue = X.length > 0 ? X[X.length - 1] : b;
        return ye.some({
          boxes: F0(N, m, N, b, z),
          start: m,
          finish: ue
        });
      } else if (kn(z, N)) {
        const X = Jo(m, "td,th", E(z)), ue = X.length > 0 ? X[X.length - 1] : m;
        return ye.some({
          boxes: F0(z, m, N, b, z),
          start: m,
          finish: ue
        });
      } else
        return Uw(m, b).shared.bind((X) => Ns(X, "table", C).bind((ue) => {
          const xe = Jo(b, "td,th", E(ue)), Fe = xe.length > 0 ? xe[xe.length - 1] : b, it = Jo(m, "td,th", E(ue)), qt = it.length > 0 ? it[it.length - 1] : m;
          return ye.some({
            boxes: F0(ue, m, N, b, z),
            start: qt,
            finish: Fe
          });
        }));
    }));
  }, Bv = (m, b) => {
    const C = Rs(m, b);
    return C.length > 0 ? ye.some(C) : ye.none();
  }, Uc = (m, b) => Y(m, (C) => Do(C, b)), qk = (m, b, C) => yi(m, b).bind((E) => yi(m, C).bind((N) => Sd(Fv, [
    E,
    N
  ]).map((z) => ({
    first: E,
    last: N,
    table: z
  })))), $v = (m, b) => Il(m, "table").bind((C) => yi(C, b).bind((E) => lb(E, m).bind((N) => N.boxes.map((z) => ({
    boxes: z,
    start: N.start,
    finish: N.finish
  }))))), Ww = (m, b, C, E, N) => Uc(m, N).bind((z) => Zk(z, b, C).bind((X) => $v(X, E))), Ap = (m, b) => Bv(m, b), Zw = (m, b, C) => qk(m, b, C).bind((E) => {
    const N = (xe) => Wt(m, xe), z = "thead,tfoot,tbody,table", X = Il(E.first, z, N), ue = Il(E.last, z, N);
    return X.bind((xe) => ue.bind((Fe) => Wt(xe, Fe) ? It(E.table, E.first, E.last) : ye.none()));
  }), Kk = ve, Gw = (m) => {
    const b = (E, N) => Re(E, N).exists((z) => parseInt(z, 10) > 1), C = (E) => b(E, "rowspan") || b(E, "colspan");
    return m.length > 0 && Mt(m, C) ? ye.some(m) : ye.none();
  }, Yk = (m, b, C) => b.length <= 1 ? ye.none() : Zw(m, C.firstSelectedSelector, C.lastSelectedSelector).map((E) => ({
    bounds: E,
    cells: b
  })), Bl = "data-mce-selected", Wc = "td[" + Bl + "],th[" + Bl + "]", Qt = "[" + Bl + "]", B0 = "data-mce-first-selected", Xi = "td[" + B0 + "],th[" + B0 + "]", $0 = "data-mce-last-selected", Xk = "td[" + $0 + "],th[" + $0 + "]", Js = Qt, Am = {
    selected: Bl,
    selectedSelector: Wc,
    firstSelected: B0,
    firstSelectedSelector: Xi,
    lastSelected: $0,
    lastSelectedSelector: Xk
  }, L0 = (m, b, C) => ({
    element: C,
    mergable: Yk(b, m, Am),
    unmergable: Gw(m),
    selection: Kk(m)
  }), J3 = (m, b, C) => ({
    element: m,
    clipboard: b,
    generators: C
  }), Pm = (m, b, C, E) => ({
    selection: Kk(m),
    clipboard: C,
    generators: E
  }), H0 = (m) => Zi(m).bind((b) => Ap(b, Am.firstSelectedSelector)).fold(G(m), (b) => b[0]), of = (m) => (b, C) => {
    const E = kr(b), N = E === "col" || E === "colgroup" ? H0(b) : b;
    return Ns(N, m, C);
  }, Qk = of("th,td,caption"), qw = of("th,td"), Us = (m) => Xd(m.model.table.getSelectedCells()), cb = (m) => St(Us(m), (b) => Do(b, Am.selectedSelector)), va = (m) => Zi(m[0]).map((b) => {
    const C = Ro(b, Js);
    return oc(C), [C];
  }), Jk = (m, b) => tn(b, (C) => m.selection.serializer.serialize(C.dom, {})).join(""), Zc = (m) => tn(m, (b) => b.dom.innerText).join(""), ub = (m, b) => {
    m.on("BeforeGetContent", (C) => {
      const E = (N) => {
        C.preventDefault(), va(N).each((z) => {
          C.content = C.format === "text" ? Zc(z) : Jk(m, z);
        });
      };
      if (C.selection === !0) {
        const N = cb(m);
        N.length >= 1 && E(N);
      }
    }), m.on("BeforeSetContent", (C) => {
      if (C.selection === !0 && C.paste === !0) {
        const E = Us(m);
        Ue(E).each((N) => {
          Zi(N).each((z) => {
            const X = St(Bf(C.content), (xe) => kr(xe) !== "meta"), ue = Tn("table");
            if (ef(m) && X.length === 1 && ue(X[0])) {
              C.preventDefault();
              const xe = He.fromDom(m.getDoc()), Fe = Tm(xe), it = J3(N, X[0], Fe);
              b.pasteCells(z, it).each(() => {
                m.focus();
              });
            }
          });
        });
      }
    });
  }, Gc = (m, b) => ({
    element: m,
    offset: b
  }), e4 = (m, b, C) => m.property().isText(b) && m.property().getText(b).trim().length === 0 || m.property().isComment(b) ? C(b).bind((E) => e4(m, E, C).orThunk(() => ye.some(E))) : ye.none(), t4 = (m, b) => m.property().isText(b) ? m.property().getText(b).length : m.property().children(b).length, n4 = (m, b) => {
    const C = e4(m, b, m.query().prevSibling).getOr(b);
    if (m.property().isText(C))
      return Gc(C, t4(m, C));
    const E = m.property().children(C);
    return E.length > 0 ? n4(m, E[E.length - 1]) : Gc(C, t4(m, C));
  }, o4 = n4, Ii = Op(), rc = (m) => o4(Ii, m), Lv = (m, b) => {
    sa(m) || eb(m).each((E) => {
      const N = E.value / 2;
      Rt(m, N, E.unit), Rt(b, N, E.unit);
    });
  }, Pp = (m) => tn(m, G(0)), Kw = (m, b, C, E, N) => N(m.slice(0, b)).concat(E).concat(N(m.slice(C))), db = (m) => (b, C, E, N) => {
    if (m(E)) {
      const z = Math.max(N, b[C] - Math.abs(E)), X = Math.abs(z - b[C]);
      return E >= 0 ? X : -X;
    } else
      return E;
  }, Vf = db((m) => m < 0), fb = db(je), qh = () => {
    const m = (ue, xe, Fe, it, qt) => {
      const _n = Vf(ue, xe, it, qt);
      return Kw(ue, xe, Fe + 1, [
        _n,
        0
      ], Pp);
    }, b = (ue, xe, Fe, it) => {
      const qt = (100 + Fe) / 100, _n = Math.max(it, (ue[xe] + Fe) / qt);
      return tn(ue, (bn, ln) => (ln === xe ? _n : bn / qt) - bn);
    }, C = (ue, xe, Fe, it, qt, _n) => _n ? b(ue, xe, it, qt) : m(ue, xe, Fe, it, qt);
    return {
      resizeTable: (ue, xe) => ue(xe),
      clampTableDelta: Vf,
      calcLeftEdgeDeltas: C,
      calcMiddleDeltas: (ue, xe, Fe, it, qt, _n, bn) => C(ue, Fe, it, qt, _n, bn),
      calcRightEdgeDeltas: (ue, xe, Fe, it, qt, _n) => {
        if (_n)
          return b(ue, Fe, it, qt);
        {
          const bn = Vf(ue, Fe, it, qt);
          return Pp(ue.slice(0, Fe)).concat([bn]);
        }
      },
      calcRedestributedWidths: (ue, xe, Fe, it) => {
        if (it) {
          const _n = (xe + Fe) / xe, bn = tn(ue, (ln) => ln / _n);
          return {
            delta: _n * 100 - 100,
            newSizes: bn
          };
        } else
          return {
            delta: Fe,
            newSizes: ue
          };
      }
    };
  }, Dp = () => {
    const m = (X, ue, xe, Fe, it) => {
      const qt = Fe >= 0 ? xe : ue, _n = fb(X, qt, Fe, it);
      return Kw(X, ue, xe + 1, [
        _n,
        -_n
      ], Pp);
    };
    return {
      resizeTable: (X, ue, xe) => {
        xe && X(ue);
      },
      clampTableDelta: (X, ue, xe, Fe, it) => {
        if (it) {
          if (xe >= 0)
            return xe;
          {
            const qt = tt(X, (_n, bn) => _n + bn - Fe, 0);
            return Math.max(-qt, xe);
          }
        } else
          return Vf(X, ue, xe, Fe);
      },
      calcLeftEdgeDeltas: m,
      calcMiddleDeltas: (X, ue, xe, Fe, it, qt) => m(X, xe, Fe, it, qt),
      calcRightEdgeDeltas: (X, ue, xe, Fe, it, qt) => {
        if (qt)
          return Pp(X);
        {
          const _n = Fe / X.length;
          return tn(X, G(_n));
        }
      },
      calcRedestributedWidths: (X, ue, xe, Fe) => ({
        delta: 0,
        newSizes: X
      })
    };
  }, jf = (m) => dr.fromTable(m).grid, Kh = Tn("th"), Yh = (m) => Mt(m, (b) => Kh(b.element)), r4 = (m, b) => m && b ? "sectionCells" : m ? "section" : "cells", Yw = (m) => {
    const b = m.section === "thead", C = xc(z0(m.cells), "th");
    return m.section === "tfoot" ? { type: "footer" } : b || C ? {
      type: "header",
      subType: r4(b, C)
    } : { type: "body" };
  }, z0 = (m) => {
    const b = St(m, (C) => Kh(C.element));
    return b.length === 0 ? ye.some("td") : b.length === m.length ? ye.some("th") : ye.none();
  }, e_ = (m) => {
    const b = tn(m, (N) => Yw(N).type), C = mn(b, "header"), E = mn(b, "footer");
    if (!C && !E)
      return ye.some("body");
    {
      const N = mn(b, "body");
      return C && !N && !E ? ye.some("header") : !C && !N && E ? ye.some("footer") : ye.none();
    }
  }, Xw = (m) => mo(m.all, (b) => {
    const C = Yw(b);
    return C.type === "header" ? ye.from(C.subType) : ye.none();
  }), V0 = (m, b, C) => le(C(m.element, b), !0, m.isLocked), Qw = (m, b) => m.section !== b ? Ae(m.element, m.cells, b, m.isNew) : m, j0 = () => ({
    transformRow: Qw,
    transformCell: (m, b, C) => {
      const E = C(m.element, b), N = kr(E) !== "td" ? gi(E, "td") : E;
      return le(N, m.isNew, m.isLocked);
    }
  }), mb = () => ({
    transformRow: Qw,
    transformCell: V0
  }), U0 = () => ({
    transformRow: (m, b) => Qw(m, b === "thead" ? "tbody" : b),
    transformCell: V0
  }), rf = {
    getTableSectionType: (m, b) => {
      const C = dr.fromTable(m);
      switch (Xw(C).getOr(b)) {
        case "section":
          return j0();
        case "sectionCells":
          return mb();
        case "cells":
          return U0();
      }
    },
    section: j0,
    sectionCells: mb,
    cells: U0,
    fallback: () => ({
      transformRow: ve,
      transformCell: V0
    })
  }, pb = (m, b, C, E) => {
    C === E ? Oe(m, b) : cr(m, b, C);
  }, t_ = (m, b, C) => {
    jn(Ln(m, b)).fold(() => vs(m, C), (E) => ua(E, C));
  }, n_ = (m, b) => {
    const C = xr(m, b).getOrThunk(() => {
      const E = He.fromTag(b, Gn(m).dom);
      return b === "thead" ? t_(m, "caption,colgroup", E) : b === "colgroup" ? t_(m, "caption", E) : es(m, E), E;
    });
    return ii(C), C;
  }, W0 = (m, b) => {
    const C = [], E = [], N = (bn) => tn(bn, (ln) => {
      ln.isNew && C.push(ln.element);
      const Zn = ln.element;
      return ii(Zn), Le(ln.cells, (Ut) => {
        Ut.isNew && E.push(Ut.element), pb(Ut.element, "colspan", Ut.colspan, 1), pb(Ut.element, "rowspan", Ut.rowspan, 1), es(Zn, Ut.element);
      }), Zn;
    }), z = (bn) => Ot(bn, (ln) => tn(ln.cells, (Zn) => (pb(Zn.element, "span", Zn.colspan, 1), Zn.element))), X = (bn, ln) => {
      const Zn = n_(m, ln), un = (ln === "colgroup" ? z : N)(bn);
      ka(Zn, un);
    }, ue = (bn) => {
      xr(m, bn).each(na);
    }, xe = (bn, ln) => {
      bn.length > 0 ? X(bn, ln) : ue(ln);
    }, Fe = [], it = [], qt = [], _n = [];
    return Le(b, (bn) => {
      switch (bn.section) {
        case "thead":
          Fe.push(bn);
          break;
        case "tbody":
          it.push(bn);
          break;
        case "tfoot":
          qt.push(bn);
          break;
        case "colgroup":
          _n.push(bn);
          break;
      }
    }), xe(_n, "colgroup"), xe(Fe, "thead"), xe(it, "tbody"), xe(qt, "tfoot"), {
      newRows: C,
      newCells: E
    };
  }, Rp = (m) => tn(m, (b) => {
    const C = Za(b.element);
    return Le(b.cells, (E) => {
      const N = Ai(E.element);
      pb(N, "colspan", E.colspan, 1), pb(N, "rowspan", E.rowspan, 1), es(C, N);
    }), C;
  }), a4 = (m, b) => tn(m, (C) => Sl(C, b)), Jw = (m, b) => m[b], Hv = (m, b) => {
    if (m.length === 0)
      return 0;
    const C = m[0];
    return Wo(m, (N) => !b(C.element, N.element)).getOr(m.length);
  }, i4 = (m, b, C, E) => {
    const N = Jw(m, b), z = N.section === "colgroup", X = Hv(N.cells.slice(C), E), ue = z ? 1 : Hv(a4(m.slice(b), C), E);
    return {
      colspan: X,
      rowspan: ue
    };
  }, Z0 = (m, b) => {
    const C = tn(m, (N) => tn(N.cells, Kt)), E = (N, z, X, ue) => {
      for (let xe = N; xe < N + X; xe++)
        for (let Fe = z; Fe < z + ue; Fe++)
          C[xe][Fe] = !0;
    };
    return tn(m, (N, z) => {
      const X = Ot(N.cells, (ue, xe) => {
        if (C[z][xe] === !1) {
          const Fe = i4(m, z, xe, b);
          return E(z, xe, Fe.rowspan, Fe.colspan), [ld(ue.element, Fe.rowspan, Fe.colspan, ue.isNew)];
        } else
          return [];
      });
      return Ru(N.element, X, N.section, N.isNew);
    });
  }, hb = (m, b, C) => {
    const E = [];
    Le(m.colgroups, (N) => {
      const z = [];
      for (let X = 0; X < m.grid.columns; X++) {
        const ue = dr.getColumnAt(m, X).map((xe) => le(xe.element, C, !1)).getOrThunk(() => le(b.colGap(), !0, !1));
        z.push(ue);
      }
      E.push(Ae(N.element, z, "colgroup", C));
    });
    for (let N = 0; N < m.grid.rows; N++) {
      const z = [];
      for (let xe = 0; xe < m.grid.columns; xe++) {
        const Fe = dr.getAt(m, N, xe).map((it) => le(it.element, C, it.isLocked)).getOrThunk(() => le(b.gap(), !0, !1));
        z.push(Fe);
      }
      const X = m.all[N], ue = Ae(X.element, z, X.section, C);
      E.push(ue);
    }
    return E;
  }, o_ = (m, b) => hb(m, b, !1), G0 = (m) => Z0(m, Wt), e2 = (m, b) => mo(m.all, (C) => Y(C.cells, (E) => Wt(b, E.element))), r_ = (m, b, C) => {
    const E = tn(b.selection, (z) => ip(z).bind((X) => e2(m, X)).filter(C)), N = Bs(E);
    return vm(N.length > 0, N);
  }, Ol = (m, b, C, E, N) => (z, X, ue, xe) => {
    const Fe = dr.fromTable(z), it = ye.from(xe == null ? void 0 : xe.section).getOrThunk(rf.fallback);
    return b(Fe, X).map((_n) => {
      const bn = o_(Fe, ue), ln = m(bn, _n, Wt, N(ue), it), Zn = Ys(ln.grid), Ut = G0(ln.grid);
      return {
        info: _n,
        grid: Ut,
        cursor: ln.cursor,
        lockedColumns: Zn
      };
    }).bind((_n) => {
      const bn = W0(z, _n.grid), ln = ye.from(xe == null ? void 0 : xe.sizing).getOrThunk(() => I.getTableSize(z)), Zn = ye.from(xe == null ? void 0 : xe.resize).getOrThunk(Dp);
      return C(z, _n.grid, _n.info, {
        sizing: ln,
        resize: Zn,
        section: it
      }), E(z), Oe(z, Jl), _n.lockedColumns.length > 0 && cr(z, Jl, _n.lockedColumns.join(",")), ye.some({
        cursor: _n.cursor,
        newRows: bn.newRows,
        newCells: bn.newCells
      });
    });
  }, zv = (m, b) => ip(b.element).bind((C) => e2(m, C).map((E) => ({
    ...E,
    generators: b.generators,
    clipboard: b.clipboard
  }))), t2 = (m, b) => r_(m, b, je).map((C) => ({
    cells: C,
    generators: b.generators,
    clipboard: b.clipboard
  })), gb = (m, b) => b.mergable, s_ = (m, b) => b.unmergable, sf = (m, b) => r_(m, b, je), Oc = (m, b) => r_(m, b, (C) => !C.isLocked), bb = (m, b) => e2(m, b).exists((C) => !C.isLocked), vb = (m, b) => Mt(b, (C) => bb(m, C)), Vv = (m, b) => gb(m, b).filter((C) => vb(m, C.cells)), l4 = (m, b) => s_(m, b).filter((C) => vb(m, C)), c4 = (m, b, C, E) => {
    const N = Na(m).rows;
    if (N.length === 0)
      return m;
    for (let z = b.startRow; z <= b.finishRow; z++)
      for (let X = b.startCol; X <= b.finishCol; X++) {
        const ue = N[z], xe = Sl(ue, X).isLocked;
        zo(ue, X, le(E(), !1, xe));
      }
    return m;
  }, Xh = (m, b, C, E) => {
    const N = Na(m).rows;
    let z = !0;
    for (let X = 0; X < N.length; X++)
      for (let ue = 0; ue < kl(N[0]); ue++) {
        const xe = N[X], Fe = Sl(xe, ue), it = Fe.element, qt = C(it, b);
        qt && !z ? zo(xe, ue, le(E(), !0, Fe.isLocked)) : qt && (z = !1);
      }
    return m;
  }, qc = (m, b) => tt(m, (C, E) => dt(C, (N) => b(N.element, E.element)) ? C : C.concat([E]), []), a_ = (m, b, C, E) => (b > 0 && b < m[0].cells.length && Le(m, (N) => {
    const z = N.cells[b - 1];
    let X = 0;
    const ue = E();
    for (; N.cells.length > b + X && C(z.element, N.cells[b + X].element); )
      zo(N, b + X, le(ue, !0, N.cells[b + X].isLocked)), X++;
  }), m), Ma = (m, b, C, E) => {
    const N = Na(m).rows;
    if (b > 0 && b < N.length) {
      const z = N[b - 1].cells, X = qc(z, C);
      Le(X, (ue) => {
        let xe = ye.none();
        for (let Fe = b; Fe < N.length; Fe++)
          for (let it = 0; it < kl(N[0]); it++) {
            const qt = N[Fe], _n = Sl(qt, it);
            C(_n.element, ue.element) && (xe.isNone() && (xe = ye.some(E())), xe.each((ln) => {
              zo(qt, it, le(ln, !0, _n.isLocked));
            }));
          }
      });
    }
    return m;
  }, Qh = (m) => {
    const b = (z) => z(m), C = G(m), E = () => N, N = {
      tag: !0,
      inner: m,
      fold: (z, X) => X(m),
      isValue: je,
      isError: Kt,
      map: (z) => q0.value(z(m)),
      mapError: E,
      bind: b,
      exists: b,
      forall: b,
      getOr: C,
      or: E,
      getOrThunk: C,
      orThunk: E,
      getOrDie: C,
      each: (z) => {
        z(m);
      },
      toOptional: () => ye.some(m)
    };
    return N;
  }, Kc = (m) => {
    const b = () => C, C = {
      tag: !1,
      inner: m,
      fold: (E, N) => E(m),
      isValue: Kt,
      isError: je,
      map: b,
      mapError: (E) => q0.error(E(m)),
      bind: b,
      exists: Kt,
      forall: je,
      getOr: ve,
      or: ve,
      getOrThunk: ot,
      orThunk: ot,
      getOrDie: lt(String(m)),
      each: Q,
      toOptional: ye.none
    };
    return C;
  }, q0 = {
    value: Qh,
    error: Kc,
    fromOption: (m, b) => m.fold(() => Kc(b), Qh)
  }, yb = (m, b, C) => {
    if (m.row >= b.length || m.column > kl(b[0]))
      return q0.error("invalid start address out of table bounds, row: " + m.row + ", column: " + m.column);
    const E = b.slice(m.row), N = E[0].cells.slice(m.column), z = kl(C[0]), X = C.length;
    return q0.value({
      rowDelta: E.length - X,
      colDelta: N.length - z
    });
  }, Jh = (m, b) => {
    const C = kl(m[0]), E = kl(b[0]);
    return {
      rowDelta: 0,
      colDelta: C - E
    };
  }, af = (m, b) => {
    const C = m.length, E = b.length;
    return {
      rowDelta: C - E,
      colDelta: 0
    };
  }, Yc = (m, b, C, E) => {
    const N = b.section === "colgroup" ? C.col : C.cell;
    return En(m, (z) => le(N(), !0, E(z)));
  }, n2 = (m, b, C, E) => {
    const N = m[m.length - 1];
    return m.concat(En(b, () => {
      const z = N.section === "colgroup" ? C.colgroup : C.row, X = Ki(N, z, ve), ue = Yc(X.cells.length, X, C, (xe) => at(E, xe.toString()));
      return fa(X, ue);
    }));
  }, o2 = (m, b, C, E) => tn(m, (N) => {
    const z = Yc(b, N, C, Kt);
    return pp(N, E, z);
  }), r2 = (m, b, C) => tn(m, (E) => tt(C, (N, z) => {
    const X = Yc(1, E, b, je)[0];
    return hp(N, z, X);
  }, E)), eg = (m, b, C) => {
    const E = b.colDelta < 0 ? o2 : ve, N = b.rowDelta < 0 ? n2 : ve, z = Ys(m), X = kl(m[0]), ue = dt(z, (it) => it === X - 1), xe = E(m, Math.abs(b.colDelta), C, ue ? X - 1 : X), Fe = Ys(xe);
    return N(xe, Math.abs(b.rowDelta), C, At(Fe, je));
  }, u4 = (m, b, C, E) => {
    const N = Sl(m[b], C), z = Xe(E, N.element), X = m[b];
    return m.length > 1 && kl(X) > 1 && (C > 0 && z(fl(X, C - 1)) || C < X.cells.length - 1 && z(fl(X, C + 1)) || b > 0 && z(fl(m[b - 1], C)) || b < m.length - 1 && z(fl(m[b + 1], C)));
  }, tg = (m, b, C, E, N, z) => {
    const X = m.row, ue = m.column, xe = C.length, Fe = kl(C[0]), it = X + xe, qt = ue + Fe + z.length, _n = At(z, je);
    for (let bn = X; bn < it; bn++) {
      let ln = 0;
      for (let Zn = ue; Zn < qt; Zn++) {
        if (_n[Zn]) {
          ln++;
          continue;
        }
        u4(b, bn, Zn, N) && Xh(b, fl(b[bn], Zn), N, E.cell);
        const Ut = Zn - ue - ln, un = Sl(C[bn - X], Ut), Co = un.element, wn = E.replace(Co);
        zo(b[bn], Zn, le(wn, !0, un.isLocked));
      }
    }
    return b;
  }, Uf = (m, b, C) => {
    const E = kl(b[0]), N = Na(b).cols.length + m.row, z = En(E - m.column, (ue) => ue + m.column), X = Y(z, (ue) => Mt(C, (xe) => xe !== ue)).getOr(E - 1);
    return {
      row: N,
      column: X
    };
  }, jv = (m, b, C) => St(C, (E) => E >= m.column && E <= kl(b[0]) + m.column), Rr = (m, b, C, E, N) => {
    const z = Ys(b), X = Uf(m, b, z), ue = Na(C).rows, xe = jv(X, ue, z);
    return yb(X, b, ue).map((it) => {
      const qt = {
        ...it,
        colDelta: it.colDelta - xe.length
      }, _n = eg(b, qt, E), bn = Ys(_n), ln = jv(X, ue, bn);
      return tg(X, _n, ue, E, N, ln);
    });
  }, sc = (m, b, C, E, N) => {
    a_(b, m, N, E.cell);
    const z = af(C, b), X = eg(C, z, E), ue = af(b, X), xe = eg(b, ue, E);
    return tn(xe, (Fe, it) => pp(Fe, m, X[it].cells));
  }, ju = (m, b, C, E, N) => {
    Ma(b, m, N, E.cell);
    const z = Ys(b), X = Jh(b, C), ue = {
      ...X,
      colDelta: X.colDelta - z.length
    }, xe = eg(b, ue, E), {
      cols: Fe,
      rows: it
    } = Na(xe), qt = Ys(xe), _n = Jh(C, b), bn = {
      ..._n,
      colDelta: _n.colDelta + qt.length
    }, ln = r2(C, E, qt), Zn = eg(ln, bn, E);
    return [
      ...Fe,
      ...it.slice(0, m),
      ...Zn,
      ...it.slice(m, it.length)
    ];
  }, Dm = (m, b, C, E) => Ki(m, (N) => E(N, C), b), Ws = (m, b, C, E, N) => {
    const { rows: z, cols: X } = Na(m), ue = z.slice(0, b), xe = z.slice(b), Fe = Dm(z[C], (it, qt) => b > 0 && b < z.length && E(fl(z[b - 1], qt), fl(z[b], qt)) ? Sl(z[b], qt) : le(N(it.element, E), !0, it.isLocked), E, N);
    return [
      ...X,
      ...ue,
      Fe,
      ...xe
    ];
  }, i_ = (m, b, C, E, N, z, X) => {
    if (C === "colgroup" || !E) {
      const ue = Sl(m, N);
      return le(X(ue.element, z), !0, !1);
    } else
      return Sl(m, b);
  }, K0 = (m, b, C, E, N) => tn(m, (z) => {
    const X = b > 0 && b < kl(z) && E(fl(z, b - 1), fl(z, b)), ue = i_(z, b, z.section, X, C, E, N);
    return hp(z, b, ue);
  }), Uv = (m, b) => Ot(m, (C) => {
    const E = C.cells, N = on(b, (z, X) => X >= 0 && X < z.length ? z.slice(0, X).concat(z.slice(X + 1)) : z, E);
    return N.length > 0 ? [Ae(C.element, N, C.section, C.isNew)] : [];
  }), Y0 = (m, b, C) => {
    const { rows: E, cols: N } = Na(m);
    return [
      ...N,
      ...E.slice(0, b),
      ...E.slice(C + 1)
    ];
  }, d4 = (m, b, C, E) => fl(m[b], C) !== void 0 && b > 0 && E(fl(m[b - 1], C), fl(m[b], C)), pa = (m, b, C) => b > 0 && C(fl(m, b - 1), fl(m, b)), s2 = (m, b, C, E) => d4(m, b, C, E) || pa(m[b], C, E), f4 = (m, b) => Mt(b, ve) && Yh(m.cells) ? je : (E, N, z) => !(kr(E.element) === "th" && b[z]), m4 = (m, b) => Mt(b, ve) && Yh(m) ? je : (E, N, z) => !(kr(E.element) === "th" && b[N]), xb = (m, b, C, E) => {
    const N = (X) => X === "row" ? oa(b) : sa(b), z = (X) => N(X) ? `${X}group` : X;
    return m ? Kh(b) ? z(C) : null : E && Kh(b) ? z(C === "row" ? "col" : "row") : null;
  }, Nn = (m, b) => (C, E, N) => ye.some(xb(m, C.element, "col", b[N])), p4 = (m, b) => (C, E) => ye.some(xb(m, C.element, "row", b[E])), l_ = (m, b, C) => le(C(m.element, b), !0, m.isLocked), X0 = (m, b, C, E, N, z, X) => {
    const ue = (xe) => dt(b, (Fe) => C(xe.element, Fe.element));
    return tn(m, (xe, Fe) => Rf(xe, (it, qt) => {
      if (ue(it)) {
        const _n = X(it, Fe, qt) ? N(it, C, E) : it;
        return z(_n, Fe, qt).each((bn) => {
          ta(_n.element, { scope: ye.from(bn) });
        }), _n;
      } else
        return it;
    }));
  }, a2 = (m, b, C) => Ot(m, (E, N) => s2(m, N, b, C) ? [] : [Sl(E, b)]), h4 = (m, b, C) => {
    const E = m[b];
    return Ot(E.cells, (N, z) => s2(m, b, z, C) ? [] : [N]);
  }, Wv = (m, b, C, E, N) => {
    const z = Na(m).rows, X = Ot(b, (it) => a2(z, it, E)), ue = tn(z, (it) => Yh(it.cells)), xe = m4(X, ue), Fe = p4(C, ue);
    return X0(m, X, E, N, l_, Fe, xe);
  }, Zv = (m, b, C, E, N, z, X) => {
    const { cols: ue, rows: xe } = Na(m), Fe = xe[b[0]], it = Ot(b, (Ut) => h4(xe, Ut, N)), qt = tn(Fe.cells, (Ut, un) => Yh(a2(xe, un, N))), _n = [...xe];
    Le(b, (Ut) => {
      _n[Ut] = X.transformRow(xe[Ut], C);
    });
    const bn = [
      ...ue,
      ..._n
    ], ln = f4(Fe, qt), Zn = Nn(E, qt);
    return X0(bn, it, N, z, X.transformCell, Zn, ln);
  }, ng = (m, b, C, E) => {
    const N = Na(m).rows, z = tn(b, (X) => Sl(N[X.row], X.column));
    return X0(m, z, C, E, l_, ye.none, je);
  }, Wf = { generate: (m) => {
    if (!D(m))
      throw new Error("cases must be an array");
    if (m.length === 0)
      throw new Error("there must be at least one case");
    const b = [], C = {};
    return Le(m, (E, N) => {
      const z = xn(E);
      if (z.length !== 1)
        throw new Error("one and only one name per case");
      const X = z[0], ue = E[X];
      if (C[X] !== void 0)
        throw new Error("duplicate key detected:" + X);
      if (X === "cata")
        throw new Error("cannot have a case named cata (sorry)");
      if (!D(ue))
        throw new Error("case arguments must be an array");
      b.push(X), C[X] = (...xe) => {
        const Fe = xe.length;
        if (Fe !== ue.length)
          throw new Error("Wrong number of arguments to case " + X + ". Expected " + ue.length + " (" + ue + "), got " + Fe);
        return {
          fold: (...qt) => {
            if (qt.length !== m.length)
              throw new Error("Wrong number of arguments to fold. Expected " + m.length + ", got " + qt.length);
            return qt[N].apply(null, xe);
          },
          match: (qt) => {
            const _n = xn(qt);
            if (b.length !== _n.length)
              throw new Error("Wrong number of arguments to match. Expected: " + b.join(",") + `
Actual: ` + _n.join(","));
            if (!Mt(b, (ln) => mn(_n, ln)))
              throw new Error("Not all branches were specified when using match. Specified: " + _n.join(", ") + `
Required: ` + b.join(", "));
            return qt[X].apply(null, xe);
          },
          log: (qt) => {
            console.log(qt, {
              constructors: b,
              constructor: X,
              params: xe
            });
          }
        };
      };
    }), C;
  } }, Rm = { ...Wf.generate([
    { none: [] },
    { only: ["index"] },
    {
      left: [
        "index",
        "next"
      ]
    },
    {
      middle: [
        "prev",
        "index",
        "next"
      ]
    },
    {
      right: [
        "prev",
        "index"
      ]
    }
  ]) }, c_ = (m, b) => m.length === 0 ? Rm.none() : m.length === 1 ? Rm.only(0) : b === 0 ? Rm.left(0, 1) : b === m.length - 1 ? Rm.right(b - 1, b) : b > 0 && b < m.length - 1 ? Rm.middle(b - 1, b, b + 1) : Rm.none(), lf = (m, b, C, E, N) => {
    const z = m.slice(0), X = c_(m, b), ue = G(tn(z, G(0))), xe = (_n) => E.singleColumnWidth(z[_n], C), Fe = (_n, bn) => N.calcLeftEdgeDeltas(z, _n, bn, C, E.minCellWidth(), E.isRelative), it = (_n, bn, ln) => N.calcMiddleDeltas(z, _n, bn, ln, C, E.minCellWidth(), E.isRelative), qt = (_n, bn) => N.calcRightEdgeDeltas(z, _n, bn, C, E.minCellWidth(), E.isRelative);
    return X.fold(ue, xe, Fe, it, qt);
  }, u_ = (m, b, C) => {
    let E = 0;
    for (let N = m; N < b; N++)
      E += C[N] !== void 0 ? C[N] : 0;
    return E;
  }, wb = (m, b) => {
    const C = dr.justCells(m);
    return tn(C, (E) => {
      const N = u_(E.column, E.column + E.colspan, b);
      return {
        element: E.element,
        width: N,
        colspan: E.colspan
      };
    });
  }, b4 = (m, b) => {
    const C = dr.justColumns(m);
    return tn(C, (E, N) => ({
      element: E.element,
      width: b[N],
      colspan: E.colspan
    }));
  }, v4 = (m, b) => tn(m.all, (C, E) => ({
    element: C.element,
    height: b[E]
  })), y4 = (m) => on(m, (b, C) => b + C, 0), i2 = (m, b) => dr.hasColumns(m) ? b4(m, b) : wb(m, b), Q0 = (m, b, C) => {
    const E = i2(m, b);
    Le(E, (N) => {
      C.setElementWidth(N.element, N.width);
    });
  }, d_ = (m, b, C, E, N) => {
    const z = dr.fromTable(m), X = N.getCellDelta(b), ue = N.getWidths(z, N), xe = C === z.grid.columns - 1, Fe = E.clampTableDelta(ue, C, X, N.minCellWidth(), xe), it = lf(ue, C, Fe, N, E), qt = tn(it, (_n, bn) => _n + ue[bn]);
    Q0(z, qt, N), E.resizeTable(N.adjustTableWidth, Fe, xe);
  }, l2 = (m, b, C) => {
    const E = dr.fromTable(m), N = Qe(E, m), z = tn(N, (xe, Fe) => C === Fe ? Math.max(b + xe, qa()) : xe), X = v4(E, z);
    Le(X, (xe) => {
      If(xe.element, xe.height);
    }), Le(dr.justCells(E), (xe) => {
      _m(xe.element);
    });
    const ue = y4(z);
    If(m, ue);
  }, x4 = (m, b, C, E, N) => {
    const z = dr.generate(b), X = E.getWidths(z, E), ue = E.pixelWidth(), { newSizes: xe, delta: Fe } = N.calcRedestributedWidths(X, ue, C.pixelDelta, E.isRelative);
    Q0(z, xe, E), E.adjustTableWidth(Fe);
  }, Gv = (m, b, C, E) => {
    const N = dr.generate(b), z = E.getWidths(N, E);
    Q0(N, z, E);
  }, Np = (m) => tt(m, (C, E) => dt(C, (z) => z.column === E.column) ? C : C.concat([E]), []).sort((C, E) => C.column - E.column), Cb = Tn("col"), J0 = Tn("colgroup"), c2 = (m) => kr(m) === "tr" || J0(m), ey = (m) => {
    const b = Ms(m, "colspan", 1), C = Ms(m, "rowspan", 1);
    return {
      element: m,
      colspan: b,
      rowspan: C
    };
  }, u2 = (m, b = ey) => {
    const C = (ue) => Cb(ue.element) ? m.col(ue) : m.cell(ue), E = (ue) => J0(ue.element) ? m.colgroup(ue) : m.row(ue), N = (ue) => {
      if (c2(ue))
        return E({ element: ue });
      {
        const xe = ue, Fe = C(b(xe));
        return z = ye.some({
          item: xe,
          replacement: Fe
        }), Fe;
      }
    };
    let z = ye.none();
    return { getOrInit: (ue, xe) => z.fold(() => N(ue), (Fe) => xe(ue, Fe.item) ? Fe.replacement : N(ue)) };
  }, d2 = (m) => (b) => {
    const C = [], E = (X, ue) => Y(C, (xe) => ue(xe.item, X)), N = (X) => {
      const ue = m === "td" ? { scope: null } : {}, xe = b.replace(X, m, ue);
      return C.push({
        item: X,
        sub: xe
      }), xe;
    };
    return { replaceOrInit: (X, ue) => {
      if (c2(X) || Cb(X))
        return X;
      {
        const xe = X;
        return E(xe, ue).fold(() => N(xe), (Fe) => ue(X, Fe.item) ? Fe.sub : N(xe));
      }
    } };
  }, f2 = (m) => Re(m, "scope").map((b) => b.substr(0, 3)), Qi = {
    modification: u2,
    transform: d2,
    merging: (m) => ({
      unmerge: (E) => {
        const N = f2(E);
        return N.each((z) => cr(E, "scope", z)), () => {
          const z = m.cell({
            element: E,
            colspan: 1,
            rowspan: 1
          });
          return ur(z, "width"), ur(E, "width"), N.each((X) => cr(z, "scope", X)), z;
        };
      },
      merge: (E) => {
        const N = () => {
          const z = Bs(tn(E, f2));
          if (z.length === 0)
            return ye.none();
          {
            const X = z[0], ue = [
              "row",
              "col"
            ];
            return dt(z, (Fe) => Fe !== X && mn(ue, Fe)) ? ye.none() : ye.from(X);
          }
        };
        return ur(E[0], "width"), N().fold(() => Oe(E[0], "scope"), (z) => cr(E[0], "scope", z + "group")), G(E[0]);
      }
    })
  }, w4 = [
    "body",
    "p",
    "div",
    "article",
    "aside",
    "figcaption",
    "figure",
    "footer",
    "header",
    "nav",
    "section",
    "ol",
    "ul",
    "table",
    "thead",
    "tfoot",
    "tbody",
    "caption",
    "tr",
    "td",
    "th",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "blockquote",
    "pre",
    "address"
  ], m_ = (m, b) => {
    const C = m.property().name(b);
    return mn([
      "ol",
      "ul"
    ], C);
  }, Mp = (m, b) => {
    const C = m.property().name(b);
    return mn(w4, C);
  }, og = (m, b) => mn([
    "br",
    "img",
    "hr",
    "input"
  ], m.property().name(b)), m2 = Op(), vt = (m) => Mp(m2, m), Zf = (m) => m_(m2, m), C4 = (m) => og(m2, m), p_ = (m) => {
    const b = Tn("br"), C = (xe) => Mt(xe, (Fe) => b(Fe) || Ke(Fe) && $s(Fe).trim().length === 0), E = (xe) => kr(xe) === "li" || fs(xe, Zf).isSome(), N = (xe) => Ti(xe).map((Fe) => vt(Fe) ? !0 : C4(Fe) ? kr(Fe) !== "img" : !1).getOr(!1), z = (xe) => nb(xe).bind((Fe) => {
      const it = N(Fe);
      return rr(Fe).map((qt) => it === !0 || E(qt) || b(Fe) || vt(qt) && !Wt(xe, qt) ? [] : [He.fromTag("br")]);
    }).getOr([]), ue = (() => {
      const xe = Ot(m, (Fe) => {
        const it = ko(Fe);
        return C(it) ? [] : it.concat(z(Fe));
      });
      return xe.length === 0 ? [He.fromTag("br")] : xe;
    })();
    ii(m[0]), ka(m[0], ue);
  }, qv = (m) => Mv(m, !0), Uu = (m) => {
    dd(m).length === 0 && na(m);
  }, Kv = (m, b) => ({
    grid: m,
    cursor: b
  }), h_ = (m) => mo(m, (b) => mo(b.cells, (C) => {
    const E = C.element;
    return vm(qv(E), E);
  })), p2 = (m, b, C) => {
    var E, N;
    const z = Na(m).rows;
    return ye.from((N = (E = z[b]) === null || E === void 0 ? void 0 : E.cells[C]) === null || N === void 0 ? void 0 : N.element).filter(qv).orThunk(() => h_(z));
  }, $l = (m, b, C) => {
    const E = p2(m, b, C);
    return Kv(m, E);
  }, ty = (m) => tt(m, (C, E) => dt(C, (z) => z.row === E.row) ? C : C.concat([E]), []).sort((C, E) => C.row - E.row), g_ = (m, b, C, E) => {
    const N = b[0].row, z = ty(b), X = on(z, (ue, xe) => ({
      grid: Ws(ue.grid, N, xe.row + ue.delta, C, E.getOrInit),
      delta: ue.delta + 1
    }), {
      grid: m,
      delta: 0
    }).grid;
    return $l(X, N, b[0].column);
  }, S4 = (m, b, C, E) => {
    const N = ty(b), z = N[N.length - 1], X = z.row + z.rowspan, ue = on(N, (xe, Fe) => Ws(xe, X, Fe.row, C, E.getOrInit), m);
    return $l(ue, X, b[0].column);
  }, b_ = (m, b, C, E) => {
    const N = b.details, z = Np(N), X = z[0].column, ue = on(z, (xe, Fe) => ({
      grid: K0(xe.grid, X, Fe.column + xe.delta, C, E.getOrInit),
      delta: xe.delta + 1
    }), {
      grid: m,
      delta: 0
    }).grid;
    return $l(ue, N[0].row, X);
  }, k4 = (m, b, C, E) => {
    const N = b.details, z = N[N.length - 1], X = z.column + z.colspan, ue = Np(N), xe = on(ue, (Fe, it) => K0(Fe, X, it.column, C, E.getOrInit), m);
    return $l(xe, N[0].row, X);
  }, v_ = (m, b, C, E) => {
    const N = Np(b), z = tn(N, (ue) => ue.column), X = Wv(m, z, !0, C, E.replaceOrInit);
    return $l(X, b[0].row, b[0].column);
  }, _4 = (m, b, C, E) => {
    const N = ng(m, b, C, E.replaceOrInit);
    return $l(N, b[0].row, b[0].column);
  }, E4 = (m, b, C, E) => {
    const N = Np(b), z = tn(N, (ue) => ue.column), X = Wv(m, z, !1, C, E.replaceOrInit);
    return $l(X, b[0].row, b[0].column);
  }, y_ = (m, b, C, E) => {
    const N = ng(m, b, C, E.replaceOrInit);
    return $l(N, b[0].row, b[0].column);
  }, Sb = (m, b) => (C, E, N, z, X) => {
    const ue = ty(E), xe = tn(ue, (it) => it.row), Fe = Zv(C, xe, m, b, N, z.replaceOrInit, X);
    return $l(Fe, E[0].row, E[0].column);
  }, T4 = Sb("thead", !0), x_ = Sb("tbody", !1), Oa = Sb("tfoot", !1), ny = (m, b, C, E) => {
    const N = Np(b.details), z = Uv(m, tn(N, (ue) => ue.column)), X = z.length > 0 ? z[0].cells.length - 1 : 0;
    return $l(z, N[0].row, Math.min(N[0].column, X));
  }, w_ = (m, b, C, E) => {
    const N = ty(b), z = Y0(m, N[0].row, N[N.length - 1].row), X = Math.max(Na(z).rows.length - 1, 0);
    return $l(z, Math.min(b[0].row, X), b[0].column);
  }, C_ = (m, b, C, E) => {
    const N = b.cells;
    p_(N);
    const z = c4(m, b.bounds, C, E.merge(N));
    return Kv(z, ye.from(N[0]));
  }, oy = (m, b, C, E) => {
    const z = on(b, (X, ue) => Xh(X, ue, C, E.unmerge(ue)), m);
    return Kv(z, ye.from(b[0]));
  }, Al = (m, b, C, E) => {
    const z = ((xe, Fe) => {
      const it = dr.fromTable(xe);
      return hb(it, Fe, !0);
    })(b.clipboard, b.generators), X = Kl(b.row, b.column);
    return Rr(X, m, z, b.generators, C).fold(() => Kv(m, ye.some(b.element)), (xe) => $l(xe, b.row, b.column));
  }, Ll = (m, b, C) => {
    const E = Ph(m, C.section), N = dr.generate(E);
    return hb(N, b, !0);
  }, S_ = (m, b, C, E) => {
    const N = Na(m).rows, z = b.cells[0].column, X = N[b.cells[0].row], ue = Ll(b.clipboard, b.generators, X), xe = sc(z, m, ue, b.generators, C);
    return $l(xe, b.cells[0].row, b.cells[0].column);
  }, k_ = (m, b, C, E) => {
    const N = Na(m).rows, z = b.cells[b.cells.length - 1].column + b.cells[b.cells.length - 1].colspan, X = N[b.cells[0].row], ue = Ll(b.clipboard, b.generators, X), xe = sc(z, m, ue, b.generators, C);
    return $l(xe, b.cells[0].row, z);
  }, h2 = (m, b, C, E) => {
    const N = Na(m).rows, z = b.cells[0].row, X = N[z], ue = Ll(b.clipboard, b.generators, X), xe = ju(z, m, ue, b.generators, C);
    return $l(xe, b.cells[0].row, b.cells[0].column);
  }, __ = (m, b, C, E) => {
    const N = Na(m).rows, z = b.cells[b.cells.length - 1].row + b.cells[b.cells.length - 1].rowspan, X = N[b.cells[0].row], ue = Ll(b.clipboard, b.generators, X), xe = ju(z, m, ue, b.generators, C);
    return $l(xe, z, b.cells[0].column);
  }, E_ = (m, b) => {
    const C = dr.fromTable(m);
    return sf(C, b).bind((N) => {
      const z = N[N.length - 1], X = N[0].column, ue = z.column + z.colspan, xe = To(tn(C.all, (Fe) => St(Fe.cells, (it) => it.column >= X && it.column < ue)));
      return z0(xe);
    }).getOr("");
  }, g2 = (m, b) => {
    const C = dr.fromTable(m);
    return sf(C, b).bind(z0).getOr("");
  }, b2 = (m, b) => {
    const C = dr.fromTable(m);
    return sf(C, b).bind((N) => {
      const z = N[N.length - 1], X = N[0].row, ue = z.row + z.rowspan, xe = C.all.slice(X, ue);
      return e_(xe);
    }).getOr("");
  }, ry = (m, b, C, E) => Gv(m, b, C, E.sizing), Nm = (m, b, C, E) => x4(m, b, C, E.sizing, E.resize), ac = (m, b) => dt(b, (C) => C.column === 0 && C.isLocked), v2 = (m, b) => dt(b, (C) => C.column + C.colspan >= m.grid.columns && C.isLocked), ss = (m, b) => {
    const C = Kd(m), E = Np(b);
    return tt(E, (N, z) => {
      const ue = C[z.column].map(ms).getOr(0);
      return N + ue;
    }, 0);
  }, cf = (m) => (b, C) => sf(b, C).filter((E) => !(m ? ac : v2)(b, E)).map((E) => ({
    details: E,
    pixelDelta: ss(b, E)
  })), Yv = (m, b) => Oc(m, b).map((C) => ({
    details: C,
    pixelDelta: -ss(m, C)
  })), T_ = (m) => (b, C) => t2(b, C).filter((E) => !(m ? ac : v2)(b, E.cells)), sy = Qi.transform("th"), ay = Qi.transform("td"), Ip = Ol(g_, sf, Q, Q, Qi.modification), Ji = Ol(S4, sf, Q, Q, Qi.modification), Fp = Ol(b_, cf(!0), Nm, Q, Qi.modification), y2 = Ol(k4, cf(!1), Nm, Q, Qi.modification), O_ = Ol(ny, Yv, Nm, Uu, Qi.modification), O4 = Ol(w_, sf, Q, Uu, Qi.modification), kb = Ol(v_, Oc, Q, Q, sy), x2 = Ol(E4, Oc, Q, Q, ay), w2 = Ol(T4, Oc, Q, Q, sy), C2 = Ol(x_, Oc, Q, Q, ay), S2 = Ol(Oa, Oc, Q, Q, ay), Bn = Ol(_4, Oc, Q, Q, sy), Xv = Ol(y_, Oc, Q, Q, ay), k2 = Ol(C_, Vv, ry, Q, Qi.merging), _b = Ol(oy, l4, ry, Q, Qi.merging), kd = Ol(Al, zv, ry, Q, Qi.modification), A4 = Ol(S_, T_(!0), Q, Q, Qi.modification), el = Ol(k_, T_(!1), Q, Q, Qi.modification), P4 = Ol(h2, t2, Q, Q, Qi.modification), Bp = Ol(__, t2, Q, Q, Qi.modification), _2 = E_, A_ = g2, Pl = b2, $p = (m, b) => m.dispatch("NewRow", { node: b }), iy = (m, b) => m.dispatch("NewCell", { node: b }), Lp = (m, b, C) => {
    m.dispatch("TableModified", {
      ...C,
      table: b
    });
  }, D4 = (m, b, C, E, N) => {
    m.dispatch("TableSelectionChange", {
      cells: b,
      start: C,
      finish: E,
      otherCells: N
    });
  }, R4 = (m) => {
    m.dispatch("TableSelectionClear");
  }, di = (m, b, C, E, N) => {
    m.dispatch("ObjectResizeStart", {
      target: b,
      width: C,
      height: E,
      origin: N
    });
  }, ei = (m, b, C, E, N) => {
    m.dispatch("ObjectResized", {
      target: b,
      width: C,
      height: E,
      origin: N
    });
  }, fi = {
    structure: !1,
    style: !0
  }, xs = {
    structure: !0,
    style: !1
  }, Ci = {
    structure: !0,
    style: !0
  }, ti = (m, b) => kp(m) ? I.percentageSize(b) : Om(m) ? I.pixelSize(b) : I.getTableSize(b), E2 = (m, b, C) => {
    const E = (Aa) => kr(jh(Aa)) === "table", N = (Aa) => !E(m) || jf(Aa).rows > 1, z = (Aa) => !E(m) || jf(Aa).columns > 1, X = zk(m), ue = M0(m) ? Q : Lv, xe = (Aa) => {
      switch (Vk(m)) {
        case "section":
          return rf.section();
        case "sectionCells":
          return rf.sectionCells();
        case "cells":
          return rf.cells();
        default:
          return rf.getTableSectionType(Aa, "section");
      }
    }, Fe = (Aa, Qf) => Qf.cursor.fold(() => {
      const x1 = dd(Aa);
      return Ue(x1).filter(os).map((Jc) => {
        C.clearSelectedCells(Aa.dom);
        const Vo = m.dom.createRng();
        return Vo.selectNode(Jc.dom), m.selection.setRng(Vo), cr(Jc, "data-mce-selected", "1"), Vo;
      });
    }, (x1) => {
      const Jc = rc(x1), Vo = m.dom.createRng();
      return Vo.setStart(Jc.element.dom, Jc.offset), Vo.setEnd(Jc.element.dom, Jc.offset), m.selection.setRng(Vo), C.clearSelectedCells(Aa.dom), ye.some(Vo);
    }), it = (Aa, Qf, x1, Jc) => (Vo, EC, TC = !1) => {
      oc(Vo);
      const ex = He.fromDom(m.getDoc()), FE = wd(x1, ex, X), wg = {
        sizing: ti(m, Vo),
        resize: M0(m) ? qh() : Dp(),
        section: xe(Vo)
      };
      return Qf(Vo) ? Aa(Vo, EC, FE, wg).bind((Vm) => {
        b.refresh(Vo.dom), Le(Vm.newRows, (w1) => {
          $p(m, w1.dom);
        }), Le(Vm.newCells, (w1) => {
          iy(m, w1.dom);
        });
        const BE = Fe(Vo, Vm);
        return os(Vo) && (oc(Vo), TC || Lp(m, Vo.dom, Jc)), BE.map((w1) => ({
          rng: w1,
          effect: Jc
        }));
      }) : ye.none();
    }, qt = it(O4, N, Q, xs), _n = it(O_, z, Q, xs), bn = it(Ip, je, Q, xs), ln = it(Ji, je, Q, xs), Zn = it(Fp, je, ue, xs), Ut = it(y2, je, ue, xs), un = it(k2, je, Q, xs), Co = it(_b, je, Q, xs), wn = it(A4, je, Q, xs), Xr = it(el, je, Q, xs), ws = it(P4, je, Q, xs), ps = it(Bp, je, Q, xs), nl = it(kd, je, Q, Ci), ni = it(Bn, je, Q, xs), Xf = it(Xv, je, Q, xs), Jp = it(kb, je, Q, xs), eh = it(x2, je, Q, xs), as = it(w2, je, Q, xs), dc = it(C2, je, Q, xs), fc = it(S2, je, Q, xs);
    return {
      deleteRow: qt,
      deleteColumn: _n,
      insertRowsBefore: bn,
      insertRowsAfter: ln,
      insertColumnsBefore: Zn,
      insertColumnsAfter: Ut,
      mergeCells: un,
      unmergeCells: Co,
      pasteColsBefore: wn,
      pasteColsAfter: Xr,
      pasteRowsBefore: ws,
      pasteRowsAfter: ps,
      pasteCells: nl,
      makeCellsHeader: ni,
      unmakeCellsHeader: Xf,
      makeColumnsHeader: Jp,
      unmakeColumnsHeader: eh,
      makeRowsHeader: as,
      makeRowsBody: dc,
      makeRowsFooter: fc,
      getTableRowType: Pl,
      getTableCellType: A_,
      getTableColType: _2
    };
  }, ly = (m, b, C) => {
    const E = Ms(m, b, 1);
    C === 1 || E <= 1 ? Oe(m, b) : cr(m, b, Math.min(C, E));
  }, T2 = (m, b) => (C) => {
    const E = C.column + C.colspan - 1, N = C.column;
    return E >= m && N < b;
  }, P_ = (m, b, C) => {
    if (dr.hasColumns(m)) {
      const E = St(dr.justColumns(m), T2(b, C)), N = tn(E, (X) => {
        const ue = Ai(X.element);
        return ly(ue, "span", C - b), ue;
      }), z = He.fromTag("colgroup");
      return ka(z, N), [z];
    } else
      return [];
  }, D_ = (m, b, C) => tn(m.all, (E) => {
    const N = St(E.cells, T2(b, C)), z = tn(N, (ue) => {
      const xe = Ai(ue.element);
      return ly(xe, "colspan", C - b), xe;
    }), X = He.fromTag("tr");
    return ka(X, z), X;
  }), cy = (m, b) => {
    const C = dr.fromTable(m);
    return Oc(C, b).map((N) => {
      const z = N[N.length - 1], X = N[0].column, ue = z.column + z.colspan, xe = P_(C, X, ue), Fe = D_(C, X, ue);
      return [
        ...xe,
        ...Fe
      ];
    });
  }, uy = (m, b, C) => {
    const E = dr.fromTable(m);
    return sf(E, b).bind((z) => {
      const X = hb(E, C, !1), xe = Na(X).rows.slice(z[0].row, z[z.length - 1].row + z[z.length - 1].rowspan), Fe = Ot(xe, (qt) => {
        const _n = St(qt.cells, (bn) => !bn.isLocked);
        return _n.length > 0 ? [{
          ...qt,
          cells: _n
        }] : [];
      }), it = G0(Fe);
      return vm(it.length > 0, it);
    }).map((z) => Rp(z));
  }, rg = Wf.generate([
    { invalid: ["raw"] },
    { pixels: ["value"] },
    { percent: ["value"] }
  ]), O2 = (m, b, C) => {
    const E = C.substring(0, C.length - m.length), N = parseFloat(E);
    return E === N.toString() ? b(N) : rg.invalid(C);
  }, sg = {
    ...rg,
    from: (m) => xi(m, "%") ? O2("%", rg.percent, m) : xi(m, "px") ? O2("px", rg.pixels, m) : rg.invalid(m)
  }, N4 = (m, b) => tn(m, (C) => sg.from(C).fold(() => C, (N) => N / b * 100 + "%", (N) => N + "%")), Ac = (m, b, C) => {
    const E = C / b;
    return tn(m, (N) => sg.from(N).fold(() => N, (X) => X * E + "px", (X) => X / 100 * C + "px"));
  }, pF = (m, b) => {
    const C = m.fold(() => G(""), (E) => {
      const N = E / b;
      return G(N + "px");
    }, () => {
      const E = 100 / b;
      return G(E + "%");
    });
    return En(b, C);
  }, M4 = (m, b, C) => m.fold(() => b, (E) => Ac(b, C, E), (E) => N4(b, C)), mu = (m, b, C) => {
    const E = sg.from(C), N = Mt(m, (z) => z === "0px") ? pF(E, m.length) : M4(E, m, b);
    return ic(N);
  }, Qv = (m, b) => m.length === 0 ? b : on(m, (C, E) => sg.from(E).fold(G(0), ve, ve) + C, 0), Jv = (m, b) => {
    const C = Math.floor(m);
    return {
      value: C + b,
      remainder: m - C
    };
  }, uf = (m, b) => sg.from(m).fold(G(m), (C) => C + b + "px", (C) => C + b + "%"), ic = (m) => {
    if (m.length === 0)
      return m;
    const b = on(m, (E, N) => {
      const z = sg.from(N).fold(() => ({
        value: N,
        remainder: 0
      }), (X) => Jv(X, "px"), (X) => ({
        value: X + "%",
        remainder: 0
      }));
      return {
        output: [z.value].concat(E.output),
        remainder: E.remainder + z.remainder
      };
    }, {
      output: [],
      remainder: 0
    }), C = b.output;
    return C.slice(0, C.length - 1).concat([uf(C[C.length - 1], Math.round(b.remainder))]);
  }, Hp = sg.from, A2 = (m, b, C) => {
    Le(b, (E) => {
      const N = m.slice(E.column, E.colspan + E.column), z = Qv(N, wc());
      pt(E.element, "width", z + C);
    });
  }, dy = (m, b, C) => {
    Le(b, (E, N) => {
      const z = Qv([m[N]], wc());
      pt(E.element, "width", z + C);
    });
  }, R_ = (m, b, C) => {
    Le(C, (E) => {
      ur(E.element, "height");
    }), Le(b, (E, N) => {
      pt(E.element, "height", m[N]);
    });
  }, ag = (m) => Hp(m).fold(G("px"), G("px"), G("%")), P2 = (m, b, C) => {
    const E = dr.fromTable(m), N = E.all, z = dr.justCells(E), X = dr.justColumns(E);
    b.each((ue) => {
      const xe = ag(ue), Fe = za(m), it = vd(E, m), qt = mu(it, Fe, ue);
      dr.hasColumns(E) ? dy(qt, X, xe) : A2(qt, z, xe), pt(m, "width", ue);
    }), C.each((ue) => {
      const xe = V(m), Fe = Vc(E, m), it = mu(Fe, xe, ue);
      R_(it, N, z), pt(m, "height", ue);
    });
  }, D2 = Yi, N_ = Nw, M_ = _c, e1 = (m) => {
    Oe(m, "width"), Oe(m, "height");
  }, ig = (m) => {
    const b = Va(m);
    P2(m, ye.some(b), ye.none()), e1(m);
  }, R2 = (m) => {
    const b = Vr(m);
    P2(m, ye.some(b), ye.none()), e1(m);
  }, N2 = (m) => {
    const b = tb(m);
    P2(m, ye.none(), ye.some(b)), e1(m);
  }, I_ = (m) => {
    ur(m, "width");
    const b = Cc(m), C = b.length > 0 ? b : dd(m);
    Le(C, (E) => {
      ur(E, "width"), e1(E);
    }), e1(m);
  }, F_ = {
    styles: {
      "border-collapse": "collapse",
      width: "100%"
    },
    attributes: { border: "1" },
    colGroups: !1
  }, I4 = () => He.fromTag("th"), fy = () => He.fromTag("td"), B_ = () => He.fromTag("col"), F4 = (m, b, C, E) => {
    const N = He.fromTag("tr");
    for (let z = 0; z < m; z++) {
      const X = E < b || z < C ? I4() : fy();
      z < C && cr(X, "scope", "row"), E < b && cr(X, "scope", "col"), es(X, He.fromTag("br")), es(N, X);
    }
    return N;
  }, $_ = (m) => {
    const b = He.fromTag("colgroup");
    return En(m, () => es(b, B_())), b;
  }, t1 = (m, b, C, E) => En(m, (N) => F4(b, C, E, N)), B4 = (m, b, C, E, N, z = F_) => {
    const X = He.fromTag("table"), ue = N !== "cells";
    to(X, z.styles), ea(X, z.attributes), z.colGroups && es(X, $_(b));
    const xe = Math.min(m, C);
    if (ue && C > 0) {
      const bn = He.fromTag("thead");
      es(X, bn);
      const Zn = t1(C, b, N === "sectionCells" ? xe : 0, E);
      ka(bn, Zn);
    }
    const Fe = He.fromTag("tbody");
    es(X, Fe);
    const it = ue ? m - xe : m, _n = t1(it, b, ue ? 0 : C, E);
    return ka(Fe, _n), X;
  }, L_ = (m) => m.dom.innerHTML, lc = (m) => {
    const b = He.fromTag("div"), C = He.fromDom(m.dom.cloneNode(!0));
    return es(b, C), L_(b);
  }, M2 = (m, b) => {
    m.selection.select(b.dom, !0), m.selection.collapse(!0);
  }, I2 = (m, b) => {
    yi(b, "td,th").each(Xe(M2, m));
  }, F2 = (m, b) => {
    Le(Rs(b, "tr"), (C) => {
      $p(m, C.dom), Le(Rs(C, "th,td"), (E) => {
        iy(m, E.dom);
      });
    });
  }, my = (m) => k(m) && m.indexOf("%") !== -1, $4 = (m, b, C, E, N) => {
    const z = Rv(m), X = {
      styles: z,
      attributes: Tl(m),
      colGroups: Fw(m)
    };
    return m.undoManager.ignore(() => {
      const ue = B4(C, b, N, E, Vk(m), X);
      cr(ue, "data-mce-id", "__mce");
      const xe = lc(ue);
      m.insertContent(xe), m.addVisual();
    }), yi(jh(m), 'table[data-mce-id="__mce"]').map((ue) => (Om(m) ? R2(ue) : Hu(m) ? I_(ue) : (kp(m) || my(z.width)) && ig(ue), oc(ue), Oe(ue, "data-mce-id"), F2(m, ue), I2(m, ue), ue.dom)).getOrNull();
  }, L4 = (m, b, C, E = {}) => {
    const N = (z) => Ce(z) && z > 0;
    if (N(b) && N(C)) {
      const z = E.headerRows || 0, X = E.headerColumns || 0;
      return $4(m, C, b, X, z);
    } else
      return console.error("Invalid values for mceInsertTable - rows and columns values are required to insert a table."), null;
  };
  var py = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
  const H_ = "x-tinymce/dom-table-", B2 = H_ + "rows", $2 = H_ + "columns", n1 = (m) => {
    const b = py.FakeClipboardItem(m);
    py.write([b]);
  }, L2 = (m) => {
    var b;
    const C = (b = py.read()) !== null && b !== void 0 ? b : [];
    return mo(C, (E) => ye.from(E.getType(m)));
  }, z_ = (m) => {
    L2(m).isSome() && py.clear();
  }, V_ = (m) => {
    m.fold(H4, (b) => n1({ [B2]: b }));
  }, j_ = () => L2(B2), H4 = () => z_(B2), U_ = (m) => {
    m.fold(Z_, (b) => n1({ [$2]: b }));
  }, W_ = () => L2($2), Z_ = () => z_($2), hy = (m) => Qk(Vu(m), tf(m)).filter(Ep), Eb = (m) => qw(Vu(m), tf(m)).filter(Ep), G_ = (m, b) => {
    const C = tf(m), E = () => hy(m).each((Ut) => {
      Zi(Ut, C).filter(te(C)).each((un) => {
        const Co = He.fromText("");
        if (ua(un, Co), na(un), m.dom.isEmpty(m.getBody()))
          m.setContent(""), m.selection.setCursorLocation();
        else {
          const wn = m.dom.createRng();
          wn.setStart(Co.dom, 0), wn.setEnd(Co.dom, 0), m.selection.setRng(wn), m.nodeChanged();
        }
      });
    }), N = (Ut) => hy(m).each((un) => {
      Hu(m) || Om(m) || kp(m) || Zi(un, C).each((wn) => {
        Ut === "relative" && !D2(wn) ? ig(wn) : Ut === "fixed" && !N_(wn) ? R2(wn) : Ut === "responsive" && !M_(wn) && I_(wn), oc(wn), Lp(m, wn.dom, xs);
      });
    }), z = (Ut) => Zi(Ut, C), X = (Ut) => Eb(m).bind((un) => z(un).map((Co) => Ut(Co, un))), ue = (Ut, un) => {
      X((Co) => {
        m.formatter.toggle("tableclass", { value: un }, Co.dom), Lp(m, Co.dom, fi);
      });
    }, xe = (Ut, un) => {
      X((Co) => {
        const wn = Us(m), ws = Mt(wn, (ps) => m.formatter.match("tablecellclass", { value: un }, ps.dom)) ? m.formatter.remove : m.formatter.apply;
        Le(wn, (ps) => ws("tablecellclass", { value: un }, ps.dom)), Lp(m, Co.dom, fi);
      });
    }, Fe = () => {
      hy(m).each((Ut) => {
        Zi(Ut, C).each((un) => {
          xr(un, "caption").fold(() => {
            const Co = He.fromTag("caption");
            es(Co, He.fromText("Caption")), ai(un, Co, 0), m.selection.setCursorLocation(Co.dom, 0);
          }, (Co) => {
            Tn("caption")(Ut) && Bt("td", un).each((wn) => m.selection.setCursorLocation(wn.dom, 0)), na(Co);
          }), Lp(m, un.dom, xs);
        });
      });
    }, it = (Ut) => {
      m.focus();
    }, qt = (Ut, un = !1) => X((Co, wn) => {
      const Xr = L0(Us(m), Co, wn);
      Ut(Co, Xr, un).each(it);
    }), _n = () => X((Ut, un) => {
      const Co = L0(Us(m), Ut, un), wn = wd(Q, He.fromDom(m.getDoc()), ye.none());
      return uy(Ut, Co, wn);
    }), bn = () => X((Ut, un) => {
      const Co = L0(Us(m), Ut, un);
      return cy(Ut, Co);
    }), ln = (Ut, un) => un().each((Co) => {
      const wn = tn(Co, (Xr) => Ai(Xr));
      X((Xr, ws) => {
        const ps = Tm(He.fromDom(m.getDoc())), nl = Pm(Us(m), ws, wn, ps);
        Ut(Xr, nl).each(it);
      });
    }), Zn = (Ut) => (un, Co) => Mr(Co, "type").each((wn) => {
      qt(Ut(wn), Co.no_events);
    });
    Ct({
      mceTableSplitCells: () => qt(b.unmergeCells),
      mceTableMergeCells: () => qt(b.mergeCells),
      mceTableInsertRowBefore: () => qt(b.insertRowsBefore),
      mceTableInsertRowAfter: () => qt(b.insertRowsAfter),
      mceTableInsertColBefore: () => qt(b.insertColumnsBefore),
      mceTableInsertColAfter: () => qt(b.insertColumnsAfter),
      mceTableDeleteCol: () => qt(b.deleteColumn),
      mceTableDeleteRow: () => qt(b.deleteRow),
      mceTableCutCol: () => bn().each((Ut) => {
        U_(Ut), qt(b.deleteColumn);
      }),
      mceTableCutRow: () => _n().each((Ut) => {
        V_(Ut), qt(b.deleteRow);
      }),
      mceTableCopyCol: () => bn().each((Ut) => U_(Ut)),
      mceTableCopyRow: () => _n().each((Ut) => V_(Ut)),
      mceTablePasteColBefore: () => ln(b.pasteColsBefore, W_),
      mceTablePasteColAfter: () => ln(b.pasteColsAfter, W_),
      mceTablePasteRowBefore: () => ln(b.pasteRowsBefore, j_),
      mceTablePasteRowAfter: () => ln(b.pasteRowsAfter, j_),
      mceTableDelete: E,
      mceTableCellToggleClass: xe,
      mceTableToggleClass: ue,
      mceTableToggleCaption: Fe,
      mceTableSizingMode: (Ut, un) => N(un),
      mceTableCellType: Zn((Ut) => Ut === "th" ? b.makeCellsHeader : b.unmakeCellsHeader),
      mceTableColType: Zn((Ut) => Ut === "th" ? b.makeColumnsHeader : b.unmakeColumnsHeader),
      mceTableRowType: Zn((Ut) => {
        switch (Ut) {
          case "header":
            return b.makeRowsHeader;
          case "footer":
            return b.makeRowsFooter;
          default:
            return b.makeRowsBody;
        }
      })
    }, (Ut, un) => m.addCommand(un, Ut)), m.addCommand("mceInsertTable", (Ut, un) => {
      L4(m, un.rows, un.columns, un.options);
    }), m.addCommand("mceTableApplyCellStyle", (Ut, un) => {
      const Co = (ws) => "tablecell" + ws.toLowerCase().replace("-", "");
      if (!_(un))
        return;
      const wn = St(Us(m), Ep);
      if (wn.length === 0)
        return;
      const Xr = nr(un, (ws, ps) => m.formatter.has(Co(ps)) && k(ws));
      yn(Xr) || (Ct(Xr, (ws, ps) => {
        const nl = Co(ps);
        Le(wn, (ni) => {
          ws === "" ? m.formatter.remove(nl, { value: null }, ni.dom, !0) : m.formatter.apply(nl, { value: ws }, ni.dom);
        });
      }), z(wn[0]).each((ws) => Lp(m, ws.dom, fi)));
    });
  }, z4 = (m, b) => {
    const C = tf(m), E = (N) => qw(Vu(m)).bind((z) => Zi(z, C).map((X) => {
      const ue = L0(Us(m), X, z);
      return N(X, ue);
    })).getOr("");
    Ct({
      mceTableRowType: () => E(b.getTableRowType),
      mceTableCellType: () => E(b.getTableCellType),
      mceTableColType: () => E(b.getTableColType)
    }, (N, z) => m.addQueryValueHandler(z, N));
  }, gy = Wf.generate([
    { before: ["element"] },
    {
      on: [
        "element",
        "offset"
      ]
    },
    { after: ["element"] }
  ]), V4 = (m, b, C, E) => m.fold(b, C, E), _d = (m) => m.fold(ve, ve, ve), by = gy.before, vy = gy.on, yy = gy.after, cc = {
    before: by,
    on: vy,
    after: yy,
    cata: V4,
    getStart: _d
  }, Vp = { create: (m, b) => ({
    selection: m,
    kill: b
  }) }, j4 = (m, b) => {
    const C = m.document.createRange();
    return C.selectNode(b.dom), C;
  }, jp = (m, b) => {
    const C = m.document.createRange();
    return o1(C, b), C;
  }, o1 = (m, b) => m.selectNodeContents(b.dom), U4 = (m, b) => {
    b.fold((C) => {
      m.setStartBefore(C.dom);
    }, (C, E) => {
      m.setStart(C.dom, E);
    }, (C) => {
      m.setStartAfter(C.dom);
    });
  }, W4 = (m, b) => {
    b.fold((C) => {
      m.setEndBefore(C.dom);
    }, (C, E) => {
      m.setEnd(C.dom, E);
    }, (C) => {
      m.setEndAfter(C.dom);
    });
  }, q_ = (m, b, C) => {
    const E = m.document.createRange();
    return U4(E, b), W4(E, C), E;
  }, xy = (m, b, C, E, N) => {
    const z = m.document.createRange();
    return z.setStart(b.dom, C), z.setEnd(E.dom, N), z;
  }, wy = (m) => ({
    left: m.left,
    top: m.top,
    right: m.right,
    bottom: m.bottom,
    width: m.width,
    height: m.height
  }), Z4 = (m) => {
    const b = m.getClientRects(), C = b.length > 0 ? b[0] : m.getBoundingClientRect();
    return C.width > 0 || C.height > 0 ? ye.some(C).map(wy) : ye.none();
  }, r1 = Wf.generate([
    {
      ltr: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    },
    {
      rtl: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]), H2 = (m, b, C) => b(He.fromDom(C.startContainer), C.startOffset, He.fromDom(C.endContainer), C.endOffset), G4 = (m, b) => b.match({
    domRange: (C) => ({
      ltr: G(C),
      rtl: ye.none
    }),
    relative: (C, E) => ({
      ltr: Wd(() => q_(m, C, E)),
      rtl: Wd(() => ye.some(q_(m, E, C)))
    }),
    exact: (C, E, N, z) => ({
      ltr: Wd(() => xy(m, C, E, N, z)),
      rtl: Wd(() => ye.some(xy(m, N, z, C, E)))
    })
  }), z2 = (m, b) => {
    const C = b.ltr();
    return C.collapsed ? b.rtl().filter((N) => N.collapsed === !1).map((N) => r1.rtl(He.fromDom(N.endContainer), N.endOffset, He.fromDom(N.startContainer), N.startOffset)).getOrThunk(() => H2(m, r1.ltr, C)) : H2(m, r1.ltr, C);
  }, V2 = (m, b) => {
    const C = G4(m, b);
    return z2(m, C);
  }, Cy = (m, b) => V2(m, b).match({
    ltr: (E, N, z, X) => {
      const ue = m.document.createRange();
      return ue.setStart(E.dom, N), ue.setEnd(z.dom, X), ue;
    },
    rtl: (E, N, z, X) => {
      const ue = m.document.createRange();
      return ue.setStart(z.dom, X), ue.setEnd(E.dom, N), ue;
    }
  });
  r1.ltr, r1.rtl;
  const lg = { create: (m, b, C, E) => ({
    start: m,
    soffset: b,
    finish: C,
    foffset: E
  }) }, j2 = { create: (m, b, C, E) => ({
    start: cc.on(m, b),
    finish: cc.on(C, E)
  }) }, Y_ = (m, b) => {
    const C = Cy(m, b);
    return lg.create(He.fromDom(C.startContainer), C.startOffset, He.fromDom(C.endContainer), C.endOffset);
  }, Sy = j2.create, K4 = (m, b, C, E, N, z, X) => Wt(C, N) && E === z ? ye.none() : Ns(C, "td,th", b).bind((ue) => Ns(N, "td,th", b).bind((xe) => Up(m, b, ue, xe, X))), Up = (m, b, C, E, N) => Wt(C, E) ? ye.none() : lb(C, E, b).bind((z) => {
    const X = z.boxes.getOr([]);
    return X.length > 1 ? (N(m, X, z.start, z.finish), ye.some(Vp.create(ye.some(Sy(C, 0, C, ml(C))), !0))) : ye.none();
  }), hF = (m, b, C, E, N) => {
    const z = (X) => (N.clearBeforeUpdate(C), N.selectRange(C, X.boxes, X.start, X.finish), X.boxes);
    return Ww(E, m, b, N.firstSelectedSelector, N.lastSelectedSelector).map(z);
  }, Tb = (m, b) => ({
    item: m,
    mode: b
  }), ky = (m, b, C, E = Ob) => m.property().parent(b).map((N) => Tb(N, E)), Ob = (m, b, C, E = Ab) => C.sibling(m, b).map((N) => Tb(N, E)), Ab = (m, b, C, E = Ab) => {
    const N = m.property().children(b);
    return C.first(N).map((X) => Tb(X, E));
  }, Y4 = [
    {
      current: ky,
      next: Ob,
      fallback: ye.none()
    },
    {
      current: Ob,
      next: Ab,
      fallback: ye.some(ky)
    },
    {
      current: Ab,
      next: Ab,
      fallback: ye.some(Ob)
    }
  ], X_ = (m, b, C, E, N = Y4) => Y(N, (X) => X.current === C).bind((X) => X.current(m, b, E, X.next).orThunk(() => X.fallback.bind((ue) => X_(m, b, ue, E)))), Mm = {
    left: () => ({
      sibling: (C, E) => C.query().prevSibling(E),
      first: (C) => C.length > 0 ? ye.some(C[C.length - 1]) : ye.none()
    }),
    right: () => ({
      sibling: (C, E) => C.query().nextSibling(E),
      first: (C) => C.length > 0 ? ye.some(C[0]) : ye.none()
    })
  }, U2 = (m, b, C, E, N, z) => X_(m, b, E, N).bind((ue) => z(ue.item) ? ye.none() : C(ue.item) ? ye.some(ue.item) : U2(m, ue.item, C, ue.mode, N, z)), W2 = (m, b, C, E) => U2(m, b, C, Ob, Mm.left(), E), Q4 = (m, b, C, E) => U2(m, b, C, Ob, Mm.right(), E), Z2 = (m) => (b) => m.property().children(b).length === 0, Q_ = (m, b, C) => eE(m, b, Z2(m), C), J_ = (m, b, C) => Pb(m, b, Z2(m), C), eE = W2, Pb = Q4, Ey = Op(), cg = (m, b) => Q_(Ey, m, b), Im = (m, b) => J_(Ey, m, b), s1 = (m, b, C) => eE(Ey, m, b, C), Db = (m, b, C) => Pb(Ey, m, b, C), J4 = (m, b, C) => fs(m, b, C).isSome(), df = Wf.generate([
    { none: ["message"] },
    { success: [] },
    { failedUp: ["cell"] },
    { failedDown: ["cell"] }
  ]), pu = (m, b, C) => {
    const E = m.getRect(b), N = m.getRect(C);
    return N.right > E.left && N.left < E.right;
  }, Ty = (m) => Ns(m, "tr"), ug = {
    ...df,
    verify: (m, b, C, E, N, z, X) => Ns(E, "td,th", X).bind((ue) => Ns(b, "td,th", X).map((xe) => Wt(ue, xe) ? Wt(E, ue) && ml(ue) === N ? z(xe) : df.none("in same cell") : Sd(Ty, [
      ue,
      xe
    ]).fold(() => pu(m, xe, ue) ? df.success() : z(xe), (Fe) => z(xe)))).getOr(df.none("default")),
    cata: (m, b, C, E, N) => m.fold(b, C, E, N)
  }, Rb = (m, b, C, E) => ({
    parent: m,
    children: b,
    element: C,
    index: E
  }), Nb = (m) => rr(m).bind((b) => {
    const C = ko(b);
    return Dl(C, m).map((E) => Rb(b, C, m, E));
  }), Dl = (m, b) => Wo(m, Xe(Wt, b)), Oy = Tn("br"), dg = (m, b, C) => b(m, C).bind((E) => Ke(E) && $s(E).trim().length === 0 ? dg(E, b, C) : ye.some(E)), Ay = (m, b, C) => C.traverse(b).orThunk(() => dg(b, C.gather, m)).map(C.relative), tE = (m, b) => Yo(m, b).filter(Oy).orThunk(() => Yo(m, b - 1).filter(Oy)), G2 = (m, b, C, E) => tE(b, C).bind((N) => E.traverse(N).fold(() => dg(N, E.gather, m).map(E.relative), (z) => Nb(z).map((X) => cc.on(X.parent, X.index)))), Py = (m, b, C, E) => (Oy(b) ? Ay(m, b, E) : G2(m, b, C, E)).map((z) => ({
    start: z,
    finish: z
  })), Fi = (m) => ug.cata(m, (b) => ye.none(), () => ye.none(), (b) => ye.some(Gc(b, 0)), (b) => ye.some(Gc(b, ml(b)))), Dy = (m, b) => ({
    left: m.left,
    top: m.top + b,
    right: m.right,
    bottom: m.bottom + b
  }), Ed = (m, b) => ({
    left: m.left,
    top: m.top - b,
    right: m.right,
    bottom: m.bottom - b
  }), q2 = (m, b, C) => ({
    left: m.left + b,
    top: m.top + C,
    right: m.right + b,
    bottom: m.bottom + C
  }), K2 = (m) => m.top, Fm = (m) => m.bottom, nE = (m, b, C) => C >= 0 && C < ml(b) ? m.getRangedRect(b, C, b, C + 1) : C > 0 ? m.getRangedRect(b, C - 1, b, C) : ye.none(), Wp = (m) => ({
    left: m.left,
    top: m.top,
    right: m.right,
    bottom: m.bottom
  }), Ry = (m, b) => ye.some(m.getRect(b)), Ny = (m, b, C) => Ss(b) ? Ry(m, b).map(Wp) : Ke(b) ? nE(m, b, C).map(Wp) : ye.none(), Y2 = (m, b) => Ss(b) ? Ry(m, b).map(Wp) : Ke(b) ? m.getRangedRect(b, 0, b, ml(b)).map(Wp) : ye.none(), fg = 5, Mb = 100, pl = Wf.generate([
    { none: [] },
    { retry: ["caret"] }
  ]), oE = (m, b) => m.left < b.left || Math.abs(b.right - m.left) < 1 || m.left > b.right, X2 = (m, b, C) => vi(b, vt).fold(Kt, (E) => Y2(m, E).exists((N) => oE(C, N))), Q2 = (m, b, C, E, N) => {
    const z = Dy(N, fg);
    return Math.abs(C.bottom - E.bottom) < 1 || C.top > N.bottom ? pl.retry(z) : C.top === N.bottom ? pl.retry(Dy(N, 1)) : X2(m, b, N) ? pl.retry(q2(z, fg, 0)) : pl.none();
  }, J2 = {
    point: K2,
    adjuster: (m, b, C, E, N) => {
      const z = Ed(N, fg);
      return Math.abs(C.top - E.top) < 1 || C.bottom < N.top ? pl.retry(z) : C.bottom === N.top ? pl.retry(Ed(N, 1)) : X2(m, b, N) ? pl.retry(q2(z, fg, 0)) : pl.none();
    },
    move: Ed,
    gather: cg
  }, sE = {
    point: Fm,
    adjuster: Q2,
    move: Dy,
    gather: Im
  }, aE = (m, b, C) => m.elementFromPoint(b, C).filter((E) => kr(E) === "table").isSome(), hu = (m, b, C, E, N) => Bm(m, b, C, b.move(E, fg), N), Bm = (m, b, C, E, N) => N === 0 ? ye.some(E) : aE(m, E.left, b.point(E)) ? hu(m, b, C, E, N - 1) : m.situsFromPoint(E.left, b.point(E)).bind((z) => z.start.fold(ye.none, (X) => Y2(m, X).bind((ue) => b.adjuster(m, X, ue, C, E).fold(ye.none, (xe) => Bm(m, b, C, xe, N - 1))).orThunk(() => ye.some(E)), ye.none)), iE = (m, b, C) => m.point(b) > C.getInnerHeight() ? ye.some(m.point(b) - C.getInnerHeight()) : m.point(b) < 0 ? ye.some(-m.point(b)) : ye.none(), mg = (m, b, C) => {
    const E = m.move(C, fg), N = Bm(b, m, C, E, Mb).getOr(E);
    return iE(m, N, b).fold(() => b.situsFromPoint(N.left, m.point(N)), (z) => (b.scrollBy(0, z), b.situsFromPoint(N.left, m.point(N) - z)));
  }, Hl = {
    tryUp: Xe(mg, J2),
    tryDown: Xe(mg, sE),
    getJumpSize: G(fg)
  }, Xc = 20, zl = (m, b, C) => m.getSelection().bind((E) => Py(b, E.finish, E.foffset, C).fold(() => ye.some(Gc(E.finish, E.foffset)), (N) => {
    const z = m.fromSitus(N), X = ug.verify(m, E.finish, E.foffset, z.finish, z.foffset, C.failure, b);
    return Fi(X);
  })), gu = (m, b, C, E, N, z) => z === 0 ? ye.none() : pg(m, b, C, E, N).bind((X) => {
    const ue = m.fromSitus(X), xe = ug.verify(m, C, E, ue.finish, ue.foffset, N.failure, b);
    return ug.cata(xe, () => ye.none(), () => ye.some(X), (Fe) => Wt(C, Fe) && E === 0 ? My(m, C, E, Ed, N) : gu(m, b, Fe, 0, N, z - 1), (Fe) => Wt(C, Fe) && E === ml(Fe) ? My(m, C, E, Dy, N) : gu(m, b, Fe, ml(Fe), N, z - 1));
  }), My = (m, b, C, E, N) => Ny(m, b, C).bind((z) => bu(m, N, E(z, Hl.getJumpSize()))), bu = (m, b, C) => {
    const E = Mh().browser;
    return E.isChromium() || E.isSafari() || E.isFirefox() ? b.retry(m, C) : ye.none();
  }, pg = (m, b, C, E, N) => Ny(m, C, E).bind((z) => bu(m, N, z)), tP = (m, b, C) => zl(m, b, C).bind((E) => gu(m, b, E.element, E.offset, C, Xc).map(m.fromSitus)), lE = (m, b) => J4(m, (C) => rr(C).exists((E) => Wt(E, b))), nP = (m, b, C, E, N) => Ns(E, "td,th", b).bind((z) => Ns(z, "table", b).bind((X) => lE(N, X) ? tP(m, b, C).bind((ue) => Ns(ue.finish, "td,th", b).map((xe) => ({
    start: z,
    finish: xe,
    range: ue
  }))) : ye.none())), cE = (m, b, C, E, N, z) => z(E, b).orThunk(() => nP(m, b, C, E, N).map((X) => {
    const ue = X.range;
    return Vp.create(ye.some(Sy(ue.start, ue.soffset, ue.finish, ue.foffset)), !0);
  })), uE = (m, b) => Ns(m, "tr", b).bind((C) => Ns(C, "table", b).bind((E) => {
    const N = Rs(E, "tr");
    return Wt(C, N[0]) ? s1(E, (z) => nb(z).isSome(), b).map((z) => {
      const X = ml(z);
      return Vp.create(ye.some(Sy(z, X, z, X)), !0);
    }) : ye.none();
  })), eC = (m, b) => Ns(m, "tr", b).bind((C) => Ns(C, "table", b).bind((E) => {
    const N = Rs(E, "tr");
    return Wt(C, N[N.length - 1]) ? Db(E, (z) => jc(z).isSome(), b).map((z) => Vp.create(ye.some(Sy(z, 0, z, 0)), !0)) : ye.none();
  })), tC = (m, b, C, E, N, z, X) => nP(m, C, E, N, z).bind((ue) => Up(b, C, ue.start, ue.finish, X)), tl = (m) => {
    let b = m;
    return {
      get: () => b,
      set: (N) => {
        b = N;
      }
    };
  }, nC = (m) => {
    const b = tl(ye.none()), C = () => b.get().each(m);
    return {
      clear: () => {
        C(), b.set(ye.none());
      },
      isSet: () => b.get().isSome(),
      get: () => b.get(),
      set: (ue) => {
        C(), b.set(ye.some(ue));
      }
    };
  }, Zp = () => {
    const m = nC(Q);
    return {
      ...m,
      on: (C) => m.get().each(C)
    };
  }, Ib = (m, b) => Ns(m, "td,th", b), oC = (m) => Kr(m).exists(Mv), Iy = (m, b, C, E) => {
    const N = Zp(), z = N.clear, X = (it) => {
      N.on((qt) => {
        E.clearBeforeUpdate(b), Ib(it.target, C).each((_n) => {
          lb(qt, _n, C).each((bn) => {
            const ln = bn.boxes.getOr([]);
            if (ln.length === 1) {
              const Zn = ln[0], Ut = Bw(Zn) === "false", un = xc(Nv(it.target), Zn, Wt);
              Ut && un && E.selectRange(b, ln, Zn, Zn);
            } else ln.length > 1 && (E.selectRange(b, ln, bn.start, bn.finish), m.selectContents(_n));
          });
        });
      });
    };
    return {
      clearstate: z,
      mousedown: (it) => {
        E.clear(b), Ib(it.target, C).filter(oC).each(N.set);
      },
      mouseover: (it) => {
        X(it);
      },
      mouseup: (it) => {
        X(it), z();
      }
    };
  }, a1 = {
    traverse: Ti,
    gather: Im,
    relative: cc.before,
    retry: Hl.tryDown,
    failure: ug.failedDown
  }, rC = {
    traverse: Ei,
    gather: cg,
    relative: cc.before,
    retry: Hl.tryUp,
    failure: ug.failedUp
  }, Fb = (m) => (b) => b === m, sC = Fb(38), Gf = Fb(40), hg = (m) => m >= 37 && m <= 40, dE = {
    isBackward: Fb(37),
    isForward: Fb(39)
  }, $m = {
    isBackward: Fb(39),
    isForward: Fb(37)
  }, vu = (m) => {
    const b = m !== void 0 ? m.dom : document, C = b.body.scrollLeft || b.documentElement.scrollLeft, E = b.body.scrollTop || b.documentElement.scrollTop;
    return $t(C, E);
  }, fE = (m, b, C) => {
    const N = (C !== void 0 ? C.dom : document).defaultView;
    N && N.scrollBy(m, b);
  }, qf = Wf.generate([
    { domRange: ["rng"] },
    {
      relative: [
        "startSitu",
        "finishSitu"
      ]
    },
    {
      exact: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]), gg = (m) => qf.exact(m.start, m.soffset, m.finish, m.foffset), aC = (m) => m.match({
    domRange: (b) => He.fromDom(b.startContainer),
    relative: (b, C) => cc.getStart(b),
    exact: (b, C, E, N) => b
  }), Fy = qf.domRange, mE = qf.relative, oP = qf.exact, rP = (m) => {
    const b = aC(m);
    return lo(b);
  }, pE = lg.create, Gp = {
    domRange: Fy,
    relative: mE,
    exact: oP,
    exactFromRange: gg,
    getWin: rP,
    range: pE
  }, Bb = (m, b, C) => {
    var E, N;
    return ye.from((N = (E = m.dom).caretPositionFromPoint) === null || N === void 0 ? void 0 : N.call(E, b, C)).bind((z) => {
      if (z.offsetNode === null)
        return ye.none();
      const X = m.dom.createRange();
      return X.setStart(z.offsetNode, z.offset), X.collapse(), ye.some(X);
    });
  }, i1 = (m, b, C) => {
    var E, N;
    return ye.from((N = (E = m.dom).caretRangeFromPoint) === null || N === void 0 ? void 0 : N.call(E, b, C));
  }, sP = document.caretPositionFromPoint ? Bb : document.caretRangeFromPoint ? i1 : ye.none, aP = (m, b, C) => {
    const E = He.fromDom(m.document);
    return sP(E, b, C).map((N) => lg.create(He.fromDom(N.startContainer), N.startOffset, He.fromDom(N.endContainer), N.endOffset));
  }, $b = (m, b) => {
    const C = kr(m);
    return C === "input" ? cc.after(m) : mn([
      "br",
      "img"
    ], C) ? b === 0 ? cc.before(m) : cc.after(m) : cc.on(m, b);
  }, iC = (m, b) => {
    const C = m.fold(cc.before, $b, cc.after), E = b.fold(cc.before, $b, cc.after);
    return Gp.relative(C, E);
  }, By = (m, b, C, E) => {
    const N = $b(m, b), z = $b(C, E);
    return Gp.relative(N, z);
  }, lC = (m, b, C, E) => {
    const z = Gn(m).dom.createRange();
    return z.setStart(m.dom, b), z.setEnd(C.dom, E), z;
  }, cC = (m, b, C, E) => {
    const N = lC(m, b, C, E), z = Wt(m, C) && b === E;
    return N.collapsed && !z;
  }, Lb = (m) => ye.from(m.getSelection()), uC = (m, b) => {
    Lb(m).each((C) => {
      C.removeAllRanges(), C.addRange(b);
    });
  }, Hb = (m, b, C, E, N) => {
    const z = xy(m, b, C, E, N);
    uC(m, z);
  }, dC = (m, b, C, E, N, z) => {
    b.collapse(C.dom, E), b.extend(N.dom, z);
  }, Br = (m, b) => V2(m, b).match({
    ltr: (C, E, N, z) => {
      Hb(m, C, E, N, z);
    },
    rtl: (C, E, N, z) => {
      Lb(m).each((X) => {
        if (X.setBaseAndExtent)
          X.setBaseAndExtent(C.dom, E, N.dom, z);
        else if (X.extend)
          try {
            dC(m, X, C, E, N, z);
          } catch {
            Hb(m, N, z, C, E);
          }
        else
          Hb(m, N, z, C, E);
      });
    }
  }), Kf = (m, b, C, E, N) => {
    const z = By(b, C, E, N);
    Br(m, z);
  }, bg = (m, b, C) => {
    const E = iC(b, C);
    Br(m, E);
  }, l1 = (m) => {
    if (m.rangeCount > 0) {
      const b = m.getRangeAt(0), C = m.getRangeAt(m.rangeCount - 1);
      return ye.some(lg.create(He.fromDom(b.startContainer), b.startOffset, He.fromDom(C.endContainer), C.endOffset));
    } else
      return ye.none();
  }, fC = (m) => {
    if (m.anchorNode === null || m.focusNode === null)
      return l1(m);
    {
      const b = He.fromDom(m.anchorNode), C = He.fromDom(m.focusNode);
      return cC(b, m.anchorOffset, C, m.focusOffset) ? ye.some(lg.create(b, m.anchorOffset, C, m.focusOffset)) : l1(m);
    }
  }, Lm = (m, b, C = !0) => {
    const N = (C ? jp : j4)(m, b);
    uC(m, N);
  }, mC = (m) => Lb(m).filter((b) => b.rangeCount > 0).bind(fC), $y = (m) => mC(m).map((b) => Gp.exact(b.start, b.soffset, b.finish, b.foffset)), pC = (m, b) => {
    const C = Cy(m, b);
    return Z4(C);
  }, hC = (m, b, C) => aP(m, b, C), vg = (m) => {
    Lb(m).each((b) => b.removeAllRanges());
  }, Ly = (m) => ({
    elementFromPoint: (Ut, un) => He.fromPoint(He.fromDom(m.document), Ut, un),
    getRect: (Ut) => Ut.dom.getBoundingClientRect(),
    getRangedRect: (Ut, un, Co, wn) => {
      const Xr = Gp.exact(Ut, un, Co, wn);
      return pC(m, Xr);
    },
    getSelection: () => $y(m).map((Ut) => Y_(m, Ut)),
    fromSitus: (Ut) => {
      const un = Gp.relative(Ut.start, Ut.finish);
      return Y_(m, un);
    },
    situsFromPoint: (Ut, un) => hC(m, Ut, un).map((Co) => j2.create(Co.start, Co.soffset, Co.finish, Co.foffset)),
    clearSelection: () => {
      vg(m);
    },
    collapseSelection: (Ut = !1) => {
      $y(m).each((un) => un.fold((Co) => Co.collapse(Ut), (Co, wn) => {
        const Xr = Ut ? Co : wn;
        bg(m, Xr, Xr);
      }, (Co, wn, Xr, ws) => {
        const ps = Ut ? Co : Xr, nl = Ut ? wn : ws;
        Kf(m, ps, nl, ps, nl);
      }));
    },
    setSelection: (Ut) => {
      Kf(m, Ut.start, Ut.soffset, Ut.finish, Ut.foffset);
    },
    setRelativeSelection: (Ut, un) => {
      bg(m, Ut, un);
    },
    selectNode: (Ut) => {
      Lm(m, Ut, !1);
    },
    selectContents: (Ut) => {
      Lm(m, Ut);
    },
    getInnerHeight: () => m.innerHeight,
    getScrollY: () => vu(He.fromDom(m.document)).top,
    scrollBy: (Ut, un) => {
      fE(Ut, un, He.fromDom(m.document));
    }
  }), yg = (m, b) => ({
    rows: m,
    cols: b
  }), Hy = (m, b, C, E) => {
    const N = Ly(m), z = Iy(N, b, C, E);
    return {
      clearstate: z.clearstate,
      mousedown: z.mousedown,
      mouseover: z.mouseover,
      mouseup: z.mouseup
    };
  }, hE = (m) => vi(m, Xn).exists(Mv), zb = (m, b) => hE(m) || hE(b), zy = (m, b, C, E) => {
    const N = Ly(m), z = () => (E.clear(b), ye.none());
    return {
      keydown: (xe, Fe, it, qt, _n, bn) => {
        const ln = xe.raw, Zn = ln.which, Ut = ln.shiftKey === !0;
        return Bv(b, E.selectedSelector).fold(() => (hg(Zn) && !Ut && E.clearBeforeUpdate(b), hg(Zn) && Ut && !zb(Fe, qt) ? ye.none : Gf(Zn) && Ut ? Xe(tC, N, b, C, a1, qt, Fe, E.selectRange) : sC(Zn) && Ut ? Xe(tC, N, b, C, rC, qt, Fe, E.selectRange) : Gf(Zn) ? Xe(cE, N, C, a1, qt, Fe, eC) : sC(Zn) ? Xe(cE, N, C, rC, qt, Fe, uE) : ye.none), (Co) => {
          const wn = (Xr) => () => mo(Xr, (ps) => hF(ps.rows, ps.cols, b, Co, E)).fold(() => qk(b, E.firstSelectedSelector, E.lastSelectedSelector).map((ps) => {
            const nl = Gf(Zn) || bn.isForward(Zn) ? cc.after : cc.before;
            return N.setRelativeSelection(cc.on(ps.first, 0), nl(ps.table)), E.clear(b), Vp.create(ye.none(), !0);
          }), (ps) => ye.some(Vp.create(ye.none(), !0)));
          return hg(Zn) && Ut && !zb(Fe, qt) ? ye.none : Gf(Zn) && Ut ? wn([yg(1, 0)]) : sC(Zn) && Ut ? wn([yg(-1, 0)]) : bn.isBackward(Zn) && Ut ? wn([
            yg(0, -1),
            yg(-1, 0)
          ]) : bn.isForward(Zn) && Ut ? wn([
            yg(0, 1),
            yg(1, 0)
          ]) : hg(Zn) && !Ut ? z : ye.none;
        })();
      },
      keyup: (xe, Fe, it, qt, _n) => Bv(b, E.selectedSelector).fold(() => {
        const bn = xe.raw, ln = bn.which;
        return bn.shiftKey === !0 && hg(ln) && zb(Fe, qt) ? K4(b, C, Fe, it, qt, _n, E.selectRange) : ye.none();
      }, ye.none)
    };
  }, iP = (m, b, C, E) => {
    const N = Ly(m);
    return (z, X) => {
      E.clearBeforeUpdate(b), lb(z, X, C).each((ue) => {
        const xe = ue.boxes.getOr([]);
        E.selectRange(b, xe, ue.start, ue.finish), N.selectContents(X), N.collapseSelection();
      });
    };
  }, Vy = (m, b) => {
    const C = Ps(m, b);
    return C === void 0 || C === "" ? [] : C.split(" ");
  }, Hm = (m, b, C) => {
    const N = Vy(m, b).concat([C]);
    return cr(m, b, N.join(" ")), !0;
  }, lP = (m, b, C) => {
    const E = St(Vy(m, b), (N) => N !== C);
    return E.length > 0 ? cr(m, b, E.join(" ")) : Oe(m, b), !1;
  }, c1 = (m) => m.dom.classList !== void 0, Wu = (m) => Vy(m, "class"), Bi = (m, b) => Hm(m, "class", b), cP = (m, b) => lP(m, "class", b), ff = (m, b) => {
    c1(m) ? m.dom.classList.add(b) : Bi(m, b);
  }, uP = (m) => {
    (c1(m) ? m.dom.classList : Wu(m)).length === 0 && Oe(m, "class");
  }, gE = (m, b) => {
    c1(m) ? m.dom.classList.remove(b) : cP(m, b), uP(m);
  }, u1 = (m, b) => c1(m) && m.dom.classList.contains(b), Vb = (m, b) => {
    Le(b, (C) => {
      gE(m, C);
    });
  }, bE = (m) => (b) => {
    ff(b, m);
  }, vE = (m) => (b) => {
    Vb(b, m);
  }, yE = {
    byClass: (m) => {
      const b = bE(m.selected), C = vE([
        m.selected,
        m.lastSelected,
        m.firstSelected
      ]), E = (z) => {
        const X = Rs(z, m.selectedSelector);
        Le(X, C);
      };
      return {
        clearBeforeUpdate: E,
        clear: E,
        selectRange: (z, X, ue, xe) => {
          E(z), Le(X, b), ff(ue, m.firstSelected), ff(xe, m.lastSelected);
        },
        selectedSelector: m.selectedSelector,
        firstSelectedSelector: m.firstSelectedSelector,
        lastSelectedSelector: m.lastSelectedSelector
      };
    },
    byAttr: (m, b, C) => {
      const E = (xe) => {
        Oe(xe, m.selected), Oe(xe, m.firstSelected), Oe(xe, m.lastSelected);
      }, N = (xe) => {
        cr(xe, m.selected, "1");
      }, z = (xe) => {
        X(xe), C();
      }, X = (xe) => {
        const Fe = Rs(xe, `${m.selectedSelector},${m.firstSelectedSelector},${m.lastSelectedSelector}`);
        Le(Fe, E);
      };
      return {
        clearBeforeUpdate: X,
        clear: z,
        selectRange: (xe, Fe, it, qt) => {
          z(xe), Le(Fe, N), cr(it, m.firstSelected, "1"), cr(qt, m.lastSelected, "1"), b(Fe, it, qt);
        },
        selectedSelector: m.selectedSelector,
        firstSelectedSelector: m.firstSelectedSelector,
        lastSelectedSelector: m.lastSelectedSelector
      };
    }
  }, xE = (m, b, C, E) => {
    switch (m.tag) {
      case "none":
        return b();
      case "single":
        return E(m.element);
      case "multiple":
        return C(m.elements);
    }
  }, Mn = () => ({ tag: "none" }), $i = (m) => ({
    tag: "multiple",
    elements: m
  }), d1 = (m) => ({
    tag: "single",
    element: m
  }), Li = (m, b, C) => ({ get: () => Ap(m(), C).fold(() => b().fold(Mn, d1), $i) }), Zu = (m, b) => {
    const C = m.slice(0, b[b.length - 1].row + 1), E = G0(C);
    return Ot(E, (N) => {
      const z = N.cells.slice(0, b[b.length - 1].column + 1);
      return tn(z, (X) => X.element);
    });
  }, gC = (m, b) => {
    const C = m.slice(b[0].row + b[0].rowspan - 1, m.length), E = G0(C);
    return Ot(E, (N) => {
      const z = N.cells.slice(b[0].column + b[0].colspan - 1, N.cells.length);
      return tn(z, (X) => X.element);
    });
  }, xg = (m, b, C) => {
    const E = dr.fromTable(m);
    return sf(E, b).map((z) => {
      const X = hb(E, C, !1), { rows: ue } = Na(X), xe = Zu(ue, z), Fe = gC(ue, z);
      return {
        upOrLeftCells: xe,
        downOrRightCells: Fe
      };
    });
  }, jy = (m, b, C, E, N, z, X) => ({
    target: m,
    x: b,
    y: C,
    stop: E,
    prevent: N,
    kill: z,
    raw: X
  }), qp = (m) => {
    const b = He.fromDom(rn(m).getOr(m.target)), C = () => m.stopPropagation(), E = () => m.preventDefault(), N = oe(E, C);
    return jy(b, m.clientX, m.clientY, C, E, N, m);
  }, f1 = (m, b) => (C) => {
    m(C) && b(qp(C));
  }, wE = (m, b, C, E, N) => {
    const z = f1(C, E);
    return m.dom.addEventListener(b, z, N), { unbind: Xe(fP, m, b, z, N) };
  }, dP = (m, b, C, E) => wE(m, b, C, E, !1), fP = (m, b, C, E) => {
    m.dom.removeEventListener(b, C, E);
  }, mP = je, Kp = (m, b, C) => dP(m, b, mP, C), m1 = qp, p1 = (m) => !u1(He.fromDom(m.target), "ephox-snooker-resizer-bar"), Uy = (m, b) => {
    const C = Li(() => He.fromDom(m.getBody()), () => qw(Vu(m), tf(m)), Am.selectedSelector), E = (xe, Fe, it) => {
      Zi(Fe).each((_n) => {
        const bn = tn(xe, (Co) => Co.dom), ln = zk(m), Zn = wd(Q, He.fromDom(m.getDoc()), ln), Ut = Us(m), un = xg(_n, { selection: Ut }, Zn).map((Co) => Jn(Co, (wn) => tn(wn, (Xr) => Xr.dom))).getOrUndefined();
        D4(m, bn, Fe.dom, it.dom, un);
      });
    }, N = () => R4(m), z = yE.byAttr(Am, E, N);
    return m.on("init", (xe) => {
      const Fe = m.getWin(), it = jh(m), qt = tf(m), _n = () => {
        const as = m.selection, dc = He.fromDom(as.getStart()), fc = He.fromDom(as.getEnd());
        Sd(Zi, [
          dc,
          fc
        ]).fold(() => z.clear(it), Q);
      }, bn = Hy(Fe, it, qt, z), ln = zy(Fe, it, qt, z), Zn = iP(Fe, it, qt, z), Ut = (as) => as.raw.shiftKey === !0;
      m.on("TableSelectorChange", (as) => Zn(as.start, as.finish));
      const un = (as, dc) => {
        Ut(as) && (dc.kill && as.kill(), dc.selection.each((fc) => {
          const qu = Gp.relative(fc.start, fc.finish), Ku = Cy(Fe, qu);
          m.selection.setRng(Ku);
        }));
      }, Co = (as) => {
        const dc = m1(as);
        if (dc.raw.shiftKey && hg(dc.raw.which)) {
          const fc = m.selection.getRng(), qu = He.fromDom(fc.startContainer), Ku = He.fromDom(fc.endContainer);
          ln.keyup(dc, qu, fc.startOffset, Ku, fc.endOffset).each((Cr) => {
            un(dc, Cr);
          });
        }
      }, wn = (as) => {
        const dc = m1(as);
        b.hide();
        const fc = m.selection.getRng(), qu = He.fromDom(fc.startContainer), Ku = He.fromDom(fc.endContainer), Cr = bp(dE, $m)(He.fromDom(m.selection.getStart()));
        ln.keydown(dc, qu, fc.startOffset, Ku, fc.endOffset, Cr).each((Aa) => {
          un(dc, Aa);
        }), b.show();
      }, Xr = (as) => as.button === 0, ws = (as) => as.buttons === void 0 ? !0 : (as.buttons & 1) !== 0, ps = (as) => {
        bn.clearstate();
      }, nl = (as) => {
        Xr(as) && p1(as) && bn.mousedown(m1(as));
      }, ni = (as) => {
        ws(as) && p1(as) && bn.mouseover(m1(as));
      }, Xf = (as) => {
        Xr(as) && p1(as) && bn.mouseup(m1(as));
      }, eh = (() => {
        const as = tl(He.fromDom(it)), dc = tl(0);
        return { touchEnd: (qu) => {
          const Ku = He.fromDom(qu.target);
          if (Tn("td")(Ku) || Tn("th")(Ku)) {
            const Cr = as.get(), Aa = dc.get();
            Wt(Cr, Ku) && qu.timeStamp - Aa < 300 && (qu.preventDefault(), Zn(Ku, Ku));
          }
          as.set(Ku), dc.set(qu.timeStamp);
        } };
      })();
      m.on("dragstart", ps), m.on("mousedown", nl), m.on("mouseover", ni), m.on("mouseup", Xf), m.on("touchend", eh.touchEnd), m.on("keyup", Co), m.on("keydown", wn), m.on("NodeChange", _n);
    }), m.on("PreInit", () => {
      m.serializer.addTempAttr(Am.firstSelected), m.serializer.addTempAttr(Am.lastSelected);
    }), {
      getSelectedCells: () => xE(C.get(), G([]), (xe) => tn(xe, (Fe) => Fe.dom), (xe) => [xe.dom]),
      clearSelectedCells: (xe) => z.clear(He.fromDom(xe))
    };
  }, Qc = (m) => {
    let b = [];
    return {
      bind: (z) => {
        if (z === void 0)
          throw new Error("Event bind error: undefined handler");
        b.push(z);
      },
      unbind: (z) => {
        b = St(b, (X) => X !== z);
      },
      trigger: (...z) => {
        const X = {};
        Le(m, (ue, xe) => {
          X[ue] = z[xe];
        }), Le(b, (ue) => {
          ue(X);
        });
      }
    };
  }, Yf = (m) => {
    const b = Jn(m, (E) => ({
      bind: E.bind,
      unbind: E.unbind
    })), C = Jn(m, (E) => E.trigger);
    return {
      registry: b,
      trigger: C
    };
  }, Yp = (m, b) => {
    let C = null;
    const E = () => {
      L(C) || (clearTimeout(C), C = null);
    };
    return {
      cancel: E,
      throttle: (...z) => {
        E(), C = setTimeout(() => {
          C = null, m.apply(null, z);
        }, b);
      }
    };
  }, Xp = (m) => m.slice(0).sort(), pP = (m, b) => {
    throw new Error("All required keys (" + Xp(m).join(", ") + ") were not specified. Specified keys were: " + Xp(b).join(", ") + ".");
  }, Wy = (m) => {
    throw new Error("Unsupported keys for object: " + Xp(m).join(", "));
  }, Zy = (m, b) => {
    if (!D(b))
      throw new Error("The " + m + " fields must be an array. Was: " + b + ".");
    Le(b, (C) => {
      if (!k(C))
        throw new Error("The value " + C + " in the " + m + " fields was not a string.");
    });
  }, hP = (m, b) => {
    throw new Error("All values need to be of type: " + b + ". Keys (" + Xp(m).join(", ") + ") were not.");
  }, gP = (m) => {
    const b = Xp(m);
    Y(b, (E, N) => N < b.length - 1 && E === b[N + 1]).each((E) => {
      throw new Error("The field: " + E + " occurs more than once in the combined fields: [" + b.join(", ") + "].");
    });
  }, bP = (m, b) => vP(m, b, {
    validate: ke,
    label: "function"
  }), vP = (m, b, C) => {
    if (b.length === 0)
      throw new Error("You must specify at least one required field.");
    return Zy("required", b), gP(b), (E) => {
      const N = xn(E);
      Mt(b, (ue) => mn(N, ue)) || pP(b, N), m(b, N);
      const X = St(b, (ue) => !C.validate(E[ue], ue));
      return X.length > 0 && hP(X, C.label), E;
    };
  }, CE = (m, b) => {
    const C = St(b, (E) => !mn(m, E));
    C.length > 0 && Wy(C);
  }, Gy = (m) => bP(CE, m), yP = Gy([
    "compare",
    "extract",
    "mutate",
    "sink"
  ]), qy = Gy([
    "element",
    "start",
    "stop",
    "destroy"
  ]), hl = Gy([
    "forceDrop",
    "drop",
    "move",
    "delayDrop"
  ]), Gu = () => {
    let m = ye.none();
    const b = () => {
      m = ye.none();
    }, C = (z, X) => {
      const ue = m.map((xe) => z.compare(xe, X));
      return m = ye.some(X), ue;
    }, E = (z, X) => {
      X.extract(z).each((xe) => {
        C(X, xe).each((it) => {
          N.trigger.move(it);
        });
      });
    }, N = Yf({ move: Qc(["info"]) });
    return {
      onEvent: E,
      reset: b,
      events: N.registry
    };
  }, yu = () => {
    const m = Yf({ move: Qc(["info"]) });
    return {
      onEvent: Q,
      reset: Q,
      events: m.registry
    };
  }, Ky = () => {
    const m = yu(), b = Gu();
    let C = m;
    return {
      on: () => {
        C.reset(), C = b;
      },
      off: () => {
        C.reset(), C = m;
      },
      isOn: () => C === b,
      onEvent: (ue, xe) => {
        C.onEvent(ue, xe);
      },
      events: b.events
    };
  }, Yy = (m, b, C) => {
    let E = !1;
    const N = Yf({
      start: Qc([]),
      stop: Qc([])
    }), z = Ky(), X = () => {
      ln.stop(), z.isOn() && (z.off(), N.trigger.stop());
    }, ue = Yp(X, 200), xe = (Ut) => {
      ln.start(Ut), z.on(), N.trigger.start();
    }, Fe = (Ut) => {
      ue.cancel(), z.onEvent(Ut, b);
    };
    z.events.move.bind((Ut) => {
      b.mutate(m, Ut.info);
    });
    const it = () => {
      E = !0;
    }, qt = () => {
      E = !1;
    }, _n = () => E, bn = (Ut) => (...un) => {
      E && Ut.apply(null, un);
    }, ln = b.sink(hl({
      forceDrop: X,
      drop: bn(X),
      move: bn(Fe),
      delayDrop: bn(ue.throttle)
    }), C), Zn = () => {
      ln.destroy();
    };
    return {
      element: ln.element,
      go: xe,
      on: it,
      off: qt,
      isActive: _n,
      destroy: Zn,
      events: N.registry
    };
  }, SE = (m) => {
    const b = m.replace(/\./g, "-");
    return { resolve: (E) => b + "-" + E };
  }, kE = SE("ephox-dragster").resolve, vC = (m) => {
    const b = {
      layerClass: kE("blocker"),
      ...m
    }, C = He.fromTag("div");
    return cr(C, "role", "presentation"), to(C, {
      position: "fixed",
      left: "0px",
      top: "0px",
      width: "100%",
      height: "100%"
    }), ff(C, kE("blocker")), ff(C, b.layerClass), {
      element: G(C),
      destroy: () => {
        na(C);
      }
    };
  };
  var Xy = yP({
    compare: (m, b) => $t(b.left - m.left, b.top - m.top),
    extract: (m) => ye.some($t(m.x, m.y)),
    sink: (m, b) => {
      const C = vC(b), E = Kp(C.element(), "mousedown", m.forceDrop), N = Kp(C.element(), "mouseup", m.drop), z = Kp(C.element(), "mousemove", m.move), X = Kp(C.element(), "mouseout", m.delayDrop), ue = () => {
        C.destroy(), N.unbind(), z.unbind(), X.unbind(), E.unbind();
      }, xe = (it) => {
        es(it, C.element());
      }, Fe = () => {
        na(C.element());
      };
      return qy({
        element: C.element,
        start: xe,
        stop: Fe,
        destroy: ue
      });
    },
    mutate: (m, b) => {
      m.mutate(b.left, b.top);
    }
  });
  const yC = (m, b = {}) => {
    var C;
    const E = (C = b.mode) !== null && C !== void 0 ? C : Xy;
    return Yy(m, E, b);
  }, uc = SE("ephox-snooker").resolve, TE = () => {
    const m = Yf({
      drag: Qc([
        "xDelta",
        "yDelta"
      ])
    });
    return {
      mutate: (C, E) => {
        m.trigger.drag(C, E);
      },
      events: m.registry
    };
  }, xC = () => {
    const m = Yf({
      drag: Qc([
        "xDelta",
        "yDelta",
        "target"
      ])
    });
    let b = ye.none();
    const C = TE();
    return C.events.drag.bind((z) => {
      b.each((X) => {
        m.trigger.drag(z.xDelta, z.yDelta, X);
      });
    }), {
      assign: (z) => {
        b = ye.some(z);
      },
      get: () => b,
      mutate: C.mutate,
      events: m.registry
    };
  }, h1 = (m, b, C, E, N) => {
    const z = He.fromTag("div");
    return to(z, {
      position: "absolute",
      left: b - E / 2 + "px",
      top: C + "px",
      height: N + "px",
      width: E + "px"
    }), ea(z, {
      "data-column": m,
      role: "presentation"
    }), z;
  }, g1 = (m, b, C, E, N) => {
    const z = He.fromTag("div");
    return to(z, {
      position: "absolute",
      left: b + "px",
      top: C - N / 2 + "px",
      height: N + "px",
      width: E + "px"
    }), ea(z, {
      "data-row": m,
      role: "presentation"
    }), z;
  }, Qy = uc("resizer-bar"), b1 = uc("resizer-rows"), OE = uc("resizer-cols"), AE = 7, wC = (m, b) => Ot(m.all, (C, E) => b(C.element) ? [E] : []), CC = (m, b) => {
    const C = [];
    return En(m.grid.columns, (E) => {
      dr.getColumnAt(m, E).map((z) => z.element).forall(b) && C.push(E);
    }), St(C, (E) => {
      const N = dr.filterItems(m, (z) => z.column === E);
      return Mt(N, (z) => b(z.element));
    });
  }, zm = (m) => {
    const b = Rs(m.parent(), "." + Qy);
    Le(b, na);
  }, SC = (m, b, C) => {
    const E = m.origin();
    Le(b, (N) => {
      N.each((z) => {
        const X = C(E, z);
        ff(X, Qy), es(m.parent(), X);
      });
    });
  }, PE = (m, b, C, E) => {
    SC(m, b, (N, z) => {
      const X = h1(z.col, z.x - N.left, C.top - N.top, AE, E);
      return ff(X, OE), X;
    });
  }, CP = (m, b, C, E) => {
    SC(m, b, (N, z) => {
      const X = g1(z.row, C.left - N.left, z.y - N.top, E, AE);
      return ff(X, b1), X;
    });
  }, SP = (m, b, C, E, N) => {
    const z = Mo(C), X = b.isResizable, ue = E.length > 0 ? Ni.positions(E, C) : [], xe = ue.length > 0 ? wC(m, X) : [], Fe = St(ue, (bn, ln) => dt(xe, (Zn) => ln === Zn));
    CP(b, Fe, z, ms(C));
    const it = N.length > 0 ? yp.positions(N, C) : [], qt = it.length > 0 ? CC(m, X) : [], _n = St(it, (bn, ln) => dt(qt, (Zn) => ln === Zn));
    PE(b, _n, z, re(C));
  }, DE = (m, b) => {
    if (zm(m), m.isResizable(b)) {
      const C = dr.fromTable(b), E = gp(C), N = Kd(C);
      SP(C, m, b, E, N);
    }
  }, Pc = (m, b) => {
    const C = Rs(m.parent(), "." + Qy);
    Le(C, b);
  }, Vl = (m) => {
    Pc(m, (b) => {
      pt(b, "display", "none");
    });
  }, jb = (m) => {
    Pc(m, (b) => {
      pt(b, "display", "block");
    });
  }, yF = (m) => u1(m, b1), kP = (m) => u1(m, OE), kC = uc("resizer-bar-dragging"), Nr = (m) => {
    const b = xC(), C = yC(b, {});
    let E = ye.none();
    const N = (ln, Zn) => ye.from(Ps(ln, Zn));
    b.events.drag.bind((ln) => {
      N(ln.target, "data-row").each((Zn) => {
        const Ut = ul(ln.target, "top");
        pt(ln.target, "top", Ut + ln.yDelta + "px");
      }), N(ln.target, "data-column").each((Zn) => {
        const Ut = ul(ln.target, "left");
        pt(ln.target, "left", Ut + ln.xDelta + "px");
      });
    });
    const z = (ln, Zn) => {
      const Ut = ul(ln, Zn), un = Ms(ln, "data-initial-" + Zn, 0);
      return Ut - un;
    };
    C.events.stop.bind(() => {
      b.get().each((ln) => {
        E.each((Zn) => {
          N(ln, "data-row").each((Ut) => {
            const un = z(ln, "top");
            Oe(ln, "data-initial-top"), bn.trigger.adjustHeight(Zn, un, parseInt(Ut, 10));
          }), N(ln, "data-column").each((Ut) => {
            const un = z(ln, "left");
            Oe(ln, "data-initial-left"), bn.trigger.adjustWidth(Zn, un, parseInt(Ut, 10));
          }), DE(m, Zn);
        });
      });
    });
    const X = (ln, Zn) => {
      bn.trigger.startAdjust(), b.assign(ln), cr(ln, "data-initial-" + Zn, ul(ln, Zn)), ff(ln, kC), pt(ln, "opacity", "0.2"), C.go(m.parent());
    }, ue = Kp(m.parent(), "mousedown", (ln) => {
      yF(ln.target) && X(ln.target, "top"), kP(ln.target) && X(ln.target, "left");
    }), xe = (ln) => Wt(ln, m.view()), Fe = (ln) => Ns(ln, "table", xe).filter(Mv), it = Kp(m.view(), "mouseover", (ln) => {
      Fe(ln.target).fold(() => {
        os(ln.target) && zm(m);
      }, (Zn) => {
        C.isActive() && (E = ye.some(Zn), DE(m, Zn));
      });
    }), qt = () => {
      ue.unbind(), it.unbind(), C.destroy(), zm(m);
    }, _n = (ln) => {
      DE(m, ln);
    }, bn = Yf({
      adjustHeight: Qc([
        "table",
        "delta",
        "row"
      ]),
      adjustWidth: Qc([
        "table",
        "delta",
        "column"
      ]),
      startAdjust: Qc([])
    });
    return {
      destroy: qt,
      refresh: _n,
      on: C.on,
      off: C.off,
      hideBars: Xe(Vl, m),
      showBars: Xe(jb, m),
      events: bn.registry
    };
  }, RE = { create: (m, b, C) => {
    const E = Ni, N = yp, z = Nr(m), X = Yf({
      beforeResize: Qc([
        "table",
        "type"
      ]),
      afterResize: Qc([
        "table",
        "type"
      ]),
      startDrag: Qc([])
    });
    return z.events.adjustHeight.bind((ue) => {
      const xe = ue.table;
      X.trigger.beforeResize(xe, "row");
      const Fe = E.delta(ue.delta, xe);
      l2(xe, Fe, ue.row), X.trigger.afterResize(xe, "row");
    }), z.events.startAdjust.bind((ue) => {
      X.trigger.startDrag();
    }), z.events.adjustWidth.bind((ue) => {
      const xe = ue.table;
      X.trigger.beforeResize(xe, "col");
      const Fe = N.delta(ue.delta, xe), it = C(xe);
      d_(xe, Fe, ue.column, b, it), X.trigger.afterResize(xe, "col");
    }), {
      on: z.on,
      off: z.off,
      refreshBars: z.refresh,
      hideBars: z.hideBars,
      showBars: z.showBars,
      destroy: z.destroy,
      events: X.registry
    };
  } }, v1 = {
    only: (m, b) => {
      const C = bt(m) ? Qn(m) : m;
      return {
        parent: G(C),
        view: G(m),
        origin: G($t(0, 0)),
        isResizable: b
      };
    },
    detached: (m, b, C) => {
      const E = () => Mo(b);
      return {
        parent: G(b),
        view: G(m),
        origin: E,
        isResizable: C
      };
    },
    body: (m, b, C) => ({
      parent: G(b),
      view: G(m),
      origin: G($t(0, 0)),
      isResizable: C
    })
  }, _P = () => {
    const m = He.fromTag("div");
    return to(m, {
      position: "static",
      height: "0",
      width: "0",
      padding: "0",
      margin: "0",
      border: "0"
    }), es(K(), m), m;
  }, EP = (m, b) => m.inline ? v1.body(He.fromDom(m.getBody()), _P(), b) : v1.only(He.fromDom(m.getDoc()), b), TP = (m, b) => {
    m.inline && na(b.parent());
  }, Jy = (m) => be(m) && m.nodeName === "TABLE", y1 = "bar-", ME = (m) => Ps(m, "data-mce-resize") !== "false", CF = (m) => {
    const b = dr.fromTable(m);
    dr.hasColumns(b) || Le(dd(m), (C) => {
      const E = sr(C, "width");
      pt(C, "width", E), Oe(C, "width");
    });
  }, Ub = (m) => Ga(m, "corner-"), _C = (m) => Yl(m, "corner-"), SF = (m) => {
    const b = Zp(), C = Zp(), E = Zp();
    let N, z, X, ue;
    const xe = (un) => ti(m, un), Fe = () => Ta(m) ? Dp() : qh(), it = (un) => jf(un).columns, qt = (un) => jf(un).rows, _n = (un, Co, wn, Xr) => {
      const ws = _C(Co), ps = xi(ws, "e"), nl = Ga(ws, "n");
      if (z === "" && ig(un), ue === "" && N2(un), wn !== N && z !== "") {
        pt(un, "width", z);
        const ni = Fe(), Xf = xe(un), Jp = Ta(m) || ps ? it(un) - 1 : 0;
        d_(un, wn - N, Jp, ni, Xf);
      } else if (Uk(z)) {
        const ni = parseFloat(z.replace("%", "")), Xf = wn * ni / N;
        pt(un, "width", Xf + "%");
      }
      if (Wk(z) && CF(un), Xr !== X && ue !== "") {
        pt(un, "height", ue);
        const ni = nl ? 0 : qt(un) - 1;
        l2(un, Xr - X, ni);
      }
    }, bn = () => {
      C.on((un) => {
        un.destroy();
      }), E.on((un) => {
        TP(m, un);
      });
    };
    return m.on("init", () => {
      const un = EP(m, ME);
      if (E.set(un), Qd(m) && zu(m)) {
        const Co = Fe(), wn = RE.create(un, Co, xe);
        wn.on(), wn.events.startDrag.bind((Xr) => {
          b.set(m.selection.getRng());
        }), wn.events.beforeResize.bind((Xr) => {
          const ws = Xr.table.dom;
          di(m, ws, _p(ws), $w(ws), y1 + Xr.type);
        }), wn.events.afterResize.bind((Xr) => {
          const ws = Xr.table, ps = ws.dom;
          oc(ws), b.on((nl) => {
            m.selection.setRng(nl), m.focus();
          }), ei(m, ps, _p(ps), $w(ps), y1 + Xr.type), m.undoManager.add();
        }), C.set(wn);
      }
    }), m.on("ObjectResizeStart", (un) => {
      const Co = un.target;
      if (Jy(Co)) {
        const wn = He.fromDom(Co);
        Le(m.dom.select(".mce-clonedresizable"), (Xr) => {
          m.dom.addClass(Xr, "mce-" + Iw(m) + "-columns");
        }), !N_(wn) && Om(m) ? R2(wn) : !D2(wn) && kp(m) && ig(wn), M_(wn) && Ga(un.origin, y1) && ig(wn), N = un.width, z = Hu(m) ? "" : Lw(m, Co).getOr(""), X = un.height, ue = jk(m, Co).getOr("");
      }
    }), m.on("ObjectResized", (un) => {
      const Co = un.target;
      if (Jy(Co)) {
        const wn = He.fromDom(Co), Xr = un.origin;
        Ub(Xr) && _n(wn, Xr, un.width, un.height), oc(wn), Lp(m, wn.dom, fi);
      }
    }), m.on("SwitchMode", () => {
      C.on((un) => {
        m.mode.isReadOnly() ? un.hideBars() : un.showBars();
      });
    }), m.on("dragstart dragend", (un) => {
      C.on((Co) => {
        un.type === "dragstart" ? (Co.hideBars(), Co.off()) : (Co.on(), Co.showBars());
      });
    }), m.on("remove", () => {
      bn();
    }), {
      refresh: (un) => {
        C.on((Co) => Co.refreshBars(He.fromDom(un)));
      },
      hide: () => {
        C.on((un) => un.hideBars());
      },
      show: () => {
        C.on((un) => un.showBars());
      }
    };
  }, IE = (m) => {
    Vh(m);
    const b = SF(m), C = Uy(m, b), E = E2(m, b, C);
    return G_(m, E), z4(m, E), ub(m, E), {
      getSelectedCells: C.getSelectedCells,
      clearSelectedCells: C.clearSelectedCells
    };
  }, OP = (m) => ({ table: IE(m) });
  var _o = () => {
    o.add("dom", OP);
  };
  _o();
})();
(function() {
  const o = Object.getPrototypeOf, r = (t, a, c) => {
    var f;
    return c(t, a.prototype) ? !0 : ((f = t.constructor) === null || f === void 0 ? void 0 : f.name) === a.name;
  }, i = (t) => {
    const a = typeof t;
    return t === null ? "null" : a === "object" && Array.isArray(t) ? "array" : a === "object" && r(t, String, (c, f) => f.isPrototypeOf(c)) ? "string" : a;
  }, u = (t) => (a) => i(a) === t, h = (t) => (a) => typeof a === t, y = (t) => (a) => t === a, k = (t, a) => D(t) && r(t, a, (c, f) => o(c) === f), _ = u("string"), D = u("object"), L = (t) => k(t, Object), W = u("array"), se = y(null), J = h("boolean"), be = y(void 0), ke = (t) => t == null, Ce = (t) => !ke(t), Q = h("function"), oe = h("number"), ae = (t, a) => {
    if (W(t)) {
      for (let c = 0, f = t.length; c < f; ++c)
        if (!a(t[c]))
          return !1;
      return !0;
    }
    return !1;
  }, G = () => {
  }, ve = (t) => () => t(), nt = (t, a) => (...c) => t(a.apply(null, c)), Xe = (t, a) => (c) => t(a(c)), te = (t) => () => t, lt = (t) => t, ot = (t, a) => t === a;
  function Kt(t, ...a) {
    return (...c) => {
      const f = a.concat(c);
      return t.apply(null, f);
    };
  }
  const je = (t) => (a) => !t(a), ye = (t) => () => {
    throw new Error(t);
  }, dn = (t) => t(), wt = te(!1), qe = te(!0);
  class B {
    constructor(a, c) {
      this.tag = a, this.value = c;
    }
    static some(a) {
      return new B(!0, a);
    }
    static none() {
      return B.singletonNone;
    }
    fold(a, c) {
      return this.tag ? c(this.value) : a();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(a) {
      return this.tag ? B.some(a(this.value)) : B.none();
    }
    bind(a) {
      return this.tag ? a(this.value) : B.none();
    }
    exists(a) {
      return this.tag && a(this.value);
    }
    forall(a) {
      return !this.tag || a(this.value);
    }
    filter(a) {
      return !this.tag || a(this.value) ? this : B.none();
    }
    getOr(a) {
      return this.tag ? this.value : a;
    }
    or(a) {
      return this.tag ? this : a;
    }
    getOrThunk(a) {
      return this.tag ? this.value : a();
    }
    orThunk(a) {
      return this.tag ? this : a();
    }
    getOrDie(a) {
      if (this.tag)
        return this.value;
      throw new Error(a ?? "Called getOrDie on None");
    }
    static from(a) {
      return Ce(a) ? B.some(a) : B.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(a) {
      this.tag && a(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  B.singletonNone = new B(!1);
  const mn = Array.prototype.slice, dt = Array.prototype.indexOf, En = Array.prototype.push, tn = (t, a) => dt.call(t, a), Le = (t, a) => {
    const c = tn(t, a);
    return c === -1 ? B.none() : B.some(c);
  }, jt = (t, a) => tn(t, a) > -1, Fn = (t, a) => {
    for (let c = 0, f = t.length; c < f; c++) {
      const g = t[c];
      if (a(g, c))
        return !0;
    }
    return !1;
  }, St = (t, a) => {
    const c = [];
    for (let f = 0; f < t; f++)
      c.push(a(f));
    return c;
  }, on = (t, a) => {
    const c = [];
    for (let f = 0; f < t.length; f += a) {
      const g = mn.call(t, f, f + a);
      c.push(g);
    }
    return c;
  }, tt = (t, a) => {
    const c = t.length, f = new Array(c);
    for (let g = 0; g < c; g++) {
      const x = t[g];
      f[g] = a(x, g);
    }
    return f;
  }, mt = (t, a) => {
    for (let c = 0, f = t.length; c < f; c++) {
      const g = t[c];
      a(g, c);
    }
  }, Y = (t, a) => {
    for (let c = t.length - 1; c >= 0; c--) {
      const f = t[c];
      a(f, c);
    }
  }, Wo = (t, a) => {
    const c = [], f = [];
    for (let g = 0, x = t.length; g < x; g++) {
      const w = t[g];
      (a(w, g) ? c : f).push(w);
    }
    return {
      pass: c,
      fail: f
    };
  }, To = (t, a) => {
    const c = [];
    for (let f = 0, g = t.length; f < g; f++) {
      const x = t[f];
      a(x, f) && c.push(x);
    }
    return c;
  }, Ot = (t, a, c) => (Y(t, (f, g) => {
    c = a(c, f, g);
  }), c), Mt = (t, a, c) => (mt(t, (f, g) => {
    c = a(c, f, g);
  }), c), zn = (t, a, c) => {
    for (let f = 0, g = t.length; f < g; f++) {
      const x = t[f];
      if (a(x, f))
        return B.some(x);
      if (c(x, f))
        break;
    }
    return B.none();
  }, At = (t, a) => zn(t, a, wt), $n = (t, a) => {
    for (let c = 0, f = t.length; c < f; c++) {
      const g = t[c];
      if (a(g, c))
        return B.some(c);
    }
    return B.none();
  }, en = (t) => {
    const a = [];
    for (let c = 0, f = t.length; c < f; ++c) {
      if (!W(t[c]))
        throw new Error("Arr.flatten item " + c + " was not an array, input: " + t);
      En.apply(a, t[c]);
    }
    return a;
  }, Ue = (t, a) => en(tt(t, a)), jn = (t, a) => {
    for (let c = 0, f = t.length; c < f; ++c) {
      const g = t[c];
      if (a(g, c) !== !0)
        return !1;
    }
    return !0;
  }, mo = (t) => {
    const a = mn.call(t, 0);
    return a.reverse(), a;
  }, xn = (t, a) => To(t, (c) => !jt(a, c)), Vt = (t, a) => {
    const c = {};
    for (let f = 0, g = t.length; f < g; f++) {
      const x = t[f];
      c[String(x)] = a(x, f);
    }
    return c;
  }, Ct = (t) => [t], Jn = (t, a) => {
    const c = mn.call(t, 0);
    return c.sort(a), c;
  }, Pn = (t, a) => a >= 0 && a < t.length ? B.some(t[a]) : B.none(), so = (t) => Pn(t, 0), pr = (t) => Pn(t, t.length - 1), nr = Q(Array.from) ? Array.from : (t) => mn.call(t), Ko = (t, a) => {
    for (let c = 0; c < t.length; c++) {
      const f = a(t[c], c);
      if (f.isSome())
        return f;
    }
    return B.none();
  }, Qo = Object.keys, Mr = Object.hasOwnProperty, at = (t, a) => {
    const c = Qo(t);
    for (let f = 0, g = c.length; f < g; f++) {
      const x = c[f], w = t[x];
      a(w, x);
    }
  }, kt = (t, a) => yn(t, (c, f) => ({
    k: f,
    v: a(c, f)
  })), yn = (t, a) => {
    const c = {};
    return at(t, (f, g) => {
      const x = a(f, g);
      c[x.k] = x.v;
    }), c;
  }, pn = (t) => (a, c) => {
    t[c] = a;
  }, Oo = (t, a, c, f) => {
    at(t, (g, x) => {
      (a(g, x) ? c : f)(g, x);
    });
  }, hr = (t, a) => {
    const c = {}, f = {};
    return Oo(t, a, pn(c), pn(f)), {
      t: c,
      f
    };
  }, or = (t, a) => {
    const c = {};
    return Oo(t, a, pn(c), G), c;
  }, Ir = (t, a) => {
    const c = [];
    return at(t, (f, g) => {
      c.push(a(f, g));
    }), c;
  }, Zo = (t, a) => {
    const c = Qo(t);
    for (let f = 0, g = c.length; f < g; f++) {
      const x = c[f], w = t[x];
      if (a(w, x, t))
        return B.some(w);
    }
    return B.none();
  }, Tr = (t) => Ir(t, lt), Ht = (t, a) => Ho(t, a) ? B.from(t[a]) : B.none(), Ho = (t, a) => Mr.call(t, a), As = (t, a) => Ho(t, a) && t[a] !== void 0 && t[a] !== null, ra = (t, a, c = ot) => t.exists((f) => c(f, a)), qs = (t, a, c = ot) => xa(t, a, c).getOr(t.isNone() && a.isNone()), Ks = (t) => {
    const a = [], c = (f) => {
      a.push(f);
    };
    for (let f = 0; f < t.length; f++)
      t[f].each(c);
    return a;
  }, kr = (t) => {
    const a = [];
    for (let c = 0; c < t.length; c++) {
      const f = t[c];
      if (f.isSome())
        a.push(f.getOrDie());
      else
        return B.none();
    }
    return B.some(a);
  }, xa = (t, a, c) => t.isSome() && a.isSome() ? B.some(c(t.getOrDie(), a.getOrDie())) : B.none(), ca = (t, a, c, f) => t.isSome() && a.isSome() && c.isSome() ? B.some(f(t.getOrDie(), a.getOrDie(), c.getOrDie())) : B.none(), Or = (t, a) => t != null ? B.some(a(t)) : B.none(), Xn = (t, a) => t ? B.some(a) : B.none(), Ss = (t, a) => t + a, Ke = (t, a) => t.substring(a), bt = (t, a, c) => a === "" || t.length >= a.length && t.substr(c, c + a.length) === a, gn = (t, a) => cr(t, a) ? Ke(t, a.length) : t, Tn = (t, a) => ea(t, a) ? t : Ss(t, a), Po = (t, a, c = 0, f) => {
    const g = t.indexOf(a, c);
    return g !== -1 ? be(f) ? !0 : g + a.length <= f : !1;
  }, cr = (t, a) => bt(t, a, 0), ea = (t, a) => bt(t, a, t.length - a.length), Ps = ((t) => (a) => a.replace(t, ""))(/^\s+|\s+$/g), Re = (t) => t.length > 0, Oe = (t) => !Re(t), ct = (t) => t.style !== void 0 && Q(t.style.getPropertyValue), _t = (t, a) => {
    const f = (a || document).createElement("div");
    if (f.innerHTML = t, !f.hasChildNodes() || f.childNodes.length > 1) {
      const g = "HTML does not have a single root node";
      throw console.error(g, t), new Error(g);
    }
    return Bo(f.childNodes[0]);
  }, Kn = (t, a) => {
    const f = (a || document).createElement(t);
    return Bo(f);
  }, io = (t, a) => {
    const f = (a || document).createTextNode(t);
    return Bo(f);
  }, Bo = (t) => {
    if (t == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: t };
  }, He = {
    fromHtml: _t,
    fromTag: Kn,
    fromText: io,
    fromDom: Bo,
    fromPoint: (t, a, c) => B.from(t.dom.elementFromPoint(a, c)).map(Bo)
  }, Do = typeof window < "u" ? window : Function("return this;")(), Ne = (t, a) => {
    let c = a ?? Do;
    for (let f = 0; f < t.length && c !== void 0 && c !== null; ++f)
      c = c[t[f]];
    return c;
  }, Ie = (t, a) => {
    const c = t.split(".");
    return Ne(c, a);
  }, Bt = (t, a) => Ie(t, a), Wt = (t, a) => {
    const c = Bt(t, a);
    if (c == null)
      throw new Error(t + " not available on this browser");
    return c;
  }, kn = Object.getPrototypeOf, eo = (t) => Wt("HTMLElement", t), Gn = (t) => {
    const a = Ie("ownerDocument.defaultView", t);
    return D(t) && (eo(a).prototype.isPrototypeOf(t) || /^HTML\w*Element$/.test(kn(t).constructor.name));
  }, qn = 9, Qn = 11, lo = 1, rr = 3, Kr = (t) => t.dom.nodeName.toLowerCase(), Wa = (t) => t.dom.nodeType, Ei = (t) => (a) => Wa(a) === t, Ti = (t) => ko(t) && Gn(t.dom), ko = Ei(lo), Yo = Ei(rr), Fr = Ei(qn), Ba = Ei(Qn), ua = (t) => (a) => ko(a) && Kr(a) === t, vs = (t, a) => {
    const c = t.dom;
    if (c.nodeType !== lo)
      return !1;
    {
      const f = c;
      if (f.matches !== void 0)
        return f.matches(a);
      if (f.msMatchesSelector !== void 0)
        return f.msMatchesSelector(a);
      if (f.webkitMatchesSelector !== void 0)
        return f.webkitMatchesSelector(a);
      if (f.mozMatchesSelector !== void 0)
        return f.mozMatchesSelector(a);
      throw new Error("Browser lacks native selectors");
    }
  }, es = (t) => t.nodeType !== lo && t.nodeType !== qn && t.nodeType !== Qn || t.childElementCount === 0, ai = (t, a) => {
    const c = a === void 0 ? document : a.dom;
    return es(c) ? [] : tt(c.querySelectorAll(t), He.fromDom);
  }, vc = (t, a) => {
    const c = a === void 0 ? document : a.dom;
    return es(c) ? B.none() : B.from(c.querySelector(t)).map(He.fromDom);
  }, Lr = (t, a) => t.dom === a.dom, ka = (t, a) => {
    const c = t.dom, f = a.dom;
    return c === f ? !1 : c.contains(f);
  }, ii = (t) => He.fromDom(t.dom.ownerDocument), na = (t) => Fr(t) ? t : ii(t), Oi = (t) => He.fromDom(na(t).dom.documentElement), cl = (t) => He.fromDom(na(t).dom.defaultView), Za = (t) => B.from(t.dom.parentNode).map(He.fromDom), Ai = (t) => Za(t), Ui = (t) => B.from(t.dom.parentElement).map(He.fromDom), au = (t, a) => {
    const c = Q(a) ? a : wt;
    let f = t.dom;
    const g = [];
    for (; f.parentNode !== null && f.parentNode !== void 0; ) {
      const x = f.parentNode, w = He.fromDom(x);
      if (g.push(w), c(w) === !0)
        break;
      f = x;
    }
    return g;
  }, gi = (t) => B.from(t.dom.offsetParent).map(He.fromDom), Ml = (t) => B.from(t.dom.nextSibling).map(He.fromDom), $a = (t) => tt(t.dom.childNodes, He.fromDom), Wi = (t, a) => {
    const c = t.dom.childNodes;
    return B.from(c[a]).map(He.fromDom);
  }, Kl = (t) => Wi(t, 0), yc = (t, a) => ({
    element: t,
    offset: a
  }), ld = (t, a) => {
    const c = $a(t);
    return c.length > 0 && a < c.length ? yc(c[a], 0) : yc(t, a);
  }, iu = (t) => Ba(t) && Ce(t.dom.host), bi = Q(Element.prototype.attachShadow) && Q(Node.prototype.getRootNode), Ru = te(bi), le = bi ? (t) => He.fromDom(t.dom.getRootNode()) : na, Ae = (t) => iu(t) ? t : He.fromDom(na(t).dom.body), Ze = (t) => Dt(t).isSome(), Dt = (t) => {
    const a = le(t);
    return iu(a) ? B.some(a) : B.none();
  }, Yt = (t) => He.fromDom(t.dom.host), Wn = (t) => {
    if (Ru() && Ce(t.target)) {
      const a = He.fromDom(t.target);
      if (ko(a) && lr(a) && t.composed && t.composedPath) {
        const c = t.composedPath();
        if (c)
          return so(c);
      }
    }
    return B.from(t.target);
  }, lr = (t) => Ce(t.dom.shadowRoot), yr = (t) => {
    const a = Yo(t) ? t.dom.parentNode : t.dom;
    if (a == null || a.ownerDocument === null)
      return !1;
    const c = a.ownerDocument;
    return Dt(He.fromDom(a)).fold(() => c.body.contains(a), Xe(yr, Yt));
  }, Uo = () => Yr(He.fromDom(document)), Yr = (t) => {
    const a = t.dom.body;
    if (a == null)
      throw new Error("Body is not available yet");
    return He.fromDom(a);
  }, Ds = (t, a, c) => {
    if (_(c) || J(c) || oe(c))
      t.setAttribute(a, c + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", a, ":: Value ", c, ":: Element ", t), new Error("Attribute value was not simple");
  }, rn = (t, a, c) => {
    Ds(t.dom, a, c);
  }, cd = (t, a) => {
    const c = t.dom;
    at(a, (f, g) => {
      Ds(c, g, f);
    });
  }, os = (t, a) => {
    const c = t.dom.getAttribute(a);
    return c === null ? void 0 : c;
  }, K = (t, a) => B.from(os(t, a)), ge = (t, a) => {
    const c = t.dom;
    return c && c.hasAttribute ? c.hasAttribute(a) : !1;
  }, Ee = (t, a) => {
    t.dom.removeAttribute(a);
  }, ft = (t) => Mt(t.dom.attributes, (a, c) => (a[c.name] = c.value, a), {}), Cn = (t, a, c) => {
    if (!_(c))
      throw console.error("Invalid call to CSS.set. Property ", a, ":: Value ", c, ":: Element ", t), new Error("CSS value must be a string: " + c);
    ct(t) && t.style.setProperty(a, c);
  }, Jo = (t, a) => {
    ct(t) && t.style.removeProperty(a);
  }, Ln = (t, a, c) => {
    const f = t.dom;
    Cn(f, a, c);
  }, Rs = (t, a) => {
    const c = t.dom;
    at(a, (f, g) => {
      Cn(c, g, f);
    });
  }, Gt = (t, a) => {
    const c = t.dom;
    at(a, (f, g) => {
      f.fold(() => {
        Jo(c, g);
      }, (x) => {
        Cn(c, g, x);
      });
    });
  }, fs = (t, a) => {
    const c = t.dom, g = window.getComputedStyle(c).getPropertyValue(a);
    return g === "" && !yr(t) ? vi(c, a) : g;
  }, vi = (t, a) => ct(t) ? t.style.getPropertyValue(a) : "", ks = (t, a) => {
    const c = t.dom, f = vi(c, a);
    return B.from(f).filter((g) => g.length > 0);
  }, ga = (t) => {
    const a = {}, c = t.dom;
    if (ct(c))
      for (let f = 0; f < c.style.length; f++) {
        const g = c.style.item(f);
        a[g] = c.style[g];
      }
    return a;
  }, Il = (t, a, c) => {
    const f = He.fromTag(t);
    return Ln(f, a, c), ks(f, a).isSome();
  }, xr = (t, a) => {
    const c = t.dom;
    Jo(c, a), ra(K(t, "style").map(Ps), "") && Ee(t, "style");
  }, yi = (t) => t.dom.offsetWidth, Ns = (t, a) => {
    const c = (T, A) => {
      if (!oe(A) && !A.match(/^[0-9]+$/))
        throw new Error(t + ".set accepts only positive integer values. Value was " + A);
      const F = T.dom;
      ct(F) && (F.style[t] = A + "px");
    }, f = (T) => {
      const A = a(T);
      if (A <= 0 || A === null) {
        const F = fs(T, t);
        return parseFloat(F) || 0;
      }
      return A;
    }, g = f, x = (T, A) => Mt(A, (F, H) => {
      const q = fs(T, H), ne = q === void 0 ? 0 : parseInt(q, 10);
      return isNaN(ne) ? F : F + ne;
    }, 0);
    return {
      set: c,
      get: f,
      getOuter: g,
      aggregate: x,
      max: (T, A, F) => {
        const H = x(T, F);
        return A > H ? A - H : 0;
      }
    };
  }, xc = Ns("height", (t) => {
    const a = t.dom;
    return yr(t) ? a.getBoundingClientRect().height : a.offsetHeight;
  }), Bs = (t) => xc.get(t), ud = (t) => xc.getOuter(t), vm = (t, a) => {
    const c = [
      "margin-top",
      "border-top-width",
      "padding-top",
      "padding-bottom",
      "border-bottom-width",
      "margin-bottom"
    ], f = xc.max(t, a, c);
    Ln(t, "max-height", f + "px");
  }, Oh = (t, a) => ({
    left: t,
    top: a,
    translate: (f, g) => Oh(t + f, a + g)
  }), zs = Oh, Yl = (t) => {
    const a = t.getBoundingClientRect();
    return zs(a.left, a.top);
  }, La = (t, a) => t !== void 0 ? t : a !== void 0 ? a : 0, Ga = (t) => {
    const a = t.dom.ownerDocument, c = a.body, f = a.defaultView, g = a.documentElement;
    if (c === t.dom)
      return zs(c.offsetLeft, c.offsetTop);
    const x = La(f == null ? void 0 : f.pageYOffset, g.scrollTop), w = La(f == null ? void 0 : f.pageXOffset, g.scrollLeft), T = La(g.clientTop, c.clientTop), A = La(g.clientLeft, c.clientLeft);
    return xi(t).translate(w - A, x - T);
  }, xi = (t) => {
    const a = t.dom, f = a.ownerDocument.body;
    return f === a ? zs(f.offsetLeft, f.offsetTop) : yr(t) ? Yl(a) : zs(0, 0);
  }, Of = Ns("width", (t) => t.dom.offsetWidth), gr = (t, a) => Of.set(t, a), Pi = (t) => Of.get(t), li = (t) => Of.getOuter(t), pe = (t, a) => {
    const c = [
      "margin-left",
      "border-left-width",
      "padding-left",
      "padding-right",
      "border-right-width",
      "margin-right"
    ], f = Of.max(t, a, c);
    Ln(t, "max-width", f + "px");
  }, Te = (t) => {
    let a = !1, c;
    return (...f) => (a || (a = !0, c = t.apply(null, f)), c);
  }, rt = (t, a, c, f) => {
    const g = t.isiOS() && /ipad/i.test(c) === !0, x = t.isiOS() && !g, w = t.isiOS() || t.isAndroid(), T = w || f("(pointer:coarse)"), A = g || !x && w && f("(min-device-width:768px)"), F = x || w && !A, H = a.isSafari() && t.isiOS() && /safari/i.test(c) === !1, q = !F && !A && !H;
    return {
      isiPad: te(g),
      isiPhone: te(x),
      isTablet: te(A),
      isPhone: te(F),
      isTouch: te(T),
      isAndroid: t.isAndroid,
      isiOS: t.isiOS,
      isWebView: te(H),
      isDesktop: te(q)
    };
  }, pt = (t, a) => {
    for (let c = 0; c < t.length; c++) {
      const f = t[c];
      if (f.test(a))
        return f;
    }
  }, to = (t, a) => {
    const c = pt(t, a);
    if (!c)
      return {
        major: 0,
        minor: 0
      };
    const f = (g) => Number(a.replace(c, "$" + g));
    return Ha(f(1), f(2));
  }, sr = (t, a) => {
    const c = String(a).toLowerCase();
    return t.length === 0 ? _s() : to(t, c);
  }, _s = () => Ha(0, 0), Ha = (t, a) => ({
    major: t,
    minor: a
  }), ur = {
    nu: Ha,
    detect: sr,
    unknown: _s
  }, _a = (t, a) => Ko(a.brands, (c) => {
    const f = c.brand.toLowerCase();
    return At(t, (g) => {
      var x;
      return f === ((x = g.brand) === null || x === void 0 ? void 0 : x.toLowerCase());
    }).map((g) => ({
      current: g.name,
      version: ur.nu(parseInt(c.version, 10), 0)
    }));
  }), Ms = (t, a) => {
    const c = String(a).toLowerCase();
    return At(t, (f) => f.search(c));
  }, da = (t, a) => Ms(t, a).map((c) => {
    const f = ur.detect(c.versionRegexes, a);
    return {
      current: c.name,
      version: f
    };
  }), sa = (t, a) => Ms(t, a).map((c) => {
    const f = ur.detect(c.versionRegexes, a);
    return {
      current: c.name,
      version: f
    };
  }), oa = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, ul = (t) => (a) => Po(a, t), wc = [
    {
      name: "Edge",
      versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
      search: (t) => Po(t, "edge/") && Po(t, "chrome") && Po(t, "safari") && Po(t, "applewebkit")
    },
    {
      name: "Chromium",
      brand: "Chromium",
      versionRegexes: [
        /.*?chrome\/([0-9]+)\.([0-9]+).*/,
        oa
      ],
      search: (t) => Po(t, "chrome") && !Po(t, "chromeframe")
    },
    {
      name: "IE",
      versionRegexes: [
        /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
        /.*?rv:([0-9]+)\.([0-9]+).*/
      ],
      search: (t) => Po(t, "msie") || Po(t, "trident")
    },
    {
      name: "Opera",
      versionRegexes: [
        oa,
        /.*?opera\/([0-9]+)\.([0-9]+).*/
      ],
      search: ul("opera")
    },
    {
      name: "Firefox",
      versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
      search: ul("firefox")
    },
    {
      name: "Safari",
      versionRegexes: [
        oa,
        /.*?cpu os ([0-9]+)_([0-9]+).*/
      ],
      search: (t) => (Po(t, "safari") || Po(t, "mobile/")) && Po(t, "applewebkit")
    }
  ], qa = [
    {
      name: "Windows",
      search: ul("win"),
      versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "iOS",
      search: (t) => Po(t, "iphone") || Po(t, "ipad"),
      versionRegexes: [
        /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
        /.*cpu os ([0-9]+)_([0-9]+).*/,
        /.*cpu iphone os ([0-9]+)_([0-9]+).*/
      ]
    },
    {
      name: "Android",
      search: ul("android"),
      versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "macOS",
      search: ul("mac os x"),
      versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    },
    {
      name: "Linux",
      search: ul("linux"),
      versionRegexes: []
    },
    {
      name: "Solaris",
      search: ul("sunos"),
      versionRegexes: []
    },
    {
      name: "FreeBSD",
      search: ul("freebsd"),
      versionRegexes: []
    },
    {
      name: "ChromeOS",
      search: ul("cros"),
      versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }
  ], dl = {
    browsers: te(wc),
    oses: te(qa)
  }, Mc = "Edge", Ic = "Chromium", ip = "IE", dd = "Opera", Cc = "Firefox", Zi = "Safari", fd = () => Af({
    current: void 0,
    version: ur.unknown()
  }), Af = (t) => {
    const a = t.current, c = t.version, f = (g) => () => a === g;
    return {
      current: a,
      version: c,
      isEdge: f(Mc),
      isChromium: f(Ic),
      isIE: f(ip),
      isOpera: f(dd),
      isFirefox: f(Cc),
      isSafari: f(Zi)
    };
  }, lu = {
    unknown: fd,
    nu: Af,
    edge: te(Mc),
    chromium: te(Ic),
    ie: te(ip),
    opera: te(dd),
    firefox: te(Cc),
    safari: te(Zi)
  }, Ah = "Windows", Pf = "iOS", Ph = "Android", Wd = "Linux", Dh = "macOS", Zd = "Solaris", Sv = "FreeBSD", Me = "ChromeOS", ym = () => wl({
    current: void 0,
    version: ur.unknown()
  }), wl = (t) => {
    const a = t.current, c = t.version, f = (g) => () => a === g;
    return {
      current: a,
      version: c,
      isWindows: f(Ah),
      isiOS: f(Pf),
      isAndroid: f(Ph),
      isMacOS: f(Dh),
      isLinux: f(Wd),
      isSolaris: f(Zd),
      isFreeBSD: f(Sv),
      isChromeOS: f(Me)
    };
  }, Nu = {
    unknown: ym,
    nu: wl,
    windows: te(Ah),
    ios: te(Pf),
    android: te(Ph),
    linux: te(Wd),
    macos: te(Dh),
    solaris: te(Zd),
    freebsd: te(Sv),
    chromeos: te(Me)
  }, Wg = { detect: (t, a, c) => {
    const f = dl.browsers(), g = dl.oses(), x = a.bind((A) => _a(f, A)).orThunk(() => da(f, t)).fold(lu.unknown, lu.nu), w = sa(g, t).fold(Nu.unknown, Nu.nu), T = rt(w, x, t, c);
    return {
      browser: x,
      os: w,
      deviceType: T
    };
  } }, zr = (t) => window.matchMedia(t).matches;
  let Gi = Te(() => Wg.detect(navigator.userAgent, B.from(navigator.userAgentData), zr));
  const Fl = () => Gi(), Ka = (t, a, c, f, g, x, w) => ({
    target: t,
    x: a,
    y: c,
    stop: f,
    prevent: g,
    kill: x,
    raw: w
  }), Gd = (t) => {
    const a = He.fromDom(Wn(t).getOr(t.target)), c = () => t.stopPropagation(), f = () => t.preventDefault(), g = nt(f, c);
    return Ka(a, t.clientX, t.clientY, c, f, g, t);
  }, Fc = (t, a) => (c) => {
    t(c) && a(Gd(c));
  }, Di = (t, a, c, f, g) => {
    const x = Fc(c, f);
    return t.dom.addEventListener(a, x, g), { unbind: Kt(Zg, t, a, x, g) };
  }, Bc = (t, a, c, f) => Di(t, a, c, f, !1), Nh = (t, a, c, f) => Di(t, a, c, f, !0), Zg = (t, a, c, f) => {
    t.dom.removeEventListener(a, c, f);
  }, Xl = (t, a) => {
    Za(t).each((f) => {
      f.dom.insertBefore(a.dom, t.dom);
    });
  }, $c = (t, a) => {
    Ml(t).fold(() => {
      Za(t).each((g) => {
        qi(g, a);
      });
    }, (f) => {
      Xl(f, a);
    });
  }, lp = (t, a) => {
    Kl(t).fold(() => {
      qi(t, a);
    }, (f) => {
      t.dom.insertBefore(a.dom, f.dom);
    });
  }, qi = (t, a) => {
    t.dom.appendChild(a.dom);
  }, Ya = (t, a, c) => {
    Wi(t, c).fold(() => {
      qi(t, a);
    }, (f) => {
      Xl(f, a);
    });
  }, md = (t, a) => {
    mt(a, (c) => {
      qi(t, c);
    });
  }, Df = (t) => {
    t.dom.textContent = "", mt($a(t), (a) => {
      Sc(a);
    });
  }, Sc = (t) => {
    const a = t.dom;
    a.parentNode !== null && a.parentNode.removeChild(a);
  }, wi = (t) => {
    const a = t !== void 0 ? t.dom : document, c = a.body.scrollLeft || a.documentElement.scrollLeft, f = a.body.scrollTop || a.documentElement.scrollTop;
    return zs(c, f);
  }, cp = (t, a, c) => {
    const g = (c !== void 0 ? c.dom : document).defaultView;
    g && g.scrollTo(t, a);
  }, up = (t) => {
    const a = t === void 0 ? window : t;
    return Fl().browser.isFirefox() ? B.none() : B.from(a.visualViewport);
  }, dp = (t, a, c, f) => ({
    x: t,
    y: a,
    width: c,
    height: f,
    right: t + c,
    bottom: a + f
  }), xm = (t) => {
    const a = t === void 0 ? window : t, c = a.document, f = wi(He.fromDom(c));
    return up(a).fold(() => {
      const g = a.document.documentElement, x = g.clientWidth, w = g.clientHeight;
      return dp(f.left, f.top, x, w);
    }, (g) => dp(Math.max(g.pageLeft, f.left), Math.max(g.pageTop, f.top), g.width, g.height));
  }, Ql = () => He.fromDom(document), fp = (t, a) => t.view(a).fold(te([]), (f) => {
    const g = t.owner(f), x = fp(t, g);
    return [f].concat(x);
  }), Gg = (t, a) => {
    const c = a.owner(t), f = fp(a, c);
    return B.some(f);
  };
  var mp = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    view: (t) => {
      var a;
      return (t.dom === document ? B.none() : B.from((a = t.dom.defaultView) === null || a === void 0 ? void 0 : a.frameElement)).map(He.fromDom);
    },
    owner: (t) => ii(t)
  });
  const wm = (t) => {
    const a = Ql(), c = wi(a);
    return Gg(t, mp).fold(Kt(Ga, t), (g) => {
      const x = xi(t), w = Ot(g, (T, A) => {
        const F = xi(A);
        return {
          left: T.left + F.left,
          top: T.top + F.top
        };
      }, {
        left: 0,
        top: 0
      });
      return zs(w.left + x.left + c.left, w.top + x.top + c.top);
    });
  }, Mu = (t, a, c) => ({
    point: t,
    width: a,
    height: c
  }), Mh = (t, a, c, f) => ({
    x: t,
    y: a,
    width: c,
    height: f
  }), Is = (t, a, c, f) => ({
    x: t,
    y: a,
    width: c,
    height: f,
    right: t + c,
    bottom: a + f
  }), aa = (t) => {
    const a = Ga(t), c = li(t), f = ud(t);
    return Is(a.left, a.top, c, f);
  }, Cl = (t) => {
    const a = wm(t), c = li(t), f = ud(t);
    return Is(a.left, a.top, c, f);
  }, Ih = (t, a) => {
    const c = Math.max(t.x, a.x), f = Math.max(t.y, a.y), g = Math.min(t.right, a.right), x = Math.min(t.bottom, a.bottom), w = g - c, T = x - f;
    return Is(c, f, w, T);
  }, Fh = (t, a) => Mt(a, (c, f) => Ih(c, f), t), Ra = () => xm(window), no = (t) => {
    let a = t;
    return {
      get: () => a,
      set: (g) => {
        a = g;
      }
    };
  }, cu = (t) => {
    const a = no(B.none()), c = () => a.get().each(t);
    return {
      clear: () => {
        c(), a.set(B.none());
      },
      isSet: () => a.get().isSome(),
      get: () => a.get(),
      set: (T) => {
        c(), a.set(B.some(T));
      }
    };
  }, Kg = () => cu((t) => t.destroy()), za = () => cu((t) => t.unbind()), ms = () => {
    const t = cu(G);
    return {
      ...t,
      on: (c) => t.get().each(c)
    };
  };
  var qd = tinymce.util.Tools.resolve("tinymce.ThemeManager");
  const Bh = (t) => {
    const a = (x) => x(t), c = te(t), f = () => g, g = {
      tag: !0,
      inner: t,
      fold: (x, w) => w(t),
      isValue: qe,
      isError: wt,
      map: (x) => zo.value(x(t)),
      mapError: f,
      bind: a,
      exists: a,
      forall: a,
      getOr: c,
      or: f,
      getOrThunk: c,
      orThunk: f,
      getOrDie: c,
      each: (x) => {
        x(t);
      },
      toOptional: () => B.some(t)
    };
    return g;
  }, pp = (t) => {
    const a = () => c, c = {
      tag: !1,
      inner: t,
      fold: (f, g) => f(t),
      isValue: wt,
      isError: qe,
      map: a,
      mapError: (f) => zo.error(f(t)),
      bind: a,
      exists: wt,
      forall: qe,
      getOr: lt,
      or: lt,
      getOrThunk: dn,
      orThunk: dn,
      getOrDie: ye(String(t)),
      each: G,
      toOptional: B.none
    };
    return c;
  }, zo = {
    value: Bh,
    error: pp,
    fromOption: (t, a) => t.fold(() => pp(a), Bh)
  };
  var fa;
  (function(t) {
    t[t.Error = 0] = "Error", t[t.Value = 1] = "Value";
  })(fa || (fa = {}));
  const Rf = (t, a, c) => t.stype === fa.Error ? a(t.serror) : c(t.svalue), Sl = (t) => {
    const a = [], c = [];
    return mt(t, (f) => {
      Rf(f, (g) => c.push(g), (g) => a.push(g));
    }), {
      values: a,
      errors: c
    };
  }, fl = (t, a) => t.stype === fa.Error ? {
    stype: fa.Error,
    serror: a(t.serror)
  } : t, kl = (t, a) => t.stype === fa.Value ? {
    stype: fa.Value,
    svalue: a(t.svalue)
  } : t, Na = (t, a) => t.stype === fa.Value ? a(t.svalue) : t, Ki = (t, a) => t.stype === fa.Error ? a(t.serror) : t, Jl = (t) => ({
    stype: fa.Value,
    svalue: t
  }), Cm = (t) => ({
    stype: fa.Error,
    serror: t
  }), wa = {
    fromResult: (t) => t.fold(Cm, Jl),
    toResult: (t) => Rf(t, zo.error, zo.value),
    svalue: Jl,
    partition: Sl,
    serror: Cm,
    bind: Na,
    bindError: Ki,
    map: kl,
    mapError: fl,
    fold: Rf
  }, pd = (t, a, c, f) => ({
    tag: "field",
    key: t,
    newKey: a,
    presence: c,
    prop: f
  }), Lc = (t, a) => ({
    tag: "custom",
    newKey: t,
    instantiator: a
  }), ys = (t, a, c) => {
    switch (t.tag) {
      case "field":
        return a(t.key, t.newKey, t.presence, t.prop);
      case "custom":
        return c(t.newKey, t.instantiator);
    }
  }, Hc = (t, a) => a, Nf = (t, a) => L(t) && L(a) ? Fs(t, a) : a, Iu = (t) => (...a) => {
    if (a.length === 0)
      throw new Error("Can't merge zero objects");
    const c = {};
    for (let f = 0; f < a.length; f++) {
      const g = a[f];
      for (const x in g)
        Ho(g, x) && (c[x] = t(c[x], g[x]));
    }
    return c;
  }, Fs = Iu(Nf), hd = Iu(Hc), ec = () => ({
    tag: "required",
    process: {}
  }), dr = (t) => ({
    tag: "defaultedThunk",
    process: t
  }), Kd = (t) => dr(te(t)), Sm = () => ({
    tag: "option",
    process: {}
  }), gp = (t) => ({
    tag: "mergeWithThunk",
    process: t
  }), Yg = (t) => gp(te(t)), bp = (t, a) => t.length > 0 ? wa.svalue(Fs(a, hd.apply(void 0, t))) : wa.svalue(a), Xg = (t) => nt(wa.serror, en)(t), re = {
    consolidateObj: (t, a) => {
      const c = wa.partition(t);
      return c.errors.length > 0 ? Xg(c.errors) : bp(c.values, a);
    },
    consolidateArr: (t) => {
      const a = wa.partition(t);
      return a.errors.length > 0 ? Xg(a.errors) : wa.svalue(a.values);
    }
  }, Pe = (t) => D(t) && Qo(t).length > 100 ? " removed due to size" : JSON.stringify(t, null, 2), $e = (t) => {
    const a = t.length > 10 ? t.slice(0, 10).concat([{
      path: [],
      getErrorInfo: te("... (only showing first ten failures)")
    }]) : t;
    return tt(a, (c) => "Failed path: (" + c.path.join(" > ") + `)
` + c.getErrorInfo());
  }, $t = (t, a) => wa.serror([{
    path: t,
    getErrorInfo: a
  }]), vo = (t, a, c) => $t(t, () => 'Could not find valid *required* value for "' + a + '" in ' + Pe(c)), $o = (t, a) => $t(t, () => 'Choice schema did not contain choice key: "' + a + '"'), Mo = (t, a, c) => $t(t, () => 'The chosen schema: "' + c + '" did not exist in branches: ' + Pe(a)), bo = (t, a) => $t(t, () => "There are unsupported fields: [" + a.join(", ") + "] specified"), Vs = (t, a) => $t(t, te(a)), ma = (t) => {
    const a = (f, g) => wa.bindError(t(g), (x) => Vs(f, x)), c = te("val");
    return {
      extract: a,
      toString: c
    };
  }, _l = ma(wa.svalue), ba = (t, a, c, f) => Ht(a, c).fold(() => vo(t, c, a), f), Qg = (t, a, c, f) => {
    const g = Ht(t, a).getOrThunk(() => c(t));
    return f(g);
  }, P0 = (t, a, c) => c(Ht(t, a)), _v = (t, a, c, f) => {
    const g = Ht(t, a).map((x) => x === !0 ? c(t) : x);
    return f(g);
  }, Ri = (t, a, c, f, g) => {
    const x = (T) => g.extract(a.concat([f]), T), w = (T) => T.fold(() => wa.svalue(B.none()), (A) => {
      const F = g.extract(a.concat([f]), A);
      return wa.map(F, B.some);
    });
    switch (t.tag) {
      case "required":
        return ba(a, c, f, x);
      case "defaultedThunk":
        return Qg(c, f, t.process, x);
      case "option":
        return P0(c, f, w);
      case "defaultedOptionThunk":
        return _v(c, f, t.process, w);
      case "mergeWithThunk":
        return Qg(c, f, te({}), (T) => {
          const A = Fs(t.process(c), T);
          return x(A);
        });
    }
  }, Jg = (t, a, c) => {
    const f = {}, g = [];
    for (const x of c)
      ys(x, (w, T, A, F) => {
        const H = Ri(A, t, a, w, F);
        wa.fold(H, (q) => {
          g.push(...q);
        }, (q) => {
          f[T] = q;
        });
      }, (w, T) => {
        f[w] = T(a);
      });
    return g.length > 0 ? wa.serror(g) : wa.svalue(f);
  }, Xa = (t) => ({
    extract: (f, g) => t().extract(f, g),
    toString: () => t().toString()
  }), Ev = (t) => Qo(or(t, Ce)), Ni = (t) => {
    const a = wo(t), c = Ot(t, (g, x) => ys(x, (w) => Fs(g, { [w]: !0 }), te(g)), {});
    return {
      extract: (g, x) => {
        const w = J(x) ? [] : Ev(x), T = To(w, (A) => !As(c, A));
        return T.length === 0 ? a.extract(g, x) : bo(g, T);
      },
      toString: a.toString
    };
  }, wo = (t) => ({
    extract: (f, g) => Jg(f, g, t),
    toString: () => `obj{
` + tt(t, (g) => ys(g, (x, w, T, A) => x + " -> " + A.toString(), (x, w) => "state(" + x + ")")).join(`
`) + "}"
  }), zc = (t) => ({
    extract: (f, g) => {
      const x = tt(g, (w, T) => t.extract(f.concat(["[" + T + "]"]), w));
      return re.consolidateArr(x);
    },
    toString: () => "array(" + t.toString() + ")"
  }), vp = (t, a) => {
    const c = a !== void 0 ? a : lt;
    return {
      extract: (x, w) => {
        const T = [];
        for (const A of t) {
          const F = A.extract(x, w);
          if (F.stype === fa.Value)
            return {
              stype: fa.Value,
              svalue: c(F.svalue)
            };
          T.push(F);
        }
        return re.consolidateArr(T);
      },
      toString: () => "oneOf(" + tt(t, (x) => x.toString()).join(", ") + ")"
    };
  }, yp = (t, a) => {
    const c = (x, w) => zc(ma(t)).extract(x, w);
    return {
      extract: (x, w) => {
        const T = Qo(w), A = c(x, T);
        return wa.bind(A, (F) => {
          const H = tt(F, (q) => pd(q, q, ec(), a));
          return wo(H).extract(x, w);
        });
      },
      toString: () => "setOf(" + a.toString() + ")"
    };
  }, D0 = (t, a) => {
    const c = Te(a);
    return {
      extract: (x, w) => c().extract(x, w),
      toString: () => c().toString()
    };
  }, Tv = nt(zc, wo), uu = te(_l), gd = (t, a) => ma((c) => {
    const f = typeof c;
    return t(c) ? wa.svalue(c) : wa.serror(`Expected type: ${a} but got: ${f}`);
  }), Mf = gd(oe, "number"), On = gd(_, "string"), kc = gd(J, "boolean"), Ov = gd(Q, "function"), km = (t) => {
    if (Object(t) !== t)
      return !0;
    switch ({}.toString.call(t).slice(8, -1)) {
      case "Boolean":
      case "Number":
      case "String":
      case "Date":
      case "RegExp":
      case "Blob":
      case "FileList":
      case "ImageData":
      case "ImageBitmap":
      case "ArrayBuffer":
        return !0;
      case "Array":
      case "Object":
        return Object.keys(t).every((a) => km(t[a]));
      default:
        return !1;
    }
  }, du = ma((t) => km(t) ? wa.svalue(t) : wa.serror("Expected value to be acceptable for sending via postMessage")), Lh = (t, a, c, f) => Ht(c, f).fold(() => Mo(t, c, f), (x) => x.extract(t.concat(["branch: " + f]), a)), If = (t, a) => ({
    extract: (g, x) => Ht(x, t).fold(() => $o(g, t), (T) => Lh(g, x, a, T)),
    toString: () => "chooseOn(" + t + "). Possible values: " + Qo(a)
  }), _m = () => zc(_l), Hh = (t) => ma((a) => t(a).fold(wa.serror, wa.svalue)), Fu = (t, a) => yp((c) => wa.fromResult(t(c)), a), R0 = (t, a, c) => {
    const f = a.extract([t], c);
    return wa.mapError(f, (g) => ({
      input: c,
      errors: g
    }));
  }, ia = (t, a, c) => wa.toResult(R0(t, a, c)), Zt = (t) => t.fold((a) => {
    throw new Error(Bu(a));
  }, lt), El = (t, a, c) => Zt(ia(t, a, c)), Bu = (t) => `Errors: 
` + $e(t.errors).join(`
`) + `

Input object: ` + Pe(t.input), ci = (t, a) => If(t, kt(a, wo)), xp = (t, a) => D0(t, a), Qa = pd, Wr = Lc, eb = (t) => Hh((a) => jt(t, a) ? zo.value(a) : zo.error(`Unsupported value: "${a}", choose one of "${t.join(", ")}".`)), Rt = (t) => Qa(t, t, ec(), uu()), Vr = (t, a) => Qa(t, t, ec(), a), tb = (t) => Vr(t, Mf), Va = (t) => Vr(t, On), Yi = (t, a) => Qa(t, t, ec(), eb(a)), Nw = (t) => Vr(t, kc), _c = (t) => Vr(t, Ov), Mw = (t, a) => Qa(t, t, Sm(), ma((c) => wa.serror("The field: " + t + " is forbidden. " + a))), Yd = (t, a) => Qa(t, t, ec(), wo(a)), N0 = (t, a) => Qa(t, t, ec(), Tv(a)), Ec = (t, a) => Qa(t, t, ec(), zc(a)), jr = (t) => Qa(t, t, Sm(), uu()), bd = (t, a) => Qa(t, t, Sm(), a), Em = (t) => bd(t, Mf), ja = (t) => bd(t, On), Av = (t, a) => bd(t, eb(a)), vd = (t) => bd(t, Ov), $u = (t, a) => bd(t, zc(a)), Es = (t, a) => bd(t, wo(a)), wp = (t, a) => bd(t, Ni(a)), Qe = (t, a) => Qa(t, t, Kd(a), uu()), Vc = (t, a, c) => Qa(t, t, Kd(a), c), Cp = (t, a) => Vc(t, a, Mf), Mi = (t, a) => Vc(t, a, On), fu = (t, a, c) => Vc(t, a, eb(c)), Ea = (t, a) => Vc(t, a, kc), Ca = (t, a) => Vc(t, a, Ov), P = (t, a) => Vc(t, a, du), I = (t, a, c) => Vc(t, a, zc(c)), ee = (t, a, c) => Vc(t, a, wo(c)), Be = { generate: (t) => {
    if (!W(t))
      throw new Error("cases must be an array");
    if (t.length === 0)
      throw new Error("there must be at least one case");
    const a = [], c = {};
    return mt(t, (f, g) => {
      const x = Qo(f);
      if (x.length !== 1)
        throw new Error("one and only one name per case");
      const w = x[0], T = f[w];
      if (c[w] !== void 0)
        throw new Error("duplicate key detected:" + w);
      if (w === "cata")
        throw new Error("cannot have a case named cata (sorry)");
      if (!W(T))
        throw new Error("case arguments must be an array");
      a.push(w), c[w] = (...A) => {
        const F = A.length;
        if (F !== T.length)
          throw new Error("Wrong number of arguments to case " + w + ". Expected " + T.length + " (" + T + "), got " + F);
        return {
          fold: (...q) => {
            if (q.length !== t.length)
              throw new Error("Wrong number of arguments to fold. Expected " + t.length + ", got " + q.length);
            return q[g].apply(null, A);
          },
          match: (q) => {
            const ne = Qo(q);
            if (a.length !== ne.length)
              throw new Error("Wrong number of arguments to match. Expected: " + a.join(",") + `
Actual: ` + ne.join(","));
            if (!jn(a, (fe) => jt(ne, fe)))
              throw new Error("Not all branches were specified when using match. Specified: " + ne.join(", ") + `
Required: ` + a.join(", "));
            return q[w].apply(null, A);
          },
          log: (q) => {
            console.log(q, {
              constructors: a,
              constructor: w,
              params: A
            });
          }
        };
      };
    }), c;
  } };
  Be.generate([
    {
      bothErrors: [
        "error1",
        "error2"
      ]
    },
    {
      firstError: [
        "error1",
        "value2"
      ]
    },
    {
      secondError: [
        "value1",
        "error2"
      ]
    },
    {
      bothValues: [
        "value1",
        "value2"
      ]
    }
  ]);
  const Pt = (t) => {
    const a = [], c = [];
    return mt(t, (f) => {
      f.fold((g) => {
        a.push(g);
      }, (g) => {
        c.push(g);
      });
    }), {
      errors: a,
      values: c
    };
  }, sn = (t, a) => {
    const c = {};
    return at(t, (f, g) => {
      jt(a, g) || (c[g] = f);
    }), c;
  }, Hn = (t, a) => ({ [t]: a }), Ro = (t) => {
    const a = {};
    return mt(t, (c) => {
      a[c.key] = c.value;
    }), a;
  }, ar = (t, a) => sn(t, a), rs = (t, a) => Hn(t, a), Zr = (t) => Ro(t), $s = (t, a) => t.length === 0 ? zo.value(a) : zo.value(Fs(a, hd.apply(void 0, t))), tc = (t) => zo.error(en(t)), yd = (t, a) => {
    const c = Pt(t);
    return c.errors.length > 0 ? tc(c.errors) : $s(c.values, a);
  }, ml = (t) => Q(t) ? t : wt, xd = (t, a, c) => {
    let f = t.dom;
    const g = ml(c);
    for (; f.parentNode; ) {
      f = f.parentNode;
      const x = He.fromDom(f), w = a(x);
      if (w.isSome())
        return w;
      if (g(x))
        break;
    }
    return B.none();
  }, Ff = (t, a, c) => {
    const f = a(t), g = ml(c);
    return f.orThunk(() => g(t) ? B.none() : xd(t, a, g));
  }, Lu = (t, a) => Lr(t.element, a.event.target), Sp = {
    can: qe,
    abort: wt,
    run: G
  }, jc = (t) => {
    if (!As(t, "can") && !As(t, "abort") && !As(t, "run"))
      throw new Error("EventHandler defined by: " + JSON.stringify(t, null, 2) + " does not have can, abort, or run!");
    return {
      ...Sp,
      ...t
    };
  }, nb = (t, a) => (...c) => Mt(t, (f, g) => f && a(g).apply(void 0, c), !0), zh = (t, a) => (...c) => Mt(t, (f, g) => f || a(g).apply(void 0, c), !1), ob = (t) => Q(t) ? {
    can: qe,
    abort: wt,
    run: t
  } : t, rb = (t) => {
    const a = nb(t, (g) => g.can), c = zh(t, (g) => g.abort);
    return {
      can: a,
      abort: c,
      run: (...g) => {
        mt(t, (x) => {
          x.run.apply(void 0, g);
        });
      }
    };
  }, ui = te, wr = ui("touchstart"), Xs = ui("touchmove"), Ja = ui("touchend"), Tc = ui("touchcancel"), nc = ui("mousedown"), sb = ui("mousemove"), wd = ui("mouseout"), Tm = ui("mouseup"), Bf = ui("mouseover"), Xd = ui("focusin"), $f = ui("focusout"), Cd = ui("keydown"), Pv = ui("keyup"), Lf = ui("input"), ab = ui("change"), Vh = ui("click"), zk = ui("transitioncancel"), Qd = ui("transitionend"), Vk = ui("transitionstart"), Iw = ui("selectstart"), Ta = (t) => te("alloy." + t), M0 = { tap: Ta("tap") }, Jd = Ta("focus"), kp = Ta("blur.post"), Om = Ta("paste.post"), Hu = Ta("receive"), zu = Ta("execute"), Dv = Ta("focus.item"), ef = M0.tap, Tl = Ta("longpress"), Rv = Ta("sandbox.close"), Fw = Ta("typeahead.cancel"), Nv = Ta("system.init"), Mv = Ta("system.touchmove"), Bw = Ta("system.touchend"), jh = Ta("system.scroll"), tf = Ta("system.resize"), oc = Ta("system.attached"), Vu = Ta("system.detached"), _p = Ta("system.dismissRequested"), $w = Ta("system.repositionRequested"), Uh = Ta("focusmanager.shifted"), Lw = Ta("slotcontainer.visibility"), jk = Ta("system.external.element.scroll"), Uk = Ta("change.tab"), Wk = Ta("dismiss.tab"), Ep = Ta("highlight"), Wh = Ta("dehighlight"), tr = (t, a) => {
    I0(t, t.element, a, {});
  }, po = (t, a, c) => {
    I0(t, t.element, a, c);
  }, Tp = (t) => {
    tr(t, zu());
  }, Iv = (t, a, c) => {
    I0(t, a, c, {});
  }, I0 = (t, a, c, f) => {
    const g = {
      target: a,
      ...f
    };
    t.getSystem().triggerEvent(c, a, g);
  }, Hw = (t, a, c, f) => {
    const g = {
      ...f,
      target: a
    };
    t.getSystem().triggerEvent(c, a, g);
  }, Hf = (t, a, c, f) => {
    t.getSystem().triggerEvent(c, a, f.event);
  }, js = (t) => Zr(t), Zk = (t, a) => ({
    key: t,
    value: jc({ abort: a })
  }), zw = (t, a) => ({
    key: t,
    value: jc({ can: a })
  }), F0 = (t) => ({
    key: t,
    value: jc({
      run: (a, c) => {
        c.event.prevent();
      }
    })
  }), It = (t, a) => ({
    key: t,
    value: jc({ run: a })
  }), Zh = (t, a, c) => ({
    key: t,
    value: jc({
      run: (f, g) => {
        a.apply(void 0, [
          f,
          g
        ].concat(c));
      }
    })
  }), X3 = (t) => (a) => It(t, a), Op = (t) => (a) => ({
    key: t,
    value: jc({
      run: (c, f) => {
        Lu(c, f) && a(c, f);
      }
    })
  }), Q3 = (t, a) => It(t, (c, f) => {
    c.getSystem().getByUid(a).each((g) => {
      Hf(g, g.element, t, f);
    });
  }), Gh = (t, a, c) => {
    const f = a.partUids[c];
    return Q3(t, f);
  }, Vw = (t, a) => It(t, (c, f) => {
    const g = f.event, x = c.getSystem().getByDom(g.target).getOrThunk(() => Ff(g.target, (T) => c.getSystem().getByDom(T).toOptional(), wt).getOr(c));
    a(c, x, f);
  }), nf = (t) => It(t, (a, c) => {
    c.cut();
  }), jw = (t) => It(t, (a, c) => {
    c.stop();
  }), ib = (t, a) => Op(t)(a), Qs = Op(oc()), zf = Op(Vu()), Gk = Op(Nv()), Sd = X3(zu()), Uw = (t, a, c) => {
    const f = c.toString(), g = f.indexOf(")") + 1, x = f.indexOf("("), w = f.substring(x + 1, g - 1).split(/,\s*/);
    return t.toFunctionAnnotation = () => ({
      name: a,
      parameters: Fv(w.slice(0, 1).concat(w.slice(3)))
    }), t;
  }, Fv = (t) => tt(t, (a) => ea(a, "/*") ? a.substring(0, a.length - 2) : a), lb = (t, a) => {
    const c = t.toString(), f = c.indexOf(")") + 1, g = c.indexOf("("), x = c.substring(g + 1, f - 1).split(/,\s*/);
    return t.toFunctionAnnotation = () => ({
      name: a,
      parameters: Fv(x)
    }), t;
  }, Bv = (t, a) => {
    const c = a.toString(), f = c.indexOf(")") + 1, g = c.indexOf("("), x = c.substring(g + 1, f - 1).split(/,\s*/);
    return t.toFunctionAnnotation = () => ({
      name: "OVERRIDE",
      parameters: Fv(x.slice(1))
    }), t;
  }, Uc = (t) => ({
    classes: be(t.classes) ? [] : t.classes,
    attributes: be(t.attributes) ? {} : t.attributes,
    styles: be(t.styles) ? {} : t.styles
  }), qk = (t, a) => ({
    ...t,
    attributes: {
      ...t.attributes,
      ...a.attributes
    },
    styles: {
      ...t.styles,
      ...a.styles
    },
    classes: t.classes.concat(a.classes)
  }), $v = (t, a, c) => Sd((f) => {
    c(f, t, a);
  }), Ww = (t, a, c) => Gk((f, g) => {
    c(f, t, a);
  }), Ap = (t, a, c, f, g, x) => {
    const w = Ni(t), T = Es(a, [wp("config", t)]);
    return Yk(w, T, a, c, f, g, x);
  }, Zw = (t, a, c, f, g, x) => {
    const w = t, T = Es(a, [bd("config", t)]);
    return Yk(w, T, a, c, f, g, x);
  }, Kk = (t, a, c) => Uw((g, ...x) => {
    const w = [g].concat(x);
    return g.config({ name: te(t) }).fold(() => {
      throw new Error("We could not find any behaviour configuration for: " + t + ". Using API: " + c);
    }, (T) => {
      const A = Array.prototype.slice.call(w, 1);
      return a.apply(void 0, [
        g,
        T.config,
        T.state
      ].concat(A));
    });
  }, c, a), Gw = (t) => ({
    key: t,
    value: void 0
  }), Yk = (t, a, c, f, g, x, w) => {
    const T = (q) => As(q, c) ? q[c]() : B.none(), A = kt(g, (q, ne) => Kk(c, q, ne)), H = {
      ...kt(x, (q, ne) => lb(q, ne)),
      ...A,
      revoke: Kt(Gw, c),
      config: (q) => {
        const ne = El(c + "-config", t, q);
        return {
          key: c,
          value: {
            config: ne,
            me: H,
            configAsRaw: Te(() => El(c + "-config", t, q)),
            initialConfig: q,
            state: w
          }
        };
      },
      schema: te(a),
      exhibit: (q, ne) => xa(T(q), Ht(f, "exhibit"), (ie, fe) => fe(ne, ie.config, ie.state)).getOrThunk(() => Uc({})),
      name: te(c),
      handlers: (q) => T(q).map((ne) => Ht(f, "events").getOr(() => ({}))(ne.config, ne.state)).getOr({})
    };
    return H;
  }, Bl = { init: () => Wc({ readState: te("No State required") }) }, Wc = (t) => t, Qt = (t) => Zr(t), B0 = Ni([
    Rt("fields"),
    Rt("name"),
    Qe("active", {}),
    Qe("apis", {}),
    Qe("state", Bl),
    Qe("extra", {})
  ]), Xi = (t) => {
    const a = El("Creating behaviour: " + t.name, B0, t);
    return Ap(a.fields, a.name, a.active, a.apis, a.extra, a.state);
  }, $0 = Ni([
    Rt("branchKey"),
    Rt("branches"),
    Rt("name"),
    Qe("active", {}),
    Qe("apis", {}),
    Qe("state", Bl),
    Qe("extra", {})
  ]), Xk = (t) => {
    const a = El("Creating behaviour: " + t.name, $0, t);
    return Zw(ci(a.branchKey, a.branches), a.name, a.active, a.apis, a.extra, a.state);
  }, Js = te(void 0), Am = (t, a) => {
    const c = os(t, a);
    return c === void 0 || c === "" ? [] : c.split(" ");
  }, L0 = (t, a, c) => {
    const g = Am(t, a).concat([c]);
    return rn(t, a, g.join(" ")), !0;
  }, J3 = (t, a, c) => {
    const f = To(Am(t, a), (g) => g !== c);
    return f.length > 0 ? rn(t, a, f.join(" ")) : Ee(t, a), !1;
  }, Pm = (t) => t.dom.classList !== void 0, H0 = (t) => Am(t, "class"), of = (t, a) => L0(t, "class", a), Qk = (t, a) => J3(t, "class", a), qw = (t, a) => jt(H0(t), a) ? Qk(t, a) : of(t, a), Us = (t, a) => {
    Pm(t) ? t.dom.classList.add(a) : of(t, a);
  }, cb = (t) => {
    (Pm(t) ? t.dom.classList : H0(t)).length === 0 && Ee(t, "class");
  }, va = (t, a) => {
    Pm(t) ? t.dom.classList.remove(a) : Qk(t, a), cb(t);
  }, Jk = (t, a) => {
    const c = Pm(t) ? t.dom.classList.toggle(a) : qw(t, a);
    return cb(t), c;
  }, Zc = (t, a) => Pm(t) && t.dom.classList.contains(a), ub = (t, a) => {
    mt(a, (c) => {
      Us(t, c);
    });
  }, Gc = (t, a) => {
    mt(a, (c) => {
      va(t, c);
    });
  }, e4 = (t, a) => {
    mt(a, (c) => {
      Jk(t, c);
    });
  }, t4 = (t, a) => jn(a, (c) => Zc(t, c)), n4 = (t) => {
    const a = t.dom.classList, c = new Array(a.length);
    for (let f = 0; f < a.length; f++) {
      const g = a.item(f);
      g !== null && (c[f] = g);
    }
    return c;
  }, o4 = (t) => Pm(t) ? n4(t) : H0(t), Ii = (t, a, c, f, g) => {
    const x = (w) => w + "px";
    return {
      position: t,
      left: a.map(x),
      top: c.map(x),
      right: f.map(x),
      bottom: g.map(x)
    };
  }, rc = (t) => ({
    ...t,
    position: B.some(t.position)
  }), Lv = (t, a) => {
    Gt(t, rc(a));
  }, Pp = (t) => (ra(ks(t, "position"), "fixed") ? B.none() : gi(t)).orThunk(() => {
    const f = He.fromTag("span");
    return Za(t).bind((g) => {
      qi(g, f);
      const x = gi(f);
      return Sc(f), x;
    });
  }), Kw = (t) => Pp(t).map(Ga).getOrThunk(() => zs(0, 0)), db = (t, a) => {
    const c = t.element;
    Us(c, a.transitionClass), va(c, a.fadeOutClass), Us(c, a.fadeInClass), a.onShow(t);
  }, Vf = (t, a) => {
    const c = t.element;
    Us(c, a.transitionClass), va(c, a.fadeInClass), Us(c, a.fadeOutClass), a.onHide(t);
  }, fb = (t, a) => t.y < a.bottom && t.bottom > a.y, qh = (t, a) => t.y >= a.y, Dp = (t, a) => t.bottom <= a.bottom, jf = (t, a, c) => ({
    location: "top",
    leftX: a,
    topY: c.bounds.y - t.y
  }), Kh = (t, a, c) => ({
    location: "bottom",
    leftX: a,
    bottomY: t.bottom - c.bounds.bottom
  }), Yh = (t) => t.box.x - t.win.x, r4 = (t, a, c) => {
    const f = a.win, g = a.box, x = Yh(a);
    return Ko(t, (w) => {
      switch (w) {
        case "bottom":
          return Dp(g, c.bounds) ? B.none() : B.some(Kh(f, x, c));
        case "top":
          return qh(g, c.bounds) ? B.none() : B.some(jf(f, x, c));
        default:
          return B.none();
      }
    }).getOr({ location: "no-dock" });
  }, Yw = (t, a, c) => jn(t, (f) => {
    switch (f) {
      case "bottom":
        return Dp(a, c.bounds);
      case "top":
        return qh(a, c.bounds);
    }
  }), z0 = (t, a) => {
    const c = a.optScrollEnv.fold(te(t.bounds.y), (f) => f.scrollElmTop + (t.bounds.y - f.currentScrollTop));
    return zs(t.bounds.x, c);
  }, e_ = (t, a) => {
    const c = a.optScrollEnv.fold(te(t.y), (f) => t.y + f.currentScrollTop - f.scrollElmTop);
    return zs(t.x, c);
  }, Xw = (t, a, c) => c.getInitialPos().map((f) => {
    const g = z0(f, a);
    return {
      box: Is(g.left, g.top, Pi(t), Bs(t)),
      location: f.location
    };
  }), V0 = (t, a, c, f, g) => {
    const x = e_(a, c), w = Is(x.left, x.top, a.width, a.height);
    f.setInitialPos({
      style: ga(t),
      position: fs(t, "position") || "static",
      bounds: w,
      location: g.location
    });
  }, Qw = (t, a, c, f, g) => {
    f.getInitialPos().fold(() => V0(t, a, c, f, g), () => G);
  }, j0 = (t, a, c) => c.getInitialPos().bind((f) => {
    var g;
    switch (c.clearInitialPos(), f.position) {
      case "static":
        return B.some({ morph: "static" });
      case "absolute":
        const x = Pp(t).getOr(Uo()), w = aa(x), T = (g = x.dom.scrollTop) !== null && g !== void 0 ? g : 0;
        return B.some({
          morph: "absolute",
          positionCss: Ii("absolute", Ht(f.style, "left").map((A) => a.x - w.x), Ht(f.style, "top").map((A) => a.y - w.y + T), Ht(f.style, "right").map((A) => w.right - a.right), Ht(f.style, "bottom").map((A) => w.bottom - a.bottom))
        });
      default:
        return B.none();
    }
  }), mb = (t, a, c) => Xw(t, a, c).filter(({ box: f }) => Yw(c.getModes(), f, a)).bind(({ box: f }) => j0(t, f, c)), U0 = (t) => {
    switch (t.location) {
      case "top":
        return B.some({
          morph: "fixed",
          positionCss: Ii("fixed", B.some(t.leftX), B.some(t.topY), B.none(), B.none())
        });
      case "bottom":
        return B.some({
          morph: "fixed",
          positionCss: Ii("fixed", B.some(t.leftX), B.none(), B.none(), B.some(t.bottomY))
        });
      default:
        return B.none();
    }
  }, dF = (t, a, c) => {
    const f = aa(t), g = Ra(), x = r4(c.getModes(), {
      win: g,
      box: f
    }, a);
    return x.location === "top" || x.location === "bottom" ? (V0(t, f, a, c, x), U0(x)) : B.none();
  }, s4 = (t, a, c) => mb(t, a, c).orThunk(() => a.optScrollEnv.bind((f) => Xw(t, a, c)).bind(({ box: f, location: g }) => {
    const x = Ra(), w = Yh({
      win: x,
      box: f
    }), T = g === "top" ? jf(x, w, a) : Kh(x, w, a);
    return U0(T);
  })), rf = (t, a, c) => {
    const f = t.element;
    return ra(ks(f, "position"), "fixed") ? s4(f, a, c) : dF(f, a, c);
  }, pb = (t, a, c) => {
    const f = t.element;
    return Xw(f, a, c).bind(({ box: g }) => j0(f, g, c));
  }, t_ = (t, a, c, f) => {
    const g = aa(t), x = Ra(), w = Yh({
      win: x,
      box: g
    }), T = f(x, w, a);
    return T.location === "bottom" || T.location === "top" ? (Qw(t, g, a, c, T), U0(T)) : B.none();
  }, n_ = (t, a, c) => {
    c.setDocked(!1), mt([
      "left",
      "right",
      "top",
      "bottom",
      "position"
    ], (f) => xr(t.element, f)), a.onUndocked(t);
  }, W0 = (t, a, c, f) => {
    const g = f.position === "fixed";
    c.setDocked(g), Lv(t.element, f), (g ? a.onDocked : a.onUndocked)(t);
  }, Rp = (t, a, c, f, g = !1) => {
    a.contextual.each((x) => {
      x.lazyContext(t).each((w) => {
        const T = fb(w, f.bounds);
        T !== c.isVisible() && (c.setVisible(T), g && !T ? (ub(t.element, [x.fadeOutClass]), x.onHide(t)) : (T ? db : Vf)(t, x));
      });
    });
  }, a4 = (t, a, c, f, g) => {
    Rp(t, a, c, f, !0), W0(t, a, c, g.positionCss);
  }, Jw = (t, a, c, f, g) => {
    switch (g.morph) {
      case "static":
        return n_(t, a, c);
      case "absolute":
        return W0(t, a, c, g.positionCss);
      case "fixed":
        return a4(t, a, c, f, g);
    }
  }, Hv = (t, a, c) => {
    const f = a.lazyViewport(t);
    Rp(t, a, c, f), rf(t, f, c).each((g) => {
      Jw(t, a, c, f, g);
    });
  }, i4 = (t, a, c) => {
    const f = t.element;
    c.setDocked(!1);
    const g = a.lazyViewport(t);
    pb(t, g, c).each((x) => {
      switch (x.morph) {
        case "static": {
          n_(t, a, c);
          break;
        }
        case "absolute": {
          W0(t, a, c, x.positionCss);
          break;
        }
      }
    }), c.setVisible(!0), a.contextual.each((x) => {
      Gc(f, [
        x.fadeInClass,
        x.fadeOutClass,
        x.transitionClass
      ]), x.onShow(t);
    }), Z0(t, a, c);
  }, Z0 = (t, a, c) => {
    t.getSystem().isConnected() && Hv(t, a, c);
  }, hb = (t, a, c) => {
    c.isDocked() && i4(t, a, c);
  }, o_ = (t) => (a, c, f) => {
    const g = c.lazyViewport(a);
    t_(a.element, g, f, t).each((w) => {
      a4(a, c, f, g, w);
    });
  }, G0 = o_(jf), e2 = o_(Kh);
  var t2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    refresh: Z0,
    reset: hb,
    isDocked: (t, a, c) => c.isDocked(),
    getModes: (t, a, c) => c.getModes(),
    setModes: (t, a, c, f) => c.setModes(f),
    forceDockToTop: G0,
    forceDockToBottom: e2
  }), s_ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, a) => js([
      ib(Qd(), (c, f) => {
        t.contextual.each((g) => {
          Zc(c.element, g.transitionClass) && (Gc(c.element, [
            g.transitionClass,
            g.fadeInClass
          ]), (a.isVisible() ? g.onShown : g.onHidden)(c)), f.stop();
        });
      }),
      It(jh(), (c, f) => {
        Z0(c, t, a);
      }),
      It(jk(), (c, f) => {
        Z0(c, t, a);
      }),
      It(tf(), (c, f) => {
        hb(c, t, a);
      })
    ])
  });
  const sf = (t, a) => {
    const f = (a || document).createElement("div");
    return f.innerHTML = t, $a(He.fromDom(f));
  }, Oc = (t) => t.dom.innerHTML, bb = (t, a) => {
    const f = ii(t).dom, g = He.fromDom(f.createDocumentFragment()), x = sf(a, f);
    md(g, x), Df(t), qi(t, g);
  }, vb = (t) => {
    const a = He.fromTag("div"), c = He.fromDom(t.dom.cloneNode(!0));
    return qi(a, c), Oc(a);
  }, Vv = (t, a) => He.fromDom(t.dom.cloneNode(a)), l4 = (t) => Vv(t, !1), c4 = (t) => Vv(t, !0), Xh = (t) => {
    if (iu(t))
      return "#shadow-root";
    {
      const a = l4(t);
      return vb(a);
    }
  }, qc = (t) => Xh(t), a_ = "unknown";
  var Ma;
  (function(t) {
    t[t.STOP = 0] = "STOP", t[t.NORMAL = 1] = "NORMAL", t[t.LOGGING = 2] = "LOGGING";
  })(Ma || (Ma = {}));
  const Qh = no({}), Kc = (t, a) => {
    const c = [], f = (/* @__PURE__ */ new Date()).getTime();
    return {
      logEventCut: (g, x, w) => {
        c.push({
          outcome: "cut",
          target: x,
          purpose: w
        });
      },
      logEventStopped: (g, x, w) => {
        c.push({
          outcome: "stopped",
          target: x,
          purpose: w
        });
      },
      logNoParent: (g, x, w) => {
        c.push({
          outcome: "no-parent",
          target: x,
          purpose: w
        });
      },
      logEventNoHandlers: (g, x) => {
        c.push({
          outcome: "no-handlers-left",
          target: x
        });
      },
      logEventResponse: (g, x, w) => {
        c.push({
          outcome: "response",
          purpose: w,
          target: x
        });
      },
      write: () => {
        const g = (/* @__PURE__ */ new Date()).getTime();
        jt([
          "mousemove",
          "mouseover",
          "mouseout",
          Nv()
        ], t) || console.log(t, {
          event: t,
          time: g - f,
          target: a.dom,
          sequence: tt(c, (x) => jt([
            "cut",
            "stopped",
            "response"
          ], x.outcome) ? "{" + x.purpose + "} " + x.outcome + " at (" + qc(x.target) + ")" : x.outcome)
        });
      }
    };
  }, fF = (t, a, c) => {
    switch (Ht(Qh.get(), t).orThunk(() => {
      const g = Qo(Qh.get());
      return Ko(g, (x) => t.indexOf(x) > -1 ? B.some(Qh.get()[x]) : B.none());
    }).getOr(Ma.NORMAL)) {
      case Ma.NORMAL:
        return c(Yc());
      case Ma.LOGGING: {
        const g = Kc(t, a), x = c(g);
        return g.write(), x;
      }
      case Ma.STOP:
        return !0;
    }
  }, q0 = [
    "alloy/data/Fields",
    "alloy/debugging/Debugging"
  ], yb = () => {
    const t = new Error();
    if (t.stack !== void 0) {
      const a = t.stack.split(`
`);
      return At(a, (c) => c.indexOf("alloy") > 0 && !Fn(q0, (f) => c.indexOf(f) > -1)).getOr(a_);
    } else
      return a_;
  }, Jh = {
    logEventCut: G,
    logEventStopped: G,
    logNoParent: G,
    logEventNoHandlers: G,
    logEventResponse: G,
    write: G
  }, af = (t, a, c) => fF(t, a, c), Yc = te(Jh), n2 = te([
    Rt("menu"),
    Rt("selectedMenu")
  ]), o2 = te([
    Rt("item"),
    Rt("selectedItem")
  ]);
  te(wo(o2().concat(n2())));
  const r2 = te(wo(o2())), eg = Yd("initSize", [
    Rt("numColumns"),
    Rt("numRows")
  ]), u4 = () => Vr("markers", r2()), tg = () => Yd("markers", [Rt("backgroundMenu")].concat(n2()).concat(o2())), Uf = (t) => Yd("markers", tt(t, Rt)), jv = (t, a, c) => (yb(), Qa(a, a, c, Hh((f) => zo.value((...g) => f.apply(void 0, g))))), Rr = (t) => jv("onHandler", t, Kd(G)), sc = (t) => jv("onKeyboardHandler", t, Kd(B.none)), ju = (t) => jv("onHandler", t, ec()), Dm = (t) => jv("onKeyboardHandler", t, ec()), Ws = (t, a) => Wr(t, te(a)), i_ = (t) => Wr(t, lt), K0 = te(eg);
  var Uv = [
    Es("contextual", [
      Va("fadeInClass"),
      Va("fadeOutClass"),
      Va("transitionClass"),
      _c("lazyContext"),
      Rr("onShow"),
      Rr("onShown"),
      Rr("onHide"),
      Rr("onHidden")
    ]),
    Ca("lazyViewport", () => ({
      bounds: Ra(),
      optScrollEnv: B.none()
    })),
    I("modes", [
      "top",
      "bottom"
    ], On),
    Rr("onDocked"),
    Rr("onUndocked")
  ], d4 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: (t) => {
      const a = no(!1), c = no(!0), f = ms(), g = no(t.modes), x = () => `docked:  ${a.get()}, visible: ${c.get()}, modes: ${g.get().join(",")}`;
      return Wc({
        isDocked: a.get,
        setDocked: a.set,
        getInitialPos: f.get,
        setInitialPos: f.set,
        clearInitialPos: f.clear,
        isVisible: c.get,
        setVisible: c.set,
        getModes: g.get,
        setModes: g.set,
        readState: x
      });
    }
  });
  const pa = Xi({
    fields: Uv,
    name: "docking",
    active: s_,
    apis: t2,
    state: d4
  }), s2 = (t, a, c) => Lr(a, t.element) && !Lr(a, c), f4 = js([zw(Jd(), (t, a) => {
    const c = a.event, f = c.originator, g = c.target;
    return s2(t, f, g) ? (console.warn(Jd() + ` did not get interpreted by the desired target. 
Originator: ` + qc(f) + `
Target: ` + qc(g) + `
Check the ` + Jd() + " event handlers"), !1) : !0;
  })]);
  var m4 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: f4
  });
  let xb = 0;
  const Nn = (t) => {
    const c = (/* @__PURE__ */ new Date()).getTime(), f = Math.floor(Math.random() * 1e9);
    return xb++, t + "_" + f + xb + String(c);
  }, p4 = te("alloy-id-"), l_ = te("data-alloy-id"), X0 = p4(), a2 = l_(), h4 = (t, a) => {
    const c = Nn(X0 + t);
    return Wv(a, c), c;
  }, Wv = (t, a) => {
    Object.defineProperty(t.dom, a2, {
      value: a,
      writable: !0
    });
  }, Zv = (t) => {
    const a = ko(t) ? t.dom[a2] : null;
    return B.from(a);
  }, ng = (t) => Nn(t), mF = lt, Wf = (t) => {
    const a = (g) => `The component must be in a context to execute: ${g}` + (t ? `
` + qc(t().element) + " is not in context." : ""), c = (g) => () => {
      throw new Error(a(g));
    }, f = (g) => () => {
      console.warn(a(g));
    };
    return {
      debugInfo: te("fake"),
      triggerEvent: f("triggerEvent"),
      triggerFocus: f("triggerFocus"),
      triggerEscape: f("triggerEscape"),
      broadcast: f("broadcast"),
      broadcastOn: f("broadcastOn"),
      broadcastEvent: f("broadcastEvent"),
      build: c("build"),
      buildOrPatch: c("buildOrPatch"),
      addToWorld: c("addToWorld"),
      removeFromWorld: c("removeFromWorld"),
      addToGui: c("addToGui"),
      removeFromGui: c("removeFromGui"),
      getByUid: c("getByUid"),
      getByDom: c("getByDom"),
      isConnected: wt
    };
  }, g4 = Wf(), Rm = Nn("alloy-premade"), c_ = (t) => (Object.defineProperty(t.element.dom, Rm, {
    value: t.uid,
    writable: !0
  }), rs(Rm, t)), lf = (t) => Ho(t.dom, Rm), u_ = (t) => Ht(t, Rm), wb = (t) => Bv((a, ...c) => t(a.getApis(), a, ...c), t), b4 = (t, a) => {
    const c = tt(a, (g) => Es(g.name(), [
      Rt("config"),
      Qe("state", Bl)
    ])), f = ia("component.behaviours", wo(c), t.behaviours).fold((g) => {
      throw new Error(Bu(g) + `
Complete spec:
` + JSON.stringify(t, null, 2));
    }, lt);
    return {
      list: a,
      data: kt(f, (g) => {
        const x = g.map((w) => ({
          config: w.config,
          state: w.state.init(w.config)
        }));
        return te(x);
      })
    };
  }, v4 = (t) => t.list, y4 = (t) => t.data, i2 = (t, a) => {
    const c = {};
    return at(t, (f, g) => {
      at(f, (x, w) => {
        const T = Ht(c, w).getOr([]);
        c[w] = T.concat([a(g, x)]);
      });
    }), c;
  }, Q0 = (t, a, c, f) => {
    const g = { ...a };
    mt(c, (H) => {
      g[H.name()] = H.exhibit(t, f);
    });
    const x = i2(g, (H, q) => ({
      name: H,
      modification: q
    })), w = (H) => Ot(H, (q, ne) => ({
      ...ne.modification,
      ...q
    }), {}), T = Ot(x.classes, (H, q) => q.modification.concat(H), []), A = w(x.attributes), F = w(x.styles);
    return Uc({
      classes: T,
      attributes: A,
      styles: F
    });
  }, d_ = (t, a, c, f) => {
    try {
      const g = Jn(c, (x, w) => {
        const T = x[a], A = w[a], F = f.indexOf(T), H = f.indexOf(A);
        if (F === -1)
          throw new Error("The ordering for " + t + " does not have an entry for " + T + `.
Order specified: ` + JSON.stringify(f, null, 2));
        if (H === -1)
          throw new Error("The ordering for " + t + " does not have an entry for " + A + `.
Order specified: ` + JSON.stringify(f, null, 2));
        return F < H ? -1 : H < F ? 1 : 0;
      });
      return zo.value(g);
    } catch (g) {
      return zo.error([g]);
    }
  }, l2 = (t, a) => ({
    handler: t,
    purpose: a
  }), x4 = (t, a) => ({
    cHandler: t,
    purpose: a
  }), Gv = (t, a) => x4(Kt.apply(void 0, [t.handler].concat(a)), t.purpose), Np = (t) => t.cHandler, Cb = (t, a) => ({
    name: t,
    handler: a
  }), J0 = (t, a) => {
    const c = {};
    return mt(t, (f) => {
      c[f.name()] = f.handlers(a);
    }), c;
  }, c2 = (t, a, c) => {
    const f = {
      ...c,
      ...J0(a, t)
    };
    return i2(f, Cb);
  }, ey = (t, a, c, f) => {
    const g = c2(t, c, f);
    return f_(g, a);
  }, u2 = (t) => {
    const a = ob(t);
    return (c, f, ...g) => {
      const x = [
        c,
        f
      ].concat(g);
      a.abort.apply(void 0, x) ? f.stop() : a.can.apply(void 0, x) && a.run.apply(void 0, x);
    };
  }, d2 = (t, a) => zo.error(["The event (" + t + `) has more than one behaviour that listens to it.
When this occurs, you must specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).
The behaviours that can trigger it are: ` + JSON.stringify(tt(a, (c) => c.name), null, 2)]), f2 = (t, a, c) => {
    const f = a[c];
    return f ? d_("Event: " + c, "name", t, f).map((g) => {
      const x = tt(g, (w) => w.handler);
      return rb(x);
    }) : d2(c, t);
  }, f_ = (t, a) => {
    const c = Ir(t, (f, g) => (f.length === 1 ? zo.value(f[0].handler) : f2(f, a, g)).map((w) => {
      const T = u2(w), A = f.length > 1 ? To(a[g], (F) => Fn(f, (H) => H.name === F)).join(" > ") : f[0].name;
      return rs(g, l2(T, A));
    }));
    return yd(c, {});
  }, Qi = "alloy.base.behaviour", w4 = wo([
    Qa("dom", "dom", ec(), wo([
      Rt("tag"),
      Qe("styles", {}),
      Qe("classes", []),
      Qe("attributes", {}),
      jr("value"),
      jr("innerHtml")
    ])),
    Rt("components"),
    Rt("uid"),
    Qe("events", {}),
    Qe("apis", {}),
    Qa("eventOrder", "eventOrder", Yg({
      [zu()]: [
        "disabling",
        Qi,
        "toggling",
        "typeaheadevents"
      ],
      [Jd()]: [
        Qi,
        "focusing",
        "keying"
      ],
      [Nv()]: [
        Qi,
        "disabling",
        "toggling",
        "representing"
      ],
      [Lf()]: [
        Qi,
        "representing",
        "streaming",
        "invalidating"
      ],
      [Vu()]: [
        Qi,
        "representing",
        "item-events",
        "toolbar-button-events",
        "tooltipping"
      ],
      [nc()]: [
        "focusing",
        Qi,
        "item-type-events"
      ],
      [wr()]: [
        "focusing",
        Qi,
        "item-type-events"
      ],
      [Bf()]: [
        "item-type-events",
        "tooltipping"
      ],
      [Hu()]: [
        "receiving",
        "reflecting",
        "tooltipping"
      ]
    }), uu()),
    jr("domModification")
  ]), m_ = (t) => ia("custom.definition", w4, t), Mp = (t) => ({
    ...t.dom,
    uid: t.uid,
    domChildren: tt(t.components, (a) => a.element)
  }), og = (t) => t.domModification.fold(() => Uc({}), Uc), m2 = (t) => t.events, vt = (t) => t.dom.value, Zf = (t, a) => {
    if (a === void 0)
      throw new Error("Value.set was undefined");
    t.dom.value = a;
  }, C4 = (t, a, c) => Wi(t, a).map((g) => {
    if (c.exists((w) => !Lr(w, g))) {
      const w = c.map(Kr).getOr("span"), T = He.fromTag(w);
      return Xl(g, T), T;
    } else
      return g;
  }), p_ = (t, a, c) => {
    c.fold(() => qi(t, a), (f) => {
      Lr(f, a) || (Xl(f, a), Sc(f));
    });
  }, qv = (t, a, c) => {
    const f = tt(a, c), g = $a(t);
    return mt(g.slice(f.length), Sc), f;
  }, Uu = (t, a, c, f) => {
    const g = Wi(t, a), x = f(c, g), w = C4(t, a, g);
    return p_(t, x.element, w), x;
  }, Kv = (t, a, c) => qv(t, a, (f, g) => Uu(t, g, f, c)), h_ = (t, a) => qv(t, a, (c, f) => {
    const g = Wi(t, f);
    return p_(t, c, g), c;
  }), p2 = (t, a) => {
    const c = Qo(t), f = Qo(a), g = xn(f, c), x = hr(t, (w, T) => !Ho(a, T) || w !== a[T]).t;
    return {
      toRemove: g,
      toSet: x
    };
  }, $l = (t, a) => {
    const {
      class: c,
      style: f,
      ...g
    } = ft(a), {
      toSet: x,
      toRemove: w
    } = p2(t.attributes, g), T = () => {
      mt(w, (Ge) => Ee(a, Ge)), cd(a, x);
    }, A = ga(a), {
      toSet: F,
      toRemove: H
    } = p2(t.styles, A), q = () => {
      mt(H, (Ge) => xr(a, Ge)), Rs(a, F);
    }, ne = o4(a), ie = xn(ne, t.classes), fe = xn(t.classes, ne), _e = () => {
      ub(a, fe), Gc(a, ie);
    }, st = (Ge) => {
      bb(a, Ge);
    }, De = () => {
      const Ge = t.domChildren;
      h_(a, Ge);
    }, Je = () => {
      const Ge = a, Ft = t.value.getOrUndefined();
      Ft !== vt(Ge) && Zf(Ge, Ft ?? "");
    };
    return T(), _e(), q(), t.innerHtml.fold(De, st), Je(), a;
  }, ty = (t) => {
    const a = He.fromTag(t.tag);
    cd(a, t.attributes), ub(a, t.classes), Rs(a, t.styles), t.innerHtml.each((f) => bb(a, f));
    const c = t.domChildren;
    return md(a, c), t.value.each((f) => {
      Zf(a, f);
    }), a;
  }, g_ = (t, a) => {
    try {
      const c = $l(t, a);
      return B.some(c);
    } catch {
      return B.none();
    }
  }, S4 = (t) => t.innerHtml.isSome() && t.domChildren.length > 0, b_ = (t, a) => {
    const c = (g) => Kr(g) === t.tag && !S4(t) && !lf(g), f = a.filter(c).bind((g) => g_(t, g)).getOrThunk(() => ty(t));
    return Wv(f, t.uid), f;
  }, k4 = (t) => {
    const a = Ht(t, "behaviours").getOr({});
    return Ue(Qo(a), (c) => {
      const f = a[c];
      return Ce(f) ? [f.me] : [];
    });
  }, v_ = (t, a) => b4(t, a), _4 = (t) => {
    const a = k4(t);
    return v_(t, a);
  }, E4 = (t, a, c) => {
    const f = Mp(t), g = og(t), x = { "alloy.base.modification": g }, w = a.length > 0 ? Q0(c, x, a, f) : g;
    return qk(f, w);
  }, y_ = (t, a, c) => {
    const f = { "alloy.base.behaviour": m2(t) };
    return ey(c, t.eventOrder, a, f).getOrDie();
  }, Sb = (t, a) => {
    const c = () => Ge, f = no(g4), g = Zt(m_(t)), x = _4(t), w = v4(x), T = y4(x), A = E4(g, w, T), F = b_(A, a), H = y_(g, w, T), q = no(g.components), ne = (Ft) => {
      f.set(Ft);
    }, ie = () => {
      f.set(Wf(c));
    }, fe = () => {
      const Ft = $a(F), gt = Ue(Ft, (Jt) => f.get().getByDom(Jt).fold(() => [], Ct));
      q.set(gt);
    }, _e = (Ft) => {
      const gt = T;
      return (Q(gt[Ft.name()]) ? gt[Ft.name()] : () => {
        throw new Error("Could not find " + Ft.name() + " in " + JSON.stringify(t, null, 2));
      })();
    }, st = (Ft) => Q(T[Ft.name()]), De = () => g.apis, Je = (Ft) => T[Ft]().map((gt) => gt.state.readState()).getOr("not enabled"), Ge = {
      uid: t.uid,
      getSystem: f.get,
      config: _e,
      hasConfigured: st,
      spec: t,
      readState: Je,
      getApis: De,
      connect: ne,
      disconnect: ie,
      element: F,
      syncComponents: fe,
      components: q.get,
      events: H
    };
    return Ge;
  }, T4 = (t, a) => {
    const c = Ht(t, "components").getOr([]);
    return a.fold(() => tt(c, Al), (f) => tt(c, (g, x) => oy(g, Wi(f, x))));
  }, x_ = (t, a) => {
    const {
      events: c,
      ...f
    } = mF(t), g = T4(f, a), x = {
      ...f,
      events: {
        ...m4,
        ...c
      },
      components: g
    };
    return zo.value(Sb(x, a));
  }, Oa = (t) => {
    const a = He.fromText(t);
    return ny({ element: a });
  }, ny = (t) => {
    const a = El("external.component", Ni([
      Rt("element"),
      jr("uid")
    ]), t), c = no(Wf()), f = (T) => {
      c.set(T);
    }, g = () => {
      c.set(Wf(() => w));
    }, x = a.uid.getOrThunk(() => ng("external"));
    Wv(a.element, x);
    const w = {
      uid: x,
      getSystem: c.get,
      config: B.none,
      hasConfigured: wt,
      connect: f,
      disconnect: g,
      getApis: () => ({}),
      element: a.element,
      spec: t,
      readState: te("No state"),
      syncComponents: G,
      components: te([]),
      events: {}
    };
    return c_(w);
  }, w_ = ng, C_ = (t) => Ho(t, "uid"), oy = (t, a) => u_(t).getOrThunk(() => {
    const c = C_(t) ? t : {
      uid: w_(""),
      ...t
    };
    return x_(c, a).getOrDie();
  }), Al = (t) => oy(t, B.none()), Ll = c_;
  var S_ = (t, a, c, f, g) => t(c, f) ? B.some(c) : Q(g) && g(c) ? B.none() : a(c, f, g);
  const k_ = (t, a, c) => {
    let f = t.dom;
    const g = Q(c) ? c : wt;
    for (; f.parentNode; ) {
      f = f.parentNode;
      const x = He.fromDom(f);
      if (a(x))
        return B.some(x);
      if (g(x))
        break;
    }
    return B.none();
  }, h2 = (t, a, c) => S_((g, x) => x(g), k_, t, a, c), __ = (t, a) => {
    const c = t.dom;
    return c.parentNode ? E_(He.fromDom(c.parentNode), (f) => !Lr(t, f) && a(f)) : B.none();
  }, E_ = (t, a) => {
    const c = (g) => a(He.fromDom(g));
    return At(t.dom.childNodes, c).map(He.fromDom);
  }, g2 = (t, a) => {
    const c = (f) => {
      for (let g = 0; g < f.childNodes.length; g++) {
        const x = He.fromDom(f.childNodes[g]);
        if (a(x))
          return B.some(x);
        const w = c(f.childNodes[g]);
        if (w.isSome())
          return w;
      }
      return B.none();
    };
    return c(t.dom);
  }, b2 = (t, a, c) => h2(t, a, c).isSome(), ry = (t) => vc(t), Nm = (t, a, c) => k_(t, (f) => vs(f, a), c), ac = (t, a) => __(t, (c) => vs(c, a)), v2 = (t, a) => E_(t, (c) => vs(c, a)), ss = (t, a) => vc(a, t), cf = (t, a, c) => S_((g, x) => vs(g, x), Nm, t, a, c), Yv = "aria-controls", T_ = (t) => h2(t, (c) => {
    if (!ko(c))
      return !1;
    const f = os(c, "id");
    return f !== void 0 && f.indexOf(Yv) > -1;
  }).bind((c) => {
    const f = os(c, "id"), g = le(c);
    return ss(g, `[${Yv}="${f}"]`);
  }), sy = () => {
    const t = Nn(Yv);
    return {
      id: t,
      link: (f) => {
        rn(f, Yv, t);
      },
      unlink: (f) => {
        Ee(f, Yv);
      }
    };
  }, ay = (t, a) => T_(a).exists((c) => Ip(t, c)), Ip = (t, a) => b2(a, (c) => Lr(c, t.element), wt) || ay(t, a), Ji = (t, a, c, f, g, x, w, T = !1) => ({
    x: t,
    y: a,
    bubble: c,
    direction: f,
    placement: g,
    restriction: x,
    label: `${w}-${g}`,
    alwaysFit: T
  }), Fp = Be.generate([
    { southeast: [] },
    { southwest: [] },
    { northeast: [] },
    { northwest: [] },
    { south: [] },
    { north: [] },
    { east: [] },
    { west: [] }
  ]), y2 = (t, a, c, f, g, x, w, T, A) => t.fold(a, c, f, g, x, w, T, A), O_ = (t, a, c, f) => t.fold(a, a, f, f, a, f, c, c), O4 = (t, a, c, f) => t.fold(a, f, a, f, c, c, a, f), kb = Fp.southeast, x2 = Fp.southwest, w2 = Fp.northeast, C2 = Fp.northwest, S2 = Fp.south, Bn = Fp.north, Xv = Fp.east, k2 = Fp.west, _b = (t, a, c, f) => {
    const g = t + a;
    return g > f ? c : g < c ? f : g;
  }, kd = (t, a, c) => Math.min(Math.max(t, a), c), A4 = (t, a) => {
    switch (a) {
      case 1:
        return t.x;
      case 0:
        return t.x + t.width;
      case 2:
        return t.y;
      case 3:
        return t.y + t.height;
    }
  }, el = (t, a) => Vt([
    "left",
    "right",
    "top",
    "bottom"
  ], (c) => Ht(a, c).map((f) => A4(t, f))), P4 = (t, a, c) => {
    const f = (A, F) => a[A].map((H) => {
      const q = A === "top" || A === "bottom", ne = q ? c.top : c.left, fe = (A === "left" || A === "top" ? Math.max : Math.min)(H, F) + ne;
      return q ? kd(fe, t.y, t.bottom) : kd(fe, t.x, t.right);
    }).getOr(F), g = f("left", t.x), x = f("top", t.y), w = f("right", t.right), T = f("bottom", t.bottom);
    return Is(g, x, w - g, T - x);
  }, Bp = "layout", _2 = (t) => t.x, A_ = (t, a) => t.x + t.width / 2 - a.width / 2, Pl = (t, a) => t.x + t.width - a.width, $p = (t, a) => t.y - a.height, iy = (t) => t.y + t.height, Lp = (t, a) => t.y + t.height / 2 - a.height / 2, D4 = (t) => t.x + t.width, R4 = (t, a) => t.x - a.width, di = (t, a, c) => Ji(_2(t), iy(t), c.southeast(), kb(), "southeast", el(t, {
    left: 1,
    top: 3
  }), Bp), ei = (t, a, c) => Ji(Pl(t, a), iy(t), c.southwest(), x2(), "southwest", el(t, {
    right: 0,
    top: 3
  }), Bp), fi = (t, a, c) => Ji(_2(t), $p(t, a), c.northeast(), w2(), "northeast", el(t, {
    left: 1,
    bottom: 2
  }), Bp), xs = (t, a, c) => Ji(Pl(t, a), $p(t, a), c.northwest(), C2(), "northwest", el(t, {
    right: 0,
    bottom: 2
  }), Bp), Ci = (t, a, c) => Ji(A_(t, a), $p(t, a), c.north(), Bn(), "north", el(t, { bottom: 2 }), Bp), ti = (t, a, c) => Ji(A_(t, a), iy(t), c.south(), S2(), "south", el(t, { top: 3 }), Bp), E2 = (t, a, c) => Ji(D4(t), Lp(t, a), c.east(), Xv(), "east", el(t, { left: 0 }), Bp), ly = (t, a, c) => Ji(R4(t, a), Lp(t, a), c.west(), k2(), "west", el(t, { right: 1 }), Bp), T2 = () => [
    di,
    ei,
    fi,
    xs,
    ti,
    Ci,
    E2,
    ly
  ], P_ = () => [
    ei,
    di,
    xs,
    fi,
    ti,
    Ci,
    E2,
    ly
  ], D_ = () => [
    fi,
    xs,
    di,
    ei,
    Ci,
    ti
  ], cy = () => [
    xs,
    fi,
    ei,
    di,
    Ci,
    ti
  ], uy = () => [
    di,
    ei,
    fi,
    xs,
    ti,
    Ci
  ], rg = () => [
    ei,
    di,
    xs,
    fi,
    ti,
    Ci
  ], O2 = (t, a) => a.universal ? t : To(t, (c) => jt(a.channels, c));
  var sg = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t) => js([It(Hu(), (a, c) => {
      const f = t.channels, g = Qo(f), x = c, w = O2(g, x);
      mt(w, (T) => {
        const A = f[T], F = A.schema, H = El("channel[" + T + `] data
Receiver: ` + qc(a.element), F, x.data);
        A.onReceive(a, H);
      });
    })])
  }), N4 = [Vr("channels", Fu(zo.value, Ni([
    ju("onReceive"),
    Qe("schema", uu())
  ])))];
  const Ac = Xi({
    fields: N4,
    name: "receiving",
    active: sg
  });
  var M4 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, a) => Uc({
      classes: [],
      styles: a.useFixed() ? {} : { position: "relative" }
    })
  });
  const mu = (t, a = !1) => t.dom.focus({ preventScroll: a }), Qv = (t) => t.dom.blur(), Jv = (t) => {
    const a = le(t).dom;
    return t.dom === a.activeElement;
  }, uf = (t = Ql()) => B.from(t.dom.activeElement).map(He.fromDom), ic = (t) => uf(le(t)).filter((a) => t.dom.contains(a.dom)), Hp = (t, a) => {
    const c = le(a), f = uf(c).bind((x) => {
      const w = (T) => Lr(x, T);
      return w(a) ? B.some(a) : g2(a, w);
    }), g = t(a);
    return f.each((x) => {
      uf(c).filter((w) => Lr(w, x)).fold(() => {
        mu(x);
      }, G);
    }), g;
  }, A2 = Be.generate([
    { none: [] },
    {
      relative: [
        "x",
        "y",
        "width",
        "height"
      ]
    },
    {
      fixed: [
        "x",
        "y",
        "width",
        "height"
      ]
    }
  ]), dy = (t, a, c, f, g, x) => {
    const w = a.rect, T = w.x - c, A = w.y - f, F = w.width, H = w.height, q = g - (T + F), ne = x - (A + H), ie = B.some(T), fe = B.some(A), _e = B.some(q), st = B.some(ne), De = B.none();
    return y2(a.direction, () => Ii(t, ie, fe, De, De), () => Ii(t, De, fe, _e, De), () => Ii(t, ie, De, De, st), () => Ii(t, De, De, _e, st), () => Ii(t, ie, fe, De, De), () => Ii(t, ie, De, De, st), () => Ii(t, ie, fe, De, De), () => Ii(t, De, fe, _e, De));
  }, R_ = (t, a) => t.fold(() => {
    const c = a.rect;
    return Ii("absolute", B.some(c.x), B.some(c.y), B.none(), B.none());
  }, (c, f, g, x) => dy("absolute", a, c, f, g, x), (c, f, g, x) => dy("fixed", a, c, f, g, x)), ag = (t, a) => {
    const c = Kt(wm, a), f = t.fold(c, c, () => {
      const w = wi();
      return wm(a).translate(-w.left, -w.top);
    }), g = li(a), x = ud(a);
    return Is(f.left, f.top, g, x);
  }, P2 = (t, a) => a.fold(() => t.fold(Ra, Ra, Is), (c) => t.fold(te(c), te(c), () => {
    const f = D2(t, c.x, c.y);
    return Is(f.left, f.top, c.width, c.height);
  })), D2 = (t, a, c) => {
    const f = zs(a, c), g = () => {
      const x = wi();
      return f.translate(-x.left, -x.top);
    };
    return t.fold(te(f), te(f), g);
  }, N_ = (t, a, c, f) => t.fold(a, c, f);
  A2.none;
  const M_ = A2.relative, e1 = A2.fixed, ig = (t, a) => ({
    anchorBox: t,
    origin: a
  }), R2 = (t, a) => ig(t, a), N2 = "data-alloy-placement", I_ = (t, a) => {
    rn(t, N2, a);
  }, F_ = (t) => K(t, N2), I4 = (t) => Ee(t, N2), fy = Be.generate([
    { fit: ["reposition"] },
    {
      nofit: [
        "reposition",
        "visibleW",
        "visibleH",
        "isVisible"
      ]
    }
  ]), B_ = (t, a) => {
    const {
      x: c,
      y: f,
      right: g,
      bottom: x
    } = a, { x: w, y: T, right: A, bottom: F, width: H, height: q } = t, ne = w >= c && w <= g, ie = T >= f && T <= x, fe = ne && ie, _e = A <= g && A >= c, st = F <= x && F >= f, De = _e && st, Je = Math.min(H, w >= c ? g - w : A - c), Ge = Math.min(q, T >= f ? x - T : F - f);
    return {
      originInBounds: fe,
      sizeInBounds: De,
      visibleW: Je,
      visibleH: Ge
    };
  }, F4 = (t, a) => {
    const {
      x: c,
      y: f,
      right: g,
      bottom: x
    } = a, { x: w, y: T, width: A, height: F } = t, H = Math.max(c, g - A), q = Math.max(f, x - F), ne = kd(w, c, H), ie = kd(T, f, q), fe = Math.min(ne + A, g) - ne, _e = Math.min(ie + F, x) - ie;
    return Is(ne, ie, fe, _e);
  }, $_ = (t, a, c) => {
    const f = te(a.bottom - c.y), g = te(c.bottom - a.y), x = O_(t, g, g, f), w = te(a.right - c.x), T = te(c.right - a.x);
    return {
      maxWidth: O4(t, T, T, w),
      maxHeight: x
    };
  }, t1 = (t, a, c, f) => {
    const g = t.bubble, x = g.offset, w = P4(f, t.restriction, x), T = t.x + x.left, A = t.y + x.top, F = Is(T, A, a, c), { originInBounds: H, sizeInBounds: q, visibleW: ne, visibleH: ie } = B_(F, w), fe = H && q, _e = fe ? F : F4(F, w), st = _e.width > 0 && _e.height > 0, { maxWidth: De, maxHeight: Je } = $_(t.direction, _e, f), Ge = {
      rect: _e,
      maxHeight: Je,
      maxWidth: De,
      direction: t.direction,
      placement: t.placement,
      classes: {
        on: g.classesOn,
        off: g.classesOff
      },
      layout: t.label,
      testY: A
    };
    return fe || t.alwaysFit ? fy.fit(Ge) : fy.nofit(Ge, ne, ie, st);
  }, B4 = (t, a, c, f, g, x) => {
    const w = f.width, T = f.height, A = (H, q, ne, ie, fe) => {
      const _e = H(c, f, g, t, x), st = t1(_e, w, T, x);
      return st.fold(te(st), (De, Je, Ge, Ft) => (fe === Ft ? Ge > ie || Je > ne : !fe && Ft) ? st : fy.nofit(q, ne, ie, fe));
    };
    return Mt(a, (H, q) => {
      const ne = Kt(A, q);
      return H.fold(te(H), ne);
    }, fy.nofit({
      rect: c,
      maxHeight: f.height,
      maxWidth: f.width,
      direction: kb(),
      placement: "southeast",
      classes: {
        on: [],
        off: []
      },
      layout: "none",
      testY: c.y
    }, -1, -1, !1)).fold(lt, lt);
  }, L_ = qe, lc = (t, a, c) => Bc(t, a, L_, c), M2 = (t, a, c) => Nh(t, a, L_, c), I2 = Gd, F2 = [
    "top",
    "bottom",
    "right",
    "left"
  ], my = "data-alloy-transition-timer", $4 = (t, a) => t4(t, a.classes), L4 = (t, a, c) => c.exists((f) => {
    const g = t.mode;
    return g === "all" ? !0 : f[g] !== a[g];
  }), py = (t, a) => {
    const c = (f) => parseFloat(f).toFixed(3);
    return Zo(a, (f, g) => {
      const x = t[g].map(c), w = f.map(c);
      return !qs(x, w);
    }).isSome();
  }, H_ = (t) => {
    const a = (x) => {
      const T = fs(t, x).split(/\s*,\s*/);
      return To(T, Re);
    }, c = (x) => {
      if (_(x) && /^[\d.]+/.test(x)) {
        const w = parseFloat(x);
        return ea(x, "ms") ? w : w * 1e3;
      } else
        return 0;
    }, f = a("transition-delay"), g = a("transition-duration");
    return Mt(g, (x, w, T) => {
      const A = c(f[T]) + c(w);
      return Math.max(x, A);
    }, 0);
  }, B2 = (t, a) => {
    const c = za(), f = za();
    let g;
    const x = (F) => {
      var H;
      const q = (H = F.raw.pseudoElement) !== null && H !== void 0 ? H : "";
      return Lr(F.target, t) && Oe(q) && jt(F2, F.raw.propertyName);
    }, w = (F) => {
      if (ke(F) || x(F)) {
        c.clear(), f.clear();
        const H = F == null ? void 0 : F.raw.type;
        (ke(H) || H === Qd()) && (clearTimeout(g), Ee(t, my), Gc(t, a.classes));
      }
    }, T = lc(t, Vk(), (F) => {
      x(F) && (T.unbind(), c.set(lc(t, Qd(), w)), f.set(lc(t, zk(), w)));
    }), A = H_(t);
    requestAnimationFrame(() => {
      g = setTimeout(w, A + 17), rn(t, my, g);
    });
  }, $2 = (t, a) => {
    ub(t, a.classes), K(t, my).each((c) => {
      clearTimeout(parseInt(c, 10)), Ee(t, my);
    }), B2(t, a);
  }, n1 = (t, a, c, f, g, x) => {
    const w = L4(f, g, x);
    if (w || $4(t, f)) {
      Ln(t, "position", c.position);
      const T = ag(a, t), A = R_(a, {
        ...g,
        rect: T
      }), F = Vt(F2, (H) => A[H]);
      py(c, F) && (Gt(t, F), w && $2(t, f), yi(t));
    } else
      Gc(t, f.classes);
  }, L2 = (t) => ({
    width: li(t),
    height: ud(t)
  }), z_ = (t, a, c, f) => {
    xr(a, "max-height"), xr(a, "max-width");
    const g = L2(a);
    return B4(a, f.preference, t, g, c, f.bounds);
  }, V_ = (t, a) => {
    const c = a.classes;
    Gc(t, c.off), ub(t, c.on);
  }, j_ = (t, a, c) => {
    const f = c.maxHeightFunction;
    f(t, a.maxHeight);
  }, H4 = (t, a, c) => {
    const f = c.maxWidthFunction;
    f(t, a.maxWidth);
  }, U_ = (t, a, c) => {
    const f = R_(c.origin, a);
    c.transition.each((g) => {
      n1(t, c.origin, f, g, a, c.lastPlacement);
    }), Lv(t, f);
  }, W_ = (t, a) => {
    I_(t, a.placement);
  }, Z_ = (t, a) => {
    vm(t, Math.floor(a));
  }, hy = te((t, a) => {
    Z_(t, a), Rs(t, {
      "overflow-x": "hidden",
      "overflow-y": "auto"
    });
  }), Eb = te((t, a) => {
    Z_(t, a);
  }), G_ = (t, a, c) => t[a] === void 0 ? c : t[a], z4 = (t, a, c, f, g, x, w, T) => {
    const A = G_(w, "maxHeightFunction", hy()), F = G_(w, "maxWidthFunction", G), H = t.anchorBox, q = t.origin, ne = {
      bounds: P2(q, x),
      origin: q,
      preference: f,
      maxHeightFunction: A,
      maxWidthFunction: F,
      lastPlacement: g,
      transition: T
    };
    return gy(H, a, c, ne);
  }, gy = (t, a, c, f) => {
    const g = z_(t, a, c, f);
    return U_(a, g, f), W_(a, g), V_(a, g), j_(a, g, f), H4(a, g, f), {
      layout: g.layout,
      placement: g.placement
    };
  }, V4 = [
    "valignCentre",
    "alignLeft",
    "alignRight",
    "alignCentre",
    "top",
    "bottom",
    "left",
    "right",
    "inset"
  ], _d = (t, a, c, f = 1) => {
    const g = t * f, x = a * f, w = (A) => Ht(c, A).getOr([]), T = (A, F, H) => {
      const q = xn(V4, H);
      return {
        offset: zs(A, F),
        classesOn: Ue(H, w),
        classesOff: Ue(q, w)
      };
    };
    return {
      southeast: () => T(-t, a, [
        "top",
        "alignLeft"
      ]),
      southwest: () => T(t, a, [
        "top",
        "alignRight"
      ]),
      south: () => T(-t / 2, a, [
        "top",
        "alignCentre"
      ]),
      northeast: () => T(-t, -a, [
        "bottom",
        "alignLeft"
      ]),
      northwest: () => T(t, -a, [
        "bottom",
        "alignRight"
      ]),
      north: () => T(-t / 2, -a, [
        "bottom",
        "alignCentre"
      ]),
      east: () => T(t, -a / 2, [
        "valignCentre",
        "left"
      ]),
      west: () => T(-t, -a / 2, [
        "valignCentre",
        "right"
      ]),
      insetNortheast: () => T(g, x, [
        "top",
        "alignLeft",
        "inset"
      ]),
      insetNorthwest: () => T(-g, x, [
        "top",
        "alignRight",
        "inset"
      ]),
      insetNorth: () => T(-g / 2, x, [
        "top",
        "alignCentre",
        "inset"
      ]),
      insetSoutheast: () => T(g, -x, [
        "bottom",
        "alignLeft",
        "inset"
      ]),
      insetSouthwest: () => T(-g, -x, [
        "bottom",
        "alignRight",
        "inset"
      ]),
      insetSouth: () => T(-g / 2, -x, [
        "bottom",
        "alignCentre",
        "inset"
      ]),
      insetEast: () => T(-g, -x / 2, [
        "valignCentre",
        "right",
        "inset"
      ]),
      insetWest: () => T(g, -x / 2, [
        "valignCentre",
        "left",
        "inset"
      ])
    };
  }, by = () => _d(0, 0, {}), vy = lt, yy = (t, a) => (c) => cc(c) === "rtl" ? a : t, cc = (t) => fs(t, "direction") === "rtl" ? "rtl" : "ltr";
  var zp;
  (function(t) {
    t.TopToBottom = "toptobottom", t.BottomToTop = "bottomtotop";
  })(zp || (zp = {}));
  const Vp = "data-alloy-vertical-dir", j4 = (t) => b2(t, (a) => ko(a) && os(a, "data-alloy-vertical-dir") === zp.BottomToTop), jp = () => Es("layouts", [
    Rt("onLtr"),
    Rt("onRtl"),
    jr("onBottomLtr"),
    jr("onBottomRtl")
  ]), o1 = (t, a, c, f, g, x, w) => {
    const T = w.map(j4).getOr(!1), A = a.layouts.map((ie) => ie.onLtr(t)), F = a.layouts.map((ie) => ie.onRtl(t)), H = T ? a.layouts.bind((ie) => ie.onBottomLtr.map((fe) => fe(t))).or(A).getOr(g) : A.getOr(c), q = T ? a.layouts.bind((ie) => ie.onBottomRtl.map((fe) => fe(t))).or(F).getOr(x) : F.getOr(f);
    return yy(H, q)(t);
  }, U4 = (t, a, c) => {
    const f = a.hotspot, g = ag(c, f.element), x = o1(t.element, a, uy(), rg(), D_(), cy(), B.some(a.hotspot.element));
    return B.some(vy({
      anchorBox: g,
      bubble: a.bubble.getOr(by()),
      overrides: a.overrides,
      layouts: x
    }));
  };
  var W4 = [
    Rt("hotspot"),
    jr("bubble"),
    Qe("overrides", {}),
    jp(),
    Ws("placement", U4)
  ];
  const q_ = (t, a, c) => {
    const f = D2(c, a.x, a.y), g = Is(f.left, f.top, a.width, a.height), x = o1(t.element, a, T2(), P_(), T2(), P_(), B.none());
    return B.some(vy({
      anchorBox: g,
      bubble: a.bubble,
      overrides: a.overrides,
      layouts: x
    }));
  };
  var xy = [
    Rt("x"),
    Rt("y"),
    Qe("height", 0),
    Qe("width", 0),
    Qe("bubble", by()),
    Qe("overrides", {}),
    jp(),
    Ws("placement", q_)
  ];
  const wy = Be.generate([
    { screen: ["point"] },
    {
      absolute: [
        "point",
        "scrollLeft",
        "scrollTop"
      ]
    }
  ]), Z4 = (t) => t.fold(lt, (a, c, f) => a.translate(-c, -f)), r1 = (t) => t.fold(lt, lt), H2 = (t) => Mt(t, (a, c) => a.translate(c.left, c.top), zs(0, 0)), G4 = (t) => {
    const a = tt(t, Z4);
    return H2(a);
  }, z2 = (t) => {
    const a = tt(t, r1);
    return H2(a);
  }, V2 = wy.screen, Cy = wy.absolute, q4 = (t, a, c) => {
    const f = cl(c.root).dom, g = (x) => {
      const w = ii(x), T = ii(t.element);
      return Lr(w, T);
    };
    return B.from(f.frameElement).map(He.fromDom).filter(g).map(Ga);
  }, lg = (t, a, c) => {
    const f = ii(t.element), g = wi(f), x = q4(t, a, c).getOr(g);
    return Cy(x, g.left, g.top);
  }, K_ = (t, a, c, f) => {
    const g = V2(zs(t, a));
    return B.some(Mu(g, c, f));
  }, j2 = (t, a, c, f, g) => t.map((x) => {
    const w = [
      a,
      x.point
    ], T = N_(f, () => z2(w), () => z2(w), () => G4(w)), A = Mh(T.left, T.top, x.width, x.height), F = c.showAbove ? D_() : uy(), H = c.showAbove ? cy() : rg(), q = o1(g, c, F, H, F, H, B.none());
    return vy({
      anchorBox: A,
      bubble: c.bubble.getOr(by()),
      overrides: c.overrides,
      layouts: q
    });
  }), Y_ = (t, a, c) => {
    const f = lg(t, c, a);
    return a.node.filter(yr).bind((g) => {
      const x = g.dom.getBoundingClientRect(), w = K_(x.left, x.top, x.width, x.height), T = a.node.getOr(t.element);
      return j2(w, f, a, c, T);
    });
  };
  var Sy = [
    Rt("node"),
    Rt("root"),
    jr("bubble"),
    jp(),
    Qe("overrides", {}),
    Qe("showAbove", !1),
    Ws("placement", Y_)
  ];
  const K4 = "\uFEFF", Up = "", Tb = { create: (t, a, c, f) => ({
    start: t,
    soffset: a,
    finish: c,
    foffset: f
  }) }, ky = Be.generate([
    { before: ["element"] },
    {
      on: [
        "element",
        "offset"
      ]
    },
    { after: ["element"] }
  ]), Ob = (t, a, c, f) => t.fold(a, c, f), Ab = (t) => t.fold(lt, lt, lt), Y4 = ky.before, X_ = ky.on, X4 = ky.after, _y = {
    before: Y4,
    on: X_,
    after: X4,
    cata: Ob,
    getStart: Ab
  }, Mm = Be.generate([
    { domRange: ["rng"] },
    {
      relative: [
        "startSitu",
        "finishSitu"
      ]
    },
    {
      exact: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]), U2 = (t) => Mm.exact(t.start, t.soffset, t.finish, t.foffset), W2 = (t) => t.match({
    domRange: (a) => He.fromDom(a.startContainer),
    relative: (a, c) => _y.getStart(a),
    exact: (a, c, f, g) => a
  }), Q4 = Mm.domRange, Z2 = Mm.relative, Q_ = Mm.exact, J_ = (t) => {
    const a = W2(t);
    return cl(a);
  }, eE = Tb.create, Pb = {
    domRange: Q4,
    relative: Z2,
    exact: Q_,
    exactFromRange: U2,
    getWin: J_,
    range: eE
  }, Ey = (t, a) => {
    a.fold((c) => {
      t.setStartBefore(c.dom);
    }, (c, f) => {
      t.setStart(c.dom, f);
    }, (c) => {
      t.setStartAfter(c.dom);
    });
  }, cg = (t, a) => {
    a.fold((c) => {
      t.setEndBefore(c.dom);
    }, (c, f) => {
      t.setEnd(c.dom, f);
    }, (c) => {
      t.setEndAfter(c.dom);
    });
  }, Im = (t, a, c) => {
    const f = t.document.createRange();
    return Ey(f, a), cg(f, c), f;
  }, s1 = (t, a, c, f, g) => {
    const x = t.document.createRange();
    return x.setStart(a.dom, c), x.setEnd(f.dom, g), x;
  }, Db = (t) => ({
    left: t.left,
    top: t.top,
    right: t.right,
    bottom: t.bottom,
    width: t.width,
    height: t.height
  }), J4 = (t) => {
    const a = t.getClientRects(), c = a.length > 0 ? a[0] : t.getBoundingClientRect();
    return c.width > 0 || c.height > 0 ? B.some(c).map(Db) : B.none();
  }, df = (t) => {
    const a = t.getBoundingClientRect();
    return a.width > 0 || a.height > 0 ? B.some(a).map(Db) : B.none();
  }, pu = Be.generate([
    {
      ltr: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    },
    {
      rtl: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]), Ty = (t, a, c) => a(He.fromDom(c.startContainer), c.startOffset, He.fromDom(c.endContainer), c.endOffset), eP = (t, a) => a.match({
    domRange: (c) => ({
      ltr: te(c),
      rtl: B.none
    }),
    relative: (c, f) => ({
      ltr: Te(() => Im(t, c, f)),
      rtl: Te(() => B.some(Im(t, f, c)))
    }),
    exact: (c, f, g, x) => ({
      ltr: Te(() => s1(t, c, f, g, x)),
      rtl: Te(() => B.some(s1(t, g, x, c, f)))
    })
  }), gF = (t, a) => {
    const c = a.ltr();
    return c.collapsed ? a.rtl().filter((g) => g.collapsed === !1).map((g) => pu.rtl(He.fromDom(g.endContainer), g.endOffset, He.fromDom(g.startContainer), g.startOffset)).getOrThunk(() => Ty(t, pu.ltr, c)) : Ty(t, pu.ltr, c);
  }, ug = (t, a) => {
    const c = eP(t, a);
    return gF(t, c);
  }, Rb = (t, a) => ug(t, a).match({
    ltr: (f, g, x, w) => {
      const T = t.document.createRange();
      return T.setStart(f.dom, g), T.setEnd(x.dom, w), T;
    },
    rtl: (f, g, x, w) => {
      const T = t.document.createRange();
      return T.setStart(x.dom, w), T.setEnd(f.dom, g), T;
    }
  });
  pu.ltr, pu.rtl;
  const Nb = (t, a, c) => To(au(t, c), a), Dl = (t, a) => ai(a, t), Oy = (t, a, c, f) => {
    const x = ii(t).dom.createRange();
    return x.setStart(t.dom, a), x.setEnd(c.dom, f), x;
  }, dg = (t, a, c, f) => {
    const g = Oy(t, a, c, f), x = Lr(t, c) && a === f;
    return g.collapsed && !x;
  }, Ay = (t) => B.from(t.getSelection()), tE = (t) => {
    if (t.rangeCount > 0) {
      const a = t.getRangeAt(0), c = t.getRangeAt(t.rangeCount - 1);
      return B.some(Tb.create(He.fromDom(a.startContainer), a.startOffset, He.fromDom(c.endContainer), c.endOffset));
    } else
      return B.none();
  }, G2 = (t) => {
    if (t.anchorNode === null || t.focusNode === null)
      return tE(t);
    {
      const a = He.fromDom(t.anchorNode), c = He.fromDom(t.focusNode);
      return dg(a, t.anchorOffset, c, t.focusOffset) ? B.some(Tb.create(a, t.anchorOffset, c, t.focusOffset)) : tE(t);
    }
  }, Py = (t) => Ay(t).filter((a) => a.rangeCount > 0).bind(G2), Fi = (t, a) => {
    const c = Rb(t, a);
    return J4(c);
  }, Dy = (t, a) => {
    const c = Rb(t, a);
    return df(c);
  }, q2 = ((t, a) => {
    const c = (x) => {
      if (!t(x))
        throw new Error("Can only get " + a + " value of a " + a + " node");
      return f(x).getOr("");
    }, f = (x) => t(x) ? B.from(x.dom.nodeValue) : B.none();
    return {
      get: c,
      getOption: f,
      set: (x, w) => {
        if (!t(x))
          throw new Error("Can only set raw " + a + " value of a " + a + " node");
        x.dom.nodeValue = w;
      }
    };
  })(Yo, "text"), K2 = (t) => q2.get(t), Fm = (t, a) => ({
    element: t,
    offset: a
  }), nE = (t, a) => {
    const c = $a(t);
    if (c.length === 0)
      return Fm(t, a);
    if (a < c.length)
      return Fm(c[a], 0);
    {
      const f = c[c.length - 1], g = Yo(f) ? K2(f).length : $a(f).length;
      return Fm(f, g);
    }
  }, Wp = (t, a) => Yo(t) ? Fm(t, a) : nE(t, a), Ry = (t) => t.foffset !== void 0, Ny = (t, a) => a.getSelection.getOrThunk(() => () => Py(t))().map((f) => {
    if (Ry(f)) {
      const g = Wp(f.start, f.soffset), x = Wp(f.finish, f.foffset);
      return Pb.range(g.element, g.offset, x.element, x.offset);
    } else
      return f;
  }), Y2 = (t, a, c) => {
    const f = cl(a.root).dom, g = lg(t, c, a), x = Ny(f, a).bind((A) => {
      if (Ry(A))
        return Dy(f, Pb.exactFromRange(A)).orThunk(() => {
          const H = He.fromText(K4);
          Xl(A.start, H);
          const q = Fi(f, Pb.exact(H, 0, H, 1));
          return Sc(H), q;
        }).bind((H) => K_(H.left, H.top, H.width, H.height));
      {
        const F = kt(A, (q) => q.dom.getBoundingClientRect()), H = {
          left: Math.min(F.firstCell.left, F.lastCell.left),
          right: Math.max(F.firstCell.right, F.lastCell.right),
          top: Math.min(F.firstCell.top, F.lastCell.top),
          bottom: Math.max(F.firstCell.bottom, F.lastCell.bottom)
        };
        return K_(H.left, H.top, H.right - H.left, H.bottom - H.top);
      }
    }), T = Ny(f, a).bind((A) => Ry(A) ? ko(A.start) ? B.some(A.start) : Ui(A.start) : B.some(A.firstCell)).getOr(t.element);
    return j2(x, g, a, c, T);
  };
  var fg = [
    jr("getSelection"),
    Rt("root"),
    jr("bubble"),
    jp(),
    Qe("overrides", {}),
    Qe("showAbove", !1),
    Ws("placement", Y2)
  ];
  const Mb = "link-layout", pl = (t) => t.x + t.width, oE = (t, a) => t.x - a.width, X2 = (t, a) => t.y - a.height + t.height, Q2 = (t) => t.y, rE = (t, a, c) => Ji(pl(t), Q2(t), c.southeast(), kb(), "southeast", el(t, {
    left: 0,
    top: 2
  }), Mb), J2 = (t, a, c) => Ji(oE(t, a), Q2(t), c.southwest(), x2(), "southwest", el(t, {
    right: 1,
    top: 2
  }), Mb), sE = (t, a, c) => Ji(pl(t), X2(t, a), c.northeast(), w2(), "northeast", el(t, {
    left: 0,
    bottom: 3
  }), Mb), aE = (t, a, c) => Ji(oE(t, a), X2(t, a), c.northwest(), C2(), "northwest", el(t, {
    right: 1,
    bottom: 3
  }), Mb), hu = () => [
    rE,
    J2,
    sE,
    aE
  ], Bm = () => [
    J2,
    rE,
    aE,
    sE
  ], iE = (t, a, c) => {
    const f = ag(c, a.item.element), g = o1(t.element, a, hu(), Bm(), hu(), Bm(), B.none());
    return B.some(vy({
      anchorBox: f,
      bubble: by(),
      overrides: a.overrides,
      layouts: g
    }));
  };
  var mg = [
    Rt("item"),
    jp(),
    Qe("overrides", {}),
    Ws("placement", iE)
  ], Hl = ci("type", {
    selection: fg,
    node: Sy,
    hotspot: W4,
    submenu: mg,
    makeshift: xy
  });
  const Xc = [
    Ec("classes", On),
    fu("mode", "all", [
      "all",
      "layout",
      "placement"
    ])
  ], zl = [
    Qe("useFixed", wt),
    jr("getBounds")
  ], gu = [
    Vr("anchor", Hl),
    Es("transition", Xc)
  ], My = () => {
    const t = document.documentElement;
    return e1(0, 0, t.clientWidth, t.clientHeight);
  }, bu = (t) => {
    const a = Ga(t.element), c = t.element.dom.getBoundingClientRect();
    return M_(a.left, a.top, c.width, c.height);
  }, pg = (t, a, c, f, g, x) => {
    const w = R2(a.anchorBox, t);
    return z4(w, f.element, a.bubble, a.layouts, g, c, a.overrides, x);
  }, tP = (t, a, c, f, g) => {
    const x = B.none();
    lE(t, a, c, f, g, x);
  }, lE = (t, a, c, f, g, x) => {
    const w = El("placement.info", wo(gu), g), T = w.anchor, A = f.element, F = c.get(f.uid);
    Hp(() => {
      Ln(A, "position", "fixed");
      const H = ks(A, "visibility");
      Ln(A, "visibility", "hidden");
      const q = a.useFixed() ? My() : bu(t);
      T.placement(t, T, q).each((ne) => {
        const ie = x.orThunk(() => a.getBounds.map(dn)), fe = pg(q, ne, ie, f, F, w.transition);
        c.set(f.uid, fe);
      }), H.fold(() => {
        xr(A, "visibility");
      }, (ne) => {
        Ln(A, "visibility", ne);
      }), ks(A, "left").isNone() && ks(A, "top").isNone() && ks(A, "right").isNone() && ks(A, "bottom").isNone() && ra(ks(A, "position"), "fixed") && xr(A, "position");
    }, A);
  };
  var uE = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    position: tP,
    positionWithinBounds: lE,
    getMode: (t, a, c) => a.useFixed() ? "fixed" : "absolute",
    reset: (t, a, c, f) => {
      const g = f.element;
      mt([
        "position",
        "left",
        "right",
        "top",
        "bottom"
      ], (x) => xr(g, x)), I4(g), c.clear(f.uid);
    }
  }), tC = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      let t = {};
      return Wc({
        readState: () => t,
        clear: (g) => {
          Ce(g) ? delete t[g] : t = {};
        },
        set: (g, x) => {
          t[g] = x;
        },
        get: (g) => Ht(t, g)
      });
    }
  });
  const tl = Xi({
    fields: zl,
    name: "positioning",
    active: M4,
    apis: uE,
    state: tC
  }), nC = (t) => t.getSystem().isConnected(), Zp = (t) => {
    tr(t, Vu());
    const a = t.components();
    mt(a, Zp);
  }, Ib = (t) => {
    const a = t.components();
    mt(a, Ib), tr(t, oc());
  }, oC = (t, a) => {
    t.getSystem().addToWorld(a), yr(t.element) && Ib(a);
  }, Iy = (t) => {
    Zp(t), t.getSystem().removeFromWorld(t);
  }, a1 = (t, a) => {
    qi(t.element, a.element);
  }, rC = (t) => {
    mt(t.components(), (a) => Sc(a.element)), Df(t.element), t.syncComponents();
  }, Fb = (t, a, c) => {
    const f = t.components();
    rC(t);
    const g = c(a), x = xn(f, g);
    mt(x, (w) => {
      Zp(w), t.getSystem().removeFromWorld(w);
    }), mt(g, (w) => {
      nC(w) ? a1(t, w) : (t.getSystem().addToWorld(w), a1(t, w), yr(t.element) && Ib(w));
    }), t.syncComponents();
  }, sC = (t, a, c) => {
    const f = t.components(), g = Ue(a, (T) => u_(T).toArray());
    mt(f, (T) => {
      jt(g, T) || Iy(T);
    });
    const x = c(a), w = xn(f, x);
    mt(w, (T) => {
      nC(T) && Iy(T);
    }), mt(x, (T) => {
      nC(T) || oC(t, T);
    }), t.syncComponents();
  }, Gf = (t, a) => {
    hg(t, a, qi);
  }, hg = (t, a, c) => {
    t.getSystem().addToWorld(a), c(t.element, a.element), yr(t.element) && Ib(a), t.syncComponents();
  }, dE = (t) => {
    Zp(t), Sc(t.element), t.getSystem().removeFromWorld(t);
  }, $m = (t) => {
    const a = Za(t.element).bind((c) => t.getSystem().getByDom(c).toOptional());
    dE(t), a.each((c) => {
      c.syncComponents();
    });
  }, vu = (t) => {
    const a = t.components();
    mt(a, dE), Df(t.element), t.syncComponents();
  }, fE = (t, a) => {
    gg(t, a, qi);
  }, qf = (t, a) => {
    gg(t, a, $c);
  }, gg = (t, a, c) => {
    c(t, a.element);
    const f = $a(a.element);
    mt(f, (g) => {
      a.getByDom(g).each(Ib);
    });
  }, aC = (t) => {
    const a = $a(t.element);
    mt(a, (c) => {
      t.getByDom(c).each(Zp);
    }), Sc(t.element);
  }, Fy = (t, a, c, f) => {
    c.get().each((w) => {
      vu(t);
    });
    const g = a.getAttachPoint(t);
    Gf(g, t);
    const x = t.getSystem().build(f);
    return Gf(t, x), c.set(x), x;
  }, mE = (t, a, c, f) => {
    const g = Fy(t, a, c, f);
    return a.onOpen(t, g), g;
  }, oP = (t, a, c, f) => c.get().map(() => Fy(t, a, c, f)), rP = (t, a, c, f, g) => {
    $b(t, a), mE(t, a, c, f), g(), By(t, a);
  }, pE = (t, a, c) => {
    c.get().each((f) => {
      vu(t), $m(t), a.onClose(t, f), c.clear();
    });
  }, Gp = (t, a, c) => c.isOpen(), Bb = (t, a, c, f) => Gp(t, a, c) && c.get().exists((g) => a.isPartOf(t, g, f)), i1 = (t, a, c) => c.get(), sP = (t, a, c, f) => {
    ks(t.element, a).fold(() => {
      Ee(t.element, c);
    }, (g) => {
      rn(t.element, c, g);
    }), Ln(t.element, a, f);
  }, aP = (t, a, c) => {
    K(t.element, c).fold(() => xr(t.element, a), (f) => Ln(t.element, a, f));
  }, $b = (t, a, c) => {
    const f = a.getAttachPoint(t);
    Ln(t.element, "position", tl.getMode(f)), sP(t, "visibility", a.cloakVisibilityAttr, "hidden");
  }, iC = (t) => Fn([
    "top",
    "left",
    "right",
    "bottom"
  ], (a) => ks(t, a).isSome()), By = (t, a, c) => {
    iC(t.element) || xr(t.element, "position"), aP(t, "visibility", a.cloakVisibilityAttr);
  };
  var lC = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    cloak: $b,
    decloak: By,
    open: mE,
    openWhileCloaked: rP,
    close: pE,
    isOpen: Gp,
    isPartOf: Bb,
    getState: i1,
    setContent: oP
  }), Lb = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, a) => js([It(Rv(), (c, f) => {
      pE(c, t, a);
    })])
  }), uC = [
    Rr("onOpen"),
    Rr("onClose"),
    Rt("isPartOf"),
    Rt("getAttachPoint"),
    Qe("cloakVisibilityAttr", "data-precloak-visibility")
  ], dC = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = ms(), a = te("not-implemented");
      return Wc({
        readState: a,
        isOpen: t.isSet,
        clear: t.clear,
        set: t.set,
        get: t.get
      });
    }
  });
  const Br = Xi({
    fields: uC,
    name: "sandboxing",
    active: Lb,
    apis: lC,
    state: dC
  }), Kf = te("dismiss.popups"), bg = te("reposition.popups"), l1 = te("mouse.released"), fC = Ni([
    Qe("isExtraPart", wt),
    Es("fireEventInstead", [Qe("event", _p())])
  ]), Lm = (t) => {
    const a = El("Dismissal", fC, t);
    return {
      [Kf()]: {
        schema: Ni([Rt("target")]),
        onReceive: (c, f) => {
          Br.isOpen(c) && (Br.isPartOf(c, f.target) || a.isExtraPart(c, f.target) || a.fireEventInstead.fold(() => Br.close(c), (x) => tr(c, x.event)));
        }
      }
    };
  }, mC = Ni([
    Es("fireEventInstead", [Qe("event", $w())]),
    _c("doReposition")
  ]), $y = (t) => {
    const a = El("Reposition", mC, t);
    return {
      [bg()]: {
        onReceive: (c) => {
          Br.isOpen(c) && a.fireEventInstead.fold(() => a.doReposition(c), (f) => tr(c, f.event));
        }
      }
    };
  }, pC = (t, a, c) => {
    a.store.manager.onLoad(t, a, c);
  }, hC = (t, a, c) => {
    a.store.manager.onUnload(t, a, c);
  };
  var Hy = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    onLoad: pC,
    onUnload: hC,
    setValue: (t, a, c, f) => {
      a.store.manager.setValue(t, a, c, f);
    },
    getValue: (t, a, c) => a.store.manager.getValue(t, a, c),
    getState: (t, a, c) => c
  }), zb = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, a) => {
      const c = t.resetOnDom ? [
        Qs((f, g) => {
          pC(f, t, a);
        }),
        zf((f, g) => {
          hC(f, t, a);
        })
      ] : [Ww(t, a, pC)];
      return js(c);
    }
  });
  const zy = () => {
    const t = no(null), a = () => ({
      mode: "memory",
      value: t.get()
    }), c = () => t.get() === null, f = () => {
      t.set(null);
    };
    return Wc({
      set: t.set,
      get: t.get,
      isNotSet: c,
      clear: f,
      readState: a
    });
  }, iP = () => Wc({ readState: G }), Vy = () => {
    const t = no({}), a = no({});
    return Wc({
      readState: () => ({
        mode: "dataset",
        dataByValue: t.get(),
        dataByText: a.get()
      }),
      lookup: (w) => Ht(t.get(), w).orThunk(() => Ht(a.get(), w)),
      update: (w) => {
        const T = t.get(), A = a.get(), F = {}, H = {};
        mt(w, (q) => {
          F[q.value] = q, Ht(q, "meta").each((ne) => {
            Ht(ne, "text").each((ie) => {
              H[ie] = q;
            });
          });
        }), t.set({
          ...T,
          ...F
        }), a.set({
          ...A,
          ...H
        });
      },
      clear: () => {
        t.set({}), a.set({});
      }
    });
  };
  var lP = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    memory: zy,
    dataset: Vy,
    manual: iP,
    init: (t) => t.store.manager.state(t)
  });
  const c1 = (t, a, c, f) => {
    const g = a.store;
    c.update([f]), g.setValue(t, f), a.onSetValue(t, f);
  }, Wu = (t, a, c) => {
    const f = a.store, g = f.getDataKey(t);
    return c.lookup(g).getOrThunk(() => f.getFallbackEntry(g));
  }, Bi = (t, a, c) => {
    a.store.initialValue.each((g) => {
      c1(t, a, c, g);
    });
  }, cP = (t, a, c) => {
    c.clear();
  };
  var ff = [
    jr("initialValue"),
    Rt("getFallbackEntry"),
    Rt("getDataKey"),
    Rt("setValue"),
    Ws("manager", {
      setValue: c1,
      getValue: Wu,
      onLoad: Bi,
      onUnload: cP,
      state: Vy
    })
  ];
  const uP = (t, a, c) => a.store.getValue(t), gE = (t, a, c, f) => {
    a.store.setValue(t, f), a.onSetValue(t, f);
  }, u1 = (t, a, c) => {
    a.store.initialValue.each((f) => {
      a.store.setValue(t, f);
    });
  };
  var Vb = [
    Rt("getValue"),
    Qe("setValue", G),
    jr("initialValue"),
    Ws("manager", {
      setValue: gE,
      getValue: uP,
      onLoad: u1,
      onUnload: G,
      state: Bl.init
    })
  ];
  const bE = (t, a, c, f) => {
    c.set(f), a.onSetValue(t, f);
  }, vE = (t, a, c) => c.get(), bF = (t, a, c) => {
    a.store.initialValue.each((f) => {
      c.isNotSet() && c.set(f);
    });
  }, vF = (t, a, c) => {
    c.clear();
  };
  var yE = [
    jr("initialValue"),
    Ws("manager", {
      setValue: bE,
      getValue: vE,
      onLoad: bF,
      onUnload: vF,
      state: zy
    })
  ], xE = [
    Vc("store", { mode: "memory" }, ci("mode", {
      memory: yE,
      manual: Vb,
      dataset: ff
    })),
    Rr("onSetValue"),
    Qe("resetOnDom", !1)
  ];
  const Mn = Xi({
    fields: xE,
    name: "representing",
    active: zb,
    apis: Hy,
    extra: {
      setValueFrom: (t, a) => {
        const c = Mn.getValue(a);
        Mn.setValue(t, c);
      }
    },
    state: lP
  }), $i = (t, a) => ee(t, {}, tt(a, (c) => Mw(c.name(), "Cannot configure " + c.name() + " for " + t)).concat([Wr("dump", lt)])), d1 = (t) => t.dump, Li = (t, a) => ({
    ...Qt(a),
    ...t.dump
  }), Zu = {
    field: $i,
    augment: Li,
    get: d1
  }, gC = "placeholder", xg = Be.generate([
    {
      single: [
        "required",
        "valueThunk"
      ]
    },
    {
      multiple: [
        "required",
        "valueThunks"
      ]
    }
  ]), jy = (t) => Ho(t, "uiType"), qp = (t, a, c, f) => t.exists((g) => g !== c.owner) ? xg.single(!0, te(c)) : Ht(f, c.name).fold(() => {
    throw new Error("Unknown placeholder component: " + c.name + `
Known: [` + Qo(f) + `]
Namespace: ` + t.getOr("none") + `
Spec: ` + JSON.stringify(c, null, 2));
  }, (g) => g.replace()), f1 = (t, a, c, f) => jy(c) && c.uiType === gC ? qp(t, a, c, f) : xg.single(!1, te(c)), wE = (t, a, c, f) => f1(t, a, c, f).fold((x, w) => {
    const T = jy(c) ? w(a, c.config, c.validated) : w(a), A = Ht(T, "components").getOr([]), F = Ue(A, (H) => wE(t, a, H, f));
    return [{
      ...T,
      components: F
    }];
  }, (x, w) => {
    if (jy(c)) {
      const T = w(a, c.config, c.validated);
      return c.validated.preprocess.getOr(lt)(T);
    } else
      return w(a);
  }), dP = (t, a, c, f) => Ue(c, (g) => wE(t, a, g, f)), fP = (t, a) => {
    let c = !1;
    const f = () => c, g = () => {
      if (c)
        throw new Error("Trying to use the same placeholder more than once: " + t);
      return c = !0, a;
    }, x = () => a.fold((w, T) => w, (w, T) => w);
    return {
      name: te(t),
      required: x,
      used: f,
      replace: g
    };
  }, mP = (t, a, c, f) => {
    const g = kt(f, (w, T) => fP(T, w)), x = dP(t, a, c, g);
    return at(g, (w) => {
      if (w.used() === !1 && w.required())
        throw new Error("Placeholder: " + w.name() + ` was not found in components list
Namespace: ` + t.getOr("none") + `
Components: ` + JSON.stringify(a.components, null, 2));
    }), x;
  }, Kp = xg.single, m1 = xg.multiple, p1 = te(gC), Uy = Be.generate([
    { required: ["data"] },
    { external: ["data"] },
    { optional: ["data"] },
    { group: ["data"] }
  ]), Qc = Qe("factory", { sketch: lt }), Yf = Qe("schema", []), Yp = Rt("name"), Xp = Qa("pname", "pname", dr((t) => "<alloy." + Nn(t.name) + ">"), uu()), pP = Wr("schema", () => [jr("preprocess")]), Wy = Qe("defaults", te({})), Zy = Qe("overrides", te({})), hP = wo([
    Qc,
    Yf,
    Yp,
    Xp,
    Wy,
    Zy
  ]), gP = wo([
    Qc,
    Yf,
    Yp,
    Wy,
    Zy
  ]), bP = wo([
    Qc,
    Yf,
    Yp,
    Xp,
    Wy,
    Zy
  ]), vP = wo([
    Qc,
    pP,
    Yp,
    Rt("unit"),
    Xp,
    Wy,
    Zy
  ]), CE = (t) => t.fold(B.some, B.none, B.some, B.some), Gy = (t) => {
    const a = (c) => c.name;
    return t.fold(a, a, a, a);
  }, yP = (t) => t.fold(lt, lt, lt, lt), qy = (t, a) => (c) => {
    const f = El("Converting part type", a, c);
    return t(f);
  }, hl = qy(Uy.required, hP), Gu = qy(Uy.external, gP), yu = qy(Uy.optional, bP), Ky = qy(Uy.group, vP), Yy = te("entirety");
  var SE = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    required: hl,
    external: Gu,
    optional: yu,
    group: Ky,
    asNamedPart: CE,
    name: Gy,
    asCommon: yP,
    original: Yy
  });
  const bC = (t, a, c, f) => Fs(a.defaults(t, c, f), c, { uid: t.partUids[a.name] }, a.overrides(t, c, f)), kE = (t, a, c) => {
    const f = {}, g = {};
    return mt(c, (x) => {
      x.fold((w) => {
        f[w.pname] = Kp(!0, (T, A, F) => w.factory.sketch(bC(T, w, A, F)));
      }, (w) => {
        const T = a.parts[w.name];
        g[w.name] = te(w.factory.sketch(bC(a, w, T[Yy()]), T));
      }, (w) => {
        f[w.pname] = Kp(!1, (T, A, F) => w.factory.sketch(bC(T, w, A, F)));
      }, (w) => {
        f[w.pname] = m1(!0, (T, A, F) => {
          const H = T[w.name];
          return tt(H, (q) => w.factory.sketch(Fs(w.defaults(T, q, F), q, w.overrides(T, q))));
        });
      });
    }), {
      internals: te(f),
      externals: te(g)
    };
  }, vC = (t, a) => {
    const c = {};
    return mt(a, (f) => {
      CE(f).each((g) => {
        const x = _E(t, g.pname);
        c[g.name] = (w) => {
          const T = El("Part: " + g.name + " in " + t, wo(g.schema), w);
          return {
            ...x,
            config: w,
            validated: T
          };
        };
      });
    }), c;
  }, _E = (t, a) => ({
    uiType: p1(),
    owner: t,
    name: a
  }), EE = (t, a, c) => ({
    uiType: p1(),
    owner: t,
    name: a,
    config: c,
    validated: {}
  }), xP = (t) => Ue(t, (a) => a.fold(B.none, B.some, B.none, B.none).map((c) => Yd(c.name, c.schema.concat([i_(Yy())]))).toArray()), wP = (t) => tt(t, Gy), Xy = (t, a, c) => kE(t, a, c), yC = (t, a, c) => mP(B.some(t), a, a.components, c), Xt = (t, a, c) => {
    const f = a.partUids[c];
    return t.getSystem().getByUid(f).toOptional();
  }, uc = (t, a, c) => Xt(t, a, c).getOrDie("Could not find part: " + c), TE = (t, a, c) => {
    const f = {}, g = a.partUids, x = t.getSystem();
    return mt(c, (w) => {
      f[w] = te(x.getByUid(g[w]));
    }), f;
  }, xC = (t, a) => {
    const c = t.getSystem();
    return kt(a.partUids, (f, g) => te(c.getByUid(f)));
  }, h1 = (t) => Qo(t.partUids), g1 = (t, a, c) => {
    const f = {}, g = a.partUids, x = t.getSystem();
    return mt(c, (w) => {
      f[w] = te(x.getByUid(g[w]).getOrDie());
    }), f;
  }, Qy = (t, a) => {
    const c = wP(a);
    return Zr(tt(c, (f) => ({
      key: f,
      value: t + "-" + f
    })));
  }, b1 = (t) => Qa("partUids", "partUids", gp((a) => Qy(a.uid, t)), uu());
  var OE = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    generate: vC,
    generateOne: EE,
    schemas: xP,
    names: wP,
    substitutes: Xy,
    components: yC,
    defaultUids: Qy,
    defaultUidsSchema: b1,
    getAllParts: xC,
    getAllPartNames: h1,
    getPart: Xt,
    getPartOrDie: uc,
    getParts: TE,
    getPartsOrDie: g1
  });
  const AE = (t, a) => (t.length > 0 ? [Yd("parts", t)] : []).concat([
    Rt("uid"),
    Qe("dom", {}),
    Qe("components", []),
    i_("originalSpec"),
    Qe("debug.sketcher", {})
  ]).concat(a), wC = (t, a, c, f, g) => {
    const x = AE(f, g);
    return El(t + " [SpecSchema]", Ni(x.concat(a)), c);
  }, CC = (t, a, c, f) => {
    const g = PE(f), x = wC(t, a, g, [], []);
    return c(x, g);
  }, zm = (t, a, c, f, g) => {
    const x = PE(g), w = xP(c), T = b1(c), A = wC(t, a, x, w, [T]), F = Xy(t, A, c), H = yC(t, A, F.internals());
    return f(A, H, x, F.externals());
  }, SC = (t) => Ho(t, "uid"), PE = (t) => SC(t) ? t : {
    ...t,
    uid: ng("uid")
  }, CP = (t) => t.uid !== void 0, SP = Ni([
    Rt("name"),
    Rt("factory"),
    Rt("configFields"),
    Qe("apis", {}),
    Qe("extraApis", {})
  ]), DE = Ni([
    Rt("name"),
    Rt("factory"),
    Rt("configFields"),
    Rt("partFields"),
    Qe("apis", {}),
    Qe("extraApis", {})
  ]), Pc = (t) => {
    const a = El("Sketcher for " + t.name, SP, t), c = (x) => CC(a.name, a.configFields, a.factory, x), f = kt(a.apis, wb), g = kt(a.extraApis, (x, w) => lb(x, w));
    return {
      name: a.name,
      configFields: a.configFields,
      sketch: c,
      ...f,
      ...g
    };
  }, Vl = (t) => {
    const a = El("Sketcher for " + t.name, DE, t), c = (w) => zm(a.name, a.configFields, a.partFields, a.factory, w), f = vC(a.name, a.partFields), g = kt(a.apis, wb), x = kt(a.extraApis, (w, T) => lb(w, T));
    return {
      name: a.name,
      partFields: a.partFields,
      configFields: a.configFields,
      sketch: c,
      parts: f,
      ...g,
      ...x
    };
  }, jb = (t) => ua("input")(t) && os(t, "type") !== "radio" || ua("textarea")(t);
  var kP = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getCurrent: (t, a, c) => a.find(t)
  });
  const kC = [Rt("find")], Nr = Xi({
    fields: kC,
    name: "composing",
    apis: kP
  }), xF = [
    "input",
    "button",
    "textarea",
    "select"
  ], RE = (t, a, c) => {
    (a.disabled() ? Jy : y1)(t, a);
  }, NE = (t, a) => a.useNative === !0 && jt(xF, Kr(t.element)), wF = (t) => ge(t.element, "disabled"), Qp = (t) => {
    rn(t.element, "disabled", "disabled");
  }, v1 = (t) => {
    Ee(t.element, "disabled");
  }, _P = (t) => os(t.element, "aria-disabled") === "true", EP = (t) => {
    rn(t.element, "aria-disabled", "true");
  }, TP = (t) => {
    rn(t.element, "aria-disabled", "false");
  }, Jy = (t, a, c) => {
    a.disableClass.each((g) => {
      Us(t.element, g);
    }), (NE(t, a) ? Qp : EP)(t), a.onDisabled(t);
  }, y1 = (t, a, c) => {
    a.disableClass.each((g) => {
      va(t.element, g);
    }), (NE(t, a) ? v1 : TP)(t), a.onEnabled(t);
  }, ME = (t, a) => NE(t, a) ? wF(t) : _P(t);
  var Ub = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    enable: y1,
    disable: Jy,
    isDisabled: ME,
    onLoad: RE,
    set: (t, a, c, f) => {
      (f ? Jy : y1)(t, a);
    }
  }), IE = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, a) => Uc({ classes: a.disabled() ? a.disableClass.toArray() : [] }),
    events: (t, a) => js([
      Zk(zu(), (c, f) => ME(c, t)),
      Ww(t, a, RE)
    ])
  }), OP = [
    Ca("disabled", wt),
    Qe("useNative", !0),
    jr("disableClass"),
    Rr("onDisabled"),
    Rr("onEnabled")
  ];
  const _o = Xi({
    fields: OP,
    name: "disabling",
    active: IE,
    apis: Ub
  }), m = (t, a, c, f) => {
    const g = Dl(t.element, "." + a.highlightClass);
    mt(g, (x) => {
      Fn(f, (T) => Lr(T.element, x)) || (va(x, a.highlightClass), t.getSystem().getByDom(x).each((T) => {
        a.onDehighlight(t, T), tr(T, Wh());
      }));
    });
  }, b = (t, a, c) => m(t, a, c, []), C = (t, a, c, f) => {
    xe(t, a, c, f) && (va(f.element, a.highlightClass), a.onDehighlight(t, f), tr(f, Wh()));
  }, E = (t, a, c, f) => {
    m(t, a, c, [f]), xe(t, a, c, f) || (Us(f.element, a.highlightClass), a.onHighlight(t, f), tr(f, Ep()));
  }, N = (t, a, c) => {
    qt(t, a).each((f) => {
      E(t, a, c, f);
    });
  }, z = (t, a, c) => {
    _n(t, a).each((f) => {
      E(t, a, c, f);
    });
  }, X = (t, a, c, f) => {
    it(t, a, c, f).fold((g) => {
      throw g;
    }, (g) => {
      E(t, a, c, g);
    });
  }, ue = (t, a, c, f) => {
    const g = Ut(t, a);
    At(g, f).each((w) => {
      E(t, a, c, w);
    });
  }, xe = (t, a, c, f) => Zc(f.element, a.highlightClass), Fe = (t, a, c) => ss(t.element, "." + a.highlightClass).bind((f) => t.getSystem().getByDom(f).toOptional()), it = (t, a, c, f) => {
    const g = Dl(t.element, "." + a.itemClass);
    return B.from(g[f]).fold(() => zo.error(new Error("No element found with index " + f)), t.getSystem().getByDom);
  }, qt = (t, a, c) => ss(t.element, "." + a.itemClass).bind((f) => t.getSystem().getByDom(f).toOptional()), _n = (t, a, c) => {
    const f = Dl(t.element, "." + a.itemClass);
    return (f.length > 0 ? B.some(f[f.length - 1]) : B.none()).bind((x) => t.getSystem().getByDom(x).toOptional());
  }, bn = (t, a, c, f) => {
    const g = Dl(t.element, "." + a.itemClass);
    return $n(g, (w) => Zc(w, a.highlightClass)).bind((w) => {
      const T = _b(w, f, 0, g.length - 1);
      return t.getSystem().getByDom(g[T]).toOptional();
    });
  }, ln = (t, a, c) => bn(t, a, c, -1), Zn = (t, a, c) => bn(t, a, c, 1), Ut = (t, a, c) => {
    const f = Dl(t.element, "." + a.itemClass);
    return Ks(tt(f, (g) => t.getSystem().getByDom(g).toOptional()));
  };
  var un = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    dehighlightAll: b,
    dehighlight: C,
    highlight: E,
    highlightFirst: N,
    highlightLast: z,
    highlightAt: X,
    highlightBy: ue,
    isHighlighted: xe,
    getHighlighted: Fe,
    getFirst: qt,
    getLast: _n,
    getPrevious: ln,
    getNext: Zn,
    getCandidates: Ut
  }), Co = [
    Rt("highlightClass"),
    Rt("itemClass"),
    Rr("onHighlight"),
    Rr("onDehighlight")
  ];
  const wn = Xi({
    fields: Co,
    name: "highlighting",
    apis: un
  }), Xr = [8], ws = [9], ps = [13], nl = [27], ni = [32], Xf = [37], Jp = [38], eh = [39], as = [40], dc = (t, a, c) => {
    const f = mo(t.slice(0, a)), g = mo(t.slice(a + 1));
    return At(f.concat(g), c);
  }, fc = (t, a, c) => {
    const f = mo(t.slice(0, a));
    return At(f, c);
  }, qu = (t, a, c) => {
    const f = t.slice(0, a), g = t.slice(a + 1);
    return At(g.concat(f), c);
  }, Ku = (t, a, c) => {
    const f = t.slice(a + 1);
    return At(f, c);
  }, Cr = (t) => (a) => {
    const c = a.raw;
    return jt(t, c.which);
  }, Aa = (t) => (a) => jn(t, (c) => c(a)), Qf = (t) => t.raw.shiftKey === !0, x1 = (t) => t.raw.ctrlKey === !0, Jc = je(Qf), Vo = (t, a) => ({
    matches: t,
    classification: a
  }), EC = (t, a) => At(t, (f) => f.matches(a)).map((f) => f.classification), TC = (t, a, c) => {
    a.exists((g) => c.exists((x) => Lr(x, g))) || po(t, Uh(), {
      prevFocus: a,
      newFocus: c
    });
  }, ex = () => {
    const t = (c) => ic(c.element);
    return {
      get: t,
      set: (c, f) => {
        const g = t(c);
        c.getSystem().triggerFocus(f, c.element);
        const x = t(c);
        TC(c, g, x);
      }
    };
  }, FE = () => {
    const t = (c) => wn.getHighlighted(c).map((f) => f.element);
    return {
      get: t,
      set: (c, f) => {
        const g = t(c);
        c.getSystem().getByDom(f).fold(G, (w) => {
          wn.highlight(c, w);
        });
        const x = t(c);
        TC(c, g, x);
      }
    };
  };
  var wg;
  (function(t) {
    t.OnFocusMode = "onFocus", t.OnEnterOrSpaceMode = "onEnterOrSpace", t.OnApiMode = "onApi";
  })(wg || (wg = {}));
  const Vm = (t, a, c, f, g) => {
    const x = () => t.concat([
      Qe("focusManager", ex()),
      Vc("focusInside", "onFocus", Hh((F) => jt([
        "onFocus",
        "onEnterOrSpace",
        "onApi"
      ], F) ? zo.value(F) : zo.error("Invalid value for focusInside"))),
      Ws("handler", A),
      Ws("state", a),
      Ws("sendFocusIn", g)
    ]), w = (F, H, q, ne, ie) => {
      const fe = q(F, H, ne, ie);
      return EC(fe, H.event).bind((_e) => _e(F, H, ne, ie));
    }, A = {
      schema: x,
      processKey: w,
      toEvents: (F, H) => {
        const q = F.focusInside !== wg.OnFocusMode ? B.none() : g(F).map((fe) => It(Jd(), (_e, st) => {
          fe(_e, F, H), st.stop();
        })), ne = (fe, _e) => {
          const st = Cr(ni.concat(ps))(_e.event);
          F.focusInside === wg.OnEnterOrSpaceMode && st && Lu(fe, _e) && g(F).each((De) => {
            De(fe, F, H), _e.stop();
          });
        }, ie = [
          It(Cd(), (fe, _e) => {
            w(fe, _e, c, F, H).fold(() => {
              ne(fe, _e);
            }, (st) => {
              _e.stop();
            });
          }),
          It(Pv(), (fe, _e) => {
            w(fe, _e, f, F, H).each((st) => {
              _e.stop();
            });
          })
        ];
        return js(q.toArray().concat(ie));
      }
    };
    return A;
  }, BE = (t) => {
    const a = [
      jr("onEscape"),
      jr("onEnter"),
      Qe("selector", '[data-alloy-tabstop="true"]:not(:disabled)'),
      Qe("firstTabstop", 0),
      Qe("useTabstopAt", qe),
      jr("visibilitySelector")
    ].concat([t]), c = (De, Je) => {
      const Ge = De.visibilitySelector.bind((Ft) => cf(Je, Ft)).getOr(Je);
      return Bs(Ge) > 0;
    }, f = (De, Je) => {
      const Ge = Dl(De.element, Je.selector), Ft = To(Ge, (gt) => c(Je, gt));
      return B.from(Ft[Je.firstTabstop]);
    }, g = (De, Je) => Je.focusManager.get(De).bind((Ge) => cf(Ge, Je.selector)), x = (De, Je) => c(De, Je) && De.useTabstopAt(Je), w = (De, Je, Ge) => {
      f(De, Je).each((Ft) => {
        Je.focusManager.set(De, Ft);
      });
    }, T = (De, Je, Ge, Ft, gt) => gt(Je, Ge, (Jt) => x(Ft, Jt)).fold(() => Ft.cyclic ? B.some(!0) : B.none(), (Jt) => (Ft.focusManager.set(De, Jt), B.some(!0))), A = (De, Je, Ge, Ft) => {
      const gt = Dl(De.element, Ge.selector);
      return g(De, Ge).bind((Jt) => $n(gt, Kt(Lr, Jt)).bind((Nt) => T(De, gt, Nt, Ge, Ft)));
    }, F = (De, Je, Ge) => {
      const Ft = Ge.cyclic ? dc : fc;
      return A(De, Je, Ge, Ft);
    }, H = (De, Je, Ge) => {
      const Ft = Ge.cyclic ? qu : Ku;
      return A(De, Je, Ge, Ft);
    }, q = (De) => Ai(De).bind(Kl).exists((Je) => Lr(Je, De)), ne = (De, Je, Ge) => g(De, Ge).filter((Ft) => !Ge.useTabstopAt(Ft)).bind((Ft) => (q(Ft) ? F : H)(De, Je, Ge)), ie = (De, Je, Ge) => Ge.onEnter.bind((Ft) => Ft(De, Je)), fe = (De, Je, Ge) => Ge.onEscape.bind((Ft) => Ft(De, Je)), _e = te([
      Vo(Aa([
        Qf,
        Cr(ws)
      ]), F),
      Vo(Cr(ws), H),
      Vo(Aa([
        Jc,
        Cr(ps)
      ]), ie)
    ]), st = te([
      Vo(Cr(nl), fe),
      Vo(Cr(ws), ne)
    ]);
    return Vm(a, Bl.init, _e, st, () => B.some(w));
  };
  var w1 = BE(Wr("cyclic", wt)), zj = BE(Wr("cyclic", qe));
  const OC = (t, a, c) => (Iv(t, c, zu()), B.some(!0)), tx = (t, a, c) => jb(c) && Cr(ni)(a.event) ? B.none() : OC(t, a, c), C1 = (t, a) => B.some(!0), AP = [
    Qe("execute", tx),
    Qe("useSpace", !1),
    Qe("useEnter", !0),
    Qe("useControlEnter", !1),
    Qe("useDown", !1)
  ], kF = (t, a, c) => c.execute(t, a, t.element), _F = (t, a, c, f) => {
    const g = c.useSpace && !jb(t.element) ? ni : [], x = c.useEnter ? ps : [], w = c.useDown ? as : [], T = g.concat(x).concat(w);
    return [Vo(Cr(T), kF)].concat(c.useControlEnter ? [Vo(Aa([
      x1,
      Cr(ps)
    ]), kF)] : []);
  }, Vj = (t, a, c, f) => c.useSpace && !jb(t.element) ? [Vo(Cr(ni), C1)] : [];
  var EF = Vm(AP, Bl.init, _F, Vj, () => B.none());
  const PP = () => {
    const t = ms();
    return Wc({
      readState: () => t.get().map((g) => ({
        numRows: String(g.numRows),
        numColumns: String(g.numColumns)
      })).getOr({
        numRows: "?",
        numColumns: "?"
      }),
      setGridSize: (g, x) => {
        t.set({
          numRows: g,
          numColumns: x
        });
      },
      getNumRows: () => t.get().map((g) => g.numRows),
      getNumColumns: () => t.get().map((g) => g.numColumns)
    });
  };
  var jj = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    flatgrid: PP,
    init: (t) => t.state(t)
  });
  const TF = (t) => (a, c, f, g) => {
    const x = t(a.element);
    return AC(x, a, c, f, g);
  }, DP = (t, a) => {
    const c = yy(t, a);
    return TF(c);
  }, RP = (t, a) => {
    const c = yy(a, t);
    return TF(c);
  }, NP = (t) => (a, c, f, g) => AC(t, a, c, f, g), AC = (t, a, c, f, g) => f.focusManager.get(a).bind((w) => t(a.element, w, f, g)).map((w) => (f.focusManager.set(a, w), !0)), $E = NP, OF = NP, MP = NP, AF = (t) => t.offsetWidth <= 0 && t.offsetHeight <= 0, PF = (t) => !AF(t.dom), Uj = (t, a) => $n(t, a).map((c) => ({
    index: c,
    candidates: t
  })), Td = (t, a, c) => {
    const f = (w) => Lr(w, a), g = Dl(t, c), x = To(g, PF);
    return Uj(x, f);
  }, DF = (t, a) => $n(t, (c) => Lr(a, c)), RF = (t, a, c, f) => {
    const g = Math.floor(a / c), x = a % c;
    return f(g, x).bind((w) => {
      const T = w.row * c + w.column;
      return T >= 0 && T < t.length ? B.some(t[T]) : B.none();
    });
  }, NF = (t, a, c, f, g) => RF(t, a, f, (x, w) => {
    const A = x === c - 1 ? t.length - x * f : f, F = _b(w, g, 0, A - 1);
    return B.some({
      row: x,
      column: F
    });
  }), MF = (t, a, c, f, g) => RF(t, a, f, (x, w) => {
    const T = _b(x, g, 0, c - 1), F = T === c - 1 ? t.length - T * f : f, H = kd(w, 0, F - 1);
    return B.some({
      row: T,
      column: H
    });
  }), Wj = (t, a, c, f) => NF(t, a, c, f, 1), nx = (t, a, c, f) => NF(t, a, c, f, -1), IP = (t, a, c, f) => MF(t, a, c, f, -1), Zj = (t, a, c, f) => MF(t, a, c, f, 1), FP = [
    Rt("selector"),
    Qe("execute", tx),
    sc("onEscape"),
    Qe("captureTab", !1),
    K0()
  ], LE = (t, a, c) => {
    ss(t.element, a.selector).each((f) => {
      a.focusManager.set(t, f);
    });
  }, BP = (t, a) => a.focusManager.get(t).bind((c) => cf(c, a.selector)), Gj = (t, a, c, f) => BP(t, c).bind((g) => c.execute(t, a, g)), HE = (t) => (a, c, f, g) => Td(a, c, f.selector).bind((x) => t(x.candidates, x.index, g.getNumRows().getOr(f.initSize.numRows), g.getNumColumns().getOr(f.initSize.numColumns))), IF = (t, a, c) => c.captureTab ? B.some(!0) : B.none(), qj = (t, a, c) => c.onEscape(t, a), FF = HE(nx), BF = HE(Wj), $F = HE(IP), $P = HE(Zj), Kj = te([
    Vo(Cr(Xf), DP(FF, BF)),
    Vo(Cr(eh), RP(FF, BF)),
    Vo(Cr(Jp), $E($F)),
    Vo(Cr(as), OF($P)),
    Vo(Aa([
      Qf,
      Cr(ws)
    ]), IF),
    Vo(Aa([
      Jc,
      Cr(ws)
    ]), IF),
    Vo(Cr(ni.concat(ps)), Gj)
  ]), Yj = te([
    Vo(Cr(nl), qj),
    Vo(Cr(ni), C1)
  ]);
  var Xj = Vm(FP, PP, Kj, Yj, () => B.some(LE));
  const LF = (t, a, c, f, g) => {
    const x = (T) => Kr(T) === "button" && os(T, "disabled") === "disabled", w = (T, A, F) => g(T, A, f, 0, F.length - 1, F[A], (H) => x(F[H]) ? w(T, H, F) : B.from(F[H]));
    return Td(t, c, a).bind((T) => {
      const A = T.index, F = T.candidates;
      return w(A, A, F);
    });
  }, S1 = (t, a, c, f) => LF(t, a, c, f, (g, x, w, T, A, F, H) => {
    const q = kd(x + w, T, A);
    return q === g ? B.from(F) : H(q);
  }), PC = (t, a, c, f) => LF(t, a, c, f, (g, x, w, T, A, F, H) => {
    const q = _b(x, w, T, A);
    return q === g ? B.none() : H(q);
  }), Qj = [
    Rt("selector"),
    Qe("getInitial", B.none),
    Qe("execute", tx),
    sc("onEscape"),
    Qe("executeOnMove", !1),
    Qe("allowVertical", !0),
    Qe("allowHorizontal", !0),
    Qe("cycles", !0)
  ], LP = (t, a) => a.focusManager.get(t).bind((c) => cf(c, a.selector)), HP = (t, a, c) => LP(t, c).bind((f) => c.execute(t, a, f)), HF = (t, a, c) => {
    a.getInitial(t).orThunk(() => ss(t.element, a.selector)).each((f) => {
      a.focusManager.set(t, f);
    });
  }, zP = (t, a, c) => (c.cycles ? PC : S1)(t, c.selector, a, -1), VP = (t, a, c) => (c.cycles ? PC : S1)(t, c.selector, a, 1), jP = (t) => (a, c, f, g) => t(a, c, f, g).bind(() => f.executeOnMove ? HP(a, c, f) : B.some(!0)), zF = (t, a, c) => c.onEscape(t, a), Jj = (t, a, c, f) => {
    const g = [...c.allowHorizontal ? Xf : []].concat(c.allowVertical ? Jp : []), x = [...c.allowHorizontal ? eh : []].concat(c.allowVertical ? as : []);
    return [
      Vo(Cr(g), jP(DP(zP, VP))),
      Vo(Cr(x), jP(RP(zP, VP))),
      Vo(Cr(ps), HP),
      Vo(Cr(ni), HP)
    ];
  }, eU = te([
    Vo(Cr(ni), C1),
    Vo(Cr(nl), zF)
  ]);
  var tU = Vm(Qj, Bl.init, Jj, eU, () => B.some(HF));
  const ox = (t, a, c) => B.from(t[a]).bind((f) => B.from(f[c]).map((g) => ({
    rowIndex: a,
    columnIndex: c,
    cell: g
  }))), VF = (t, a, c, f) => {
    const x = t[a].length, w = _b(c, f, 0, x - 1);
    return ox(t, a, w);
  }, DC = (t, a, c, f) => {
    const g = _b(c, f, 0, t.length - 1), x = t[g].length, w = kd(a, 0, x - 1);
    return ox(t, g, w);
  }, jF = (t, a, c, f) => {
    const x = t[a].length, w = kd(c + f, 0, x - 1);
    return ox(t, a, w);
  }, UP = (t, a, c, f) => {
    const g = kd(c + f, 0, t.length - 1), x = t[g].length, w = kd(a, 0, x - 1);
    return ox(t, g, w);
  }, eu = (t, a, c) => VF(t, a, c, 1), nU = (t, a, c) => VF(t, a, c, -1), UF = (t, a, c) => DC(t, c, a, -1), WF = (t, a, c) => DC(t, c, a, 1), oU = (t, a, c) => jF(t, a, c, -1), ZF = (t, a, c) => jF(t, a, c, 1), GF = (t, a, c) => UP(t, c, a, -1), rU = (t, a, c) => UP(t, c, a, 1), sU = [
    Yd("selectors", [
      Rt("row"),
      Rt("cell")
    ]),
    Qe("cycles", !0),
    Qe("previousSelector", B.none),
    Qe("execute", tx)
  ], aU = (t, a, c) => {
    a.previousSelector(t).orThunk(() => {
      const g = a.selectors;
      return ss(t.element, g.cell);
    }).each((g) => {
      a.focusManager.set(t, g);
    });
  }, iU = (t, a, c) => ic(t.element).bind((f) => c.execute(t, a, f)), qF = (t, a) => tt(t, (c) => Dl(c, a.selectors.cell)), zE = (t, a) => (c, f, g) => {
    const x = g.cycles ? t : a;
    return cf(f, g.selectors.row).bind((w) => {
      const T = Dl(w, g.selectors.cell);
      return DF(T, f).bind((A) => {
        const F = Dl(c, g.selectors.row);
        return DF(F, w).bind((H) => {
          const q = qF(F, g);
          return x(q, H, A).map((ne) => ne.cell);
        });
      });
    });
  }, KF = zE(nU, oU), WP = zE(eu, ZF), YF = zE(UF, GF), XF = zE(WF, rU), lU = te([
    Vo(Cr(Xf), DP(KF, WP)),
    Vo(Cr(eh), RP(KF, WP)),
    Vo(Cr(Jp), $E(YF)),
    Vo(Cr(as), OF(XF)),
    Vo(Cr(ni.concat(ps)), iU)
  ]), cU = te([Vo(Cr(ni), C1)]);
  var uU = Vm(sU, Bl.init, lU, cU, () => B.some(aU));
  const dU = [
    Rt("selector"),
    Qe("execute", tx),
    Qe("moveOnTab", !1)
  ], ZP = (t, a, c) => c.focusManager.get(t).bind((f) => c.execute(t, a, f)), QF = (t, a, c) => {
    ss(t.element, a.selector).each((f) => {
      a.focusManager.set(t, f);
    });
  }, Cg = (t, a, c) => PC(t, c.selector, a, -1), GP = (t, a, c) => PC(t, c.selector, a, 1), JF = (t, a, c, f) => c.moveOnTab ? MP(Cg)(t, a, c, f) : B.none(), eB = (t, a, c, f) => c.moveOnTab ? MP(GP)(t, a, c, f) : B.none(), fU = te([
    Vo(Cr(Jp), MP(Cg)),
    Vo(Cr(as), MP(GP)),
    Vo(Aa([
      Qf,
      Cr(ws)
    ]), JF),
    Vo(Aa([
      Jc,
      Cr(ws)
    ]), eB),
    Vo(Cr(ps), ZP),
    Vo(Cr(ni), ZP)
  ]), rx = te([Vo(Cr(ni), C1)]);
  var mU = Vm(dU, Bl.init, fU, rx, () => B.some(QF));
  const pU = [
    sc("onSpace"),
    sc("onEnter"),
    sc("onShiftEnter"),
    sc("onLeft"),
    sc("onRight"),
    sc("onTab"),
    sc("onShiftTab"),
    sc("onUp"),
    sc("onDown"),
    sc("onEscape"),
    Qe("stopSpaceKeyup", !1),
    jr("focusIn")
  ], tB = (t, a, c) => [
    Vo(Cr(ni), c.onSpace),
    Vo(Aa([
      Jc,
      Cr(ps)
    ]), c.onEnter),
    Vo(Aa([
      Qf,
      Cr(ps)
    ]), c.onShiftEnter),
    Vo(Aa([
      Qf,
      Cr(ws)
    ]), c.onShiftTab),
    Vo(Aa([
      Jc,
      Cr(ws)
    ]), c.onTab),
    Vo(Cr(Jp), c.onUp),
    Vo(Cr(as), c.onDown),
    Vo(Cr(Xf), c.onLeft),
    Vo(Cr(eh), c.onRight),
    Vo(Cr(ni), c.onSpace)
  ], hU = (t, a, c) => [
    ...c.stopSpaceKeyup ? [Vo(Cr(ni), C1)] : [],
    Vo(Cr(nl), c.onEscape)
  ];
  var gU = Vm(pU, Bl.init, tB, hU, (t) => t.focusIn);
  const bU = w1.schema(), nB = zj.schema(), qP = tU.schema(), KP = Xj.schema(), vU = uU.schema(), Wb = EF.schema(), oB = mU.schema(), rB = gU.schema();
  var yU = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    acyclic: bU,
    cyclic: nB,
    flow: qP,
    flatgrid: KP,
    matrix: vU,
    execution: Wb,
    menu: oB,
    special: rB
  });
  const xU = (t) => As(t, "setGridSize"), oo = Xk({
    branchKey: "mode",
    branches: yU,
    name: "keying",
    active: {
      events: (t, a) => t.handler.toEvents(t, a)
    },
    apis: {
      focusIn: (t, a, c) => {
        a.sendFocusIn(a).fold(() => {
          t.getSystem().triggerFocus(t.element, t.element);
        }, (f) => {
          f(t, a, c);
        });
      },
      setGridSize: (t, a, c, f, g) => {
        xU(c) ? c.setGridSize(f, g) : console.error("Layout does not support setGridSize");
      }
    },
    state: jj
  }), sx = (t, a) => {
    Hp(() => {
      Fb(t, a, () => tt(a, t.getSystem().build));
    }, t.element);
  }, YP = (t, a) => {
    Hp(() => {
      sC(t, a, () => Kv(t.element, a, t.getSystem().buildOrPatch));
    }, t.element);
  }, XP = (t, a, c, f) => {
    Iy(a);
    const g = Uu(t.element, c, f, t.getSystem().buildOrPatch);
    oC(t, g), t.syncComponents();
  }, th = (t, a, c) => {
    const f = t.getSystem().build(c);
    hg(t, f, a);
  }, Zb = (t, a, c, f) => {
    $m(a), th(t, (g, x) => Ya(g, x, c), f);
  }, wU = (t, a, c, f) => (a.reuseDom ? YP : sx)(t, f), CU = (t, a, c, f) => {
    th(t, qi, f);
  }, sB = (t, a, c, f) => {
    th(t, lp, f);
  }, Sg = (t, a, c, f) => {
    const g = ax(t);
    At(g, (w) => Lr(f.element, w.element)).each($m);
  }, ax = (t, a) => t.components(), aB = (t, a, c, f, g) => {
    const x = ax(t);
    return B.from(x[f]).map((w) => (g.fold(() => $m(w), (T) => {
      (a.reuseDom ? XP : Zb)(t, w, f, T);
    }), w));
  };
  var iB = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    append: CU,
    prepend: sB,
    remove: Sg,
    replaceAt: aB,
    replaceBy: (t, a, c, f, g) => {
      const x = ax(t);
      return $n(x, f).bind((w) => aB(t, a, c, w, g));
    },
    set: wU,
    contents: ax
  });
  const No = Xi({
    fields: [Ea("reuseDom", !0)],
    name: "replacing",
    apis: iB
  }), QP = (t, a) => {
    const c = js(a);
    return Xi({
      fields: [Rt("enabled")],
      name: t,
      active: { events: te(c) }
    });
  }, Go = (t, a) => {
    const c = QP(t, a);
    return {
      key: t,
      value: {
        config: {},
        me: c,
        configAsRaw: te({}),
        initialConfig: {},
        state: Bl
      }
    };
  }, lB = (t, a) => {
    a.ignore || (mu(t.element), a.onFocus(t));
  };
  var VE = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    focus: lB,
    blur: (t, a) => {
      a.ignore || Qv(t.element);
    },
    isFocused: (t) => Jv(t.element)
  }), uB = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, a) => {
      const c = a.ignore ? {} : { attributes: { tabindex: "-1" } };
      return Uc(c);
    },
    events: (t) => js([It(Jd(), (a, c) => {
      lB(a, t), c.stop();
    })].concat(t.stopMousedown ? [It(nc(), (a, c) => {
      c.event.prevent();
    })] : []))
  }), kU = [
    Rr("onFocus"),
    Qe("stopMousedown", !1),
    Qe("ignore", !1)
  ];
  const Ao = Xi({
    fields: kU,
    name: "focusing",
    active: uB,
    apis: VE
  }), dB = (t) => ({ init: () => {
    const c = no(t);
    return {
      get: () => c.get(),
      set: (T) => c.set(T),
      clear: () => c.set(t),
      readState: () => c.get()
    };
  } }), fB = (t, a, c) => {
    const f = a.aria;
    f.update(t, f, c.get());
  }, mB = (t, a, c) => {
    a.toggleClass.each((f) => {
      c.get() ? Us(t.element, f) : va(t.element, f);
    });
  }, RC = (t, a, c, f) => {
    const g = c.get();
    c.set(f), mB(t, a, c), fB(t, a, c), g !== f && a.onToggled(t, f);
  }, jE = (t, a, c) => {
    RC(t, a, c, !c.get());
  }, _U = (t, a, c) => {
    RC(t, a, c, !0);
  }, EU = (t, a, c) => {
    RC(t, a, c, !1);
  }, TU = (t, a, c) => c.get(), pB = (t, a, c) => {
    RC(t, a, c, a.selected);
  };
  var hB = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    onLoad: pB,
    toggle: jE,
    isOn: TU,
    on: _U,
    off: EU,
    set: RC
  }), gB = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: () => Uc({}),
    events: (t, a) => {
      const c = $v(t, a, jE), f = Ww(t, a, pB);
      return js(en([
        t.toggleOnExecute ? [c] : [],
        [f]
      ]));
    }
  });
  const NC = (t, a, c) => {
    rn(t.element, "aria-pressed", c), a.syncWithExpanded && UE(t, a, c);
  }, OU = (t, a, c) => {
    rn(t.element, "aria-selected", c);
  }, MC = (t, a, c) => {
    rn(t.element, "aria-checked", c);
  }, UE = (t, a, c) => {
    rn(t.element, "aria-expanded", c);
  };
  var bB = [
    Qe("selected", !1),
    jr("toggleClass"),
    Qe("toggleOnExecute", !0),
    Rr("onToggled"),
    Vc("aria", { mode: "none" }, ci("mode", {
      pressed: [
        Qe("syncWithExpanded", !1),
        Ws("update", NC)
      ],
      checked: [Ws("update", MC)],
      expanded: [Ws("update", UE)],
      selected: [Ws("update", OU)],
      none: [Ws("update", G)]
    }))
  ];
  const ir = Xi({
    fields: bB,
    name: "toggling",
    active: gB,
    apis: hB,
    state: dB(!1)
  }), vB = () => {
    const t = (a, c) => {
      c.stop(), Tp(a);
    };
    return [
      It(Vh(), t),
      It(ef(), t),
      nf(wr()),
      nf(nc())
    ];
  }, WE = (t) => {
    const a = (c) => Sd((f, g) => {
      c(f), g.stop();
    });
    return js(en([
      t.map(a).toArray(),
      vB()
    ]));
  }, eD = "alloy.item-hover", yB = "alloy.item-focus", tD = "alloy.item-toggled", xB = (t) => {
    (ic(t.element).isNone() || Ao.isFocused(t)) && (Ao.isFocused(t) || Ao.focus(t), po(t, eD, { item: t }));
  }, wB = (t) => {
    po(t, yB, { item: t });
  }, CB = (t, a) => {
    po(t, tD, {
      item: t,
      state: a
    });
  }, IC = te(eD), nD = te(yB), oD = te(tD), AU = (t) => t.role.fold(() => t.toggling.map((a) => a.exclusive ? "menuitemradio" : "menuitemcheckbox").getOr("menuitem"), lt), PU = (t, a) => ({
    aria: { mode: a ? "selected" : "checked" },
    ...or(t, (c, f) => f !== "exclusive"),
    onToggled: (c, f) => {
      Q(t.onToggled) && t.onToggled(c, f), CB(c, f);
    }
  }), DU = (t) => ({
    dom: t.dom,
    domModification: {
      ...t.domModification,
      attributes: {
        role: AU(t),
        ...t.domModification.attributes,
        "aria-haspopup": t.hasSubmenu,
        ...t.hasSubmenu ? { "aria-expanded": !1 } : {}
      }
    },
    behaviours: Zu.augment(t.itemBehaviours, [
      t.toggling.fold(ir.revoke, (a) => ir.config(PU(a, t.role.exists((c) => c === "option")))),
      Ao.config({
        ignore: t.ignoreFocus,
        stopMousedown: t.ignoreFocus,
        onFocus: (a) => {
          wB(a);
        }
      }),
      oo.config({ mode: "execution" }),
      Mn.config({
        store: {
          mode: "memory",
          initialValue: t.data
        }
      }),
      Go("item-type-events", [
        ...vB(),
        It(Bf(), xB),
        It(Dv(), Ao.focus)
      ])
    ]),
    components: t.components,
    eventOrder: t.eventOrder
  }), RU = [
    Rt("data"),
    Rt("components"),
    Rt("dom"),
    Qe("hasSubmenu", !1),
    jr("toggling"),
    jr("role"),
    Zu.field("itemBehaviours", [
      ir,
      Ao,
      oo,
      Mn
    ]),
    Qe("ignoreFocus", !1),
    Qe("domModification", {}),
    Ws("builder", DU),
    Qe("eventOrder", {})
  ], SB = (t) => ({
    dom: t.dom,
    components: t.components,
    events: js([jw(Dv())])
  }), kB = [
    Rt("dom"),
    Rt("components"),
    Ws("builder", SB)
  ], rD = te("item-widget"), sD = te([hl({
    name: "widget",
    overrides: (t) => ({
      behaviours: Qt([Mn.config({
        store: {
          mode: "manual",
          getValue: (a) => t.data,
          setValue: G
        }
      })])
    })
  })]), NU = (t) => {
    const a = Xy(rD(), t, sD()), c = yC(rD(), t, a.internals()), f = (x) => Xt(x, t, "widget").map((w) => (oo.focusIn(w), w)), g = (x, w) => jb(w.event.target) ? B.none() : (t.autofocus && w.setSource(x.element), B.none());
    return {
      dom: t.dom,
      components: c,
      domModification: t.domModification,
      events: js([
        Sd((x, w) => {
          f(x).each((T) => {
            w.stop();
          });
        }),
        It(Bf(), xB),
        It(Dv(), (x, w) => {
          t.autofocus ? f(x) : Ao.focus(x);
        })
      ]),
      behaviours: Zu.augment(t.widgetBehaviours, [
        Mn.config({
          store: {
            mode: "memory",
            initialValue: t.data
          }
        }),
        Ao.config({
          ignore: t.ignoreFocus,
          onFocus: (x) => {
            wB(x);
          }
        }),
        oo.config({
          mode: "special",
          focusIn: t.autofocus ? (x) => {
            f(x);
          } : Js(),
          onLeft: g,
          onRight: g,
          onEscape: (x, w) => !Ao.isFocused(x) && !t.autofocus ? (Ao.focus(x), B.some(!0)) : (t.autofocus && w.setSource(x.element), B.none())
        })
      ])
    };
  }, MU = [
    Rt("uid"),
    Rt("data"),
    Rt("components"),
    Rt("dom"),
    Qe("autofocus", !1),
    Qe("ignoreFocus", !1),
    Zu.field("widgetBehaviours", [
      Mn,
      Ao,
      oo
    ]),
    Qe("domModification", {}),
    b1(sD()),
    Ws("builder", NU)
  ], IU = ci("type", {
    widget: MU,
    item: RU,
    separator: kB
  }), FU = (t, a) => ({
    mode: "flatgrid",
    selector: "." + t.markers.item,
    initSize: {
      numColumns: a.initSize.numColumns,
      numRows: a.initSize.numRows
    },
    focusManager: t.focusManager
  }), _B = (t, a) => ({
    mode: "matrix",
    selectors: {
      row: a.rowSelector,
      cell: "." + t.markers.item
    },
    previousSelector: a.previousSelector,
    focusManager: t.focusManager
  }), BU = (t, a) => ({
    mode: "menu",
    selector: "." + t.markers.item,
    moveOnTab: a.moveOnTab,
    focusManager: t.focusManager
  }), $U = te([Ky({
    factory: {
      sketch: (t) => {
        const a = El("menu.spec item", IU, t);
        return a.builder(a);
      }
    },
    name: "items",
    unit: "item",
    defaults: (t, a) => Ho(a, "uid") ? a : {
      ...a,
      uid: ng("item")
    },
    overrides: (t, a) => ({
      type: a.type,
      ignoreFocus: t.fakeFocus,
      domModification: { classes: [t.markers.item] }
    })
  })]), LU = te([
    ja("role"),
    Rt("value"),
    Rt("items"),
    Rt("dom"),
    Rt("components"),
    Qe("eventOrder", {}),
    $i("menuBehaviours", [
      wn,
      Mn,
      Nr,
      oo
    ]),
    Vc("movement", {
      mode: "menu",
      moveOnTab: !0
    }, ci("mode", {
      grid: [
        K0(),
        Ws("config", FU)
      ],
      matrix: [
        Ws("config", _B),
        Rt("rowSelector"),
        Qe("previousSelector", B.none)
      ],
      menu: [
        Qe("moveOnTab", !0),
        Ws("config", BU)
      ]
    })),
    u4(),
    Qe("fakeFocus", !1),
    Qe("focusManager", ex()),
    Rr("onHighlight"),
    Rr("onDehighlight"),
    Qe("showMenuRole", !0)
  ]), EB = te("alloy.menu-focus"), HU = (t, a) => {
    const c = Dl(t.element, '[role="menuitemradio"][aria-checked="true"]');
    mt(c, (f) => {
      Lr(f, a.element) || t.getSystem().getByDom(f).each((g) => {
        ir.off(g);
      });
    });
  }, k1 = (t, a, c, f) => ({
    uid: t.uid,
    dom: t.dom,
    markers: t.markers,
    behaviours: Li(t.menuBehaviours, [
      wn.config({
        highlightClass: t.markers.selectedItem,
        itemClass: t.markers.item,
        onHighlight: t.onHighlight,
        onDehighlight: t.onDehighlight
      }),
      Mn.config({
        store: {
          mode: "memory",
          initialValue: t.value
        }
      }),
      Nr.config({ find: B.some }),
      oo.config(t.movement.config(t, t.movement))
    ]),
    events: js([
      It(nD(), (g, x) => {
        const w = x.event;
        g.getSystem().getByDom(w.target).each((T) => {
          wn.highlight(g, T), x.stop(), po(g, EB(), {
            menu: g,
            item: T
          });
        });
      }),
      It(IC(), (g, x) => {
        const w = x.event.item;
        wn.highlight(g, w);
      }),
      It(oD(), (g, x) => {
        const { item: w, state: T } = x.event;
        T && os(w.element, "role") === "menuitemradio" && HU(g, w);
      })
    ]),
    components: a,
    eventOrder: t.eventOrder,
    ...t.showMenuRole ? { domModification: { attributes: { role: t.role.getOr("menu") } } } : {}
  }), _1 = Vl({
    name: "Menu",
    configFields: LU(),
    partFields: $U(),
    factory: k1
  }), zU = (t) => yn(t, (a, c) => ({
    k: a,
    v: c
  })), Gb = (t, a, c, f) => Ht(c, f).bind((g) => Ht(t, g).bind((x) => {
    const w = Gb(t, a, c, x);
    return B.some([x].concat(w));
  })).getOr([]), TB = (t, a) => {
    const c = {};
    at(t, (w, T) => {
      mt(w, (A) => {
        c[A] = T;
      });
    });
    const f = a, g = zU(a), x = kt(g, (w, T) => [T].concat(Gb(c, f, g, T)));
    return kt(c, (w) => Ht(x, w).getOr([w]));
  }, VU = () => {
    const t = no({}), a = no({}), c = no({}), f = ms(), g = no({}), x = () => {
      t.set({}), a.set({}), c.set({}), f.clear();
    }, w = () => f.get().isNone(), T = (gt, Jt) => {
      a.set({
        ...a.get(),
        [gt]: {
          type: "prepared",
          menu: Jt
        }
      });
    }, A = (gt, Jt, vn, Nt) => {
      f.set(gt), t.set(vn), a.set(Jt), g.set(Nt);
      const Yn = TB(Nt, vn);
      c.set(Yn);
    }, F = (gt) => Zo(t.get(), (Jt, vn) => Jt === gt), H = (gt, Jt, vn) => _e(gt).bind((Nt) => F(gt).bind((Yn) => Jt(Yn).map((In) => ({
      triggeredMenu: Nt,
      triggeringItem: In,
      triggeringPath: vn
    })))), q = (gt, Jt) => {
      const vn = To(De(gt).toArray(), (Nt) => _e(Nt).isSome());
      return Ht(c.get(), gt).bind((Nt) => {
        const Yn = mo(vn.concat(Nt)), In = Ue(Yn, (xo, fo) => H(xo, Jt, Yn.slice(0, fo + 1)).fold(() => ra(f.get(), xo) ? [] : [B.none()], (Gr) => [B.some(Gr)]));
        return kr(In);
      });
    }, ne = (gt) => Ht(t.get(), gt).map((Jt) => {
      const vn = Ht(c.get(), gt).getOr([]);
      return [Jt].concat(vn);
    }), ie = (gt) => Ht(c.get(), gt).bind((Jt) => Jt.length > 1 ? B.some(Jt.slice(1)) : B.none()), fe = (gt) => Ht(c.get(), gt), _e = (gt) => st(gt).bind(kg), st = (gt) => Ht(a.get(), gt), De = (gt) => Ht(t.get(), gt);
    return {
      setMenuBuilt: T,
      setContents: A,
      expand: ne,
      refresh: fe,
      collapse: ie,
      lookupMenu: st,
      lookupItem: De,
      otherMenus: (gt) => {
        const Jt = g.get();
        return xn(Qo(Jt), gt);
      },
      getPrimary: () => f.get().bind(_e),
      getMenus: () => a.get(),
      clear: x,
      isClear: w,
      getTriggeringPath: q
    };
  }, kg = (t) => t.type === "prepared" ? B.some(t.menu) : B.none(), OB = {
    init: VU,
    extractPreparedMenu: kg
  }, AB = Nn("tiered-menu-item-highlight"), Od = Nn("tiered-menu-item-dehighlight");
  var Dc;
  (function(t) {
    t[t.HighlightMenuAndItem = 0] = "HighlightMenuAndItem", t[t.HighlightJustMenu = 1] = "HighlightJustMenu", t[t.HighlightNone = 2] = "HighlightNone";
  })(Dc || (Dc = {}));
  const PB = (t, a) => {
    const c = ms(), f = (cn, Un, jo) => kt(jo, (So, go) => {
      const Lo = () => _1.sketch({
        ...So,
        value: go,
        markers: t.markers,
        fakeFocus: t.fakeFocus,
        onHighlight: (Os, Qr) => {
          po(Os, AB, {
            menuComp: Os,
            itemComp: Qr
          });
        },
        onDehighlight: (Os, Qr) => {
          po(Os, Od, {
            menuComp: Os,
            itemComp: Qr
          });
        },
        focusManager: t.fakeFocus ? FE() : ex()
      });
      return go === Un ? {
        type: "prepared",
        menu: cn.getSystem().build(Lo())
      } : {
        type: "notbuilt",
        nbMenu: Lo
      };
    }), g = OB.init(), x = (cn) => {
      const Un = f(cn, t.data.primary, t.data.menus), jo = A();
      return g.setContents(t.data.primary, Un, t.data.expansions, jo), g.getPrimary();
    }, w = (cn) => Mn.getValue(cn).value, T = (cn, Un, jo) => Ko(Un, (So) => {
      if (!So.getSystem().isConnected())
        return B.none();
      const go = wn.getCandidates(So);
      return At(go, (Lo) => w(Lo) === jo);
    }), A = (cn) => kt(t.data.menus, (Un, jo) => Ue(Un.items, (So) => So.type === "separator" ? [] : [So.data.value])), F = wn.highlight, H = (cn, Un) => {
      F(cn, Un), wn.getHighlighted(Un).orThunk(() => wn.getFirst(Un)).each((jo) => {
        t.fakeFocus ? wn.highlight(Un, jo) : Iv(cn, jo.element, Dv());
      });
    }, q = (cn, Un) => Ks(tt(Un, (jo) => cn.lookupMenu(jo).bind((So) => So.type === "prepared" ? B.some(So.menu) : B.none()))), ne = (cn, Un, jo) => {
      const So = q(Un, Un.otherMenus(jo));
      mt(So, (go) => {
        Gc(go.element, [t.markers.backgroundMenu]), t.stayInDom || No.remove(cn, go);
      });
    }, ie = (cn) => c.get().getOrThunk(() => {
      const Un = {}, jo = Dl(cn.element, `.${t.markers.item}`), So = To(jo, (go) => os(go, "aria-haspopup") === "true");
      return mt(So, (go) => {
        cn.getSystem().getByDom(go).each((Lo) => {
          const Os = w(Lo);
          Un[Os] = Lo;
        });
      }), c.set(Un), Un;
    }), fe = (cn, Un) => {
      const jo = ie(cn);
      at(jo, (So, go) => {
        const Lo = jt(Un, go);
        rn(So.element, "aria-expanded", Lo);
      });
    }, _e = (cn, Un, jo) => B.from(jo[0]).bind((So) => Un.lookupMenu(So).bind((go) => {
      if (go.type === "notbuilt")
        return B.none();
      {
        const Lo = go.menu, Os = q(Un, jo.slice(1));
        return mt(Os, (Qr) => {
          Us(Qr.element, t.markers.backgroundMenu);
        }), yr(Lo.element) || No.append(cn, Ll(Lo)), Gc(Lo.element, [t.markers.backgroundMenu]), H(cn, Lo), ne(cn, Un, jo), B.some(Lo);
      }
    }));
    let st;
    (function(cn) {
      cn[cn.HighlightSubmenu = 0] = "HighlightSubmenu", cn[cn.HighlightParent = 1] = "HighlightParent";
    })(st || (st = {}));
    const De = (cn, Un, jo) => {
      if (jo.type === "notbuilt") {
        const So = cn.getSystem().build(jo.nbMenu());
        return g.setMenuBuilt(Un, So), So;
      } else
        return jo.menu;
    }, Je = (cn, Un, jo = st.HighlightSubmenu) => {
      if (Un.hasConfigured(_o) && _o.isDisabled(Un))
        return B.some(Un);
      {
        const So = w(Un);
        return g.expand(So).bind((go) => (fe(cn, go), B.from(go[0]).bind((Lo) => g.lookupMenu(Lo).bind((Os) => {
          const Qr = De(cn, Lo, Os);
          return yr(Qr.element) || No.append(cn, Ll(Qr)), t.onOpenSubmenu(cn, Un, Qr, mo(go)), jo === st.HighlightSubmenu ? (wn.highlightFirst(Qr), _e(cn, g, go)) : (wn.dehighlightAll(Qr), B.some(Un));
        }))));
      }
    }, Ge = (cn, Un) => {
      const jo = w(Un);
      return g.collapse(jo).bind((So) => (fe(cn, So), _e(cn, g, So).map((go) => (t.onCollapseMenu(cn, Un, go), go))));
    }, Ft = (cn, Un) => {
      const jo = w(Un);
      return g.refresh(jo).bind((So) => (fe(cn, So), _e(cn, g, So)));
    }, gt = (cn, Un) => jb(Un.element) ? B.none() : Je(cn, Un, st.HighlightSubmenu), Jt = (cn, Un) => jb(Un.element) ? B.none() : Ge(cn, Un), vn = (cn, Un) => Ge(cn, Un).orThunk(() => t.onEscape(cn, Un).map(() => cn)), Nt = (cn) => (Un, jo) => cf(jo.getSource(), `.${t.markers.item}`).bind((So) => Un.getSystem().getByDom(So).toOptional().bind((go) => cn(Un, go).map(qe))), Yn = js([
      It(EB(), (cn, Un) => {
        const jo = Un.event.item;
        g.lookupItem(w(jo)).each(() => {
          const So = Un.event.menu;
          wn.highlight(cn, So);
          const go = w(Un.event.item);
          g.refresh(go).each((Lo) => ne(cn, g, Lo));
        });
      }),
      Sd((cn, Un) => {
        const jo = Un.event.target;
        cn.getSystem().getByDom(jo).each((So) => {
          w(So).indexOf("collapse-item") === 0 && Ge(cn, So), Je(cn, So, st.HighlightSubmenu).fold(() => {
            t.onExecute(cn, So);
          }, G);
        });
      }),
      Qs((cn, Un) => {
        x(cn).each((jo) => {
          No.append(cn, Ll(jo)), t.onOpenMenu(cn, jo), t.highlightOnOpen === Dc.HighlightMenuAndItem ? H(cn, jo) : t.highlightOnOpen === Dc.HighlightJustMenu && F(cn, jo);
        });
      }),
      It(AB, (cn, Un) => {
        t.onHighlightItem(cn, Un.event.menuComp, Un.event.itemComp);
      }),
      It(Od, (cn, Un) => {
        t.onDehighlightItem(cn, Un.event.menuComp, Un.event.itemComp);
      }),
      ...t.navigateOnHover ? [It(IC(), (cn, Un) => {
        const jo = Un.event.item;
        Ft(cn, jo), Je(cn, jo, st.HighlightParent), t.onHover(cn, jo);
      })] : []
    ]), In = (cn) => wn.getHighlighted(cn).bind(wn.getHighlighted), xo = (cn) => {
      In(cn).each((Un) => {
        Ge(cn, Un);
      });
    }, fo = (cn) => {
      g.getPrimary().each((Un) => {
        H(cn, Un);
      });
    }, Gr = (cn) => B.from(cn.components()[0]).filter((Un) => os(Un.element, "role") === "menu"), br = {
      collapseMenu: xo,
      highlightPrimary: fo,
      repositionMenus: (cn) => {
        g.getPrimary().bind((jo) => In(cn).bind((So) => {
          const go = w(So), Lo = Tr(g.getMenus()), Os = Ks(tt(Lo, OB.extractPreparedMenu));
          return g.getTriggeringPath(go, (Qr) => T(cn, Os, Qr));
        }).map((So) => ({
          primary: jo,
          triggeringPath: So
        }))).fold(() => {
          Gr(cn).each((jo) => {
            t.onRepositionMenu(cn, jo, []);
          });
        }, ({ primary: jo, triggeringPath: So }) => {
          t.onRepositionMenu(cn, jo, So);
        });
      }
    };
    return {
      uid: t.uid,
      dom: t.dom,
      markers: t.markers,
      behaviours: Li(t.tmenuBehaviours, [
        oo.config({
          mode: "special",
          onRight: Nt(gt),
          onLeft: Nt(Jt),
          onEscape: Nt(vn),
          focusIn: (cn, Un) => {
            g.getPrimary().each((jo) => {
              Iv(cn, jo.element, Dv());
            });
          }
        }),
        wn.config({
          highlightClass: t.markers.selectedMenu,
          itemClass: t.markers.menu
        }),
        Nr.config({
          find: (cn) => wn.getHighlighted(cn)
        }),
        No.config({})
      ]),
      eventOrder: t.eventOrder,
      apis: br,
      events: Yn
    };
  }, DB = te("collapse-item"), jU = (t, a, c) => ({
    primary: t,
    menus: a,
    expansions: c
  }), ZE = (t, a) => ({
    primary: t,
    menus: rs(t, a),
    expansions: {}
  }), RB = (t) => ({
    value: Nn(DB()),
    meta: { text: t }
  }), E1 = Pc({
    name: "TieredMenu",
    configFields: [
      Dm("onExecute"),
      Dm("onEscape"),
      ju("onOpenMenu"),
      ju("onOpenSubmenu"),
      Rr("onRepositionMenu"),
      Rr("onCollapseMenu"),
      Qe("highlightOnOpen", Dc.HighlightMenuAndItem),
      Yd("data", [
        Rt("primary"),
        Rt("menus"),
        Rt("expansions")
      ]),
      Qe("fakeFocus", !1),
      Rr("onHighlightItem"),
      Rr("onDehighlightItem"),
      Rr("onHover"),
      tg(),
      Rt("dom"),
      Qe("navigateOnHover", !0),
      Qe("stayInDom", !1),
      $i("tmenuBehaviours", [
        oo,
        wn,
        Nr,
        No
      ]),
      Qe("eventOrder", {})
    ],
    apis: {
      collapseMenu: (t, a) => {
        t.collapseMenu(a);
      },
      highlightPrimary: (t, a) => {
        t.highlightPrimary(a);
      },
      repositionMenus: (t, a) => {
        t.repositionMenus(a);
      }
    },
    factory: PB,
    extraApis: {
      tieredData: jU,
      singleData: ZE,
      collapseItem: RB
    }
  }), UU = (t, a, c, f, g) => {
    const x = () => t.lazySink(a), w = f.type === "horizontal" ? {
      layouts: {
        onLtr: () => uy(),
        onRtl: () => rg()
      }
    } : {}, T = (F) => F.length === 2, A = (F) => T(F) ? w : {};
    return E1.sketch({
      dom: { tag: "div" },
      data: f.data,
      markers: f.menu.markers,
      highlightOnOpen: f.menu.highlightOnOpen,
      fakeFocus: f.menu.fakeFocus,
      onEscape: () => (Br.close(a), t.onEscape.map((F) => F(a)), B.some(!0)),
      onExecute: () => B.some(!0),
      onOpenMenu: (F, H) => {
        tl.positionWithinBounds(x().getOrDie(), H, c, g());
      },
      onOpenSubmenu: (F, H, q, ne) => {
        const ie = x().getOrDie();
        tl.position(ie, q, {
          anchor: {
            type: "submenu",
            item: H,
            ...A(ne)
          }
        });
      },
      onRepositionMenu: (F, H, q) => {
        const ne = x().getOrDie();
        tl.positionWithinBounds(ne, H, c, g()), mt(q, (ie) => {
          const fe = A(ie.triggeringPath);
          tl.position(ne, ie.triggeredMenu, {
            anchor: {
              type: "submenu",
              item: ie.triggeringItem,
              ...fe
            }
          });
        });
      }
    });
  }, GE = (t, a) => {
    const c = (ne, ie) => t.getRelated(ne).exists((_e) => Ip(_e, ie)), f = (ne, ie) => {
      Br.setContent(ne, ie);
    }, g = (ne, ie, fe) => {
      const _e = B.none;
      x(ne, ie, fe, _e);
    }, x = (ne, ie, fe, _e) => {
      const st = t.lazySink(ne).getOrDie();
      Br.openWhileCloaked(ne, ie, () => tl.positionWithinBounds(st, ne, fe, _e())), Mn.setValue(ne, B.some({
        mode: "position",
        config: fe,
        getBounds: _e
      }));
    }, w = (ne, ie, fe) => {
      T(ne, ie, fe, B.none);
    }, T = (ne, ie, fe, _e) => {
      const st = UU(t, ne, ie, fe, _e);
      Br.open(ne, st), Mn.setValue(ne, B.some({
        mode: "menu",
        menu: st
      }));
    }, A = (ne) => {
      Br.isOpen(ne) && (Mn.setValue(ne, B.none()), Br.close(ne));
    }, F = (ne) => Br.getState(ne), H = (ne) => {
      Br.isOpen(ne) && Mn.getValue(ne).each((ie) => {
        switch (ie.mode) {
          case "menu":
            Br.getState(ne).each(E1.repositionMenus);
            break;
          case "position":
            const fe = t.lazySink(ne).getOrDie();
            tl.positionWithinBounds(fe, ne, ie.config, ie.getBounds());
            break;
        }
      });
    }, q = {
      setContent: f,
      showAt: g,
      showWithinBounds: x,
      showMenuAt: w,
      showMenuWithinBounds: T,
      hide: A,
      getContent: F,
      reposition: H,
      isOpen: Br.isOpen
    };
    return {
      uid: t.uid,
      dom: t.dom,
      behaviours: Li(t.inlineBehaviours, [
        Br.config({
          isPartOf: (ne, ie, fe) => Ip(ie, fe) || c(ne, fe),
          getAttachPoint: (ne) => t.lazySink(ne).getOrDie(),
          onOpen: (ne) => {
            t.onShow(ne);
          },
          onClose: (ne) => {
            t.onHide(ne);
          }
        }),
        Mn.config({
          store: {
            mode: "memory",
            initialValue: B.none()
          }
        }),
        Ac.config({
          channels: {
            ...Lm({
              isExtraPart: a.isExtraPart,
              ...t.fireDismissalEventInstead.map((ne) => ({ fireEventInstead: { event: ne.event } })).getOr({})
            }),
            ...$y({
              ...t.fireRepositionEventInstead.map((ne) => ({ fireEventInstead: { event: ne.event } })).getOr({}),
              doReposition: H
            })
          }
        })
      ]),
      eventOrder: t.eventOrder,
      apis: q
    };
  }, la = Pc({
    name: "InlineView",
    configFields: [
      Rt("lazySink"),
      Rr("onShow"),
      Rr("onHide"),
      vd("onEscape"),
      $i("inlineBehaviours", [
        Br,
        Mn,
        Ac
      ]),
      Es("fireDismissalEventInstead", [Qe("event", _p())]),
      Es("fireRepositionEventInstead", [Qe("event", $w())]),
      Qe("getRelated", B.none),
      Qe("isExtraPart", wt),
      Qe("eventOrder", B.none)
    ],
    factory: GE,
    apis: {
      showAt: (t, a, c, f) => {
        t.showAt(a, c, f);
      },
      showWithinBounds: (t, a, c, f, g) => {
        t.showWithinBounds(a, c, f, g);
      },
      showMenuAt: (t, a, c, f) => {
        t.showMenuAt(a, c, f);
      },
      showMenuWithinBounds: (t, a, c, f, g) => {
        t.showMenuWithinBounds(a, c, f, g);
      },
      hide: (t, a) => {
        t.hide(a);
      },
      isOpen: (t, a) => t.isOpen(a),
      getContent: (t, a) => t.getContent(a),
      setContent: (t, a, c) => {
        t.setContent(a, c);
      },
      reposition: (t, a) => {
        t.reposition(a);
      }
    }
  });
  var FC = tinymce.util.Tools.resolve("tinymce.util.Delay"), T1 = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), NB = tinymce.util.Tools.resolve("tinymce.EditorManager"), ix = tinymce.util.Tools.resolve("tinymce.Env"), Yu;
  (function(t) {
    t.default = "wrap", t.floating = "floating", t.sliding = "sliding", t.scrolling = "scrolling";
  })(Yu || (Yu = {}));
  var lx;
  (function(t) {
    t.auto = "auto", t.top = "top", t.bottom = "bottom";
  })(lx || (lx = {}));
  const Ls = (t) => (a) => a.options.get(t), BC = (t) => (a) => B.from(t(a)), MB = (t) => {
    const a = ix.deviceType.isPhone(), c = ix.deviceType.isTablet() || a, f = t.options.register, g = (w) => _(w) || w === !1, x = (w) => _(w) || oe(w);
    f("skin", {
      processor: (w) => _(w) || w === !1,
      default: "oxide"
    }), f("skin_url", { processor: "string" }), f("height", {
      processor: x,
      default: Math.max(t.getElement().offsetHeight, 400)
    }), f("width", {
      processor: x,
      default: T1.DOM.getStyle(t.getElement(), "width")
    }), f("min_height", {
      processor: "number",
      default: 100
    }), f("min_width", { processor: "number" }), f("max_height", { processor: "number" }), f("max_width", { processor: "number" }), f("style_formats", { processor: "object[]" }), f("style_formats_merge", {
      processor: "boolean",
      default: !1
    }), f("style_formats_autohide", {
      processor: "boolean",
      default: !1
    }), f("line_height_formats", {
      processor: "string",
      default: "1 1.1 1.2 1.3 1.4 1.5 2"
    }), f("font_family_formats", {
      processor: "string",
      default: "Andale Mono=andale mono,monospace;Arial=arial,helvetica,sans-serif;Arial Black=arial black,sans-serif;Book Antiqua=book antiqua,palatino,serif;Comic Sans MS=comic sans ms,sans-serif;Courier New=courier new,courier,monospace;Georgia=georgia,palatino,serif;Helvetica=helvetica,arial,sans-serif;Impact=impact,sans-serif;Symbol=symbol;Tahoma=tahoma,arial,helvetica,sans-serif;Terminal=terminal,monaco,monospace;Times New Roman=times new roman,times,serif;Trebuchet MS=trebuchet ms,geneva,sans-serif;Verdana=verdana,geneva,sans-serif;Webdings=webdings;Wingdings=wingdings,zapf dingbats"
    }), f("font_size_formats", {
      processor: "string",
      default: "8pt 10pt 12pt 14pt 18pt 24pt 36pt"
    }), f("font_size_input_default_unit", {
      processor: "string",
      default: "pt"
    }), f("block_formats", {
      processor: "string",
      default: "Paragraph=p;Heading 1=h1;Heading 2=h2;Heading 3=h3;Heading 4=h4;Heading 5=h5;Heading 6=h6;Preformatted=pre"
    }), f("content_langs", { processor: "object[]" }), f("removed_menuitems", {
      processor: "string",
      default: ""
    }), f("menubar", {
      processor: (w) => _(w) || J(w),
      default: !a
    }), f("menu", {
      processor: "object",
      default: {}
    }), f("toolbar", {
      processor: (w) => J(w) || _(w) || W(w) ? {
        value: w,
        valid: !0
      } : {
        valid: !1,
        message: "Must be a boolean, string or array."
      },
      default: !0
    }), St(9, (w) => {
      f("toolbar" + (w + 1), { processor: "string" });
    }), f("toolbar_mode", {
      processor: "string",
      default: c ? "scrolling" : "floating"
    }), f("toolbar_groups", {
      processor: "object",
      default: {}
    }), f("toolbar_location", {
      processor: "string",
      default: lx.auto
    }), f("toolbar_persist", {
      processor: "boolean",
      default: !1
    }), f("toolbar_sticky", {
      processor: "boolean",
      default: t.inline
    }), f("toolbar_sticky_offset", {
      processor: "number",
      default: 0
    }), f("fixed_toolbar_container", {
      processor: "string",
      default: ""
    }), f("fixed_toolbar_container_target", { processor: "object" }), f("ui_mode", {
      processor: "string",
      default: "combined"
    }), f("file_picker_callback", { processor: "function" }), f("file_picker_validator_handler", { processor: "function" }), f("file_picker_types", { processor: "string" }), f("typeahead_urls", {
      processor: "boolean",
      default: !0
    }), f("anchor_top", {
      processor: g,
      default: "#top"
    }), f("anchor_bottom", {
      processor: g,
      default: "#bottom"
    }), f("draggable_modal", {
      processor: "boolean",
      default: !1
    }), f("statusbar", {
      processor: "boolean",
      default: !0
    }), f("elementpath", {
      processor: "boolean",
      default: !0
    }), f("branding", {
      processor: "boolean",
      default: !0
    }), f("promotion", {
      processor: "boolean",
      default: !0
    }), f("resize", {
      processor: (w) => w === "both" || J(w),
      default: !ix.deviceType.isTouch()
    }), f("sidebar_show", { processor: "string" }), f("help_accessibility", {
      processor: "boolean",
      default: t.hasPlugin("help")
    }), f("default_font_stack", {
      processor: "string[]",
      default: []
    });
  }, qE = Ls("readonly"), aD = Ls("height"), O1 = Ls("width"), cx = BC(Ls("min_width")), KE = BC(Ls("min_height")), $C = BC(Ls("max_width")), iD = BC(Ls("max_height")), IB = BC(Ls("style_formats")), FB = Ls("style_formats_merge"), BB = Ls("style_formats_autohide"), YE = Ls("content_langs"), lD = Ls("removed_menuitems"), A1 = Ls("toolbar_mode"), XE = Ls("toolbar_groups"), cD = Ls("toolbar_location"), $B = Ls("fixed_toolbar_container"), WU = Ls("fixed_toolbar_container_target"), LB = Ls("toolbar_persist"), HB = Ls("toolbar_sticky_offset"), uD = Ls("menubar"), QE = Ls("toolbar"), zB = Ls("file_picker_callback"), JE = Ls("file_picker_validator_handler"), dD = Ls("font_size_input_default_unit"), fD = Ls("file_picker_types"), VB = Ls("typeahead_urls"), eT = Ls("anchor_top"), jB = Ls("anchor_bottom"), UB = Ls("draggable_modal"), WB = Ls("statusbar"), ZB = Ls("elementpath"), mD = Ls("branding"), pD = Ls("resize"), tT = Ls("paste_as_text"), GB = Ls("sidebar_show"), LC = Ls("promotion"), qB = Ls("help_accessibility"), KB = Ls("default_font_stack"), hD = (t) => t.options.get("skin") === !1, nT = (t) => t.options.get("menubar") !== !1, gD = (t) => {
    const a = t.options.get("skin_url");
    if (hD(t))
      return a;
    if (a)
      return t.documentBaseURI.toAbsolute(a);
    {
      const c = t.options.get("skin");
      return NB.baseURL + "/skins/ui/" + c;
    }
  }, oT = (t) => B.from(t.options.get("skin_url")), bD = (t) => t.options.get("line_height_formats").split(" "), rT = (t) => {
    const a = QE(t), c = _(a), f = W(a) && a.length > 0;
    return !P1(t) && (f || c || a === !0);
  }, vD = (t) => {
    const a = St(9, (f) => t.options.get("toolbar" + (f + 1))), c = To(a, _);
    return Xn(c.length > 0, c);
  }, P1 = (t) => vD(t).fold(() => {
    const a = QE(t);
    return ae(a, _) && a.length > 0;
  }, qe), _g = (t) => cD(t) === lx.bottom, YB = (t) => {
    var a;
    if (!t.inline)
      return B.none();
    const c = (a = $B(t)) !== null && a !== void 0 ? a : "";
    if (c.length > 0)
      return ss(Uo(), c);
    const f = WU(t);
    return Ce(f) ? B.some(He.fromDom(f)) : B.none();
  }, ux = (t) => t.inline && YB(t).isSome(), HC = (t) => YB(t).getOrThunk(() => Ae(le(He.fromDom(t.getElement())))), sT = (t) => t.inline && !nT(t) && !rT(t) && !P1(t), dx = (t) => (t.options.get("toolbar_sticky") || t.inline) && !ux(t) && !sT(t), qb = (t) => !ux(t) && t.options.get("ui_mode") === "split", yD = (t) => {
    const a = t.options.get("menu");
    return kt(a, (c) => ({
      ...c,
      items: c.items
    }));
  };
  var ZU = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    get ToolbarMode() {
      return Yu;
    },
    get ToolbarLocation() {
      return lx;
    },
    register: MB,
    getSkinUrl: gD,
    getSkinUrlOption: oT,
    isReadOnly: qE,
    isSkinDisabled: hD,
    getHeightOption: aD,
    getWidthOption: O1,
    getMinWidthOption: cx,
    getMinHeightOption: KE,
    getMaxWidthOption: $C,
    getMaxHeightOption: iD,
    getUserStyleFormats: IB,
    shouldMergeStyleFormats: FB,
    shouldAutoHideStyleFormats: BB,
    getLineHeightFormats: bD,
    getContentLanguages: YE,
    getRemovedMenuItems: lD,
    isMenubarEnabled: nT,
    isMultipleToolbars: P1,
    isToolbarEnabled: rT,
    isToolbarPersist: LB,
    getMultipleToolbarsOption: vD,
    getUiContainer: HC,
    useFixedContainer: ux,
    isSplitUiMode: qb,
    getToolbarMode: A1,
    isDraggableModal: UB,
    isDistractionFree: sT,
    isStickyToolbar: dx,
    getStickyToolbarOffset: HB,
    getToolbarLocation: cD,
    isToolbarLocationBottom: _g,
    getToolbarGroups: XE,
    getMenus: yD,
    getMenubar: uD,
    getToolbar: QE,
    getFilePickerCallback: zB,
    getFilePickerTypes: fD,
    useTypeaheadUrls: VB,
    getAnchorTop: eT,
    getAnchorBottom: jB,
    getFilePickerValidatorHandler: JE,
    getFontSizeInputDefaultUnit: dD,
    useStatusBar: WB,
    useElementPath: ZB,
    promotionEnabled: LC,
    useBranding: mD,
    getResize: pD,
    getPasteAsText: tT,
    getSidebarShow: GB,
    useHelpAccessibility: qB,
    getDefaultFontStack: KB
  });
  const XB = [
    "visible",
    "hidden",
    "clip"
  ], xD = (t) => Ps(t).length > 0 && !jt(XB, t), aT = (t) => {
    if (Ti(t)) {
      const a = fs(t, "overflow-x"), c = fs(t, "overflow-y");
      return xD(a) || xD(c);
    } else
      return !1;
  }, GU = (t) => {
    const a = Nb(t, aT), c = a.length === 0 ? Dt(t).map(Yt).map((f) => Nb(f, aT)).getOr([]) : a;
    return so(c).map((f) => ({
      element: f,
      others: c.slice(1)
    }));
  }, Eg = (t, a) => qb(t) ? GU(a) : B.none(), D1 = (t) => {
    const a = [
      ...tt(t.others, aa),
      Ra()
    ];
    return Fh(aa(t.element), a);
  }, Rl = Pc({
    name: "Button",
    factory: (t) => {
      const a = WE(t.action), c = t.dom.tag, f = (x) => Ht(t.dom, "attributes").bind((w) => Ht(w, x)), g = () => {
        if (c === "button") {
          const x = f("type").getOr("button"), w = f("role").map((T) => ({ role: T })).getOr({});
          return {
            type: x,
            ...w
          };
        } else
          return { role: t.role.getOr(f("role").getOr("button")) };
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: t.components,
        events: a,
        behaviours: Zu.augment(t.buttonBehaviours, [
          Ao.config({}),
          oo.config({
            mode: "execution",
            useSpace: !0,
            useEnter: !0
          })
        ]),
        domModification: { attributes: g() },
        eventOrder: t.eventOrder
      };
    },
    configFields: [
      Qe("uid", void 0),
      Rt("dom"),
      Qe("components", []),
      Zu.field("buttonBehaviours", [
        Ao,
        oo
      ]),
      jr("action"),
      jr("role"),
      Qe("eventOrder", {})
    ]
  }), qU = (t) => {
    const a = t.dom.attributes !== void 0 ? t.dom.attributes : [];
    return Mt(a, (c, f) => f.name === "class" ? c : {
      ...c,
      [f.name]: f.value
    }, {});
  }, wD = (t) => Array.prototype.slice.call(t.dom.classList, 0), jm = (t) => {
    const a = He.fromHtml(t), c = $a(a), f = qU(a), g = wD(a), x = c.length === 0 ? {} : { innerHtml: Oc(a) };
    return {
      tag: Kr(a),
      classes: g,
      attributes: f,
      ...x
    };
  }, is = (t) => {
    const a = CP(t) && As(t, "uid") ? t.uid : ng("memento");
    return {
      get: (x) => x.getSystem().getByUid(a).getOrDie(),
      getOpt: (x) => x.getSystem().getByUid(a).toOptional(),
      asSpec: () => ({
        ...t,
        uid: a
      })
    };
  };
  var KU = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, a) => Uc({
      attributes: Zr([{
        key: a.tabAttr,
        value: "true"
      }])
    })
  }), YU = [Qe("tabAttr", "data-alloy-tabstop")];
  const Zs = Xi({
    fields: YU,
    name: "tabstopping",
    active: KU
  }), JB = Nn("tooltip.exclusive"), zC = Nn("tooltip.show"), VC = Nn("tooltip.hide"), lT = Nn("tooltip.immediateHide"), cT = Nn("tooltip.immediateShow"), e$ = (t, a, c) => {
    t.getSystem().broadcastOn([JB], {});
  };
  var XU = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    hideAllExclusive: e$,
    setComponents: (t, a, c, f) => {
      c.getTooltip().each((g) => {
        g.getSystem().isConnected() && No.set(g, f);
      });
    }
  }), QU = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, a) => {
      const c = (w) => {
        a.getTooltip().each((T) => {
          T.getSystem().isConnected() && ($m(T), t.onHide(w, T), a.clearTooltip());
        }), a.clearTimer();
      }, f = (w) => {
        if (!a.isShowing()) {
          e$(w);
          const T = t.lazySink(w).getOrDie(), A = w.getSystem().build({
            dom: t.tooltipDom,
            components: t.tooltipComponents,
            events: js(t.mode === "normal" ? [
              It(Bf(), (F) => {
                tr(w, zC);
              }),
              It(wd(), (F) => {
                tr(w, VC);
              })
            ] : []),
            behaviours: Qt([No.config({})])
          });
          a.setTooltip(A), Gf(T, A), t.onShow(w, A), tl.position(T, A, { anchor: t.anchor(w) });
        }
      }, g = (w) => {
        a.getTooltip().each((T) => {
          const A = t.lazySink(w).getOrDie();
          tl.position(A, T, { anchor: t.anchor(w) });
        });
      }, x = () => {
        switch (t.mode) {
          case "normal":
            return [
              It(Xd(), (w) => {
                tr(w, cT);
              }),
              It(kp(), (w) => {
                tr(w, lT);
              }),
              It(Bf(), (w) => {
                tr(w, zC);
              }),
              It(wd(), (w) => {
                tr(w, VC);
              })
            ];
          case "follow-highlight":
            return [
              It(Ep(), (w, T) => {
                tr(w, zC);
              }),
              It(Wh(), (w) => {
                tr(w, VC);
              })
            ];
          case "children-normal":
            return [
              It(Xd(), (w, T) => {
                ic(w.element).each((A) => {
                  vs(T.event.target, "[data-mce-tooltip]") && a.getTooltip().fold(() => {
                    tr(w, cT);
                  }, (F) => {
                    a.isShowing() && (t.onShow(w, F), g(w));
                  });
                });
              }),
              It(kp(), (w) => {
                ic(w.element).fold(() => {
                  tr(w, lT);
                }, G);
              }),
              It(Bf(), (w) => {
                ss(w.element, "[data-mce-tooltip]:hover").each((T) => {
                  a.getTooltip().fold(() => {
                    tr(w, zC);
                  }, (A) => {
                    a.isShowing() && (t.onShow(w, A), g(w));
                  });
                });
              }),
              It(wd(), (w) => {
                ss(w.element, "[data-mce-tooltip]:hover").fold(() => {
                  tr(w, VC);
                }, G);
              })
            ];
          default:
            return [
              It(Xd(), (w, T) => {
                ic(w.element).each((A) => {
                  vs(T.event.target, "[data-mce-tooltip]") && a.getTooltip().fold(() => {
                    tr(w, cT);
                  }, (F) => {
                    a.isShowing() && (t.onShow(w, F), g(w));
                  });
                });
              }),
              It(kp(), (w) => {
                ic(w.element).fold(() => {
                  tr(w, lT);
                }, G);
              })
            ];
        }
      };
      return js(en([
        [
          It(zC, (w) => {
            a.resetTimer(() => {
              f(w);
            }, t.delayForShow());
          }),
          It(VC, (w) => {
            a.resetTimer(() => {
              c(w);
            }, t.delayForHide());
          }),
          It(cT, (w) => {
            a.resetTimer(() => {
              f(w);
            }, 0);
          }),
          It(lT, (w) => {
            a.resetTimer(() => {
              c(w);
            }, 0);
          }),
          It(Hu(), (w, T) => {
            const A = T;
            A.universal || jt(A.channels, JB) && c(w);
          }),
          zf((w) => {
            c(w);
          })
        ],
        x()
      ]));
    }
  }), JU = [
    Rt("lazySink"),
    Rt("tooltipDom"),
    Qe("exclusive", !0),
    Qe("tooltipComponents", []),
    Ca("delayForShow", te(300)),
    Ca("delayForHide", te(300)),
    fu("mode", "normal", [
      "normal",
      "follow-highlight",
      "children-keyboard-focus",
      "children-normal"
    ]),
    Qe("anchor", (t) => ({
      type: "hotspot",
      hotspot: t,
      layouts: {
        onLtr: te([
          ti,
          Ci,
          di,
          fi,
          ei,
          xs
        ]),
        onRtl: te([
          ti,
          Ci,
          di,
          fi,
          ei,
          xs
        ])
      },
      bubble: _d(0, -2, {})
    })),
    Rr("onHide"),
    Rr("onShow")
  ], CD = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = ms(), a = ms(), c = () => {
        t.on(clearTimeout);
      }, f = (x, w) => {
        c(), t.set(setTimeout(x, w));
      }, g = te("not-implemented");
      return Wc({
        getTooltip: a.get,
        isShowing: a.isSet,
        setTooltip: a.set,
        clearTooltip: a.clear,
        clearTimer: c,
        resetTimer: f,
        readState: g
      });
    }
  });
  const gl = Xi({
    fields: JU,
    name: "tooltipping",
    active: QU,
    state: CD,
    apis: XU
  }), { entries: t$, setPrototypeOf: n$, isFrozen: o$, getPrototypeOf: eW, getOwnPropertyDescriptor: tW } = Object;
  let { freeze: Xu, seal: Um, create: nW } = Object, { apply: SD, construct: jC } = typeof Reflect < "u" && Reflect;
  SD || (SD = function(a, c, f) {
    return a.apply(c, f);
  }), Xu || (Xu = function(a) {
    return a;
  }), Um || (Um = function(a) {
    return a;
  }), jC || (jC = function(a, c) {
    return new a(...c);
  });
  const oW = Jf(Array.prototype.forEach), rW = Jf(Array.prototype.pop), UC = Jf(Array.prototype.push), uT = Jf(String.prototype.toLowerCase), kD = Jf(String.prototype.toString), sW = Jf(String.prototype.match), Wm = Jf(String.prototype.replace), aW = Jf(String.prototype.indexOf), iW = Jf(String.prototype.trim), mf = Jf(RegExp.prototype.test), WC = lW(TypeError);
  function Jf(t) {
    return function(a) {
      for (var c = arguments.length, f = new Array(c > 1 ? c - 1 : 0), g = 1; g < c; g++)
        f[g - 1] = arguments[g];
      return SD(t, a, f);
    };
  }
  function lW(t) {
    return function() {
      for (var a = arguments.length, c = new Array(a), f = 0; f < a; f++)
        c[f] = arguments[f];
      return jC(t, c);
    };
  }
  function hs(t, a, c) {
    var f;
    c = (f = c) !== null && f !== void 0 ? f : uT, n$ && n$(t, null);
    let g = a.length;
    for (; g--; ) {
      let x = a[g];
      if (typeof x == "string") {
        const w = c(x);
        w !== x && (o$(a) || (a[g] = w), x = w);
      }
      t[x] = !0;
    }
    return t;
  }
  function fx(t) {
    const a = nW(null);
    for (const [c, f] of t$(t))
      a[c] = f;
    return a;
  }
  function mx(t, a) {
    for (; t !== null; ) {
      const f = tW(t, a);
      if (f) {
        if (f.get)
          return Jf(f.get);
        if (typeof f.value == "function")
          return Jf(f.value);
      }
      t = eW(t);
    }
    function c(f) {
      return console.warn("fallback value for", f), null;
    }
    return c;
  }
  const r$ = Xu([
    "a",
    "abbr",
    "acronym",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "bdi",
    "bdo",
    "big",
    "blink",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "center",
    "cite",
    "code",
    "col",
    "colgroup",
    "content",
    "data",
    "datalist",
    "dd",
    "decorator",
    "del",
    "details",
    "dfn",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "element",
    "em",
    "fieldset",
    "figcaption",
    "figure",
    "font",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meter",
    "nav",
    "nobr",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "section",
    "select",
    "shadow",
    "small",
    "source",
    "spacer",
    "span",
    "strike",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "track",
    "tt",
    "u",
    "ul",
    "var",
    "video",
    "wbr"
  ]), _D = Xu([
    "svg",
    "a",
    "altglyph",
    "altglyphdef",
    "altglyphitem",
    "animatecolor",
    "animatemotion",
    "animatetransform",
    "circle",
    "clippath",
    "defs",
    "desc",
    "ellipse",
    "filter",
    "font",
    "g",
    "glyph",
    "glyphref",
    "hkern",
    "image",
    "line",
    "lineargradient",
    "marker",
    "mask",
    "metadata",
    "mpath",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialgradient",
    "rect",
    "stop",
    "style",
    "switch",
    "symbol",
    "text",
    "textpath",
    "title",
    "tref",
    "tspan",
    "view",
    "vkern"
  ]), ED = Xu([
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence"
  ]), s$ = Xu([
    "animate",
    "color-profile",
    "cursor",
    "discard",
    "font-face",
    "font-face-format",
    "font-face-name",
    "font-face-src",
    "font-face-uri",
    "foreignobject",
    "hatch",
    "hatchpath",
    "mesh",
    "meshgradient",
    "meshpatch",
    "meshrow",
    "missing-glyph",
    "script",
    "set",
    "solidcolor",
    "unknown",
    "use"
  ]), TD = Xu([
    "math",
    "menclose",
    "merror",
    "mfenced",
    "mfrac",
    "mglyph",
    "mi",
    "mlabeledtr",
    "mmultiscripts",
    "mn",
    "mo",
    "mover",
    "mpadded",
    "mphantom",
    "mroot",
    "mrow",
    "ms",
    "mspace",
    "msqrt",
    "mstyle",
    "msub",
    "msup",
    "msubsup",
    "mtable",
    "mtd",
    "mtext",
    "mtr",
    "munder",
    "munderover",
    "mprescripts"
  ]), OD = Xu([
    "maction",
    "maligngroup",
    "malignmark",
    "mlongdiv",
    "mscarries",
    "mscarry",
    "msgroup",
    "mstack",
    "msline",
    "msrow",
    "semantics",
    "annotation",
    "annotation-xml",
    "mprescripts",
    "none"
  ]), dT = Xu(["#text"]), AD = Xu([
    "accept",
    "action",
    "align",
    "alt",
    "autocapitalize",
    "autocomplete",
    "autopictureinpicture",
    "autoplay",
    "background",
    "bgcolor",
    "border",
    "capture",
    "cellpadding",
    "cellspacing",
    "checked",
    "cite",
    "class",
    "clear",
    "color",
    "cols",
    "colspan",
    "controls",
    "controlslist",
    "coords",
    "crossorigin",
    "datetime",
    "decoding",
    "default",
    "dir",
    "disabled",
    "disablepictureinpicture",
    "disableremoteplayback",
    "download",
    "draggable",
    "enctype",
    "enterkeyhint",
    "face",
    "for",
    "headers",
    "height",
    "hidden",
    "high",
    "href",
    "hreflang",
    "id",
    "inputmode",
    "integrity",
    "ismap",
    "kind",
    "label",
    "lang",
    "list",
    "loading",
    "loop",
    "low",
    "max",
    "maxlength",
    "media",
    "method",
    "min",
    "minlength",
    "multiple",
    "muted",
    "name",
    "nonce",
    "noshade",
    "novalidate",
    "nowrap",
    "open",
    "optimum",
    "pattern",
    "placeholder",
    "playsinline",
    "poster",
    "preload",
    "pubdate",
    "radiogroup",
    "readonly",
    "rel",
    "required",
    "rev",
    "reversed",
    "role",
    "rows",
    "rowspan",
    "spellcheck",
    "scope",
    "selected",
    "shape",
    "size",
    "sizes",
    "span",
    "srclang",
    "start",
    "src",
    "srcset",
    "step",
    "style",
    "summary",
    "tabindex",
    "title",
    "translate",
    "type",
    "usemap",
    "valign",
    "value",
    "width",
    "xmlns",
    "slot"
  ]), ZC = Xu([
    "accent-height",
    "accumulate",
    "additive",
    "alignment-baseline",
    "ascent",
    "attributename",
    "attributetype",
    "azimuth",
    "basefrequency",
    "baseline-shift",
    "begin",
    "bias",
    "by",
    "class",
    "clip",
    "clippathunits",
    "clip-path",
    "clip-rule",
    "color",
    "color-interpolation",
    "color-interpolation-filters",
    "color-profile",
    "color-rendering",
    "cx",
    "cy",
    "d",
    "dx",
    "dy",
    "diffuseconstant",
    "direction",
    "display",
    "divisor",
    "dur",
    "edgemode",
    "elevation",
    "end",
    "fill",
    "fill-opacity",
    "fill-rule",
    "filter",
    "filterunits",
    "flood-color",
    "flood-opacity",
    "font-family",
    "font-size",
    "font-size-adjust",
    "font-stretch",
    "font-style",
    "font-variant",
    "font-weight",
    "fx",
    "fy",
    "g1",
    "g2",
    "glyph-name",
    "glyphref",
    "gradientunits",
    "gradienttransform",
    "height",
    "href",
    "id",
    "image-rendering",
    "in",
    "in2",
    "k",
    "k1",
    "k2",
    "k3",
    "k4",
    "kerning",
    "keypoints",
    "keysplines",
    "keytimes",
    "lang",
    "lengthadjust",
    "letter-spacing",
    "kernelmatrix",
    "kernelunitlength",
    "lighting-color",
    "local",
    "marker-end",
    "marker-mid",
    "marker-start",
    "markerheight",
    "markerunits",
    "markerwidth",
    "maskcontentunits",
    "maskunits",
    "max",
    "mask",
    "media",
    "method",
    "mode",
    "min",
    "name",
    "numoctaves",
    "offset",
    "operator",
    "opacity",
    "order",
    "orient",
    "orientation",
    "origin",
    "overflow",
    "paint-order",
    "path",
    "pathlength",
    "patterncontentunits",
    "patterntransform",
    "patternunits",
    "points",
    "preservealpha",
    "preserveaspectratio",
    "primitiveunits",
    "r",
    "rx",
    "ry",
    "radius",
    "refx",
    "refy",
    "repeatcount",
    "repeatdur",
    "restart",
    "result",
    "rotate",
    "scale",
    "seed",
    "shape-rendering",
    "specularconstant",
    "specularexponent",
    "spreadmethod",
    "startoffset",
    "stddeviation",
    "stitchtiles",
    "stop-color",
    "stop-opacity",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke",
    "stroke-width",
    "style",
    "surfacescale",
    "systemlanguage",
    "tabindex",
    "targetx",
    "targety",
    "transform",
    "transform-origin",
    "text-anchor",
    "text-decoration",
    "text-rendering",
    "textlength",
    "type",
    "u1",
    "u2",
    "unicode",
    "values",
    "viewbox",
    "visibility",
    "version",
    "vert-adv-y",
    "vert-origin-x",
    "vert-origin-y",
    "width",
    "word-spacing",
    "wrap",
    "writing-mode",
    "xchannelselector",
    "ychannelselector",
    "x",
    "x1",
    "x2",
    "xmlns",
    "y",
    "y1",
    "y2",
    "z",
    "zoomandpan"
  ]), GC = Xu([
    "accent",
    "accentunder",
    "align",
    "bevelled",
    "close",
    "columnsalign",
    "columnlines",
    "columnspan",
    "denomalign",
    "depth",
    "dir",
    "display",
    "displaystyle",
    "encoding",
    "fence",
    "frame",
    "height",
    "href",
    "id",
    "largeop",
    "length",
    "linethickness",
    "lspace",
    "lquote",
    "mathbackground",
    "mathcolor",
    "mathsize",
    "mathvariant",
    "maxsize",
    "minsize",
    "movablelimits",
    "notation",
    "numalign",
    "open",
    "rowalign",
    "rowlines",
    "rowspacing",
    "rowspan",
    "rspace",
    "rquote",
    "scriptlevel",
    "scriptminsize",
    "scriptsizemultiplier",
    "selection",
    "separator",
    "separators",
    "stretchy",
    "subscriptshift",
    "supscriptshift",
    "symmetric",
    "voffset",
    "width",
    "xmlns"
  ]), qC = Xu([
    "xlink:href",
    "xml:id",
    "xlink:title",
    "xml:space",
    "xmlns:xlink"
  ]), nh = Um(/\{\{[\w\W]*|[\w\W]*\}\}/gm), PD = Um(/<%[\w\W]*|[\w\W]*%>/gm), cW = Um(/\${[\w\W]*}/gm), uW = Um(/^data-[\-\w.\u00B7-\uFFFF]/), dW = Um(/^aria-[\-\w]+$/), a$ = Um(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), KC = Um(/^(?:\w+script|data):/i), fW = Um(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), DD = Um(/^html$/i);
  var fT = Object.freeze({
    __proto__: null,
    MUSTACHE_EXPR: nh,
    ERB_EXPR: PD,
    TMPLIT_EXPR: cW,
    DATA_ATTR: uW,
    ARIA_ATTR: dW,
    IS_ALLOWED_URI: a$,
    IS_SCRIPT_OR_DATA: KC,
    ATTR_WHITESPACE: fW,
    DOCTYPE_NAME: DD
  });
  const mW = () => typeof window > "u" ? null : window, RD = function(a, c) {
    if (typeof a != "object" || typeof a.createPolicy != "function")
      return null;
    let f = null;
    const g = "data-tt-policy-suffix";
    c && c.hasAttribute(g) && (f = c.getAttribute(g));
    const x = "dompurify" + (f ? "#" + f : "");
    try {
      return a.createPolicy(x, {
        createHTML(w) {
          return w;
        },
        createScriptURL(w) {
          return w;
        }
      });
    } catch {
      return console.warn("TrustedTypes policy " + x + " could not be created."), null;
    }
  };
  function mT() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : mW();
    const a = (Pr) => mT(Pr);
    if (a.version = "3.0.5", a.removed = [], !t || !t.document || t.document.nodeType !== 9)
      return a.isSupported = !1, a;
    const c = t.document, f = c.currentScript;
    let { document: g } = t;
    const { DocumentFragment: x, HTMLTemplateElement: w, Node: T, Element: A, NodeFilter: F, NamedNodeMap: H = t.NamedNodeMap || t.MozNamedAttrMap, HTMLFormElement: q, DOMParser: ne, trustedTypes: ie } = t, fe = A.prototype, _e = mx(fe, "cloneNode"), st = mx(fe, "nextSibling"), De = mx(fe, "childNodes"), Je = mx(fe, "parentNode");
    if (typeof w == "function") {
      const Pr = g.createElement("template");
      Pr.content && Pr.content.ownerDocument && (g = Pr.content.ownerDocument);
    }
    let Ge, Ft = "";
    const { implementation: gt, createNodeIterator: Jt, createDocumentFragment: vn, getElementsByTagName: Nt } = g, { importNode: Yn } = c;
    let In = {};
    a.isSupported = typeof t$ == "function" && typeof Je == "function" && gt && gt.createHTMLDocument !== void 0;
    const { MUSTACHE_EXPR: xo, ERB_EXPR: fo, TMPLIT_EXPR: Gr, DATA_ATTR: Hr, ARIA_ATTR: br, IS_SCRIPT_OR_DATA: cn, ATTR_WHITESPACE: Un } = fT;
    let { IS_ALLOWED_URI: jo } = fT, So = null;
    const go = hs({}, [
      ...r$,
      ..._D,
      ...ED,
      ...TD,
      ...dT
    ]);
    let Lo = null;
    const Os = hs({}, [
      ...AD,
      ...ZC,
      ...GC,
      ...qC
    ]);
    let Qr = Object.seal(Object.create(null, {
      tagNameCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      },
      attributeNameCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: !1
      }
    })), gc = null, Fd = null, ep = !0, Wl = !0, Bd = !1, _f = !0, Eu = !1, hh = !1, u0 = !1, uI = !1, tw = !1, HA = !1, i9 = !1, mie = !0, pie = !1;
    const Ahe = "user-content-";
    let Xee = !0, dI = !1, zA = {}, VA = null;
    const hie = hs({}, [
      "annotation-xml",
      "audio",
      "colgroup",
      "desc",
      "foreignobject",
      "head",
      "iframe",
      "math",
      "mi",
      "mn",
      "mo",
      "ms",
      "mtext",
      "noembed",
      "noframes",
      "noscript",
      "plaintext",
      "script",
      "style",
      "svg",
      "template",
      "thead",
      "title",
      "video",
      "xmp"
    ]);
    let gie = null;
    const bie = hs({}, [
      "audio",
      "video",
      "img",
      "source",
      "image",
      "track"
    ]);
    let Qee = null;
    const vie = hs({}, [
      "alt",
      "class",
      "for",
      "id",
      "label",
      "name",
      "pattern",
      "placeholder",
      "role",
      "summary",
      "title",
      "value",
      "style",
      "xmlns"
    ]), l9 = "http://www.w3.org/1998/Math/MathML", c9 = "http://www.w3.org/2000/svg", d0 = "http://www.w3.org/1999/xhtml";
    let jA = d0, Jee = !1, ete = null;
    const Phe = hs({}, [
      l9,
      c9,
      d0
    ], kD);
    let lk;
    const Dhe = [
      "application/xhtml+xml",
      "text/html"
    ], Rhe = "text/html";
    let Tu, UA = null;
    const Nhe = g.createElement("form"), yie = function(Et) {
      return Et instanceof RegExp || Et instanceof Function;
    }, tte = function(Et) {
      if (!(UA && UA === Et)) {
        if ((!Et || typeof Et != "object") && (Et = {}), Et = fx(Et), lk = Dhe.indexOf(Et.PARSER_MEDIA_TYPE) === -1 ? lk = Rhe : lk = Et.PARSER_MEDIA_TYPE, Tu = lk === "application/xhtml+xml" ? kD : uT, So = "ALLOWED_TAGS" in Et ? hs({}, Et.ALLOWED_TAGS, Tu) : go, Lo = "ALLOWED_ATTR" in Et ? hs({}, Et.ALLOWED_ATTR, Tu) : Os, ete = "ALLOWED_NAMESPACES" in Et ? hs({}, Et.ALLOWED_NAMESPACES, kD) : Phe, Qee = "ADD_URI_SAFE_ATTR" in Et ? hs(fx(vie), Et.ADD_URI_SAFE_ATTR, Tu) : vie, gie = "ADD_DATA_URI_TAGS" in Et ? hs(fx(bie), Et.ADD_DATA_URI_TAGS, Tu) : bie, VA = "FORBID_CONTENTS" in Et ? hs({}, Et.FORBID_CONTENTS, Tu) : hie, gc = "FORBID_TAGS" in Et ? hs({}, Et.FORBID_TAGS, Tu) : {}, Fd = "FORBID_ATTR" in Et ? hs({}, Et.FORBID_ATTR, Tu) : {}, zA = "USE_PROFILES" in Et ? Et.USE_PROFILES : !1, ep = Et.ALLOW_ARIA_ATTR !== !1, Wl = Et.ALLOW_DATA_ATTR !== !1, Bd = Et.ALLOW_UNKNOWN_PROTOCOLS || !1, _f = Et.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Eu = Et.SAFE_FOR_TEMPLATES || !1, hh = Et.WHOLE_DOCUMENT || !1, tw = Et.RETURN_DOM || !1, HA = Et.RETURN_DOM_FRAGMENT || !1, i9 = Et.RETURN_TRUSTED_TYPE || !1, uI = Et.FORCE_BODY || !1, mie = Et.SANITIZE_DOM !== !1, pie = Et.SANITIZE_NAMED_PROPS || !1, Xee = Et.KEEP_CONTENT !== !1, dI = Et.IN_PLACE || !1, jo = Et.ALLOWED_URI_REGEXP || a$, jA = Et.NAMESPACE || d0, Qr = Et.CUSTOM_ELEMENT_HANDLING || {}, Et.CUSTOM_ELEMENT_HANDLING && yie(Et.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Qr.tagNameCheck = Et.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Et.CUSTOM_ELEMENT_HANDLING && yie(Et.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Qr.attributeNameCheck = Et.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Et.CUSTOM_ELEMENT_HANDLING && typeof Et.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Qr.allowCustomizedBuiltInElements = Et.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Eu && (Wl = !1), HA && (tw = !0), zA && (So = hs({}, [...dT]), Lo = [], zA.html === !0 && (hs(So, r$), hs(Lo, AD)), zA.svg === !0 && (hs(So, _D), hs(Lo, ZC), hs(Lo, qC)), zA.svgFilters === !0 && (hs(So, ED), hs(Lo, ZC), hs(Lo, qC)), zA.mathMl === !0 && (hs(So, TD), hs(Lo, GC), hs(Lo, qC))), Et.ADD_TAGS && (So === go && (So = fx(So)), hs(So, Et.ADD_TAGS, Tu)), Et.ADD_ATTR && (Lo === Os && (Lo = fx(Lo)), hs(Lo, Et.ADD_ATTR, Tu)), Et.ADD_URI_SAFE_ATTR && hs(Qee, Et.ADD_URI_SAFE_ATTR, Tu), Et.FORBID_CONTENTS && (VA === hie && (VA = fx(VA)), hs(VA, Et.FORBID_CONTENTS, Tu)), Xee && (So["#text"] = !0), hh && hs(So, [
          "html",
          "head",
          "body"
        ]), So.table && (hs(So, ["tbody"]), delete gc.tbody), Et.TRUSTED_TYPES_POLICY) {
          if (typeof Et.TRUSTED_TYPES_POLICY.createHTML != "function")
            throw WC('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
          if (typeof Et.TRUSTED_TYPES_POLICY.createScriptURL != "function")
            throw WC('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
          Ge = Et.TRUSTED_TYPES_POLICY, Ft = Ge.createHTML("");
        } else
          Ge === void 0 && (Ge = RD(ie, f)), Ge !== null && typeof Ft == "string" && (Ft = Ge.createHTML(""));
        Xu && Xu(Et), UA = Et;
      }
    }, xie = hs({}, [
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext"
    ]), wie = hs({}, [
      "foreignobject",
      "desc",
      "title",
      "annotation-xml"
    ]), Mhe = hs({}, [
      "title",
      "style",
      "font",
      "a",
      "script"
    ]), u9 = hs({}, _D);
    hs(u9, ED), hs(u9, s$);
    const nte = hs({}, TD);
    hs(nte, OD);
    const Ihe = function(Et) {
      let ao = Je(Et);
      (!ao || !ao.tagName) && (ao = {
        namespaceURI: jA,
        tagName: "template"
      });
      const Fo = uT(Et.tagName), hi = uT(ao.tagName);
      return ete[Et.namespaceURI] ? Et.namespaceURI === c9 ? ao.namespaceURI === d0 ? Fo === "svg" : ao.namespaceURI === l9 ? Fo === "svg" && (hi === "annotation-xml" || xie[hi]) : !!u9[Fo] : Et.namespaceURI === l9 ? ao.namespaceURI === d0 ? Fo === "math" : ao.namespaceURI === c9 ? Fo === "math" && wie[hi] : !!nte[Fo] : Et.namespaceURI === d0 ? ao.namespaceURI === c9 && !wie[hi] || ao.namespaceURI === l9 && !xie[hi] ? !1 : !nte[Fo] && (Mhe[Fo] || !u9[Fo]) : !!(lk === "application/xhtml+xml" && ete[Et.namespaceURI]) : !1;
    }, ck = function(Et) {
      UC(a.removed, { element: Et });
      try {
        Et.parentNode.removeChild(Et);
      } catch {
        Et.remove();
      }
    }, fI = function(Et, ao) {
      try {
        UC(a.removed, {
          attribute: ao.getAttributeNode(Et),
          from: ao
        });
      } catch {
        UC(a.removed, {
          attribute: null,
          from: ao
        });
      }
      if (ao.removeAttribute(Et), Et === "is" && !Lo[Et])
        if (tw || HA)
          try {
            ck(ao);
          } catch {
          }
        else
          try {
            ao.setAttribute(Et, "");
          } catch {
          }
    }, Cie = function(Et) {
      let ao, Fo;
      if (uI)
        Et = "<remove></remove>" + Et;
      else {
        const gh = sW(Et, /^[\r\n\t ]+/);
        Fo = gh && gh[0];
      }
      lk === "application/xhtml+xml" && jA === d0 && (Et = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Et + "</body></html>");
      const hi = Ge ? Ge.createHTML(Et) : Et;
      if (jA === d0)
        try {
          ao = new ne().parseFromString(hi, lk);
        } catch {
        }
      if (!ao || !ao.documentElement) {
        ao = gt.createDocument(jA, "template", null);
        try {
          ao.documentElement.innerHTML = Jee ? Ft : hi;
        } catch {
        }
      }
      const Ou = ao.body || ao.documentElement;
      return Et && Fo && Ou.insertBefore(g.createTextNode(Fo), Ou.childNodes[0] || null), jA === d0 ? Nt.call(ao, hh ? "html" : "body")[0] : hh ? ao.documentElement : Ou;
    }, Sie = function(Et) {
      return Jt.call(Et.ownerDocument || Et, Et, F.SHOW_ELEMENT | F.SHOW_COMMENT | F.SHOW_TEXT, null, !1);
    }, Fhe = function(Et) {
      return Et instanceof q && (typeof Et.nodeName != "string" || typeof Et.textContent != "string" || typeof Et.removeChild != "function" || !(Et.attributes instanceof H) || typeof Et.removeAttribute != "function" || typeof Et.setAttribute != "function" || typeof Et.namespaceURI != "string" || typeof Et.insertBefore != "function" || typeof Et.hasChildNodes != "function");
    }, d9 = function(Et) {
      return typeof T == "object" ? Et instanceof T : Et && typeof Et == "object" && typeof Et.nodeType == "number" && typeof Et.nodeName == "string";
    }, f0 = function(Et, ao, Fo) {
      In[Et] && oW(In[Et], (hi) => {
        hi.call(a, ao, Fo, UA);
      });
    }, kie = function(Et) {
      let ao;
      if (f0("beforeSanitizeElements", Et, null), Fhe(Et))
        return ck(Et), !0;
      const Fo = Tu(Et.nodeName);
      if (f0("uponSanitizeElement", Et, {
        tagName: Fo,
        allowedTags: So
      }), Et.hasChildNodes() && !d9(Et.firstElementChild) && (!d9(Et.content) || !d9(Et.content.firstElementChild)) && mf(/<[/\w]/g, Et.innerHTML) && mf(/<[/\w]/g, Et.textContent))
        return ck(Et), !0;
      if (!So[Fo] || gc[Fo]) {
        if (!gc[Fo] && Eie(Fo) && (Qr.tagNameCheck instanceof RegExp && mf(Qr.tagNameCheck, Fo) || Qr.tagNameCheck instanceof Function && Qr.tagNameCheck(Fo)))
          return !1;
        if (Xee && !VA[Fo]) {
          const hi = Je(Et) || Et.parentNode, Ou = De(Et) || Et.childNodes;
          if (Ou && hi) {
            const gh = Ou.length;
            for (let Nl = gh - 1; Nl >= 0; --Nl)
              hi.insertBefore(_e(Ou[Nl], !0), st(Et));
          }
        }
        return ck(Et), !0;
      }
      return Et instanceof A && !Ihe(Et) || (Fo === "noscript" || Fo === "noembed" || Fo === "noframes") && mf(/<\/no(script|embed|frames)/i, Et.innerHTML) ? (ck(Et), !0) : (Eu && Et.nodeType === 3 && (ao = Et.textContent, ao = Wm(ao, xo, " "), ao = Wm(ao, fo, " "), ao = Wm(ao, Gr, " "), Et.textContent !== ao && (UC(a.removed, { element: Et.cloneNode() }), Et.textContent = ao)), f0("afterSanitizeElements", Et, null), !1);
    }, _ie = function(Et, ao, Fo) {
      if (mie && (ao === "id" || ao === "name") && (Fo in g || Fo in Nhe))
        return !1;
      if (!(Wl && !Fd[ao] && mf(Hr, ao))) {
        if (!(ep && mf(br, ao))) {
          if (!Lo[ao] || Fd[ao]) {
            if (!(Eie(Et) && (Qr.tagNameCheck instanceof RegExp && mf(Qr.tagNameCheck, Et) || Qr.tagNameCheck instanceof Function && Qr.tagNameCheck(Et)) && (Qr.attributeNameCheck instanceof RegExp && mf(Qr.attributeNameCheck, ao) || Qr.attributeNameCheck instanceof Function && Qr.attributeNameCheck(ao)) || ao === "is" && Qr.allowCustomizedBuiltInElements && (Qr.tagNameCheck instanceof RegExp && mf(Qr.tagNameCheck, Fo) || Qr.tagNameCheck instanceof Function && Qr.tagNameCheck(Fo)))) return !1;
          } else if (!Qee[ao]) {
            if (!mf(jo, Wm(Fo, Un, ""))) {
              if (!((ao === "src" || ao === "xlink:href" || ao === "href") && Et !== "script" && aW(Fo, "data:") === 0 && gie[Et])) {
                if (!(Bd && !mf(cn, Wm(Fo, Un, "")))) {
                  if (Fo)
                    return !1;
                }
              }
            }
          }
        }
      }
      return !0;
    }, Eie = function(Et) {
      return Et.indexOf("-") > 0;
    }, Tie = function(Et) {
      let ao, Fo, hi, Ou;
      f0("beforeSanitizeAttributes", Et, null);
      const { attributes: gh } = Et;
      if (!gh)
        return;
      const Nl = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: Lo
      };
      for (Ou = gh.length; Ou--; ) {
        ao = gh[Ou];
        const { name: bh, namespaceURI: ote } = ao;
        Fo = bh === "value" ? ao.value : iW(ao.value);
        const $he = Fo;
        if (hi = Tu(bh), Nl.attrName = hi, Nl.attrValue = Fo, Nl.keepAttr = !0, Nl.forceKeepAttr = void 0, f0("uponSanitizeAttribute", Et, Nl), Fo = Nl.attrValue, Nl.forceKeepAttr)
          continue;
        if (!Nl.keepAttr) {
          fI(bh, Et);
          continue;
        }
        if (!_f && mf(/\/>/i, Fo)) {
          fI(bh, Et);
          continue;
        }
        Eu && (Fo = Wm(Fo, xo, " "), Fo = Wm(Fo, fo, " "), Fo = Wm(Fo, Gr, " "));
        const Oie = Tu(Et.nodeName);
        if (!_ie(Oie, hi, Fo)) {
          fI(bh, Et);
          continue;
        }
        if (pie && (hi === "id" || hi === "name") && (fI(bh, Et), Fo = Ahe + Fo), Ge && typeof ie == "object" && typeof ie.getAttributeType == "function" && !ote)
          switch (ie.getAttributeType(Oie, hi)) {
            case "TrustedHTML": {
              Fo = Ge.createHTML(Fo);
              break;
            }
            case "TrustedScriptURL": {
              Fo = Ge.createScriptURL(Fo);
              break;
            }
          }
        if (Fo !== $he)
          try {
            ote ? Et.setAttributeNS(ote, bh, Fo) : Et.setAttribute(bh, Fo);
          } catch {
            fI(bh, Et);
          }
      }
      f0("afterSanitizeAttributes", Et, null);
    }, Bhe = function Pr(Et) {
      let ao;
      const Fo = Sie(Et);
      for (f0("beforeSanitizeShadowDOM", Et, null); ao = Fo.nextNode(); )
        f0("uponSanitizeShadowNode", ao, null), !kie(ao) && (ao.content instanceof x && Pr(ao.content), Tie(ao));
      f0("afterSanitizeShadowDOM", Et, null);
    };
    return a.sanitize = function(Pr) {
      let Et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ao, Fo, hi, Ou;
      if (Jee = !Pr, Jee && (Pr = "<!-->"), typeof Pr != "string" && !d9(Pr))
        if (typeof Pr.toString == "function") {
          if (Pr = Pr.toString(), typeof Pr != "string")
            throw WC("dirty is not a string, aborting");
        } else
          throw WC("toString is not a function");
      if (!a.isSupported)
        return Pr;
      if (u0 || tte(Et), a.removed = [], typeof Pr == "string" && (dI = !1), dI) {
        if (Pr.nodeName) {
          const bh = Tu(Pr.nodeName);
          if (!So[bh] || gc[bh])
            throw WC("root node is forbidden and cannot be sanitized in-place");
        }
      } else if (Pr instanceof T)
        ao = Cie("<!---->"), Fo = ao.ownerDocument.importNode(Pr, !0), Fo.nodeType === 1 && Fo.nodeName === "BODY" || Fo.nodeName === "HTML" ? ao = Fo : ao.appendChild(Fo);
      else {
        if (!tw && !Eu && !hh && Pr.indexOf("<") === -1)
          return Ge && i9 ? Ge.createHTML(Pr) : Pr;
        if (ao = Cie(Pr), !ao)
          return tw ? null : i9 ? Ft : "";
      }
      ao && uI && ck(ao.firstChild);
      const gh = Sie(dI ? Pr : ao);
      for (; hi = gh.nextNode(); )
        kie(hi) || (hi.content instanceof x && Bhe(hi.content), Tie(hi));
      if (dI)
        return Pr;
      if (tw) {
        if (HA)
          for (Ou = vn.call(ao.ownerDocument); ao.firstChild; )
            Ou.appendChild(ao.firstChild);
        else
          Ou = ao;
        return (Lo.shadowroot || Lo.shadowrootmode) && (Ou = Yn.call(c, Ou, !0)), Ou;
      }
      let Nl = hh ? ao.outerHTML : ao.innerHTML;
      return hh && So["!doctype"] && ao.ownerDocument && ao.ownerDocument.doctype && ao.ownerDocument.doctype.name && mf(DD, ao.ownerDocument.doctype.name) && (Nl = "<!DOCTYPE " + ao.ownerDocument.doctype.name + `>
` + Nl), Eu && (Nl = Wm(Nl, xo, " "), Nl = Wm(Nl, fo, " "), Nl = Wm(Nl, Gr, " ")), Ge && i9 ? Ge.createHTML(Nl) : Nl;
    }, a.setConfig = function(Pr) {
      tte(Pr), u0 = !0;
    }, a.clearConfig = function() {
      UA = null, u0 = !1;
    }, a.isValidAttribute = function(Pr, Et, ao) {
      UA || tte({});
      const Fo = Tu(Pr), hi = Tu(Et);
      return _ie(Fo, hi, ao);
    }, a.addHook = function(Pr, Et) {
      typeof Et == "function" && (In[Pr] = In[Pr] || [], UC(In[Pr], Et));
    }, a.removeHook = function(Pr) {
      if (In[Pr])
        return rW(In[Pr]);
    }, a.removeHooks = function(Pr) {
      In[Pr] && (In[Pr] = []);
    }, a.removeAllHooks = function() {
      In = {};
    }, a;
  }
  var pW = mT();
  const ND = (t) => pW().sanitize(t);
  var Ad = tinymce.util.Tools.resolve("tinymce.util.I18n");
  const hW = {
    indent: !0,
    outdent: !0,
    "table-insert-column-after": !0,
    "table-insert-column-before": !0,
    "paste-column-after": !0,
    "paste-column-before": !0,
    "unordered-list": !0,
    "list-bull-circle": !0,
    "list-bull-default": !0,
    "list-bull-square": !0
  }, i$ = "temporary-placeholder", MD = (t) => () => Ht(t, i$).getOr("!not found!"), ID = (t, a) => {
    const c = t.toLowerCase();
    if (Ad.isRtl()) {
      const f = Tn(c, "-rtl");
      return Ho(a, f) ? f : c;
    } else
      return c;
  }, l$ = (t, a) => Ht(a, ID(t, a)), c$ = (t, a) => {
    const c = a();
    return l$(t, c).getOrThunk(MD(c));
  }, u$ = (t, a, c) => {
    const f = a();
    return l$(t, f).or(c).getOrThunk(MD(f));
  }, d$ = (t) => Ad.isRtl() ? Ho(hW, t) : !1, FD = () => Go("add-focusable", [Qs((t) => {
    v2(t.element, "svg").each((a) => rn(a, "focusable", "false"));
  })]), BD = (t, a, c, f) => {
    var g, x;
    const w = d$(a) ? ["tox-icon--flip"] : [], T = Ht(c, ID(a, c)).or(f).getOrThunk(MD(c));
    return {
      dom: {
        tag: t.tag,
        attributes: (g = t.attributes) !== null && g !== void 0 ? g : {},
        classes: t.classes.concat(w),
        innerHtml: T
      },
      behaviours: Qt([
        ...(x = t.behaviours) !== null && x !== void 0 ? x : [],
        FD()
      ])
    };
  }, xu = (t, a, c, f = B.none()) => BD(a, t, c(), f), f$ = (t, a, c) => {
    const f = c(), g = At(t, (x) => Ho(f, ID(x, f)));
    return BD(a, g.getOr(i$), f, B.none());
  }, gW = {
    success: "checkmark",
    error: "warning",
    err: "error",
    warning: "warning",
    warn: "warning",
    info: "info"
  }, pT = Pc({
    name: "Notification",
    factory: (t) => {
      const a = Nn("notification-text"), c = is({
        dom: jm(`<p id=${a}>${ND(t.backstageProvider.translate(t.text))}</p>`),
        behaviours: Qt([No.config({})])
      }), f = (fe) => ({
        dom: {
          tag: "div",
          classes: ["tox-bar"],
          styles: { width: `${fe}%` }
        }
      }), g = (fe) => ({
        dom: {
          tag: "div",
          classes: ["tox-text"],
          innerHtml: `${fe}%`
        }
      }), x = is({
        dom: {
          tag: "div",
          classes: t.progress ? [
            "tox-progress-bar",
            "tox-progress-indicator"
          ] : ["tox-progress-bar"]
        },
        components: [
          {
            dom: {
              tag: "div",
              classes: ["tox-bar-container"]
            },
            components: [f(0)]
          },
          g(0)
        ],
        behaviours: Qt([No.config({})])
      }), A = {
        updateProgress: (fe, _e) => {
          fe.getSystem().isConnected() && x.getOpt(fe).each((st) => {
            No.set(st, [
              {
                dom: {
                  tag: "div",
                  classes: ["tox-bar-container"]
                },
                components: [f(_e)]
              },
              g(_e)
            ]);
          });
        },
        updateText: (fe, _e) => {
          if (fe.getSystem().isConnected()) {
            const st = c.get(fe);
            No.set(st, [Oa(_e)]);
          }
        }
      }, F = en([
        t.icon.toArray(),
        t.level.toArray(),
        t.level.bind((fe) => B.from(gW[fe])).toArray()
      ]), H = is(Rl.sketch({
        dom: {
          tag: "button",
          classes: [
            "tox-notification__dismiss",
            "tox-button",
            "tox-button--naked",
            "tox-button--icon"
          ],
          attributes: { "aria-label": t.backstageProvider.translate("Close") }
        },
        components: [xu("close", {
          tag: "span",
          classes: ["tox-icon"]
        }, t.iconProvider)],
        buttonBehaviours: Qt([
          Zs.config({}),
          gl.config({ ...t.backstageProvider.tooltips.getConfig({ tooltipText: t.backstageProvider.translate("Close") }) })
        ]),
        action: (fe) => {
          t.onAction(fe);
        }
      })), q = f$(F, {
        tag: "div",
        classes: ["tox-notification__icon"]
      }, t.iconProvider), ne = {
        dom: {
          tag: "div",
          classes: ["tox-notification__body"]
        },
        components: [c.asSpec()],
        behaviours: Qt([No.config({})])
      }, ie = [
        q,
        ne
      ];
      return {
        uid: t.uid,
        dom: {
          tag: "div",
          attributes: {
            role: "alert",
            "aria-labelledby": a
          },
          classes: t.level.map((fe) => [
            "tox-notification",
            "tox-notification--in",
            `tox-notification--${fe}`
          ]).getOr([
            "tox-notification",
            "tox-notification--in"
          ])
        },
        behaviours: Qt([
          Zs.config({}),
          Ao.config({}),
          oo.config({
            mode: "special",
            onEscape: (fe) => (t.onAction(fe), B.some(!0))
          })
        ]),
        components: ie.concat(t.progress ? [x.asSpec()] : []).concat([H.asSpec()]),
        apis: A
      };
    },
    configFields: [
      jr("level"),
      Rt("progress"),
      jr("icon"),
      Rt("onAction"),
      Rt("text"),
      Rt("iconProvider"),
      Rt("backstageProvider")
    ],
    apis: {
      updateProgress: (t, a, c) => {
        t.updateProgress(a, c);
      },
      updateText: (t, a, c) => {
        t.updateText(a, c);
      }
    }
  });
  var bW = (t, a, c, f) => {
    const g = a.backstage.shared, x = () => {
      const H = aa(He.fromDom(t.getContentAreaContainer()));
      return B.some(H);
    }, w = (H) => {
      x().each((q) => {
        mt(H, (ne) => {
          Pi(ne.element) > q.width && Ln(ne.element, "width", q.width + "px");
        });
      });
    };
    return {
      open: (H, q, ne) => {
        const ie = () => {
          const De = (gt) => {
            No.remove(gt, fe), _e();
          }, Je = (gt, Jt) => {
            $a(gt.element).length === 0 ? Ge(gt, Jt) : Ft(gt, Jt);
          }, Ge = (gt, Jt) => {
            la.hide(gt), f.clear(), Jt && t.focus();
          }, Ft = (gt, Jt) => {
            Jt && oo.focusIn(gt);
          };
          f.on((gt) => {
            q();
            const Jt = ne();
            De(gt), Je(gt, Jt);
          });
        }, fe = Al(pT.sketch({
          text: H.text,
          level: jt([
            "success",
            "error",
            "warning",
            "warn",
            "info"
          ], H.type) ? H.type : void 0,
          progress: H.progressBar === !0,
          icon: H.icon,
          onAction: ie,
          iconProvider: g.providers.icons,
          backstageProvider: g.providers
        }));
        if (f.isSet()) {
          const De = Ll(fe);
          f.on((Je) => {
            No.append(Je, De), la.reposition(Je), pa.refresh(Je), w(Je.components());
          });
        } else {
          const De = Al(la.sketch({
            dom: {
              tag: "div",
              classes: ["tox-notifications-container"],
              attributes: {
                "aria-label": "Notifications",
                role: "region"
              }
            },
            lazySink: g.getSink,
            fireDismissalEventInstead: {},
            ...g.header.isPositionedAtTop() ? {} : { fireRepositionEventInstead: {} },
            inlineBehaviours: Qt([
              oo.config({
                mode: "cyclic",
                selector: ".tox-notification, .tox-notification a, .tox-notification button"
              }),
              No.config({}),
              ...dx(t) && !g.header.isPositionedAtTop() ? [] : [pa.config({
                contextual: {
                  lazyContext: () => B.some(aa(He.fromDom(t.getContentAreaContainer()))),
                  fadeInClass: "tox-notification-container-dock-fadein",
                  fadeOutClass: "tox-notification-container-dock-fadeout",
                  transitionClass: "tox-notification-container-dock-transition"
                },
                modes: ["top"],
                lazyViewport: (gt) => Eg(t, gt.element).map((vn) => ({
                  bounds: D1(vn),
                  optScrollEnv: B.some({
                    currentScrollTop: vn.element.dom.scrollTop,
                    scrollElmTop: Ga(vn.element).top
                  })
                })).getOrThunk(() => ({
                  bounds: Ra(),
                  optScrollEnv: B.none()
                }))
              })]
            ])
          })), Je = Ll(fe), Ge = { maxHeightFunction: Eb() }, Ft = {
            ...g.anchors.banner(),
            overrides: Ge
          };
          f.set(De), c.add(De), la.showWithinBounds(De, Je, { anchor: Ft }, x);
        }
        oe(H.timeout) && H.timeout > 0 && FC.setEditorTimeout(t, () => {
          ie();
        }, H.timeout);
        const _e = () => {
          f.on((De) => {
            la.reposition(De), pa.refresh(De), w(De.components());
          });
        };
        return {
          close: ie,
          reposition: _e,
          text: (De) => {
            pT.updateText(fe, De);
          },
          settings: H,
          getEl: () => fe.element.dom,
          progressBar: {
            value: (De) => {
              pT.updateProgress(fe, De);
            }
          }
        };
      },
      close: (H) => {
        H.close();
      },
      getArgs: (H) => H.settings
    };
  };
  const m$ = { setup: (t, a) => {
    const c = (g, x) => {
      po(g, Cd(), { raw: x });
    }, f = () => t.getMenu().bind(wn.getHighlighted);
    a.on("keydown", (g) => {
      const x = g.which;
      t.isActive() && (t.isMenuOpen() ? x === 13 ? (f().each(Tp), g.preventDefault()) : x === 40 ? (f().fold(() => {
        t.getMenu().each(wn.highlightFirst);
      }, (w) => {
        c(w, g);
      }), g.preventDefault(), g.stopImmediatePropagation()) : (x === 37 || x === 38 || x === 39) && f().each((w) => {
        c(w, g), g.preventDefault(), g.stopImmediatePropagation();
      }) : (x === 13 || x === 38 || x === 40) && t.cancelIfNecessary());
    }), a.on("NodeChange", () => {
      t.isActive() && !t.isProcessingAction() && !a.queryCommandState("mceAutoCompleterInRange") && t.cancelIfNecessary();
    });
  } };
  var hT;
  (function(t) {
    t[t.CLOSE_ON_EXECUTE = 0] = "CLOSE_ON_EXECUTE", t[t.BUBBLE_TO_SANDBOX = 1] = "BUBBLE_TO_SANDBOX";
  })(hT || (hT = {}));
  var em = hT;
  const gT = "tox-menu-nav__js", bT = "tox-collection__item", $D = "tox-swatch", p$ = {
    normal: gT,
    color: $D
  }, vT = "tox-collection__item--enabled", LD = "tox-collection__group-heading", HD = "tox-collection__item-icon", yT = "tox-collection__item-label", h$ = "tox-collection__item-accessory", g$ = "tox-collection__item-caret", zD = "tox-collection__item-checkmark", R1 = "tox-collection__item--active", VD = "tox-collection__item-container", b$ = "tox-collection__item-container--column", Kb = "tox-collection__item-container--row", vW = "tox-collection__item-container--align-right", jD = "tox-collection__item-container--align-left", xT = "tox-collection__item-container--valign-top", yW = "tox-collection__item-container--valign-middle", v$ = "tox-collection__item-container--valign-bottom", UD = (t) => Ht(p$, t).getOr(gT), y$ = (t) => t === "color" ? "tox-swatches" : "tox-menu", YC = (t) => ({
    backgroundMenu: "tox-background-menu",
    selectedMenu: "tox-selected-menu",
    selectedItem: "tox-collection__item--active",
    hasIcons: "tox-menu--has-icons",
    menu: y$(t),
    tieredMenu: "tox-tiered-menu"
  }), Yb = (t) => {
    const a = YC(t);
    return {
      backgroundMenu: a.backgroundMenu,
      selectedMenu: a.selectedMenu,
      menu: a.menu,
      selectedItem: a.selectedItem,
      item: UD(t)
    };
  }, xW = (t, a, c) => {
    const f = YC(c);
    return {
      tag: "div",
      classes: en([
        [
          f.menu,
          `tox-menu-${a}-column`
        ],
        t ? [f.hasIcons] : []
      ])
    };
  }, x$ = [_1.parts.items({})], XC = (t, a, c) => {
    const f = YC(c);
    return {
      dom: {
        tag: "div",
        classes: en([[f.tieredMenu]])
      },
      markers: Yb(c)
    };
  }, WD = te([
    jr("data"),
    Qe("inputAttributes", {}),
    Qe("inputStyles", {}),
    Qe("tag", "input"),
    Qe("inputClasses", []),
    Rr("onSetValue"),
    Qe("styles", {}),
    Qe("eventOrder", {}),
    $i("inputBehaviours", [
      Mn,
      Ao
    ]),
    Qe("selectOnFocus", !0)
  ]), ZD = (t) => Qt([Ao.config({
    onFocus: t.selectOnFocus ? (a) => {
      const c = a.element, f = vt(c);
      c.dom.setSelectionRange(0, f.length);
    } : G
  })]), wW = (t) => ({
    ...ZD(t),
    ...Li(t.inputBehaviours, [Mn.config({
      store: {
        mode: "manual",
        ...t.data.map((a) => ({ initialValue: a })).getOr({}),
        getValue: (a) => vt(a.element),
        setValue: (a, c) => {
          vt(a.element) !== c && Zf(a.element, c);
        }
      },
      onSetValue: t.onSetValue
    })])
  }), GD = (t) => ({
    tag: t.tag,
    attributes: {
      type: "text",
      ...t.inputAttributes
    },
    styles: t.inputStyles,
    classes: t.inputClasses
  }), CW = (t, a) => ({
    uid: t.uid,
    dom: GD(t),
    components: [],
    behaviours: wW(t),
    eventOrder: t.eventOrder
  }), N1 = Pc({
    name: "Input",
    configFields: WD(),
    factory: CW
  }), w$ = Nn("refetch-trigger-event"), C$ = Nn("redirect-menu-item-interaction"), qD = "tox-menu__searcher", Xb = (t) => ss(t.element, `.${qD}`).bind((a) => t.getSystem().getByDom(a).toOptional()), KD = Xb, SW = (t, a) => {
    Mn.setValue(t, a.fetchPattern), t.element.dom.selectionStart = a.selectionStart, t.element.dom.selectionEnd = a.selectionEnd;
  }, S$ = (t) => {
    const a = Mn.getValue(t), c = t.element.dom.selectionStart, f = t.element.dom.selectionEnd;
    return {
      fetchPattern: a,
      selectionStart: c,
      selectionEnd: f
    };
  }, kW = (t, a) => {
    K(a.element, "id").each((c) => rn(t.element, "aria-activedescendant", c));
  }, _W = (t) => {
    const a = (g, x) => (x.cut(), B.none()), c = (g, x) => {
      const w = {
        interactionEvent: x.event,
        eventType: x.event.raw.type
      };
      return po(g, C$, w), B.some(!0);
    }, f = "searcher-events";
    return {
      dom: {
        tag: "div",
        classes: [bT]
      },
      components: [N1.sketch({
        inputClasses: [
          qD,
          "tox-textfield"
        ],
        inputAttributes: {
          ...t.placeholder.map((g) => ({ placeholder: t.i18n(g) })).getOr({}),
          type: "search",
          "aria-autocomplete": "list"
        },
        inputBehaviours: Qt([
          Go(f, [
            It(Lf(), (g) => {
              tr(g, w$);
            }),
            It(Cd(), (g, x) => {
              x.event.raw.key === "Escape" && x.stop();
            })
          ]),
          oo.config({
            mode: "special",
            onLeft: a,
            onRight: a,
            onSpace: a,
            onEnter: c,
            onEscape: c,
            onUp: c,
            onDown: c
          })
        ]),
        eventOrder: {
          keydown: [
            f,
            oo.name()
          ]
        }
      })]
    };
  }, wT = "tox-collection--results__js", QC = (t) => {
    var a;
    return t.dom ? {
      ...t,
      dom: {
        ...t.dom,
        attributes: {
          ...(a = t.dom.attributes) !== null && a !== void 0 ? a : {},
          id: Nn("aria-item-search-result-id"),
          "aria-selected": "false"
        }
      }
    } : t;
  }, YD = (t, a) => (c) => {
    const f = on(c, a);
    return tt(f, (g) => ({
      dom: t,
      components: g
    }));
  }, k$ = (t) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-menu",
        "tox-swatches-menu"
      ]
    },
    components: [{
      dom: {
        tag: "div",
        classes: ["tox-swatches"]
      },
      components: [_1.parts.items({
        preprocess: t !== "auto" ? YD({
          tag: "div",
          classes: ["tox-swatches__row"]
        }, t) : lt
      })]
    }]
  }), EW = (t) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-menu",
        "tox-collection",
        "tox-collection--toolbar",
        "tox-collection--toolbar-lg"
      ]
    },
    components: [_1.parts.items({
      preprocess: YD({
        tag: "div",
        classes: ["tox-collection__group"]
      }, t)
    })]
  }), XD = (t, a) => {
    const c = [];
    let f = [];
    return mt(t, (g, x) => {
      a(g, x) ? (f.length > 0 && c.push(f), f = [], (Ho(g.dom, "innerHtml") || g.components && g.components.length > 0) && f.push(g)) : f.push(g);
    }), f.length > 0 && c.push(f), tt(c, (g) => ({
      dom: {
        tag: "div",
        classes: ["tox-collection__group"]
      },
      components: g
    }));
  }, CT = (t, a, c) => _1.parts.items({
    preprocess: (f) => {
      const g = tt(f, c);
      return t !== "auto" && t > 1 ? YD({
        tag: "div",
        classes: ["tox-collection__group"]
      }, t)(g) : XD(g, (x, w) => a[w].type === "separator");
    }
  }), _$ = (t, a, c = !0) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-menu",
        "tox-collection"
      ].concat(t === 1 ? ["tox-collection--list"] : ["tox-collection--grid"])
    },
    components: [CT(t, a, lt)]
  }), E$ = (t, a, c = !0) => {
    const f = Nn("aria-controls-search-results");
    return {
      dom: {
        tag: "div",
        classes: [
          "tox-menu",
          "tox-collection",
          wT
        ].concat(t === 1 ? ["tox-collection--list"] : ["tox-collection--grid"]),
        attributes: { id: f }
      },
      components: [CT(t, a, QC)]
    };
  }, T$ = (t, a, c) => {
    const f = Nn("aria-controls-search-results");
    return {
      dom: {
        tag: "div",
        classes: [
          "tox-menu",
          "tox-collection"
        ].concat(t === 1 ? ["tox-collection--list"] : ["tox-collection--grid"])
      },
      components: [
        _W({
          i18n: Ad.translate,
          placeholder: c.placeholder
        }),
        {
          dom: {
            tag: "div",
            classes: [
              ...t === 1 ? ["tox-collection--list"] : ["tox-collection--grid"],
              wT
            ],
            attributes: { id: f }
          },
          components: [CT(t, a, QC)]
        }
      ]
    };
  }, O$ = (t, a = !0) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-collection",
        "tox-collection--horizontal"
      ]
    },
    components: [_1.parts.items({ preprocess: (c) => XD(c, (f, g) => t[g].type === "separator") })]
  }), JC = (t) => Fn(t, (a) => "icon" in a && a.icon !== void 0), Tg = (t) => (console.error(Bu(t)), console.log(t), B.none()), TW = (t, a, c, f, g) => {
    const x = O$(c);
    return {
      value: t,
      dom: x.dom,
      components: x.components,
      items: c
    };
  }, QD = (t, a, c, f, g) => {
    const x = () => g.menuType !== "searchable" ? _$(f, c) : g.searchMode.searchMode === "search-with-field" ? T$(f, c, g.searchMode) : E$(f, c);
    if (g.menuType === "color") {
      const w = k$(f);
      return {
        value: t,
        dom: w.dom,
        components: w.components,
        items: c
      };
    } else if (g.menuType === "normal" && f === "auto") {
      const w = _$(f, c);
      return {
        value: t,
        dom: w.dom,
        components: w.components,
        items: c
      };
    } else if (g.menuType === "normal" || g.menuType === "searchable") {
      const w = x();
      return {
        value: t,
        dom: w.dom,
        components: w.components,
        items: c
      };
    } else if (g.menuType === "listpreview" && f !== "auto") {
      const w = EW(f);
      return {
        value: t,
        dom: w.dom,
        components: w.components,
        items: c
      };
    } else
      return {
        value: t,
        dom: xW(a, f, g.menuType),
        components: x$,
        items: c
      };
  }, oi = Va("type"), ST = Va("name"), kT = Va("label"), Og = Va("text"), A$ = Va("title"), P$ = Va("icon"), eS = Va("value"), OW = _c("fetch"), AW = _c("getSubmenuItems"), px = _c("onAction"), JD = _c("onItemAction"), Qb = Ca("onSetup", () => G), PW = ja("name"), Jb = ja("text"), D$ = ja("role"), pf = ja("icon"), tS = ja("tooltip"), _T = ja("label"), ET = ja("shortcut"), R$ = vd("select"), TT = Ea("active", !1), DW = Ea("borderless", !1), tm = Ea("enabled", !0), nS = Ea("primary", !1), OT = (t) => Qe("columns", t), eR = Qe("meta", {}), tR = Ca("onAction", G), M1 = (t) => Mi("type", t), nR = (t) => Qa("name", "name", dr(() => Nn(`${t}-name`)), On), RW = (t) => Qa("value", "value", dr(() => Nn(`${t}-value`)), uu()), N$ = wo([
    oi,
    Jb
  ]), M$ = (t) => ia("separatormenuitem", N$, t), I$ = wo([
    M1("autocompleteitem"),
    TT,
    tm,
    eR,
    eS,
    Jb,
    pf
  ]), NW = (t) => ia("Autocompleter.Separator", N$, t), MW = (t) => ia("Autocompleter.Item", I$, t), oS = [
    tm,
    tS,
    pf,
    Jb,
    Qb
  ], Qu = wo([
    oi,
    px,
    ET
  ].concat(oS)), nm = (t) => ia("toolbarbutton", Qu, t), oR = [TT].concat(oS), rR = wo(oR.concat([
    oi,
    px,
    ET
  ])), AT = (t) => ia("ToggleButton", rR, t), F$ = [
    Ca("predicate", wt),
    fu("scope", "node", [
      "node",
      "editor"
    ]),
    fu("position", "selection", [
      "node",
      "selection",
      "line"
    ])
  ], IW = oS.concat([
    M1("contextformbutton"),
    nS,
    px,
    Wr("original", lt)
  ]), rS = oR.concat([
    M1("contextformbutton"),
    nS,
    px,
    Wr("original", lt)
  ]), PT = oS.concat([M1("contextformbutton")]), sR = oR.concat([M1("contextformtogglebutton")]), FW = ci("type", {
    contextformbutton: IW,
    contextformtogglebutton: rS
  }), Zm = wo([
    M1("contextform"),
    Ca("initValue", te("")),
    _T,
    Ec("commands", FW),
    bd("launch", ci("type", {
      contextformbutton: PT,
      contextformtogglebutton: sR
    }))
  ].concat(F$)), BW = (t) => ia("ContextForm", Zm, t), $W = wo([
    M1("contexttoolbar"),
    Va("items")
  ].concat(F$)), hf = (t) => ia("ContextToolbar", $W, t), sS = [
    oi,
    Va("src"),
    ja("alt"),
    I("classes", [], On)
  ], om = wo(sS), LW = [
    oi,
    Og,
    PW,
    I("classes", ["tox-collection__item-label"], On)
  ], Ts = wo(LW), I1 = Xa(() => If("type", {
    cardimage: om,
    cardtext: Ts,
    cardcontainer: DT
  })), DT = wo([
    oi,
    Mi("direction", "horizontal"),
    Mi("align", "left"),
    Mi("valign", "middle"),
    Ec("items", I1)
  ]), F1 = [
    tm,
    Jb,
    D$,
    ET,
    RW("menuitem"),
    eR
  ], aR = wo([
    oi,
    _T,
    Ec("items", I1),
    Qb,
    tR
  ].concat(F1)), iR = (t) => ia("cardmenuitem", aR, t), HW = wo([
    oi,
    TT,
    pf
  ].concat(F1)), lR = (t) => ia("choicemenuitem", HW, t), B$ = [
    oi,
    Va("fancytype"),
    tR
  ], $$ = [Qe("initData", {})].concat(B$), L$ = [
    vd("select"),
    ee("initData", {}, [
      Ea("allowCustomColors", !0),
      Mi("storageKey", "default"),
      $u("colors", uu())
    ])
  ].concat(B$), cR = ci("fancytype", {
    inserttable: $$,
    colorswatch: L$
  }), H$ = (t) => ia("fancymenuitem", cR, t), RT = wo([
    oi,
    Qb,
    tR,
    pf
  ].concat(F1)), zW = (t) => ia("menuitem", RT, t), VW = wo([
    oi,
    AW,
    Qb,
    pf
  ].concat(F1)), jW = (t) => ia("nestedmenuitem", VW, t), UW = wo([
    oi,
    pf,
    TT,
    Qb,
    px
  ].concat(F1)), WW = (t) => ia("togglemenuitem", UW, t), NT = (t, a, c) => {
    const f = Dl(t.element, "." + c);
    if (f.length > 0) {
      const g = $n(f, (x) => {
        const w = x.dom.getBoundingClientRect().top, T = f[0].dom.getBoundingClientRect().top;
        return Math.abs(w - T) > a;
      }).getOr(f.length);
      return B.some({
        numColumns: g,
        numRows: Math.ceil(f.length / g)
      });
    } else
      return B.none();
  }, z$ = (t, a) => Qt([Go(t, a)]), hx = {
    namedEvents: z$,
    unnamedEvents: (t) => z$(Nn("unnamed-events"), t)
  }, V$ = (t) => t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), j$ = "silver.readonly", ZW = wo([Nw("readonly")]), aS = (t, a) => {
    const f = t.mainUi.outerContainer.element, g = [
      t.mainUi.mothership,
      ...t.uiMotherships
    ];
    a && mt(g, (x) => {
      x.broadcastOn([Kf()], { target: f });
    }), mt(g, (x) => {
      x.broadcastOn([j$], { readonly: a });
    });
  }, MT = (t, a) => {
    t.on("init", () => {
      t.mode.isReadOnly() && aS(a, !0);
    }), t.on("SwitchMode", () => aS(a, t.mode.isReadOnly())), qE(t) && t.mode.set("readonly");
  }, Si = () => Ac.config({
    channels: {
      [j$]: {
        schema: ZW,
        onReceive: (t, a) => {
          _o.set(t, a.readonly);
        }
      }
    }
  }), rm = {
    item: (t) => _o.config({
      disabled: t,
      disableClass: "tox-collection__item--state-disabled"
    }),
    button: (t) => _o.config({ disabled: t }),
    splitButton: (t) => _o.config({
      disabled: t,
      disableClass: "tox-tbtn--disabled"
    }),
    toolbarButton: (t) => _o.config({
      disabled: t,
      disableClass: "tox-tbtn--disabled",
      useNative: !1
    })
  }, IT = (t, a) => {
    const c = t.getApi(a);
    return (f) => {
      f(c);
    };
  }, Ag = (t, a) => Qs((c) => {
    IT(t, c)((g) => {
      const x = t.onSetup(g);
      Q(x) && a.set(x);
    });
  }), mc = (t, a) => zf((c) => IT(t, c)(a.get())), GW = (t, a) => Sd((c, f) => {
    IT(t, c)(t.onAction), !t.triggersSubmenu && a === em.CLOSE_ON_EXECUTE && (c.getSystem().isConnected() && tr(c, Rv()), f.stop());
  }), uR = {
    [zu()]: [
      "disabling",
      "alloy.base.behaviour",
      "toggling",
      "item-events"
    ]
  }, B1 = Ks, $1 = (t, a, c, f) => {
    const g = no(G);
    return {
      type: "item",
      dom: a.dom,
      components: B1(a.optComponents),
      data: t.data,
      eventOrder: uR,
      hasSubmenu: t.triggersSubmenu,
      itemBehaviours: Qt([
        Go("item-events", [
          GW(t, c),
          Ag(t, g),
          mc(t, g)
        ]),
        rm.item(() => !t.enabled || f.isDisabled()),
        Si(),
        No.config({})
      ].concat(t.itemBehaviours))
    };
  }, gx = (t) => ({
    value: t.value,
    meta: {
      text: t.text.getOr(""),
      ...t.meta
    }
  }), FT = (t) => {
    const a = ix.os.isMacOS() || ix.os.isiOS(), g = a ? {
      alt: "",
      ctrl: "",
      shift: "",
      meta: "",
      access: ""
    } : {
      meta: "Ctrl",
      access: "Shift+Alt"
    }, x = t.split("+"), w = tt(x, (T) => {
      const A = T.toLowerCase().trim();
      return Ho(g, A) ? g[A] : T;
    });
    return a ? w.join("") : w.join("+");
  }, BT = (t, a, c = [HD]) => xu(t, {
    tag: "div",
    classes: c
  }, a), dR = (t) => ({
    dom: {
      tag: "div",
      classes: [yT]
    },
    components: [Oa(Ad.translate(t))]
  }), U$ = (t, a) => ({
    dom: {
      tag: "div",
      classes: a,
      innerHtml: t
    }
  }), qW = (t, a) => ({
    dom: {
      tag: "div",
      classes: [yT]
    },
    components: [{
      dom: {
        tag: t.tag,
        styles: t.styles
      },
      components: [Oa(Ad.translate(a))]
    }]
  }), KW = (t) => ({
    dom: {
      tag: "div",
      classes: [h$]
    },
    components: [Oa(FT(t))]
  }), W$ = (t) => BT("checkmark", t, [zD]), YW = (t) => BT("chevron-right", t, [g$]), Z$ = (t) => BT("chevron-down", t, [g$]), G$ = (t, a) => {
    const c = t.direction === "vertical" ? b$ : Kb, f = t.align === "left" ? jD : vW;
    return {
      dom: {
        tag: "div",
        classes: [
          VD,
          c,
          f,
          (() => {
            switch (t.valign) {
              case "top":
                return xT;
              case "middle":
                return yW;
              case "bottom":
                return v$;
            }
          })()
        ]
      },
      components: a
    };
  }, q$ = (t, a, c) => ({
    dom: {
      tag: "img",
      classes: a,
      attributes: {
        src: t,
        alt: c.getOr("")
      }
    }
  }), XW = (t, a, c) => {
    const f = "custom", g = "remove", x = t.value, w = t.iconContent.map((F) => u$(F, a.icons, c)), T = t.ariaLabel.map((F) => ({
      "aria-label": a.translate(F),
      "data-mce-name": F
    })).getOr({});
    return {
      dom: (() => {
        const F = $D, H = w.getOr(""), q = {
          tag: "div",
          attributes: T,
          classes: [F]
        };
        return x === f ? {
          ...q,
          tag: "button",
          classes: [
            ...q.classes,
            "tox-swatches__picker-btn"
          ],
          innerHtml: H
        } : x === g ? {
          ...q,
          classes: [
            ...q.classes,
            "tox-swatch--remove"
          ],
          innerHtml: H
        } : Ce(x) ? {
          ...q,
          attributes: {
            ...q.attributes,
            "data-mce-color": x
          },
          styles: { "background-color": x },
          innerHtml: H
        } : q;
      })(),
      optComponents: []
    };
  }, K$ = (t) => {
    const a = t.map((c) => ({
      attributes: {
        id: Nn("menu-item"),
        "aria-label": Ad.translate(c)
      }
    })).getOr({});
    return {
      tag: "div",
      classes: [
        gT,
        bT
      ],
      ...a
    };
  }, QW = (t, a, c, f) => {
    const g = {
      tag: "div",
      classes: [HD]
    }, x = (ne) => xu(ne, g, a.icons, f), w = () => B.some({ dom: g }), T = c ? t.iconContent.map(x).orThunk(w) : B.none(), A = t.checkMark, F = B.from(t.meta).fold(() => dR, (ne) => Ho(ne, "style") ? Kt(qW, ne.style) : dR), H = t.htmlContent.fold(() => t.textContent.map(F), (ne) => B.some(U$(ne, [yT])));
    return {
      dom: K$(t.ariaLabel),
      optComponents: [
        T,
        H,
        t.shortcutContent.map(KW),
        A,
        t.caret
      ]
    };
  }, oh = (t, a, c, f = B.none()) => t.presets === "color" ? XW(t, a, f) : QW(t, a, c, f), Y$ = (t, a, c) => Ht(t, "tooltipWorker").map((f) => [gl.config({
    lazySink: a.getSink,
    tooltipDom: {
      tag: "div",
      classes: ["tox-tooltip-worker-container"]
    },
    tooltipComponents: [],
    anchor: (g) => ({
      type: "submenu",
      item: g,
      overrides: { maxHeightFunction: Eb }
    }),
    mode: "follow-highlight",
    onShow: (g, x) => {
      f((w) => {
        gl.setComponents(g, [ny({ element: He.fromDom(w) })]);
      });
    }
  })]).getOrThunk(() => c.map((f) => [gl.config({
    ...a.providers.tooltips.getConfig({ tooltipText: f }),
    mode: "follow-highlight"
  })]).getOr([])), X$ = (t) => T1.DOM.encode(t), fR = (t, a) => {
    const c = Ad.translate(t), f = X$(c);
    if (a.length > 0) {
      const g = new RegExp(V$(a), "gi");
      return f.replace(g, (x) => `<span class="tox-autocompleter-highlight">${x}</span>`);
    } else
      return f;
  }, Q$ = (t, a, c, f, g, x, w, T = !0) => {
    const A = oh({
      presets: f,
      textContent: B.none(),
      htmlContent: c ? t.text.map((H) => fR(H, a)) : B.none(),
      ariaLabel: t.text,
      iconContent: t.icon,
      shortcutContent: B.none(),
      checkMark: B.none(),
      caret: B.none(),
      value: t.value
    }, w.providers, T, t.icon), F = t.text.filter((H) => !c && H !== "");
    return $1({
      data: gx(t),
      enabled: t.enabled,
      getApi: te({}),
      onAction: (H) => g(t.value, t.meta),
      onSetup: te(G),
      triggersSubmenu: !1,
      itemBehaviours: Y$(t, w, F)
    }, A, x, w.providers);
  }, mR = (t, a) => tt(t, (c) => {
    switch (c.type) {
      case "cardcontainer":
        return G$(c, mR(c.items, a));
      case "cardimage":
        return q$(c.src, c.classes, c.alt);
      case "cardtext":
        const g = c.name.exists((x) => jt(a.cardText.highlightOn, x)) ? B.from(a.cardText.matchText).getOr("") : "";
        return U$(fR(c.text, g), c.classes);
    }
  }), pR = (t, a, c, f) => {
    const g = (w) => ({
      isEnabled: () => !_o.isDisabled(w),
      setEnabled: (T) => {
        _o.set(w, !T), mt(Dl(w.element, "*"), (A) => {
          w.getSystem().getByDom(A).each((F) => {
            F.hasConfigured(_o) && _o.set(F, !T);
          });
        });
      }
    }), x = {
      dom: K$(t.label),
      optComponents: [B.some({
        dom: {
          tag: "div",
          classes: [
            VD,
            Kb
          ]
        },
        components: mR(t.items, f)
      })]
    };
    return $1({
      data: gx({
        text: B.none(),
        ...t
      }),
      enabled: t.enabled,
      getApi: g,
      onAction: t.onAction,
      onSetup: t.onSetup,
      triggersSubmenu: !1,
      itemBehaviours: B.from(f.itemBehaviours).getOr([])
    }, x, a, c.providers);
  }, hR = (t, a, c, f, g, x, w, T = !0) => {
    const A = (q) => ({
      setActive: (ne) => {
        ir.set(q, ne);
      },
      isActive: () => ir.isOn(q),
      isEnabled: () => !_o.isDisabled(q),
      setEnabled: (ne) => _o.set(q, !ne)
    }), F = oh({
      presets: c,
      textContent: a ? t.text : B.none(),
      htmlContent: B.none(),
      ariaLabel: t.text,
      iconContent: t.icon,
      shortcutContent: a ? t.shortcut : B.none(),
      checkMark: a ? B.some(W$(w.icons)) : B.none(),
      caret: B.none(),
      value: t.value
    }, w, T), H = t.text.filter(te(!a)).map((q) => gl.config(w.tooltips.getConfig({ tooltipText: w.translate(q) })));
    return Fs($1({
      data: gx(t),
      enabled: t.enabled,
      getApi: A,
      onAction: (q) => f(t.value),
      onSetup: (q) => (q.setActive(g), G),
      triggersSubmenu: !1,
      itemBehaviours: [...H.toArray()]
    }, F, x, w), {
      toggling: {
        toggleClass: vT,
        toggleOnExecute: !1,
        selected: t.active,
        exclusive: !0
      }
    });
  }, $T = vC(rD(), sD()), gR = (t) => ({ value: tL(t) }), J$ = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, bR = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, eL = (t) => J$.test(t) || bR.test(t), tL = (t) => gn(t, "#").toUpperCase(), JW = (t) => eL(t) ? B.some({ value: tL(t) }) : B.none(), nL = (t) => ({ value: t.value.replace(J$, (c, f, g, x) => f + f + g + g + x + x) }), oL = (t) => {
    const a = nL(t), c = bR.exec(a.value);
    return c === null ? [
      "FFFFFF",
      "FF",
      "FF",
      "FF"
    ] : c;
  }, LT = (t) => {
    const a = t.toString(16);
    return (a.length === 1 ? "0" + a : a).toUpperCase();
  }, iS = (t) => {
    const a = LT(t.red) + LT(t.green) + LT(t.blue);
    return gR(a);
  }, rL = Math.min, sL = Math.max, HT = Math.round, eZ = /^\s*rgb\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*\)\s*$/i, tZ = /^\s*rgba\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*((?:\d?\.\d+|\d+)%?)\s*\)\s*$/i, L1 = (t, a, c, f) => ({
    red: t,
    green: a,
    blue: c,
    alpha: f
  }), vR = (t) => {
    const a = parseInt(t, 10);
    return a.toString() === t && a >= 0 && a <= 255;
  }, aL = (t) => {
    let a, c, f;
    const g = (t.hue || 0) % 360;
    let x = t.saturation / 100, w = t.value / 100;
    if (x = sL(0, rL(x, 1)), w = sL(0, rL(w, 1)), x === 0)
      return a = c = f = HT(255 * w), L1(a, c, f, 1);
    const T = g / 60, A = w * x, F = A * (1 - Math.abs(T % 2 - 1)), H = w - A;
    switch (Math.floor(T)) {
      case 0:
        a = A, c = F, f = 0;
        break;
      case 1:
        a = F, c = A, f = 0;
        break;
      case 2:
        a = 0, c = A, f = F;
        break;
      case 3:
        a = 0, c = F, f = A;
        break;
      case 4:
        a = F, c = 0, f = A;
        break;
      case 5:
        a = A, c = 0, f = F;
        break;
      default:
        a = c = f = 0;
    }
    return a = HT(255 * (a + H)), c = HT(255 * (c + H)), f = HT(255 * (f + H)), L1(a, c, f, 1);
  }, lS = (t) => {
    const a = oL(t), c = parseInt(a[1], 16), f = parseInt(a[2], 16), g = parseInt(a[3], 16);
    return L1(c, f, g, 1);
  }, iL = (t, a, c, f) => {
    const g = parseInt(t, 10), x = parseInt(a, 10), w = parseInt(c, 10), T = parseFloat(f);
    return L1(g, x, w, T);
  }, zT = (t) => {
    const a = eZ.exec(t);
    if (a !== null)
      return B.some(iL(a[1], a[2], a[3], "1"));
    const c = tZ.exec(t);
    return c !== null ? B.some(iL(c[1], c[2], c[3], c[4])) : B.none();
  }, lL = (t) => `rgba(${t.red},${t.green},${t.blue},${t.alpha})`, cL = L1(255, 0, 0, 1), nZ = (t) => {
    t.dispatch("SkinLoaded");
  }, oZ = (t, a) => {
    t.dispatch("SkinLoadError", a);
  }, rZ = (t) => {
    t.dispatch("ResizeEditor");
  }, bx = (t, a) => {
    t.dispatch("ResizeContent", a);
  }, uL = (t, a) => {
    t.dispatch("ScrollContent", a);
  }, dL = (t, a) => {
    t.dispatch("TextColorChange", a);
  }, sZ = (t, a) => {
    t.dispatch("AfterProgressState", { state: a });
  }, aZ = (t, a) => t.dispatch("ResolveName", {
    name: a.nodeName.toLowerCase(),
    target: a
  }), iZ = (t, a) => {
    t.dispatch("ToggleToolbarDrawer", { state: a });
  }, lZ = (t, a) => {
    t.dispatch("StylesTextUpdate", a);
  }, cZ = (t, a) => {
    t.dispatch("AlignTextUpdate", a);
  }, yR = (t, a) => {
    t.dispatch("FontSizeTextUpdate", a);
  }, fL = (t, a) => {
    t.dispatch("FontSizeInputTextUpdate", a);
  }, mL = (t, a) => {
    t.dispatch("BlocksTextUpdate", a);
  }, uZ = (t, a) => {
    t.dispatch("FontFamilyTextUpdate", a);
  }, cS = (t, a) => () => {
    t(), a();
  }, Rc = (t) => H1(t, "NodeChange", (a) => {
    a.setEnabled(t.selection.isEditable());
  }), dZ = (t, a) => (c) => {
    const f = za(), g = () => {
      c.setActive(t.formatter.match(a));
      const x = t.formatter.formatChanged(a, c.setActive);
      f.set(x);
    };
    return t.initialized ? g() : t.once("init", g), () => {
      t.off("init", g), f.clear();
    };
  }, VT = (t, a) => (c) => {
    const f = Rc(t)(c), g = dZ(t, a)(c);
    return () => {
      f(), g();
    };
  }, H1 = (t, a, c) => (f) => {
    const g = () => c(f), x = () => {
      c(f), t.on(a, g);
    };
    return t.initialized ? x() : t.once("init", x), () => {
      t.off("init", x), t.off(a, g);
    };
  }, pL = (t) => (a) => () => {
    t.undoManager.transact(() => {
      t.focus(), t.execCommand("mceToggleFormat", !1, a.format);
    });
  }, Ju = (t, a) => () => t.execCommand(a);
  var z1 = tinymce.util.Tools.resolve("tinymce.util.LocalStorage");
  const hL = {}, fZ = (t, a = 10) => {
    const c = z1.getItem(t), f = _(c) ? JSON.parse(c) : [], x = ((F) => a - F.length < 0 ? F.slice(0, a) : F)(f), w = (F) => {
      Le(x, F).each(T), x.unshift(F), x.length > a && x.pop(), z1.setItem(t, JSON.stringify(x));
    }, T = (F) => {
      x.splice(F, 1);
    };
    return {
      add: w,
      state: () => x.slice(0)
    };
  }, gL = (t) => Ht(hL, t).getOrThunk(() => {
    const a = `tinymce-custom-colors-${t}`, c = z1.getItem(a);
    if (ke(c)) {
      const g = z1.getItem("tinymce-custom-colors");
      z1.setItem(a, Ce(g) ? g : "[]");
    }
    const f = fZ(a, 10);
    return hL[t] = f, f;
  }), jT = (t) => tt(gL(t).state(), (a) => ({
    type: "choiceitem",
    text: a,
    icon: "checkmark",
    value: a
  })), UT = (t, a) => {
    gL(t).add(a);
  }, V1 = (t, a, c) => ({
    hue: t,
    saturation: a,
    value: c
  }), WT = (t) => {
    let a = 0, c = 0, f = 0;
    const g = t.red / 255, x = t.green / 255, w = t.blue / 255, T = Math.min(g, Math.min(x, w)), A = Math.max(g, Math.max(x, w));
    if (T === A)
      return f = T, V1(0, 0, f * 100);
    const F = g === T ? x - w : w === T ? g - x : w - g;
    return a = g === T ? 3 : w === T ? 1 : 5, a = 60 * (a - F / (A - T)), c = (A - T) / A, f = A, V1(Math.round(a), Math.round(c * 100), Math.round(f * 100));
  }, mZ = (t) => WT(lS(t)), bL = (t) => iS(aL(t)), xR = (t) => JW(t).orThunk(() => zT(t).map(iS)).getOrThunk(() => {
    const a = document.createElement("canvas");
    a.height = 1, a.width = 1;
    const c = a.getContext("2d");
    c.clearRect(0, 0, a.width, a.height), c.fillStyle = "#FFFFFF", c.fillStyle = t, c.fillRect(0, 0, 1, 1);
    const f = c.getImageData(0, 0, 1, 1).data, g = f[0], x = f[1], w = f[2], T = f[3];
    return iS(L1(g, x, w, T));
  }), uS = "forecolor", vx = "hilitecolor", vL = 5, pZ = (t) => {
    const a = [];
    for (let c = 0; c < t.length; c += 2)
      a.push({
        text: t[c + 1],
        value: "#" + xR(t[c]).value,
        icon: "checkmark",
        type: "choiceitem"
      });
    return a;
  }, rh = (t) => (a) => a.options.get(t), wR = "#000000", hZ = (t) => {
    const a = t.options.register, c = (g) => ae(g, _) ? {
      value: pZ(g),
      valid: !0
    } : {
      valid: !1,
      message: "Must be an array of strings."
    }, f = (g) => oe(g) && g > 0 ? {
      value: g,
      valid: !0
    } : {
      valid: !1,
      message: "Must be a positive number."
    };
    a("color_map", {
      processor: c,
      default: [
        "#BFEDD2",
        "Light Green",
        "#FBEEB8",
        "Light Yellow",
        "#F8CAC6",
        "Light Red",
        "#ECCAFA",
        "Light Purple",
        "#C2E0F4",
        "Light Blue",
        "#2DC26B",
        "Green",
        "#F1C40F",
        "Yellow",
        "#E03E2D",
        "Red",
        "#B96AD9",
        "Purple",
        "#3598DB",
        "Blue",
        "#169179",
        "Dark Turquoise",
        "#E67E23",
        "Orange",
        "#BA372A",
        "Dark Red",
        "#843FA1",
        "Dark Purple",
        "#236FA1",
        "Dark Blue",
        "#ECF0F1",
        "Light Gray",
        "#CED4D9",
        "Medium Gray",
        "#95A5A6",
        "Gray",
        "#7E8C8D",
        "Dark Gray",
        "#34495E",
        "Navy Blue",
        "#000000",
        "Black",
        "#ffffff",
        "White"
      ]
    }), a("color_map_background", { processor: c }), a("color_map_foreground", { processor: c }), a("color_cols", {
      processor: f,
      default: CR(t)
    }), a("color_cols_foreground", {
      processor: f,
      default: yL(t, uS)
    }), a("color_cols_background", {
      processor: f,
      default: yL(t, vx)
    }), a("custom_colors", {
      processor: "boolean",
      default: !0
    }), a("color_default_foreground", {
      processor: "string",
      default: wR
    }), a("color_default_background", {
      processor: "string",
      default: wR
    });
  }, ZT = (t, a) => a === uS && t.options.isSet("color_map_foreground") ? rh("color_map_foreground")(t) : a === vx && t.options.isSet("color_map_background") ? rh("color_map_background")(t) : rh("color_map")(t), CR = (t, a = "default") => Math.max(vL, Math.ceil(Math.sqrt(ZT(t, a).length))), yL = (t, a) => {
    const c = rh("color_cols")(t), f = CR(t, a);
    return c === CR(t) ? f : c;
  }, xL = (t, a = "default") => Math.round(a === uS ? rh("color_cols_foreground")(t) : a === vx ? rh("color_cols_background")(t) : rh("color_cols")(t)), wL = rh("custom_colors"), gZ = rh("color_default_foreground"), bZ = rh("color_default_background"), vZ = "rgba(0, 0, 0, 0)", yZ = (t) => zT(t).exists((a) => a.alpha !== 0), CL = (t) => Ff(t, (a) => {
    if (ko(a)) {
      const c = fs(a, "background-color");
      return Xn(yZ(c), c);
    } else
      return B.none();
  }).getOr(vZ), SL = (t, a) => {
    const c = He.fromDom(t.selection.getStart()), f = a === "hilitecolor" ? CL(c) : fs(c, "color");
    return zT(f).map((g) => "#" + iS(g).value);
  }, xZ = (t, a, c) => {
    t.undoManager.transact(() => {
      t.focus(), t.formatter.apply(a, { value: c }), t.nodeChanged();
    });
  }, sh = (t, a) => {
    t.undoManager.transact(() => {
      t.focus(), t.formatter.remove(a, { value: null }, void 0, !0), t.nodeChanged();
    });
  }, wZ = (t) => {
    t.addCommand("mceApplyTextcolor", (a, c) => {
      xZ(t, a, c);
    }), t.addCommand("mceRemoveTextcolor", (a) => {
      sh(t, a);
    });
  }, kL = (t) => {
    const a = "choiceitem", c = {
      type: a,
      text: "Remove color",
      icon: "color-swatch-remove-color",
      value: "remove"
    };
    return t ? [
      c,
      {
        type: a,
        text: "Custom color",
        icon: "color-picker",
        value: "custom"
      }
    ] : [c];
  }, dS = (t, a, c, f) => {
    c === "custom" ? PL(t)((x) => {
      x.each((w) => {
        UT(a, w), t.execCommand("mceApplyTextcolor", a, w), f(w);
      });
    }, SL(t, a).getOr(wR)) : c === "remove" ? (f(""), t.execCommand("mceRemoveTextcolor", a)) : (f(c), t.execCommand("mceApplyTextcolor", a, c));
  }, ki = (t, a, c) => t.concat(jT(a).concat(kL(c))), _L = (t, a, c) => (f) => {
    f(ki(t, a, c));
  }, SR = (t, a, c) => {
    const f = a === "forecolor" ? "tox-icon-text-color__color" : "tox-icon-highlight-bg-color__color";
    t.setIconFill(f, c);
  }, EL = (t, a) => {
    t.setTooltip(a);
  }, TL = (t, a) => (c) => {
    const f = SL(t, a);
    return ra(f, c.toUpperCase());
  }, kR = (t, a, c) => {
    if (Oe(c))
      return a === "forecolor" ? "Text color" : "Background color";
    const f = a === "forecolor" ? "Text color {0}" : "Background color {0}", g = ki(ZT(t, a), a, !1), x = At(g, (w) => w.value === c).getOr({ text: "" }).text;
    return t.translate([
      f,
      t.translate(x)
    ]);
  }, OL = (t, a, c, f) => {
    t.ui.registry.addSplitButton(a, {
      tooltip: kR(t, c, f.get()),
      presets: "color",
      icon: a === "forecolor" ? "text-color" : "highlight-bg-color",
      select: TL(t, c),
      columns: xL(t, c),
      fetch: _L(ZT(t, c), c, wL(t)),
      onAction: (g) => {
        dS(t, c, f.get(), G);
      },
      onItemAction: (g, x) => {
        dS(t, c, x, (w) => {
          f.set(w), dL(t, {
            name: a,
            color: w
          });
        });
      },
      onSetup: (g) => {
        SR(g, a, f.get());
        const x = (w) => {
          w.name === a && (SR(g, w.name, w.color), EL(g, kR(t, c, w.color)));
        };
        return t.on("TextColorChange", x), cS(Rc(t)(g), () => {
          t.off("TextColorChange", x);
        });
      }
    });
  }, AL = (t, a, c, f, g) => {
    t.ui.registry.addNestedMenuItem(a, {
      text: f,
      icon: a === "forecolor" ? "text-color" : "highlight-bg-color",
      onSetup: (x) => (EL(x, kR(t, c, g.get())), SR(x, a, g.get()), Rc(t)(x)),
      getSubmenuItems: () => [{
        type: "fancymenuitem",
        fancytype: "colorswatch",
        select: TL(t, c),
        initData: { storageKey: c },
        onAction: (x) => {
          dS(t, c, x.value, (w) => {
            g.set(w), dL(t, {
              name: a,
              color: w
            });
          });
        }
      }]
    });
  }, PL = (t) => (a, c) => {
    let f = !1;
    const g = (T) => {
      const F = T.getData().colorpicker;
      f ? (a(B.from(F)), T.close()) : t.windowManager.alert(t.translate([
        "Invalid hex color code: {0}",
        F
      ]));
    }, x = (T, A) => {
      A.name === "hex-valid" && (f = A.value);
    }, w = { colorpicker: c };
    t.windowManager.open({
      title: "Color Picker",
      size: "normal",
      body: {
        type: "panel",
        items: [{
          type: "colorpicker",
          name: "colorpicker",
          label: "Color"
        }]
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: w,
      onAction: x,
      onSubmit: g,
      onClose: G,
      onCancel: () => {
        a(B.none());
      }
    });
  }, CZ = (t) => {
    wZ(t);
    const a = gZ(t), c = bZ(t), f = no(a), g = no(c);
    OL(t, "forecolor", "forecolor", f), OL(t, "backcolor", "hilitecolor", g), AL(t, "forecolor", "forecolor", "Text color", f), AL(t, "backcolor", "hilitecolor", "Background color", g);
  }, _R = (t, a, c, f, g, x, w, T) => {
    const A = JC(a), H = SZ(a, c, f, g !== "color" ? "normal" : "color", x, w, T);
    return QD(t, A, H, f, { menuType: g });
  }, SZ = (t, a, c, f, g, x, w) => Ks(tt(t, (T) => T.type === "choiceitem" ? lR(T).fold(Tg, (A) => B.some(hR(A, c === 1, f, a, x(A.value), g, w, JC(t)))) : B.none())), GT = (t, a) => {
    const c = Yb(a);
    return t === 1 ? {
      mode: "menu",
      moveOnTab: !0
    } : t === "auto" ? {
      mode: "grid",
      selector: "." + c.item,
      initSize: {
        numColumns: 1,
        numRows: 1
      }
    } : {
      mode: "matrix",
      rowSelector: "." + (a === "color" ? "tox-swatches__row" : "tox-collection__group"),
      previousSelector: (g) => a === "color" ? ss(g.element, "[aria-checked=true]") : B.none()
    };
  }, kZ = (t, a) => t === 1 ? {
    mode: "menu",
    moveOnTab: !1,
    selector: ".tox-collection__item"
  } : t === "auto" ? {
    mode: "flatgrid",
    selector: ".tox-collection__item",
    initSize: {
      numColumns: 1,
      numRows: 1
    }
  } : {
    mode: "matrix",
    selectors: {
      row: a === "color" ? ".tox-swatches__row" : ".tox-collection__group",
      cell: a === "color" ? `.${$D}` : `.${bT}`
    }
  }, _Z = (t, a) => {
    const c = EZ(t, a), f = a.colorinput.getColorCols(t.initData.storageKey), g = "color", w = {
      ..._R(Nn("menu-value"), c, (T) => {
        t.onAction({ value: T });
      }, f, g, em.CLOSE_ON_EXECUTE, t.select.getOr(wt), a.shared.providers),
      markers: Yb(g),
      movement: GT(f, g),
      showMenuRole: !1
    };
    return {
      type: "widget",
      data: { value: Nn("widget-id") },
      dom: {
        tag: "div",
        classes: ["tox-fancymenuitem"]
      },
      autofocus: !0,
      components: [$T.widget(_1.sketch(w))]
    };
  }, EZ = (t, a) => {
    const c = t.initData.allowCustomColors && a.colorinput.hasCustomColors();
    return t.initData.colors.fold(() => ki(a.colorinput.getColors(t.initData.storageKey), t.initData.storageKey, c), (f) => f.concat(kL(c)));
  }, DL = Nn("cell-over"), RL = Nn("cell-execute"), TZ = (t) => (a, c) => t.shared.providers.translate([
    "{0} columns, {1} rows",
    c,
    a
  ]), OZ = (t, a, c) => {
    const f = (w) => po(w, DL, {
      row: t,
      col: a
    }), g = (w) => po(w, RL, {
      row: t,
      col: a
    }), x = (w, T) => {
      T.stop(), g(w);
    };
    return Al({
      dom: {
        tag: "div",
        attributes: {
          role: "button",
          "aria-label": c
        }
      },
      behaviours: Qt([
        Go("insert-table-picker-cell", [
          It(Bf(), Ao.focus),
          It(zu(), g),
          It(Vh(), x),
          It(ef(), x)
        ]),
        ir.config({
          toggleClass: "tox-insert-table-picker__selected",
          toggleOnExecute: !1
        }),
        Ao.config({ onFocus: f })
      ])
    });
  }, AZ = (t, a, c) => {
    const f = [];
    for (let g = 0; g < a; g++) {
      const x = [];
      for (let w = 0; w < c; w++) {
        const T = t(g + 1, w + 1);
        x.push(OZ(g, w, T));
      }
      f.push(x);
    }
    return f;
  }, PZ = (t, a, c, f, g) => {
    for (let x = 0; x < f; x++)
      for (let w = 0; w < g; w++)
        ir.set(t[x][w], x <= a && w <= c);
  }, DZ = (t) => Ue(t, (a) => tt(a, Ll)), NL = (t, a) => Oa(`${a}x${t}`), RZ = {
    inserttable: (t, a) => {
      const g = TZ(a), x = AZ(g, 10, 10), w = NL(0, 0), T = is({
        dom: {
          tag: "span",
          classes: ["tox-insert-table-picker__label"]
        },
        components: [w],
        behaviours: Qt([No.config({})])
      });
      return {
        type: "widget",
        data: { value: Nn("widget-id") },
        dom: {
          tag: "div",
          classes: ["tox-fancymenuitem"]
        },
        autofocus: !0,
        components: [$T.widget({
          dom: {
            tag: "div",
            classes: ["tox-insert-table-picker"]
          },
          components: DZ(x).concat(T.asSpec()),
          behaviours: Qt([
            Go("insert-table-picker", [
              Qs((A) => {
                No.set(T.get(A), [w]);
              }),
              Vw(DL, (A, F, H) => {
                const { row: q, col: ne } = H.event;
                PZ(x, q, ne, 10, 10), No.set(T.get(A), [NL(q + 1, ne + 1)]);
              }),
              Vw(RL, (A, F, H) => {
                const { row: q, col: ne } = H.event;
                t.onAction({
                  numRows: q + 1,
                  numColumns: ne + 1
                }), tr(A, Rv());
              })
            ]),
            oo.config({
              initSize: {
                numRows: 10,
                numColumns: 10
              },
              mode: "flatgrid",
              selector: '[role="button"]'
            })
          ])
        })]
      };
    },
    colorswatch: _Z
  }, ML = (t, a) => Ht(RZ, t.fancytype).map((c) => c(t, a)), NZ = (t, a, c, f = !0, g = !1) => {
    const x = g ? Z$(c.icons) : YW(c.icons), w = (A) => ({
      isEnabled: () => !_o.isDisabled(A),
      setEnabled: (F) => _o.set(A, !F),
      setIconFill: (F, H) => {
        ss(A.element, `svg path[class="${F}"], rect[class="${F}"]`).each((q) => {
          rn(q, "fill", H);
        });
      },
      setTooltip: (F) => {
        const H = c.translate(F);
        rn(A.element, "aria-label", H);
      }
    }), T = oh({
      presets: "normal",
      iconContent: t.icon,
      textContent: t.text,
      htmlContent: B.none(),
      ariaLabel: t.text,
      caret: B.some(x),
      checkMark: B.none(),
      shortcutContent: t.shortcut
    }, c, f);
    return $1({
      data: gx(t),
      getApi: w,
      enabled: t.enabled,
      onAction: G,
      onSetup: t.onSetup,
      triggersSubmenu: !0,
      itemBehaviours: []
    }, T, a, c);
  }, IL = (t, a, c, f = !0) => {
    const g = (w) => ({
      isEnabled: () => !_o.isDisabled(w),
      setEnabled: (T) => _o.set(w, !T)
    }), x = oh({
      presets: "normal",
      iconContent: t.icon,
      textContent: t.text,
      htmlContent: B.none(),
      ariaLabel: t.text,
      caret: B.none(),
      checkMark: B.none(),
      shortcutContent: t.shortcut
    }, c, f);
    return $1({
      data: gx(t),
      getApi: g,
      enabled: t.enabled,
      onAction: t.onAction,
      onSetup: t.onSetup,
      triggersSubmenu: !1,
      itemBehaviours: []
    }, x, a, c);
  }, MZ = (t) => ({
    type: "separator",
    dom: {
      tag: "div",
      classes: [
        bT,
        LD
      ]
    },
    components: t.text.map(Oa).toArray()
  }), IZ = (t, a, c, f = !0) => {
    const g = (w) => ({
      setActive: (T) => {
        ir.set(w, T);
      },
      isActive: () => ir.isOn(w),
      isEnabled: () => !_o.isDisabled(w),
      setEnabled: (T) => _o.set(w, !T)
    }), x = oh({
      iconContent: t.icon,
      textContent: t.text,
      htmlContent: B.none(),
      ariaLabel: t.text,
      checkMark: B.some(W$(c.icons)),
      caret: B.none(),
      shortcutContent: t.shortcut,
      presets: "normal",
      meta: t.meta
    }, c, f);
    return Fs($1({
      data: gx(t),
      enabled: t.enabled,
      getApi: g,
      onAction: t.onAction,
      onSetup: t.onSetup,
      triggersSubmenu: !1,
      itemBehaviours: []
    }, x, a, c), {
      toggling: {
        toggleClass: vT,
        toggleOnExecute: !1,
        selected: t.active
      },
      role: t.role.getOrUndefined()
    });
  }, FZ = Q$, ER = MZ, BZ = IL, $Z = NZ, LZ = IZ, HZ = ML, FL = pR;
  var VZ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getCoupled: (t, a, c, f) => c.getOrCreate(t, a, f),
    getExistingCoupled: (t, a, c, f) => c.getExisting(t, a, f)
  }), BL = [Vr("others", Fu(zo.value, uu()))], jZ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = {}, a = (x, w) => {
        if (Qo(x.others).length === 0)
          throw new Error("Cannot find any known coupled components");
        return Ht(t, w);
      }, c = (x, w, T) => a(w, T).getOrThunk(() => {
        const F = Ht(w.others, T).getOrDie("No information found for coupled component: " + T)(x), H = x.getSystem().build(F);
        return t[T] = H, H;
      }), f = (x, w, T) => a(w, T).orThunk(() => (Ht(w.others, T).getOrDie("No information found for coupled component: " + T), B.none())), g = te({});
      return Wc({
        readState: g,
        getExisting: f,
        getOrCreate: c
      });
    }
  });
  const Ia = Xi({
    fields: BL,
    name: "coupling",
    apis: VZ,
    state: jZ
  }), TR = (t) => {
    let a = B.none(), c = [];
    const f = (F) => TR((H) => {
      g((q) => {
        H(F(q));
      });
    }), g = (F) => {
      w() ? A(F) : c.push(F);
    }, x = (F) => {
      w() || (a = B.some(F), T(c), c = []);
    }, w = () => a.isSome(), T = (F) => {
      mt(F, A);
    }, A = (F) => {
      a.each((H) => {
        setTimeout(() => {
          F(H);
        }, 0);
      });
    };
    return t(x), {
      get: g,
      map: f,
      isReady: w
    };
  }, UZ = {
    nu: TR,
    pure: (t) => TR((a) => {
      a(t);
    })
  }, WZ = (t) => {
    setTimeout(() => {
      throw t;
    }, 0);
  }, yx = (t) => {
    const a = (A) => {
      t().then(A, WZ);
    };
    return {
      map: (A) => yx(() => t().then(A)),
      bind: (A) => yx(() => t().then((F) => A(F).toPromise())),
      anonBind: (A) => yx(() => t().then(() => A.toPromise())),
      toLazy: () => UZ.nu(a),
      toCached: () => {
        let A = null;
        return yx(() => (A === null && (A = t()), A));
      },
      toPromise: t,
      get: a
    };
  }, jl = {
    nu: (t) => yx(() => new Promise(t)),
    pure: (t) => yx(() => Promise.resolve(t))
  }, $L = te("sink"), LL = te(yu({
    name: $L(),
    overrides: te({
      dom: { tag: "div" },
      behaviours: Qt([tl.config({ useFixed: qe })]),
      events: js([
        nf(Cd()),
        nf(nc()),
        nf(Vh())
      ])
    })
  })), OR = (t, a) => {
    const c = t.getHotspot(a).getOr(a), f = "hotspot", g = t.getAnchorOverrides();
    return t.layouts.fold(() => ({
      type: f,
      hotspot: c,
      overrides: g
    }), (x) => ({
      type: f,
      hotspot: c,
      overrides: g,
      layouts: x
    }));
  }, ZZ = (t, a, c) => {
    const f = t.fetch;
    return f(c).map(a);
  }, GZ = (t, a, c, f, g, x, w) => {
    const T = ZZ(t, a, f), A = HL(f, t);
    return T.map((F) => F.bind((H) => {
      const q = H.menus[H.primary];
      return B.from(q).each((ne) => {
        t.listRole.each((ie) => {
          ne.role = ie;
        });
      }), B.from(E1.sketch({
        ...x.menu(),
        uid: ng(""),
        data: H,
        highlightOnOpen: w,
        onOpenMenu: (ne, ie) => {
          const fe = A().getOrDie();
          tl.position(fe, ie, { anchor: c }), Br.decloak(g);
        },
        onOpenSubmenu: (ne, ie, fe) => {
          const _e = A().getOrDie();
          tl.position(_e, fe, {
            anchor: {
              type: "submenu",
              item: ie
            }
          }), Br.decloak(g);
        },
        onRepositionMenu: (ne, ie, fe) => {
          const _e = A().getOrDie();
          tl.position(_e, ie, { anchor: c }), mt(fe, (st) => {
            tl.position(_e, st.triggeredMenu, {
              anchor: {
                type: "submenu",
                item: st.triggeringItem
              }
            });
          });
        },
        onEscape: () => (Ao.focus(f), Br.close(g), B.some(!0))
      }));
    }));
  }, qT = (t, a, c, f, g, x, w) => {
    const T = OR(t, c);
    return GZ(t, a, T, c, f, g, w).map((F) => (F.fold(() => {
      Br.isOpen(f) && Br.close(f);
    }, (H) => {
      Br.cloak(f), Br.open(f, H), x(f);
    }), f));
  }, qZ = (t, a, c, f, g, x, w) => (Br.close(f), jl.pure(f)), AR = (t, a, c, f, g, x) => {
    const w = Ia.getCoupled(c, "sandbox");
    return (Br.isOpen(w) ? qZ : qT)(t, a, c, w, f, g, x);
  }, PR = (t, a, c) => {
    const f = Nr.getCurrent(a).getOr(a), g = Pi(t.element);
    c ? Ln(f.element, "min-width", g + "px") : gr(f.element, g);
  }, HL = (t, a) => t.getSystem().getByUid(a.uid + "-" + $L()).map((c) => () => zo.value(c)).getOrThunk(() => a.lazySink.fold(() => () => zo.error(new Error("No internal sink is specified, nor could an external sink be found")), (c) => () => c(t))), zL = (t) => {
    Br.getState(t).each((a) => {
      E1.repositionMenus(a);
    });
  }, DR = (t, a, c) => {
    const f = sy(), g = (T, A) => {
      const F = OR(t, a);
      f.link(a.element), t.matchWidth && PR(F.hotspot, A, t.useMinWidth), t.onOpen(F, T, A), c !== void 0 && c.onOpen !== void 0 && c.onOpen(T, A);
    }, x = (T, A) => {
      f.unlink(a.element), w().getOr(A).element.dom.dispatchEvent(new window.FocusEvent("focusout")), c !== void 0 && c.onClose !== void 0 && c.onClose(T, A);
    }, w = HL(a, t);
    return {
      dom: {
        tag: "div",
        classes: t.sandboxClasses,
        attributes: { id: f.id }
      },
      behaviours: Zu.augment(t.sandboxBehaviours, [
        Mn.config({
          store: {
            mode: "memory",
            initialValue: a
          }
        }),
        Br.config({
          onOpen: g,
          onClose: x,
          isPartOf: (T, A, F) => Ip(A, F) || Ip(a, F),
          getAttachPoint: () => w().getOrDie()
        }),
        Nr.config({
          find: (T) => Br.getState(T).bind((A) => Nr.getCurrent(A))
        }),
        Ac.config({
          channels: {
            ...Lm({ isExtraPart: wt }),
            ...$y({ doReposition: zL })
          }
        })
      ])
    };
  }, RR = (t) => {
    const a = Ia.getCoupled(t, "sandbox");
    zL(a);
  }, KT = () => [
    Qe("sandboxClasses", []),
    Zu.field("sandboxBehaviours", [
      Nr,
      Ac,
      Br,
      Mn
    ])
  ], KZ = te([
    Rt("dom"),
    Rt("fetch"),
    Rr("onOpen"),
    sc("onExecute"),
    Qe("getHotspot", B.some),
    Qe("getAnchorOverrides", te({})),
    jp(),
    $i("dropdownBehaviours", [
      ir,
      Ia,
      oo,
      Ao
    ]),
    Rt("toggleClass"),
    Qe("eventOrder", {}),
    jr("lazySink"),
    Qe("matchWidth", !1),
    Qe("useMinWidth", !1),
    jr("role"),
    jr("listRole")
  ].concat(KT())), YZ = te([
    Gu({
      schema: [
        tg(),
        Qe("fakeFocus", !1)
      ],
      name: "menu",
      defaults: (t) => ({ onExecute: t.onExecute })
    }),
    LL()
  ]), VL = (t, a, c, f) => {
    const g = (H) => Ht(t.dom, "attributes").bind((q) => Ht(q, H)), x = (H) => {
      Br.getState(H).each((q) => {
        E1.highlightPrimary(q);
      });
    }, w = (H, q, ne) => AR(t, lt, H, f, q, ne), T = (H) => {
      w(H, x, Dc.HighlightMenuAndItem).get(G);
    }, A = {
      expand: (H) => {
        ir.isOn(H) || w(H, G, Dc.HighlightNone).get(G);
      },
      open: (H) => {
        ir.isOn(H) || w(H, G, Dc.HighlightMenuAndItem).get(G);
      },
      refetch: (H) => Ia.getExistingCoupled(H, "sandbox").fold(() => w(H, G, Dc.HighlightMenuAndItem).map(G), (ne) => qT(t, lt, H, ne, f, G, Dc.HighlightMenuAndItem).map(G)),
      isOpen: ir.isOn,
      close: (H) => {
        ir.isOn(H) && w(H, G, Dc.HighlightMenuAndItem).get(G);
      },
      repositionMenus: (H) => {
        ir.isOn(H) && RR(H);
      }
    }, F = (H, q) => (Tp(H), B.some(!0));
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      behaviours: Li(t.dropdownBehaviours, [
        ir.config({
          toggleClass: t.toggleClass,
          aria: { mode: "expanded" }
        }),
        Ia.config({
          others: {
            sandbox: (H) => DR(t, H, {
              onOpen: () => ir.on(H),
              onClose: () => ir.off(H)
            })
          }
        }),
        oo.config({
          mode: "special",
          onSpace: F,
          onEnter: F,
          onDown: (H, q) => {
            if (gf.isOpen(H)) {
              const ne = Ia.getCoupled(H, "sandbox");
              x(ne);
            } else
              gf.open(H);
            return B.some(!0);
          },
          onEscape: (H, q) => gf.isOpen(H) ? (gf.close(H), B.some(!0)) : B.none()
        }),
        Ao.config({})
      ]),
      events: WE(B.some(T)),
      eventOrder: {
        ...t.eventOrder,
        [zu()]: [
          "disabling",
          "toggling",
          "alloy.base.behaviour"
        ]
      },
      apis: A,
      domModification: {
        attributes: {
          "aria-haspopup": t.listRole.getOr("true"),
          ...t.role.fold(() => ({}), (H) => ({ role: H })),
          ...t.dom.tag === "button" ? { type: g("type").getOr("button") } : {}
        }
      }
    };
  }, gf = Vl({
    name: "Dropdown",
    configFields: KZ(),
    partFields: YZ(),
    factory: VL,
    apis: {
      open: (t, a) => t.open(a),
      refetch: (t, a) => t.refetch(a),
      expand: (t, a) => t.expand(a),
      close: (t, a) => t.close(a),
      isOpen: (t, a) => t.isOpen(a),
      repositionMenus: (t, a) => t.repositionMenus(a)
    }
  }), XZ = (t) => {
    switch (t.searchMode) {
      case "no-search":
        return { menuType: "normal" };
      default:
        return {
          menuType: "searchable",
          searchMode: t
        };
    }
  }, QZ = (t) => {
    const a = Mn.getValue(t), c = Xb(t).map(S$);
    gf.refetch(a).get(() => {
      const f = Ia.getCoupled(a, "sandbox");
      c.each((g) => Xb(f).each((x) => SW(x, g)));
    });
  }, JZ = (t, a) => {
    eG(t).each((c) => {
      Hw(t, c.element, a.event.eventType, a.event.interactionEvent);
    });
  }, eG = (t) => Br.getState(t).bind(wn.getHighlighted).bind(wn.getHighlighted), tG = (t) => Zc(t.element, wT) ? B.some(t.element) : ss(t.element, "." + wT), fS = (t, a, c) => {
    KD(t).each((f) => {
      kW(f, c), tG(a).each((x) => {
        K(x, "id").each((w) => rn(f.element, "aria-controls", w));
      });
    }), rn(c.element, "aria-selected", "true");
  }, nG = (t, a, c) => {
    rn(c.element, "aria-selected", "false");
  }, YT = (t) => {
    KD(t).each((a) => Ao.focus(a));
  }, oG = (t) => Ia.getExistingCoupled(t, "sandbox").bind(Xb).map(S$).map((c) => c.fetchPattern).getOr("");
  var XT;
  (function(t) {
    t[t.ContentFocus = 0] = "ContentFocus", t[t.UiFocus = 1] = "UiFocus";
  })(XT || (XT = {}));
  const rG = (t, a, c, f, g) => {
    const x = c.shared.providers, w = (T) => g ? {
      ...T,
      shortcut: B.none(),
      icon: T.text.isSome() ? B.none() : T.icon
    } : T;
    switch (t.type) {
      case "menuitem":
        return zW(t).fold(Tg, (T) => B.some(BZ(w(T), a, x, f)));
      case "nestedmenuitem":
        return jW(t).fold(Tg, (T) => B.some($Z(w(T), a, x, f, g)));
      case "togglemenuitem":
        return WW(t).fold(Tg, (T) => B.some(LZ(w(T), a, x, f)));
      case "separator":
        return M$(t).fold(Tg, (T) => B.some(ER(T)));
      case "fancymenuitem":
        return H$(t).fold(Tg, (T) => HZ(T, c));
      default:
        return console.error("Unknown item in general menu", t), B.none();
    }
  }, sG = (t, a, c, f, g, x, w) => {
    const T = f === 1, A = !T || JC(t);
    return Ks(tt(t, (F) => {
      switch (F.type) {
        case "separator":
          return NW(F).fold(Tg, (H) => B.some(ER(H)));
        case "cardmenuitem":
          return iR(F).fold(Tg, (H) => B.some(FL({
            ...H,
            onAction: (q) => {
              H.onAction(q), c(H.value, H.meta);
            }
          }, g, x, {
            itemBehaviours: Y$(H.meta, x, B.none()),
            cardText: {
              matchText: a,
              highlightOn: w
            }
          })));
        case "autocompleteitem":
        default:
          return MW(F).fold(Tg, (H) => B.some(FZ(H, a, T, "normal", c, g, x, A)));
      }
    }));
  }, aG = (t, a, c, f, g, x) => {
    const w = JC(a), T = Ks(tt(a, (H) => {
      const q = (ie) => g ? !Ho(ie, "text") : w, ne = (ie) => rG(ie, c, f, q(ie), g);
      return H.type === "nestedmenuitem" && H.getSubmenuItems().length <= 0 ? ne({
        ...H,
        enabled: !1
      }) : ne(H);
    })), A = XZ(x);
    return (g ? TW : QD)(t, w, T, 1, A);
  }, xx = (t) => E1.singleData(t.value, t), wx = (t, a, c, f) => {
    const g = GT(a, f), x = Yb(f);
    return {
      data: xx({
        ...t,
        movement: g,
        menuBehaviours: hx.unnamedEvents(a !== "auto" ? [] : [Qs((w, T) => {
          NT(w, 4, x.item).each(({ numColumns: A, numRows: F }) => {
            oo.setGridSize(w, F, A);
          });
        })])
      }),
      menu: {
        markers: Yb(f),
        fakeFocus: c === XT.ContentFocus
      }
    };
  }, jL = (t) => Tb.create(He.fromDom(t.startContainer), t.startOffset, He.fromDom(t.endContainer), t.endOffset), lG = { register: (t, a) => {
    const c = Nn("autocompleter"), f = no(!1), g = no(!1), x = ms(), w = Al(la.sketch({
      dom: {
        tag: "div",
        classes: ["tox-autocompleter"],
        attributes: { id: c }
      },
      components: [],
      fireDismissalEventInstead: {},
      inlineBehaviours: Qt([Go("dismissAutocompleter", [
        It(_p(), () => q()),
        It(Ep(), (De, Je) => {
          K(Je.event.target, "id").each((Ge) => rn(He.fromDom(t.getBody()), "aria-activedescendant", Ge));
        })
      ])]),
      lazySink: a.getSink
    })), T = () => la.isOpen(w), A = g.get, F = () => {
      if (T()) {
        la.hide(w), t.dom.remove(c, !1);
        const De = He.fromDom(t.getBody());
        K(De, "aria-owns").filter((Je) => Je === c).each(() => {
          Ee(De, "aria-owns"), Ee(De, "aria-activedescendant");
        });
      }
    }, H = () => la.getContent(w).bind((De) => Pn(De.components(), 0)), q = () => t.execCommand("mceAutocompleterClose"), ne = (De) => {
      const Je = Ko(De, (Ge) => B.from(Ge.columns)).getOr(1);
      return Ue(De, (Ge) => {
        const Ft = Ge.items;
        return sG(Ft, Ge.matchText, (gt, Jt) => {
          const vn = {
            hide: () => q(),
            reload: (Nt) => {
              F(), t.execCommand("mceAutocompleterReload", !1, { fetchOptions: Nt });
            }
          };
          t.execCommand("mceAutocompleterRefreshActiveRange"), x.get().each((Nt) => {
            f.set(!0), Ge.onAction(vn, Nt, gt, Jt), f.set(!1);
          });
        }, Je, em.BUBBLE_TO_SANDBOX, a, Ge.highlightOn);
      });
    }, ie = (De, Je) => {
      const Ge = Ko(De, (Ft) => B.from(Ft.columns)).getOr(1);
      la.showMenuAt(w, {
        anchor: {
          type: "selection",
          getSelection: () => x.get().map(jL),
          root: He.fromDom(t.getBody())
        }
      }, wx(QD("autocompleter-value", !0, Je, Ge, { menuType: "normal" }), Ge, XT.ContentFocus, "normal")), H().each(wn.highlightFirst);
    }, fe = (De) => {
      const Je = ne(De);
      Je.length > 0 ? (ie(De, Je), rn(He.fromDom(t.getBody()), "aria-owns", c), t.inline || _e()) : F();
    }, _e = () => {
      t.dom.get(c) && t.dom.remove(c, !1);
      const De = t.getDoc().documentElement, Je = t.selection.getNode(), Ge = c4(w.element);
      Rs(Ge, {
        border: "0",
        clip: "rect(0 0 0 0)",
        height: "1px",
        margin: "-1px",
        overflow: "hidden",
        padding: "0",
        position: "absolute",
        width: "1px",
        top: `${Je.offsetTop}px`,
        left: `${Je.offsetLeft}px`
      }), t.dom.add(De, Ge.dom), ss(Ge, '[role="menu"]').each((Ft) => {
        xr(Ft, "position"), xr(Ft, "max-height");
      });
    };
    t.on("AutocompleterStart", ({ lookupData: De }) => {
      g.set(!0), f.set(!1), fe(De);
    }), t.on("AutocompleterUpdate", ({ lookupData: De }) => fe(De)), t.on("AutocompleterUpdateActiveRange", ({ range: De }) => x.set(De)), t.on("AutocompleterEnd", () => {
      F(), g.set(!1), f.set(!1), x.clear();
    });
    const st = {
      cancelIfNecessary: q,
      isMenuOpen: T,
      isActive: A,
      isProcessingAction: f.get,
      getMenu: H
    };
    m$.setup(st, t);
  } }, mS = (t, a, c) => cf(t, a, c).isSome(), UL = (t, a) => {
    let c = null;
    return {
      cancel: () => {
        c !== null && (clearTimeout(c), c = null);
      },
      schedule: (...x) => {
        c = setTimeout(() => {
          t.apply(null, x), c = null;
        }, a);
      }
    };
  }, WL = 5, cG = 400, ZL = (t) => {
    const a = t.raw;
    return a.touches === void 0 || a.touches.length !== 1 ? B.none() : B.some(a.touches[0]);
  }, uG = (t, a) => {
    const c = Math.abs(t.clientX - a.x), f = Math.abs(t.clientY - a.y);
    return c > WL || f > WL;
  }, dG = (t) => {
    const a = ms(), c = no(!1), f = UL((F) => {
      t.triggerEvent(Tl(), F), c.set(!0);
    }, cG), g = (F) => (ZL(F).each((H) => {
      f.cancel();
      const q = {
        x: H.clientX,
        y: H.clientY,
        target: F.target
      };
      f.schedule(F), c.set(!1), a.set(q);
    }), B.none()), x = (F) => (f.cancel(), ZL(F).each((H) => {
      a.on((q) => {
        uG(H, q) && a.clear();
      });
    }), B.none()), w = (F) => {
      f.cancel();
      const H = (q) => Lr(q.target, F.target);
      return a.get().filter(H).map((q) => c.get() ? (F.prevent(), !1) : t.triggerEvent(ef(), F));
    }, T = Zr([
      {
        key: wr(),
        value: g
      },
      {
        key: Xs(),
        value: x
      },
      {
        key: Ja(),
        value: w
      }
    ]);
    return { fireIfReady: (F, H) => Ht(T, H).bind((q) => q(F)) };
  }, fG = (t) => t.raw.which === Xr[0] && !jt([
    "input",
    "textarea"
  ], Kr(t.target)) && !mS(t.target, '[contenteditable="true"]'), mG = (t, a) => {
    const c = {
      stopBackspace: !0,
      ...a
    }, f = [
      "touchstart",
      "touchmove",
      "touchend",
      "touchcancel",
      "gesturestart",
      "mousedown",
      "mouseup",
      "mouseover",
      "mousemove",
      "mouseout",
      "click"
    ], g = dG(c), x = tt(f.concat([
      "selectstart",
      "input",
      "contextmenu",
      "change",
      "transitionend",
      "transitioncancel",
      "drag",
      "dragstart",
      "dragend",
      "dragenter",
      "dragleave",
      "dragover",
      "drop",
      "keyup"
    ]), (ie) => lc(t, ie, (fe) => {
      g.fireIfReady(fe, ie).each((st) => {
        st && fe.kill();
      }), c.triggerEvent(ie, fe) && fe.kill();
    })), w = ms(), T = lc(t, "paste", (ie) => {
      g.fireIfReady(ie, "paste").each((_e) => {
        _e && ie.kill();
      }), c.triggerEvent("paste", ie) && ie.kill(), w.set(setTimeout(() => {
        c.triggerEvent(Om(), ie);
      }, 0));
    }), A = lc(t, "keydown", (ie) => {
      c.triggerEvent("keydown", ie) ? ie.kill() : c.stopBackspace && fG(ie) && ie.prevent();
    }), F = lc(t, "focusin", (ie) => {
      c.triggerEvent("focusin", ie) && ie.kill();
    }), H = ms(), q = lc(t, "focusout", (ie) => {
      c.triggerEvent("focusout", ie) && ie.kill(), H.set(setTimeout(() => {
        c.triggerEvent(kp(), ie);
      }, 0));
    });
    return { unbind: () => {
      mt(x, (ie) => {
        ie.unbind();
      }), A.unbind(), F.unbind(), q.unbind(), T.unbind(), w.on(clearTimeout), H.on(clearTimeout);
    } };
  }, GL = (t, a) => {
    const c = Ht(t, "target").getOr(a);
    return no(c);
  }, qL = (t, a) => {
    const c = no(!1), f = no(!1);
    return {
      stop: () => {
        c.set(!0);
      },
      cut: () => {
        f.set(!0);
      },
      isStopped: c.get,
      isCut: f.get,
      event: t,
      setSource: a.set,
      getSource: a.get
    };
  }, Cx = (t) => {
    const a = no(!1);
    return {
      stop: () => {
        a.set(!0);
      },
      cut: G,
      isStopped: a.get,
      isCut: wt,
      event: t,
      setSource: ye("Cannot set source of a broadcasted event"),
      getSource: ye("Cannot get source of a broadcasted event")
    };
  }, Gm = Be.generate([
    { stopped: [] },
    { resume: ["element"] },
    { complete: [] }
  ]), KL = (t, a, c, f, g, x) => {
    const w = t(a, f), T = qL(c, g);
    return w.fold(() => (x.logEventNoHandlers(a, f), Gm.complete()), (A) => {
      const F = A.descHandler;
      return Np(F)(T), T.isStopped() ? (x.logEventStopped(a, A.element, F.purpose), Gm.stopped()) : T.isCut() ? (x.logEventCut(a, A.element, F.purpose), Gm.complete()) : Za(A.element).fold(() => (x.logNoParent(a, A.element, F.purpose), Gm.complete()), (q) => (x.logEventResponse(a, A.element, F.purpose), Gm.resume(q)));
    });
  }, NR = (t, a, c, f, g, x) => KL(t, a, c, f, g, x).fold(qe, (w) => NR(t, a, c, w, g, x), wt), YL = (t, a, c, f, g) => {
    const x = GL(c, f);
    return KL(t, a, c, f, x, g);
  }, QT = (t, a, c) => {
    const f = Cx(a);
    return mt(t, (g) => {
      const x = g.descHandler;
      Np(x)(f);
    }), f.isStopped();
  }, pG = (t, a, c, f) => Sx(t, a, c, c.target, f), Sx = (t, a, c, f, g) => {
    const x = GL(c, f);
    return NR(t, a, c, f, x, g);
  }, pS = (t, a) => ({
    element: t,
    descHandler: a
  }), hG = (t, a) => ({
    id: t,
    descHandler: a
  }), gG = () => {
    const t = {}, a = (w, T, A) => {
      at(A, (F, H) => {
        const q = t[H] !== void 0 ? t[H] : {};
        q[T] = Gv(F, w), t[H] = q;
      });
    }, c = (w, T) => Zv(T).bind((A) => Ht(w, A)).map((A) => pS(T, A));
    return {
      registerId: a,
      unregisterId: (w) => {
        at(t, (T, A) => {
          Ho(T, w) && delete T[w];
        });
      },
      filterByType: (w) => Ht(t, w).map((T) => Ir(T, (A, F) => hG(F, A))).getOr([]),
      find: (w, T, A) => Ht(t, T).bind((F) => Ff(A, (H) => c(F, H), w))
    };
  }, bG = () => {
    const t = gG(), a = {}, c = (F) => {
      const H = F.element;
      return Zv(H).getOrThunk(() => h4("uid-", F.element));
    }, f = (F, H) => {
      const q = a[H];
      if (q === F)
        x(F);
      else
        throw new Error('The tagId "' + H + '" is already used by: ' + qc(q.element) + `
Cannot use it for: ` + qc(F.element) + `
The conflicting element is` + (yr(q.element) ? " " : " not ") + "already in the DOM");
    }, g = (F) => {
      const H = c(F);
      As(a, H) && f(F, H);
      const q = [F];
      t.registerId(q, H, F.events), a[H] = F;
    }, x = (F) => {
      Zv(F.element).each((H) => {
        delete a[H], t.unregisterId(H);
      });
    };
    return {
      find: (F, H, q) => t.find(F, H, q),
      filter: (F) => t.filterByType(F),
      register: g,
      unregister: x,
      getById: (F) => Ht(a, F)
    };
  }, qm = Pc({
    name: "Container",
    factory: (t) => {
      const { attributes: a, ...c } = t.dom;
      return {
        uid: t.uid,
        dom: {
          tag: "div",
          attributes: {
            role: "presentation",
            ...a
          },
          ...c
        },
        components: t.components,
        behaviours: d1(t.containerBehaviours),
        events: t.events,
        domModification: t.domModification,
        eventOrder: t.eventOrder
      };
    },
    configFields: [
      Qe("components", []),
      $i("containerBehaviours", []),
      Qe("events", {}),
      Qe("domModification", {}),
      Qe("eventOrder", {})
    ]
  }), MR = (t) => {
    const a = (De) => Za(t.element).fold(qe, (Je) => Lr(De, Je)), c = bG(), f = (De, Je) => c.find(a, De, Je), g = mG(t.element, {
      triggerEvent: (De, Je) => af(De, Je.target, (Ge) => pG(f, De, Je, Ge))
    }), x = {
      debugInfo: te("real"),
      triggerEvent: (De, Je, Ge) => {
        af(De, Je, (Ft) => Sx(f, De, Ge, Je, Ft));
      },
      triggerFocus: (De, Je) => {
        Zv(De).fold(() => {
          mu(De);
        }, (Ge) => {
          af(Jd(), De, (Ft) => (YL(f, Jd(), {
            originator: Je,
            kill: G,
            prevent: G,
            target: De
          }, De, Ft), !1));
        });
      },
      triggerEscape: (De, Je) => {
        x.triggerEvent("keydown", De.element, Je.event);
      },
      getByUid: (De) => _e(De),
      getByDom: (De) => st(De),
      build: Al,
      buildOrPatch: oy,
      addToGui: (De) => {
        A(De);
      },
      removeFromGui: (De) => {
        F(De);
      },
      addToWorld: (De) => {
        w(De);
      },
      removeFromWorld: (De) => {
        T(De);
      },
      broadcast: (De) => {
        ne(De);
      },
      broadcastOn: (De, Je) => {
        ie(De, Je);
      },
      broadcastEvent: (De, Je) => {
        fe(De, Je);
      },
      isConnected: qe
    }, w = (De) => {
      De.connect(x), Yo(De.element) || (c.register(De), mt(De.components(), w), x.triggerEvent(Nv(), De.element, { target: De.element }));
    }, T = (De) => {
      Yo(De.element) || (mt(De.components(), T), c.unregister(De)), De.disconnect();
    }, A = (De) => {
      Gf(t, De);
    }, F = (De) => {
      $m(De);
    }, H = () => {
      g.unbind(), Sc(t.element);
    }, q = (De) => {
      const Je = c.filter(Hu());
      mt(Je, (Ge) => {
        const Ft = Ge.descHandler;
        Np(Ft)(De);
      });
    }, ne = (De) => {
      q({
        universal: !0,
        data: De
      });
    }, ie = (De, Je) => {
      q({
        universal: !1,
        channels: De,
        data: Je
      });
    }, fe = (De, Je) => {
      const Ge = c.filter(De);
      return QT(Ge, Je);
    }, _e = (De) => c.getById(De).fold(() => zo.error(new Error('Could not find component with uid: "' + De + '" in system.')), zo.value), st = (De) => {
      const Je = Zv(De).getOr("not found");
      return _e(Je);
    };
    return w(t), {
      root: t,
      element: t.element,
      destroy: H,
      add: A,
      remove: F,
      getByUid: _e,
      getByDom: st,
      addToWorld: w,
      removeFromWorld: T,
      broadcast: ne,
      broadcastOn: ie,
      broadcastEvent: fe
    };
  }, JT = (t, a) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-bar",
        "tox-form__controls-h-stack"
      ]
    },
    components: tt(t.items, a.interpreter)
  }), vG = te([
    Qe("prefix", "form-field"),
    $i("fieldBehaviours", [
      Nr,
      Mn
    ])
  ]), IR = te([
    yu({
      schema: [Rt("dom")],
      name: "label"
    }),
    yu({
      factory: {
        sketch: (t) => ({
          uid: t.uid,
          dom: {
            tag: "span",
            styles: { display: "none" },
            attributes: { "aria-hidden": "true" },
            innerHtml: t.text
          }
        })
      },
      schema: [Rt("text")],
      name: "aria-descriptor"
    }),
    hl({
      factory: {
        sketch: (t) => {
          const a = ar(t, ["factory"]);
          return t.factory.sketch(a);
        }
      },
      schema: [Rt("factory")],
      name: "field"
    })
  ]), yG = (t, a, c, f) => {
    const g = Li(t.fieldBehaviours, [
      Nr.config({
        find: (T) => Xt(T, t, "field")
      }),
      Mn.config({
        store: {
          mode: "manual",
          getValue: (T) => Nr.getCurrent(T).bind(Mn.getValue),
          setValue: (T, A) => {
            Nr.getCurrent(T).each((F) => {
              Mn.setValue(F, A);
            });
          }
        }
      })
    ]), x = js([Qs((T, A) => {
      const F = TE(T, t, [
        "label",
        "field",
        "aria-descriptor"
      ]);
      F.field().each((H) => {
        const q = Nn(t.prefix);
        F.label().each((ne) => {
          rn(ne.element, "for", q), rn(H.element, "id", q);
        }), F["aria-descriptor"]().each((ne) => {
          const ie = Nn(t.prefix);
          rn(ne.element, "id", ie), rn(H.element, "aria-describedby", ie);
        });
      });
    })]), w = {
      getField: (T) => Xt(T, t, "field"),
      getLabel: (T) => Xt(T, t, "label")
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      behaviours: g,
      events: x,
      apis: w
    };
  }, gs = Vl({
    name: "FormField",
    configFields: vG(),
    partFields: IR(),
    factory: yG,
    apis: {
      getField: (t, a) => t.getField(a),
      getLabel: (t, a) => t.getLabel(a)
    }
  });
  var xG = tinymce.util.Tools.resolve("tinymce.html.Entities");
  const kx = (t, a, c, f) => {
    const g = CG(t, a, c, f);
    return gs.sketch(g);
  }, wG = (t, a) => kx(t, a, [], []), CG = (t, a, c, f) => ({
    dom: FR(c),
    components: t.toArray().concat([a]),
    fieldBehaviours: Qt(f)
  }), SG = () => FR([]), FR = (t) => ({
    tag: "div",
    classes: ["tox-form__group"].concat(t)
  }), ev = (t, a) => gs.parts.label({
    dom: {
      tag: "label",
      classes: ["tox-label"]
    },
    components: [Oa(a.translate(t))]
  }), wu = Nn("form-component-change"), hS = Nn("form-close"), tv = Nn("form-cancel"), ah = Nn("form-action"), _x = Nn("form-submit"), eO = Nn("form-block"), BR = Nn("form-unblock"), XL = Nn("form-tabchange"), QL = Nn("form-resize"), kG = (t, a, c) => {
    const f = t.label.map((ie) => ev(ie, a)), g = a.icons(), x = (ie) => {
      var fe;
      return (fe = g[ie]) !== null && fe !== void 0 ? fe : ie;
    }, w = (ie) => (fe, _e) => {
      cf(_e.event.target, "[data-collection-item-value]").each((st) => {
        ie(fe, _e, st, os(st, "data-collection-item-value"));
      });
    }, T = (ie, fe) => {
      const _e = tt(fe, (Je) => {
        const Ge = Ad.translate(Je.text), Ft = t.columns === 1 ? `<div class="tox-collection__item-label">${Ge}</div>` : "", gt = `<div class="tox-collection__item-icon">${x(Je.icon)}</div>`, Jt = {
          _: " ",
          " - ": " ",
          "-": " "
        }, vn = Ge.replace(/\_| \- |\-/g, (Yn) => Jt[Yn]), Nt = a.isDisabled() ? " tox-collection__item--state-disabled" : "";
        return `<div data-mce-tooltip="${vn}" class="tox-collection__item${Nt}" tabindex="-1" data-collection-item-value="${xG.encodeAllRaw(Je.value)}" aria-label="${vn}">${gt}${Ft}</div>`;
      }), st = t.columns !== "auto" && t.columns > 1 ? on(_e, t.columns) : [_e], De = tt(st, (Je) => `<div class="tox-collection__group">${Je.join("")}</div>`);
      bb(ie.element, De.join(""));
    }, A = w((ie, fe, _e, st) => {
      fe.stop(), a.isDisabled() || po(ie, ah, {
        name: t.name,
        value: st
      });
    }), F = [
      It(Bf(), w((ie, fe, _e) => {
        mu(_e);
      })),
      It(Vh(), A),
      It(ef(), A),
      It(Xd(), w((ie, fe, _e) => {
        ss(ie.element, "." + R1).each((st) => {
          va(st, R1);
        }), Us(_e, R1);
      })),
      It($f(), w((ie) => {
        ss(ie.element, "." + R1).each((fe) => {
          va(fe, R1), Qv(fe);
        });
      })),
      Sd(w((ie, fe, _e, st) => {
        po(ie, ah, {
          name: t.name,
          value: st
        });
      }))
    ], H = (ie, fe) => tt(Dl(ie.element, ".tox-collection__item"), fe), q = gs.parts.field({
      dom: {
        tag: "div",
        classes: ["tox-collection"].concat(t.columns !== 1 ? ["tox-collection--grid"] : ["tox-collection--list"])
      },
      components: [],
      factory: { sketch: lt },
      behaviours: Qt([
        _o.config({
          disabled: a.isDisabled,
          onDisabled: (ie) => {
            H(ie, (fe) => {
              Us(fe, "tox-collection__item--state-disabled"), rn(fe, "aria-disabled", !0);
            });
          },
          onEnabled: (ie) => {
            H(ie, (fe) => {
              va(fe, "tox-collection__item--state-disabled"), Ee(fe, "aria-disabled");
            });
          }
        }),
        Si(),
        No.config({}),
        gl.config({
          ...a.tooltips.getConfig({
            tooltipText: "",
            onShow: (ie) => {
              ss(ie.element, "." + R1 + "[data-mce-tooltip]").each((fe) => {
                K(fe, "data-mce-tooltip").each((_e) => {
                  gl.setComponents(ie, a.tooltips.getComponents({ tooltipText: _e }));
                });
              });
            }
          }),
          mode: "children-keyboard-focus",
          anchor: (ie) => ({
            type: "node",
            node: ss(ie.element, "." + R1).orThunk(() => ry(".tox-collection__item")),
            root: ie.element,
            layouts: {
              onLtr: te([
                ti,
                Ci,
                di,
                fi,
                ei,
                xs
              ]),
              onRtl: te([
                ti,
                Ci,
                di,
                fi,
                ei,
                xs
              ])
            },
            bubble: _d(0, -2, {})
          })
        }),
        Mn.config({
          store: {
            mode: "memory",
            initialValue: c.getOr([])
          },
          onSetValue: (ie, fe) => {
            T(ie, fe), t.columns === "auto" && NT(ie, 5, "tox-collection__item").each(({ numRows: _e, numColumns: st }) => {
              oo.setGridSize(ie, _e, st);
            }), tr(ie, QL);
          }
        }),
        Zs.config({}),
        oo.config(kZ(t.columns, "normal")),
        Go("collection-events", F)
      ]),
      eventOrder: {
        [zu()]: [
          "disabling",
          "alloy.base.behaviour",
          "collection-events"
        ],
        [Xd()]: [
          "collection-events",
          "tooltipping"
        ]
      }
    });
    return kx(f, q, ["tox-form__group--collection"], []);
  }, _G = [
    "input",
    "textarea"
  ], $R = (t) => {
    const a = Kr(t);
    return jt(_G, a);
  }, j1 = (t, a) => {
    const c = a.getRoot(t).getOr(t.element);
    va(c, a.invalidClass), a.notify.each((f) => {
      $R(t.element) && rn(t.element, "aria-invalid", !1), f.getContainer(t).each((g) => {
        bb(g, f.validHtml);
      }), f.onValid(t);
    });
  }, JL = (t, a, c, f) => {
    const g = a.getRoot(t).getOr(t.element);
    Us(g, a.invalidClass), a.notify.each((x) => {
      $R(t.element) && rn(t.element, "aria-invalid", !0), x.getContainer(t).each((w) => {
        bb(w, f);
      }), x.onInvalid(t, f);
    });
  }, e6 = (t, a, c) => a.validator.fold(() => jl.pure(zo.value(!0)), (f) => f.validate(t)), LR = (t, a, c) => (a.notify.each((f) => {
    f.onValidate(t);
  }), e6(t, a).map((f) => t.getSystem().isConnected() ? f.fold((g) => (JL(t, a, c, g), zo.error(g)), (g) => (j1(t, a), zo.value(g))) : zo.error("No longer in system")));
  var bf = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    markValid: j1,
    markInvalid: JL,
    query: e6,
    run: LR,
    isInvalid: (t, a) => {
      const c = a.getRoot(t).getOr(t.element);
      return Zc(c, a.invalidClass);
    }
  }), n6 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, a) => t.validator.map((c) => js([It(c.onEvent, (f) => {
      LR(f, t, a).get(lt);
    })].concat(c.validateOnLoad ? [Qs((f) => {
      LR(f, t, a).get(G);
    })] : []))).getOr({})
  }), EG = [
    Rt("invalidClass"),
    Qe("getRoot", B.none),
    Es("notify", [
      Qe("aria", "alert"),
      Qe("getContainer", B.none),
      Qe("validHtml", ""),
      Rr("onValid"),
      Rr("onInvalid"),
      Rr("onValidate")
    ]),
    Es("validator", [
      Rt("validate"),
      Qe("onEvent", "input"),
      Qe("validateOnLoad", !0)
    ])
  ];
  const ih = Xi({
    fields: EG,
    name: "invalidating",
    active: n6,
    apis: bf,
    extra: {
      validation: (t) => (a) => {
        const c = Mn.getValue(a);
        return jl.pure(t(c));
      }
    }
  });
  var o6 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: () => js([Zk(Iw(), qe)]),
    exhibit: () => Uc({
      styles: {
        "-webkit-user-select": "none",
        "user-select": "none",
        "-ms-user-select": "none",
        "-moz-user-select": "-moz-none"
      },
      attributes: { unselectable: "on" }
    })
  });
  const Ex = Xi({
    fields: [],
    name: "unselecting",
    active: o6
  }), TG = (t, a) => gf.sketch({
    dom: t.dom,
    components: t.components,
    toggleClass: "mce-active",
    dropdownBehaviours: Qt([
      rm.button(a.providers.isDisabled),
      Si(),
      Ex.config({}),
      Zs.config({})
    ]),
    layouts: t.layouts,
    sandboxClasses: ["tox-dialog__popups"],
    lazySink: a.getSink,
    fetch: (c) => jl.nu((f) => t.fetch(f)).map((f) => B.from(xx(Fs(_R(Nn("menu-value"), f, (g) => {
      t.onItemAction(c, g);
    }, t.columns, t.presets, em.CLOSE_ON_EXECUTE, wt, a.providers), { movement: GT(t.columns, t.presets) })))),
    parts: { menu: XC(!1, 1, t.presets) }
  }), r6 = Nn("color-input-change"), zR = Nn("color-swatch-change"), s6 = Nn("color-picker-cancel"), a6 = (t, a, c, f) => {
    const g = gs.parts.field({
      factory: N1,
      inputClasses: ["tox-textfield"],
      data: f,
      onSetValue: (F) => ih.run(F).get(G),
      inputBehaviours: Qt([
        _o.config({ disabled: a.providers.isDisabled }),
        Si(),
        Zs.config({}),
        ih.config({
          invalidClass: "tox-textbox-field-invalid",
          getRoot: (F) => Ui(F.element),
          notify: {
            onValid: (F) => {
              const H = Mn.getValue(F);
              po(F, r6, { color: H });
            }
          },
          validator: {
            validateOnLoad: !1,
            validate: (F) => {
              const H = Mn.getValue(F);
              if (H.length === 0)
                return jl.pure(zo.value(!0));
              {
                const q = He.fromTag("span");
                Ln(q, "background-color", H);
                const ne = ks(q, "background-color").fold(() => zo.error("blah"), (ie) => zo.value(H));
                return jl.pure(ne);
              }
            }
          }
        })
      ]),
      selectOnFocus: !1
    }), x = t.label.map((F) => ev(F, a.providers)), w = (F, H) => {
      po(F, zR, { value: H });
    }, T = (F, H) => {
      A.getOpt(F).each((q) => {
        H === "custom" ? c.colorPicker((ne) => {
          ne.fold(() => tr(q, s6), (ie) => {
            w(q, ie), UT(t.storageKey, ie);
          });
        }, "#ffffff") : H === "remove" ? w(q, "") : w(q, H);
      });
    }, A = is(TG({
      dom: {
        tag: "span",
        attributes: { "aria-label": a.providers.translate("Color swatch") }
      },
      layouts: {
        onRtl: () => [
          ei,
          di,
          ti
        ],
        onLtr: () => [
          di,
          ei,
          ti
        ]
      },
      components: [],
      fetch: _L(c.getColors(t.storageKey), t.storageKey, c.hasCustomColors()),
      columns: c.getColorCols(t.storageKey),
      presets: "color",
      onItemAction: T
    }, a));
    return gs.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: x.toArray().concat([{
        dom: {
          tag: "div",
          classes: ["tox-color-input"]
        },
        components: [
          g,
          A.asSpec()
        ]
      }]),
      fieldBehaviours: Qt([Go("form-field-events", [
        It(r6, (F, H) => {
          A.getOpt(F).each((q) => {
            Ln(q.element, "background-color", H.event.color);
          }), po(F, wu, { name: t.name });
        }),
        It(zR, (F, H) => {
          gs.getField(F).each((q) => {
            Mn.setValue(q, H.event.value), Nr.getCurrent(F).each(Ao.focus);
          });
        }),
        It(s6, (F, H) => {
          gs.getField(F).each((q) => {
            Nr.getCurrent(F).each(Ao.focus);
          });
        })
      ])])
    });
  }, i6 = yu({
    schema: [Rt("dom")],
    name: "label"
  }), Pg = (t) => yu({
    name: "" + t + "-edge",
    overrides: (a) => a.model.manager.edgeActions[t].fold(() => ({}), (f) => ({
      events: js([
        Zh(wr(), (g, x, w) => f(g, w), [a]),
        Zh(nc(), (g, x, w) => f(g, w), [a]),
        Zh(sb(), (g, x, w) => {
          w.mouseIsDown.get() && f(g, w);
        }, [a])
      ])
    }))
  }), OG = Pg("top-left"), AG = Pg("top"), PG = Pg("top-right"), DG = Pg("right"), RG = Pg("bottom-right"), NG = Pg("bottom"), VR = Pg("bottom-left"), MG = Pg("left"), IG = hl({
    name: "thumb",
    defaults: te({ dom: { styles: { position: "absolute" } } }),
    overrides: (t) => ({
      events: js([
        Gh(wr(), t, "spectrum"),
        Gh(Xs(), t, "spectrum"),
        Gh(Ja(), t, "spectrum"),
        Gh(nc(), t, "spectrum"),
        Gh(sb(), t, "spectrum"),
        Gh(Tm(), t, "spectrum")
      ])
    })
  }), gS = (t) => Qf(t.event), FG = hl({
    schema: [Wr("mouseIsDown", () => no(!1))],
    name: "spectrum",
    overrides: (t) => {
      const c = t.model.manager, f = (g, x) => c.getValueFromEvent(x).map((w) => c.setValueFrom(g, t, w));
      return {
        behaviours: Qt([
          oo.config({
            mode: "special",
            onLeft: (g, x) => c.onLeft(g, t, gS(x)),
            onRight: (g, x) => c.onRight(g, t, gS(x)),
            onUp: (g, x) => c.onUp(g, t, gS(x)),
            onDown: (g, x) => c.onDown(g, t, gS(x))
          }),
          Zs.config({}),
          Ao.config({})
        ]),
        events: js([
          It(wr(), f),
          It(Xs(), f),
          It(nc(), f),
          It(sb(), (g, x) => {
            t.mouseIsDown.get() && f(g, x);
          })
        ])
      };
    }
  });
  var BG = [
    i6,
    MG,
    DG,
    AG,
    NG,
    OG,
    PG,
    VR,
    RG,
    IG,
    FG
  ];
  const bS = te("slider.change.value"), $G = (t) => t.type.indexOf("touch") !== -1, jR = (t) => {
    const a = t.event.raw;
    if ($G(a)) {
      const c = a;
      return c.touches !== void 0 && c.touches.length === 1 ? B.some(c.touches[0]).map((f) => zs(f.clientX, f.clientY)) : B.none();
    } else {
      const c = a;
      return c.clientX !== void 0 ? B.some(c).map((f) => zs(f.clientX, f.clientY)) : B.none();
    }
  }, l6 = "top", LG = "right", c6 = "bottom", u6 = "left", U1 = (t) => t.model.minX, W1 = (t) => t.model.minY, tO = (t) => t.model.minX - 1, nO = (t) => t.model.minY - 1, Z1 = (t) => t.model.maxX, G1 = (t) => t.model.maxY, vS = (t) => t.model.maxX + 1, q1 = (t) => t.model.maxY + 1, UR = (t, a, c) => a(t) - c(t), yS = (t) => UR(t, Z1, U1), WR = (t) => UR(t, G1, W1), ZR = (t) => yS(t) / 2, d6 = (t) => WR(t) / 2, Tx = (t, a) => a ? t.stepSize * t.speedMultiplier : t.stepSize, f6 = (t) => t.snapToGrid, m6 = (t) => t.snapStart, oO = (t) => t.rounded, sm = (t, a) => t[a + "-edge"] !== void 0, p6 = (t) => sm(t, u6), Ox = (t) => sm(t, LG), h6 = (t) => sm(t, l6), rO = (t) => sm(t, c6), Dg = (t) => t.model.value.get(), nv = (t, a) => ({
    x: t,
    y: a
  }), am = (t, a) => {
    po(t, bS(), { value: a });
  }, g6 = (t, a) => {
    am(t, nv(tO(a), nO(a)));
  }, HG = (t, a) => {
    am(t, nO(a));
  }, GR = (t, a) => {
    am(t, nv(ZR(a), nO(a)));
  }, qR = (t, a) => {
    am(t, nv(vS(a), nO(a)));
  }, KR = (t, a) => {
    am(t, vS(a));
  }, zG = (t, a) => {
    am(t, nv(vS(a), d6(a)));
  }, Pd = (t, a) => {
    am(t, nv(vS(a), q1(a)));
  }, VG = (t, a) => {
    am(t, q1(a));
  }, jG = (t, a) => {
    am(t, nv(ZR(a), q1(a)));
  }, b6 = (t, a) => {
    am(t, nv(tO(a), q1(a)));
  }, v6 = (t, a) => {
    am(t, tO(a));
  }, UG = (t, a) => {
    am(t, nv(tO(a), d6(a)));
  }, YR = (t, a, c, f) => t < a ? t : t > c ? c : t === a ? a - 1 : Math.max(a, t - f), XR = (t, a, c, f) => t > c ? t : t < a ? a : t === c ? c + 1 : Math.min(c, t + f), y6 = (t, a, c) => Math.max(a, Math.min(c, t)), WG = (t, a, c, f, g) => g.fold(() => {
    const x = t - a, w = Math.round(x / f) * f;
    return y6(a + w, a - 1, c + 1);
  }, (x) => {
    const w = (t - x) % f, T = Math.round(w / f), A = Math.floor((t - x) / f), F = Math.floor((c - x) / f), H = Math.min(F, A + T), q = x + H * f;
    return Math.max(x, q);
  }), ZG = (t, a, c) => Math.min(c, Math.max(t, a)) - a, x6 = (t) => {
    const { min: a, max: c, range: f, value: g, step: x, snap: w, snapStart: T, rounded: A, hasMinEdge: F, hasMaxEdge: H, minBound: q, maxBound: ne, screenRange: ie } = t, fe = F ? a - 1 : a, _e = H ? c + 1 : c;
    if (g < q)
      return fe;
    if (g > ne)
      return _e;
    {
      const st = ZG(g, q, ne), De = y6(st / ie * f + a, fe, _e);
      return w && De >= a && De <= c ? WG(De, a, c, x, T) : A ? Math.round(De) : De;
    }
  }, QR = (t) => {
    const { min: a, max: c, range: f, value: g, hasMinEdge: x, hasMaxEdge: w, maxBound: T, maxOffset: A, centerMinEdge: F, centerMaxEdge: H } = t;
    return g < a ? x ? 0 : F : g > c ? w ? T : H : (g - a) / f * A;
  }, JR = "top", w6 = "right", C6 = "bottom", sO = "left", eN = "width", S6 = "height", Km = (t) => t.element.dom.getBoundingClientRect(), vf = (t, a) => t[a], xS = (t) => {
    const a = Km(t);
    return vf(a, sO);
  }, aO = (t) => {
    const a = Km(t);
    return vf(a, w6);
  }, iO = (t) => {
    const a = Km(t);
    return vf(a, JR);
  }, lO = (t) => {
    const a = Km(t);
    return vf(a, C6);
  }, K1 = (t) => {
    const a = Km(t);
    return vf(a, eN);
  }, tN = (t) => {
    const a = Km(t);
    return vf(a, S6);
  }, nN = (t, a, c) => (t + a) / 2 - c, oN = (t, a) => {
    const c = Km(t), f = Km(a), g = vf(c, sO), x = vf(c, w6), w = vf(f, sO);
    return nN(g, x, w);
  }, k6 = (t, a) => {
    const c = Km(t), f = Km(a), g = vf(c, JR), x = vf(c, C6), w = vf(f, JR);
    return nN(g, x, w);
  }, cO = (t, a) => {
    po(t, bS(), { value: a });
  }, Ax = (t, a, c) => {
    const f = {
      min: U1(a),
      max: Z1(a),
      range: yS(a),
      value: c,
      step: Tx(a),
      snap: f6(a),
      snapStart: m6(a),
      rounded: oO(a),
      hasMinEdge: p6(a),
      hasMaxEdge: Ox(a),
      minBound: xS(t),
      maxBound: aO(t),
      screenRange: K1(t)
    };
    return x6(f);
  }, GG = (t, a, c) => {
    const f = Ax(t, a, c);
    return cO(t, f), f;
  }, qG = (t, a) => {
    const c = U1(a);
    cO(t, c);
  }, _6 = (t, a) => {
    const c = Z1(a);
    cO(t, c);
  }, E6 = (t, a, c, f) => {
    const x = (t > 0 ? XR : YR)(Dg(c), U1(c), Z1(c), Tx(c, f));
    return cO(a, x), B.some(x);
  }, uO = (t) => (a, c, f) => E6(t, a, c, f).map(qe), T6 = (t) => jR(t).map((c) => c.left), tu = (t, a, c, f, g) => {
    const w = K1(t), T = f.bind((H) => B.some(oN(H, t))).getOr(0), A = g.bind((H) => B.some(oN(H, t))).getOr(w), F = {
      min: U1(a),
      max: Z1(a),
      range: yS(a),
      value: c,
      hasMinEdge: p6(a),
      hasMaxEdge: Ox(a),
      minBound: xS(t),
      minOffset: 0,
      maxBound: aO(t),
      maxOffset: w,
      centerMinEdge: T,
      centerMaxEdge: A
    };
    return QR(F);
  }, dO = (t, a, c, f, g, x) => {
    const w = tu(a, x, c, f, g);
    return xS(a) - xS(t) + w;
  }, KG = (t, a, c, f) => {
    const g = Dg(c), x = dO(t, f.getSpectrum(t), g, f.getLeftEdge(t), f.getRightEdge(t), c), w = Pi(a.element) / 2;
    Ln(a.element, "left", x - w + "px");
  }, YG = uO(-1), O6 = uO(1), XG = B.none, QG = B.none, JG = {
    "top-left": B.none(),
    top: B.none(),
    "top-right": B.none(),
    right: B.some(KR),
    "bottom-right": B.none(),
    bottom: B.none(),
    "bottom-left": B.none(),
    left: B.some(v6)
  };
  var A6 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setValueFrom: GG,
    setToMin: qG,
    setToMax: _6,
    findValueOfOffset: Ax,
    getValueFromEvent: T6,
    findPositionOfValue: dO,
    setPositionFromValue: KG,
    onLeft: YG,
    onRight: O6,
    onUp: XG,
    onDown: QG,
    edgeActions: JG
  });
  const yf = (t, a) => {
    po(t, bS(), { value: a });
  }, wS = (t, a, c) => {
    const f = {
      min: W1(a),
      max: G1(a),
      range: WR(a),
      value: c,
      step: Tx(a),
      snap: f6(a),
      snapStart: m6(a),
      rounded: oO(a),
      hasMinEdge: h6(a),
      hasMaxEdge: rO(a),
      minBound: iO(t),
      maxBound: lO(t),
      screenRange: tN(t)
    };
    return x6(f);
  }, P6 = (t, a, c) => {
    const f = wS(t, a, c);
    return yf(t, f), f;
  }, fO = (t, a) => {
    const c = W1(a);
    yf(t, c);
  }, rN = (t, a) => {
    const c = G1(a);
    yf(t, c);
  }, eq = (t, a, c, f) => {
    const x = (t > 0 ? XR : YR)(Dg(c), W1(c), G1(c), Tx(c, f));
    return yf(a, x), B.some(x);
  }, D6 = (t) => (a, c, f) => eq(t, a, c, f).map(qe), tq = (t) => jR(t).map((c) => c.top), nq = (t, a, c, f, g) => {
    const w = tN(t), T = f.bind((H) => B.some(k6(H, t))).getOr(0), A = g.bind((H) => B.some(k6(H, t))).getOr(w), F = {
      min: W1(a),
      max: G1(a),
      range: WR(a),
      value: c,
      hasMinEdge: h6(a),
      hasMaxEdge: rO(a),
      minBound: iO(t),
      minOffset: 0,
      maxBound: lO(t),
      maxOffset: w,
      centerMinEdge: T,
      centerMaxEdge: A
    };
    return QR(F);
  }, sN = (t, a, c, f, g, x) => {
    const w = nq(a, x, c, f, g);
    return iO(a) - iO(t) + w;
  }, oq = (t, a, c, f) => {
    const g = Dg(c), x = sN(t, f.getSpectrum(t), g, f.getTopEdge(t), f.getBottomEdge(t), c), w = Bs(a.element) / 2;
    Ln(a.element, "top", x - w + "px");
  }, rq = B.none, R6 = B.none, sq = D6(-1), lh = D6(1), mO = {
    "top-left": B.none(),
    top: B.some(HG),
    "top-right": B.none(),
    right: B.none(),
    "bottom-right": B.none(),
    bottom: B.some(VG),
    "bottom-left": B.none(),
    left: B.none()
  };
  var aq = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setValueFrom: P6,
    setToMin: fO,
    setToMax: rN,
    findValueOfOffset: wS,
    getValueFromEvent: tq,
    findPositionOfValue: sN,
    setPositionFromValue: oq,
    onLeft: rq,
    onRight: R6,
    onUp: sq,
    onDown: lh,
    edgeActions: mO
  });
  const pO = (t, a) => {
    po(t, bS(), { value: a });
  }, CS = (t, a) => ({
    x: t,
    y: a
  }), N6 = (t, a, c) => {
    const f = Ax(t, a, c.left), g = wS(t, a, c.top), x = CS(f, g);
    return pO(t, x), x;
  }, aN = (t, a, c, f, g) => {
    const x = t > 0 ? XR : YR, w = a ? Dg(f).x : x(Dg(f).x, U1(f), Z1(f), Tx(f, g)), T = a ? x(Dg(f).y, W1(f), G1(f), Tx(f, g)) : Dg(f).y;
    return pO(c, CS(w, T)), B.some(w);
  }, Y1 = (t, a) => (c, f, g) => aN(t, a, c, f, g).map(qe), SS = (t, a) => {
    const c = U1(a), f = W1(a);
    pO(t, CS(c, f));
  }, kS = (t, a) => {
    const c = Z1(a), f = G1(a);
    pO(t, CS(c, f));
  }, M6 = (t) => jR(t), I6 = (t, a, c, f) => {
    const g = Dg(c), x = dO(t, f.getSpectrum(t), g.x, f.getLeftEdge(t), f.getRightEdge(t), c), w = sN(t, f.getSpectrum(t), g.y, f.getTopEdge(t), f.getBottomEdge(t), c), T = Pi(a.element) / 2, A = Bs(a.element) / 2;
    Ln(a.element, "left", x - T + "px"), Ln(a.element, "top", w - A + "px");
  }, F6 = Y1(-1, !1), B6 = Y1(1, !1), iq = Y1(-1, !0), lq = Y1(1, !0), cq = {
    "top-left": B.some(g6),
    top: B.some(GR),
    "top-right": B.some(qR),
    right: B.some(zG),
    "bottom-right": B.some(Pd),
    bottom: B.some(jG),
    "bottom-left": B.some(b6),
    left: B.some(UG)
  };
  var uq = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setValueFrom: N6,
    setToMin: SS,
    setToMax: kS,
    getValueFromEvent: M6,
    setPositionFromValue: I6,
    onLeft: F6,
    onRight: B6,
    onUp: iq,
    onDown: lq,
    edgeActions: cq
  });
  const dq = [
    Qe("stepSize", 1),
    Qe("speedMultiplier", 10),
    Qe("onChange", G),
    Qe("onChoose", G),
    Qe("onInit", G),
    Qe("onDragStart", G),
    Qe("onDragEnd", G),
    Qe("snapToGrid", !1),
    Qe("rounded", !0),
    jr("snapStart"),
    Vr("model", ci("mode", {
      x: [
        Qe("minX", 0),
        Qe("maxX", 100),
        Wr("value", (t) => no(t.mode.minX)),
        Rt("getInitialValue"),
        Ws("manager", A6)
      ],
      y: [
        Qe("minY", 0),
        Qe("maxY", 100),
        Wr("value", (t) => no(t.mode.minY)),
        Rt("getInitialValue"),
        Ws("manager", aq)
      ],
      xy: [
        Qe("minX", 0),
        Qe("maxX", 100),
        Qe("minY", 0),
        Qe("maxY", 100),
        Wr("value", (t) => no({
          x: t.mode.minX,
          y: t.mode.minY
        })),
        Rt("getInitialValue"),
        Ws("manager", uq)
      ]
    })),
    $i("sliderBehaviours", [
      oo,
      Mn
    ]),
    Wr("mouseIsDown", () => no(!1))
  ], xf = Vl({
    name: "Slider",
    configFields: dq,
    partFields: BG,
    factory: (t, a, c, f) => {
      const g = (gt) => uc(gt, t, "thumb"), x = (gt) => uc(gt, t, "spectrum"), w = (gt) => Xt(gt, t, "left-edge"), T = (gt) => Xt(gt, t, "right-edge"), A = (gt) => Xt(gt, t, "top-edge"), F = (gt) => Xt(gt, t, "bottom-edge"), H = t.model, q = H.manager, ne = (gt, Jt) => {
        q.setPositionFromValue(gt, Jt, t, {
          getLeftEdge: w,
          getRightEdge: T,
          getTopEdge: A,
          getBottomEdge: F,
          getSpectrum: x
        });
      }, ie = (gt, Jt) => {
        H.value.set(Jt);
        const vn = g(gt);
        ne(gt, vn);
      }, fe = (gt, Jt) => {
        ie(gt, Jt);
        const vn = g(gt);
        return t.onChange(gt, vn, Jt), B.some(!0);
      }, _e = (gt) => {
        q.setToMin(gt, t);
      }, st = (gt) => {
        q.setToMax(gt, t);
      }, De = (gt) => {
        const Jt = () => {
          Xt(gt, t, "thumb").each((Nt) => {
            const Yn = H.value.get();
            t.onChoose(gt, Nt, Yn);
          });
        }, vn = t.mouseIsDown.get();
        t.mouseIsDown.set(!1), vn && Jt();
      }, Je = (gt, Jt) => {
        Jt.stop(), t.mouseIsDown.set(!0), t.onDragStart(gt, g(gt));
      }, Ge = (gt, Jt) => {
        Jt.stop(), t.onDragEnd(gt, g(gt)), De(gt);
      }, Ft = (gt) => {
        Xt(gt, t, "spectrum").map(oo.focusIn);
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: a,
        behaviours: Li(t.sliderBehaviours, [
          oo.config({
            mode: "special",
            focusIn: Ft
          }),
          Mn.config({
            store: {
              mode: "manual",
              getValue: (gt) => H.value.get(),
              setValue: ie
            }
          }),
          Ac.config({ channels: { [l1()]: { onReceive: De } } })
        ]),
        events: js([
          It(bS(), (gt, Jt) => {
            fe(gt, Jt.event.value);
          }),
          Qs((gt, Jt) => {
            const vn = H.getInitialValue();
            H.value.set(vn);
            const Nt = g(gt);
            ne(gt, Nt);
            const Yn = x(gt);
            t.onInit(gt, Nt, Yn, H.value.get());
          }),
          It(wr(), Je),
          It(Ja(), Ge),
          It(nc(), (gt, Jt) => {
            Ft(gt), Je(gt, Jt);
          }),
          It(Tm(), Ge)
        ]),
        apis: {
          resetToMin: _e,
          resetToMax: st,
          setValue: ie,
          refresh: ne
        },
        domModification: { styles: { position: "relative" } }
      };
    },
    apis: {
      setValue: (t, a, c) => {
        t.setValue(a, c);
      },
      resetToMin: (t, a) => {
        t.resetToMin(a);
      },
      resetToMax: (t, a) => {
        t.resetToMax(a);
      },
      refresh: (t, a) => {
        t.refresh(a);
      }
    }
  }), iN = Nn("rgb-hex-update"), lN = Nn("slider-update"), $6 = Nn("palette-update"), L6 = (t, a) => {
    const c = xf.parts.spectrum({
      dom: {
        tag: "div",
        classes: [a("hue-slider-spectrum")],
        attributes: { role: "presentation" }
      }
    }), f = xf.parts.thumb({
      dom: {
        tag: "div",
        classes: [a("hue-slider-thumb")],
        attributes: { role: "presentation" }
      }
    });
    return xf.sketch({
      dom: {
        tag: "div",
        classes: [a("hue-slider")],
        attributes: {
          role: "slider",
          "aria-valuemin": 0,
          "aria-valuemax": 360,
          "aria-valuenow": 120
        }
      },
      rounded: !1,
      model: {
        mode: "y",
        getInitialValue: te(0)
      },
      components: [
        c,
        f
      ],
      sliderBehaviours: Qt([Ao.config({})]),
      onChange: (g, x, w) => {
        rn(g.element, "aria-valuenow", Math.floor(360 - w * 3.6)), po(g, lN, { value: w });
      }
    });
  }, Px = "form", mq = [$i("formBehaviours", [Mn])], cN = (t) => "<alloy.field." + t + ">", pq = (t) => {
    const a = (() => {
      const x = [];
      return {
        field: (T, A) => (x.push(T), EE(Px, cN(T), A)),
        record: te(x)
      };
    })(), c = t(a), f = a.record(), g = tt(f, (x) => hl({
      name: x,
      pname: cN(x)
    }));
    return zm(Px, mq, g, gq, c);
  }, hq = (t, a) => t.fold(() => zo.error(a), zo.value), gq = (t, a) => ({
    uid: t.uid,
    dom: t.dom,
    components: a,
    behaviours: Li(t.formBehaviours, [Mn.config({
      store: {
        mode: "manual",
        getValue: (c) => {
          const f = xC(c, t);
          return kt(f, (g, x) => g().bind((w) => {
            const T = Nr.getCurrent(w);
            return hq(T, new Error(`Cannot find a current component to extract the value from for form part '${x}': ` + qc(w.element)));
          }).map(Mn.getValue));
        },
        setValue: (c, f) => {
          at(f, (g, x) => {
            Xt(c, t, x).each((w) => {
              Nr.getCurrent(w).each((T) => {
                Mn.setValue(T, g);
              });
            });
          });
        }
      }
    })]),
    apis: {
      getField: (c, f) => Xt(c, t, f).bind(Nr.getCurrent)
    }
  }), Dx = {
    getField: wb((t, a, c) => t.getField(a, c)),
    sketch: pq
  }, uN = Nn("valid-input"), H6 = Nn("invalid-input"), dN = Nn("validating-input"), _S = "colorcustom.rgb.", Rg = (t, a, c, f) => {
    const g = (ne, ie) => ih.config({
      invalidClass: a("invalid"),
      notify: {
        onValidate: (fe) => {
          po(fe, dN, { type: ne });
        },
        onValid: (fe) => {
          po(fe, uN, {
            type: ne,
            value: Mn.getValue(fe)
          });
        },
        onInvalid: (fe) => {
          po(fe, H6, {
            type: ne,
            value: Mn.getValue(fe)
          });
        }
      },
      validator: {
        validate: (fe) => {
          const _e = Mn.getValue(fe), st = ie(_e) ? zo.value(!0) : zo.error(t("aria.input.invalid"));
          return jl.pure(st);
        },
        validateOnLoad: !1
      }
    }), x = (ne, ie, fe, _e, st) => {
      const De = t(_S + "range"), Je = gs.parts.label({
        dom: {
          tag: "label",
          attributes: { "aria-label": _e }
        },
        components: [Oa(fe)]
      }), Ge = gs.parts.field({
        data: st,
        factory: N1,
        inputAttributes: {
          type: "text",
          ...ie === "hex" ? { "aria-live": "polite" } : {}
        },
        inputClasses: [a("textfield")],
        inputBehaviours: Qt([
          g(ie, ne),
          Zs.config({})
        ]),
        onSetValue: (vn) => {
          ih.isInvalid(vn) && ih.run(vn).get(G);
        }
      }), Ft = [
        Je,
        Ge
      ], gt = ie !== "hex" ? [gs.parts["aria-descriptor"]({ text: De })] : [], Jt = Ft.concat(gt);
      return {
        dom: {
          tag: "div",
          attributes: { role: "presentation" }
        },
        components: Jt
      };
    }, w = (ne, ie) => {
      const fe = iS(ie);
      return Dx.getField(ne, "hex").each((_e) => {
        Ao.isFocused(_e) || Mn.setValue(ne, { hex: fe.value });
      }), fe;
    }, T = (ne, ie) => {
      const fe = ie.red, _e = ie.green, st = ie.blue;
      Mn.setValue(ne, {
        red: fe,
        green: _e,
        blue: st
      });
    }, A = is({
      dom: {
        tag: "div",
        classes: [a("rgba-preview")],
        styles: { "background-color": "white" },
        attributes: { role: "presentation" }
      }
    }), F = (ne, ie) => {
      A.getOpt(ne).each((fe) => {
        Ln(fe.element, "background-color", "#" + ie.value);
      });
    };
    return Pc({
      factory: () => {
        const ne = {
          red: no(B.some(255)),
          green: no(B.some(255)),
          blue: no(B.some(255)),
          hex: no(B.some("ffffff"))
        }, ie = (fo, Gr) => {
          const Hr = lS(Gr);
          T(fo, Hr), De(Hr);
        }, fe = (fo) => ne[fo].get(), _e = (fo, Gr) => {
          ne[fo].set(Gr);
        }, st = () => fe("red").bind((fo) => fe("green").bind((Gr) => fe("blue").map((Hr) => L1(fo, Gr, Hr, 1)))), De = (fo) => {
          const Gr = fo.red, Hr = fo.green, br = fo.blue;
          _e("red", B.some(Gr)), _e("green", B.some(Hr)), _e("blue", B.some(br));
        }, Je = (fo, Gr) => {
          const Hr = Gr.event;
          Hr.type !== "hex" ? _e(Hr.type, B.none()) : f(fo);
        }, Ge = (fo, Gr) => {
          c(fo);
          const Hr = gR(Gr);
          _e("hex", B.some(Hr.value));
          const br = lS(Hr);
          T(fo, br), De(br), po(fo, iN, { hex: Hr }), F(fo, Hr);
        }, Ft = (fo, Gr, Hr) => {
          const br = parseInt(Hr, 10);
          _e(Gr, B.some(br)), st().each((cn) => {
            const Un = w(fo, cn);
            po(fo, iN, { hex: Un }), F(fo, Un);
          });
        }, gt = (fo) => fo.type === "hex", Jt = (fo, Gr) => {
          const Hr = Gr.event;
          gt(Hr) ? Ge(fo, Hr.value) : Ft(fo, Hr.type, Hr.value);
        }, vn = (fo) => ({
          label: t(_S + fo + ".label"),
          description: t(_S + fo + ".description")
        }), Nt = vn("red"), Yn = vn("green"), In = vn("blue"), xo = vn("hex");
        return Fs(Dx.sketch((fo) => ({
          dom: {
            tag: "form",
            classes: [a("rgb-form")],
            attributes: { "aria-label": t("aria.color.picker") }
          },
          components: [
            fo.field("red", gs.sketch(x(vR, "red", Nt.label, Nt.description, 255))),
            fo.field("green", gs.sketch(x(vR, "green", Yn.label, Yn.description, 255))),
            fo.field("blue", gs.sketch(x(vR, "blue", In.label, In.description, 255))),
            fo.field("hex", gs.sketch(x(eL, "hex", xo.label, xo.description, "ffffff"))),
            A.asSpec()
          ],
          formBehaviours: Qt([
            ih.config({ invalidClass: a("form-invalid") }),
            Go("rgb-form-events", [
              It(uN, Jt),
              It(H6, Je),
              It(dN, Je)
            ])
          ])
        })), {
          apis: {
            updateHex: (fo, Gr) => {
              Mn.setValue(fo, { hex: Gr.value }), ie(fo, Gr), F(fo, Gr);
            }
          }
        });
      },
      name: "RgbForm",
      configFields: [],
      apis: {
        updateHex: (ne, ie, fe) => {
          ne.updateHex(ie, fe);
        }
      },
      extraApis: {}
    });
  }, fN = (t, a) => {
    const c = xf.parts.spectrum({
      dom: {
        tag: "canvas",
        attributes: { role: "presentation" },
        classes: [a("sv-palette-spectrum")]
      }
    }), f = xf.parts.thumb({
      dom: {
        tag: "div",
        attributes: { role: "presentation" },
        classes: [a("sv-palette-thumb")],
        innerHtml: `<div class=${a("sv-palette-inner-thumb")} role="presentation"></div>`
      }
    }), g = (F, H) => {
      const { width: q, height: ne } = F, ie = F.getContext("2d");
      if (ie === null)
        return;
      ie.fillStyle = H, ie.fillRect(0, 0, q, ne);
      const fe = ie.createLinearGradient(0, 0, q, 0);
      fe.addColorStop(0, "rgba(255,255,255,1)"), fe.addColorStop(1, "rgba(255,255,255,0)"), ie.fillStyle = fe, ie.fillRect(0, 0, q, ne);
      const _e = ie.createLinearGradient(0, 0, 0, ne);
      _e.addColorStop(0, "rgba(0,0,0,0)"), _e.addColorStop(1, "rgba(0,0,0,1)"), ie.fillStyle = _e, ie.fillRect(0, 0, q, ne);
    }, x = (F, H) => {
      const q = F.components()[0].element.dom, ne = V1(H, 100, 100), ie = aL(ne);
      g(q, lL(ie));
    }, w = (F, H) => {
      const q = WT(lS(H));
      xf.setValue(F, {
        x: q.saturation,
        y: 100 - q.value
      }), rn(F.element, "aria-valuetext", t([
        "Saturation {0}%, Brightness {1}%",
        q.saturation,
        q.value
      ]));
    };
    return Pc({
      factory: (F) => {
        const H = te({
          x: 0,
          y: 0
        }), q = (fe, _e, st) => {
          oe(st) || rn(fe.element, "aria-valuetext", t([
            "Saturation {0}%, Brightness {1}%",
            Math.floor(st.x),
            Math.floor(100 - st.y)
          ])), po(fe, $6, { value: st });
        }, ne = (fe, _e, st, De) => {
          g(st.element.dom, lL(cL));
        }, ie = Qt([
          Nr.config({ find: B.some }),
          Ao.config({})
        ]);
        return xf.sketch({
          dom: {
            tag: "div",
            attributes: {
              role: "slider",
              "aria-valuetext": t([
                "Saturation {0}%, Brightness {1}%",
                0,
                0
              ])
            },
            classes: [a("sv-palette")]
          },
          model: {
            mode: "xy",
            getInitialValue: H
          },
          rounded: !1,
          components: [
            c,
            f
          ],
          onChange: q,
          onInit: ne,
          sliderBehaviours: ie
        });
      },
      name: "SaturationBrightnessPalette",
      configFields: [],
      apis: {
        setHue: (F, H, q) => {
          x(H, q);
        },
        setThumb: (F, H, q) => {
          w(H, q);
        }
      },
      extraApis: {}
    });
  }, z6 = (t, a) => {
    const c = (g) => {
      const x = Rg(t, a, g.onValidHex, g.onInvalidHex), w = fN(t, a), T = (Jt) => (100 - Jt) / 100 * 360, A = (Jt) => 100 - Jt / 360 * 100, F = {
        paletteRgba: no(cL),
        paletteHue: no(0)
      }, H = is(L6(t, a)), q = is(w.sketch({})), ne = is(x.sketch({})), ie = (Jt, vn, Nt) => {
        q.getOpt(Jt).each((Yn) => {
          w.setHue(Yn, Nt);
        });
      }, fe = (Jt, vn) => {
        ne.getOpt(Jt).each((Nt) => {
          x.updateHex(Nt, vn);
        });
      }, _e = (Jt, vn, Nt) => {
        H.getOpt(Jt).each((Yn) => {
          xf.setValue(Yn, A(Nt));
        });
      }, st = (Jt, vn) => {
        q.getOpt(Jt).each((Nt) => {
          w.setThumb(Nt, vn);
        });
      }, De = (Jt, vn) => {
        const Nt = lS(Jt);
        F.paletteRgba.set(Nt), F.paletteHue.set(vn);
      }, Je = (Jt, vn, Nt, Yn) => {
        De(vn, Nt), mt(Yn, (In) => {
          In(Jt, vn, Nt);
        });
      }, Ge = () => {
        const Jt = [fe];
        return (vn, Nt) => {
          const Yn = Nt.event.value, In = F.paletteHue.get(), xo = V1(In, Yn.x, 100 - Yn.y), fo = bL(xo);
          Je(vn, fo, In, Jt);
        };
      }, Ft = () => {
        const Jt = [
          ie,
          fe
        ];
        return (vn, Nt) => {
          const Yn = T(Nt.event.value), In = F.paletteRgba.get(), xo = WT(In), fo = V1(Yn, xo.saturation, xo.value), Gr = bL(fo);
          Je(vn, Gr, Yn, Jt);
        };
      }, gt = () => {
        const Jt = [
          ie,
          _e,
          st
        ];
        return (vn, Nt) => {
          const Yn = Nt.event.hex, In = mZ(Yn);
          Je(vn, Yn, In.hue, Jt);
        };
      };
      return {
        uid: g.uid,
        dom: g.dom,
        components: [
          q.asSpec(),
          H.asSpec(),
          ne.asSpec()
        ],
        behaviours: Qt([
          Go("colour-picker-events", [
            It(iN, gt()),
            It($6, Ge()),
            It(lN, Ft())
          ]),
          Nr.config({ find: (Jt) => ne.getOpt(Jt) }),
          oo.config({ mode: "acyclic" })
        ])
      };
    };
    return Pc({
      name: "ColourPicker",
      configFields: [
        Rt("dom"),
        Qe("onValidHex", G),
        Qe("onInvalidHex", G)
      ],
      factory: c
    });
  }, ed = {
    self: () => Nr.config({ find: B.some }),
    memento: (t) => Nr.config({ find: t.getOpt }),
    childAt: (t) => Nr.config({ find: (a) => Wi(a.element, t).bind((c) => a.getSystem().getByDom(c).toOptional()) })
  }, j6 = wo([
    Qe("preprocess", lt),
    Qe("postprocess", lt)
  ]), U6 = (t, a) => {
    const c = El("RepresentingConfigs.memento processors", j6, a);
    return Mn.config({
      store: {
        mode: "manual",
        getValue: (f) => {
          const g = t.get(f), x = Mn.getValue(g);
          return c.postprocess(x);
        },
        setValue: (f, g) => {
          const x = c.preprocess(g), w = t.get(f);
          Mn.setValue(w, x);
        }
      }
    });
  }, X1 = (t, a, c) => Mn.config({
    store: {
      mode: "manual",
      ...t.map((f) => ({ initialValue: f })).getOr({}),
      getValue: a,
      setValue: c
    }
  }), W6 = (t, a, c) => X1(t, (f) => a(f.element), (f, g) => c(f.element, g)), yq = (t) => W6(t, Oc, bb), hO = (t) => Mn.config({
    store: {
      mode: "memory",
      initialValue: t
    }
  }), xq = {
    "colorcustom.rgb.red.label": "R",
    "colorcustom.rgb.red.description": "Red component",
    "colorcustom.rgb.green.label": "G",
    "colorcustom.rgb.green.description": "Green component",
    "colorcustom.rgb.blue.label": "B",
    "colorcustom.rgb.blue.description": "Blue component",
    "colorcustom.rgb.hex.label": "#",
    "colorcustom.rgb.hex.description": "Hex color code",
    "colorcustom.rgb.range": "Range 0 to 255",
    "aria.color.picker": "Color Picker",
    "aria.input.invalid": "Invalid input"
  }, Z6 = (t) => (a) => _(a) ? t.translate(xq[a]) : t.translate(a), G6 = (t, a, c) => {
    const f = (A) => "tox-" + A, g = z6(Z6(a), f), x = (A) => {
      po(A, ah, {
        name: "hex-valid",
        value: !0
      });
    }, w = (A) => {
      po(A, ah, {
        name: "hex-valid",
        value: !1
      });
    }, T = is(g.sketch({
      dom: {
        tag: "div",
        classes: [f("color-picker-container")],
        attributes: { role: "presentation" }
      },
      onValidHex: x,
      onInvalidHex: w
    }));
    return {
      dom: { tag: "div" },
      components: [T.asSpec()],
      behaviours: Qt([
        X1(c, (A) => {
          const F = T.get(A);
          return Nr.getCurrent(F).bind((ne) => Mn.getValue(ne).hex).map((ne) => "#" + gn(ne, "#")).getOr("");
        }, (A, F) => {
          const H = /^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/, q = B.from(H.exec(F)).bind((fe) => Pn(fe, 1)), ne = T.get(A);
          Nr.getCurrent(ne).fold(() => {
            console.log("Can not find form");
          }, (fe) => {
            Mn.setValue(fe, { hex: q.getOr("") }), Dx.getField(fe, "hex").each((_e) => {
              tr(_e, Lf());
            });
          });
        }),
        ed.self()
      ])
    };
  };
  var wq = tinymce.util.Tools.resolve("tinymce.Resource");
  const q6 = (t) => Ho(t, "init"), Cq = (t) => {
    const a = ms(), c = is({ dom: { tag: t.tag } }), f = ms(), g = !q6(t) && t.onFocus.isSome() ? [
      Ao.config({
        onFocus: (x) => {
          t.onFocus.each((w) => {
            w(x.element.dom);
          });
        }
      }),
      Zs.config({})
    ] : [];
    return {
      dom: {
        tag: "div",
        classes: ["tox-custom-editor"]
      },
      behaviours: Qt([
        Go("custom-editor-events", [Qs((x) => {
          c.getOpt(x).each((w) => {
            (q6(t) ? t.init(w.element.dom) : wq.load(t.scriptId, t.scriptUrl).then((T) => T(w.element.dom, t.settings))).then((T) => {
              f.on((A) => {
                T.setValue(A);
              }), f.clear(), a.set(T);
            });
          });
        })]),
        X1(B.none(), () => a.get().fold(() => f.get().getOr(""), (x) => x.getValue()), (x, w) => {
          a.get().fold(() => f.set(w), (T) => T.setValue(w));
        }),
        ed.self()
      ].concat(g)),
      components: [c.asSpec()]
    };
  };
  var im = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const Sq = (t, a) => {
    const c = im.explode(a.getOption("images_file_types")), f = (g) => Fn(c, (x) => ea(g.name.toLowerCase(), `.${x.toLowerCase()}`));
    return To(nr(t), f);
  }, kq = (t, a, c) => {
    const f = (ne, ie) => {
      ie.stop();
    }, g = (ne) => (ie, fe) => {
      mt(ne, (_e) => {
        _e(ie, fe);
      });
    }, x = (ne, ie) => {
      var fe;
      if (!_o.isDisabled(ne)) {
        const _e = ie.event.raw;
        T(ne, (fe = _e.dataTransfer) === null || fe === void 0 ? void 0 : fe.files);
      }
    }, w = (ne, ie) => {
      const fe = ie.event.raw.target;
      T(ne, fe.files);
    }, T = (ne, ie) => {
      ie && (Mn.setValue(ne, Sq(ie, a)), po(ne, wu, { name: t.name }));
    }, A = is({
      dom: {
        tag: "input",
        attributes: {
          type: "file",
          accept: "image/*"
        },
        styles: { display: "none" }
      },
      behaviours: Qt([Go("input-file-events", [
        nf(Vh()),
        nf(ef())
      ])])
    }), F = (ne) => ({
      uid: ne.uid,
      dom: {
        tag: "div",
        classes: ["tox-dropzone-container"]
      },
      behaviours: Qt([
        hO(c.getOr([])),
        ed.self(),
        _o.config({}),
        ir.config({
          toggleClass: "dragenter",
          toggleOnExecute: !1
        }),
        Go("dropzone-events", [
          It("dragenter", g([
            f,
            ir.toggle
          ])),
          It("dragleave", g([
            f,
            ir.toggle
          ])),
          It("dragover", f),
          It("drop", g([
            f,
            x
          ])),
          It(ab(), w)
        ])
      ]),
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-dropzone"],
          styles: {}
        },
        components: [
          {
            dom: { tag: "p" },
            components: [Oa(a.translate("Drop an image here"))]
          },
          Rl.sketch({
            dom: {
              tag: "button",
              styles: { position: "relative" },
              classes: [
                "tox-button",
                "tox-button--secondary"
              ]
            },
            components: [
              Oa(a.translate("Browse for an image")),
              A.asSpec()
            ],
            action: (ie) => {
              A.get(ie).element.dom.click();
            },
            buttonBehaviours: Qt([
              Zs.config({}),
              rm.button(a.isDisabled),
              Si()
            ])
          })
        ]
      }]
    }), H = t.label.map((ne) => ev(ne, a)), q = gs.parts.field({ factory: { sketch: F } });
    return kx(H, q, ["tox-form__group--stretched"], []);
  }, K6 = (t, a) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-form__grid",
        `tox-form__grid--${t.columns}col`
      ]
    },
    components: tt(t.items, a.interpreter)
  }), Y6 = (t, a) => {
    let c = null, f = null;
    return {
      cancel: () => {
        se(c) || (clearTimeout(c), c = null, f = null);
      },
      throttle: (...w) => {
        f = w, se(c) && (c = setTimeout(() => {
          const T = f;
          c = null, f = null, t.apply(null, T);
        }, a));
      }
    };
  }, _q = (t, a) => {
    let c = null;
    return {
      cancel: () => {
        se(c) || (clearTimeout(c), c = null);
      },
      throttle: (...x) => {
        se(c) && (c = setTimeout(() => {
          c = null, t.apply(null, x);
        }, a));
      }
    };
  }, mN = (t, a) => {
    let c = null;
    const f = () => {
      se(c) || (clearTimeout(c), c = null);
    };
    return {
      cancel: f,
      throttle: (...x) => {
        f(), c = setTimeout(() => {
          c = null, t.apply(null, x);
        }, a);
      }
    };
  }, ES = Nn("alloy-fake-before-tabstop"), pN = Nn("alloy-fake-after-tabstop"), hN = (t) => ({
    dom: {
      tag: "div",
      styles: {
        width: "1px",
        height: "1px",
        outline: "none"
      },
      attributes: { tabindex: "0" },
      classes: t
    },
    behaviours: Qt([
      Ao.config({ ignore: !0 }),
      Zs.config({})
    ])
  }), X6 = (t, a) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-navobj",
        ...t.getOr([])
      ]
    },
    components: [
      hN([ES]),
      a,
      hN([pN])
    ],
    behaviours: Qt([ed.childAt(1)])
  }), Q6 = (t, a) => {
    po(t, Cd(), {
      raw: {
        which: 9,
        shiftKey: a
      }
    });
  }, Eq = (t, a) => {
    const c = a.element;
    Zc(c, ES) ? Q6(t, !0) : Zc(c, pN) && Q6(t, !1);
  }, Rx = (t) => mS(t, [
    "." + ES,
    "." + pN
  ].join(","), wt), TS = Nn("update-dialog"), J6 = Nn("update-title"), e8 = Nn("update-body"), t8 = Nn("update-footer"), n8 = Nn("body-send-message"), OS = Nn("dialog-focus-shifted"), gN = Fl().browser, Nx = gN.isSafari(), Tq = gN.isFirefox(), o8 = Nx || Tq, Oq = gN.isChromium(), Aq = ({ scrollTop: t, scrollHeight: a, clientHeight: c }) => Math.ceil(t) + c >= a, r8 = (t, a) => t.scrollTo(0, a === "bottom" ? 99999999 : a), Pq = (t, a) => {
    const c = t.body;
    return B.from(!/^<!DOCTYPE (html|HTML)/.test(a) && (!Oq && !Nx || Ce(c) && (c.scrollTop !== 0 || Math.abs(c.scrollHeight - c.clientHeight) > 1)) ? c : t.documentElement);
  }, s8 = (t, a, c) => {
    const f = t.dom;
    B.from(f.contentDocument).fold(c, (g) => {
      let x = 0;
      const w = Pq(g, a).map((A) => (x = A.scrollTop, A)).forall(Aq), T = () => {
        const A = f.contentWindow;
        Ce(A) && (w ? r8(A, "bottom") : !w && o8 && x !== 0 && r8(A, x));
      };
      Nx && f.addEventListener("load", T, { once: !0 }), g.open(), g.write(a), g.close(), Nx || T();
    });
  }, Dq = Xn(o8, Nx ? 500 : 200).map((t) => Y6(s8, t)), bN = (t, a) => {
    const c = no(t.getOr(""));
    return {
      getValue: (f) => c.get(),
      setValue: (f, g) => {
        if (c.get() !== g) {
          const x = f.element, w = () => rn(x, "srcdoc", g);
          a ? Dq.fold(te(s8), (T) => T.throttle)(x, g, w) : w();
        }
        c.set(g);
      }
    };
  }, Rq = (t, a, c) => {
    const f = "tox-dialog__iframe", g = t.transparent ? [] : [`${f}--opaque`], x = t.border ? ["tox-navobj-bordered"] : [], w = {
      ...t.label.map((q) => ({ title: q })).getOr({}),
      ...c.map((q) => ({ srcdoc: q })).getOr({}),
      ...t.sandboxed ? { sandbox: "allow-scripts allow-same-origin" } : {}
    }, T = bN(c, t.streamContent), A = t.label.map((q) => ev(q, a)), F = (q) => X6(B.from(x), {
      uid: q.uid,
      dom: {
        tag: "iframe",
        attributes: w,
        classes: [
          f,
          ...g
        ]
      },
      behaviours: Qt([
        Zs.config({}),
        Ao.config({}),
        X1(c, T.getValue, T.setValue),
        Ac.config({
          channels: {
            [OS]: {
              onReceive: (ne, ie) => {
                ie.newFocus.each((fe) => {
                  Ui(ne.element).each((_e) => {
                    (Lr(ne.element, fe) ? Us : va)(_e, "tox-navobj-bordered-focus");
                  });
                });
              }
            }
          }
        })
      ])
    }), H = gs.parts.field({ factory: { sketch: F } });
    return kx(A, H, ["tox-form__group--stretched"], []);
  }, Nq = (t) => new Promise((a, c) => {
    const f = () => {
      x(), a(t);
    }, g = [
      lc(t, "load", f),
      lc(t, "error", () => {
        x(), c("Unable to load data from image: " + t.dom.src);
      })
    ], x = () => mt(g, (w) => w.unbind());
    t.dom.complete && f();
  }), Mq = (t, a, c, f, g) => {
    const x = c * g, w = f * g, T = Math.max(0, t / 2 - x / 2), A = Math.max(0, a / 2 - w / 2);
    return {
      left: T.toString() + "px",
      top: A.toString() + "px",
      width: x.toString() + "px",
      height: w.toString() + "px"
    };
  }, AS = (t, a, c) => {
    const f = Pi(t), g = Bs(t);
    return Math.min(f / a, g / c, 1);
  }, vN = (t, a) => {
    const c = no(a.getOr({ url: "" })), f = is({
      dom: {
        tag: "img",
        classes: ["tox-imagepreview__image"],
        attributes: a.map((A) => ({ src: A.url })).getOr({})
      }
    }), g = is({
      dom: {
        tag: "div",
        classes: ["tox-imagepreview__container"],
        attributes: { role: "presentation" }
      },
      components: [f.asSpec()]
    }), x = (A, F) => {
      const H = { url: F.url };
      F.zoom.each((ne) => H.zoom = ne), F.cachedWidth.each((ne) => H.cachedWidth = ne), F.cachedHeight.each((ne) => H.cachedHeight = ne), c.set(H);
      const q = () => {
        const { cachedWidth: ne, cachedHeight: ie, zoom: fe } = H;
        if (!be(ne) && !be(ie)) {
          if (be(fe)) {
            const st = AS(A.element, ne, ie);
            H.zoom = st;
          }
          const _e = Mq(Pi(A.element), Bs(A.element), ne, ie, H.zoom);
          g.getOpt(A).each((st) => {
            Rs(st.element, _e);
          });
        }
      };
      f.getOpt(A).each((ne) => {
        const ie = ne.element;
        F.url !== os(ie, "src") && (rn(ie, "src", F.url), va(A.element, "tox-imagepreview__loaded")), q(), Nq(ie).then((fe) => {
          A.getSystem().isConnected() && (Us(A.element, "tox-imagepreview__loaded"), H.cachedWidth = fe.dom.naturalWidth, H.cachedHeight = fe.dom.naturalHeight, q());
        });
      });
    }, w = {};
    t.height.each((A) => w.height = A);
    const T = a.map((A) => ({
      url: A.url,
      zoom: B.from(A.zoom),
      cachedWidth: B.from(A.cachedWidth),
      cachedHeight: B.from(A.cachedHeight)
    }));
    return {
      dom: {
        tag: "div",
        classes: ["tox-imagepreview"],
        styles: w,
        attributes: { role: "presentation" }
      },
      components: [g.asSpec()],
      behaviours: Qt([
        ed.self(),
        X1(T, () => c.get(), x)
      ])
    };
  }, Iq = (t, a, c) => {
    const f = "tox-label", g = t.align === "center" ? [`${f}--center`] : [], x = t.align === "end" ? [`${f}--end`] : [], w = is({
      dom: {
        tag: "label",
        classes: [
          f,
          ...g,
          ...x
        ]
      },
      components: [Oa(a.providers.translate(t.label))]
    }), T = tt(t.items, a.interpreter);
    return {
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: [
        w.asSpec(),
        ...T
      ],
      behaviours: Qt([
        ed.self(),
        No.config({}),
        yq(B.none()),
        oo.config({ mode: "acyclic" }),
        Go("label", [Qs((A) => {
          t.for.each((F) => {
            c(F).each((H) => {
              w.getOpt(A).each((q) => {
                var ne;
                const ie = (ne = os(H.element, "id")) !== null && ne !== void 0 ? ne : Nn("form-field");
                rn(H.element, "id", ie), rn(q.element, "for", ie);
              });
            });
          });
        })])
      ])
    };
  }, a8 = Nn("toolbar.button.execute"), yN = (t) => Sd((a, c) => {
    IT(t, a)((f) => {
      po(a, a8, { buttonApi: f }), t.onAction(f);
    });
  }), Q1 = Nn("common-button-display-events"), gO = {
    [zu()]: [
      "disabling",
      "alloy.base.behaviour",
      "toggling",
      "toolbar-button-events",
      "tooltipping"
    ],
    [oc()]: [
      "toolbar-button-events",
      Q1
    ],
    [Vu()]: [
      "toolbar-button-events",
      "dropdown-events",
      "tooltipping"
    ],
    [nc()]: [
      "focusing",
      "alloy.base.behaviour",
      Q1
    ]
  }, bO = (t) => Ln(t.element, "width", fs(t.element, "width")), i8 = (t, a, c) => xu(t, {
    tag: "span",
    classes: [
      "tox-icon",
      "tox-tbtn__icon-wrap"
    ],
    behaviours: c
  }, a), xN = (t, a) => i8(t, a, []), Ng = (t, a) => i8(t, a, [No.config({})]), wN = (t, a, c) => ({
    dom: {
      tag: "span",
      classes: [`${a}__select-label`]
    },
    components: [Oa(c.translate(t))],
    behaviours: Qt([No.config({})])
  }), wf = Nn("update-menu-text"), ov = Nn("update-menu-icon"), vO = (t, a, c, f) => {
    const g = no(G), x = t.text.map((_e) => is(wN(_e, a, c.providers))), w = t.icon.map((_e) => is(Ng(_e, c.providers.icons))), T = (_e, st) => {
      const De = Mn.getValue(_e);
      return Ao.focus(De), po(De, "keydown", { raw: st.event.raw }), gf.close(De), B.some(!0);
    }, A = t.role.fold(() => ({}), (_e) => ({ role: _e })), F = B.from(t.listRole).map((_e) => ({ listRole: _e })).getOr({}), H = t.ariaLabel.fold(() => ({}), (_e) => ({ "aria-label": c.providers.translate(_e) })), q = xu("chevron-down", {
      tag: "div",
      classes: [`${a}__select-chevron`]
    }, c.providers.icons), ne = Nn("common-button-display-events"), ie = "dropdown-events";
    return is(gf.sketch({
      ...t.uid ? { uid: t.uid } : {},
      ...A,
      ...F,
      dom: {
        tag: "button",
        classes: [
          a,
          `${a}--select`
        ].concat(tt(t.classes, (_e) => `${a}--${_e}`)),
        attributes: {
          ...H,
          ...Ce(f) ? { "data-mce-name": f } : {}
        }
      },
      components: B1([
        w.map((_e) => _e.asSpec()),
        x.map((_e) => _e.asSpec()),
        B.some(q)
      ]),
      matchWidth: !0,
      useMinWidth: !0,
      onOpen: (_e, st, De) => {
        t.searchable && YT(De);
      },
      dropdownBehaviours: Qt([
        ...t.dropdownBehaviours,
        rm.button(() => t.disabled || c.providers.isDisabled()),
        Si(),
        Ex.config({}),
        No.config({}),
        ...t.tooltip.map((_e) => gl.config(c.providers.tooltips.getConfig({ tooltipText: c.providers.translate(_e) }))).toArray(),
        Go(ie, [
          Ag(t, g),
          mc(t, g)
        ]),
        Go(ne, [Qs((_e, st) => bO(_e))]),
        Go("menubutton-update-display-text", [
          It(wf, (_e, st) => {
            x.bind((De) => De.getOpt(_e)).each((De) => {
              No.set(De, [Oa(c.providers.translate(st.event.text))]);
            });
          }),
          It(ov, (_e, st) => {
            w.bind((De) => De.getOpt(_e)).each((De) => {
              No.set(De, [Ng(st.event.icon, c.providers.icons)]);
            });
          })
        ])
      ]),
      eventOrder: Fs(gO, {
        [nc()]: [
          "focusing",
          "alloy.base.behaviour",
          "item-type-events",
          "normal-dropdown-events"
        ],
        [oc()]: [
          "toolbar-button-events",
          gl.name(),
          ie,
          ne
        ]
      }),
      sandboxBehaviours: Qt([
        oo.config({
          mode: "special",
          onLeft: T,
          onRight: T
        }),
        Go("dropdown-sandbox-events", [
          It(w$, (_e, st) => {
            QZ(_e), st.stop();
          }),
          It(C$, (_e, st) => {
            JZ(_e, st), st.stop();
          })
        ])
      ]),
      lazySink: c.getSink,
      toggleClass: `${a}--active`,
      parts: {
        menu: {
          ...XC(!1, t.columns, t.presets),
          fakeFocus: t.searchable,
          ...t.listRole === "listbox" ? {} : {
            onHighlightItem: fS,
            onCollapseMenu: (_e, st, De) => {
              wn.getHighlighted(De).each((Je) => {
                fS(_e, De, Je);
              });
            },
            onDehighlightItem: nG
          }
        }
      },
      getAnchorOverrides: () => ({
        maxHeightFunction: (_e, st) => {
          hy()(_e, st - 10);
        }
      }),
      fetch: (_e) => jl.nu(Kt(t.fetch, _e))
    })).asSpec();
  }, Fq = (t) => _(t), CN = (t) => t.type === "separator", l8 = (t) => Ho(t, "getSubmenuItems"), c8 = { type: "separator" }, Bq = (t, a) => {
    const c = Mt(t, (f, g) => Fq(g) ? g === "" ? f : g === "|" ? f.length > 0 && !CN(f[f.length - 1]) ? f.concat([c8]) : f : Ho(a, g.toLowerCase()) ? f.concat([a[g.toLowerCase()]]) : f : f.concat([g]), []);
    return c.length > 0 && CN(c[c.length - 1]) && c.pop(), c;
  }, $q = (t, a) => {
    const c = t.getSubmenuItems(), f = SN(c, a), g = Fs(f.menus, { [t.value]: f.items }), x = Fs(f.expansions, { [t.value]: t.value });
    return {
      item: t,
      menus: g,
      expansions: x
    };
  }, Lq = (t) => {
    const a = Ht(t, "value").getOrThunk(() => Nn("generated-menu-item"));
    return Fs({ value: a }, t);
  }, SN = (t, a) => {
    const c = Bq(_(t) ? t.split(" ") : t, a);
    return Ot(c, (f, g) => {
      if (l8(g)) {
        const x = Lq(g), w = $q(x, a);
        return {
          menus: Fs(f.menus, w.menus),
          items: [
            w.item,
            ...f.items
          ],
          expansions: Fs(f.expansions, w.expansions)
        };
      } else
        return {
          ...f,
          items: [
            g,
            ...f.items
          ]
        };
    }, {
      menus: {},
      expansions: {},
      items: []
    });
  }, Hq = (t) => t.search.fold(() => ({ searchMode: "no-search" }), (a) => ({
    searchMode: "search-with-field",
    placeholder: a.placeholder
  })), u8 = (t) => t.search.fold(() => ({ searchMode: "no-search" }), (a) => ({ searchMode: "search-with-results" })), Mx = (t, a, c, f) => {
    const g = Nn("primary-menu"), x = SN(t, c.shared.providers.menuItems());
    if (x.items.length === 0)
      return B.none();
    const w = Hq(f), T = aG(g, x.items, a, c, f.isHorizontalMenu, w), A = u8(f), F = kt(x.menus, (q, ne) => aG(ne, q, a, c, !1, A)), H = Fs(F, rs(g, T));
    return B.from(E1.tieredData(g, H, x.expansions));
  }, yO = (t) => !Ho(t, "items"), xO = "data-value", d8 = (t, a, c, f, g) => tt(c, (x) => yO(x) ? {
    type: "togglemenuitem",
    ...g ? {} : { role: "option" },
    text: x.text,
    value: x.value,
    active: x.value === f,
    onAction: () => {
      Mn.setValue(t, x.value), po(t, wu, { name: a }), Ao.focus(t);
    }
  } : {
    type: "nestedmenuitem",
    text: x.text,
    getSubmenuItems: () => d8(t, a, x.items, f, g)
  }), kN = (t, a) => Ko(t, (c) => yO(c) ? Xn(c.value === a, c) : kN(c.items, a)), zq = (t, a, c) => {
    const f = Fn(t.items, (F) => !yO(F)), g = a.shared.providers, x = c.bind((F) => kN(t.items, F)).orThunk(() => so(t.items).filter(yO)), w = t.label.map((F) => ev(F, g)), T = gs.parts.field({
      dom: {},
      factory: {
        sketch: (F) => vO({
          uid: F.uid,
          text: x.map((H) => H.text),
          icon: B.none(),
          tooltip: B.none(),
          role: Xn(!f, "combobox"),
          ...f ? {} : { listRole: "listbox" },
          ariaLabel: t.label,
          fetch: (H, q) => {
            const ne = d8(H, t.name, t.items, Mn.getValue(H), f);
            q(Mx(ne, em.CLOSE_ON_EXECUTE, a, {
              isHorizontalMenu: !1,
              search: B.none()
            }));
          },
          onSetup: te(G),
          getApi: te({}),
          columns: 1,
          presets: "normal",
          classes: [],
          dropdownBehaviours: [
            Zs.config({}),
            X1(x.map((H) => H.value), (H) => os(H.element, xO), (H, q) => {
              kN(t.items, q).each((ne) => {
                rn(H.element, xO, ne.value), po(H, wf, { text: ne.text });
              });
            })
          ]
        }, "tox-listbox", a.shared)
      }
    }), A = {
      dom: {
        tag: "div",
        classes: ["tox-listboxfield"]
      },
      components: [T]
    };
    return gs.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: en([
        w.toArray(),
        [A]
      ]),
      fieldBehaviours: Qt([_o.config({
        disabled: te(!t.enabled),
        onDisabled: (F) => {
          gs.getField(F).each(_o.disable);
        },
        onEnabled: (F) => {
          gs.getField(F).each(_o.enable);
        }
      })])
    });
  }, _N = (t, a) => ({
    dom: {
      tag: "div",
      classes: t.classes
    },
    components: tt(t.items, a.shared.interpreter)
  }), Vq = (t, a) => {
    const c = tt(t.options, (g) => ({
      dom: {
        tag: "option",
        value: g.value,
        innerHtml: g.text
      }
    })), f = t.data.map((g) => rs("initialValue", g)).getOr({});
    return {
      uid: t.uid,
      dom: {
        tag: "select",
        classes: t.selectClasses,
        attributes: t.selectAttributes
      },
      components: c,
      behaviours: Li(t.selectBehaviours, [
        Ao.config({}),
        Mn.config({
          store: {
            mode: "manual",
            getValue: (g) => vt(g.element),
            setValue: (g, x) => {
              const w = so(t.options);
              At(t.options, (A) => A.value === x).isSome() ? Zf(g.element, x) : g.element.dom.selectedIndex === -1 && x === "" && w.each((A) => Zf(g.element, A.value));
            },
            ...f
          }
        })
      ])
    };
  }, f8 = Pc({
    name: "HtmlSelect",
    configFields: [
      Rt("options"),
      $i("selectBehaviours", [
        Ao,
        Mn
      ]),
      Qe("selectClasses", []),
      Qe("selectAttributes", {}),
      jr("data")
    ],
    factory: Vq
  }), jq = (t, a, c) => {
    const f = tt(t.items, (A) => ({
      text: a.translate(A.text),
      value: A.value
    })), g = t.label.map((A) => ev(A, a)), x = gs.parts.field({
      dom: {},
      ...c.map((A) => ({ data: A })).getOr({}),
      selectAttributes: { size: t.size },
      options: f,
      factory: f8,
      selectBehaviours: Qt([
        _o.config({ disabled: () => !t.enabled || a.isDisabled() }),
        Zs.config({}),
        Go("selectbox-change", [It(ab(), (A, F) => {
          po(A, wu, { name: t.name });
        })])
      ])
    }), w = t.size > 1 ? B.none() : B.some(xu("chevron-down", {
      tag: "div",
      classes: ["tox-selectfield__icon-js"]
    }, a.icons)), T = {
      dom: {
        tag: "div",
        classes: ["tox-selectfield"]
      },
      components: en([
        [x],
        w.toArray()
      ])
    };
    return gs.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: en([
        g.toArray(),
        [T]
      ]),
      fieldBehaviours: Qt([
        _o.config({
          disabled: () => !t.enabled || a.isDisabled(),
          onDisabled: (A) => {
            gs.getField(A).each(_o.disable);
          },
          onEnabled: (A) => {
            gs.getField(A).each(_o.enable);
          }
        }),
        Si()
      ])
    });
  }, m8 = te([
    Qe("field1Name", "field1"),
    Qe("field2Name", "field2"),
    ju("onLockedChange"),
    Uf(["lockClass"]),
    Qe("locked", !1),
    Zu.field("coupledFieldBehaviours", [
      Nr,
      Mn
    ])
  ]), Uq = (t, a, c) => Xt(t, a, c).bind(Nr.getCurrent), p8 = (t, a) => hl({
    factory: gs,
    name: t,
    overrides: (c) => ({
      fieldBehaviours: Qt([Go("coupled-input-behaviour", [It(Lf(), (f) => {
        Uq(f, c, a).each((g) => {
          Xt(f, c, "lock").each((x) => {
            ir.isOn(x) && c.onLockedChange(f, g, x);
          });
        });
      })])])
    })
  }), Wq = te([
    p8("field1", "field2"),
    p8("field2", "field1"),
    hl({
      factory: Rl,
      schema: [Rt("dom")],
      name: "lock",
      overrides: (t) => ({
        buttonBehaviours: Qt([ir.config({
          selected: t.locked,
          toggleClass: t.markers.lockClass,
          aria: { mode: "pressed" }
        })])
      })
    })
  ]), Zq = (t, a, c, f) => ({
    uid: t.uid,
    dom: t.dom,
    components: a,
    behaviours: Zu.augment(t.coupledFieldBehaviours, [
      Nr.config({ find: B.some }),
      Mn.config({
        store: {
          mode: "manual",
          getValue: (g) => {
            const x = g1(g, t, [
              "field1",
              "field2"
            ]);
            return {
              [t.field1Name]: Mn.getValue(x.field1()),
              [t.field2Name]: Mn.getValue(x.field2())
            };
          },
          setValue: (g, x) => {
            const w = g1(g, t, [
              "field1",
              "field2"
            ]);
            As(x, t.field1Name) && Mn.setValue(w.field1(), x[t.field1Name]), As(x, t.field2Name) && Mn.setValue(w.field2(), x[t.field2Name]);
          }
        }
      })
    ]),
    apis: {
      getField1: (g) => Xt(g, t, "field1"),
      getField2: (g) => Xt(g, t, "field2"),
      getLock: (g) => Xt(g, t, "lock")
    }
  }), Dd = Vl({
    name: "FormCoupledInputs",
    configFields: m8(),
    partFields: Wq(),
    factory: Zq,
    apis: {
      getField1: (t, a) => t.getField1(a),
      getField2: (t, a) => t.getField2(a),
      getLock: (t, a) => t.getLock(a)
    }
  }), h8 = (t) => {
    const a = {
      "": 0,
      px: 0,
      pt: 1,
      mm: 1,
      pc: 2,
      ex: 2,
      em: 2,
      ch: 2,
      rem: 2,
      cm: 3,
      in: 4,
      "%": 4
    }, c = (g) => g in a ? a[g] : 1;
    let f = t.value.toFixed(c(t.unit));
    return f.indexOf(".") !== -1 && (f = f.replace(/\.?0*$/, "")), f + t.unit;
  }, EN = (t) => {
    const c = /^\s*(\d+(?:\.\d+)?)\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\s*$/.exec(t);
    if (c !== null) {
      const f = parseFloat(c[1]), g = c[2];
      return zo.value({
        value: f,
        unit: g
      });
    } else
      return zo.error(t);
  }, g8 = (t, a) => {
    const c = {
      "": 96,
      px: 96,
      pt: 72,
      cm: 2.54,
      pc: 12,
      mm: 25.4,
      in: 1
    }, f = (g) => Ho(c, g);
    return t.unit === a ? B.some(t.value) : f(t.unit) && f(a) ? c[t.unit] === c[a] ? B.some(t.value) : B.some(t.value / c[t.unit] * c[a]) : B.none();
  }, wO = (t) => B.none(), Gq = (t, a) => (c) => g8(c, a).map((f) => ({
    value: f * t,
    unit: a
  })), qq = (t, a) => {
    const c = EN(t).toOptional(), f = EN(a).toOptional();
    return xa(c, f, (g, x) => g8(g, x.unit).map((w) => x.value / w).map((w) => Gq(w, x.unit)).getOr(wO)).getOr(wO);
  }, Kq = (t, a) => {
    let c = wO;
    const f = Nn("ratio-event"), g = (ie) => xu(ie, {
      tag: "span",
      classes: [
        "tox-icon",
        "tox-lock-icon__" + ie
      ]
    }, a.icons), x = t.label.getOr("Constrain proportions"), w = a.translate(x), T = Dd.parts.lock({
      dom: {
        tag: "button",
        classes: [
          "tox-lock",
          "tox-button",
          "tox-button--naked",
          "tox-button--icon"
        ],
        attributes: {
          "aria-label": w,
          "data-mce-name": x
        }
      },
      components: [
        g("lock"),
        g("unlock")
      ],
      buttonBehaviours: Qt([
        _o.config({ disabled: () => !t.enabled || a.isDisabled() }),
        Si(),
        Zs.config({}),
        gl.config(a.tooltips.getConfig({ tooltipText: w }))
      ])
    }), A = (ie) => ({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: ie
    }), F = (ie) => gs.parts.field({
      factory: N1,
      inputClasses: ["tox-textfield"],
      inputBehaviours: Qt([
        _o.config({ disabled: () => !t.enabled || a.isDisabled() }),
        Si(),
        Zs.config({}),
        Go("size-input-events", [
          It(Xd(), (fe, _e) => {
            po(fe, f, { isField1: ie });
          }),
          It(ab(), (fe, _e) => {
            po(fe, wu, { name: t.name });
          })
        ])
      ]),
      selectOnFocus: !1
    }), H = (ie) => ({
      dom: {
        tag: "label",
        classes: ["tox-label"]
      },
      components: [Oa(a.translate(ie))]
    }), q = Dd.parts.field1(A([
      gs.parts.label(H("Width")),
      F(!0)
    ])), ne = Dd.parts.field2(A([
      gs.parts.label(H("Height")),
      F(!1)
    ]));
    return Dd.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-form__controls-h-stack"]
        },
        components: [
          q,
          ne,
          A([
            H(Up),
            T
          ])
        ]
      }],
      field1Name: "width",
      field2Name: "height",
      locked: !0,
      markers: { lockClass: "tox-locked" },
      onLockedChange: (ie, fe, _e) => {
        EN(Mn.getValue(ie)).each((st) => {
          c(st).each((De) => {
            Mn.setValue(fe, h8(De));
          });
        });
      },
      coupledFieldBehaviours: Qt([
        _o.config({
          disabled: () => !t.enabled || a.isDisabled(),
          onDisabled: (ie) => {
            Dd.getField1(ie).bind(gs.getField).each(_o.disable), Dd.getField2(ie).bind(gs.getField).each(_o.disable), Dd.getLock(ie).each(_o.disable);
          },
          onEnabled: (ie) => {
            Dd.getField1(ie).bind(gs.getField).each(_o.enable), Dd.getField2(ie).bind(gs.getField).each(_o.enable), Dd.getLock(ie).each(_o.enable);
          }
        }),
        Si(),
        Go("size-input-events2", [It(f, (ie, fe) => {
          const _e = fe.event.isField1, st = _e ? Dd.getField1(ie) : Dd.getField2(ie), De = _e ? Dd.getField2(ie) : Dd.getField1(ie), Je = st.map(Mn.getValue).getOr(""), Ge = De.map(Mn.getValue).getOr("");
          c = qq(Je, Ge);
        })])
      ])
    });
  }, b8 = (t, a, c) => {
    const f = xf.parts.label({
      dom: {
        tag: "label",
        classes: ["tox-label"]
      },
      components: [Oa(a.translate(t.label))]
    }), g = xf.parts.spectrum({
      dom: {
        tag: "div",
        classes: ["tox-slider__rail"],
        attributes: { role: "presentation" }
      }
    }), x = xf.parts.thumb({
      dom: {
        tag: "div",
        classes: ["tox-slider__handle"],
        attributes: { role: "presentation" }
      }
    });
    return xf.sketch({
      dom: {
        tag: "div",
        classes: ["tox-slider"],
        attributes: { role: "presentation" }
      },
      model: {
        mode: "x",
        minX: t.min,
        maxX: t.max,
        getInitialValue: te(c.getOrThunk(() => (Math.abs(t.max) - Math.abs(t.min)) / 2))
      },
      components: [
        f,
        g,
        x
      ],
      sliderBehaviours: Qt([
        ed.self(),
        Ao.config({})
      ]),
      onChoose: (w, T, A) => {
        po(w, wu, {
          name: t.name,
          value: A
        });
      },
      onChange: (w, T, A) => {
        po(w, wu, {
          name: t.name,
          value: A
        });
      }
    });
  }, Yq = (t, a) => {
    const c = (T) => ({
      dom: {
        tag: "th",
        innerHtml: a.translate(T)
      }
    }), f = (T) => ({
      dom: { tag: "thead" },
      components: [{
        dom: { tag: "tr" },
        components: tt(T, c)
      }]
    }), g = (T) => ({
      dom: {
        tag: "td",
        innerHtml: a.translate(T)
      }
    }), x = (T) => ({
      dom: { tag: "tr" },
      components: tt(T, g)
    }), w = (T) => ({
      dom: { tag: "tbody" },
      components: tt(T, x)
    });
    return {
      dom: {
        tag: "table",
        classes: ["tox-dialog__table"]
      },
      components: [
        f(t.header),
        w(t.cells)
      ],
      behaviours: Qt([
        Zs.config({}),
        Ao.config({})
      ])
    };
  }, v8 = (t, a) => {
    const c = t.label.map((ie) => ev(ie, a)), f = [
      _o.config({ disabled: () => t.disabled || a.isDisabled() }),
      Si(),
      oo.config({
        mode: "execution",
        useEnter: t.multiline !== !0,
        useControlEnter: t.multiline === !0,
        execute: (ie) => (tr(ie, _x), B.some(!0))
      }),
      Go("textfield-change", [
        It(Lf(), (ie, fe) => {
          po(ie, wu, { name: t.name });
        }),
        It(Om(), (ie, fe) => {
          po(ie, wu, { name: t.name });
        })
      ]),
      Zs.config({})
    ], g = t.validation.map((ie) => ih.config({
      getRoot: (fe) => Ui(fe.element),
      invalidClass: "tox-invalid",
      validator: {
        validate: (fe) => {
          const _e = Mn.getValue(fe), st = ie.validator(_e);
          return jl.pure(st === !0 ? zo.value(_e) : zo.error(st));
        },
        validateOnLoad: ie.validateOnLoad
      }
    })).toArray(), x = t.placeholder.fold(te({}), (ie) => ({ placeholder: a.translate(ie) })), w = t.inputMode.fold(te({}), (ie) => ({ inputmode: ie })), T = {
      ...x,
      ...w
    }, A = gs.parts.field({
      tag: t.multiline === !0 ? "textarea" : "input",
      ...t.data.map((ie) => ({ data: ie })).getOr({}),
      inputAttributes: T,
      inputClasses: [t.classname],
      inputBehaviours: Qt(en([
        f,
        g
      ])),
      selectOnFocus: !1,
      factory: N1
    }), F = t.multiline ? {
      dom: {
        tag: "div",
        classes: ["tox-textarea-wrap"]
      },
      components: [A]
    } : A, q = (t.flex ? ["tox-form__group--stretched"] : []).concat(t.maximized ? ["tox-form-group--maximize"] : []), ne = [
      _o.config({
        disabled: () => t.disabled || a.isDisabled(),
        onDisabled: (ie) => {
          gs.getField(ie).each(_o.disable);
        },
        onEnabled: (ie) => {
          gs.getField(ie).each(_o.enable);
        }
      }),
      Si()
    ];
    return kx(c, F, q, ne);
  }, Xq = (t, a, c) => v8({
    name: t.name,
    multiline: !1,
    label: t.label,
    inputMode: t.inputMode,
    placeholder: t.placeholder,
    flex: !1,
    disabled: !t.enabled,
    classname: "tox-textfield",
    validation: B.none(),
    maximized: t.maximized,
    data: c
  }, a), y8 = (t, a, c) => v8({
    name: t.name,
    multiline: !0,
    label: t.label,
    inputMode: B.none(),
    placeholder: t.placeholder,
    flex: !0,
    disabled: !t.enabled,
    classname: "tox-textarea",
    validation: B.none(),
    maximized: t.maximized,
    data: c
  }, a), Ix = (t, a) => a.getAnimationRoot.fold(() => t.element, (c) => c(t)), ch = (t) => t.dimension.property, uh = (t, a) => t.dimension.getDimension(a), CO = (t, a) => {
    const c = Ix(t, a);
    Gc(c, [
      a.shrinkingClass,
      a.growingClass
    ]);
  }, TN = (t, a) => {
    va(t.element, a.openClass), Us(t.element, a.closedClass), Ln(t.element, ch(a), "0px"), yi(t.element);
  }, ON = (t, a) => {
    va(t.element, a.closedClass), Us(t.element, a.openClass), xr(t.element, ch(a));
  }, x8 = (t, a, c, f) => {
    c.setCollapsed(), Ln(t.element, ch(a), uh(a, t.element)), CO(t, a), TN(t, a), a.onStartShrink(t), a.onShrunk(t);
  }, w8 = (t, a, c, f) => {
    const g = f.getOrThunk(() => uh(a, t.element));
    c.setCollapsed(), Ln(t.element, ch(a), g), yi(t.element);
    const x = Ix(t, a);
    va(x, a.growingClass), Us(x, a.shrinkingClass), TN(t, a), a.onStartShrink(t);
  }, C8 = (t, a, c) => {
    const f = uh(a, t.element);
    (f === "0px" ? x8 : w8)(t, a, c, B.some(f));
  }, S8 = (t, a, c) => {
    const f = Ix(t, a), g = Zc(f, a.shrinkingClass), x = uh(a, t.element);
    ON(t, a);
    const w = uh(a, t.element);
    (g ? () => {
      Ln(t.element, ch(a), x), yi(t.element);
    } : () => {
      TN(t, a);
    })(), va(f, a.shrinkingClass), Us(f, a.growingClass), ON(t, a), Ln(t.element, ch(a), w), c.setExpanded(), a.onStartGrow(t);
  }, Qq = (t, a, c) => {
    if (c.isExpanded()) {
      xr(t.element, ch(a));
      const f = uh(a, t.element);
      Ln(t.element, ch(a), f);
    }
  }, k8 = (t, a, c) => {
    c.isExpanded() || S8(t, a, c);
  }, _8 = (t, a, c) => {
    c.isExpanded() && C8(t, a, c);
  }, Jq = (t, a, c) => {
    c.isExpanded() && x8(t, a, c);
  }, eK = (t, a, c) => c.isExpanded(), E8 = (t, a, c) => c.isCollapsed(), T8 = (t, a, c) => {
    const f = Ix(t, a);
    return Zc(f, a.growingClass) === !0;
  }, O8 = (t, a, c) => {
    const f = Ix(t, a);
    return Zc(f, a.shrinkingClass) === !0;
  };
  var A8 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    refresh: Qq,
    grow: k8,
    shrink: _8,
    immediateShrink: Jq,
    hasGrown: eK,
    hasShrunk: E8,
    isGrowing: T8,
    isShrinking: O8,
    isTransitioning: (t, a, c) => T8(t, a) || O8(t, a),
    toggleGrow: (t, a, c) => {
      (c.isExpanded() ? C8 : S8)(t, a, c);
    },
    disableTransitions: CO,
    immediateGrow: (t, a, c) => {
      c.isExpanded() || (ON(t, a), Ln(t.element, ch(a), uh(a, t.element)), CO(t, a), c.setExpanded(), a.onStartGrow(t), a.onGrown(t));
    }
  }), P8 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, a, c) => {
      const f = a.expanded;
      return Uc(f ? {
        classes: [a.openClass],
        styles: {}
      } : {
        classes: [a.closedClass],
        styles: rs(a.dimension.property, "0px")
      });
    },
    events: (t, a) => js([ib(Qd(), (c, f) => {
      f.event.raw.propertyName === t.dimension.property && (CO(c, t), a.isExpanded() && xr(c.element, t.dimension.property), (a.isExpanded() ? t.onGrown : t.onShrunk)(c));
    })])
  }), Fae = [
    Rt("closedClass"),
    Rt("openClass"),
    Rt("shrinkingClass"),
    Rt("growingClass"),
    jr("getAnimationRoot"),
    Rr("onShrunk"),
    Rr("onStartShrink"),
    Rr("onGrown"),
    Rr("onStartGrow"),
    Qe("expanded", !1),
    Vr("dimension", ci("property", {
      width: [
        Ws("property", "width"),
        Ws("getDimension", (t) => Pi(t) + "px")
      ],
      height: [
        Ws("property", "height"),
        Ws("getDimension", (t) => Bs(t) + "px")
      ]
    }))
  ], rK = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: (t) => {
      const a = no(t.expanded), c = () => "expanded: " + a.get();
      return Wc({
        isExpanded: () => a.get() === !0,
        isCollapsed: () => a.get() === !1,
        setCollapsed: Kt(a.set, !1),
        setExpanded: Kt(a.set, !0),
        readState: c
      });
    }
  });
  const nu = Xi({
    fields: Fae,
    name: "sliding",
    active: P8,
    apis: A8,
    state: rK
  }), D8 = (t) => ({
    isEnabled: () => !_o.isDisabled(t),
    setEnabled: (a) => _o.set(t, !a),
    setActive: (a) => {
      const c = t.element;
      a ? (Us(c, "tox-tbtn--enabled"), rn(c, "aria-pressed", !0)) : (va(c, "tox-tbtn--enabled"), Ee(c, "aria-pressed"));
    },
    isActive: () => Zc(t.element, "tox-tbtn--enabled"),
    setText: (a) => {
      po(t, wf, { text: a });
    },
    setIcon: (a) => po(t, ov, { icon: a })
  }), PS = (t, a, c, f, g = !0, x) => vO({
    text: t.text,
    icon: t.icon,
    tooltip: t.tooltip,
    ariaLabel: t.tooltip,
    searchable: t.search.isSome(),
    role: f,
    fetch: (w, T) => {
      const A = { pattern: t.search.isSome() ? oG(w) : "" };
      t.fetch((F) => {
        T(Mx(F, em.CLOSE_ON_EXECUTE, c, {
          isHorizontalMenu: !1,
          search: t.search
        }));
      }, A, D8(w));
    },
    onSetup: t.onSetup,
    getApi: D8,
    columns: 1,
    presets: "normal",
    classes: [],
    dropdownBehaviours: [...g ? [Zs.config({})] : []]
  }, a, c.shared, x), sK = (t, a, c) => {
    const f = (x) => (w) => {
      const T = !w.isActive();
      w.setActive(T), x.storage.set(T), c.shared.getSink().each((A) => {
        a().getOpt(A).each((F) => {
          mu(F.element), po(F, ah, {
            name: x.name,
            value: x.storage.get()
          });
        });
      });
    }, g = (x) => (w) => {
      w.setActive(x.storage.get());
    };
    return (x) => {
      x(tt(t, (w) => {
        const T = w.text.fold(() => ({}), (A) => ({ text: A }));
        return {
          type: w.type,
          active: !1,
          ...T,
          onAction: f(w),
          onSetup: g(w)
        };
      }));
    };
  }, AN = (t) => ({
    dom: {
      tag: "span",
      classes: ["tox-tree__label"],
      attributes: { "aria-label": t }
    },
    components: [Oa(t)]
  }), _O = Nn("leaf-label-event-id"), EO = ({ leaf: t, onLeafAction: a, visible: c, treeId: f, selectedId: g, backstage: x }) => {
    const w = t.menu.map((A) => PS(A, "tox-mbtn", x, B.none(), c)), T = [AN(t.title)];
    return w.each((A) => T.push(A)), Rl.sketch({
      dom: {
        tag: "div",
        classes: [
          "tox-tree--leaf__label",
          "tox-trbtn"
        ].concat(c ? ["tox-tree--leaf__label--visible"] : [])
      },
      components: T,
      role: "treeitem",
      action: (A) => {
        a(t.id), A.getSystem().broadcastOn([`update-active-item-${f}`], { value: t.id });
      },
      eventOrder: {
        [Cd()]: [
          _O,
          "keying"
        ]
      },
      buttonBehaviours: Qt([
        ...c ? [Zs.config({})] : [],
        ir.config({
          toggleClass: "tox-trbtn--enabled",
          toggleOnExecute: !1,
          aria: { mode: "selected" }
        }),
        Ac.config({
          channels: {
            [`update-active-item-${f}`]: {
              onReceive: (A, F) => {
                (F.value === t.id ? ir.on : ir.off)(A);
              }
            }
          }
        }),
        Go(_O, [
          Qs((A, F) => {
            g.each((H) => {
              (H === t.id ? ir.on : ir.off)(A);
            });
          }),
          It(Cd(), (A, F) => {
            const H = F.event.raw.code === "ArrowLeft", q = F.event.raw.code === "ArrowRight";
            H ? (Nm(A.element, ".tox-tree--directory").each((ne) => {
              A.getSystem().getByDom(ne).each((ie) => {
                v2(ne, ".tox-tree--directory__label").each((fe) => {
                  ie.getSystem().getByDom(fe).each(Ao.focus);
                });
              });
            }), F.stop()) : q && F.stop();
          })
        ])
      ])
    });
  }, aK = (t, a, c) => xu(t, {
    tag: "span",
    classes: [
      "tox-tree__icon-wrap",
      "tox-icon"
    ],
    behaviours: c
  }, a), iK = (t, a) => aK(t, a, []), R8 = Nn("directory-label-event-id"), lK = ({ directory: t, visible: a, noChildren: c, backstage: f }) => {
    const g = t.menu.map((T) => PS(T, "tox-mbtn", f, B.none())), x = [
      {
        dom: {
          tag: "div",
          classes: ["tox-chevron"]
        },
        components: [iK("chevron-right", f.shared.providers.icons)]
      },
      AN(t.title)
    ];
    g.each((T) => {
      x.push(T);
    });
    const w = (T) => {
      Nm(T.element, ".tox-tree--directory").each((A) => {
        T.getSystem().getByDom(A).each((F) => {
          const H = !ir.isOn(F);
          ir.toggle(F), po(T, "expand-tree-node", {
            expanded: H,
            node: t.id
          });
        });
      });
    };
    return Rl.sketch({
      dom: {
        tag: "div",
        classes: [
          "tox-tree--directory__label",
          "tox-trbtn"
        ].concat(a ? ["tox-tree--directory__label--visible"] : [])
      },
      components: x,
      action: w,
      eventOrder: {
        [Cd()]: [
          R8,
          "keying"
        ]
      },
      buttonBehaviours: Qt([
        ...a ? [Zs.config({})] : [],
        Go(R8, [It(Cd(), (T, A) => {
          const F = A.event.raw.code === "ArrowRight", H = A.event.raw.code === "ArrowLeft";
          F && c && A.stop(), (F || H) && Nm(T.element, ".tox-tree--directory").each((q) => {
            T.getSystem().getByDom(q).each((ne) => {
              !ir.isOn(ne) && F || ir.isOn(ne) && H ? (w(T), A.stop()) : H && !ir.isOn(ne) && (Nm(ne.element, ".tox-tree--directory").each((ie) => {
                v2(ie, ".tox-tree--directory__label").each((fe) => {
                  ne.getSystem().getByDom(fe).each(Ao.focus);
                });
              }), A.stop());
            });
          });
        })])
      ])
    });
  }, cK = ({ children: t, onLeafAction: a, visible: c, treeId: f, expandedIds: g, selectedId: x, backstage: w }) => ({
    dom: {
      tag: "div",
      classes: ["tox-tree--directory__children"]
    },
    components: t.map((T) => T.type === "leaf" ? EO({
      leaf: T,
      selectedId: x,
      onLeafAction: a,
      visible: c,
      treeId: f,
      backstage: w
    }) : PN({
      directory: T,
      expandedIds: g,
      selectedId: x,
      onLeafAction: a,
      labelTabstopping: c,
      treeId: f,
      backstage: w
    })),
    behaviours: Qt([
      nu.config({
        dimension: { property: "height" },
        closedClass: "tox-tree--directory__children--closed",
        openClass: "tox-tree--directory__children--open",
        growingClass: "tox-tree--directory__children--growing",
        shrinkingClass: "tox-tree--directory__children--shrinking",
        expanded: c
      }),
      No.config({})
    ])
  }), uK = Nn("directory-event-id"), PN = ({ directory: t, onLeafAction: a, labelTabstopping: c, treeId: f, backstage: g, expandedIds: x, selectedId: w }) => {
    const { children: T } = t, A = no(x), F = (q) => T.map((ne) => ne.type === "leaf" ? EO({
      leaf: ne,
      selectedId: w,
      onLeafAction: a,
      visible: q,
      treeId: f,
      backstage: g
    }) : PN({
      directory: ne,
      expandedIds: A.get(),
      selectedId: w,
      onLeafAction: a,
      labelTabstopping: q,
      treeId: f,
      backstage: g
    })), H = x.includes(t.id);
    return {
      dom: {
        tag: "div",
        classes: ["tox-tree--directory"],
        attributes: { role: "treeitem" }
      },
      components: [
        lK({
          directory: t,
          visible: c,
          noChildren: t.children.length === 0,
          backstage: g
        }),
        cK({
          children: T,
          expandedIds: x,
          selectedId: w,
          onLeafAction: a,
          visible: H,
          treeId: f,
          backstage: g
        })
      ],
      behaviours: Qt([
        Go(uK, [
          Qs((q, ne) => {
            ir.set(q, H);
          }),
          It("expand-tree-node", (q, ne) => {
            const { expanded: ie, node: fe } = ne.event;
            A.set(ie ? [
              ...A.get(),
              fe
            ] : A.get().filter((_e) => _e !== fe));
          })
        ]),
        ir.config({
          ...t.children.length > 0 ? { aria: { mode: "expanded" } } : {},
          toggleClass: "tox-tree--directory--expanded",
          onToggled: (q, ne) => {
            const ie = q.components()[1], fe = F(ne);
            ne ? nu.grow(ie) : nu.shrink(ie), No.set(ie, fe);
          }
        })
      ])
    };
  }, dK = Nn("tree-event-id"), fK = (t, a) => {
    const c = t.onLeafAction.getOr(G), f = t.onToggleExpand.getOr(G), g = t.defaultExpandedIds, x = no(g), w = no(t.defaultSelectedId), T = Nn("tree-id"), A = (F, H) => t.items.map((q) => q.type === "leaf" ? EO({
      leaf: q,
      selectedId: F,
      onLeafAction: c,
      visible: !0,
      treeId: T,
      backstage: a
    }) : PN({
      directory: q,
      selectedId: F,
      onLeafAction: c,
      expandedIds: H,
      labelTabstopping: !0,
      treeId: T,
      backstage: a
    }));
    return {
      dom: {
        tag: "div",
        classes: ["tox-tree"],
        attributes: { role: "tree" }
      },
      components: A(w.get(), x.get()),
      behaviours: Qt([
        oo.config({
          mode: "flow",
          selector: ".tox-tree--leaf__label--visible, .tox-tree--directory__label--visible",
          cycles: !1
        }),
        Go(dK, [It("expand-tree-node", (F, H) => {
          const { expanded: q, node: ne } = H.event;
          x.set(q ? [
            ...x.get(),
            ne
          ] : x.get().filter((ie) => ie !== ne)), f(x.get(), {
            expanded: q,
            node: ne
          });
        })]),
        Ac.config({
          channels: {
            [`update-active-item-${T}`]: {
              onReceive: (F, H) => {
                w.set(B.some(H.value)), No.set(F, A(B.some(H.value), x.get()));
              }
            }
          }
        }),
        No.config({})
      ])
    };
  };
  var N8 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, a) => {
      const f = t.stream.streams.setup(t, a);
      return js([
        It(t.event, f),
        zf(() => a.cancel())
      ].concat(t.cancelEvent.map((g) => [It(g, () => a.cancel())]).getOr([])));
    }
  });
  const M8 = (t) => {
    const a = no(null);
    return Wc({
      readState: () => ({ timer: a.get() !== null ? "set" : "unset" }),
      setTimer: (x) => {
        a.set(x);
      },
      cancel: () => {
        const x = a.get();
        x !== null && x.cancel();
      }
    });
  };
  var mK = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    throttle: M8,
    init: (t) => t.stream.streams.state(t)
  });
  const pK = (t, a) => {
    const c = t.stream, f = mN(t.onStream, c.delay);
    return a.setTimer(f), (g, x) => {
      f.throttle(g, x), c.stopEvent && x.stop();
    };
  };
  var hK = [
    Vr("stream", ci("mode", {
      throttle: [
        Rt("delay"),
        Qe("stopEvent", !0),
        Ws("streams", {
          setup: pK,
          state: M8
        })
      ]
    })),
    Qe("event", "input"),
    jr("cancelEvent"),
    ju("onStream")
  ];
  const DN = Xi({
    fields: hK,
    name: "streaming",
    active: N8,
    state: mK
  }), TO = (t, a, c) => {
    const f = Mn.getValue(c);
    Mn.setValue(a, f), F8(a);
  }, I8 = (t, a) => {
    const c = t.element, f = vt(c), g = c.dom;
    os(c, "type") !== "number" && a(g, f);
  }, F8 = (t) => {
    I8(t, (a, c) => a.setSelectionRange(c.length, c.length));
  }, gK = (t, a) => {
    I8(t, (c, f) => c.setSelectionRange(a, f.length));
  }, bK = (t, a, c) => {
    if (t.selectsOver) {
      const f = Mn.getValue(a), g = t.getDisplayText(f), x = Mn.getValue(c);
      return t.getDisplayText(x).indexOf(g) === 0 ? B.some(() => {
        TO(t, a, c), gK(a, g.length);
      }) : B.none();
    } else
      return B.none();
  }, OO = te("alloy.typeahead.itemexecute"), vK = (t, a, c, f) => {
    const g = (q, ne, ie) => {
      t.previewing.set(!1);
      const fe = Ia.getCoupled(q, "sandbox");
      if (Br.isOpen(fe))
        Nr.getCurrent(fe).each((_e) => {
          wn.getHighlighted(_e).fold(() => {
            ie(_e);
          }, () => {
            Hf(fe, _e.element, "keydown", ne);
          });
        });
      else {
        const _e = (st) => {
          Nr.getCurrent(st).each(ie);
        };
        qT(t, w(q), q, fe, f, _e, Dc.HighlightMenuAndItem).get(G);
      }
    }, x = ZD(t), w = (q) => (ne) => ne.map((ie) => {
      const fe = Tr(ie.menus), _e = Ue(fe, (De) => To(De.items, (Je) => Je.type === "item"));
      return Mn.getState(q).update(tt(_e, (De) => De.data)), ie;
    }), T = (q) => Nr.getCurrent(q), A = "typeaheadevents", F = [
      Ao.config({}),
      Mn.config({
        onSetValue: t.onSetValue,
        store: {
          mode: "dataset",
          getDataKey: (q) => vt(q.element),
          getFallbackEntry: (q) => ({
            value: q,
            meta: {}
          }),
          setValue: (q, ne) => {
            Zf(q.element, t.model.getDisplayText(ne));
          },
          ...t.initialData.map((q) => rs("initialValue", q)).getOr({})
        }
      }),
      DN.config({
        stream: {
          mode: "throttle",
          delay: t.responseTime,
          stopEvent: !1
        },
        onStream: (q, ne) => {
          const ie = Ia.getCoupled(q, "sandbox");
          if (Ao.isFocused(q) && vt(q.element).length >= t.minChars) {
            const _e = T(ie).bind((De) => wn.getHighlighted(De).map(Mn.getValue));
            t.previewing.set(!0);
            const st = (De) => {
              T(ie).each((Je) => {
                _e.fold(() => {
                  t.model.selectsOver && wn.highlightFirst(Je);
                }, (Ge) => {
                  wn.highlightBy(Je, (Ft) => Mn.getValue(Ft).value === Ge.value), wn.getHighlighted(Je).orThunk(() => (wn.highlightFirst(Je), B.none()));
                });
              });
            };
            qT(t, w(q), q, ie, f, st, Dc.HighlightJustMenu).get(G);
          }
        },
        cancelEvent: Fw()
      }),
      oo.config({
        mode: "special",
        onDown: (q, ne) => (g(q, ne, wn.highlightFirst), B.some(!0)),
        onEscape: (q) => {
          const ne = Ia.getCoupled(q, "sandbox");
          return Br.isOpen(ne) ? (Br.close(ne), B.some(!0)) : B.none();
        },
        onUp: (q, ne) => (g(q, ne, wn.highlightLast), B.some(!0)),
        onEnter: (q) => {
          const ne = Ia.getCoupled(q, "sandbox"), ie = Br.isOpen(ne);
          if (ie && !t.previewing.get())
            return T(ne).bind((fe) => wn.getHighlighted(fe)).map((fe) => (po(q, OO(), { item: fe }), !0));
          {
            const fe = Mn.getValue(q);
            return tr(q, Fw()), t.onExecute(ne, q, fe), ie && Br.close(ne), B.some(!0);
          }
        }
      }),
      ir.config({
        toggleClass: t.markers.openClass,
        aria: { mode: "expanded" }
      }),
      Ia.config({
        others: {
          sandbox: (q) => DR(t, q, {
            onOpen: () => ir.on(q),
            onClose: () => {
              t.lazyTypeaheadComp.get().each((ne) => Ee(ne.element, "aria-activedescendant")), ir.off(q);
            }
          })
        }
      }),
      Go(A, [
        Qs((q) => {
          t.lazyTypeaheadComp.set(B.some(q));
        }),
        zf((q) => {
          t.lazyTypeaheadComp.set(B.none());
        }),
        Sd((q) => {
          const ne = G;
          AR(t, w(q), q, f, ne, Dc.HighlightMenuAndItem).get(G);
        }),
        It(OO(), (q, ne) => {
          const ie = Ia.getCoupled(q, "sandbox");
          TO(t.model, q, ne.event.item), tr(q, Fw()), t.onItemExecute(q, ie, ne.event.item, Mn.getValue(q)), Br.close(ie), F8(q);
        })
      ].concat(t.dismissOnBlur ? [It(kp(), (q) => {
        const ne = Ia.getCoupled(q, "sandbox");
        ic(ne.element).isNone() && Br.close(ne);
      })] : []))
    ], H = {
      [Vu()]: [
        Mn.name(),
        DN.name(),
        A
      ],
      ...t.eventOrder
    };
    return {
      uid: t.uid,
      dom: GD(Fs(t, {
        inputAttributes: {
          role: "combobox",
          "aria-autocomplete": "list",
          "aria-haspopup": "true"
        }
      })),
      behaviours: {
        ...x,
        ...Li(t.typeaheadBehaviours, F)
      },
      eventOrder: H
    };
  }, yK = te([
    jr("lazySink"),
    Rt("fetch"),
    Qe("minChars", 5),
    Qe("responseTime", 1e3),
    Rr("onOpen"),
    Qe("getHotspot", B.some),
    Qe("getAnchorOverrides", te({})),
    Qe("layouts", B.none()),
    Qe("eventOrder", {}),
    ee("model", {}, [
      Qe("getDisplayText", (t) => t.meta !== void 0 && t.meta.text !== void 0 ? t.meta.text : t.value),
      Qe("selectsOver", !0),
      Qe("populateFromBrowse", !0)
    ]),
    Rr("onSetValue"),
    sc("onExecute"),
    Rr("onItemExecute"),
    Qe("inputClasses", []),
    Qe("inputAttributes", {}),
    Qe("inputStyles", {}),
    Qe("matchWidth", !0),
    Qe("useMinWidth", !1),
    Qe("dismissOnBlur", !0),
    Uf(["openClass"]),
    jr("initialData"),
    jr("listRole"),
    $i("typeaheadBehaviours", [
      Ao,
      Mn,
      DN,
      oo,
      ir,
      Ia
    ]),
    Wr("lazyTypeaheadComp", () => no(B.none)),
    Wr("previewing", () => no(!0))
  ].concat(WD()).concat(KT())), xK = te([Gu({
    schema: [tg()],
    name: "menu",
    overrides: (t) => ({
      fakeFocus: !0,
      onHighlightItem: (a, c, f) => {
        t.previewing.get() ? t.lazyTypeaheadComp.get().each((g) => {
          bK(t.model, g, f).fold(() => {
            t.model.selectsOver ? (wn.dehighlight(c, f), t.previewing.set(!0)) : t.previewing.set(!1);
          }, (x) => {
            x(), t.previewing.set(!1);
          });
        }) : t.lazyTypeaheadComp.get().each((g) => {
          t.model.populateFromBrowse && TO(t.model, g, f), K(f.element, "id").each((x) => rn(g.element, "aria-activedescendant", x));
        });
      },
      onExecute: (a, c) => t.lazyTypeaheadComp.get().map((f) => (po(f, OO(), { item: c }), !0)),
      onHover: (a, c) => {
        t.previewing.set(!1), t.lazyTypeaheadComp.get().each((f) => {
          t.model.populateFromBrowse && TO(t.model, f, c);
        });
      }
    })
  })]), wK = Vl({
    name: "Typeahead",
    configFields: yK(),
    partFields: xK(),
    factory: vK
  }), lm = (t) => ({
    ...t,
    toCached: () => lm(t.toCached()),
    bindFuture: (A) => lm(t.bind((F) => F.fold((H) => jl.pure(zo.error(H)), (H) => A(H)))),
    bindResult: (A) => lm(t.map((F) => F.bind(A))),
    mapResult: (A) => lm(t.map((F) => F.map(A))),
    mapError: (A) => lm(t.map((F) => F.mapError(A))),
    foldResult: (A, F) => t.map((H) => H.fold(A, F)),
    withTimeout: (A, F) => lm(jl.nu((H) => {
      let q = !1;
      const ne = setTimeout(() => {
        q = !0, H(zo.error(F()));
      }, A);
      t.get((ie) => {
        q || (clearTimeout(ne), H(ie));
      });
    }))
  }), B8 = (t) => lm(jl.nu(t)), RN = (t) => lm(jl.pure(zo.value(t))), $8 = {
    nu: B8,
    wrap: lm,
    pure: RN,
    value: RN,
    error: (t) => lm(jl.pure(zo.error(t))),
    fromResult: (t) => lm(jl.pure(t)),
    fromFuture: (t) => lm(t.map(zo.value)),
    fromPromise: (t) => B8((a) => {
      t.then((c) => {
        a(zo.value(c));
      }, (c) => {
        a(zo.error(c));
      });
    })
  }, Fx = (t, a, c = [], f, g, x, w) => {
    const T = a.fold(() => ({}), (H) => ({ action: H })), A = {
      buttonBehaviours: Qt([
        rm.button(() => !t.enabled || w.isDisabled()),
        Si(),
        Zs.config({}),
        ...x.map((H) => gl.config(w.tooltips.getConfig({ tooltipText: w.translate(H) }))).toArray(),
        Go("button press", [
          F0("click"),
          F0("mousedown")
        ])
      ].concat(c)),
      eventOrder: {
        click: [
          "button press",
          "alloy.base.behaviour"
        ],
        mousedown: [
          "button press",
          "alloy.base.behaviour"
        ]
      },
      ...T
    }, F = Fs(A, { dom: f });
    return Fs(F, { components: g });
  }, kK = (t, a, c, f = [], g) => {
    const x = t.tooltip.map((F) => ({ "aria-label": c.translate(F) })).getOr({}), w = {
      tag: "button",
      classes: ["tox-tbtn"],
      attributes: {
        ...x,
        "data-mce-name": g
      }
    }, T = t.icon.map((F) => xN(F, c.icons)), A = B1([T]);
    return Fx(t, a, f, w, A, t.tooltip, c);
  }, AO = (t) => {
    switch (t) {
      case "primary":
        return ["tox-button"];
      case "toolbar":
        return ["tox-tbtn"];
      case "secondary":
      default:
        return [
          "tox-button",
          "tox-button--secondary"
        ];
    }
  }, NN = (t, a, c, f = [], g = []) => {
    const x = c.translate(t.text), w = t.icon.map((ie) => xN(ie, c.icons)), T = [w.getOrThunk(() => Oa(x))], A = t.buttonType.getOr(!t.primary && !t.borderless ? "secondary" : "primary"), q = {
      tag: "button",
      classes: [
        ...AO(A),
        ...w.isSome() ? ["tox-button--icon"] : [],
        ...t.borderless ? ["tox-button--naked"] : [],
        ...g
      ],
      attributes: {
        "aria-label": x,
        "data-mce-name": t.text
      }
    }, ne = t.icon.map(te(x));
    return Fx(t, a, f, q, T, ne, c);
  }, L8 = (t, a, c, f = [], g = []) => {
    const x = NN(t, B.some(a), c, f, g);
    return Rl.sketch(x);
  }, MN = (t, a) => (c) => {
    a === "custom" ? po(c, ah, {
      name: t,
      value: {}
    }) : a === "submit" ? tr(c, _x) : a === "cancel" ? tr(c, tv) : console.error("Unknown button type: ", a);
  }, _K = (t, a) => a === "menu", EK = (t, a) => a === "custom" || a === "cancel" || a === "submit", Ym = (t, a) => a === "togglebutton", PO = (t, a, c) => {
    var f, g;
    const x = t.icon.map((Ge) => Ng(Ge, a.icons)).map(is), w = (Ge) => {
      po(Ge, ah, {
        name: t.name,
        value: {
          setIcon: (Ft) => {
            x.map((gt) => gt.getOpt(Ge).each((Jt) => {
              No.set(Jt, [Ng(Ft, a.icons)]);
            }));
          }
        }
      });
    }, T = t.buttonType.getOr(t.primary ? "primary" : "secondary"), A = {
      ...t,
      name: (f = t.name) !== null && f !== void 0 ? f : "",
      primary: T === "primary",
      tooltip: t.tooltip,
      enabled: (g = t.enabled) !== null && g !== void 0 ? g : !1,
      borderless: !1
    }, F = A.tooltip.or(t.text).map((Ge) => ({ "aria-label": a.translate(Ge) })).getOr({}), H = AO(T ?? "secondary"), q = t.icon.isSome() && t.text.isSome(), ne = {
      tag: "button",
      classes: [
        ...H.concat(t.icon.isSome() ? ["tox-button--icon"] : []),
        ...t.active ? ["tox-button--enabled"] : [],
        ...q ? ["tox-button--icon-and-text"] : []
      ],
      attributes: {
        ...F,
        ...Ce(c) ? { "data-mce-name": c } : {}
      }
    }, ie = [], fe = a.translate(t.text.getOr("")), _e = Oa(fe), De = [
      ...B1([x.map((Ge) => Ge.asSpec())]),
      ...t.text.isSome() ? [_e] : []
    ], Je = Fx(A, B.some(w), ie, ne, De, t.tooltip, a);
    return Rl.sketch(Je);
  }, J1 = (t, a, c) => {
    if (_K(t, a)) {
      const f = () => w, g = t, x = {
        ...t,
        type: "menubutton",
        search: B.none(),
        onSetup: (T) => (T.setEnabled(t.enabled), G),
        fetch: sK(g.items, f, c)
      }, w = is(PS(x, "tox-tbtn", c, B.none(), !0, t.text.or(t.tooltip).getOrUndefined()));
      return w.asSpec();
    } else if (EK(t, a)) {
      const f = MN(t.name, a), g = {
        ...t,
        borderless: !1
      };
      return L8(g, f, c.shared.providers, []);
    } else {
      if (Ym(t, a))
        return PO(t, c.shared.providers, t.text.or(t.tooltip).getOrUndefined());
      throw console.error("Unknown footer button type: ", a), new Error("Unknown footer button type");
    }
  }, TK = (t, a) => {
    const c = MN(t.name, "custom");
    return wG(B.none(), gs.parts.field({
      factory: Rl,
      ...NN(t, B.some(c), a, [
        hO(""),
        ed.self()
      ])
    }));
  }, IN = { type: "separator" }, OK = (t) => ({
    type: "menuitem",
    value: t.url,
    text: t.title,
    meta: { attach: t.attach },
    onAction: G
  }), DS = (t, a) => ({
    type: "menuitem",
    value: a,
    text: t,
    meta: { attach: void 0 },
    onAction: G
  }), H8 = (t) => tt(t, OK), FN = (t, a) => To(a, (c) => c.type === t), z8 = (t, a) => H8(FN(t, a)), AK = (t) => z8("header", t.targets), V8 = (t) => z8("anchor", t.targets), PK = (t) => B.from(t.anchorTop).map((a) => DS("<top>", a)).toArray(), DK = (t) => B.from(t.anchorBottom).map((a) => DS("<bottom>", a)).toArray(), BN = (t) => tt(t, (a) => DS(a, a)), RK = (t) => Mt(t, (a, c) => a.length === 0 || c.length === 0 ? a.concat(c) : a.concat(IN, c), []), $N = (t, a) => {
    const c = t.toLowerCase();
    return To(a, (f) => {
      var g;
      const x = f.meta !== void 0 && f.meta.text !== void 0 ? f.meta.text : f.text, w = (g = f.value) !== null && g !== void 0 ? g : "";
      return Po(x.toLowerCase(), c) || Po(w.toLowerCase(), c);
    });
  }, j8 = (t, a, c) => {
    var f, g;
    const x = Mn.getValue(a), w = (g = (f = x == null ? void 0 : x.meta) === null || f === void 0 ? void 0 : f.text) !== null && g !== void 0 ? g : x.value;
    return c.getLinkInformation().fold(() => [], (A) => {
      const F = $N(w, BN(c.getHistory(t)));
      return t === "file" ? RK([
        F,
        $N(w, AK(A)),
        $N(w, en([
          PK(A),
          V8(A),
          DK(A)
        ]))
      ]) : F;
    });
  }, LN = Nn("aria-invalid"), NK = (t, a, c, f) => {
    const g = a.shared.providers, x = (Je) => {
      const Ge = Mn.getValue(Je);
      c.addToHistory(Ge.value, t.filetype);
    }, w = {
      ...f.map((Je) => ({ initialData: Je })).getOr({}),
      dismissOnBlur: !0,
      inputClasses: ["tox-textfield"],
      sandboxClasses: ["tox-dialog__popups"],
      inputAttributes: {
        "aria-errormessage": LN,
        type: "url"
      },
      minChars: 0,
      responseTime: 0,
      fetch: (Je) => {
        const Ge = j8(t.filetype, Je, c), Ft = Mx(Ge, em.BUBBLE_TO_SANDBOX, a, {
          isHorizontalMenu: !1,
          search: B.none()
        });
        return jl.pure(Ft);
      },
      getHotspot: (Je) => fe.getOpt(Je),
      onSetValue: (Je, Ge) => {
        Je.hasConfigured(ih) && ih.run(Je).get(G);
      },
      typeaheadBehaviours: Qt([
        ...c.getValidationHandler().map((Je) => ih.config({
          getRoot: (Ge) => Ui(Ge.element),
          invalidClass: "tox-control-wrap--status-invalid",
          notify: {
            onInvalid: (Ge, Ft) => {
              H.getOpt(Ge).each((gt) => {
                rn(gt.element, "title", g.translate(Ft));
              });
            }
          },
          validator: {
            validate: (Ge) => {
              const Ft = Mn.getValue(Ge);
              return $8.nu((gt) => {
                Je({
                  type: t.filetype,
                  url: Ft.value
                }, (Jt) => {
                  if (Jt.status === "invalid") {
                    const vn = zo.error(Jt.message);
                    gt(vn);
                  } else {
                    const vn = zo.value(Jt.message);
                    gt(vn);
                  }
                });
              });
            },
            validateOnLoad: !1
          }
        })).toArray(),
        _o.config({ disabled: () => !t.enabled || g.isDisabled() }),
        Zs.config({}),
        Go("urlinput-events", [
          It(Lf(), (Je) => {
            const Ge = vt(Je.element), Ft = Ge.trim();
            Ft !== Ge && Zf(Je.element, Ft), t.filetype === "file" && po(Je, wu, { name: t.name });
          }),
          It(ab(), (Je) => {
            po(Je, wu, { name: t.name }), x(Je);
          }),
          It(Om(), (Je) => {
            po(Je, wu, { name: t.name }), x(Je);
          })
        ])
      ]),
      eventOrder: {
        [Lf()]: [
          "streaming",
          "urlinput-events",
          "invalidating"
        ]
      },
      model: {
        getDisplayText: (Je) => Je.value,
        selectsOver: !1,
        populateFromBrowse: !1
      },
      markers: { openClass: "tox-textfield--popup-open" },
      lazySink: a.shared.getSink,
      parts: { menu: XC(!1, 1, "normal") },
      onExecute: (Je, Ge, Ft) => {
        po(Ge, _x, {});
      },
      onItemExecute: (Je, Ge, Ft, gt) => {
        x(Je), po(Je, wu, { name: t.name });
      }
    }, T = gs.parts.field({
      ...w,
      factory: wK
    }), A = t.label.map((Je) => ev(Je, g)), H = is(((Je, Ge, Ft = Je, gt = Je) => xu(Ft, {
      tag: "div",
      classes: [
        "tox-icon",
        "tox-control-wrap__status-icon-" + Je
      ],
      attributes: {
        title: g.translate(gt),
        "aria-live": "polite",
        ...Ge.fold(() => ({}), (Jt) => ({ id: Jt }))
      }
    }, g.icons))("invalid", B.some(LN), "warning")), q = is({
      dom: {
        tag: "div",
        classes: ["tox-control-wrap__status-icon-wrap"]
      },
      components: [H.asSpec()]
    }), ne = c.getUrlPicker(t.filetype), ie = Nn("browser.url.event"), fe = is({
      dom: {
        tag: "div",
        classes: ["tox-control-wrap"]
      },
      components: [
        T,
        q.asSpec()
      ],
      behaviours: Qt([_o.config({ disabled: () => !t.enabled || g.isDisabled() })])
    }), _e = is(L8({
      name: t.name,
      icon: B.some("browse"),
      text: t.picker_text.or(t.label).getOr(""),
      enabled: t.enabled,
      primary: !1,
      buttonType: B.none(),
      borderless: !0
    }, (Je) => tr(Je, ie), g, [], ["tox-browse-url"])), st = () => ({
      dom: {
        tag: "div",
        classes: ["tox-form__controls-h-stack"]
      },
      components: en([
        [fe.asSpec()],
        ne.map(() => _e.asSpec()).toArray()
      ])
    }), De = (Je) => {
      Nr.getCurrent(Je).each((Ge) => {
        const Ft = Mn.getValue(Ge), gt = {
          fieldname: t.name,
          ...Ft
        };
        ne.each((Jt) => {
          Jt(gt).get((vn) => {
            Mn.setValue(Ge, vn), po(Je, wu, { name: t.name });
          });
        });
      });
    };
    return gs.sketch({
      dom: SG(),
      components: A.toArray().concat([st()]),
      fieldBehaviours: Qt([
        _o.config({
          disabled: () => !t.enabled || g.isDisabled(),
          onDisabled: (Je) => {
            gs.getField(Je).each(_o.disable), _e.getOpt(Je).each(_o.disable);
          },
          onEnabled: (Je) => {
            gs.getField(Je).each(_o.enable), _e.getOpt(Je).each(_o.enable);
          }
        }),
        Si(),
        Go("url-input-events", [It(ie, De)])
      ])
    });
  }, MK = (t, a) => {
    const c = c$(t.icon, a.icons);
    return qm.sketch({
      dom: {
        tag: "div",
        attributes: { role: "alert" },
        classes: [
          "tox-notification",
          "tox-notification--in",
          `tox-notification--${t.level}`
        ]
      },
      components: [
        {
          dom: {
            tag: "div",
            classes: ["tox-notification__icon"],
            innerHtml: t.url ? void 0 : c
          },
          components: t.url ? [Rl.sketch({
            dom: {
              tag: "button",
              classes: [
                "tox-button",
                "tox-button--naked",
                "tox-button--icon"
              ],
              innerHtml: c,
              attributes: { title: a.translate(t.iconTooltip) }
            },
            action: (f) => po(f, ah, {
              name: "alert-banner",
              value: t.url
            }),
            buttonBehaviours: Qt([FD()])
          })] : void 0
        },
        {
          dom: {
            tag: "div",
            classes: ["tox-notification__body"],
            innerHtml: a.translate(t.text)
          }
        }
      ]
    });
  }, IK = (t, a) => {
    t.dom.checked = a;
  }, FK = (t) => t.dom.checked, U8 = (t, a, c) => {
    const f = (A) => (A.element.dom.click(), B.some(!0)), g = gs.parts.field({
      factory: { sketch: lt },
      dom: {
        tag: "input",
        classes: ["tox-checkbox__input"],
        attributes: { type: "checkbox" }
      },
      behaviours: Qt([
        ed.self(),
        _o.config({
          disabled: () => !t.enabled || a.isDisabled(),
          onDisabled: (A) => {
            Ui(A.element).each((F) => Us(F, "tox-checkbox--disabled"));
          },
          onEnabled: (A) => {
            Ui(A.element).each((F) => va(F, "tox-checkbox--disabled"));
          }
        }),
        Zs.config({}),
        Ao.config({}),
        W6(c, FK, IK),
        oo.config({
          mode: "special",
          onEnter: f,
          onSpace: f,
          stopSpaceKeyup: !0
        }),
        Go("checkbox-events", [It(ab(), (A, F) => {
          po(A, wu, { name: t.name });
        })])
      ])
    }), x = gs.parts.label({
      dom: {
        tag: "span",
        classes: ["tox-checkbox__label"]
      },
      components: [Oa(a.translate(t.label))],
      behaviours: Qt([Ex.config({})])
    }), w = (A) => xu(A === "checked" ? "selected" : "unselected", {
      tag: "span",
      classes: [
        "tox-icon",
        "tox-checkbox-icon__" + A
      ]
    }, a.icons), T = is({
      dom: {
        tag: "div",
        classes: ["tox-checkbox__icons"]
      },
      components: [
        w("checked"),
        w("unchecked")
      ]
    });
    return gs.sketch({
      dom: {
        tag: "label",
        classes: ["tox-checkbox"]
      },
      components: [
        g,
        T.asSpec(),
        x
      ],
      fieldBehaviours: Qt([
        _o.config({ disabled: () => !t.enabled || a.isDisabled() }),
        Si()
      ])
    });
  }, Xm = (t, a) => {
    const c = [
      "tox-form__group",
      ...t.stretched ? ["tox-form__group--stretched"] : []
    ], f = Go("htmlpanel", [Qs((g) => {
      t.onInit(g.element.dom);
    })]);
    return t.presets === "presentation" ? qm.sketch({
      dom: {
        tag: "div",
        classes: c,
        innerHtml: t.html
      },
      containerBehaviours: Qt([
        gl.config({
          ...a.tooltips.getConfig({
            tooltipText: "",
            onShow: (g) => {
              ss(g.element, "[data-mce-tooltip]:hover").orThunk(() => ic(g.element)).each((x) => {
                K(x, "data-mce-tooltip").each((w) => {
                  gl.setComponents(g, a.tooltips.getComponents({ tooltipText: w }));
                });
              });
            }
          }),
          mode: "children-normal",
          anchor: (g) => ({
            type: "node",
            node: ss(g.element, "[data-mce-tooltip]:hover").orThunk(() => ic(g.element).filter((x) => K(x, "data-mce-tooltip").isSome())),
            root: g.element,
            layouts: {
              onLtr: te([
                ti,
                Ci,
                di,
                fi,
                ei,
                xs
              ]),
              onRtl: te([
                ti,
                Ci,
                di,
                fi,
                ei,
                xs
              ])
            },
            bubble: _d(0, -2, {})
          })
        }),
        f
      ])
    }) : qm.sketch({
      dom: {
        tag: "div",
        classes: c,
        innerHtml: t.html,
        attributes: { role: "document" }
      },
      containerBehaviours: Qt([
        Zs.config({}),
        Ao.config({}),
        f
      ])
    });
  }, mi = (t) => (a, c, f, g, x) => Ht(c, "name").fold(() => t(c, g, B.none(), x), (w) => a.field(w, t(c, g, Ht(f, w), x))), BK = (t) => (a, c, f, g, x) => {
    const w = Fs(c, { source: "dynamic" });
    return mi(t)(a, w, f, g, x);
  }, $K = {
    bar: mi((t, a) => JT(t, a.shared)),
    collection: mi((t, a, c) => kG(t, a.shared.providers, c)),
    alertbanner: mi((t, a) => MK(t, a.shared.providers)),
    input: mi((t, a, c) => Xq(t, a.shared.providers, c)),
    textarea: mi((t, a, c) => y8(t, a.shared.providers, c)),
    label: mi((t, a, c, f) => Iq(t, a.shared, f)),
    iframe: BK((t, a, c) => Rq(t, a.shared.providers, c)),
    button: mi((t, a) => TK(t, a.shared.providers)),
    checkbox: mi((t, a, c) => U8(t, a.shared.providers, c)),
    colorinput: mi((t, a, c) => a6(t, a.shared, a.colorinput, c)),
    colorpicker: mi((t, a, c) => G6(t, a.shared.providers, c)),
    dropzone: mi((t, a, c) => kq(t, a.shared.providers, c)),
    grid: mi((t, a) => K6(t, a.shared)),
    listbox: mi((t, a, c) => zq(t, a, c)),
    selectbox: mi((t, a, c) => jq(t, a.shared.providers, c)),
    sizeinput: mi((t, a) => Kq(t, a.shared.providers)),
    slider: mi((t, a, c) => b8(t, a.shared.providers, c)),
    urlinput: mi((t, a, c) => NK(t, a, a.urlinput, c)),
    customeditor: mi(Cq),
    htmlpanel: mi((t, a) => Xm(t, a.shared.providers)),
    imagepreview: mi((t, a, c) => vN(t, c)),
    table: mi((t, a) => Yq(t, a.shared.providers)),
    tree: mi((t, a) => fK(t, a)),
    panel: mi((t, a) => _N(t, a))
  }, LK = {
    field: (t, a) => a,
    record: te([])
  }, W8 = (t, a, c, f, g) => {
    const x = Fs(f, { shared: { interpreter: (w) => HN(t, w, c, x, g) } });
    return HN(t, a, c, x, g);
  }, HN = (t, a, c, f, g) => Ht($K, a.type).fold(() => (console.error(`Unknown factory type "${a.type}", defaulting to container: `, a), a), (x) => x(t, a, c, f, g)), zN = (t, a, c, f) => HN(LK, t, a, c, f), Mg = "layout-inset", Z8 = (t) => t.x, HK = (t, a) => t.x + t.width / 2 - a.width / 2, bl = (t, a) => t.x + t.width - a.width, RS = (t) => t.y, VN = (t, a) => t.y + t.height - a.height, NS = (t, a) => t.y + t.height / 2 - a.height / 2, DO = (t, a, c) => Ji(bl(t, a), VN(t, a), c.insetSouthwest(), C2(), "southwest", el(t, {
    right: 0,
    bottom: 3
  }), Mg), RO = (t, a, c) => Ji(Z8(t), VN(t, a), c.insetSoutheast(), w2(), "southeast", el(t, {
    left: 1,
    bottom: 3
  }), Mg), MS = (t, a, c) => Ji(bl(t, a), RS(t), c.insetNorthwest(), x2(), "northwest", el(t, {
    right: 0,
    top: 2
  }), Mg), IS = (t, a, c) => Ji(Z8(t), RS(t), c.insetNortheast(), kb(), "northeast", el(t, {
    left: 1,
    top: 2
  }), Mg), cm = (t, a, c) => Ji(HK(t, a), RS(t), c.insetNorth(), S2(), "north", el(t, { top: 2 }), Mg), FS = (t, a, c) => Ji(HK(t, a), VN(t, a), c.insetSouth(), Bn(), "south", el(t, { bottom: 3 }), Mg), G8 = (t, a, c) => Ji(bl(t, a), NS(t, a), c.insetEast(), k2(), "east", el(t, { right: 0 }), Mg), q8 = (t, a, c) => Ji(Z8(t), NS(t, a), c.insetWest(), Xv(), "west", el(t, { left: 1 }), Mg), K8 = (t) => {
    switch (t) {
      case "north":
        return cm;
      case "northeast":
        return IS;
      case "northwest":
        return MS;
      case "south":
        return FS;
      case "southeast":
        return RO;
      case "southwest":
        return DO;
      case "east":
        return G8;
      case "west":
        return q8;
    }
  }, BS = (t, a, c, f, g) => F_(f).map(K8).getOr(cm)(t, a, c, f, g), Y8 = (t) => {
    switch (t) {
      case "north":
        return FS;
      case "northeast":
        return RO;
      case "northwest":
        return DO;
      case "south":
        return cm;
      case "southeast":
        return IS;
      case "southwest":
        return MS;
      case "east":
        return q8;
      case "west":
        return G8;
    }
  }, X8 = (t, a, c, f, g) => F_(f).map(Y8).getOr(cm)(t, a, c, f, g), $S = {
    valignCentre: [],
    alignCentre: [],
    alignLeft: [],
    alignRight: [],
    right: [],
    left: [],
    bottom: [],
    top: []
  }, Q8 = (t, a, c) => {
    const g = { maxHeightFunction: Eb() }, x = () => ({
      type: "node",
      root: Ae(le(t())),
      node: B.from(t()),
      bubble: _d(12, 12, $S),
      layouts: {
        onRtl: () => [IS],
        onLtr: () => [MS]
      },
      overrides: g
    }), w = () => ({
      type: "hotspot",
      hotspot: a(),
      bubble: _d(-12, 12, $S),
      layouts: {
        onRtl: () => [
          di,
          ei,
          ti
        ],
        onLtr: () => [
          ei,
          di,
          ti
        ]
      },
      overrides: g
    });
    return () => c() ? x() : w();
  }, zK = (t, a, c, f) => {
    const x = { maxHeightFunction: Eb() }, w = () => ({
      type: "node",
      root: Ae(le(a())),
      node: B.from(a()),
      bubble: _d(12, 12, $S),
      layouts: {
        onRtl: () => [cm],
        onLtr: () => [cm]
      },
      overrides: x
    }), T = () => t ? {
      type: "node",
      root: Ae(le(a())),
      node: B.from(a()),
      bubble: _d(0, -ud(a()), $S),
      layouts: {
        onRtl: () => [Ci],
        onLtr: () => [Ci]
      },
      overrides: x
    } : {
      type: "hotspot",
      hotspot: c(),
      bubble: _d(0, 0, $S),
      layouts: {
        onRtl: () => [Ci],
        onLtr: () => [Ci]
      },
      overrides: x
    };
    return () => f() ? w() : T();
  }, VK = (t, a, c) => {
    const f = () => ({
      type: "node",
      root: Ae(le(t())),
      node: B.from(t()),
      layouts: {
        onRtl: () => [cm],
        onLtr: () => [cm]
      }
    }), g = () => ({
      type: "hotspot",
      hotspot: a(),
      layouts: {
        onRtl: () => [ti],
        onLtr: () => [ti]
      }
    });
    return () => c() ? f() : g();
  }, J8 = (t, a) => () => ({
    type: "selection",
    root: a(),
    getSelection: () => {
      const c = t.selection.getRng(), f = t.model.table.getSelectedCells();
      if (f.length > 1) {
        const g = f[0], x = f[f.length - 1], w = {
          firstCell: He.fromDom(g),
          lastCell: He.fromDom(x)
        };
        return B.some(w);
      }
      return B.some(Pb.range(He.fromDom(c.startContainer), c.startOffset, He.fromDom(c.endContainer), c.endOffset));
    }
  }), zae = (t) => (a) => ({
    type: "node",
    root: t(),
    node: a
  }), Vae = (t, a, c, f) => {
    const g = ux(t), x = () => He.fromDom(t.getBody()), w = () => He.fromDom(t.getContentAreaContainer()), T = () => g || !f();
    return {
      inlineDialog: Q8(w, a, T),
      inlineBottomDialog: zK(t.inline, w, c, T),
      banner: VK(w, a, T),
      cursor: J8(t, x),
      node: zae(x)
    };
  }, jK = (t) => (a, c) => {
    PL(t)(a, c);
  }, UK = (t) => () => wL(t), WK = (t) => (a) => ZT(t, a), e7 = (t) => (a) => xL(t, a), jN = (t) => ({
    colorPicker: jK(t),
    hasCustomColors: UK(t),
    getColors: WK(t),
    getColorCols: e7(t)
  }), ZK = (t) => () => UB(t), GK = (t) => ({ isDraggableModal: ZK(t) }), t7 = (t) => {
    const a = no(_g(t) ? "bottom" : "top");
    return {
      isPositionedAtTop: () => a.get() === "top",
      getDockingMode: a.get,
      setDockingMode: a.set
    };
  }, n7 = (t) => As(t, "items"), o7 = (t) => As(t, "format"), r7 = [
    {
      title: "Headings",
      items: [
        {
          title: "Heading 1",
          format: "h1"
        },
        {
          title: "Heading 2",
          format: "h2"
        },
        {
          title: "Heading 3",
          format: "h3"
        },
        {
          title: "Heading 4",
          format: "h4"
        },
        {
          title: "Heading 5",
          format: "h5"
        },
        {
          title: "Heading 6",
          format: "h6"
        }
      ]
    },
    {
      title: "Inline",
      items: [
        {
          title: "Bold",
          format: "bold"
        },
        {
          title: "Italic",
          format: "italic"
        },
        {
          title: "Underline",
          format: "underline"
        },
        {
          title: "Strikethrough",
          format: "strikethrough"
        },
        {
          title: "Superscript",
          format: "superscript"
        },
        {
          title: "Subscript",
          format: "subscript"
        },
        {
          title: "Code",
          format: "code"
        }
      ]
    },
    {
      title: "Blocks",
      items: [
        {
          title: "Paragraph",
          format: "p"
        },
        {
          title: "Blockquote",
          format: "blockquote"
        },
        {
          title: "Div",
          format: "div"
        },
        {
          title: "Pre",
          format: "pre"
        }
      ]
    },
    {
      title: "Align",
      items: [
        {
          title: "Left",
          format: "alignleft"
        },
        {
          title: "Center",
          format: "aligncenter"
        },
        {
          title: "Right",
          format: "alignright"
        },
        {
          title: "Justify",
          format: "alignjustify"
        }
      ]
    }
  ], qK = (t) => Ho(t, "items"), UN = (t) => Ho(t, "block"), s7 = (t) => Ho(t, "inline"), KK = (t) => Ho(t, "selector"), a7 = (t) => Mt(t, (a, c) => {
    if (qK(c)) {
      const f = a7(c.items);
      return {
        customFormats: a.customFormats.concat(f.customFormats),
        formats: a.formats.concat([{
          title: c.title,
          items: f.formats
        }])
      };
    } else if (s7(c) || UN(c) || KK(c)) {
      const g = `custom-${_(c.name) ? c.name : c.title.toLowerCase()}`;
      return {
        customFormats: a.customFormats.concat([{
          name: g,
          format: c
        }]),
        formats: a.formats.concat([{
          title: c.title,
          format: g,
          icon: c.icon
        }])
      };
    } else
      return {
        ...a,
        formats: a.formats.concat(c)
      };
  }, {
    customFormats: [],
    formats: []
  }), YK = (t, a) => {
    const c = a7(a), f = (g) => {
      mt(g, (x) => {
        t.formatter.has(x.name) || t.formatter.register(x.name, x.format);
      });
    };
    return t.formatter ? f(c.customFormats) : t.on("init", () => {
      f(c.customFormats);
    }), c.formats;
  }, i7 = (t) => IB(t).map((a) => {
    const c = YK(t, a);
    return FB(t) ? r7.concat(c) : c;
  }).getOr(r7), l7 = (t) => {
    const a = Qo(t);
    return a.length === 1 && jt(a, "title");
  }, c7 = (t, a, c) => ({
    ...t,
    type: "formatter",
    isSelected: a(t.format),
    getStylePreview: c(t.format)
  }), LS = (t, a, c, f) => {
    const g = (A) => c7(A, c, f), x = (A) => {
      const F = T(A.items);
      return {
        ...A,
        type: "submenu",
        getStyleItems: te(F)
      };
    }, w = (A) => {
      const F = _(A.name) ? A.name : Nn(A.title), H = `custom-${F}`, q = {
        ...A,
        type: "formatter",
        format: H,
        isSelected: c(H),
        getStylePreview: f(H)
      };
      return t.formatter.register(F, q), q;
    }, T = (A) => tt(A, (F) => n7(F) ? x(F) : o7(F) ? g(F) : l7(F) ? {
      ...F,
      type: "separator"
    } : w(F));
    return T(a);
  }, XK = (t) => {
    const a = (T) => () => t.formatter.match(T), c = (T) => () => {
      const A = t.formatter.get(T);
      return A !== void 0 ? B.some({
        tag: A.length > 0 && (A[0].inline || A[0].block) || "div",
        styles: t.dom.parseStyle(t.formatter.getCssText(T))
      }) : B.none();
    }, f = no([]), g = no([]), x = no(!1);
    return t.on("PreInit", (T) => {
      const A = i7(t), F = LS(t, A, a, c);
      f.set(F);
    }), t.on("addStyleModifications", (T) => {
      const A = LS(t, T.items, a, c);
      g.set(A), x.set(T.replace);
    }), { getData: () => {
      const T = x.get() ? [] : f.get(), A = g.get();
      return T.concat(A);
    } };
  }, NO = (t) => {
    let f = 0;
    const g = () => f > 0, x = (T) => [{
      dom: {
        tag: "div",
        classes: ["tox-tooltip__body"]
      },
      components: [Oa(T.tooltipText)]
    }];
    return {
      getConfig: (T) => ({
        delayForShow: () => g() ? 60 : 300,
        delayForHide: te(300),
        exclusive: !0,
        lazySink: t,
        tooltipDom: {
          tag: "div",
          classes: [
            "tox-tooltip",
            "tox-tooltip--up"
          ]
        },
        tooltipComponents: x(T),
        onShow: (A, F) => {
          f++, T.onShow && T.onShow(A, F);
        },
        onHide: (A, F) => {
          f--, T.onHide && T.onHide(A, F);
        }
      }),
      getComponents: x
    };
  }, QK = (t) => Ce(t) && t.nodeType === 1, WN = im.trim, Bx = (t) => (a) => !!(QK(a) && (a.contentEditable === t || a.getAttribute("data-mce-contenteditable") === t)), u7 = Bx("true"), JK = Bx("false"), ZN = (t, a, c, f, g) => ({
    type: t,
    title: a,
    url: c,
    level: f,
    attach: g
  }), d7 = (t) => {
    let a = t;
    for (; a = a.parentNode; ) {
      const c = a.contentEditable;
      if (c && c !== "inherit")
        return u7(a);
    }
    return !1;
  }, f7 = (t, a) => tt(Dl(He.fromDom(a), t), (c) => c.dom), m7 = (t) => t.innerText || t.textContent, GN = (t) => t.id ? t.id : Nn("h"), MO = (t) => t && t.nodeName === "A" && (t.id || t.name) !== void 0, eY = (t) => MO(t) && e0(t), p7 = (t) => t && /^(H[1-6])$/.test(t.nodeName), e0 = (t) => d7(t) && !JK(t), h7 = (t) => p7(t) && e0(t), tY = (t) => p7(t) ? parseInt(t.nodeName.substr(1), 10) : 0, g7 = (t) => {
    var a;
    const c = GN(t), f = () => {
      t.id = c;
    };
    return ZN("header", (a = m7(t)) !== null && a !== void 0 ? a : "", "#" + c, tY(t), f);
  }, qN = (t) => {
    const a = t.id || t.name, c = m7(t);
    return ZN("anchor", c || "#" + a, "#" + a, 0, G);
  }, KN = (t) => tt(To(t, h7), g7), nY = (t) => tt(To(t, eY), qN), oY = (t) => f7("h1,h2,h3,h4,h5,h6,a:not([href])", t), rY = (t) => WN(t.title).length > 0, sY = { find: (t) => {
    const a = oY(t);
    return To(KN(a).concat(nY(a)), rY);
  } }, IO = "tinymce-url-history", v7 = 5, y7 = (t) => _(t) && /^https?/.test(t), aY = (t) => W(t) && t.length <= v7 && jn(t, y7), x7 = (t) => D(t) && Zo(t, (a) => !aY(a)).isNone(), w7 = () => {
    const t = z1.getItem(IO);
    if (t === null)
      return {};
    let a;
    try {
      a = JSON.parse(t);
    } catch (c) {
      if (c instanceof SyntaxError)
        return console.log("Local storage " + IO + " was not valid JSON", c), {};
      throw c;
    }
    return x7(a) ? a : (console.log("Local storage " + IO + " was not valid format", a), {});
  }, C7 = (t) => {
    if (!x7(t))
      throw new Error(`Bad format for history:
` + JSON.stringify(t));
    z1.setItem(IO, JSON.stringify(t));
  }, iY = (t) => {
    const a = w7();
    return Ht(a, t).getOr([]);
  }, HS = (t, a) => {
    if (!y7(t))
      return;
    const c = w7(), f = Ht(c, a).getOr([]), g = To(f, (x) => x !== t);
    c[a] = [t].concat(g).slice(0, v7), C7(c);
  }, S7 = (t) => !!t, lY = (t) => kt(im.makeMap(t, /[, ]/), S7), zS = (t) => B.from(zB(t)), k7 = (t) => {
    const a = B.from(fD(t)).filter(S7).map(lY);
    return zS(t).fold(wt, (c) => a.fold(qe, (f) => Qo(f).length > 0 ? f : !1));
  }, cY = (t, a) => {
    const c = k7(t);
    return J(c) ? c ? zS(t) : B.none() : c[a] ? zS(t) : B.none();
  }, uY = (t, a) => cY(t, a).map((c) => (f) => jl.nu((g) => {
    const x = (T, A) => {
      if (!_(T))
        throw new Error("Expected value to be string");
      if (A !== void 0 && !D(A))
        throw new Error("Expected meta to be a object");
      g({
        value: T,
        meta: A
      });
    }, w = {
      filetype: a,
      fieldname: f.fieldname,
      ...B.from(f.meta).getOr({})
    };
    c.call(t, x, f.value, w);
  })), _7 = (t) => B.from(t).filter(_).getOrUndefined(), dY = (t) => VB(t) ? B.some({
    targets: sY.find(t.getBody()),
    anchorTop: _7(eT(t)),
    anchorBottom: _7(jB(t))
  }) : B.none(), fY = (t) => B.from(JE(t)), mY = (t) => ({
    getHistory: iY,
    addToHistory: HS,
    getLinkInformation: () => dY(t),
    getValidationHandler: () => fY(t),
    getUrlPicker: (a) => uY(t, a)
  }), pY = (t, a, c, f) => {
    const g = no(!1), x = t7(a), w = {
      icons: () => a.ui.registry.getAll().icons,
      menuItems: () => a.ui.registry.getAll().menuItems,
      translate: Ad.translate,
      isDisabled: () => a.mode.isReadOnly() || !a.ui.isEnabled(),
      getOption: a.options.get,
      tooltips: NO(t.dialog)
    }, T = mY(a), A = XK(a), F = jN(a), H = GK(a), q = () => g.get(), ne = (De) => g.set(De), ie = {
      shared: {
        providers: w,
        anchors: Vae(a, c, f, x.isPositionedAtTop),
        header: x
      },
      urlinput: T,
      styles: A,
      colorinput: F,
      dialog: H,
      isContextMenuOpen: q,
      setContextMenuState: ne
    }, fe = (De) => B.none(), _e = {
      ...ie,
      shared: {
        ...ie.shared,
        interpreter: (De) => zN(De, {}, _e, fe),
        getSink: t.popup
      }
    }, st = {
      ...ie,
      shared: {
        ...ie.shared,
        interpreter: (De) => zN(De, {}, st, fe),
        getSink: t.dialog
      }
    };
    return {
      popup: _e,
      dialog: st
    };
  }, hY = (t, a, c) => {
    const f = (Nt, Yn) => {
      mt([
        a,
        ...c
      ], (In) => {
        In.broadcastEvent(Nt, Yn);
      });
    }, g = (Nt, Yn) => {
      mt([
        a,
        ...c
      ], (In) => {
        In.broadcastOn([Nt], Yn);
      });
    }, x = (Nt) => g(Kf(), { target: Nt.target }), w = Ql(), T = lc(w, "touchstart", x), A = lc(w, "touchmove", (Nt) => f(Mv(), Nt)), F = lc(w, "touchend", (Nt) => f(Bw(), Nt)), H = lc(w, "mousedown", x), q = lc(w, "mouseup", (Nt) => {
      Nt.raw.button === 0 && g(l1(), { target: Nt.target });
    }), ne = (Nt) => g(Kf(), { target: He.fromDom(Nt.target) }), ie = (Nt) => {
      Nt.button === 0 && g(l1(), { target: He.fromDom(Nt.target) });
    }, fe = () => {
      mt(t.editorManager.get(), (Nt) => {
        t !== Nt && Nt.dispatch("DismissPopups", { relatedTarget: t });
      });
    }, _e = (Nt) => f(jh(), I2(Nt)), st = (Nt) => {
      g(bg(), {}), f(tf(), I2(Nt));
    }, De = le(He.fromDom(t.getElement())), Je = M2(De, "scroll", (Nt) => {
      requestAnimationFrame(() => {
        const Yn = t.getContainer();
        if (Yn != null) {
          const xo = Eg(t, a.element).map((fo) => [
            fo.element,
            ...fo.others
          ]).getOr([]);
          Fn(xo, (fo) => Lr(fo, Nt.target)) && (t.dispatch("ElementScroll", { target: Nt.target.dom }), f(jk(), Nt));
        }
      });
    }), Ge = () => g(bg(), {}), Ft = (Nt) => {
      Nt.state && g(Kf(), { target: He.fromDom(t.getContainer()) });
    }, gt = (Nt) => {
      g(Kf(), { target: He.fromDom(Nt.relatedTarget.getContainer()) });
    }, Jt = (Nt) => t.dispatch("focusin", Nt), vn = (Nt) => t.dispatch("focusout", Nt);
    t.on("PostRender", () => {
      t.on("click", ne), t.on("tap", ne), t.on("mouseup", ie), t.on("mousedown", fe), t.on("ScrollWindow", _e), t.on("ResizeWindow", st), t.on("ResizeEditor", Ge), t.on("AfterProgressState", Ft), t.on("DismissPopups", gt), mt([
        a,
        ...c
      ], (Nt) => {
        Nt.element.dom.addEventListener("focusin", Jt), Nt.element.dom.addEventListener("focusout", vn);
      });
    }), t.on("remove", () => {
      t.off("click", ne), t.off("tap", ne), t.off("mouseup", ie), t.off("mousedown", fe), t.off("ScrollWindow", _e), t.off("ResizeWindow", st), t.off("ResizeEditor", Ge), t.off("AfterProgressState", Ft), t.off("DismissPopups", gt), mt([
        a,
        ...c
      ], (Nt) => {
        Nt.element.dom.removeEventListener("focusin", Jt), Nt.element.dom.removeEventListener("focusout", vn);
      }), H.unbind(), T.unbind(), A.unbind(), F.unbind(), q.unbind(), Je.unbind();
    }), t.on("detach", () => {
      mt([
        a,
        ...c
      ], aC), mt([
        a,
        ...c
      ], (Nt) => Nt.destroy());
    });
  }, ol = OE, Ig = SE, gY = te([
    Qe("shell", !1),
    Rt("makeItem"),
    Qe("setupItem", G),
    Zu.field("listBehaviours", [No])
  ]), E7 = yu({
    name: "items",
    overrides: () => ({ behaviours: Qt([No.config({})]) })
  }), FO = te([E7]), T7 = te("CustomList"), vY = (t, a, c, f) => {
    const g = (T, A) => {
      w(T).fold(() => {
        throw console.error("Custom List was defined to not be a shell, but no item container was specified in components"), new Error("Custom List was defined to not be a shell, but no item container was specified in components");
      }, (F) => {
        const H = No.contents(F), q = A.length, ne = q - H.length, ie = ne > 0 ? St(ne, () => t.makeItem()) : [], fe = H.slice(q);
        mt(fe, (st) => No.remove(F, st)), mt(ie, (st) => No.append(F, st));
        const _e = No.contents(F);
        mt(_e, (st, De) => {
          t.setupItem(T, st, A[De], De);
        });
      });
    }, x = t.shell ? {
      behaviours: [No.config({})],
      components: []
    } : {
      behaviours: [],
      components: a
    }, w = (T) => t.shell ? B.some(T) : Xt(T, t, "items");
    return {
      uid: t.uid,
      dom: t.dom,
      components: x.components,
      behaviours: Li(t.listBehaviours, x.behaviours),
      apis: { setItems: g }
    };
  }, O7 = Vl({
    name: T7(),
    configFields: gY(),
    partFields: FO(),
    factory: vY,
    apis: {
      setItems: (t, a, c) => {
        t.setItems(a, c);
      }
    }
  }), $x = te([
    Rt("dom"),
    Qe("shell", !0),
    $i("toolbarBehaviours", [No])
  ]), yY = te([yu({
    name: "groups",
    overrides: () => ({ behaviours: Qt([No.config({})]) })
  })]), xY = (t, a, c, f) => {
    const g = (T, A) => {
      x(T).fold(() => {
        throw console.error("Toolbar was defined to not be a shell, but no groups container was specified in components"), new Error("Toolbar was defined to not be a shell, but no groups container was specified in components");
      }, (F) => {
        No.set(F, A);
      });
    }, x = (T) => t.shell ? B.some(T) : Xt(T, t, "groups"), w = t.shell ? {
      behaviours: [No.config({})],
      components: []
    } : {
      behaviours: [],
      components: a
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: w.components,
      behaviours: Li(t.toolbarBehaviours, w.behaviours),
      apis: {
        setGroups: g,
        refresh: G
      },
      domModification: { attributes: { role: "group" } }
    };
  }, Qm = Vl({
    name: "Toolbar",
    configFields: $x(),
    partFields: yY(),
    factory: xY,
    apis: {
      setGroups: (t, a, c) => {
        t.setGroups(a, c);
      }
    }
  }), A7 = G, P7 = wt, D7 = te([]);
  var R7 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setup: A7,
    isDocked: P7,
    getBehaviours: D7
  });
  const YN = te(Nn("toolbar-height-change")), dh = {
    fadeInClass: "tox-editor-dock-fadein",
    fadeOutClass: "tox-editor-dock-fadeout",
    transitionClass: "tox-editor-dock-transition"
  }, N7 = "tox-tinymce--toolbar-sticky-on", rv = "tox-tinymce--toolbar-sticky-off", M7 = (t, a) => {
    const c = ii(a), g = cl(a).dom.innerHeight, x = wi(c), w = He.fromDom(t.elm), T = Cl(w), A = Bs(w), F = T.y, H = F + A, q = Ga(a), ne = Bs(a), ie = q.top, fe = ie + ne, _e = Math.abs(ie - x.top) < 2, st = Math.abs(fe - (x.top + g)) < 2;
    if (_e && F < fe)
      cp(x.left, F - ne, c);
    else if (st && H > ie) {
      const De = F - g + A + ne;
      cp(x.left, De, c);
    }
  }, sv = (t, a) => jt(pa.getModes(t), a), Lx = (t) => {
    const a = (f) => ud(f) + (parseInt(fs(f, "margin-top"), 10) || 0) + (parseInt(fs(f, "margin-bottom"), 10) || 0), c = t.element;
    Ui(c).each((f) => {
      const g = "padding-" + pa.getModes(t)[0];
      if (pa.isDocked(t)) {
        const x = Pi(f);
        Ln(c, "width", x + "px"), Ln(f, g, a(c) + "px");
      } else
        xr(c, "width"), xr(f, g);
    });
  }, XN = (t, a) => {
    a ? (va(t, dh.fadeOutClass), ub(t, [
      dh.transitionClass,
      dh.fadeInClass
    ])) : (va(t, dh.fadeInClass), ub(t, [
      dh.fadeOutClass,
      dh.transitionClass
    ]));
  }, QN = (t, a) => {
    const c = He.fromDom(t.getContainer());
    a ? (Us(c, N7), va(c, rv)) : (Us(c, rv), va(c, N7));
  }, I7 = (t, a) => {
    const c = ii(a);
    uf(c).filter((f) => !Lr(a, f)).filter((f) => Lr(f, He.fromDom(c.dom.body)) || ka(t, f)).each(() => mu(a));
  }, Uae = (t, a) => ic(t).orThunk(() => a().toOptional().bind((c) => ic(c.element))), wY = (t, a, c) => {
    t.inline || (a.header.isPositionedAtTop() || t.on("ResizeEditor", () => {
      c().each(pa.reset);
    }), t.on("ResizeWindow ResizeEditor", () => {
      c().each(Lx);
    }), t.on("SkinLoaded", () => {
      c().each((f) => {
        pa.isDocked(f) ? pa.reset(f) : pa.refresh(f);
      });
    }), t.on("FullscreenStateChanged", () => {
      c().each(pa.reset);
    })), t.on("AfterScrollIntoView", (f) => {
      c().each((g) => {
        pa.refresh(g);
        const x = g.element;
        PF(x) && M7(f, x);
      });
    }), t.on("PostRender", () => {
      QN(t, !1);
    });
  }, CY = (t) => t().map(pa.isDocked).getOr(!1), SY = () => [Ac.config({ channels: { [YN()]: { onReceive: Lx } } })], F7 = (t, a) => {
    const c = ms(), f = a.getSink, g = (T) => {
      f().each((A) => T(A.element));
    }, x = (T) => {
      t.inline || Lx(T), QN(t, pa.isDocked(T)), T.getSystem().broadcastOn([bg()], {}), f().each((A) => A.getSystem().broadcastOn([bg()], {}));
    }, w = t.inline ? [] : SY();
    return [
      Ao.config({}),
      pa.config({
        contextual: {
          lazyContext: (T) => {
            const A = ud(T.element), F = t.inline ? t.getContentAreaContainer() : t.getContainer();
            return B.from(F).map((H) => {
              const q = aa(He.fromDom(H));
              return Eg(t, T.element).fold(() => {
                const ie = q.height - A, fe = q.y + (sv(T, "top") ? 0 : A);
                return Is(q.x, fe, q.width, ie);
              }, (ie) => {
                const fe = Ih(q, D1(ie)), _e = sv(T, "top") ? fe.y : fe.y + A;
                return Is(fe.x, _e, fe.width, fe.height - A);
              });
            });
          },
          onShow: () => {
            g((T) => XN(T, !0));
          },
          onShown: (T) => {
            g((A) => Gc(A, [
              dh.transitionClass,
              dh.fadeInClass
            ])), c.get().each((A) => {
              I7(T.element, A), c.clear();
            });
          },
          onHide: (T) => {
            Uae(T.element, f).fold(c.clear, c.set), g((A) => XN(A, !1));
          },
          onHidden: () => {
            g((T) => Gc(T, [dh.transitionClass]));
          },
          ...dh
        },
        lazyViewport: (T) => Eg(t, T.element).fold(() => {
          const F = Ra(), H = HB(t), q = F.y + (sv(T, "top") ? H : 0), ne = F.height - (sv(T, "bottom") ? H : 0);
          return {
            bounds: Is(F.x, q, F.width, ne),
            optScrollEnv: B.none()
          };
        }, (F) => ({
          bounds: D1(F),
          optScrollEnv: B.some({
            currentScrollTop: F.element.dom.scrollTop,
            scrollElmTop: Ga(F.element).top
          })
        })),
        modes: [a.header.getDockingMode()],
        onDocked: x,
        onUndocked: x
      }),
      ...w
    ];
  };
  var kY = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setup: wY,
    isDocked: CY,
    getBehaviours: F7
  });
  const Hx = (t) => {
    const a = t.editor, c = t.sticky ? F7 : D7;
    return {
      uid: t.uid,
      dom: t.dom,
      components: t.components,
      behaviours: Qt(c(a, t.sharedBackstage))
    };
  }, VS = wo([
    oi,
    Vr("items", vp([
      Tv([
        ST,
        Ec("items", On)
      ]),
      On
    ]))
  ].concat(oS)), JN = (t) => ia("GroupToolbarButton", VS, t), _Y = [
    ja("text"),
    ja("tooltip"),
    ja("icon"),
    Vc("search", !1, vp([
      kc,
      wo([ja("placeholder")])
    ], (t) => J(t) ? t ? B.some({ placeholder: B.none() }) : B.none() : B.some(t))),
    _c("fetch"),
    Ca("onSetup", () => G)
  ], B7 = wo([
    oi,
    ..._Y
  ]), BO = (t) => ia("menubutton", B7, t), EY = wo([
    oi,
    tS,
    pf,
    Jb,
    R$,
    OW,
    Qb,
    fu("presets", "normal", [
      "normal",
      "color",
      "listpreview"
    ]),
    OT(1),
    px,
    JD
  ]), jS = (t) => ia("SplitButton", EY, t);
  var eM = Pc({
    factory: (t, a) => {
      const c = (g, x) => {
        const w = tt(x, (T) => {
          const A = {
            type: "menubutton",
            text: T.text,
            fetch: (H) => {
              H(T.getItems());
            }
          }, F = BO(A).mapError((H) => Bu(H)).getOrDie();
          return PS(F, "tox-mbtn", a.backstage, B.some("menuitem"));
        });
        No.set(g, w);
      }, f = {
        focus: oo.focusIn,
        setMenus: c
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: [],
        behaviours: Qt([
          No.config({}),
          Go("menubar-events", [
            Qs((g) => {
              t.onSetup(g);
            }),
            It(Bf(), (g, x) => {
              ss(g.element, ".tox-mbtn--active").each((w) => {
                cf(x.event.target, ".tox-mbtn").each((T) => {
                  Lr(w, T) || g.getSystem().getByDom(w).each((A) => {
                    g.getSystem().getByDom(T).each((F) => {
                      gf.expand(F), gf.close(A), Ao.focus(F);
                    });
                  });
                });
              });
            }),
            It(Uh(), (g, x) => {
              x.event.prevFocus.bind((w) => g.getSystem().getByDom(w).toOptional()).each((w) => {
                x.event.newFocus.bind((T) => g.getSystem().getByDom(T).toOptional()).each((T) => {
                  gf.isOpen(w) && (gf.expand(T), gf.close(w));
                });
              });
            })
          ]),
          oo.config({
            mode: "flow",
            selector: ".tox-mbtn",
            onEscape: (g) => (t.onEscape(g), B.some(!0))
          }),
          Zs.config({})
        ]),
        apis: f,
        domModification: { attributes: { role: "menubar" } }
      };
    },
    name: "silver.Menubar",
    configFields: [
      Rt("dom"),
      Rt("uid"),
      Rt("onEscape"),
      Rt("backstage"),
      Qe("onSetup", G)
    ],
    apis: {
      focus: (t, a) => {
        t.focus(a);
      },
      setMenus: (t, a, c) => {
        t.setMenus(a, c);
      }
    }
  });
  const OY = "Upgrade", AY = "https://www.tiny.cloud/tinymce-self-hosted-premium-features/?utm_campaign=self_hosted_upgrade_promo&utm_source=tiny&utm_medium=referral", PY = (t) => ({
    uid: t.uid,
    dom: t.dom,
    components: [{
      dom: {
        tag: "a",
        attributes: {
          href: AY,
          rel: "noopener",
          target: "_blank",
          "aria-hidden": "true"
        },
        classes: ["tox-promotion-link"],
        innerHtml: OY
      }
    }]
  }), $7 = "container", DY = [$i("slotBehaviours", [])], tM = (t) => "<alloy.field." + t + ">", L7 = (t) => {
    const a = (() => {
      const x = [];
      return {
        slot: (T, A) => (x.push(T), EE($7, tM(T), A)),
        record: te(x)
      };
    })(), c = t(a), f = a.record(), g = tt(f, (x) => hl({
      name: x,
      pname: tM(x)
    }));
    return zm($7, DY, g, nM, c);
  }, nM = (t, a) => {
    const c = (_e) => h1(t), f = (_e, st) => Xt(_e, t, st), g = (_e, st) => (De, Je) => Xt(De, t, Je).map((Ge) => _e(Ge, Je)).getOr(st), x = (_e) => (st, De) => {
      mt(De, (Je) => _e(st, Je));
    }, w = (_e, st) => os(_e.element, "aria-hidden") !== "true", T = (_e, st) => {
      if (!w(_e)) {
        const De = _e.element;
        xr(De, "display"), Ee(De, "aria-hidden"), po(_e, Lw(), {
          name: st,
          visible: !0
        });
      }
    }, A = (_e, st) => {
      if (w(_e)) {
        const De = _e.element;
        Ln(De, "display", "none"), rn(De, "aria-hidden", "true"), po(_e, Lw(), {
          name: st,
          visible: !1
        });
      }
    }, F = g(w, !1), H = g(A), q = x(H), ne = (_e) => q(_e, c()), ie = g(T), fe = {
      getSlotNames: c,
      getSlot: f,
      isShowing: F,
      hideSlot: H,
      hideAllSlots: ne,
      showSlot: ie
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      behaviours: d1(t.slotBehaviours),
      apis: fe
    };
  }, vl = {
    ...kt({
      getSlotNames: (t, a) => t.getSlotNames(a),
      getSlot: (t, a, c) => t.getSlot(a, c),
      isShowing: (t, a, c) => t.isShowing(a, c),
      hideSlot: (t, a, c) => t.hideSlot(a, c),
      hideAllSlots: (t, a) => t.hideAllSlots(a),
      showSlot: (t, a, c) => t.showSlot(a, c)
    }, (t) => wb(t)),
    sketch: L7
  }, $O = wo([
    pf,
    tS,
    Ca("onShow", G),
    Ca("onHide", G),
    Qb
  ]), H7 = (t) => ia("sidebar", $O, t), RY = (t) => {
    const { sidebars: a } = t.ui.registry.getAll();
    mt(Qo(a), (c) => {
      const f = a[c], g = () => ra(B.from(t.queryCommandValue("ToggleSidebar")), c);
      t.ui.registry.addToggleButton(c, {
        icon: f.icon,
        tooltip: f.tooltip,
        onAction: (x) => {
          t.execCommand("ToggleSidebar", !1, c), x.setActive(g());
        },
        onSetup: (x) => {
          x.setActive(g());
          const w = () => x.setActive(g());
          return t.on("ToggleSidebar", w), () => {
            t.off("ToggleSidebar", w);
          };
        }
      });
    });
  }, NY = (t) => ({ element: () => t.element.dom }), MY = (t, a) => {
    const c = tt(Qo(a), (f) => {
      const g = a[f], x = Zt(H7(g));
      return {
        name: f,
        getApi: NY,
        onSetup: x.onSetup,
        onShow: x.onShow,
        onHide: x.onHide
      };
    });
    return tt(c, (f) => {
      const g = no(G);
      return t.slot(f.name, {
        dom: {
          tag: "div",
          classes: ["tox-sidebar__pane"]
        },
        behaviours: hx.unnamedEvents([
          Ag(f, g),
          mc(f, g),
          It(Lw(), (x, w) => {
            const T = w.event;
            At(c, (F) => F.name === T.name).each((F) => {
              (T.visible ? F.onShow : F.onHide)(F.getApi(x));
            });
          })
        ])
      });
    });
  }, IY = (t) => vl.sketch((a) => ({
    dom: {
      tag: "div",
      classes: ["tox-sidebar__pane-container"]
    },
    components: MY(a, t),
    slotBehaviours: hx.unnamedEvents([Qs((c) => vl.hideAllSlots(c))])
  })), oM = (t, a, c) => {
    Nr.getCurrent(t).each((g) => {
      No.set(g, [IY(a)]);
      const x = c == null ? void 0 : c.toLowerCase();
      _(x) && Ho(a, x) && Nr.getCurrent(g).each((w) => {
        vl.showSlot(w, x), nu.immediateGrow(g), xr(g.element, "width"), zx(t.element, "region");
      });
    });
  }, zx = (t, a) => {
    rn(t, "role", a);
  }, FY = (t, a) => {
    Nr.getCurrent(t).each((f) => {
      Nr.getCurrent(f).each((x) => {
        nu.hasGrown(f) ? vl.isShowing(x, a) ? (nu.shrink(f), zx(t.element, "presentation")) : (vl.hideAllSlots(x), vl.showSlot(x, a), zx(t.element, "region")) : (vl.hideAllSlots(x), vl.showSlot(x, a), nu.grow(f), zx(t.element, "region"));
      });
    });
  }, rM = (t) => Nr.getCurrent(t).bind((c) => nu.isGrowing(c) || nu.hasGrown(c) ? Nr.getCurrent(c).bind((x) => At(vl.getSlotNames(x), (w) => vl.isShowing(x, w))) : B.none()), sM = Nn("FixSizeEvent"), aM = Nn("AutoSizeEvent"), BY = (t) => ({
    uid: t.uid,
    dom: {
      tag: "div",
      classes: ["tox-sidebar"],
      attributes: { role: "presentation" }
    },
    components: [{
      dom: {
        tag: "div",
        classes: ["tox-sidebar__slider"]
      },
      components: [],
      behaviours: Qt([
        Zs.config({}),
        Ao.config({}),
        nu.config({
          dimension: { property: "width" },
          closedClass: "tox-sidebar--sliding-closed",
          openClass: "tox-sidebar--sliding-open",
          shrinkingClass: "tox-sidebar--sliding-shrinking",
          growingClass: "tox-sidebar--sliding-growing",
          onShrunk: (a) => {
            Nr.getCurrent(a).each(vl.hideAllSlots), tr(a, aM);
          },
          onGrown: (a) => {
            tr(a, aM);
          },
          onStartGrow: (a) => {
            po(a, sM, { width: ks(a.element, "width").getOr("") });
          },
          onStartShrink: (a) => {
            po(a, sM, { width: Pi(a.element) + "px" });
          }
        }),
        No.config({}),
        Nr.config({
          find: (a) => {
            const c = No.contents(a);
            return so(c);
          }
        })
      ])
    }],
    behaviours: Qt([
      ed.childAt(0),
      Go("sidebar-sliding-events", [
        It(sM, (a, c) => {
          Ln(a.element, "width", c.event.width);
        }),
        It(aM, (a, c) => {
          xr(a.element, "width");
        })
      ])
    ])
  });
  var qae = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    block: (t, a, c, f) => {
      rn(t.element, "aria-busy", !0);
      const g = a.getRoot(t).getOr(t), x = Qt([
        oo.config({
          mode: "special",
          onTab: () => B.some(!0),
          onShiftTab: () => B.some(!0)
        }),
        Ao.config({})
      ]), w = f(g, x), T = g.getSystem().build(w);
      No.append(g, Ll(T)), T.hasConfigured(oo) && a.focus && oo.focusIn(T), c.isBlocked() || a.onBlock(t), c.blockWith(() => No.remove(g, T));
    },
    unblock: (t, a, c) => {
      Ee(t.element, "aria-busy"), c.isBlocked() && a.onUnblock(t), c.clear();
    },
    isBlocked: (t, a, c) => c.isBlocked()
  }), z7 = [
    Ca("getRoot", B.none),
    Ea("focus", !0),
    Rr("onBlock"),
    Rr("onUnblock")
  ], V7 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = Kg(), a = (c) => {
        t.set({ destroy: c });
      };
      return Wc({
        readState: t.isSet,
        blockWith: a,
        clear: t.clear,
        isBlocked: t.isSet
      });
    }
  });
  const Jm = Xi({
    fields: z7,
    name: "blocking",
    apis: qae,
    state: V7
  }), $Y = (t) => (a, c) => ({
    dom: {
      tag: "div",
      attributes: {
        "aria-label": t.translate("Loading..."),
        tabindex: "0"
      },
      classes: ["tox-throbber__busy-spinner"]
    },
    components: [{ dom: jm('<div class="tox-spinner"><div></div><div></div><div></div></div>') }]
  }), j7 = (t) => Nr.getCurrent(t).each((a) => mu(a.element, !0)), LY = (t, a) => {
    const c = "tabindex", f = `data-mce-${c}`;
    B.from(t.iframeElement).map(He.fromDom).each((g) => {
      a ? (K(g, c).each((x) => rn(g, f, x)), rn(g, c, -1)) : (Ee(g, c), K(g, f).each((x) => {
        rn(g, c, x), Ee(g, f);
      }));
    });
  }, HY = (t, a, c, f) => {
    const g = a.element;
    if (LY(t, c), c)
      Jm.block(a, $Y(f)), xr(g, "display"), Ee(g, "aria-hidden"), t.hasFocus() && j7(a);
    else {
      const x = Nr.getCurrent(a).exists((w) => Jv(w.element));
      Jm.unblock(a), Ln(g, "display", "none"), rn(g, "aria-hidden", "true"), x && t.focus();
    }
  }, U7 = (t) => ({
    uid: t.uid,
    dom: {
      tag: "div",
      attributes: { "aria-hidden": "true" },
      classes: ["tox-throbber"],
      styles: { display: "none" }
    },
    behaviours: Qt([
      No.config({}),
      Jm.config({ focus: !1 }),
      Nr.config({ find: (a) => so(a.components()) })
    ]),
    components: []
  }), zY = (t) => t.type === "focusin", VY = (t) => zY(t) ? (t.composed ? so(t.composedPath()) : B.from(t.target)).map(He.fromDom).filter(ko).exists((c) => Zc(c, "mce-pastebin")) : !1, jY = (t, a, c) => {
    const f = no(!1), g = ms(), x = (T) => {
      f.get() && !VY(T) && (T.preventDefault(), j7(a()), t.editorManager.setActive(t));
    };
    t.inline || t.on("PreInit", () => {
      t.dom.bind(t.getWin(), "focusin", x), t.on("BeforeExecCommand", (T) => {
        T.command.toLowerCase() === "mcefocus" && T.value !== !0 && x(T);
      });
    });
    const w = (T) => {
      T !== f.get() && (f.set(T), HY(t, a(), T, c.providers), sZ(t, T));
    };
    t.on("ProgressState", (T) => {
      if (g.on(clearTimeout), oe(T.time)) {
        const A = FC.setEditorTimeout(t, () => w(T.state), T.time);
        g.set(A);
      } else
        w(T.state), g.clear();
    });
  }, Yae = (t, a) => Mt(t, (g, x) => a(x, g.len).fold(te(g), (T) => ({
    len: T.finish,
    list: g.list.concat([T])
  })), {
    len: 0,
    list: []
  }).list, W7 = (t, a, c) => ({
    within: t,
    extra: a,
    withinWidth: c
  }), iM = (t, a, c) => {
    const f = Yae(t, (T, A) => {
      const F = c(T);
      return B.some({
        element: T,
        start: A,
        finish: A + F,
        width: F
      });
    }), g = To(f, (T) => T.finish <= a), x = Ot(g, (T, A) => T + A.width, 0), w = f.slice(g.length);
    return {
      within: g,
      extra: w,
      withinWidth: x
    };
  }, US = (t) => tt(t, (a) => a.element), UY = (t, a, c) => {
    const f = US(t.concat(a));
    return W7(f, [], c);
  }, WY = (t, a, c, f) => {
    const g = US(t).concat([c]);
    return W7(g, US(a), f);
  }, Rd = (t, a, c) => W7(US(t), [], c), ZY = (t, a, c) => {
    const f = iM(a, t, c);
    return f.extra.length === 0 ? B.some(f) : B.none();
  }, Z7 = (t, a, c, f) => {
    const g = ZY(t, a, c).getOrThunk(() => iM(a, t - c(f), c)), x = g.within, w = g.extra, T = g.withinWidth;
    return w.length === 1 && w[0].width <= c(f) ? UY(x, w, T) : w.length >= 1 ? WY(x, w, f, T) : Rd(x, w, T);
  }, lM = (t, a) => {
    const c = tt(a, (f) => Ll(f));
    Qm.setGroups(t, c);
  }, GY = (t) => Ko(t, (a) => ic(a.element).bind((c) => a.getSystem().getByDom(c).toOptional())), Vx = (t, a, c) => {
    const f = a.builtGroups.get();
    if (f.length === 0)
      return;
    const g = uc(t, a, "primary"), x = Ia.getCoupled(t, "overflowGroup");
    Ln(g.element, "visibility", "hidden");
    const w = f.concat([x]), T = GY(w);
    c([]), lM(g, w);
    const A = Pi(g.element), F = Z7(A, a.builtGroups.get(), (H) => Math.ceil(H.element.dom.getBoundingClientRect().width), x);
    F.extra.length === 0 ? (No.remove(g, x), c([])) : (lM(g, F.within), c(F.extra)), xr(g.element, "visibility"), yi(g.element), T.each(Ao.focus);
  }, G7 = te([
    $i("splitToolbarBehaviours", [Ia]),
    Wr("builtGroups", () => no([]))
  ]), LO = te([
    Uf(["overflowToggledClass"]),
    vd("getOverflowBounds"),
    Rt("lazySink"),
    Wr("overflowGroups", () => no([])),
    Rr("onOpened"),
    Rr("onClosed")
  ].concat(G7())), qY = te([
    hl({
      factory: Qm,
      schema: $x(),
      name: "primary"
    }),
    Gu({
      schema: $x(),
      name: "overflow"
    }),
    Gu({ name: "overflow-button" }),
    Gu({ name: "overflow-group" })
  ]), jx = te((t, a) => {
    pe(t, Math.floor(a));
  }), KY = te([
    Uf(["toggledClass"]),
    Rt("lazySink"),
    _c("fetch"),
    vd("getBounds"),
    Es("fireDismissalEventInstead", [Qe("event", _p())]),
    jp(),
    Rr("onToggled")
  ]), YY = te([
    Gu({
      name: "button",
      overrides: (t) => ({
        dom: { attributes: { "aria-haspopup": "true" } },
        buttonBehaviours: Qt([ir.config({
          toggleClass: t.markers.toggledClass,
          aria: { mode: "expanded" },
          toggleOnExecute: !1,
          onToggled: t.onToggled
        })])
      })
    }),
    Gu({
      factory: Qm,
      schema: $x(),
      name: "toolbar",
      overrides: (t) => ({
        toolbarBehaviours: Qt([oo.config({
          mode: "cyclic",
          onEscape: (a) => (Xt(a, t, "button").each(Ao.focus), B.none())
        })])
      })
    })
  ]), Cu = ms(), XY = (t, a) => {
    Cu.set(!0), Ux(t, a), Cu.clear();
  }, Ux = (t, a) => {
    const c = Ia.getCoupled(t, "toolbarSandbox");
    Br.isOpen(c) ? Br.close(c) : Br.open(c, a.toolbar());
  }, HO = (t, a, c, f) => {
    const g = c.getBounds.map((w) => w()), x = c.lazySink(t).getOrDie();
    tl.positionWithinBounds(x, a, {
      anchor: {
        type: "hotspot",
        hotspot: t,
        layouts: f,
        overrides: { maxWidthFunction: jx() }
      }
    }, g);
  }, cM = (t, a, c, f, g) => {
    Qm.setGroups(a, g), HO(t, a, c, f), ir.on(t);
  }, QY = (t, a, c) => {
    const f = sy(), g = (w, T) => {
      const A = Cu.get().getOr(!1);
      c.fetch().get((F) => {
        cM(t, T, c, a.layouts, F), f.link(t.element), A || oo.focusIn(T);
      });
    }, x = () => {
      ir.off(t), Cu.get().getOr(!1) || Ao.focus(t), f.unlink(t.element);
    };
    return {
      dom: {
        tag: "div",
        attributes: { id: f.id }
      },
      behaviours: Qt([
        oo.config({
          mode: "special",
          onEscape: (w) => (Br.close(w), B.some(!0))
        }),
        Br.config({
          onOpen: g,
          onClose: x,
          isPartOf: (w, T, A) => Ip(T, A) || Ip(t, A),
          getAttachPoint: () => c.lazySink(t).getOrDie()
        }),
        Ac.config({
          channels: {
            ...Lm({
              isExtraPart: wt,
              ...c.fireDismissalEventInstead.map((w) => ({ fireEventInstead: { event: w.event } })).getOr({})
            }),
            ...$y({
              doReposition: () => {
                Br.getState(Ia.getCoupled(t, "toolbarSandbox")).each((w) => {
                  HO(t, w, c, a.layouts);
                });
              }
            })
          }
        })
      ])
    };
  }, av = Vl({
    name: "FloatingToolbarButton",
    factory: (t, a, c, f) => ({
      ...Rl.sketch({
        ...f.button(),
        action: (g) => {
          Ux(g, f);
        },
        buttonBehaviours: Zu.augment({ dump: f.button().buttonBehaviours }, [Ia.config({
          others: {
            toolbarSandbox: (g) => QY(g, c, t)
          }
        })])
      }),
      apis: {
        setGroups: (g, x) => {
          Br.getState(Ia.getCoupled(g, "toolbarSandbox")).each((w) => {
            cM(g, w, t, c.layouts, x);
          });
        },
        reposition: (g) => {
          Br.getState(Ia.getCoupled(g, "toolbarSandbox")).each((x) => {
            HO(g, x, t, c.layouts);
          });
        },
        toggle: (g) => {
          Ux(g, f);
        },
        toggleWithoutFocusing: (g) => {
          XY(g, f);
        },
        getToolbar: (g) => Br.getState(Ia.getCoupled(g, "toolbarSandbox")),
        isOpen: (g) => Br.isOpen(Ia.getCoupled(g, "toolbarSandbox"))
      }
    }),
    configFields: KY(),
    partFields: YY(),
    apis: {
      setGroups: (t, a, c) => {
        t.setGroups(a, c);
      },
      reposition: (t, a) => {
        t.reposition(a);
      },
      toggle: (t, a) => {
        t.toggle(a);
      },
      toggleWithoutFocusing: (t, a) => {
        t.toggleWithoutFocusing(a);
      },
      getToolbar: (t, a) => t.getToolbar(a),
      isOpen: (t, a) => t.isOpen(a)
    }
  }), eX = te([
    Rt("items"),
    Uf(["itemSelector"]),
    $i("tgroupBehaviours", [oo])
  ]), tX = te([Ky({
    name: "items",
    unit: "item"
  })]), nX = (t, a, c, f) => ({
    uid: t.uid,
    dom: t.dom,
    components: a,
    behaviours: Li(t.tgroupBehaviours, [oo.config({
      mode: "flow",
      selector: t.markers.itemSelector
    })]),
    domModification: { attributes: { role: "toolbar" } }
  }), zO = Vl({
    name: "ToolbarGroup",
    configFields: eX(),
    partFields: tX(),
    factory: nX
  }), q7 = (t) => tt(t, (a) => Ll(a)), K7 = (t, a, c) => {
    Vx(t, c, (f) => {
      c.overflowGroups.set(f), a.getOpt(t).each((g) => {
        av.setGroups(g, q7(f));
      });
    });
  }, Y7 = (t, a, c, f) => {
    const g = is(av.sketch({
      fetch: () => jl.nu((x) => {
        x(q7(t.overflowGroups.get()));
      }),
      layouts: {
        onLtr: () => [
          ei,
          di
        ],
        onRtl: () => [
          di,
          ei
        ],
        onBottomLtr: () => [
          xs,
          fi
        ],
        onBottomRtl: () => [
          fi,
          xs
        ]
      },
      getBounds: c.getOverflowBounds,
      lazySink: t.lazySink,
      fireDismissalEventInstead: {},
      markers: { toggledClass: t.markers.overflowToggledClass },
      parts: {
        button: f["overflow-button"](),
        toolbar: f.overflow()
      },
      onToggled: (x, w) => t[w ? "onOpened" : "onClosed"](x)
    }));
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      behaviours: Li(t.splitToolbarBehaviours, [Ia.config({
        others: {
          overflowGroup: () => zO.sketch({
            ...f["overflow-group"](),
            items: [g.asSpec()]
          })
        }
      })]),
      apis: {
        setGroups: (x, w) => {
          t.builtGroups.set(tt(w, x.getSystem().build)), K7(x, g, t);
        },
        refresh: (x) => K7(x, g, t),
        toggle: (x) => {
          g.getOpt(x).each((w) => {
            av.toggle(w);
          });
        },
        toggleWithoutFocusing: (x) => {
          g.getOpt(x).each(av.toggleWithoutFocusing);
        },
        isOpen: (x) => g.getOpt(x).map(av.isOpen).getOr(!1),
        reposition: (x) => {
          g.getOpt(x).each((w) => {
            av.reposition(w);
          });
        },
        getOverflow: (x) => g.getOpt(x).bind(av.getToolbar)
      },
      domModification: { attributes: { role: "group" } }
    };
  }, uM = Vl({
    name: "SplitFloatingToolbar",
    configFields: LO(),
    partFields: qY(),
    factory: Y7,
    apis: {
      setGroups: (t, a, c) => {
        t.setGroups(a, c);
      },
      refresh: (t, a) => {
        t.refresh(a);
      },
      reposition: (t, a) => {
        t.reposition(a);
      },
      toggle: (t, a) => {
        t.toggle(a);
      },
      toggleWithoutFocusing: (t, a) => {
        t.toggle(a);
      },
      isOpen: (t, a) => t.isOpen(a),
      getOverflow: (t, a) => t.getOverflow(a)
    }
  }), X7 = te([
    Uf([
      "closedClass",
      "openClass",
      "shrinkingClass",
      "growingClass",
      "overflowToggledClass"
    ]),
    Rr("onOpened"),
    Rr("onClosed")
  ].concat(G7())), oX = te([
    hl({
      factory: Qm,
      schema: $x(),
      name: "primary"
    }),
    hl({
      factory: Qm,
      schema: $x(),
      name: "overflow",
      overrides: (t) => ({
        toolbarBehaviours: Qt([
          nu.config({
            dimension: { property: "height" },
            closedClass: t.markers.closedClass,
            openClass: t.markers.openClass,
            shrinkingClass: t.markers.shrinkingClass,
            growingClass: t.markers.growingClass,
            onShrunk: (a) => {
              Xt(a, t, "overflow-button").each((c) => {
                ir.off(c);
              }), t.onClosed(a);
            },
            onGrown: (a) => {
              t.onOpened(a);
            },
            onStartGrow: (a) => {
              Xt(a, t, "overflow-button").each(ir.on);
            }
          }),
          oo.config({
            mode: "acyclic",
            onEscape: (a) => (Xt(a, t, "overflow-button").each(Ao.focus), B.some(!0))
          })
        ])
      })
    }),
    Gu({
      name: "overflow-button",
      overrides: (t) => ({
        buttonBehaviours: Qt([ir.config({
          toggleClass: t.markers.overflowToggledClass,
          aria: { mode: "expanded" },
          toggleOnExecute: !1
        })])
      })
    }),
    Gu({ name: "overflow-group" })
  ]), rX = (t, a) => Xt(t, a, "overflow").map(nu.hasGrown).getOr(!1), VO = (t, a, c) => {
    Xt(t, a, "overflow-button").each((f) => {
      Xt(t, a, "overflow").each((g) => {
        if (jO(t, a), nu.hasShrunk(g)) {
          const x = a.onOpened;
          a.onOpened = (w) => {
            c || oo.focusIn(g), x(w), a.onOpened = x;
          };
        } else {
          const x = a.onClosed;
          a.onClosed = (w) => {
            c || Ao.focus(f), x(w), a.onClosed = x;
          };
        }
        nu.toggleGrow(g);
      });
    });
  }, jO = (t, a) => {
    Xt(t, a, "overflow").each((c) => {
      Vx(t, a, (f) => {
        const g = tt(f, (x) => Ll(x));
        Qm.setGroups(c, g);
      }), Xt(t, a, "overflow-button").each((f) => {
        nu.hasGrown(c) && ir.on(f);
      }), nu.refresh(c);
    });
  }, Q7 = (t, a, c, f) => {
    const g = "alloy.toolbar.toggle", x = (w, T) => {
      const A = tt(T, w.getSystem().build);
      t.builtGroups.set(A);
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      behaviours: Li(t.splitToolbarBehaviours, [
        Ia.config({
          others: {
            overflowGroup: (w) => zO.sketch({
              ...f["overflow-group"](),
              items: [Rl.sketch({
                ...f["overflow-button"](),
                action: (T) => {
                  tr(w, g);
                }
              })]
            })
          }
        }),
        Go("toolbar-toggle-events", [It(g, (w) => {
          VO(w, t, !1);
        })])
      ]),
      apis: {
        setGroups: (w, T) => {
          x(w, T), jO(w, t);
        },
        refresh: (w) => jO(w, t),
        toggle: (w) => {
          VO(w, t, !1);
        },
        toggleWithoutFocusing: (w) => {
          VO(w, t, !0);
        },
        isOpen: (w) => rX(w, t)
      },
      domModification: { attributes: { role: "group" } }
    };
  }, dM = Vl({
    name: "SplitSlidingToolbar",
    configFields: X7(),
    partFields: oX(),
    factory: Q7,
    apis: {
      setGroups: (t, a, c) => {
        t.setGroups(a, c);
      },
      refresh: (t, a) => {
        t.refresh(a);
      },
      toggle: (t, a) => {
        t.toggle(a);
      },
      isOpen: (t, a) => t.isOpen(a)
    }
  }), J7 = (t) => {
    const a = t.title.fold(() => ({}), (c) => ({ attributes: { title: c } }));
    return {
      dom: {
        tag: "div",
        classes: ["tox-toolbar__group"],
        ...a
      },
      components: [zO.parts.items({})],
      items: t.items,
      markers: { itemSelector: "*:not(.tox-split-button) > .tox-tbtn:not([disabled]), .tox-split-button:not([disabled]), .tox-toolbar-nav-js:not([disabled]), .tox-number-input:not([disabled])" },
      tgroupBehaviours: Qt([
        Zs.config({}),
        Ao.config({})
      ])
    };
  }, UO = (t) => zO.sketch(J7(t)), fM = (t, a) => {
    const c = Qs((f) => {
      const g = tt(t.initGroups, UO);
      Qm.setGroups(f, g);
    });
    return Qt([
      rm.toolbarButton(t.providers.isDisabled),
      Si(),
      oo.config({
        mode: a,
        onEscape: t.onEscape,
        selector: ".tox-toolbar__group"
      }),
      Go("toolbar-events", [c])
    ]);
  }, eH = (t) => {
    const a = t.cyclicKeying ? "cyclic" : "acyclic";
    return {
      uid: t.uid,
      dom: {
        tag: "div",
        classes: ["tox-toolbar-overlord"]
      },
      parts: {
        "overflow-group": J7({
          title: B.none(),
          items: []
        }),
        "overflow-button": kK({
          name: "more",
          icon: B.some("more-drawer"),
          enabled: !0,
          tooltip: B.some("Reveal or hide additional toolbar items"),
          primary: !1,
          buttonType: B.none(),
          borderless: !1
        }, B.none(), t.providers, [], "overflow-button")
      },
      splitToolbarBehaviours: fM(t, a)
    };
  }, sX = (t) => {
    const a = eH(t), c = 4, f = uM.parts.primary({
      dom: {
        tag: "div",
        classes: ["tox-toolbar__primary"]
      }
    });
    return uM.sketch({
      ...a,
      lazySink: t.getSink,
      getOverflowBounds: () => {
        const g = t.moreDrawerData.lazyHeader().element, x = Cl(g), w = Oi(g), T = Cl(w), A = Math.max(w.dom.scrollHeight, T.height);
        return Is(x.x + c, T.y, x.width - c * 2, A);
      },
      parts: {
        ...a.parts,
        overflow: {
          dom: {
            tag: "div",
            classes: ["tox-toolbar__overflow"],
            attributes: t.attributes
          }
        }
      },
      components: [f],
      markers: { overflowToggledClass: "tox-tbtn--enabled" },
      onOpened: (g) => t.onToggled(g, !0),
      onClosed: (g) => t.onToggled(g, !1)
    });
  }, aX = (t) => {
    const a = dM.parts.primary({
      dom: {
        tag: "div",
        classes: ["tox-toolbar__primary"]
      }
    }), c = dM.parts.overflow({
      dom: {
        tag: "div",
        classes: ["tox-toolbar__overflow"]
      }
    }), f = eH(t);
    return dM.sketch({
      ...f,
      components: [
        a,
        c
      ],
      markers: {
        openClass: "tox-toolbar__overflow--open",
        closedClass: "tox-toolbar__overflow--closed",
        growingClass: "tox-toolbar__overflow--growing",
        shrinkingClass: "tox-toolbar__overflow--shrinking",
        overflowToggledClass: "tox-tbtn--enabled"
      },
      onOpened: (g) => {
        g.getSystem().broadcastOn([YN()], { type: "opened" }), t.onToggled(g, !0);
      },
      onClosed: (g) => {
        g.getSystem().broadcastOn([YN()], { type: "closed" }), t.onToggled(g, !1);
      }
    });
  }, WO = (t) => {
    const a = t.cyclicKeying ? "cyclic" : "acyclic";
    return Qm.sketch({
      uid: t.uid,
      dom: {
        tag: "div",
        classes: ["tox-toolbar"].concat(t.type === Yu.scrolling ? ["tox-toolbar--scrolling"] : [])
      },
      components: [Qm.parts.groups({})],
      toolbarBehaviours: fM(t, a)
    });
  }, tH = [
    Jb,
    pf,
    ja("tooltip"),
    fu("buttonType", "secondary", [
      "primary",
      "secondary"
    ]),
    Ea("borderless", !1),
    _c("onAction")
  ], iX = [
    ...tH,
    Og,
    Yi("type", ["button"])
  ], lX = [
    ...tH,
    Ea("active", !1),
    Yi("type", ["togglebutton"])
  ], nH = {
    button: iX,
    togglebutton: lX
  }, cX = [
    Yi("type", ["group"]),
    I("buttons", [], ci("type", nH))
  ], uX = ci("type", {
    ...nH,
    group: cX
  }), oH = wo([
    I("buttons", [], uX),
    _c("onShow"),
    _c("onHide")
  ]), dX = (t) => ia("view", oH, t), fX = (t, a) => {
    var c, f;
    const g = t.type === "togglebutton", x = t.icon.map((Ge) => Ng(Ge, a.icons)).map(is), T = (Ge) => {
      const Ft = (vn) => {
        x.map((Nt) => Nt.getOpt(Ge).each((Yn) => {
          No.set(Yn, [Ng(vn, a.icons)]);
        }));
      }, gt = (vn) => {
        const Nt = Ge.element;
        vn ? (Us(Nt, "tox-button--enabled"), rn(Nt, "aria-pressed", !0)) : (va(Nt, "tox-button--enabled"), Ee(Nt, "aria-pressed"));
      }, Jt = () => Zc(Ge.element, "tox-button--enabled");
      if (g)
        return t.onAction({
          setIcon: Ft,
          setActive: gt,
          isActive: Jt
        });
      if (t.type === "button")
        return t.onAction({ setIcon: Ft });
    }, A = {
      ...t,
      name: g ? t.text.getOr(t.icon.getOr("")) : (c = t.text) !== null && c !== void 0 ? c : t.icon.getOr(""),
      primary: t.buttonType === "primary",
      buttonType: B.from(t.buttonType),
      tooltip: t.tooltip,
      icon: t.icon,
      enabled: !0,
      borderless: t.borderless
    }, F = AO((f = t.buttonType) !== null && f !== void 0 ? f : "secondary"), H = g ? t.text.map(a.translate) : B.some(a.translate(t.text)), q = H.map(Oa), ne = A.tooltip.or(H).map((Ge) => ({ "aria-label": a.translate(Ge) })).getOr({}), ie = x.map((Ge) => Ge.asSpec()), fe = B1([
      ie,
      q
    ]), _e = t.icon.isSome() && q.isSome(), st = {
      tag: "button",
      classes: F.concat(...t.icon.isSome() && !_e ? ["tox-button--icon"] : []).concat(..._e ? ["tox-button--icon-and-text"] : []).concat(...t.borderless ? ["tox-button--naked"] : []).concat(...t.type === "togglebutton" && t.active ? ["tox-button--enabled"] : []),
      attributes: ne
    }, De = [], Je = Fx(A, B.some(T), De, st, fe, t.tooltip, a);
    return Rl.sketch(Je);
  }, ZO = (t, a) => fX(t, a), mX = (t, a) => ({
    dom: {
      tag: "div",
      classes: ["tox-view__toolbar__group"]
    },
    components: tt(t.buttons, (c) => ZO(c, a))
  }), WS = Fl().deviceType, pX = WS.isPhone(), rH = WS.isTablet(), hX = (t) => {
    let a = !1;
    const c = tt(t.buttons, (f) => f.type === "group" ? (a = !0, mX(f, t.providers)) : ZO(f, t.providers));
    return {
      uid: t.uid,
      dom: {
        tag: "div",
        classes: [
          a ? "tox-view__toolbar" : "tox-view__header",
          ...pX || rH ? [
            "tox-view--mobile",
            "tox-view--scrolling"
          ] : []
        ]
      },
      behaviours: Qt([
        Ao.config({}),
        oo.config({
          mode: "flow",
          selector: "button, .tox-button",
          focusInside: wg.OnEnterOrSpaceMode
        })
      ]),
      components: a ? c : [
        qm.sketch({
          dom: {
            tag: "div",
            classes: ["tox-view__header-start"]
          },
          components: []
        }),
        qm.sketch({
          dom: {
            tag: "div",
            classes: ["tox-view__header-end"]
          },
          components: c
        })
      ]
    };
  }, gX = (t) => ({
    uid: t.uid,
    behaviours: Qt([
      Ao.config({}),
      Zs.config({})
    ]),
    dom: {
      tag: "div",
      classes: ["tox-view__pane"]
    }
  }), Xae = (t, a, c, f) => {
    const g = {
      getPane: (x) => ol.getPart(x, t, "pane"),
      getOnShow: (x) => t.viewConfig.onShow,
      getOnHide: (x) => t.viewConfig.onHide
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      behaviours: Qt([
        Ao.config({}),
        oo.config({
          mode: "cyclic",
          focusInside: wg.OnEnterOrSpaceMode
        })
      ]),
      apis: g
    };
  };
  var Wx = Vl({
    name: "silver.View",
    configFields: [Rt("viewConfig")],
    partFields: [
      yu({
        factory: { sketch: hX },
        schema: [
          Rt("buttons"),
          Rt("providers")
        ],
        name: "header"
      }),
      yu({
        factory: { sketch: gX },
        schema: [],
        name: "pane"
      })
    ],
    factory: Xae,
    apis: {
      getPane: (t, a) => t.getPane(a),
      getOnShow: (t, a) => t.getOnShow(a),
      getOnHide: (t, a) => t.getOnHide(a)
    }
  });
  const bX = (t, a, c) => Ir(a, (f, g) => {
    const x = Zt(dX(f));
    return t.slot(g, Wx.sketch({
      dom: {
        tag: "div",
        classes: ["tox-view"]
      },
      viewConfig: x,
      components: [
        ...x.buttons.length > 0 ? [Wx.parts.header({
          buttons: x.buttons,
          providers: c
        })] : [],
        Wx.parts.pane({})
      ]
    }));
  }), mM = (t, a) => vl.sketch((c) => ({
    dom: {
      tag: "div",
      classes: ["tox-view-wrap__slot-container"]
    },
    components: bX(c, t, a),
    slotBehaviours: hx.unnamedEvents([Qs((f) => vl.hideAllSlots(f))])
  })), sH = (t) => At(vl.getSlotNames(t), (a) => vl.isShowing(t, a)), GO = (t) => {
    const a = t.element;
    Ln(a, "display", "none"), rn(a, "aria-hidden", "true");
  }, aH = (t) => {
    const a = t.element;
    xr(a, "display"), Ee(a, "aria-hidden");
  }, iH = (t) => ({ getContainer: te(t) }), qO = (t, a, c) => {
    vl.getSlot(t, a).each((f) => {
      Wx.getPane(f).each((g) => {
        c(f)(iH(g.element.dom));
      });
    });
  }, vX = (t, a) => qO(t, a, Wx.getOnShow), lH = (t, a) => qO(t, a, Wx.getOnHide);
  var GS = Pc({
    factory: (t, a) => {
      const x = {
        setViews: (w, T) => {
          No.set(w, [mM(T, a.backstage.shared.providers)]);
        },
        whichView: (w) => Nr.getCurrent(w).bind(sH),
        toggleView: (w, T, A, F) => Nr.getCurrent(w).exists((H) => {
          const q = sH(H), ne = q.exists((fe) => F === fe), ie = vl.getSlot(H, F).isSome();
          return ie && (vl.hideAllSlots(H), ne ? (GO(w), T()) : (A(), aH(w), vl.showSlot(H, F), vX(H, F)), q.each((fe) => lH(H, fe))), ie;
        })
      };
      return {
        uid: t.uid,
        dom: {
          tag: "div",
          classes: ["tox-view-wrap"],
          attributes: { "aria-hidden": "true" },
          styles: { display: "none" }
        },
        components: [],
        behaviours: Qt([
          No.config({}),
          Nr.config({
            find: (w) => {
              const T = No.contents(w);
              return so(T);
            }
          })
        ]),
        apis: x
      };
    },
    name: "silver.ViewWrapper",
    configFields: [Rt("backstage")],
    apis: {
      setViews: (t, a, c) => t.setViews(a, c),
      toggleView: (t, a, c, f, g) => t.toggleView(a, c, f, g),
      whichView: (t, a) => t.whichView(a)
    }
  });
  const yX = (t, a, c) => {
    let f = !1;
    const g = (w) => {
      ac(w, ".tox-statusbar").each((T) => {
        fs(T, "display") === "none" && os(T, "aria-hidden") === "true" ? (xr(T, "display"), Ee(T, "aria-hidden")) : (Ln(T, "display", "none"), rn(T, "aria-hidden", "true"));
      });
    }, x = {
      getSocket: (w) => ol.getPart(w, t, "socket"),
      setSidebar: (w, T, A) => {
        ol.getPart(w, t, "sidebar").each((F) => oM(F, T, A));
      },
      toggleSidebar: (w, T) => {
        ol.getPart(w, t, "sidebar").each((A) => FY(A, T));
      },
      whichSidebar: (w) => ol.getPart(w, t, "sidebar").bind(rM).getOrNull(),
      getHeader: (w) => ol.getPart(w, t, "header"),
      getToolbar: (w) => ol.getPart(w, t, "toolbar"),
      setToolbar: (w, T) => {
        ol.getPart(w, t, "toolbar").each((A) => {
          const F = tt(T, UO);
          A.getApis().setGroups(A, F);
        });
      },
      setToolbars: (w, T) => {
        ol.getPart(w, t, "multiple-toolbar").each((A) => {
          const F = tt(T, (H) => tt(H, UO));
          O7.setItems(A, F);
        });
      },
      refreshToolbar: (w) => {
        ol.getPart(w, t, "toolbar").each((A) => A.getApis().refresh(A));
      },
      toggleToolbarDrawer: (w) => {
        ol.getPart(w, t, "toolbar").each((T) => {
          Or(T.getApis().toggle, (A) => A(T));
        });
      },
      toggleToolbarDrawerWithoutFocusing: (w) => {
        ol.getPart(w, t, "toolbar").each((T) => {
          Or(T.getApis().toggleWithoutFocusing, (A) => A(T));
        });
      },
      isToolbarDrawerToggled: (w) => ol.getPart(w, t, "toolbar").bind((T) => B.from(T.getApis().isOpen).map((A) => A(T))).getOr(!1),
      getThrobber: (w) => ol.getPart(w, t, "throbber"),
      focusToolbar: (w) => {
        ol.getPart(w, t, "toolbar").orThunk(() => ol.getPart(w, t, "multiple-toolbar")).each((A) => {
          oo.focusIn(A);
        });
      },
      setMenubar: (w, T) => {
        ol.getPart(w, t, "menubar").each((A) => {
          eM.setMenus(A, T);
        });
      },
      focusMenubar: (w) => {
        ol.getPart(w, t, "menubar").each((T) => {
          eM.focus(T);
        });
      },
      setViews: (w, T) => {
        ol.getPart(w, t, "viewWrapper").each((A) => {
          GS.setViews(A, T);
        });
      },
      toggleView: (w, T) => ol.getPart(w, t, "viewWrapper").exists((A) => GS.toggleView(A, () => x.showMainView(w), () => x.hideMainView(w), T)),
      whichView: (w) => ol.getPart(w, t, "viewWrapper").bind(GS.whichView).getOrNull(),
      hideMainView: (w) => {
        f = x.isToolbarDrawerToggled(w), f && x.toggleToolbarDrawer(w), ol.getPart(w, t, "editorContainer").each((T) => {
          const A = T.element;
          g(A), Ln(A, "display", "none"), rn(A, "aria-hidden", "true");
        });
      },
      showMainView: (w) => {
        f && x.toggleToolbarDrawer(w), ol.getPart(w, t, "editorContainer").each((T) => {
          const A = T.element;
          g(A), xr(A, "display"), Ee(A, "aria-hidden");
        });
      }
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      apis: x,
      behaviours: t.behaviours
    };
  }, xX = Ig.optional({
    factory: eM,
    name: "menubar",
    schema: [Rt("backstage")]
  }), wX = (t) => t.type === Yu.sliding ? aX : t.type === Yu.floating ? sX : WO, pM = Ig.optional({
    factory: {
      sketch: (t) => O7.sketch({
        uid: t.uid,
        dom: t.dom,
        listBehaviours: Qt([oo.config({
          mode: "acyclic",
          selector: ".tox-toolbar"
        })]),
        makeItem: () => WO({
          type: t.type,
          uid: Nn("multiple-toolbar-item"),
          cyclicKeying: !1,
          initGroups: [],
          providers: t.providers,
          onEscape: () => (t.onEscape(), B.some(!0))
        }),
        setupItem: (a, c, f, g) => {
          Qm.setGroups(c, f);
        },
        shell: !0
      })
    },
    name: "multiple-toolbar",
    schema: [
      Rt("dom"),
      Rt("onEscape")
    ]
  }), CX = Ig.optional({
    factory: {
      sketch: (t) => {
        const a = wX(t), c = {
          type: t.type,
          uid: t.uid,
          onEscape: () => (t.onEscape(), B.some(!0)),
          onToggled: (f, g) => t.onToolbarToggled(g),
          cyclicKeying: !1,
          initGroups: [],
          getSink: t.getSink,
          providers: t.providers,
          moreDrawerData: {
            lazyToolbar: t.lazyToolbar,
            lazyMoreButton: t.lazyMoreButton,
            lazyHeader: t.lazyHeader
          },
          attributes: t.attributes
        };
        return a(c);
      }
    },
    name: "toolbar",
    schema: [
      Rt("dom"),
      Rt("onEscape"),
      Rt("getSink")
    ]
  }), SX = Ig.optional({
    factory: { sketch: Hx },
    name: "header",
    schema: [Rt("dom")]
  }), cH = Ig.optional({
    factory: { sketch: PY },
    name: "promotion",
    schema: [Rt("dom")]
  }), uH = Ig.optional({
    name: "socket",
    schema: [Rt("dom")]
  }), KO = Ig.optional({
    factory: { sketch: BY },
    name: "sidebar",
    schema: [Rt("dom")]
  }), hM = Ig.optional({
    factory: { sketch: U7 },
    name: "throbber",
    schema: [Rt("dom")]
  }), kX = Ig.optional({
    factory: GS,
    name: "viewWrapper",
    schema: [Rt("backstage")]
  }), _X = (t) => ({
    uid: t.uid,
    dom: {
      tag: "div",
      classes: ["tox-editor-container"]
    },
    components: t.components
  }), dH = Ig.optional({
    factory: { sketch: _X },
    name: "editorContainer",
    schema: []
  });
  var Gs = Vl({
    name: "OuterContainer",
    factory: yX,
    configFields: [
      Rt("dom"),
      Rt("behaviours")
    ],
    partFields: [
      SX,
      xX,
      CX,
      pM,
      uH,
      KO,
      cH,
      hM,
      kX,
      dH
    ],
    apis: {
      getSocket: (t, a) => t.getSocket(a),
      setSidebar: (t, a, c, f) => {
        t.setSidebar(a, c, f);
      },
      toggleSidebar: (t, a, c) => {
        t.toggleSidebar(a, c);
      },
      whichSidebar: (t, a) => t.whichSidebar(a),
      getHeader: (t, a) => t.getHeader(a),
      getToolbar: (t, a) => t.getToolbar(a),
      setToolbar: (t, a, c) => {
        t.setToolbar(a, c);
      },
      setToolbars: (t, a, c) => {
        t.setToolbars(a, c);
      },
      refreshToolbar: (t, a) => t.refreshToolbar(a),
      toggleToolbarDrawer: (t, a) => {
        t.toggleToolbarDrawer(a);
      },
      toggleToolbarDrawerWithoutFocusing: (t, a) => {
        t.toggleToolbarDrawerWithoutFocusing(a);
      },
      isToolbarDrawerToggled: (t, a) => t.isToolbarDrawerToggled(a),
      getThrobber: (t, a) => t.getThrobber(a),
      setMenubar: (t, a, c) => {
        t.setMenubar(a, c);
      },
      focusMenubar: (t, a) => {
        t.focusMenubar(a);
      },
      focusToolbar: (t, a) => {
        t.focusToolbar(a);
      },
      setViews: (t, a, c) => {
        t.setViews(a, c);
      },
      toggleView: (t, a, c) => t.toggleView(a, c),
      whichView: (t, a) => t.whichView(a)
    }
  });
  const EX = "file edit view insert format tools table help", fH = {
    file: {
      title: "File",
      items: "newdocument restoredraft | preview | importword exportpdf exportword | export print | deleteallconversations"
    },
    edit: {
      title: "Edit",
      items: "undo redo | cut copy paste pastetext | selectall | searchreplace"
    },
    view: {
      title: "View",
      items: "code revisionhistory | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments"
    },
    insert: {
      title: "Insert",
      items: "image link media addcomment pageembed inserttemplate codesample inserttable accordion math | charmap emoticons hr | pagebreak nonbreaking anchor tableofcontents footnotes | mergetags | insertdatetime"
    },
    format: {
      title: "Format",
      items: "bold italic underline strikethrough superscript subscript codeformat | styles blocks fontfamily fontsize align lineheight | forecolor backcolor | language | removeformat"
    },
    tools: {
      title: "Tools",
      items: "aidialog aishortcuts | spellchecker spellcheckerlanguage | autocorrect capitalization | a11ycheck code typography wordcount addtemplate"
    },
    table: {
      title: "Table",
      items: "inserttable | cell row column | advtablesort | tableprops deletetable"
    },
    help: {
      title: "Help",
      items: "help"
    }
  }, mH = (t, a, c) => {
    const f = lD(c).split(/[ ,]/);
    return {
      text: t.title,
      getItems: () => Ue(t.items, (g) => {
        const x = g.toLowerCase();
        return x.trim().length === 0 ? [] : Fn(f, (w) => w === x) ? [] : x === "separator" || x === "|" ? [{ type: "separator" }] : a.menuItems[x] ? [a.menuItems[x]] : [];
      })
    };
  }, gM = (t) => t.split(" "), pH = (t, a) => {
    const c = {
      ...fH,
      ...a.menus
    }, f = Qo(a.menus).length > 0, g = a.menubar === void 0 || a.menubar === !0 ? gM(EX) : gM(a.menubar === !1 ? "" : a.menubar), x = To(g, (T) => {
      const A = Ho(fH, T);
      return f ? A || Ht(a.menus, T).exists((F) => Ho(F, "items")) : A;
    }), w = tt(x, (T) => {
      const A = c[T];
      return mH({
        title: A.title,
        items: gM(A.items)
      }, a, t);
    });
    return To(w, (T) => {
      const A = (F) => _(F) || F.type !== "separator";
      return T.getItems().length > 0 && Fn(T.getItems(), A);
    });
  }, bM = (t) => {
    const a = () => {
      t._skinLoaded = !0, nZ(t);
    };
    return () => {
      t.initialized ? a() : t.on("init", a);
    };
  }, TX = (t, a) => () => oZ(t, { message: a }), hH = (t, a, c) => (t.on("remove", () => c.unload(a)), c.load(a)), YO = (t, a, c, f) => (t.on("remove", () => f.unloadRawCss(a)), f.loadRawCss(a, c)), OX = async (t, a) => {
    const f = "ui/" + oT(t).getOr("default") + "/skin.css", g = tinymce.Resource.get(f);
    if (_(g))
      YO(t, f, g, t.ui.styleSheetLoader);
    else {
      const x = t.editorManager.suffix, w = a + `/skin${x}.css`;
      return hH(t, w, t.ui.styleSheetLoader);
    }
  }, gH = async (t, a) => {
    if (Ze(He.fromDom(t.getElement()))) {
      const g = "ui/" + oT(t).getOr("default") + "/skin.shadowdom.css", x = tinymce.Resource.get(g);
      if (_(x))
        YO(t, g, x, T1.DOM.styleSheetLoader);
      else {
        const w = t.editorManager.suffix, T = a + `/skin.shadowdom${w}.css`;
        return hH(t, T, T1.DOM.styleSheetLoader);
      }
    }
  }, AX = async (t, a) => {
    const c = () => {
      const g = gD(a), x = a.editorManager.suffix;
      g && a.contentCSS.push(g + (t ? "/content.inline" : "/content") + `${x}.css`);
    };
    oT(a).fold(c, (g) => {
      const x = "ui/" + g + (t ? "/content.inline" : "/content") + ".css", w = tinymce.Resource.get(x);
      _(w) ? YO(a, x, w, a.ui.styleSheetLoader) : c();
    });
    const f = gD(a);
    if (!hD(a) && _(f))
      return Promise.all([
        OX(a, f),
        gH(a, f)
      ]).then();
  }, vM = (t, a) => AX(t, a).then(bM(a), TX(a, "Skin could not be loaded")), PX = Kt(vM, !1), DX = Kt(vM, !0), Zx = (t, a, c) => Oe(c) ? t.translate(a) : t.translate([
    a,
    t.translate(c)
  ]), bH = (t, a) => {
    const c = (w, T, A, F) => {
      const H = t.shared.providers.translate(w.title);
      if (w.type === "separator")
        return B.some({
          type: "separator",
          text: H
        });
      if (w.type === "submenu") {
        const q = Ue(w.getStyleItems(), (ne) => f(ne, T, F));
        return T === 0 && q.length <= 0 ? B.none() : B.some({
          type: "nestedmenuitem",
          text: H,
          enabled: q.length > 0,
          getSubmenuItems: () => Ue(w.getStyleItems(), (ne) => f(ne, T, F))
        });
      } else
        return B.some({
          type: "togglemenuitem",
          text: H,
          icon: w.icon,
          active: w.isSelected(F),
          enabled: !A,
          onAction: a.onAction(w),
          ...w.getStylePreview().fold(() => ({}), (q) => ({ meta: { style: q } }))
        });
    }, f = (w, T, A) => {
      const F = w.type === "formatter" && a.isInvalid(w);
      return T === 0 ? F ? [] : c(w, T, !1, A).toArray() : c(w, T, F, A).toArray();
    }, g = (w) => {
      const T = a.getCurrentValue(), A = a.shouldHide ? 0 : 1;
      return Ue(w, (F) => f(F, A, T));
    };
    return {
      validateItems: g,
      getFetch: (w, T) => (A, F) => {
        const H = T(), q = g(H), ne = Mx(q, em.CLOSE_ON_EXECUTE, w, {
          isHorizontalMenu: !1,
          search: B.none()
        });
        F(ne);
      }
    };
  }, Gx = (t, a) => {
    const c = a.dataset, f = c.type === "basic" ? () => tt(c.data, (g) => c7(g, a.isSelectedFor, a.getPreviewFor)) : c.getData;
    return {
      items: bH(t, a),
      getStyleItems: f
    };
  }, qS = (t, a, c, f, g, x) => {
    const { items: w, getStyleItems: T } = Gx(a, c), A = no(c.tooltip), F = (q) => ({
      getComponent: te(q),
      setTooltip: (ne) => {
        const ie = a.shared.providers.translate(ne);
        rn(q.element, "aria-label", ie), A.set(ne);
      }
    }), H = (q) => {
      const ne = (ie) => q.setTooltip(Zx(t, f(ie.value), ie.value));
      return t.on(g, ne), cS(H1(t, "NodeChange", (ie) => {
        const fe = ie.getComponent();
        c.updateText(fe), _o.set(ie.getComponent(), !t.selection.isEditable());
      })(q), () => t.off(g, ne));
    };
    return vO({
      text: c.icon.isSome() ? B.none() : c.text,
      icon: c.icon,
      ariaLabel: B.some(c.tooltip),
      tooltip: B.none(),
      role: B.none(),
      fetch: w.getFetch(a, T),
      onSetup: H,
      getApi: F,
      columns: 1,
      presets: "normal",
      classes: c.icon.isSome() ? [] : ["bespoke"],
      dropdownBehaviours: [gl.config({
        ...a.shared.providers.tooltips.getConfig({
          tooltipText: a.shared.providers.translate(c.tooltip),
          onShow: (q) => {
            if (c.tooltip !== A.get()) {
              const ne = a.shared.providers.translate(A.get());
              gl.setComponents(q, a.shared.providers.tooltips.getComponents({ tooltipText: ne }));
            }
          }
        })
      })]
    }, "tox-tbtn", a.shared, x);
  }, RX = (t) => tt(t, (a) => {
    let c = a, f = a;
    const g = a.split("=");
    return g.length > 1 && (c = g[0], f = g[1]), {
      title: c,
      format: f
    };
  }), yM = (t) => ({
    type: "basic",
    data: t
  });
  var iv;
  (function(t) {
    t[t.SemiColon = 0] = "SemiColon", t[t.Space = 1] = "Space";
  })(iv || (iv = {}));
  const NX = (t, a) => a === iv.SemiColon ? t.replace(/;$/, "").split(";") : t.split(" "), xM = (t, a, c) => {
    const f = t.options.get(a);
    return {
      type: "basic",
      data: RX(NX(f, c))
    };
  }, MX = "Align", vH = te("Alignment {0}"), yH = "left", wM = [
    {
      title: "Left",
      icon: "align-left",
      format: "alignleft",
      command: "JustifyLeft"
    },
    {
      title: "Center",
      icon: "align-center",
      format: "aligncenter",
      command: "JustifyCenter"
    },
    {
      title: "Right",
      icon: "align-right",
      format: "alignright",
      command: "JustifyRight"
    },
    {
      title: "Justify",
      icon: "align-justify",
      format: "alignjustify",
      command: "JustifyFull"
    }
  ], xH = (t) => {
    const a = () => At(wM, (T) => t.formatter.match(T.format)), c = (T) => () => t.formatter.match(T), f = (T) => B.none, g = (T) => {
      const F = a().fold(te(yH), (H) => H.title.toLowerCase());
      po(T, ov, { icon: `align-${F}` }), cZ(t, { value: F });
    }, x = yM(wM), w = (T) => () => At(wM, (A) => A.format === T.format).each((A) => t.execCommand(A.command));
    return {
      tooltip: Zx(t, vH(), yH),
      text: B.none(),
      icon: B.some("align-left"),
      isSelectedFor: c,
      getCurrentValue: B.none,
      getPreviewFor: f,
      onAction: w,
      updateText: g,
      dataset: x,
      shouldHide: !1,
      isInvalid: (T) => !t.formatter.canApply(T.format)
    };
  }, IX = (t, a) => qS(t, a, xH(t), vH, "AlignTextUpdate", "align"), FX = (t, a) => {
    const c = Gx(a, xH(t));
    t.ui.registry.addNestedMenuItem("align", {
      text: a.shared.providers.translate(MX),
      onSetup: Rc(t),
      getSubmenuItems: () => c.items.validateItems(c.getStyleItems())
    });
  }, CM = (t, a) => {
    const c = a(), f = tt(c, (g) => g.format);
    return B.from(t.formatter.closest(f)).bind((g) => At(c, (x) => x.format === g));
  }, XO = "Blocks", QO = te("Block {0}"), JO = "Paragraph", Fg = (t) => {
    const a = (x) => () => t.formatter.match(x), c = (x) => () => {
      const w = t.formatter.get(x);
      return w ? B.some({
        tag: w.length > 0 && (w[0].inline || w[0].block) || "div",
        styles: t.dom.parseStyle(t.formatter.getCssText(x))
      }) : B.none();
    }, f = (x) => {
      const T = CM(t, () => g.data).fold(te(JO), (A) => A.title);
      po(x, wf, { text: T }), mL(t, { value: T });
    }, g = xM(t, "block_formats", iv.SemiColon);
    return {
      tooltip: Zx(t, QO(), JO),
      text: B.some(JO),
      icon: B.none(),
      isSelectedFor: a,
      getCurrentValue: B.none,
      getPreviewFor: c,
      onAction: pL(t),
      updateText: f,
      dataset: g,
      shouldHide: !1,
      isInvalid: (x) => !t.formatter.canApply(x.format)
    };
  }, wH = (t, a) => qS(t, a, Fg(t), QO, "BlocksTextUpdate", "blocks"), BX = (t, a) => {
    const c = Gx(a, Fg(t));
    t.ui.registry.addNestedMenuItem("blocks", {
      text: XO,
      onSetup: Rc(t),
      getSubmenuItems: () => c.items.validateItems(c.getStyleItems())
    });
  }, $X = "Fonts", CH = te("Font {0}"), SM = "System Font", LX = [
    "-apple-system",
    "Segoe UI",
    "Roboto",
    "Helvetica Neue",
    "sans-serif"
  ], SH = (t) => {
    const a = t.split(/\s*,\s*/);
    return tt(a, (c) => c.replace(/^['"]+|['"]+$/g, ""));
  }, kH = (t, a) => a.length > 0 && jn(a, (c) => t.indexOf(c.toLowerCase()) > -1), _H = (t, a) => {
    if (t.indexOf("-apple-system") === 0 || a.length > 0) {
      const c = SH(t.toLowerCase());
      return kH(c, LX) || kH(c, a);
    } else
      return !1;
  }, EH = (t) => {
    const a = () => {
      const A = (fe) => fe ? SH(fe)[0] : "", F = t.queryCommandValue("FontName"), H = T.data, q = F ? F.toLowerCase() : "", ne = KB(t);
      return {
        matchOpt: At(H, (fe) => {
          const _e = fe.format;
          return _e.toLowerCase() === q || A(_e).toLowerCase() === A(q).toLowerCase();
        }).orThunk(() => Xn(_H(q, ne), {
          title: SM,
          format: q
        })),
        font: F
      };
    }, c = (A) => (F) => F.exists((H) => H.format === A), f = () => {
      const { matchOpt: A } = a();
      return A;
    }, g = (A) => () => B.some({
      tag: "div",
      styles: A.indexOf("dings") === -1 ? { "font-family": A } : {}
    }), x = (A) => () => {
      t.undoManager.transact(() => {
        t.focus(), t.execCommand("FontName", !1, A.format);
      });
    }, w = (A) => {
      const { matchOpt: F, font: H } = a(), q = F.fold(te(H), (ne) => ne.title);
      po(A, wf, { text: q }), uZ(t, { value: q });
    }, T = xM(t, "font_family_formats", iv.SemiColon);
    return {
      tooltip: Zx(t, CH(), SM),
      text: B.some(SM),
      icon: B.none(),
      isSelectedFor: c,
      getCurrentValue: f,
      getPreviewFor: g,
      onAction: x,
      updateText: w,
      dataset: T,
      shouldHide: !1,
      isInvalid: wt
    };
  }, HX = (t, a) => qS(t, a, EH(t), CH, "FontFamilyTextUpdate", "fontfamily"), kM = (t, a) => {
    const c = Gx(a, EH(t));
    t.ui.registry.addNestedMenuItem("fontfamily", {
      text: a.shared.providers.translate($X),
      onSetup: Rc(t),
      getSubmenuItems: () => c.items.validateItems(c.getStyleItems())
    });
  }, zX = {
    unsupportedLength: [
      "em",
      "ex",
      "cap",
      "ch",
      "ic",
      "rem",
      "lh",
      "rlh",
      "vw",
      "vh",
      "vi",
      "vb",
      "vmin",
      "vmax",
      "cm",
      "mm",
      "Q",
      "in",
      "pc",
      "pt",
      "px"
    ],
    fixed: [
      "px",
      "pt"
    ],
    relative: ["%"],
    empty: [""]
  }, VX = (() => {
    const t = "[0-9]+", c = "[eE]" + ("[+-]?" + t), f = "\\.", g = (T) => `(?:${T})?`, w = `[+-]?(?:${[
      "Infinity",
      t + f + g(t) + g(c),
      f + t + g(c),
      t + g(c)
    ].join("|")})`;
    return new RegExp(`^(${w})(.*)$`);
  })(), jX = (t, a) => Fn(a, (c) => Fn(zX[c], (f) => t === f)), eA = (t, a) => B.from(VX.exec(t)).bind((f) => {
    const g = Number(f[1]), x = f[2];
    return jX(x, a) ? B.some({
      value: g,
      unit: x
    }) : B.none();
  }), UX = (t, a) => eA(t, a).map(({ value: c, unit: f }) => c + f), TH = {
    tab: te(9),
    escape: te(27),
    enter: te(13),
    backspace: te(8),
    delete: te(46),
    left: te(37),
    up: te(38),
    right: te(39),
    down: te(40),
    space: te(32),
    home: te(36),
    end: te(35),
    pageUp: te(33),
    pageDown: te(34)
  }, OH = (t, a, c, f) => {
    let g = B.none();
    const x = (Ge) => Ge.map((Ft) => Mn.getValue(Ft)).getOr(""), w = H1(t, "NodeChange SwitchMode", (Ge) => {
      const Ft = Ge.getComponent();
      g = B.some(Ft), c.updateInputValue(Ft), _o.set(Ft, !t.selection.isEditable());
    }), T = (Ge) => ({ getComponent: te(Ge) }), A = no(G), F = Nn("custom-number-input-events"), H = (Ge, Ft, gt) => {
      const Jt = x(g), vn = c.getNewValue(Jt, Ge), Nt = Jt.length - `${vn}`.length, Yn = g.map((xo) => xo.element.dom.selectionStart - Nt), In = g.map((xo) => xo.element.dom.selectionEnd - Nt);
      c.onAction(vn, gt), g.each((xo) => {
        Mn.setValue(xo, vn), Ft && (Yn.each((fo) => xo.element.dom.selectionStart = fo), In.each((fo) => xo.element.dom.selectionEnd = fo));
      });
    }, q = (Ge, Ft) => H((gt, Jt) => gt - Jt, Ge, Ft), ne = (Ge, Ft) => H((gt, Jt) => gt + Jt, Ge, Ft), ie = (Ge) => Ui(Ge.element).fold(B.none, (Ft) => (mu(Ft), B.some(!0))), fe = (Ge) => Jv(Ge.element) ? (Kl(Ge.element).each((Ft) => mu(Ft)), B.some(!0)) : B.none(), _e = (Ge, Ft, gt, Jt) => {
      const vn = no(G), Nt = a.shared.providers.translate(gt), Yn = Nn("altExecuting"), In = H1(t, "NodeChange SwitchMode", (fo) => {
        _o.set(fo.getComponent(), !t.selection.isEditable());
      }), xo = (fo) => {
        _o.isDisabled(fo) || Ge(!0);
      };
      return Rl.sketch({
        dom: {
          tag: "button",
          attributes: {
            "aria-label": Nt,
            "data-mce-name": Ft
          },
          classes: Jt.concat(Ft)
        },
        components: [xN(Ft, a.shared.providers.icons)],
        buttonBehaviours: Qt([
          _o.config({}),
          gl.config(a.shared.providers.tooltips.getConfig({ tooltipText: Nt })),
          Go(Yn, [
            Ag({
              onSetup: In,
              getApi: T
            }, vn),
            mc({ getApi: T }, vn),
            It(Cd(), (fo, Gr) => {
              (Gr.event.raw.keyCode === TH.space() || Gr.event.raw.keyCode === TH.enter()) && (_o.isDisabled(fo) || Ge(!1));
            }),
            It(Vh(), xo),
            It(Ja(), xo)
          ])
        ]),
        eventOrder: {
          [Cd()]: [
            Yn,
            "keying"
          ],
          [Vh()]: [
            Yn,
            "alloy.base.behaviour"
          ],
          [Ja()]: [
            Yn,
            "alloy.base.behaviour"
          ],
          [oc()]: [
            "alloy.base.behaviour",
            Yn,
            "tooltipping"
          ],
          [Vu()]: [
            Yn,
            "tooltipping"
          ]
        }
      });
    }, st = is(_e((Ge) => q(!1, Ge), "minus", "Decrease font size", [])), De = is(_e((Ge) => ne(!1, Ge), "plus", "Increase font size", [])), Je = is({
      dom: {
        tag: "div",
        classes: ["tox-input-wrapper"]
      },
      components: [N1.sketch({
        inputBehaviours: Qt([
          _o.config({}),
          Go(F, [
            Ag({
              onSetup: w,
              getApi: T
            }, A),
            mc({ getApi: T }, A)
          ]),
          Go("input-update-display-text", [
            It(wf, (Ge, Ft) => {
              Mn.setValue(Ge, Ft.event.text);
            }),
            It($f(), (Ge) => {
              c.onAction(Mn.getValue(Ge));
            }),
            It(ab(), (Ge) => {
              c.onAction(Mn.getValue(Ge));
            })
          ]),
          oo.config({
            mode: "special",
            onEnter: (Ge) => (H(lt, !0, !0), B.some(!0)),
            onEscape: ie,
            onUp: (Ge) => (ne(!0, !1), B.some(!0)),
            onDown: (Ge) => (q(!0, !1), B.some(!0)),
            onLeft: (Ge, Ft) => (Ft.cut(), B.none()),
            onRight: (Ge, Ft) => (Ft.cut(), B.none())
          })
        ])
      })],
      behaviours: Qt([
        Ao.config({}),
        oo.config({
          mode: "special",
          onEnter: fe,
          onSpace: fe,
          onEscape: ie
        }),
        Go("input-wrapper-events", [It(Bf(), (Ge) => {
          mt([
            st,
            De
          ], (Ft) => {
            const gt = He.fromDom(Ft.get(Ge).element.dom);
            Jv(gt) && Qv(gt);
          });
        })])
      ])
    });
    return {
      dom: {
        tag: "div",
        classes: ["tox-number-input"],
        attributes: { ...Ce(f) ? { "data-mce-name": f } : {} }
      },
      components: [
        st.asSpec(),
        Je.asSpec(),
        De.asSpec()
      ],
      behaviours: Qt([
        Ao.config({}),
        oo.config({
          mode: "flow",
          focusInside: wg.OnEnterOrSpaceMode,
          cycles: !1,
          selector: "button, .tox-input-wrapper",
          onEscape: (Ge) => Jv(Ge.element) ? B.none() : (mu(Ge.element), B.some(!0))
        })
      ])
    };
  }, AH = "Font sizes", _M = te("Font size {0}"), PH = "12pt", DH = {
    "8pt": "1",
    "10pt": "2",
    "12pt": "3",
    "14pt": "4",
    "18pt": "5",
    "24pt": "6",
    "36pt": "7"
  }, WX = {
    "xx-small": "7pt",
    "x-small": "8pt",
    small: "10pt",
    medium: "12pt",
    large: "14pt",
    "x-large": "18pt",
    "xx-large": "24pt"
  }, ZX = (t, a) => {
    const c = Math.pow(10, a);
    return Math.round(t * c) / c;
  }, GX = (t, a) => /[0-9.]+px$/.test(t) ? ZX(parseInt(t, 10) * 72 / 96, a || 0) + "pt" : Ht(WX, t).getOr(t), RH = (t) => Ht(DH, t).getOr(""), NH = (t) => {
    const a = () => {
      let A = B.none();
      const F = T.data, H = t.queryCommandValue("FontSize");
      if (H)
        for (let q = 3; A.isNone() && q >= 0; q--) {
          const ne = GX(H, q), ie = RH(ne);
          A = At(F, (fe) => fe.format === H || fe.format === ne || fe.format === ie);
        }
      return {
        matchOpt: A,
        size: H
      };
    }, c = (A) => (F) => F.exists((H) => H.format === A), f = () => {
      const { matchOpt: A } = a();
      return A;
    }, g = te(B.none), x = (A) => () => {
      t.undoManager.transact(() => {
        t.focus(), t.execCommand("FontSize", !1, A.format);
      });
    }, w = (A) => {
      const { matchOpt: F, size: H } = a(), q = F.fold(te(H), (ne) => ne.title);
      po(A, wf, { text: q }), yR(t, { value: q });
    }, T = xM(t, "font_size_formats", iv.Space);
    return {
      tooltip: Zx(t, _M(), PH),
      text: B.some(PH),
      icon: B.none(),
      isSelectedFor: c,
      getPreviewFor: g,
      getCurrentValue: f,
      onAction: x,
      updateText: w,
      dataset: T,
      shouldHide: !1,
      isInvalid: wt
    };
  }, MH = (t, a) => qS(t, a, NH(t), _M, "FontSizeTextUpdate", "fontsize"), qX = (t) => {
    var a;
    const c = { step: 1 };
    return (a = {
      em: { step: 0.1 },
      cm: { step: 0.1 },
      in: { step: 0.1 },
      pc: { step: 0.1 },
      ch: { step: 0.1 },
      rem: { step: 0.1 }
    }[t]) !== null && a !== void 0 ? a : c;
  }, KX = 16, YX = (t) => t >= 0, XX = (t) => {
    const a = () => t.queryCommandValue("FontSize");
    return {
      updateInputValue: (f) => po(f, wf, { text: a() }),
      onAction: (f, g) => t.execCommand("FontSize", !1, f, { skip_focus: !g }),
      getNewValue: (f, g) => {
        eA(f, [
          "unsupportedLength",
          "empty"
        ]);
        const x = a(), w = eA(f, [
          "unsupportedLength",
          "empty"
        ]).or(eA(x, [
          "unsupportedLength",
          "empty"
        ])), T = w.map((ne) => ne.value).getOr(KX), A = dD(t), F = w.map((ne) => ne.unit).filter((ne) => ne !== "").getOr(A), H = g(T, qX(F).step), q = `${YX(H) ? H : T}${F}`;
        return q !== x && fL(t, { value: q }), q;
      }
    };
  }, QX = (t, a) => OH(t, a, XX(t), "fontsizeinput"), JX = (t, a) => {
    const c = Gx(a, NH(t));
    t.ui.registry.addNestedMenuItem("fontsize", {
      text: AH,
      onSetup: Rc(t),
      getSubmenuItems: () => c.items.validateItems(c.getStyleItems())
    });
  }, eQ = "Formats", EM = (t) => Oe(t) ? "Formats" : "Format {0}", IH = (t, a) => {
    const c = "Formats", f = (w) => () => t.formatter.match(w), g = (w) => () => {
      const T = t.formatter.get(w);
      return T !== void 0 ? B.some({
        tag: T.length > 0 && (T[0].inline || T[0].block) || "div",
        styles: t.dom.parseStyle(t.formatter.getCssText(w))
      }) : B.none();
    }, x = (w) => {
      const T = (q) => n7(q) ? Ue(q.items, T) : o7(q) ? [{
        title: q.title,
        format: q.format
      }] : [], A = Ue(i7(t), T), H = CM(t, te(A)).fold(te({
        title: c,
        tooltipLabel: ""
      }), (q) => ({
        title: q.title,
        tooltipLabel: q.title
      }));
      po(w, wf, { text: H.title }), lZ(t, { value: H.tooltipLabel });
    };
    return {
      tooltip: Zx(t, EM(""), ""),
      text: B.some(c),
      icon: B.none(),
      isSelectedFor: f,
      getCurrentValue: B.none,
      getPreviewFor: g,
      onAction: pL(t),
      updateText: x,
      shouldHide: BB(t),
      isInvalid: (w) => !t.formatter.canApply(w.format),
      dataset: a
    };
  }, tQ = (t, a) => {
    const c = {
      type: "advanced",
      ...a.styles
    };
    return qS(t, a, IH(t, c), EM, "StylesTextUpdate", "styles");
  }, nQ = (t, a) => {
    const c = {
      type: "advanced",
      ...a.styles
    }, f = Gx(a, IH(t, c));
    t.ui.registry.addNestedMenuItem("styles", {
      text: eQ,
      onSetup: Rc(t),
      getSubmenuItems: () => f.items.validateItems(f.getStyleItems())
    });
  }, oQ = te([
    Rt("toggleClass"),
    Rt("fetch"),
    ju("onExecute"),
    Qe("getHotspot", B.some),
    Qe("getAnchorOverrides", te({})),
    jp(),
    ju("onItemExecute"),
    jr("lazySink"),
    Rt("dom"),
    Rr("onOpen"),
    $i("splitDropdownBehaviours", [
      Ia,
      oo,
      Ao
    ]),
    Qe("matchWidth", !1),
    Qe("useMinWidth", !1),
    Qe("eventOrder", {}),
    jr("role"),
    jr("listRole")
  ].concat(KT())), rQ = hl({
    factory: Rl,
    schema: [Rt("dom")],
    name: "arrow",
    defaults: () => ({ buttonBehaviours: Qt([Ao.revoke()]) }),
    overrides: (t) => ({
      dom: {
        tag: "span",
        attributes: { role: "presentation" }
      },
      action: (a) => {
        a.getSystem().getByUid(t.uid).each(Tp);
      },
      buttonBehaviours: Qt([ir.config({
        toggleOnExecute: !1,
        toggleClass: t.toggleClass
      })])
    })
  }), sQ = hl({
    factory: Rl,
    schema: [Rt("dom")],
    name: "button",
    defaults: () => ({ buttonBehaviours: Qt([Ao.revoke()]) }),
    overrides: (t) => ({
      dom: {
        tag: "span",
        attributes: { role: "presentation" }
      },
      action: (a) => {
        a.getSystem().getByUid(t.uid).each((c) => {
          t.onExecute(c, a);
        });
      }
    })
  }), aQ = te([
    rQ,
    sQ,
    yu({
      factory: {
        sketch: (t) => ({
          uid: t.uid,
          dom: {
            tag: "span",
            styles: { display: "none" },
            attributes: { "aria-hidden": "true" },
            innerHtml: t.text
          }
        })
      },
      schema: [Rt("text")],
      name: "aria-descriptor"
    }),
    Gu({
      schema: [tg()],
      name: "menu",
      defaults: (t) => ({
        onExecute: (a, c) => {
          a.getSystem().getByUid(t.uid).each((f) => {
            t.onItemExecute(f, a, c);
          });
        }
      })
    }),
    LL()
  ]), FH = (t, a, c, f) => {
    const g = (H) => {
      Nr.getCurrent(H).each((q) => {
        wn.highlightFirst(q), oo.focusIn(q);
      });
    }, x = (H) => {
      AR(t, lt, H, f, g, Dc.HighlightMenuAndItem).get(G);
    }, w = (H) => (x(H), B.some(!0)), T = (H) => {
      const q = uc(H, t, "button");
      return Tp(q), B.some(!0);
    }, A = {
      ...js([Qs((H, q) => {
        Xt(H, t, "aria-descriptor").each((ie) => {
          const fe = Nn("aria");
          rn(ie.element, "id", fe), rn(H.element, "aria-describedby", fe);
        });
      })]),
      ...WE(B.some(x))
    }, F = {
      repositionMenus: (H) => {
        ir.isOn(H) && RR(H);
      }
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      apis: F,
      eventOrder: {
        ...t.eventOrder,
        [zu()]: [
          "disabling",
          "toggling",
          "alloy.base.behaviour"
        ]
      },
      events: A,
      behaviours: Li(t.splitDropdownBehaviours, [
        Ia.config({
          others: {
            sandbox: (H) => {
              const q = uc(H, t, "arrow");
              return DR(t, H, {
                onOpen: () => {
                  ir.on(q), ir.on(H);
                },
                onClose: () => {
                  ir.off(q), ir.off(H);
                }
              });
            }
          }
        }),
        oo.config({
          mode: "special",
          onSpace: T,
          onEnter: T,
          onDown: w
        }),
        Ao.config({}),
        ir.config({
          toggleOnExecute: !1,
          aria: { mode: "expanded" }
        })
      ]),
      domModification: {
        attributes: {
          role: t.role.getOr("button"),
          "aria-haspopup": !0
        }
      }
    };
  }, tA = Vl({
    name: "SplitDropdown",
    configFields: oQ(),
    partFields: aQ(),
    factory: FH,
    apis: { repositionMenus: (t, a) => t.repositionMenus(a) }
  }), BH = (t) => ({
    isEnabled: () => !_o.isDisabled(t),
    setEnabled: (a) => _o.set(t, !a),
    setText: (a) => po(t, wf, { text: a }),
    setIcon: (a) => po(t, ov, { icon: a })
  }), $H = (t) => ({
    setActive: (a) => {
      ir.set(t, a);
    },
    isActive: () => ir.isOn(t),
    isEnabled: () => !_o.isDisabled(t),
    setEnabled: (a) => _o.set(t, !a),
    setText: (a) => po(t, wf, { text: a }),
    setIcon: (a) => po(t, ov, { icon: a })
  }), LH = (t, a) => t.map((c) => ({ "aria-label": a.translate(c) })).getOr({}), TM = Nn("focus-button"), nA = (t, a, c, f, g, x) => {
    const w = a.map((A) => is(wN(A, "tox-tbtn", g))), T = t.map((A) => is(Ng(A, g.icons)));
    return {
      dom: {
        tag: "button",
        classes: ["tox-tbtn"].concat(a.isSome() ? ["tox-tbtn--select"] : []),
        attributes: {
          ...LH(c, g),
          ...Ce(x) ? { "data-mce-name": x } : {}
        }
      },
      components: B1([
        T.map((A) => A.asSpec()),
        w.map((A) => A.asSpec())
      ]),
      eventOrder: {
        [nc()]: [
          "focusing",
          "alloy.base.behaviour",
          Q1
        ],
        [oc()]: [
          Q1,
          "toolbar-group-button-events"
        ]
      },
      buttonBehaviours: Qt([
        rm.toolbarButton(g.isDisabled),
        Si(),
        Go(Q1, [
          Qs((A, F) => bO(A)),
          It(wf, (A, F) => {
            w.bind((H) => H.getOpt(A)).each((H) => {
              No.set(H, [Oa(g.translate(F.event.text))]);
            });
          }),
          It(ov, (A, F) => {
            T.bind((H) => H.getOpt(A)).each((H) => {
              No.set(H, [Ng(F.event.icon, g.icons)]);
            });
          }),
          It(nc(), (A, F) => {
            F.event.prevent(), tr(A, TM);
          })
        ])
      ].concat(f.getOr([])))
    };
  }, iQ = (t, a, c, f, g) => {
    const x = a.shared, w = no(G), T = {
      toolbarButtonBehaviours: [],
      getApi: BH,
      onSetup: t.onSetup
    }, A = [Go("toolbar-group-button-events", [
      Ag(T, w),
      mc(T, w)
    ])];
    return av.sketch({
      lazySink: x.getSink,
      fetch: () => jl.nu((F) => {
        F(tt(c(t.items), UO));
      }),
      markers: { toggledClass: "tox-tbtn--enabled" },
      parts: {
        button: nA(t.icon, t.text, t.tooltip, B.some(A), x.providers, g),
        toolbar: {
          dom: {
            tag: "div",
            classes: ["tox-toolbar__overflow"],
            attributes: f
          }
        }
      }
    });
  }, HH = (t, a, c, f) => {
    var g;
    const x = no(G), w = nA(t.icon, t.text, t.tooltip, B.none(), c, f);
    return Rl.sketch({
      dom: w.dom,
      components: w.components,
      eventOrder: gO,
      buttonBehaviours: {
        ...Qt([
          Go("toolbar-button-events", [
            yN({
              onAction: t.onAction,
              getApi: a.getApi
            }),
            Ag(a, x),
            mc(a, x)
          ]),
          ...t.tooltip.map((T) => gl.config(c.tooltips.getConfig({ tooltipText: c.translate(T) + t.shortcut.map((A) => ` (${FT(A)})`).getOr("") }))).toArray(),
          rm.toolbarButton(() => !t.enabled || c.isDisabled()),
          Si()
        ].concat(a.toolbarButtonBehaviours)),
        [Q1]: (g = w.buttonBehaviours) === null || g === void 0 ? void 0 : g[Q1]
      }
    });
  }, lQ = (t, a, c) => t0(t, a, [], c), t0 = (t, a, c, f) => HH(t, {
    toolbarButtonBehaviours: c.length > 0 ? [Go("toolbarButtonWith", c)] : [],
    getApi: BH,
    onSetup: t.onSetup
  }, a, f), cQ = (t, a, c) => zH(t, a, [], c), zH = (t, a, c, f) => HH(t, {
    toolbarButtonBehaviours: [
      No.config({}),
      ir.config({
        toggleClass: "tox-tbtn--enabled",
        aria: { mode: "pressed" },
        toggleOnExecute: !1
      })
    ].concat(c.length > 0 ? [Go("toolbarToggleButtonWith", c)] : []),
    getApi: $H,
    onSetup: t.onSetup
  }, a, f), uQ = (t, a, c) => (f) => jl.nu((g) => a.fetch(g)).map((g) => B.from(xx(Fs(_R(Nn("menu-value"), g, (x) => {
    a.onItemAction(t(f), x);
  }, a.columns, a.presets, em.CLOSE_ON_EXECUTE, a.select.getOr(wt), c), {
    movement: GT(a.columns, a.presets),
    menuBehaviours: hx.unnamedEvents(a.columns !== "auto" ? [] : [Qs((x, w) => {
      NT(x, 4, UD(a.presets)).each(({ numRows: T, numColumns: A }) => {
        oo.setGridSize(x, T, A);
      });
    })])
  })))), dQ = (t, a, c) => {
    const f = no(t.tooltip.getOr("")), g = (T) => ({
      isEnabled: () => !_o.isDisabled(T),
      setEnabled: (A) => _o.set(T, !A),
      setIconFill: (A, F) => {
        ss(T.element, `svg path[class="${A}"], rect[class="${A}"]`).each((H) => {
          rn(H, "fill", F);
        });
      },
      setActive: (A) => {
        rn(T.element, "aria-pressed", A), ss(T.element, "span").each((F) => {
          T.getSystem().getByDom(F).each((H) => ir.set(H, A));
        });
      },
      isActive: () => ss(T.element, "span").exists((A) => T.getSystem().getByDom(A).exists(ir.isOn)),
      setText: (A) => ss(T.element, "span").each((F) => T.getSystem().getByDom(F).each((H) => po(H, wf, { text: A }))),
      setIcon: (A) => ss(T.element, "span").each((F) => T.getSystem().getByDom(F).each((H) => po(H, ov, { icon: A }))),
      setTooltip: (A) => {
        const F = a.providers.translate(A);
        rn(T.element, "aria-label", F), f.set(A);
      }
    }), x = no(G), w = {
      getApi: g,
      onSetup: t.onSetup
    };
    return tA.sketch({
      dom: {
        tag: "div",
        classes: ["tox-split-button"],
        attributes: {
          "aria-pressed": !1,
          ...LH(t.tooltip, a.providers),
          ...Ce(c) ? { "data-mce-name": c } : {}
        }
      },
      onExecute: (T) => {
        const A = g(T);
        A.isEnabled() && t.onAction(A);
      },
      onItemExecute: (T, A, F) => {
      },
      splitDropdownBehaviours: Qt([
        rm.splitButton(a.providers.isDisabled),
        Si(),
        Go("split-dropdown-events", [
          Qs((T, A) => bO(T)),
          It(TM, Ao.focus),
          Ag(w, x),
          mc(w, x)
        ]),
        Ex.config({}),
        ...t.tooltip.map((T) => gl.config({
          ...a.providers.tooltips.getConfig({
            tooltipText: a.providers.translate(T),
            onShow: (A) => {
              if (f.get() !== T) {
                const F = a.providers.translate(f.get());
                gl.setComponents(A, a.providers.tooltips.getComponents({ tooltipText: F }));
              }
            }
          })
        })).toArray()
      ]),
      eventOrder: {
        [oc()]: [
          "alloy.base.behaviour",
          "split-dropdown-events",
          "tooltipping"
        ],
        [Vu()]: [
          "split-dropdown-events",
          "tooltipping"
        ]
      },
      toggleClass: "tox-tbtn--enabled",
      lazySink: a.getSink,
      fetch: uQ(g, t, a.providers),
      parts: { menu: XC(!1, t.columns, t.presets) },
      components: [
        tA.parts.button(nA(t.icon, t.text, B.none(), B.some([ir.config({
          toggleClass: "tox-tbtn--enabled",
          toggleOnExecute: !1
        })]), a.providers)),
        tA.parts.arrow({
          dom: {
            tag: "button",
            classes: [
              "tox-tbtn",
              "tox-split-button__chevron"
            ],
            innerHtml: c$("chevron-down", a.providers.icons)
          },
          buttonBehaviours: Qt([
            rm.splitButton(a.providers.isDisabled),
            Si(),
            FD()
          ])
        }),
        tA.parts["aria-descriptor"]({ text: a.providers.translate("To open the popup, press Shift+Enter") })
      ]
    });
  }, fQ = [
    {
      name: "history",
      items: [
        "undo",
        "redo"
      ]
    },
    {
      name: "ai",
      items: [
        "aidialog",
        "aishortcuts"
      ]
    },
    {
      name: "styles",
      items: ["styles"]
    },
    {
      name: "formatting",
      items: [
        "bold",
        "italic"
      ]
    },
    {
      name: "alignment",
      items: [
        "alignleft",
        "aligncenter",
        "alignright",
        "alignjustify"
      ]
    },
    {
      name: "indentation",
      items: [
        "outdent",
        "indent"
      ]
    },
    {
      name: "permanent pen",
      items: ["permanentpen"]
    },
    {
      name: "comments",
      items: ["addcomment"]
    }
  ], KS = (t, a) => (c, f, g, x) => {
    const w = t(c).mapError((T) => Bu(T)).getOrDie();
    return a(w, f, g, x);
  }, mQ = {
    button: KS(nm, (t, a, c, f) => lQ(t, a.shared.providers, f)),
    togglebutton: KS(AT, (t, a, c, f) => cQ(t, a.shared.providers, f)),
    menubutton: KS(BO, (t, a, c, f) => PS(t, "tox-tbtn", a, B.none(), !1, f)),
    splitbutton: KS(jS, (t, a, c, f) => dQ(t, a.shared, f)),
    grouptoolbarbutton: KS(JN, (t, a, c, f) => {
      const g = c.ui.registry.getAll().buttons, x = (T) => rA(c, {
        buttons: g,
        toolbar: T,
        allowToolbarGroups: !1
      }, a, B.none()), w = { [Vp]: a.shared.header.isPositionedAtTop() ? zp.TopToBottom : zp.BottomToTop };
      switch (A1(c)) {
        case Yu.floating:
          return iQ(t, a, x, w, f);
        default:
          throw new Error("Toolbar groups are only supported when using floating toolbar mode");
      }
    })
  }, pQ = (t, a, c, f) => Ht(mQ, t.type).fold(() => (console.error("skipping button defined by", t), B.none()), (g) => B.some(g(t, a, c, f))), oA = {
    styles: tQ,
    fontsize: MH,
    fontsizeinput: QX,
    fontfamily: HX,
    blocks: wH,
    align: IX
  }, hQ = (t) => {
    const a = tt(fQ, (c) => {
      const f = To(c.items, (g) => Ho(t, g) || Ho(oA, g));
      return {
        name: c.name,
        items: f
      };
    });
    return To(a, (c) => c.items.length > 0);
  }, gQ = (t) => {
    const a = t.split("|");
    return tt(a, (c) => ({ items: c.trim().split(" ") }));
  }, VH = (t) => ae(t, (a) => Ho(a, "name") && Ho(a, "items")), jH = (t) => {
    const a = t.toolbar, c = t.buttons;
    return a === !1 ? [] : a === void 0 || a === !0 ? hQ(c) : _(a) ? gQ(a) : VH(a) ? a : (console.error("Toolbar type should be string, string[], boolean or ToolbarGroup[]"), []);
  }, bQ = (t, a, c, f, g, x) => Ht(a, c.toLowerCase()).orThunk(() => x.bind((w) => Ko(w, (T) => Ht(a, T + c.toLowerCase())))).fold(() => Ht(oA, c.toLowerCase()).map((w) => w(t, g)), (w) => w.type === "grouptoolbarbutton" && !f ? (console.warn(`Ignoring the '${c}' toolbar button. Group toolbar buttons are only supported when using floating toolbar mode and cannot be nested.`), B.none()) : pQ(w, g, t, c.toLowerCase())), rA = (t, a, c, f) => {
    const g = jH(a), x = tt(g, (w) => {
      const T = Ue(w.items, (A) => A.trim().length === 0 ? [] : bQ(t, a.buttons, A, a.allowToolbarGroups, c, f).toArray());
      return {
        title: B.from(t.translate(w.name)),
        items: T
      };
    });
    return To(x, (w) => w.items.length > 0);
  }, UH = (t, a, c, f) => {
    const g = a.mainUi.outerContainer, x = c.toolbar, w = c.buttons;
    if (ae(x, _)) {
      const T = x.map((A) => {
        const F = {
          toolbar: A,
          buttons: w,
          allowToolbarGroups: c.allowToolbarGroups
        };
        return rA(t, F, f, B.none());
      });
      Gs.setToolbars(g, T);
    } else
      Gs.setToolbar(g, rA(t, c, f, B.none()));
  }, WH = Fl(), vQ = WH.os.isiOS() && WH.os.version.major <= 12, yQ = (t, a) => {
    const { uiMotherships: c } = a, f = t.dom;
    let g = t.getWin();
    const x = t.getDoc().documentElement, w = no(zs(g.innerWidth, g.innerHeight)), T = no(zs(x.offsetWidth, x.offsetHeight)), A = () => {
      const ne = w.get();
      (ne.left !== g.innerWidth || ne.top !== g.innerHeight) && (w.set(zs(g.innerWidth, g.innerHeight)), bx(t));
    }, F = () => {
      const ne = t.getDoc().documentElement, ie = T.get();
      (ie.left !== ne.offsetWidth || ie.top !== ne.offsetHeight) && (T.set(zs(ne.offsetWidth, ne.offsetHeight)), bx(t));
    }, H = (ne) => {
      uL(t, ne);
    };
    f.bind(g, "resize", A), f.bind(g, "scroll", H);
    const q = M2(He.fromDom(t.getBody()), "load", F);
    t.on("hide", () => {
      mt(c, (ne) => {
        Ln(ne.element, "display", "none");
      });
    }), t.on("show", () => {
      mt(c, (ne) => {
        xr(ne.element, "display");
      });
    }), t.on("NodeChange", F), t.on("remove", () => {
      q.unbind(), f.unbind(g, "resize", A), f.unbind(g, "scroll", H), g = null;
    });
  }, ZH = (t, a, c) => {
    qb(t) && qf(c.mainUi.mothership.element, c.popupUi.mothership), fE(a, c.dialogUi.mothership);
  };
  var xQ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    render: (t, a, c, f, g) => {
      const { mainUi: x, uiMotherships: w } = a, T = no(0), A = x.outerContainer;
      PX(t);
      const F = He.fromDom(g.targetNode), H = Ae(le(F));
      qf(F, x.mothership), ZH(t, H, a), t.on("SkinLoaded", () => {
        Gs.setSidebar(A, c.sidebar, GB(t)), UH(t, a, c, f), T.set(t.getWin().innerWidth), Gs.setMenubar(A, pH(t, c)), Gs.setViews(A, c.views), yQ(t, a);
      });
      const q = Gs.getSocket(A).getOrDie("Could not find expected socket element");
      if (vQ) {
        Rs(q.element, {
          overflow: "scroll",
          "-webkit-overflow-scrolling": "touch"
        });
        const _e = _q(() => {
          t.dispatch("ScrollContent");
        }, 20), st = lc(q.element, "scroll", _e.throttle);
        t.on("remove", st.unbind);
      }
      MT(t, a), t.addCommand("ToggleSidebar", (_e, st) => {
        Gs.toggleSidebar(A, st), t.dispatch("ToggleSidebar");
      }), t.addQueryValueHandler("ToggleSidebar", () => {
        var _e;
        return (_e = Gs.whichSidebar(A)) !== null && _e !== void 0 ? _e : "";
      }), t.addCommand("ToggleView", (_e, st) => {
        if (Gs.toggleView(A, st)) {
          const De = A.element;
          x.mothership.broadcastOn([Kf()], { target: De }), mt(w, (Je) => {
            Je.broadcastOn([Kf()], { target: De });
          }), se(Gs.whichView(A)) && (t.focus(), t.nodeChanged(), Gs.refreshToolbar(A));
        }
      }), t.addQueryValueHandler("ToggleView", () => {
        var _e;
        return (_e = Gs.whichView(A)) !== null && _e !== void 0 ? _e : "";
      });
      const ne = A1(t), ie = () => {
        Gs.refreshToolbar(a.mainUi.outerContainer);
      };
      (ne === Yu.sliding || ne === Yu.floating) && t.on("ResizeWindow ResizeEditor ResizeContent", () => {
        const _e = t.getWin().innerWidth;
        _e !== T.get() && (ie(), T.set(_e));
      });
      const fe = {
        setEnabled: (_e) => {
          aS(a, !_e);
        },
        isEnabled: () => !_o.isDisabled(A)
      };
      return {
        iframeContainer: q.element.dom,
        editorContainer: A.element.dom,
        api: fe
      };
    }
  });
  const GH = (t) => /^[0-9\.]+(|px)$/i.test("" + t) ? B.some(parseInt("" + t, 10)) : B.none(), OM = (t) => oe(t) ? t + "px" : t, n0 = (t, a, c) => {
    const f = a.filter((x) => t < x), g = c.filter((x) => t > x);
    return f.or(g).getOr(t);
  }, wQ = (t) => {
    const a = aD(t), c = KE(t), f = iD(t);
    return GH(a).map((g) => n0(g, c, f));
  }, sA = (t) => wQ(t).getOr(aD(t)), YS = (t) => {
    const a = O1(t), c = cx(t), f = $C(t);
    return GH(a).map((g) => n0(g, c, f));
  }, qH = (t) => YS(t).getOr(O1(t)), { ToolbarLocation: AM, ToolbarMode: KH } = ZU, CQ = 40, SQ = (t, a, c, f, g) => {
    const { mainUi: x, uiMotherships: w } = c, T = T1.DOM, A = ux(t), F = dx(t), H = $C(t).or(YS(t)), q = f.shared.header, ne = q.isPositionedAtTop, ie = 150, fe = A1(t), _e = fe === KH.sliding || fe === KH.floating, st = no(!1), De = () => st.get() && !t.removed, Je = (br) => _e ? br.fold(te(0), (cn) => cn.components().length > 1 ? Bs(cn.components()[1].element) : 0) : 0, Ge = (br) => {
      switch (cD(t)) {
        case AM.auto:
          const cn = Gs.getToolbar(x.outerContainer), Un = Je(cn), jo = Bs(br.element) - Un, So = aa(a);
          if (So.y > jo)
            return "top";
          {
            const Lo = Oi(a), Os = Math.max(Lo.dom.scrollHeight, Bs(Lo));
            return So.bottom < Os - jo || Ra().bottom < So.bottom - jo ? "bottom" : "top";
          }
        case AM.bottom:
          return "bottom";
        case AM.top:
        default:
          return "top";
      }
    }, Ft = (br) => {
      g.on((cn) => {
        pa.setModes(cn, [br]), q.setDockingMode(br);
        const Un = ne() ? zp.TopToBottom : zp.BottomToTop;
        rn(cn.element, Vp, Un);
      });
    }, gt = () => {
      g.on((br) => {
        const cn = H.getOrThunk(() => xm().width - xi(a).left - 10);
        Ln(br.element, "max-width", cn + "px");
      });
    }, Jt = (br, cn) => {
      g.on((Un) => {
        const jo = Gs.getToolbar(x.outerContainer), So = Je(jo), go = aa(a), Lo = vn(t, x.outerContainer.element), Os = () => Lo.fold(() => go.x, (Wl) => {
          const Bd = aa(Wl);
          return Lr(Wl, Uo()) ? go.x : go.x - Bd.x;
        }), Qr = () => Lo.fold(() => ne() ? Math.max(go.y - Bs(Un.element) + So, 0) : go.bottom, (Wl) => {
          var Bd;
          const _f = aa(Wl), Eu = (Bd = Wl.dom.scrollTop) !== null && Bd !== void 0 ? Bd : 0, u0 = Lr(Wl, Uo()) ? Math.max(go.y - Bs(Un.element) + So, 0) : go.y - _f.y + Eu - Bs(Un.element) + So;
          return ne() ? u0 : go.bottom;
        }), gc = Os(), Fd = Xn(br, Math.ceil(x.outerContainer.element.dom.getBoundingClientRect().width)).filter((Wl) => Wl > ie).map((Wl) => {
          const Bd = cn.getOr(wi()), _f = window.innerWidth - (gc - Bd.left), Eu = Math.max(Math.min(Wl, _f), ie);
          return _f < Wl && Ln(x.outerContainer.element, "width", Eu + "px"), { width: Eu + "px" };
        }).getOr({ width: "max-content" }), ep = {
          position: "absolute",
          left: Math.round(gc) + "px",
          top: Qr() + "px"
        };
        Rs(x.outerContainer.element, {
          ...ep,
          ...Fd
        });
      });
    }, vn = (br, cn) => qb(br) ? Pp(cn) : B.none(), Nt = () => {
      mt(w, (br) => {
        br.broadcastOn([bg()], {});
      });
    }, Yn = () => !A && (Ga(x.outerContainer.element).left + li(x.outerContainer.element) >= window.innerWidth - CQ || ks(x.outerContainer.element, "width").isSome()) ? (Ln(x.outerContainer.element, "position", "absolute"), Ln(x.outerContainer.element, "left", "0px"), xr(x.outerContainer.element, "width"), !0) : !1, In = (br) => {
      if (!De())
        return;
      A || gt();
      const cn = wi(), Un = A ? !1 : Yn();
      if (_e && Gs.refreshToolbar(x.outerContainer), !A) {
        const jo = wi(), So = Xn(cn.left !== jo.left, cn);
        Jt(Un, So), So.each((go) => {
          cp(go.left, jo.top);
        });
      }
      F && g.on(br), Nt();
    }, xo = () => A || !F || !De() ? !1 : g.get().exists((br) => {
      const cn = q.getDockingMode(), Un = Ge(br);
      return Un !== cn ? (Ft(Un), !0) : !1;
    });
    return {
      isVisible: De,
      isPositionedAtTop: ne,
      show: () => {
        st.set(!0), Ln(x.outerContainer.element, "display", "flex"), T.addClass(t.getBody(), "mce-edit-focus"), mt(w, (br) => {
          xr(br.element, "display");
        }), xo(), qb(t) ? In((br) => pa.isDocked(br) ? pa.reset(br) : pa.refresh(br)) : In(pa.refresh);
      },
      hide: () => {
        st.set(!1), Ln(x.outerContainer.element, "display", "none"), T.removeClass(t.getBody(), "mce-edit-focus"), mt(w, (br) => {
          Ln(br.element, "display", "none");
        });
      },
      update: In,
      updateMode: () => {
        xo() && In(pa.reset);
      },
      repositionPopups: Nt
    };
  }, YH = (t, a) => {
    const c = aa(t);
    return {
      pos: a ? c.y : c.bottom,
      bounds: c
    };
  }, aA = (t, a, c, f) => {
    const g = no(YH(a, c.isPositionedAtTop())), x = (F) => {
      const { pos: H, bounds: q } = YH(a, c.isPositionedAtTop()), {
        pos: ne,
        bounds: ie
      } = g.get(), fe = q.height !== ie.height || q.width !== ie.width;
      g.set({
        pos: H,
        bounds: q
      }), fe && bx(t, F), c.isVisible() && (ne !== H ? c.update(pa.reset) : fe && (c.updateMode(), c.repositionPopups()));
    };
    f || (t.on("activate", c.show), t.on("deactivate", c.hide)), t.on("SkinLoaded ResizeWindow", () => c.update(pa.reset)), t.on("NodeChange keydown", (F) => {
      requestAnimationFrame(() => x(F));
    });
    let w = 0;
    const T = mN(() => c.update(pa.refresh), 33);
    t.on("ScrollWindow", () => {
      const F = wi().left;
      F !== w && (w = F, T.throttle()), c.updateMode();
    }), qb(t) && t.on("ElementScroll", (F) => {
      c.update(pa.refresh);
    });
    const A = za();
    A.set(M2(He.fromDom(t.getBody()), "load", (F) => x(F.raw))), t.on("remove", () => {
      A.clear();
    });
  };
  var XH = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    render: (t, a, c, f, g) => {
      const { mainUi: x } = a, w = ms(), T = He.fromDom(g.targetNode), A = SQ(t, T, a, f, w), F = LB(t);
      DX(t);
      const H = () => {
        if (w.isSet()) {
          A.show();
          return;
        }
        w.set(Gs.getHeader(x.outerContainer).getOrDie());
        const ne = HC(t);
        qb(t) ? (qf(T, x.mothership), qf(T, a.popupUi.mothership)) : fE(ne, x.mothership), fE(ne, a.dialogUi.mothership);
        const ie = () => {
          UH(t, a, c, f), Gs.setMenubar(x.outerContainer, pH(t, c)), A.show(), aA(t, T, A, F), t.nodeChanged();
        };
        F ? t.once("SkinLoaded", ie) : ie();
      };
      t.on("show", H), t.on("hide", A.hide), F || (t.on("focus", H), t.on("blur", A.hide)), t.on("init", () => {
        (t.hasFocus() || F) && H();
      }), MT(t, a);
      const q = {
        show: H,
        hide: A.hide,
        setEnabled: (ne) => {
          aS(a, !ne);
        },
        isEnabled: () => !_o.isDisabled(x.outerContainer)
      };
      return {
        editorContainer: x.outerContainer.element.dom,
        api: q
      };
    }
  });
  const QH = () => {
    const t = ms(), a = ms(), c = ms();
    return {
      dialogUi: t,
      popupUi: a,
      mainUi: c,
      getUiMotherships: () => {
        const x = t.get().map((T) => T.mothership), w = a.get().map((T) => T.mothership);
        return x.fold(() => w.toArray(), (T) => w.fold(() => [T], (A) => Lr(T.element, A.element) ? [T] : [
          T,
          A
        ]));
      },
      lazyGetInOuterOrDie: (x, w) => () => c.get().bind((T) => w(T.outerContainer)).getOrDie(`Could not find ${x} element in OuterContainer`)
    };
  }, JH = "contexttoolbar-show", ez = "contexttoolbar-hide", tz = (t) => ({
    hide: () => tr(t, Rv()),
    getValue: () => Mn.getValue(t)
  }), nz = (t, a) => It(a8, (c, f) => {
    const g = t.get(c), x = tz(g);
    a.onAction(x, f.event.buttonApi);
  }), _Q = (t, a, c) => {
    const { primary: f, ...g } = a.original, x = Zt(nm({
      ...g,
      type: "button",
      onAction: G
    }));
    return t0(x, c, [nz(t, a)]);
  }, EQ = (t, a, c) => {
    const { primary: f, ...g } = a.original, x = Zt(AT({
      ...g,
      type: "togglebutton",
      onAction: G
    }));
    return zH(x, c, [nz(t, a)]);
  }, TQ = (t) => t.type === "contextformtogglebutton", OQ = (t, a, c) => TQ(a) ? EQ(t, a, c) : _Q(t, a, c), XS = (t, a, c) => {
    const f = tt(a, (w) => is(OQ(t, w, c)));
    return {
      asSpecs: () => tt(f, (w) => w.asSpec()),
      findPrimary: (w) => Ko(a, (T, A) => T.primary ? B.from(f[A]).bind((F) => F.getOpt(w)).filter(je(_o.isDisabled)) : B.none())
    };
  }, oz = (t, a) => {
    const c = t.label.fold(() => ({}), (x) => ({ "aria-label": x })), f = is(N1.sketch({
      inputClasses: [
        "tox-toolbar-textfield",
        "tox-toolbar-nav-js"
      ],
      data: t.initValue(),
      inputAttributes: c,
      selectOnFocus: !0,
      inputBehaviours: Qt([oo.config({
        mode: "special",
        onEnter: (x) => g.findPrimary(x).map((w) => (Tp(w), !0)),
        onLeft: (x, w) => (w.cut(), B.none()),
        onRight: (x, w) => (w.cut(), B.none())
      })])
    })), g = XS(f, t.commands, a);
    return [
      {
        title: B.none(),
        items: [f.asSpec()]
      },
      {
        title: B.none(),
        items: g.asSpecs()
      }
    ];
  }, AQ = {
    renderContextForm: (t, a, c) => WO({
      type: t,
      uid: Nn("context-toolbar"),
      initGroups: oz(a, c),
      onEscape: B.none,
      cyclicKeying: !0,
      providers: c
    }),
    buildInitGroups: oz
  }, PM = (t, a, c) => a.bottom - t.y >= c && t.bottom - a.y >= c, PQ = (t) => {
    const a = t.getBoundingClientRect();
    if (a.height <= 0 && a.width <= 0) {
      const c = ld(He.fromDom(t.startContainer), t.startOffset).element;
      return (Yo(c) ? Za(c) : B.some(c)).filter(ko).map((g) => g.dom.getBoundingClientRect()).getOr(a);
    } else
      return a;
  }, iA = (t) => {
    const a = t.selection.getRng(), c = PQ(a);
    if (t.inline) {
      const f = wi();
      return Is(f.left + c.left, f.top + c.top, c.width, c.height);
    } else {
      const f = Cl(He.fromDom(t.getBody()));
      return Is(f.x + c.left, f.y + c.top, c.width, c.height);
    }
  }, DQ = (t, a) => a.filter((c) => yr(c) && Ti(c)).map(Cl).getOrThunk(() => iA(t)), RQ = (t, a, c) => {
    const f = Math.max(t.x + c, a.x), g = Math.min(t.right - c, a.right);
    return {
      x: f,
      width: g - f
    };
  }, NQ = (t, a, c, f, g, x) => {
    const w = He.fromDom(t.getContainer()), T = ss(w, ".tox-editor-header").getOr(w), A = aa(T), F = A.y >= a.bottom, H = f && !F;
    if (t.inline && H)
      return {
        y: Math.max(A.bottom + x, c.y),
        bottom: c.bottom
      };
    if (t.inline && !H)
      return {
        y: c.y,
        bottom: Math.min(A.y - x, c.bottom)
      };
    const q = g === "line" ? aa(w) : a;
    return H ? {
      y: Math.max(A.bottom + x, c.y),
      bottom: Math.min(q.bottom - x, c.bottom)
    } : {
      y: Math.max(q.y + x, c.y),
      bottom: Math.min(A.y - x, c.bottom)
    };
  }, rz = (t, a, c, f = 0) => {
    const g = xm(window), x = aa(He.fromDom(t.getContentAreaContainer())), w = nT(t) || rT(t) || P1(t), { x: T, width: A } = RQ(x, g, f);
    if (t.inline && !w)
      return Is(T, g.y, A, g.height);
    {
      const F = a.header.isPositionedAtTop(), { y: H, bottom: q } = NQ(t, x, g, F, c, f);
      return Is(T, H, A, q - H);
    }
  }, lA = 12, qx = {
    valignCentre: [],
    alignCentre: [],
    alignLeft: ["tox-pop--align-left"],
    alignRight: ["tox-pop--align-right"],
    right: ["tox-pop--right"],
    left: ["tox-pop--left"],
    bottom: ["tox-pop--bottom"],
    top: ["tox-pop--top"],
    inset: ["tox-pop--inset"]
  }, DM = {
    maxHeightFunction: Eb(),
    maxWidthFunction: jx()
  }, MQ = (t, a) => {
    const c = t.selection.getRng(), f = ld(He.fromDom(c.startContainer), c.startOffset);
    return c.startContainer === c.endContainer && c.startOffset === c.endOffset - 1 && Lr(f.element, a);
  }, IQ = (t, a, c) => {
    const f = ks(t, "position");
    Ln(t, "position", a);
    const g = c(t);
    return f.each((x) => Ln(t, "position", x)), g;
  }, RM = (t) => t === "node", NM = (t, a, c, f, g) => {
    const x = iA(t), w = f.lastElement().exists((T) => Lr(c, T));
    if (MQ(t, c))
      return w ? BS : cm;
    if (w)
      return IQ(a, f.getMode(), () => PM(x, aa(a), -20) && !f.isReposition() ? X8 : BS);
    {
      const T = f.getMode() === "fixed" ? g.y + wi().top : g.y, A = Bs(a) + lA;
      return T + A <= x.y ? cm : FS;
    }
  }, sz = (t, a, c, f) => {
    const g = (A) => (F, H, q, ne, ie) => {
      const fe = NM(t, ne, A, c, ie), _e = {
        ...F,
        y: ie.y,
        height: ie.height
      };
      return {
        ...fe(_e, H, q, ne, ie),
        alwaysFit: !0
      };
    }, x = (A) => RM(f) ? [g(A)] : [];
    return a ? {
      onLtr: (A) => [
        ti,
        di,
        ei,
        fi,
        xs,
        Ci
      ].concat(x(A)),
      onRtl: (A) => [
        ti,
        ei,
        di,
        xs,
        fi,
        Ci
      ].concat(x(A))
    } : {
      onLtr: (A) => [
        Ci,
        ti,
        fi,
        di,
        xs,
        ei
      ].concat(x(A)),
      onRtl: (A) => [
        Ci,
        ti,
        xs,
        ei,
        fi,
        di
      ].concat(x(A))
    };
  }, az = (t, a, c, f) => a === "line" ? {
    bubble: _d(lA, 0, qx),
    layouts: {
      onLtr: () => [E2],
      onRtl: () => [ly]
    },
    overrides: DM
  } : {
    bubble: _d(0, lA, qx, 1 / lA),
    layouts: sz(t, c, f, a),
    overrides: DM
  }, MM = (t, a) => {
    const c = To(a, (x) => x.predicate(t.dom)), { pass: f, fail: g } = Wo(c, (x) => x.type === "contexttoolbar");
    return {
      contextToolbars: f,
      contextForms: g
    };
  }, Kx = (t) => {
    if (t.length <= 1)
      return t;
    {
      const a = (x) => Fn(t, (w) => w.position === x), c = (x) => To(t, (w) => w.position === x), f = a("selection"), g = a("node");
      if (f || g)
        if (g && f) {
          const x = c("node"), w = tt(c("selection"), (T) => ({
            ...T,
            position: "node"
          }));
          return x.concat(w);
        } else
          return c(f ? "selection" : "node");
      else
        return c("line");
    }
  }, cA = (t) => {
    if (t.length <= 1)
      return t;
    {
      const a = (f) => At(t, (g) => g.position === f);
      return a("selection").orThunk(() => a("node")).orThunk(() => a("line")).map((f) => f.position).fold(() => [], (f) => To(t, (g) => g.position === f));
    }
  }, uA = (t, a, c) => {
    const f = MM(t, a);
    if (f.contextForms.length > 0)
      return B.some({
        elem: t,
        toolbars: [f.contextForms[0]]
      });
    {
      const g = MM(t, c);
      if (g.contextForms.length > 0)
        return B.some({
          elem: t,
          toolbars: [g.contextForms[0]]
        });
      if (f.contextToolbars.length > 0 || g.contextToolbars.length > 0) {
        const x = Kx(f.contextToolbars.concat(g.contextToolbars));
        return B.some({
          elem: t,
          toolbars: x
        });
      } else
        return B.none();
    }
  }, IM = (t, a, c) => t(a) ? B.none() : xd(a, (f) => {
    if (ko(f)) {
      const { contextToolbars: g, contextForms: x } = MM(f, c.inNodeScope), w = x.length > 0 ? x : cA(g);
      return w.length > 0 ? B.some({
        elem: f,
        toolbars: w
      }) : B.none();
    } else
      return B.none();
  }, t), FM = (t, a) => {
    const c = He.fromDom(a.getBody()), f = (w) => Lr(w, c), g = (w) => !f(w) && !ka(c, w), x = He.fromDom(a.selection.getNode());
    return g(x) ? B.none() : uA(x, t.inNodeScope, t.inEditorScope).orThunk(() => IM(f, x, t));
  }, iz = (t, a) => {
    const c = {}, f = [], g = [], x = {}, w = {}, T = (H, q) => {
      const ne = Zt(BW(q));
      c[H] = ne, ne.launch.map((ie) => {
        x["form:" + H] = {
          ...q.launch,
          type: ie.type === "contextformtogglebutton" ? "togglebutton" : "button",
          onAction: () => {
            a(ne);
          }
        };
      }), ne.scope === "editor" ? g.push(ne) : f.push(ne), w[H] = ne;
    }, A = (H, q) => {
      hf(q).each((ne) => {
        q.scope === "editor" ? g.push(ne) : f.push(ne), w[H] = ne;
      });
    }, F = Qo(t);
    return mt(F, (H) => {
      const q = t[H];
      q.type === "contextform" ? T(H, q) : q.type === "contexttoolbar" && A(H, q);
    }), {
      forms: c,
      inNodeScope: f,
      inEditorScope: g,
      lookupTable: w,
      formNavigators: x
    };
  }, QS = Nn("forward-slide"), BM = Nn("backward-slide"), dA = Nn("change-slide-event"), JS = "tox-pop--resizing", FQ = (t) => {
    const a = no([]);
    return la.sketch({
      dom: {
        tag: "div",
        classes: ["tox-pop"]
      },
      fireDismissalEventInstead: { event: "doNotDismissYet" },
      onShow: (c) => {
        a.set([]), la.getContent(c).each((f) => {
          xr(f.element, "visibility");
        }), va(c.element, JS), xr(c.element, "width");
      },
      inlineBehaviours: Qt([
        Go("context-toolbar-events", [
          ib(Qd(), (c, f) => {
            f.event.raw.propertyName === "width" && (va(c.element, JS), xr(c.element, "width"));
          }),
          It(dA, (c, f) => {
            const g = c.element;
            xr(g, "width");
            const x = Pi(g);
            la.setContent(c, f.event.contents), Us(g, JS);
            const w = Pi(g);
            Ln(g, "width", x + "px"), la.getContent(c).each((T) => {
              f.event.focus.bind((A) => (mu(A), ic(g))).orThunk(() => (oo.focusIn(T), uf(le(g))));
            }), setTimeout(() => {
              Ln(c.element, "width", w + "px");
            }, 0);
          }),
          It(QS, (c, f) => {
            la.getContent(c).each((g) => {
              a.set(a.get().concat([{
                bar: g,
                focus: uf(le(c.element))
              }]));
            }), po(c, dA, {
              contents: f.event.forwardContents,
              focus: B.none()
            });
          }),
          It(BM, (c, f) => {
            pr(a.get()).each((g) => {
              a.set(a.get().slice(0, a.get().length - 1)), po(c, dA, {
                contents: Ll(g.bar),
                focus: g.focus
              });
            });
          })
        ]),
        oo.config({
          mode: "special",
          onEscape: (c) => pr(a.get()).fold(() => t.onEscape(), (f) => (tr(c, BM), B.some(!0)))
        })
      ]),
      lazySink: () => zo.value(t.sink)
    });
  }, fA = "tox-pop--transition", BQ = (t, a, c, f) => {
    const g = f.backstage, x = g.shared, w = Fl().deviceType.isTouch, T = ms(), A = ms(), F = ms(), H = Al(FQ({
      sink: c,
      onEscape: () => (t.focus(), B.some(!0))
    })), q = () => {
      const In = F.get().getOr("node"), xo = RM(In) ? 1 : 0;
      return rz(t, x, In, xo);
    }, ne = () => !t.removed && !(w() && g.isContextMenuOpen()), ie = (In) => ra(xa(In, T.get(), Lr), !0), fe = () => {
      if (ne()) {
        const In = q(), xo = ra(F.get(), "node") ? DQ(t, T.get()) : iA(t);
        return In.height <= 0 || !PM(xo, In, 0.01);
      } else
        return !0;
    }, _e = () => {
      T.clear(), A.clear(), F.clear(), la.hide(H);
    }, st = () => {
      if (la.isOpen(H)) {
        const In = H.element;
        xr(In, "display"), fe() ? Ln(In, "display", "none") : (A.set(0), la.reposition(H));
      }
    }, De = (In) => ({
      dom: {
        tag: "div",
        classes: ["tox-pop__dialog"]
      },
      components: [In],
      behaviours: Qt([
        oo.config({ mode: "acyclic" }),
        Go("pop-dialog-wrap-events", [
          Qs((xo) => {
            t.shortcuts.add("ctrl+F9", "focus statusbar", () => oo.focusIn(xo));
          }),
          zf((xo) => {
            t.shortcuts.remove("ctrl+F9");
          })
        ])
      ])
    }), Je = Te(() => iz(a, (In) => {
      const xo = gt([In]);
      po(H, QS, { forwardContents: De(xo) });
    })), Ge = (In, xo) => rA(t, {
      buttons: In,
      toolbar: xo.items,
      allowToolbarGroups: !1
    }, f.backstage, B.some(["form:"])), Ft = (In, xo) => AQ.buildInitGroups(In, xo), gt = (In) => {
      const { buttons: xo } = t.ui.registry.getAll(), fo = Je(), Gr = {
        ...xo,
        ...fo.formNavigators
      }, Hr = A1(t) === Yu.scrolling ? Yu.scrolling : Yu.default, br = en(tt(In, (cn) => cn.type === "contexttoolbar" ? Ge(Gr, cn) : Ft(cn, x.providers)));
      return WO({
        type: Hr,
        uid: Nn("context-toolbar"),
        initGroups: br,
        onEscape: B.none,
        cyclicKeying: !0,
        providers: x.providers
      });
    }, Jt = (In, xo) => {
      const fo = In === "node" ? x.anchors.node(xo) : x.anchors.cursor(), Gr = az(t, In, w(), {
        lastElement: T.get,
        isReposition: () => ra(A.get(), 0),
        getMode: () => tl.getMode(c)
      });
      return Fs(fo, Gr);
    }, vn = (In, xo) => {
      if (Yn.cancel(), !ne())
        return;
      const fo = gt(In), Gr = In[0].position, Hr = Jt(Gr, xo);
      F.set(Gr), A.set(1);
      const br = H.element;
      xr(br, "display"), ie(xo) || (va(br, fA), tl.reset(c, H)), la.showWithinBounds(H, De(fo), {
        anchor: Hr,
        transition: {
          classes: [fA],
          mode: "placement"
        }
      }, () => B.some(q())), xo.fold(T.clear, T.set), fe() && Ln(br, "display", "none");
    };
    let Nt = !1;
    const Yn = mN(() => {
      if (!(!t.hasFocus() || t.removed || Nt))
        if (Zc(H.element, fA))
          Yn.throttle();
        else {
          const In = Je();
          FM(In, t).fold(_e, (xo) => {
            vn(xo.toolbars, B.some(xo.elem));
          });
        }
    }, 17);
    t.on("init", () => {
      t.on("remove", _e), t.on("ScrollContent ScrollWindow ObjectResized ResizeEditor longpress", st), t.on("click keyup focus SetContent", Yn.throttle), t.on(ez, _e), t.on(JH, (In) => {
        const xo = Je();
        Ht(xo.lookupTable, In.toolbarKey).each((fo) => {
          vn([fo], Xn(In.target !== t, In.target)), la.getContent(H).each(oo.focusIn);
        });
      }), t.on("focusout", (In) => {
        FC.setEditorTimeout(t, () => {
          ic(c.element).isNone() && ic(H.element).isNone() && _e();
        }, 0);
      }), t.on("SwitchMode", () => {
        t.mode.isReadOnly() && _e();
      }), t.on("ExecCommand", ({ command: In }) => {
        In.toLowerCase() === "toggleview" && _e();
      }), t.on("AfterProgressState", (In) => {
        In.state ? _e() : t.hasFocus() && Yn.throttle();
      }), t.on("dragstart", () => {
        Nt = !0;
      }), t.on("dragend drop", () => {
        Nt = !1;
      }), t.on("NodeChange", (In) => {
        ic(H.element).fold(Yn.throttle, G);
      });
    });
  }, $Q = (t) => {
    mt([
      {
        name: "alignleft",
        text: "Align left",
        cmd: "JustifyLeft",
        icon: "align-left"
      },
      {
        name: "aligncenter",
        text: "Align center",
        cmd: "JustifyCenter",
        icon: "align-center"
      },
      {
        name: "alignright",
        text: "Align right",
        cmd: "JustifyRight",
        icon: "align-right"
      },
      {
        name: "alignjustify",
        text: "Justify",
        cmd: "JustifyFull",
        icon: "align-justify"
      }
    ], (c) => {
      t.ui.registry.addToggleButton(c.name, {
        tooltip: c.text,
        icon: c.icon,
        onAction: Ju(t, c.cmd),
        onSetup: VT(t, c.name)
      });
    }), t.ui.registry.addButton("alignnone", {
      tooltip: "No alignment",
      icon: "align-none",
      onSetup: Rc(t),
      onAction: Ju(t, "JustifyNone")
    });
  }, ek = (t, a) => {
    const c = () => {
      const f = a.getOptions(t), g = a.getCurrent(t).map(a.hash), x = ms();
      return tt(f, (w) => ({
        type: "togglemenuitem",
        text: a.display(w),
        onSetup: (T) => {
          const A = (H) => {
            H && (x.on((q) => q.setActive(!1)), x.set(T)), T.setActive(H);
          };
          A(ra(g, a.hash(w)));
          const F = a.watcher(t, w, A);
          return () => {
            x.clear(), F();
          };
        },
        onAction: () => a.setCurrent(t, w)
      }));
    };
    t.ui.registry.addMenuButton(a.name, {
      tooltip: a.text,
      icon: a.icon,
      fetch: (f) => f(c()),
      onSetup: a.onToolbarSetup
    }), t.ui.registry.addNestedMenuItem(a.name, {
      type: "nestedmenuitem",
      text: a.text,
      getSubmenuItems: c,
      onSetup: a.onMenuSetup
    });
  }, lz = (t) => ({
    name: "lineheight",
    text: "Line height",
    icon: "line-height",
    getOptions: bD,
    hash: (a) => UX(a, [
      "fixed",
      "relative",
      "empty"
    ]).getOr(a),
    display: lt,
    watcher: (a, c, f) => a.formatter.formatChanged("lineheight", f, !1, { value: c }).unbind,
    getCurrent: (a) => B.from(a.queryCommandValue("LineHeight")),
    setCurrent: (a, c) => a.execCommand("LineHeight", !1, c),
    onToolbarSetup: Rc(t),
    onMenuSetup: Rc(t)
  }), LQ = (t) => B.from(YE(t)).map((c) => ({
    name: "language",
    text: "Language",
    icon: "language",
    getOptions: te(c),
    hash: (f) => be(f.customCode) ? f.code : `${f.code}/${f.customCode}`,
    display: (f) => f.title,
    watcher: (f, g, x) => {
      var w;
      return f.formatter.formatChanged("lang", x, !1, {
        value: g.code,
        customValue: (w = g.customCode) !== null && w !== void 0 ? w : null
      }).unbind;
    },
    getCurrent: (f) => {
      const g = He.fromDom(f.selection.getNode());
      return Ff(g, (x) => B.some(x).filter(ko).bind((w) => K(w, "lang").map((A) => {
        const F = K(w, "data-mce-lang").getOrUndefined();
        return {
          code: A,
          customCode: F,
          title: ""
        };
      })));
    },
    setCurrent: (f, g) => f.execCommand("Lang", !1, g),
    onToolbarSetup: (f) => {
      const g = za();
      return f.setActive(t.formatter.match("lang", {}, void 0, !0)), g.set(t.formatter.formatChanged("lang", f.setActive, !0)), cS(g.clear, Rc(t)(f));
    },
    onMenuSetup: Rc(t)
  })), HQ = (t) => {
    ek(t, lz(t)), LQ(t).each((a) => ek(t, a));
  }, zQ = (t, a) => {
    FX(t, a), kM(t, a), nQ(t, a), BX(t, a), JX(t, a);
  }, VQ = (t) => H1(t, "NodeChange", (a) => {
    a.setEnabled(t.queryCommandState("outdent") && t.selection.isEditable());
  }), jQ = (t) => {
    t.ui.registry.addButton("outdent", {
      tooltip: "Decrease indent",
      icon: "outdent",
      onSetup: VQ(t),
      onAction: Ju(t, "outdent")
    }), t.ui.registry.addButton("indent", {
      tooltip: "Increase indent",
      icon: "indent",
      onSetup: Rc(t),
      onAction: Ju(t, "indent")
    });
  }, cz = (t) => {
    jQ(t);
  }, $M = (t, a) => (c) => {
    c.setActive(a.get());
    const f = (g) => {
      a.set(g.state), c.setActive(g.state);
    };
    return t.on("PastePlainTextToggle", f), cS(() => t.off("PastePlainTextToggle", f), Rc(t)(c));
  }, uz = (t) => {
    const a = no(tT(t)), c = () => t.execCommand("mceTogglePlainTextPaste");
    t.ui.registry.addToggleButton("pastetext", {
      active: !1,
      icon: "paste-text",
      tooltip: "Paste as text",
      onAction: c,
      onSetup: $M(t, a)
    }), t.ui.registry.addToggleMenuItem("pastetext", {
      text: "Paste as text",
      icon: "paste-text",
      onAction: c,
      onSetup: $M(t, a)
    });
  }, mA = (t, a) => () => {
    t.execCommand("mceToggleFormat", !1, a);
  }, UQ = (t) => {
    im.each([
      {
        name: "bold",
        text: "Bold",
        icon: "bold",
        shortcut: "Meta+B"
      },
      {
        name: "italic",
        text: "Italic",
        icon: "italic",
        shortcut: "Meta+I"
      },
      {
        name: "underline",
        text: "Underline",
        icon: "underline",
        shortcut: "Meta+U"
      },
      {
        name: "strikethrough",
        text: "Strikethrough",
        icon: "strike-through"
      },
      {
        name: "subscript",
        text: "Subscript",
        icon: "subscript"
      },
      {
        name: "superscript",
        text: "Superscript",
        icon: "superscript"
      }
    ], (a, c) => {
      t.ui.registry.addToggleButton(a.name, {
        tooltip: a.text,
        icon: a.icon,
        onSetup: VT(t, a.name),
        onAction: mA(t, a.name),
        shortcut: a.shortcut
      });
    });
    for (let a = 1; a <= 6; a++) {
      const c = "h" + a, f = `Access+${a}`;
      t.ui.registry.addToggleButton(c, {
        text: c.toUpperCase(),
        tooltip: "Heading " + a,
        onSetup: VT(t, c),
        onAction: mA(t, c),
        shortcut: f
      });
    }
  }, dz = (t) => {
    im.each([
      {
        name: "copy",
        text: "Copy",
        action: "Copy",
        icon: "copy"
      },
      {
        name: "help",
        text: "Help",
        action: "mceHelp",
        icon: "help",
        shortcut: "Alt+0"
      },
      {
        name: "selectall",
        text: "Select all",
        action: "SelectAll",
        icon: "select-all",
        shortcut: "Meta+A"
      },
      {
        name: "newdocument",
        text: "New document",
        action: "mceNewDocument",
        icon: "new-document"
      },
      {
        name: "print",
        text: "Print",
        action: "mcePrint",
        icon: "print",
        shortcut: "Meta+P"
      }
    ], (a) => {
      t.ui.registry.addButton(a.name, {
        tooltip: a.text,
        icon: a.icon,
        onAction: Ju(t, a.action),
        shortcut: a.shortcut
      });
    }), im.each([
      {
        name: "cut",
        text: "Cut",
        action: "Cut",
        icon: "cut"
      },
      {
        name: "paste",
        text: "Paste",
        action: "Paste",
        icon: "paste"
      },
      {
        name: "removeformat",
        text: "Clear formatting",
        action: "RemoveFormat",
        icon: "remove-formatting"
      },
      {
        name: "remove",
        text: "Remove",
        action: "Delete",
        icon: "remove"
      },
      {
        name: "hr",
        text: "Horizontal line",
        action: "InsertHorizontalRule",
        icon: "horizontal-rule"
      }
    ], (a) => {
      t.ui.registry.addButton(a.name, {
        tooltip: a.text,
        icon: a.icon,
        onSetup: Rc(t),
        onAction: Ju(t, a.action)
      });
    });
  }, fz = (t) => {
    im.each([{
      name: "blockquote",
      text: "Blockquote",
      action: "mceBlockQuote",
      icon: "quote"
    }], (a) => {
      t.ui.registry.addToggleButton(a.name, {
        tooltip: a.text,
        icon: a.icon,
        onAction: Ju(t, a.action),
        onSetup: VT(t, a.name)
      });
    });
  }, WQ = (t) => {
    UQ(t), dz(t), fz(t);
  }, eie = (t) => {
    im.each([
      {
        name: "newdocument",
        text: "New document",
        action: "mceNewDocument",
        icon: "new-document"
      },
      {
        name: "copy",
        text: "Copy",
        action: "Copy",
        icon: "copy",
        shortcut: "Meta+C"
      },
      {
        name: "selectall",
        text: "Select all",
        action: "SelectAll",
        icon: "select-all",
        shortcut: "Meta+A"
      },
      {
        name: "print",
        text: "Print...",
        action: "mcePrint",
        icon: "print",
        shortcut: "Meta+P"
      }
    ], (a) => {
      t.ui.registry.addMenuItem(a.name, {
        text: a.text,
        icon: a.icon,
        shortcut: a.shortcut,
        onAction: Ju(t, a.action)
      });
    }), im.each([
      {
        name: "bold",
        text: "Bold",
        action: "Bold",
        icon: "bold",
        shortcut: "Meta+B"
      },
      {
        name: "italic",
        text: "Italic",
        action: "Italic",
        icon: "italic",
        shortcut: "Meta+I"
      },
      {
        name: "underline",
        text: "Underline",
        action: "Underline",
        icon: "underline",
        shortcut: "Meta+U"
      },
      {
        name: "strikethrough",
        text: "Strikethrough",
        action: "Strikethrough",
        icon: "strike-through"
      },
      {
        name: "subscript",
        text: "Subscript",
        action: "Subscript",
        icon: "subscript"
      },
      {
        name: "superscript",
        text: "Superscript",
        action: "Superscript",
        icon: "superscript"
      },
      {
        name: "removeformat",
        text: "Clear formatting",
        action: "RemoveFormat",
        icon: "remove-formatting"
      },
      {
        name: "cut",
        text: "Cut",
        action: "Cut",
        icon: "cut",
        shortcut: "Meta+X"
      },
      {
        name: "paste",
        text: "Paste",
        action: "Paste",
        icon: "paste",
        shortcut: "Meta+V"
      },
      {
        name: "hr",
        text: "Horizontal line",
        action: "InsertHorizontalRule",
        icon: "horizontal-rule"
      }
    ], (a) => {
      t.ui.registry.addMenuItem(a.name, {
        text: a.text,
        icon: a.icon,
        shortcut: a.shortcut,
        onSetup: Rc(t),
        onAction: Ju(t, a.action)
      });
    }), t.ui.registry.addMenuItem("codeformat", {
      text: "Code",
      icon: "sourcecode",
      onSetup: Rc(t),
      onAction: mA(t, "code")
    });
  }, ZQ = (t) => {
    WQ(t), eie(t);
  }, pA = (t, a) => H1(t, "Undo Redo AddUndo TypingUndo ClearUndos SwitchMode", (c) => {
    c.setEnabled(!t.mode.isReadOnly() && t.undoManager[a]());
  }), GQ = (t) => {
    t.ui.registry.addMenuItem("undo", {
      text: "Undo",
      icon: "undo",
      shortcut: "Meta+Z",
      onSetup: pA(t, "hasUndo"),
      onAction: Ju(t, "undo")
    }), t.ui.registry.addMenuItem("redo", {
      text: "Redo",
      icon: "redo",
      shortcut: "Meta+Y",
      onSetup: pA(t, "hasRedo"),
      onAction: Ju(t, "redo")
    });
  }, qQ = (t) => {
    t.ui.registry.addButton("undo", {
      tooltip: "Undo",
      icon: "undo",
      enabled: !1,
      onSetup: pA(t, "hasUndo"),
      onAction: Ju(t, "undo"),
      shortcut: "Meta+Z"
    }), t.ui.registry.addButton("redo", {
      tooltip: "Redo",
      icon: "redo",
      enabled: !1,
      onSetup: pA(t, "hasRedo"),
      onAction: Ju(t, "redo"),
      shortcut: "Meta+Y"
    });
  }, KQ = (t) => {
    GQ(t), qQ(t);
  }, YQ = (t) => H1(t, "VisualAid", (a) => {
    a.setActive(t.hasVisual);
  }), XQ = (t) => {
    t.ui.registry.addToggleMenuItem("visualaid", {
      text: "Visual aids",
      onSetup: YQ(t),
      onAction: Ju(t, "mceToggleVisualAid")
    });
  }, QQ = (t) => {
    t.ui.registry.addButton("visualaid", {
      tooltip: "Visual aids",
      text: "Visual aids",
      onAction: Ju(t, "mceToggleVisualAid")
    });
  }, JQ = (t) => {
    QQ(t), XQ(t);
  }, eJ = (t, a) => {
    $Q(t), ZQ(t), zQ(t, a), KQ(t), CZ(t), JQ(t), cz(t), HQ(t), uz(t);
  }, tJ = (t) => _(t) ? t.split(/[ ,]/) : t, mz = (t) => (a) => a.options.get(t), nJ = (t) => {
    const a = t.options.register;
    a("contextmenu_avoid_overlap", {
      processor: "string",
      default: ""
    }), a("contextmenu_never_use_native", {
      processor: "boolean",
      default: !1
    }), a("contextmenu", {
      processor: (c) => c === !1 ? {
        value: [],
        valid: !0
      } : _(c) || ae(c, _) ? {
        value: tJ(c),
        valid: !0
      } : {
        valid: !1,
        message: "Must be false or a string."
      },
      default: "link linkchecker image editimage table spellchecker configurepermanentpen"
    });
  }, LM = mz("contextmenu_never_use_native"), oJ = mz("contextmenu_avoid_overlap"), rJ = (t) => pz(t).length === 0, pz = (t) => {
    const a = t.ui.registry.getAll().contextMenus, c = t.options.get("contextmenu");
    return t.options.isSet("contextmenu") ? c : To(c, (f) => Ho(a, f));
  }, tk = (t, a) => ({
    type: "makeshift",
    x: t,
    y: a
  }), sJ = (t, a, c) => tk(t.x + a, t.y + c), hz = (t) => t.type === "longpress" || t.type.indexOf("touch") === 0, aJ = (t) => {
    if (hz(t)) {
      const a = t.touches[0];
      return tk(a.pageX, a.pageY);
    } else
      return tk(t.pageX, t.pageY);
  }, iJ = (t) => {
    if (hz(t)) {
      const a = t.touches[0];
      return tk(a.clientX, a.clientY);
    } else
      return tk(t.clientX, t.clientY);
  }, lJ = (t, a) => {
    const c = T1.DOM.getPos(t);
    return sJ(a, c.x, c.y);
  }, HM = (t, a) => a.type === "contextmenu" || a.type === "longpress" ? t.inline ? aJ(a) : lJ(t.getContentAreaContainer(), iJ(a)) : gz(t), gz = (t) => ({
    type: "selection",
    root: He.fromDom(t.selection.getNode())
  }), cJ = (t) => ({
    type: "node",
    node: B.some(He.fromDom(t.selection.getNode())),
    root: He.fromDom(t.getBody())
  }), hA = (t, a, c) => {
    switch (c) {
      case "node":
        return cJ(t);
      case "point":
        return HM(t, a);
      case "selection":
        return gz(t);
    }
  }, bz = (t, a, c, f, g, x) => {
    const w = c(), T = hA(t, a, x);
    Mx(w, em.CLOSE_ON_EXECUTE, f, {
      isHorizontalMenu: !1,
      search: B.none()
    }).map((A) => {
      a.preventDefault(), la.showMenuAt(g, { anchor: T }, {
        menu: { markers: Yb("normal") },
        data: A
      });
    });
  }, vz = {
    onLtr: () => [
      ti,
      di,
      ei,
      fi,
      xs,
      Ci,
      cm,
      FS,
      IS,
      RO,
      MS,
      DO
    ],
    onRtl: () => [
      ti,
      ei,
      di,
      xs,
      fi,
      Ci,
      cm,
      FS,
      MS,
      DO,
      IS,
      RO
    ]
  }, uJ = 12, dJ = {
    valignCentre: [],
    alignCentre: [],
    alignLeft: ["tox-pop--align-left"],
    alignRight: ["tox-pop--align-right"],
    right: ["tox-pop--right"],
    left: ["tox-pop--left"],
    bottom: ["tox-pop--bottom"],
    top: ["tox-pop--top"]
  }, fJ = (t, a) => {
    const c = t.selection;
    if (c.isCollapsed() || a.touches.length < 1)
      return !1;
    {
      const f = a.touches[0], g = c.getRng();
      return Fi(t.getWin(), Pb.domRange(g)).exists((w) => w.left <= f.clientX && w.right >= f.clientX && w.top <= f.clientY && w.bottom >= f.clientY);
    }
  }, mJ = (t) => {
    const a = t.selection.getRng(), c = () => {
      FC.setEditorTimeout(t, () => {
        t.selection.setRng(a);
      }, 10), x();
    };
    t.once("touchend", c);
    const f = (w) => {
      w.preventDefault(), w.stopImmediatePropagation();
    };
    t.on("mousedown", f, !0);
    const g = () => x();
    t.once("longpresscancel", g);
    const x = () => {
      t.off("touchend", c), t.off("longpresscancel", g), t.off("mousedown", f);
    };
  }, pJ = (t, a, c) => {
    const f = hA(t, a, c);
    return {
      bubble: _d(0, c === "point" ? uJ : 0, dJ),
      layouts: vz,
      overrides: {
        maxWidthFunction: jx(),
        maxHeightFunction: Eb()
      },
      ...f
    };
  }, zM = (t, a, c, f, g, x, w) => {
    const T = pJ(t, a, x);
    Mx(c, em.CLOSE_ON_EXECUTE, f, {
      isHorizontalMenu: !0,
      search: B.none()
    }).map((A) => {
      a.preventDefault();
      const F = w ? Dc.HighlightMenuAndItem : Dc.HighlightNone;
      la.showMenuWithinBounds(g, { anchor: T }, {
        menu: {
          markers: Yb("normal"),
          highlightOnOpen: F
        },
        data: A,
        type: "horizontal"
      }, () => B.some(rz(t, f.shared, x === "node" ? "node" : "selection"))), t.dispatch(ez);
    });
  }, hJ = (t, a, c, f, g, x) => {
    const w = Fl(), T = w.os.isiOS(), A = w.os.isMacOS(), F = w.os.isAndroid(), H = w.deviceType.isTouch(), q = () => !(F || T || A && H), ne = () => {
      const ie = c();
      zM(t, a, ie, f, g, x, q());
    };
    if ((A || T) && x !== "node") {
      const ie = () => {
        mJ(t), ne();
      };
      fJ(t, a) ? ie() : (t.once("selectionchange", ie), t.once("touchend", () => t.off("selectionchange", ie)));
    } else
      ne();
  }, VM = (t) => _(t) ? t === "|" : t.type === "separator", jM = { type: "separator" }, yz = (t) => {
    const a = (c) => ({
      text: c.text,
      icon: c.icon,
      enabled: c.enabled,
      shortcut: c.shortcut
    });
    if (_(t))
      return t;
    switch (t.type) {
      case "separator":
        return jM;
      case "submenu":
        return {
          type: "nestedmenuitem",
          ...a(t),
          getSubmenuItems: () => {
            const f = t.getSubmenuItems();
            return _(f) ? f : tt(f, yz);
          }
        };
      default:
        const c = t;
        return {
          type: "menuitem",
          ...a(c),
          onAction: ve(c.onAction)
        };
    }
  }, gA = (t, a) => {
    if (a.length === 0)
      return t;
    const f = pr(t).filter((g) => !VM(g)).fold(() => [], (g) => [jM]);
    return t.concat(f).concat(a).concat([jM]);
  }, gJ = (t, a, c) => {
    const f = Mt(a, (g, x) => Ht(t, x.toLowerCase()).map((w) => {
      const T = w.update(c);
      if (_(T) && Re(Ps(T)))
        return gA(g, T.split(" "));
      if (W(T) && T.length > 0) {
        const A = tt(T, yz);
        return gA(g, A);
      } else
        return g;
    }).getOrThunk(() => g.concat([x])), []);
    return f.length > 0 && VM(f[f.length - 1]) && f.pop(), f;
  }, xz = (t, a) => a.ctrlKey && !LM(t), bJ = (t) => t.type === "longpress" || Ho(t, "touches"), wz = (t, a) => !bJ(a) && (a.button !== 2 || a.target === t.getBody() && a.pointerType === ""), bA = (t, a) => wz(t, a) ? t.selection.getStart(!0) : a.target, vJ = (t, a) => {
    const c = oJ(t), f = wz(t, a) ? "selection" : "point";
    if (Re(c)) {
      const g = bA(t, a);
      return mS(He.fromDom(g), c) ? "node" : f;
    } else
      return f;
  }, yJ = (t, a, c) => {
    const g = Fl().deviceType.isTouch, x = Al(la.sketch({
      dom: { tag: "div" },
      lazySink: a,
      onEscape: () => t.focus(),
      onShow: () => c.setContextMenuState(!0),
      onHide: () => c.setContextMenuState(!1),
      fireDismissalEventInstead: {},
      inlineBehaviours: Qt([Go("dismissContextMenu", [It(_p(), (A, F) => {
        Br.close(A), t.focus();
      })])])
    })), w = () => la.hide(x), T = (A) => {
      if (LM(t) && A.preventDefault(), xz(t, A) || rJ(t))
        return;
      const F = vJ(t, A), H = () => {
        const ne = bA(t, A), ie = t.ui.registry.getAll(), fe = pz(t);
        return gJ(ie.contextMenus, fe, ne);
      };
      (g() ? hJ : bz)(t, A, H, c, x, F);
    };
    t.on("init", () => {
      const A = "ResizeEditor ScrollContent ScrollWindow longpresscancel" + (g() ? "" : " ResizeWindow");
      t.on(A, w), t.on("longpress contextmenu", T);
    });
  }, UM = Be.generate([
    {
      offset: [
        "x",
        "y"
      ]
    },
    {
      absolute: [
        "x",
        "y"
      ]
    },
    {
      fixed: [
        "x",
        "y"
      ]
    }
  ]), vA = (t) => (a) => a.translate(-t.left, -t.top), yA = (t) => (a) => a.translate(t.left, t.top), fh = (t) => (a, c) => Mt(t, (f, g) => g(f), zs(a, c)), xA = (t, a, c) => t.fold(fh([
    yA(c),
    vA(a)
  ]), fh([vA(a)]), fh([])), Yx = (t, a, c) => t.fold(fh([yA(c)]), fh([]), fh([yA(a)])), Cz = (t, a, c) => t.fold(fh([]), fh([vA(c)]), fh([
    yA(a),
    vA(c)
  ])), xJ = (t, a, c, f, g, x) => {
    const w = Yx(t, g, x), T = Yx(a, g, x);
    return Math.abs(w.left - T.left) <= c && Math.abs(w.top - T.top) <= f;
  }, wJ = (t, a, c, f, g, x) => {
    const w = Yx(t, g, x), T = Yx(a, g, x), A = Math.abs(w.left - T.left), F = Math.abs(w.top - T.top);
    return zs(A, F);
  }, Sz = (t, a, c) => {
    const f = t.fold((g, x) => ({
      position: B.some("absolute"),
      left: B.some(g + "px"),
      top: B.some(x + "px")
    }), (g, x) => ({
      position: B.some("absolute"),
      left: B.some(g - c.left + "px"),
      top: B.some(x - c.top + "px")
    }), (g, x) => ({
      position: B.some("fixed"),
      left: B.some(g + "px"),
      top: B.some(x + "px")
    }));
    return {
      right: B.none(),
      bottom: B.none(),
      ...f
    };
  }, CJ = (t, a, c) => t.fold((f, g) => nk(f + a, g + c), (f, g) => lv(f + a, g + c), (f, g) => cv(f + a, g + c)), WM = (t, a, c, f) => {
    const g = (x, w) => (T, A) => {
      const F = x(a, c, f);
      return w(T.getOr(F.left), A.getOr(F.top));
    };
    return t.fold(g(Cz, nk), g(Yx, lv), g(xA, cv));
  }, nk = UM.offset, lv = UM.absolute, cv = UM.fixed, kz = (t, a) => {
    const c = os(t, a);
    return be(c) ? NaN : parseInt(c, 10);
  }, SJ = (t, a) => {
    const c = t.element, f = kz(c, a.leftAttr), g = kz(c, a.topAttr);
    return isNaN(f) || isNaN(g) ? B.none() : B.some(zs(f, g));
  }, kJ = (t, a, c) => {
    const f = t.element;
    rn(f, a.leftAttr, c.left + "px"), rn(f, a.topAttr, c.top + "px");
  }, o0 = (t, a) => {
    const c = t.element;
    Ee(c, a.leftAttr), Ee(c, a.topAttr);
  }, _z = (t, a, c, f) => SJ(t, a).fold(() => c, (g) => cv(g.left + f.left, g.top + f.top)), _J = (t, a, c, f, g, x) => {
    const w = _z(t, a, c, f), T = a.mustSnap ? TJ(t, a, w, g, x) : Tz(t, a, w, g, x), A = xA(w, g, x);
    return kJ(t, a, A), T.fold(() => ({
      coord: cv(A.left, A.top),
      extra: B.none()
    }), (F) => ({
      coord: F.output,
      extra: F.extra
    }));
  }, EJ = (t, a) => {
    o0(t, a);
  }, Ez = (t, a, c, f) => Ko(t, (g) => {
    const x = g.sensor;
    return xJ(a, x, g.range.left, g.range.top, c, f) ? B.some({
      output: WM(g.output, a, c, f),
      extra: g.extra
    }) : B.none();
  }), TJ = (t, a, c, f, g) => {
    const x = a.getSnapPoints(t);
    return Ez(x, c, f, g).orThunk(() => Mt(x, (A, F) => {
      const H = F.sensor, q = wJ(c, H, F.range.left, F.range.top, f, g);
      return A.deltas.fold(() => ({
        deltas: B.some(q),
        snap: B.some(F)
      }), (ne) => {
        const ie = (q.left + q.top) / 2, fe = (ne.left + ne.top) / 2;
        return ie <= fe ? {
          deltas: B.some(q),
          snap: B.some(F)
        } : A;
      });
    }, {
      deltas: B.none(),
      snap: B.none()
    }).snap.map((A) => ({
      output: WM(A.output, c, f, g),
      extra: A.extra
    })));
  }, Tz = (t, a, c, f, g) => {
    const x = a.getSnapPoints(t);
    return Ez(x, c, f, g);
  }, OJ = (t, a, c) => ({
    coord: WM(t.output, t.output, a, c),
    extra: t.extra
  });
  var AJ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    snapTo: (t, a, c, f) => {
      const g = a.getTarget(t.element);
      if (a.repositionTarget) {
        const x = ii(t.element), w = wi(x), T = Kw(g), A = OJ(f, w, T), F = Sz(A.coord, w, T);
        Gt(g, F);
      }
    }
  });
  const ZM = "data-initial-z-index", PJ = (t) => {
    Za(t.element).filter(ko).each((a) => {
      K(a, ZM).fold(() => xr(a, "z-index"), (c) => Ln(a, "z-index", c)), Ee(a, ZM);
    });
  }, DJ = (t) => {
    Za(t.element).filter(ko).each((a) => {
      ks(a, "z-index").each((c) => {
        rn(a, ZM, c);
      }), Ln(a, "z-index", fs(t.element, "z-index"));
    });
  }, Oz = (t, a) => {
    t.getSystem().addToGui(a), DJ(a);
  }, RJ = (t) => {
    PJ(t), t.getSystem().removeFromGui(t);
  }, Az = (t, a, c) => t.getSystem().build(qm.sketch({
    dom: {
      styles: {
        left: "0px",
        top: "0px",
        width: "100%",
        height: "100%",
        position: "fixed",
        "z-index": "1000000000000000"
      },
      classes: [a]
    },
    events: c
  }));
  var NJ = Es("snaps", [
    Rt("getSnapPoints"),
    Rr("onSensor"),
    Rt("leftAttr"),
    Rt("topAttr"),
    Qe("lazyViewport", Ra),
    Qe("mustSnap", !1)
  ]);
  const wA = [
    Qe("useFixed", wt),
    Rt("blockerClass"),
    Qe("getTarget", lt),
    Qe("onDrag", G),
    Qe("repositionTarget", !0),
    Qe("onDrop", G),
    Ca("getBounds", Ra),
    NJ
  ], Pz = (t) => ca(ks(t, "left"), ks(t, "top"), ks(t, "position"), (a, c, f) => (f === "fixed" ? cv : nk)(parseInt(a, 10), parseInt(c, 10))).getOrThunk(() => {
    const a = Ga(t);
    return lv(a.left, a.top);
  }), MJ = (t, a, c, f, g) => {
    const x = g.bounds, w = Yx(a, c, f), T = kd(w.left, x.x, x.x + x.width - g.width), A = kd(w.top, x.y, x.y + x.height - g.height), F = lv(T, A);
    return a.fold(() => {
      const H = Cz(F, c, f);
      return nk(H.left, H.top);
    }, te(F), () => {
      const H = xA(F, c, f);
      return cv(H.left, H.top);
    });
  }, ok = (t, a, c, f, g, x, w) => {
    const T = a.fold(() => {
      const A = CJ(c, x.left, x.top), F = xA(A, f, g);
      return cv(F.left, F.top);
    }, (A) => {
      const F = _J(t, A, c, x, f, g);
      return F.extra.each((H) => {
        A.onSensor(t, H);
      }), F.coord;
    });
    return MJ(t, T, f, g, w);
  }, IJ = (t, a, c, f) => {
    const g = a.getTarget(t.element);
    if (a.repositionTarget) {
      const x = ii(t.element), w = wi(x), T = Kw(g), A = Pz(g), F = ok(t, a.snaps, A, w, T, f, c), H = Sz(F, w, T);
      Gt(g, H);
    }
    a.onDrag(t, g, f);
  }, Dz = (t, a) => ({
    bounds: t.getBounds(),
    height: ud(a.element),
    width: li(a.element)
  }), rk = (t, a, c, f, g) => {
    const x = c.update(f, g), w = c.getStartData().getOrThunk(() => Dz(a, t));
    x.each((T) => {
      IJ(t, a, w, T);
    });
  }, Rz = (t, a, c, f) => {
    a.each(RJ), c.snaps.each((x) => {
      EJ(t, x);
    });
    const g = c.getTarget(t.element);
    f.reset(), c.onDrop(t, g);
  }, GM = (t) => (a, c) => {
    const f = (g) => {
      c.setStartData(Dz(a, g));
    };
    return js([
      It(jh(), (g) => {
        c.getStartData().each(() => f(g));
      }),
      ...t(a, c, f)
    ]);
  }, FJ = (t) => js([
    It(nc(), t.forceDrop),
    It(Tm(), t.drop),
    It(sb(), (a, c) => {
      t.move(c.event);
    }),
    It(wd(), t.delayDrop)
  ]);
  var BJ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getData: (t) => B.from(zs(t.x, t.y)),
    getDelta: (t, a) => zs(a.left - t.left, a.top - t.top)
  });
  const Nz = (t, a, c) => [It(nc(), (f, g) => {
    if (g.event.raw.button !== 0)
      return;
    g.stop();
    const w = () => Rz(f, B.some(F), t, a), T = UL(w, 200), A = {
      drop: w,
      delayDrop: T.schedule,
      forceDrop: w,
      move: (q) => {
        T.cancel(), rk(f, t, a, BJ, q);
      }
    }, F = Az(f, t.blockerClass, FJ(A));
    (() => {
      c(f), Oz(f, F);
    })();
  })], $J = [
    ...wA,
    Ws("dragger", { handlers: GM(Nz) })
  ], LJ = (t) => js([
    It(wr(), t.forceDrop),
    It(Ja(), t.drop),
    It(Tc(), t.drop),
    It(Xs(), (a, c) => {
      t.move(c.event);
    })
  ]), HJ = (t) => {
    const a = t[0];
    return B.some(zs(a.clientX, a.clientY));
  };
  var Mz = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getData: (t) => {
      const c = t.raw.touches;
      return c.length === 1 ? HJ(c) : B.none();
    },
    getDelta: (t, a) => zs(a.left - t.left, a.top - t.top)
  });
  const Iz = (t, a, c) => {
    const f = ms(), g = (x) => {
      Rz(x, f.get(), t, a), f.clear();
    };
    return [
      It(wr(), (x, w) => {
        w.stop();
        const T = () => g(x), A = {
          drop: T,
          delayDrop: G,
          forceDrop: T,
          move: (q) => {
            rk(x, t, a, Mz, q);
          }
        }, F = Az(x, t.blockerClass, LJ(A));
        f.set(F), (() => {
          c(x), Oz(x, F);
        })();
      }),
      It(Xs(), (x, w) => {
        w.stop(), rk(x, t, a, Mz, w.event);
      }),
      It(Ja(), (x, w) => {
        w.stop(), g(x);
      }),
      It(Tc(), g)
    ];
  }, zJ = [
    ...wA,
    Ws("dragger", { handlers: GM(Iz) })
  ], VJ = (t, a, c) => [
    ...Nz(t, a, c),
    ...Iz(t, a, c)
  ], jJ = [
    ...wA,
    Ws("dragger", { handlers: GM(VJ) })
  ];
  var UJ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    mouse: $J,
    touch: zJ,
    mouseOrTouch: jJ
  }), WJ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      let t = B.none(), a = B.none();
      const c = () => {
        t = B.none(), a = B.none();
      }, f = (A, F) => {
        const H = t.map((q) => A.getDelta(q, F));
        return t = B.some(F), H;
      }, g = (A, F) => A.getData(F).bind((H) => f(A, H)), x = (A) => {
        a = B.some(A);
      }, w = () => a, T = te({});
      return Wc({
        readState: T,
        reset: c,
        update: g,
        getStartData: w,
        setStartData: x
      });
    }
  });
  const r0 = Xk({
    branchKey: "mode",
    branches: UJ,
    name: "dragging",
    active: {
      events: (t, a) => t.dragger.handlers(t, a)
    },
    extra: {
      snap: (t) => ({
        sensor: t.sensor,
        range: t.range,
        output: t.output,
        extra: B.from(t.extra)
      })
    },
    state: WJ,
    apis: AJ
  }), CA = 40, SA = CA / 2, Fz = (t, a, c, f, g, x) => t.fold(() => r0.snap({
    sensor: lv(c - SA, f - SA),
    range: zs(g, x),
    output: lv(B.some(c), B.some(f)),
    extra: { td: a }
  }), (w) => {
    const T = c - SA, A = f - SA, F = CA, H = CA, q = w.element.dom.getBoundingClientRect();
    return r0.snap({
      sensor: lv(T, A),
      range: zs(F, H),
      output: lv(B.some(c - q.width / 2), B.some(f - q.height / 2)),
      extra: { td: a }
    });
  }), Bz = (t, a, c) => {
    const f = (g, x) => g.exists((w) => Lr(w, x));
    return {
      getSnapPoints: t,
      leftAttr: "data-drag-left",
      topAttr: "data-drag-top",
      onSensor: (g, x) => {
        const w = x.td;
        f(a.get(), w) || (a.set(w), c(w));
      },
      mustSnap: !0
    };
  }, $z = (t) => is(Rl.sketch({
    dom: {
      tag: "div",
      classes: ["tox-selector"]
    },
    buttonBehaviours: Qt([
      r0.config({
        mode: "mouseOrTouch",
        blockerClass: "blocker",
        snaps: t
      }),
      Ex.config({})
    ]),
    eventOrder: {
      mousedown: [
        "dragging",
        "alloy.base.behaviour"
      ],
      touchstart: [
        "dragging",
        "alloy.base.behaviour"
      ]
    }
  })), ZJ = (t, a) => {
    const c = no([]), f = no([]), g = no(!1), x = ms(), w = ms(), T = (vn) => {
      const Nt = Cl(vn);
      return Fz(ie.getOpt(a), vn, Nt.x, Nt.y, Nt.width, Nt.height);
    }, A = () => tt(c.get(), (vn) => T(vn)), F = (vn) => {
      const Nt = Cl(vn);
      return Fz(fe.getOpt(a), vn, Nt.right, Nt.bottom, Nt.width, Nt.height);
    }, H = () => tt(f.get(), (vn) => F(vn)), q = Bz(A, x, (vn) => {
      w.get().each((Nt) => {
        t.dispatch("TableSelectorChange", {
          start: vn,
          finish: Nt
        });
      });
    }), ne = Bz(H, w, (vn) => {
      x.get().each((Nt) => {
        t.dispatch("TableSelectorChange", {
          start: Nt,
          finish: vn
        });
      });
    }), ie = $z(q), fe = $z(ne), _e = Al(ie.asSpec()), st = Al(fe.asSpec()), De = (vn, Nt, Yn, In) => {
      const xo = Nt.dom.getBoundingClientRect();
      xr(vn.element, "display");
      const fo = cl(He.fromDom(t.getBody())).dom.innerHeight, Gr = Yn(xo), Hr = In(xo, fo);
      (Gr || Hr) && Ln(vn.element, "display", "none");
    }, Je = (vn, Nt, Yn, In) => {
      const xo = Yn(Nt);
      r0.snapTo(vn, xo), De(vn, Nt, (Hr) => Hr[In] < 0, (Hr, br) => Hr[In] > br);
    }, Ge = (vn) => Je(_e, vn, T, "top"), Ft = () => x.get().each(Ge), gt = (vn) => Je(st, vn, F, "bottom"), Jt = () => w.get().each(gt);
    if (Fl().deviceType.isTouch()) {
      const vn = (Nt) => tt(Nt, He.fromDom);
      t.on("TableSelectionChange", (Nt) => {
        g.get() || (Gf(a, _e), Gf(a, st), g.set(!0));
        const Yn = He.fromDom(Nt.start), In = He.fromDom(Nt.finish);
        x.set(Yn), w.set(In), B.from(Nt.otherCells).each((xo) => {
          c.set(vn(xo.upOrLeftCells)), f.set(vn(xo.downOrRightCells)), Ge(Yn), gt(In);
        });
      }), t.on("ResizeEditor ResizeWindow ScrollContent", () => {
        Ft(), Jt();
      }), t.on("TableSelectionClear", () => {
        g.get() && ($m(_e), $m(st), g.set(!1)), x.clear(), w.clear();
      });
    }
  };
  var KM = `<svg height="16" viewBox="0 0 80 16" width="80" xmlns="http://www.w3.org/2000/svg"><g opacity=".8"><path d="m80 3.537v-2.202h-7.976v11.585h7.976v-2.25h-5.474v-2.621h4.812v-2.069h-4.812v-2.443zm-10.647 6.929c-.493.217-1.13.337-1.864.337s-1.276-.156-1.805-.47a3.732 3.732 0 0 1 -1.3-1.298c-.324-.554-.48-1.191-.48-1.877s.156-1.335.48-1.877a3.635 3.635 0 0 1 1.3-1.299 3.466 3.466 0 0 1 1.805-.481c.65 0 .914.06 1.263.18.36.12.698.277.986.47.289.192.578.384.842.6l.12.085v-2.586l-.023-.024c-.385-.35-.855-.614-1.384-.818-.53-.205-1.155-.313-1.877-.313-.721 0-1.6.144-2.333.445a5.773 5.773 0 0 0 -1.937 1.251 5.929 5.929 0 0 0 -1.324 1.9c-.324.735-.48 1.565-.48 2.455s.156 1.72.48 2.454c.325.734.758 1.383 1.324 1.913.553.53 1.215.938 1.937 1.25a6.286 6.286 0 0 0 2.333.434c.819 0 1.384-.108 1.961-.313.59-.216 1.083-.505 1.468-.866l.024-.024v-2.49l-.12.096c-.41.337-.878.626-1.396.866zm-14.869-4.15-4.8-5.04-.024-.025h-.902v11.67h2.502v-6.847l2.827 3.08.385.409.397-.41 2.791-3.067v6.845h2.502v-11.679h-.902l-4.788 5.052z"/><path clip-rule="evenodd" d="m15.543 5.137c0-3.032-2.466-5.113-4.957-5.137-.36 0-.745.024-1.094.096-.157.024-3.85.758-3.85.758-3.032.602-4.62 2.466-4.704 4.788-.024.89-.024 4.27-.024 4.27.036 3.165 2.406 5.138 5.017 5.126.337 0 1.119-.109 1.287-.145.144-.024.385-.084.746-.144.661-.12 1.684-.325 3.067-.602 2.37-.409 4.103-2.009 4.44-4.33.156-1.023.084-4.692.084-4.692zm-3.213 3.308-2.346.457v2.31l-5.859 1.143v-5.75l2.346-.458v3.441l3.513-.686v-3.44l-3.513.685v-2.297l5.859-1.143v5.75zm20.09-3.296-.083-1.023h-2.13v8.794h2.346v-4.884c0-1.107.95-1.985 2.057-1.997 1.095 0 1.901.89 1.901 1.997v4.884h2.346v-5.245c-.012-2.105-1.588-3.777-3.67-3.765a3.764 3.764 0 0 0 -2.778 1.25l.012-.011zm-6.014-4.102 2.346-.458v2.298l-2.346.457z" fill-rule="evenodd"/><path d="m28.752 4.126h-2.346v8.794h2.346z"/><path clip-rule="evenodd" d="m43.777 15.483 4.043-11.357h-2.418l-1.54 4.355-.445 1.324-.36-1.324-1.54-4.355h-2.418l3.151 8.794-1.083 3.08zm-21.028-5.51c0 .722.541 1.034.878 1.034s.638-.048.95-.144l.518 1.708c-.217.145-.879.518-2.13.518a2.565 2.565 0 0 1 -2.562-2.587c-.024-1.082-.024-2.49 0-4.21h-1.54v-2.142h1.54v-1.912l2.346-.458v2.37h2.201v2.142h-2.2v3.693-.012z" fill-rule="evenodd"/></g></svg>
`;
  const Lz = (t, a) => {
    const c = B.from(os(t, "id")).getOrThunk(() => {
      const f = Nn("aria");
      return rn(a, "id", f), f;
    });
    rn(t, "aria-describedby", c);
  }, GJ = (t) => {
    Ee(t, "aria-describedby");
  }, qJ = (t) => t.nodeName === "BR" || !!t.getAttribute("data-mce-bogus") || t.getAttribute("data-mce-type") === "bookmark", KJ = (t, a, c) => {
    var f;
    const g = (f = a.delimiter) !== null && f !== void 0 ? f : "", x = (F, H, q) => Rl.sketch({
      dom: {
        tag: "div",
        classes: ["tox-statusbar__path-item"],
        attributes: { "data-index": q }
      },
      components: [Oa(F)],
      action: (ne) => {
        t.focus(), t.selection.select(H), t.nodeChanged();
      },
      buttonBehaviours: Qt([
        gl.config({
          ...c.tooltips.getConfig({
            tooltipText: c.translate([
              "Select the {0} element",
              H.nodeName.toLowerCase()
            ]),
            onShow: (ne, ie) => {
              Lz(ne.element, ie.element);
            },
            onHide: (ne) => {
              GJ(ne.element);
            }
          })
        }),
        rm.button(c.isDisabled),
        Si()
      ])
    }), w = () => ({
      dom: {
        tag: "div",
        classes: ["tox-statusbar__path-divider"],
        attributes: { "aria-hidden": !0 }
      },
      components: [Oa(` ${g} `)]
    }), T = (F) => Mt(F, (H, q, ne) => {
      const ie = x(q.name, q.element, ne);
      return ne === 0 ? H.concat([ie]) : H.concat([
        w(),
        ie
      ]);
    }, []), A = (F) => {
      const H = [];
      let q = F.length;
      for (; q-- > 0; ) {
        const ne = F[q];
        if (ne.nodeType === 1 && !qJ(ne)) {
          const ie = aZ(t, ne);
          if (ie.isDefaultPrevented() || H.push({
            name: ie.name,
            element: ne
          }), ie.isPropagationStopped())
            break;
        }
      }
      return H;
    };
    return {
      dom: {
        tag: "div",
        classes: ["tox-statusbar__path"],
        attributes: { role: "navigation" }
      },
      behaviours: Qt([
        oo.config({
          mode: "flow",
          selector: "div[role=button]"
        }),
        _o.config({ disabled: c.isDisabled }),
        Si(),
        Zs.config({}),
        No.config({}),
        Go("elementPathEvents", [Qs((F, H) => {
          t.shortcuts.add("alt+F11", "focus statusbar elementpath", () => oo.focusIn(F)), t.on("NodeChange", (q) => {
            const ne = A(q.parents), ie = ne.length > 0 ? T(ne) : [];
            No.set(F, ie);
          });
        })])
      ]),
      components: []
    };
  };
  var uv;
  (function(t) {
    t[t.None = 0] = "None", t[t.Both = 1] = "Both", t[t.Vertical = 2] = "Vertical";
  })(uv || (uv = {}));
  const YJ = (t, a, c, f, g) => {
    const x = { height: n0(f + a.top, KE(t), iD(t)) };
    return c === uv.Both && (x.width = n0(g + a.left, cx(t), $C(t))), x;
  }, Hz = (t, a, c) => {
    const f = He.fromDom(t.getContainer()), g = YJ(t, a, c, Bs(f), Pi(f));
    at(g, (x, w) => {
      oe(x) && Ln(f, w, OM(x));
    }), rZ(t);
  }, XJ = (t) => {
    const a = pD(t);
    return a === !1 ? uv.None : a === "both" ? uv.Both : uv.Vertical;
  }, kA = (t, a, c, f) => {
    const x = zs(c * 20, f * 20);
    return Hz(t, x, a), B.some(!0);
  }, QJ = (t, a) => {
    const c = XJ(t);
    if (c === uv.None)
      return B.none();
    const f = c === uv.Both ? "Press the arrow keys to resize the editor." : "Press the Up and Down arrow keys to resize the editor.";
    return B.some(xu("resize-handle", {
      tag: "div",
      classes: ["tox-statusbar__resize-handle"],
      attributes: {
        "aria-label": a.translate(f),
        "data-mce-name": "resize-handle"
      },
      behaviours: [
        r0.config({
          mode: "mouse",
          repositionTarget: !1,
          onDrag: (g, x, w) => Hz(t, w, c),
          blockerClass: "tox-blocker"
        }),
        oo.config({
          mode: "special",
          onLeft: () => kA(t, c, -1, 0),
          onRight: () => kA(t, c, 1, 0),
          onUp: () => kA(t, c, 0, -1),
          onDown: () => kA(t, c, 0, 1)
        }),
        Zs.config({}),
        Ao.config({}),
        gl.config(a.tooltips.getConfig({ tooltipText: a.translate("Resize") }))
      ]
    }, a.icons));
  }, JJ = (t, a) => {
    const c = (f, g, x) => No.set(f, [Oa(a.translate([
      "{0} " + x,
      g[x]
    ]))]);
    return Rl.sketch({
      dom: {
        tag: "button",
        classes: ["tox-statusbar__wordcount"]
      },
      components: [],
      buttonBehaviours: Qt([
        rm.button(a.isDisabled),
        Si(),
        Zs.config({}),
        No.config({}),
        Mn.config({
          store: {
            mode: "memory",
            initialValue: {
              mode: "words",
              count: {
                words: 0,
                characters: 0
              }
            }
          }
        }),
        Go("wordcount-events", [
          Sd((f) => {
            const g = Mn.getValue(f), x = g.mode === "words" ? "characters" : "words";
            Mn.setValue(f, {
              mode: x,
              count: g.count
            }), c(f, g.count, x);
          }),
          Qs((f) => {
            t.on("wordCountUpdate", (g) => {
              const { mode: x } = Mn.getValue(f);
              Mn.setValue(f, {
                mode: x,
                count: g.wordCount
              }), c(f, g.wordCount, x);
            });
          })
        ])
      ]),
      eventOrder: {
        [zu()]: [
          "disabling",
          "alloy.base.behaviour",
          "wordcount-events"
        ]
      }
    });
  }, eee = (t, a) => {
    const c = () => ({
      dom: {
        tag: "span",
        classes: ["tox-statusbar__branding"]
      },
      components: [{
        dom: {
          tag: "a",
          attributes: {
            href: "https://www.tiny.cloud/powered-by-tiny?utm_campaign=poweredby&utm_source=tiny&utm_medium=referral&utm_content=v7",
            rel: "noopener",
            target: "_blank",
            "aria-label": t.translate([
              "Build with {0}",
              "TinyMCE"
            ])
          },
          innerHtml: t.translate([
            "Build with {0}",
            KM.trim()
          ])
        },
        behaviours: Qt([Ao.config({})])
      }]
    }), f = () => {
      const T = FT("Alt+0");
      return {
        dom: {
          tag: "div",
          classes: ["tox-statusbar__help-text"]
        },
        components: [Oa(Ad.translate([
          "Press {0} for help",
          T
        ]))]
      };
    }, g = () => {
      const T = [];
      return t.hasPlugin("wordcount") && T.push(JJ(t, a)), mD(t) && T.push(c()), {
        dom: {
          tag: "div",
          classes: ["tox-statusbar__right-container"]
        },
        components: T
      };
    }, x = () => {
      const T = [], A = qB(t), F = ZB(t), H = mD(t) || t.hasPlugin("wordcount"), q = () => {
        const ne = "tox-statusbar__text-container--flex-start", ie = "tox-statusbar__text-container--flex-end", fe = "tox-statusbar__text-container--space-around";
        if (A) {
          const _e = "tox-statusbar__text-container-3-cols";
          return !H && !F ? [
            _e,
            fe
          ] : H && !F ? [
            _e,
            ie
          ] : [
            _e,
            ne
          ];
        }
        return [H && !F ? ie : ne];
      };
      return F && T.push(KJ(t, {}, a)), A && T.push(f()), H && T.push(g()), T.length > 0 ? [{
        dom: {
          tag: "div",
          classes: [
            "tox-statusbar__text-container",
            ...q()
          ]
        },
        components: T
      }] : [];
    };
    return {
      dom: {
        tag: "div",
        classes: ["tox-statusbar"]
      },
      components: (() => {
        const T = x(), A = QJ(t, a);
        return T.concat(A.toArray());
      })()
    };
  }, zz = (t, a) => a.get().getOrDie(`UI for ${t} has not been rendered`), tee = (t, a) => {
    const c = t.inline, f = c ? XH : xQ, g = dx(t) ? kY : R7, x = QH(), w = ms(), T = ms(), A = ms(), ne = Fl().deviceType.isTouch() ? ["tox-platform-touch"] : [], ie = _g(t), fe = A1(t), _e = is({
      dom: {
        tag: "div",
        classes: ["tox-anchorbar"]
      }
    }), st = is({
      dom: {
        tag: "div",
        classes: ["tox-bottom-anchorbar"]
      }
    }), De = () => x.mainUi.get().map((go) => go.outerContainer).bind(Gs.getHeader), Je = () => zo.fromOption(x.dialogUi.get().map((go) => go.sink), "UI has not been rendered"), Ge = () => zo.fromOption(x.popupUi.get().map((go) => go.sink), "(popup) UI has not been rendered"), Ft = x.lazyGetInOuterOrDie("anchor bar", _e.getOpt), gt = x.lazyGetInOuterOrDie("bottom anchor bar", st.getOpt), Jt = x.lazyGetInOuterOrDie("toolbar", Gs.getToolbar), vn = x.lazyGetInOuterOrDie("throbber", Gs.getThrobber), Nt = pY({
      popup: Ge,
      dialog: Je
    }, t, Ft, gt), Yn = () => {
      const go = { attributes: { [Vp]: ie ? zp.BottomToTop : zp.TopToBottom } }, Lo = Gs.parts.menubar({
        dom: {
          tag: "div",
          classes: ["tox-menubar"]
        },
        backstage: Nt.popup,
        onEscape: () => {
          t.focus();
        }
      }), Os = Gs.parts.toolbar({
        dom: {
          tag: "div",
          classes: ["tox-toolbar"]
        },
        getSink: Nt.popup.shared.getSink,
        providers: Nt.popup.shared.providers,
        onEscape: () => {
          t.focus();
        },
        onToolbarToggled: (u0) => {
          iZ(t, u0);
        },
        type: fe,
        lazyToolbar: Jt,
        lazyHeader: () => De().getOrDie("Could not find header element"),
        ...go
      }), Qr = Gs.parts["multiple-toolbar"]({
        dom: {
          tag: "div",
          classes: ["tox-toolbar-overlord"]
        },
        providers: Nt.popup.shared.providers,
        onEscape: () => {
          t.focus();
        },
        type: fe
      }), gc = P1(t), Fd = rT(t), ep = nT(t), Wl = LC(t), Bd = In(), _f = gc || Fd || ep, Eu = () => gc ? [Qr] : Fd ? [Os] : [], hh = Wl ? [
        Bd,
        Lo
      ] : [Lo];
      return Gs.parts.header({
        dom: {
          tag: "div",
          classes: ["tox-editor-header"].concat(_f ? [] : ["tox-editor-header--empty"]),
          ...go
        },
        components: en([
          ep ? hh : [],
          Eu(),
          ux(t) ? [] : [_e.asSpec()]
        ]),
        sticky: dx(t),
        editor: t,
        sharedBackstage: Nt.popup.shared
      });
    }, In = () => Gs.parts.promotion({
      dom: {
        tag: "div",
        classes: ["tox-promotion"]
      }
    }), xo = () => {
      const go = Gs.parts.socket({
        dom: {
          tag: "div",
          classes: ["tox-edit-area"]
        }
      }), Lo = Gs.parts.sidebar({
        dom: {
          tag: "div",
          classes: ["tox-sidebar"]
        }
      });
      return {
        dom: {
          tag: "div",
          classes: ["tox-sidebar-wrap"]
        },
        components: [
          go,
          Lo
        ]
      };
    }, fo = () => {
      const go = HC(t), Lo = Lr(Uo(), go) && fs(go, "display") === "grid", Os = {
        dom: {
          tag: "div",
          classes: [
            "tox",
            "tox-silver-sink",
            "tox-tinymce-aux"
          ].concat(ne),
          attributes: { ...Ad.isRtl() ? { dir: "rtl" } : {} }
        },
        behaviours: Qt([tl.config({ useFixed: () => g.isDocked(De) })])
      }, Qr = {
        dom: { styles: { width: document.body.clientWidth + "px" } },
        events: js([It(tf(), (ep) => {
          Ln(ep.element, "width", document.body.clientWidth + "px");
        })])
      }, gc = Al(Fs(Os, Lo ? Qr : {})), Fd = MR(gc);
      return T.set(Fd), {
        sink: gc,
        mothership: Fd
      };
    }, Gr = () => {
      const go = {
        dom: {
          tag: "div",
          classes: [
            "tox",
            "tox-silver-sink",
            "tox-silver-popup-sink",
            "tox-tinymce-aux"
          ].concat(ne),
          attributes: { ...Ad.isRtl() ? { dir: "rtl" } : {} }
        },
        behaviours: Qt([tl.config({
          useFixed: () => g.isDocked(De),
          getBounds: () => a.getPopupSinkBounds()
        })])
      }, Lo = Al(go), Os = MR(Lo);
      return A.set(Os), {
        sink: Lo,
        mothership: Os
      };
    }, Hr = () => {
      const go = Yn(), Lo = xo(), Os = Gs.parts.throbber({
        dom: {
          tag: "div",
          classes: ["tox-throbber"]
        },
        backstage: Nt.popup
      }), Qr = Gs.parts.viewWrapper({ backstage: Nt.popup }), gc = WB(t) && !c ? B.some(eee(t, Nt.popup.shared.providers)) : B.none(), Fd = en([
        ie ? [] : [go],
        c ? [] : [Lo],
        ie ? [go] : []
      ]), ep = Gs.parts.editorContainer({
        components: en([
          Fd,
          c ? [] : [st.asSpec()]
        ])
      }), Wl = sT(t), Bd = {
        role: "application",
        ...Ad.isRtl() ? { dir: "rtl" } : {},
        ...Wl ? { "aria-hidden": "true" } : {}
      }, _f = Al(Gs.sketch({
        dom: {
          tag: "div",
          classes: [
            "tox",
            "tox-tinymce"
          ].concat(c ? ["tox-tinymce-inline"] : []).concat(ie ? ["tox-tinymce--toolbar-bottom"] : []).concat(ne),
          styles: {
            visibility: "hidden",
            ...Wl ? {
              opacity: "0",
              border: "0"
            } : {}
          },
          attributes: Bd
        },
        components: [
          ep,
          ...c ? [] : [
            Qr,
            ...gc.toArray()
          ],
          Os
        ],
        behaviours: Qt([
          Si(),
          _o.config({ disableClass: "tox-tinymce--disabled" }),
          oo.config({
            mode: "cyclic",
            selector: ".tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a, .tox-statusbar__resize-handle"
          })
        ])
      })), Eu = MR(_f);
      return w.set(Eu), {
        mothership: Eu,
        outerContainer: _f
      };
    }, br = (go) => {
      const Lo = OM(sA(t)), Os = OM(qH(t));
      return t.inline || (Il("div", "width", Os) && Ln(go.element, "width", Os), Il("div", "height", Lo) ? Ln(go.element, "height", Lo) : Ln(go.element, "height", "400px")), Lo;
    }, cn = (go) => {
      t.addShortcut("alt+F9", "focus menubar", () => {
        Gs.focusMenubar(go);
      }), t.addShortcut("alt+F10", "focus toolbar", () => {
        Gs.focusToolbar(go);
      }), t.addCommand("ToggleToolbarDrawer", (Lo, Os) => {
        Os != null && Os.skipFocus ? Gs.toggleToolbarDrawerWithoutFocusing(go) : Gs.toggleToolbarDrawer(go);
      }), t.addQueryStateHandler("ToggleToolbarDrawer", () => Gs.isToolbarDrawerToggled(go));
    }, Un = (go) => {
      const { mainUi: Lo, popupUi: Os, uiMotherships: Qr } = go;
      kt(XE(t), (tw, HA) => {
        t.ui.registry.addGroupToolbarButton(HA, tw);
      });
      const { buttons: gc, menuItems: Fd, contextToolbars: ep, sidebars: Wl, views: Bd } = t.ui.registry.getAll(), _f = vD(t), Eu = {
        menuItems: Fd,
        menus: yD(t),
        menubar: uD(t),
        toolbar: _f.getOrThunk(() => QE(t)),
        allowToolbarGroups: fe === Yu.floating,
        buttons: gc,
        sidebar: Wl,
        views: Bd
      };
      cn(Lo.outerContainer), hY(t, Lo.mothership, Qr), g.setup(t, Nt.popup.shared, De), eJ(t, Nt.popup), yJ(t, Nt.popup.shared.getSink, Nt.popup), RY(t), jY(t, vn, Nt.popup.shared), BQ(t, ep, Os.sink, { backstage: Nt.popup }), ZJ(t, Os.sink);
      const hh = t.getElement(), u0 = br(Lo.outerContainer), uI = {
        targetNode: hh,
        height: u0
      };
      return f.render(t, go, Eu, Nt.popup, uI);
    }, jo = (go) => (A.set(go.mothership), go), So = () => {
      const go = Hr(), Lo = fo(), Os = qb(t) ? Gr() : jo(Lo);
      x.dialogUi.set(Lo), x.popupUi.set(Os), x.mainUi.set(go);
      const Qr = {
        popupUi: Os,
        dialogUi: Lo,
        mainUi: go,
        uiMotherships: x.getUiMotherships()
      };
      return Un(Qr);
    };
    return {
      popups: {
        backstage: Nt.popup,
        getMothership: () => zz("popups", A)
      },
      dialogs: {
        backstage: Nt.dialog,
        getMothership: () => zz("dialogs", T)
      },
      renderUI: So
    };
  }, nee = (t) => t.dom.textContent, Vz = (t, a) => {
    const c = K(t, "id").fold(() => {
      const f = Nn("dialog-label");
      return rn(a, "id", f), f;
    }, lt);
    rn(t, "aria-labelledby", c);
  }, oee = te([
    Rt("lazySink"),
    jr("dragBlockClass"),
    Ca("getBounds", Ra),
    Qe("useTabstopAt", qe),
    Qe("firstTabstop", 0),
    Qe("eventOrder", {}),
    $i("modalBehaviours", [oo]),
    sc("onExecute"),
    Dm("onEscape")
  ]), YM = { sketch: lt }, ree = te([
    yu({
      name: "draghandle",
      overrides: (t, a) => ({
        behaviours: Qt([r0.config({
          mode: "mouse",
          getTarget: (c) => Nm(c, '[role="dialog"]').getOr(c),
          blockerClass: t.dragBlockClass.getOrDie(new Error(`The drag blocker class was not specified for a dialog with a drag handle: 
` + JSON.stringify(a, null, 2)).message),
          getBounds: t.getDragBounds
        })])
      })
    }),
    hl({
      schema: [Rt("dom")],
      name: "title"
    }),
    hl({
      factory: YM,
      schema: [Rt("dom")],
      name: "close"
    }),
    hl({
      factory: YM,
      schema: [Rt("dom")],
      name: "body"
    }),
    yu({
      factory: YM,
      schema: [Rt("dom")],
      name: "footer"
    }),
    Gu({
      factory: {
        sketch: (t, a) => ({
          ...t,
          dom: a.dom,
          components: a.components
        })
      },
      schema: [
        Qe("dom", {
          tag: "div",
          styles: {
            position: "fixed",
            left: "0px",
            top: "0px",
            right: "0px",
            bottom: "0px"
          }
        }),
        Qe("components", [])
      ],
      name: "blocker"
    })
  ]), see = (t, a, c, f) => {
    const g = ms(), x = (fe) => {
      g.set(fe);
      const _e = t.lazySink(fe).getOrDie(), st = f.blocker(), De = _e.getSystem().build({
        ...st,
        components: st.components.concat([Ll(fe)]),
        behaviours: Qt([
          Ao.config({}),
          Go("dialog-blocker-events", [ib(Xd(), () => {
            Jm.isBlocked(fe) ? G() : oo.focusIn(fe);
          })])
        ])
      });
      Gf(_e, De), oo.focusIn(fe);
    }, w = (fe) => {
      g.clear(), Za(fe.element).each((_e) => {
        fe.getSystem().getByDom(_e).each((st) => {
          $m(st);
        });
      });
    }, T = (fe) => uc(fe, t, "body"), A = (fe) => Xt(fe, t, "footer"), F = (fe, _e) => {
      Jm.block(fe, _e);
    }, H = (fe) => {
      Jm.unblock(fe);
    }, q = Nn("modal-events"), ne = {
      ...t.eventOrder,
      [oc()]: [q].concat(t.eventOrder["alloy.system.attached"] || [])
    }, ie = Fl();
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      apis: {
        show: x,
        hide: w,
        getBody: T,
        getFooter: A,
        setIdle: H,
        setBusy: F
      },
      eventOrder: ne,
      domModification: {
        attributes: {
          role: "dialog",
          "aria-modal": "true"
        }
      },
      behaviours: Li(t.modalBehaviours, [
        No.config({}),
        oo.config({
          mode: "cyclic",
          onEnter: t.onExecute,
          onEscape: t.onEscape,
          useTabstopAt: t.useTabstopAt,
          firstTabstop: t.firstTabstop
        }),
        Jm.config({ getRoot: g.get }),
        Go(q, [Qs((fe) => {
          const _e = uc(fe, t, "title").element, st = nee(_e);
          ie.os.isMacOS() && Ce(st) ? rn(fe.element, "aria-label", st) : Vz(fe.element, _e);
        })])
      ])
    };
  }, Hi = Vl({
    name: "ModalDialog",
    configFields: oee(),
    partFields: ree(),
    factory: see,
    apis: {
      show: (t, a) => {
        t.show(a);
      },
      hide: (t, a) => {
        t.hide(a);
      },
      getBody: (t, a) => t.getBody(a),
      getFooter: (t, a) => t.getFooter(a),
      setBusy: (t, a, c) => {
        t.setBusy(a, c);
      },
      setIdle: (t, a) => {
        t.setIdle(a);
      }
    }
  }), aee = wo([
    oi,
    ST
  ].concat(F1)), iee = kc, XM = [
    nR("button"),
    pf,
    fu("align", "end", [
      "start",
      "end"
    ]),
    nS,
    tm,
    Av("buttonType", [
      "primary",
      "secondary"
    ])
  ], QM = [
    ...XM,
    Og
  ], _A = [
    Yi("type", [
      "submit",
      "cancel",
      "custom"
    ]),
    ...QM
  ], s0 = [
    Yi("type", ["menu"]),
    Jb,
    tS,
    pf,
    Ec("items", aee),
    ...XM
  ], lee = [
    ...XM,
    Yi("type", ["togglebutton"]),
    tS,
    pf,
    Jb,
    Ea("active", !1)
  ], JM = ci("type", {
    submit: _A,
    cancel: _A,
    custom: _A,
    menu: s0,
    togglebutton: lee
  }), EA = [
    oi,
    Og,
    Yi("level", [
      "info",
      "warn",
      "error",
      "success"
    ]),
    P$,
    Qe("url", "")
  ], cee = wo(EA), uee = (t) => [
    oi,
    t
  ], dee = [
    oi,
    Og,
    tm,
    nR("button"),
    pf,
    DW,
    Av("buttonType", [
      "primary",
      "secondary",
      "toolbar"
    ]),
    nS
  ], fee = wo(dee), Xx = [
    oi,
    ST
  ], ou = Xx.concat([_T]), jz = Xx.concat([
    kT,
    tm
  ]), mee = wo(jz), pee = kc, hee = ou.concat([OT("auto")]), gee = wo(hee), bee = Tv([
    eS,
    Og,
    P$
  ]), vee = ou.concat([Mi("storageKey", "default")]), yee = wo(vee), xee = On, sk = wo(ou), eI = On, TA = Xx.concat([
    Mi("tag", "textarea"),
    Va("scriptId"),
    Va("scriptUrl"),
    vd("onFocus"),
    P("settings", void 0)
  ]), a0 = Xx.concat([
    Mi("tag", "textarea"),
    _c("init")
  ]), OA = Hh((t) => ia("customeditor.old", Ni(a0), t).orThunk(() => ia("customeditor.new", Ni(TA), t))), wee = On, Wz = wo(ou), Zz = _m(), See = (t) => [
    oi,
    tb("columns"),
    t
  ], kee = [
    oi,
    Va("html"),
    fu("presets", "presentation", [
      "presentation",
      "document"
    ]),
    Ca("onInit", G),
    Ea("stretched", !1)
  ], _ee = wo(kee), Gz = ou.concat([
    Ea("border", !1),
    Ea("sandboxed", !0),
    Ea("streamContent", !1),
    Ea("transparent", !0)
  ]), qz = wo(Gz), tI = On, Eee = wo(Xx.concat([ja("height")])), Tee = wo([
    Va("url"),
    Em("zoom"),
    Em("cachedWidth"),
    Em("cachedHeight")
  ]), Oee = ou.concat([
    ja("inputMode"),
    ja("placeholder"),
    Ea("maximized", !1),
    tm
  ]), Kz = wo(Oee), Aee = On, Pee = (t) => [
    oi,
    kT,
    t,
    fu("align", "start", [
      "start",
      "center",
      "end"
    ]),
    ja("for")
  ], Dee = [
    Og,
    eS
  ], nI = [
    Og,
    Ec("items", xp("items", () => AA))
  ], AA = vp([
    wo(Dee),
    wo(nI)
  ]), Ree = ou.concat([
    Ec("items", AA),
    tm
  ]), Yz = wo(Ree), Nee = On, Mee = ou.concat([
    N0("items", [
      Og,
      eS
    ]),
    Cp("size", 1),
    tm
  ]), Xz = wo(Mee), Iee = On, Fee = ou.concat([
    Ea("constrain", !0),
    tm
  ]), i0 = wo(Fee), oI = wo([
    Va("width"),
    Va("height")
  ]), Bee = Xx.concat([
    kT,
    Cp("min", 0),
    Cp("max", 0)
  ]), PA = wo(Bee), Qx = Mf, DA = [
    oi,
    Ec("header", On),
    Ec("cells", zc(On))
  ], Qz = wo(DA), RA = ou.concat([
    ja("placeholder"),
    Ea("maximized", !1),
    tm
  ]), Su = wo(RA), NA = On, rI = [
    Yi("type", [
      "directory",
      "leaf"
    ]),
    A$,
    Va("id"),
    bd("menu", B7)
  ], Jz = wo(rI), Lee = rI.concat([Ec("children", xp("children", () => If("type", {
    directory: Bg,
    leaf: Jz
  })))]), Bg = wo(Lee), cie = If("type", {
    directory: Bg,
    leaf: Jz
  }), Hee = [
    oi,
    Ec("items", cie),
    vd("onLeafAction"),
    vd("onToggleExpand"),
    I("defaultExpandedIds", [], On),
    ja("defaultSelectedId")
  ], e9 = wo(Hee), Jx = ou.concat([
    fu("filetype", "file", [
      "image",
      "media",
      "file"
    ]),
    tm,
    ja("picker_text")
  ]), MA = wo(Jx), t9 = wo([
    eS,
    eR
  ]), sI = (t) => Qa("items", "items", ec(), zc(Hh((a) => ia(`Checking item of ${t}`, aI, a).fold((c) => zo.error(Bu(c)), (c) => zo.value(c))))), aI = Xa(() => If("type", {
    alertbanner: cee,
    bar: wo(uee(sI("bar"))),
    button: fee,
    checkbox: mee,
    colorinput: yee,
    colorpicker: sk,
    dropzone: Wz,
    grid: wo(See(sI("grid"))),
    iframe: qz,
    input: Kz,
    listbox: Yz,
    selectbox: Xz,
    sizeinput: i0,
    slider: PA,
    textarea: Su,
    urlinput: MA,
    customeditor: OA,
    htmlpanel: _ee,
    imagepreview: Eee,
    collection: gee,
    label: wo(Pee(sI("label"))),
    table: Qz,
    tree: e9,
    panel: n9
  })), zee = [
    oi,
    Qe("classes", []),
    Ec("items", aI)
  ], n9 = wo(zee), ew = [
    nR("tab"),
    A$,
    Ec("items", aI)
  ], uie = [
    oi,
    N0("tabs", ew)
  ], Vee = wo(uie), jee = QM, die = JM, Uee = wo([
    Va("title"),
    Vr("body", If("type", {
      panel: n9,
      tabpanel: Vee
    })),
    Mi("size", "normal"),
    I("buttons", [], die),
    Qe("initialData", {}),
    Ca("onAction", G),
    Ca("onChange", G),
    Ca("onSubmit", G),
    Ca("onClose", G),
    Ca("onCancel", G),
    Ca("onTabChange", G)
  ]), Wee = (t) => ia("dialog", Uee, t), ak = wo([
    Yi("type", [
      "cancel",
      "custom"
    ]),
    ...jee
  ]), Zee = wo([
    Va("title"),
    Va("url"),
    Em("height"),
    Em("width"),
    $u("buttons", ak),
    Ca("onAction", G),
    Ca("onCancel", G),
    Ca("onClose", G),
    Ca("onMessage", G)
  ]), Gee = (t) => ia("dialog", Zee, t), IA = (t) => D(t) ? [t].concat(Ue(Tr(t), IA)) : W(t) ? Ue(t, IA) : [], qee = (t) => _(t.type) && _(t.name), fie = {
    checkbox: pee,
    colorinput: xee,
    colorpicker: eI,
    dropzone: Zz,
    input: Aee,
    iframe: tI,
    imagepreview: Tee,
    selectbox: Iee,
    sizeinput: oI,
    slider: Qx,
    listbox: Nee,
    size: oI,
    textarea: NA,
    urlinput: t9,
    customeditor: wee,
    collection: bee,
    togglemenuitem: iee
  }, e = (t) => B.from(fie[t.type]), n = (t) => To(IA(t), qee), s = (t) => {
    const a = n(t), c = Ue(a, (f) => e(f).fold(() => [], (g) => [Vr(f.name, g)]));
    return wo(c);
  }, l = (t) => {
    var a;
    const c = Zt(Wee(t)), f = s(t), g = (a = t.initialData) !== null && a !== void 0 ? a : {};
    return {
      internalDialog: c,
      dataValidator: f,
      initialData: g
    };
  }, d = {
    open: (t, a) => {
      const c = l(a);
      return t(c.internalDialog, c.initialData, c.dataValidator);
    },
    openUrl: (t, a) => {
      const c = Zt(Gee(a));
      return t(c);
    },
    redial: (t) => l(t)
  };
  var v = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, a) => {
      const c = (f, g) => {
        t.updateState.each((x) => {
          const w = x(f, g);
          a.set(w);
        }), t.renderComponents.each((x) => {
          const w = x(g, a.get());
          (t.reuseDom ? YP : sx)(f, w);
        });
      };
      return js([
        It(Hu(), (f, g) => {
          const x = g;
          if (!x.universal) {
            const w = t.channel;
            jt(x.channels, w) && c(f, x.data);
          }
        }),
        Qs((f, g) => {
          t.initialData.each((x) => {
            c(f, x);
          });
        })
      ]);
    }
  }), O = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getState: (t, a, c) => c
  }), M = [
    Rt("channel"),
    jr("renderComponents"),
    jr("updateState"),
    jr("initialData"),
    Ea("reuseDom", !0)
  ], U = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = no(B.none()), a = () => t.set(B.none());
      return {
        readState: () => t.get().getOr("none"),
        get: t.get,
        set: t.set,
        clear: a
      };
    }
  });
  const Z = Xi({
    fields: M,
    name: "reflecting",
    active: v,
    apis: O,
    state: U
  }), de = (t) => {
    const a = [], c = {};
    return at(t, (f, g) => {
      f.fold(() => {
        a.push(g);
      }, (x) => {
        c[g] = x;
      });
    }), a.length > 0 ? zo.error(a) : zo.value(c);
  }, we = (t, a, c, f) => {
    const g = is(Dx.sketch((x) => ({
      dom: {
        tag: "div",
        classes: ["tox-form"].concat(t.classes)
      },
      components: tt(t.items, (w) => W8(x, w, a, c, f))
    })));
    return {
      dom: {
        tag: "div",
        classes: ["tox-dialog__body"]
      },
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-dialog__body-content"]
        },
        components: [g.asSpec()]
      }],
      behaviours: Qt([
        oo.config({
          mode: "acyclic",
          useTabstopAt: je(Rx)
        }),
        ed.memento(g),
        U6(g, {
          postprocess: (x) => de(x).fold((w) => (console.error(w), {}), lt)
        }),
        Go("dialog-body-panel", [It(Xd(), (x, w) => {
          x.getSystem().broadcastOn([OS], { newFocus: B.some(w.event.target) });
        })])
      ])
    };
  }, me = (t, a) => ({
    uid: t.uid,
    dom: t.dom,
    components: t.components,
    events: WE(t.action),
    behaviours: Li(t.tabButtonBehaviours, [
      Ao.config({}),
      oo.config({
        mode: "execution",
        useSpace: !0,
        useEnter: !0
      }),
      Mn.config({
        store: {
          mode: "memory",
          initialValue: t.value
        }
      })
    ]),
    domModification: t.domModification
  }), Se = Pc({
    name: "TabButton",
    configFields: [
      Qe("uid", void 0),
      Rt("value"),
      Qa("dom", "dom", gp(() => ({
        attributes: {
          role: "tab",
          id: Nn("aria"),
          "aria-selected": "false"
        }
      })), uu()),
      jr("action"),
      Qe("domModification", {}),
      $i("tabButtonBehaviours", [
        Ao,
        oo,
        Mn
      ]),
      Rt("view")
    ],
    factory: me
  }), ze = te([
    Rt("tabs"),
    Rt("dom"),
    Qe("clickToDismiss", !1),
    $i("tabbarBehaviours", [
      wn,
      oo
    ]),
    Uf([
      "tabClass",
      "selectedClass"
    ])
  ]), Ye = Ky({
    factory: Se,
    name: "tabs",
    unit: "tab",
    overrides: (t) => {
      const a = (f, g) => {
        wn.dehighlight(f, g), po(f, Wk(), {
          tabbar: f,
          button: g
        });
      }, c = (f, g) => {
        wn.highlight(f, g), po(f, Uk(), {
          tabbar: f,
          button: g
        });
      };
      return {
        action: (f) => {
          const g = f.getSystem().getByUid(t.uid).getOrDie(), x = wn.isHighlighted(g, f);
          (x && t.clickToDismiss ? a : x ? G : c)(g, f);
        },
        domModification: { classes: [t.markers.tabClass] }
      };
    }
  }), We = te([Ye]), ut = (t, a, c, f) => ({
    uid: t.uid,
    dom: t.dom,
    components: a,
    "debug.sketcher": "Tabbar",
    domModification: { attributes: { role: "tablist" } },
    behaviours: Li(t.tabbarBehaviours, [
      wn.config({
        highlightClass: t.markers.selectedClass,
        itemClass: t.markers.tabClass,
        onHighlight: (g, x) => {
          rn(x.element, "aria-selected", "true");
        },
        onDehighlight: (g, x) => {
          rn(x.element, "aria-selected", "false");
        }
      }),
      oo.config({
        mode: "flow",
        getInitial: (g) => wn.getHighlighted(g).map((x) => x.element),
        selector: "." + t.markers.tabClass,
        executeOnMove: !0
      })
    ])
  }), zt = Vl({
    name: "Tabbar",
    configFields: ze(),
    partFields: We(),
    factory: ut
  }), an = (t, a) => ({
    uid: t.uid,
    dom: t.dom,
    behaviours: Li(t.tabviewBehaviours, [No.config({})]),
    domModification: { attributes: { role: "tabpanel" } }
  }), Dn = Pc({
    name: "Tabview",
    configFields: [$i("tabviewBehaviours", [No])],
    factory: an
  }), Tt = te([
    Qe("selectFirst", !0),
    Rr("onChangeTab"),
    Rr("onDismissTab"),
    Qe("tabs", []),
    $i("tabSectionBehaviours", [])
  ]), yt = hl({
    factory: zt,
    schema: [
      Rt("dom"),
      Yd("markers", [
        Rt("tabClass"),
        Rt("selectedClass")
      ])
    ],
    name: "tabbar",
    defaults: (t) => ({ tabs: t.tabs })
  }), Lt = hl({
    factory: Dn,
    name: "tabview"
  }), Vn = te([
    yt,
    Lt
  ]), co = (t, a, c, f) => {
    const g = (w) => {
      const T = Mn.getValue(w);
      Xt(w, t, "tabview").each((A) => {
        At(t.tabs, (H) => H.value === T).each((H) => {
          const q = H.view();
          K(w.element, "id").each((ne) => {
            rn(A.element, "aria-labelledby", ne);
          }), No.set(A, q), t.onChangeTab(A, w, q);
        });
      });
    }, x = (w, T) => {
      Xt(w, t, "tabbar").each((A) => {
        T(A).each(Tp);
      });
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      behaviours: d1(t.tabSectionBehaviours),
      events: js(en([
        t.selectFirst ? [Qs((w, T) => {
          x(w, wn.getFirst);
        })] : [],
        [
          It(Uk(), (w, T) => {
            const A = T.event.button;
            g(A);
          }),
          It(Wk(), (w, T) => {
            const A = T.event.button;
            t.onDismissTab(w, A);
          })
        ]
      ])),
      apis: {
        getViewItems: (w) => Xt(w, t, "tabview").map((T) => No.contents(T)).getOr([]),
        showTab: (w, T) => {
          x(w, (F) => {
            const H = wn.getCandidates(F);
            return At(H, (ne) => Mn.getValue(ne) === T).filter((ne) => !wn.isHighlighted(F, ne));
          });
        }
      }
    };
  }, Xo = Vl({
    name: "TabSection",
    configFields: Tt(),
    partFields: Vn(),
    factory: co,
    apis: {
      getViewItems: (t, a) => t.getViewItems(a),
      showTab: (t, a, c) => {
        t.showTab(a, c);
      }
    }
  }), Sr = (t, a, c) => tt(t, (f, g) => {
    No.set(c, t[g].view());
    const x = a.dom.getBoundingClientRect();
    return No.set(c, []), x.height;
  }), ts = (t) => so(Jn(t, (a, c) => a > c ? -1 : a < c ? 1 : 0)), Cs = (t, a, c) => {
    const f = Oi(t).dom, g = Nm(t, ".tox-dialog-wrap").getOr(t), x = fs(g, "position") === "fixed";
    let w;
    x ? w = Math.max(f.clientHeight, window.innerHeight) : w = Math.max(f.offsetHeight, f.scrollHeight);
    const T = Bs(a), F = a.dom.offsetLeft >= c.dom.offsetLeft + Pi(c) ? Math.max(Bs(c), T) : T, H = parseInt(fs(t, "margin-top"), 10) || 0, q = parseInt(fs(t, "margin-bottom"), 10) || 0, ie = Bs(t) + H + q - F;
    return w - ie;
  }, Pa = (t, a) => {
    so(t).each((c) => Xo.showTab(a, c.value));
  }, yl = (t, a) => {
    Ln(t, "height", a + "px"), Ln(t, "flex-basis", a + "px");
  }, bs = (t, a, c) => {
    Nm(t, '[role="dialog"]').each((f) => {
      ss(f, '[role="tablist"]').each((g) => {
        c.get().map((x) => (Ln(a, "height", "0"), Ln(a, "flex-basis", "0"), Math.min(x, Cs(f, a, g)))).each((x) => {
          yl(a, x);
        });
      });
    });
  }, hn = (t) => ss(t, '[role="tabpanel"]'), ro = (t) => {
    const a = ms();
    return {
      extraEvents: [
        Qs((g) => {
          const x = g.element;
          hn(x).each((w) => {
            Ln(w, "visibility", "hidden"), g.getSystem().getByDom(w).toOptional().each((T) => {
              const A = Sr(t, w, T);
              ts(A).fold(a.clear, a.set);
            }), bs(x, w, a), xr(w, "visibility"), Pa(t, g), requestAnimationFrame(() => {
              bs(x, w, a);
            });
          });
        }),
        It(tf(), (g) => {
          const x = g.element;
          hn(x).each((w) => {
            bs(x, w, a);
          });
        }),
        It(QL, (g, x) => {
          const w = g.element;
          hn(w).each((T) => {
            const A = uf(le(T));
            Ln(T, "visibility", "hidden");
            const F = ks(T, "height").map((ne) => parseInt(ne, 10));
            xr(T, "height"), xr(T, "flex-basis");
            const H = T.dom.getBoundingClientRect().height;
            F.forall((ne) => H > ne) ? (a.set(H), bs(w, T, a)) : F.each((ne) => {
              yl(T, ne);
            }), xr(T, "visibility"), A.each(mu);
          });
        })
      ],
      selectFirst: !1
    };
  }, Ur = "send-data-to-section", Sn = "send-data-to-view", yo = (t, a, c, f) => {
    const g = no({}), x = (H) => {
      const q = Mn.getValue(H), ne = de(q).getOr({}), ie = g.get(), fe = Fs(ie, ne);
      g.set(fe);
    }, w = (H) => {
      const q = g.get();
      Mn.setValue(H, q);
    }, T = no(null), A = tt(t.tabs, (H) => ({
      value: H.name,
      dom: {
        tag: "div",
        classes: ["tox-dialog__body-nav-item"]
      },
      components: [Oa(c.shared.providers.translate(H.title))],
      view: () => [Dx.sketch((q) => ({
        dom: {
          tag: "div",
          classes: ["tox-form"]
        },
        components: tt(H.items, (ne) => W8(q, ne, a, c, f)),
        formBehaviours: Qt([
          oo.config({
            mode: "acyclic",
            useTabstopAt: je(Rx)
          }),
          Go("TabView.form.events", [
            Qs(w),
            zf(x)
          ]),
          Ac.config({
            channels: Zr([
              {
                key: Ur,
                value: { onReceive: x }
              },
              {
                key: Sn,
                value: { onReceive: w }
              }
            ])
          })
        ])
      }))]
    })), F = ro(A);
    return Xo.sketch({
      dom: {
        tag: "div",
        classes: ["tox-dialog__body"]
      },
      onChangeTab: (H, q, ne) => {
        const ie = Mn.getValue(q);
        po(H, XL, {
          name: ie,
          oldName: T.get()
        }), T.set(ie);
      },
      tabs: A,
      components: [
        Xo.parts.tabbar({
          dom: {
            tag: "div",
            classes: ["tox-dialog__body-nav"]
          },
          components: [zt.parts.tabs({})],
          markers: {
            tabClass: "tox-tab",
            selectedClass: "tox-dialog__body-nav-item--active"
          },
          tabbarBehaviours: Qt([Zs.config({})])
        }),
        Xo.parts.tabview({
          dom: {
            tag: "div",
            classes: ["tox-dialog__body-content"]
          }
        })
      ],
      selectFirst: F.selectFirst,
      tabSectionBehaviours: Qt([
        Go("tabpanel", F.extraEvents),
        oo.config({ mode: "acyclic" }),
        Nr.config({ find: (H) => so(Xo.getViewItems(H)) }),
        X1(B.none(), (H) => (H.getSystem().broadcastOn([Ur], {}), g.get()), (H, q) => {
          g.set(q), H.getSystem().broadcastOn([Sn], {});
        })
      ])
    });
  }, fr = (t, a, c, f, g, x) => {
    const w = (F) => {
      const H = F.body;
      switch (H.type) {
        case "tabpanel":
          return [yo(H, F.initialData, f, x)];
        default:
          return [we(H, F.initialData, f, x)];
      }
    }, T = (F, H) => B.some({ isTabPanel: () => H.body.type === "tabpanel" }), A = { "aria-live": "polite" };
    return {
      dom: {
        tag: "div",
        classes: ["tox-dialog__content-js"],
        attributes: {
          ...c.map((F) => ({ id: F })).getOr({}),
          ...g ? A : {}
        }
      },
      components: [],
      behaviours: Qt([
        ed.childAt(0),
        Z.config({
          channel: `${e8}-${a}`,
          updateState: T,
          renderComponents: w,
          initialData: t
        })
      ])
    };
  }, An = (t, a, c, f, g, x) => fr(t, a, B.some(c), f, g, x), mr = (t, a, c, f) => {
    const g = fr(t, a, B.none(), c, !1, f);
    return Hi.parts.body(g);
  }, _r = (t) => {
    const a = {
      dom: {
        tag: "div",
        classes: ["tox-dialog__content-js"]
      },
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-dialog__body-iframe"]
        },
        components: [X6(B.none(), {
          dom: {
            tag: "iframe",
            attributes: { src: t.url }
          },
          behaviours: Qt([
            Zs.config({}),
            Ao.config({})
          ])
        })]
      }],
      behaviours: Qt([oo.config({
        mode: "acyclic",
        useTabstopAt: je(Rx)
      })])
    };
    return Hi.parts.body(a);
  }, zi = ix.deviceType.isTouch(), ls = (t, a) => ({
    dom: {
      tag: "div",
      styles: { display: "none" },
      classes: ["tox-dialog__header"]
    },
    components: [
      t,
      a
    ]
  }), pi = (t, a) => Hi.parts.close(Rl.sketch({
    dom: {
      tag: "button",
      classes: [
        "tox-button",
        "tox-button--icon",
        "tox-button--naked"
      ],
      attributes: {
        type: "button",
        "aria-label": a.translate("Close")
      }
    },
    action: t,
    buttonBehaviours: Qt([Zs.config({})])
  })), Nd = () => Hi.parts.title({
    dom: {
      tag: "div",
      classes: ["tox-dialog__title"],
      innerHtml: "",
      styles: { display: "none" }
    }
  }), um = (t, a) => Hi.parts.body({
    dom: {
      tag: "div",
      classes: ["tox-dialog__body"]
    },
    components: [{
      dom: {
        tag: "div",
        classes: ["tox-dialog__body-content"]
      },
      components: [{ dom: jm(`<p>${ND(a.translate(t))}</p>`) }]
    }]
  }), pc = (t) => Hi.parts.footer({
    dom: {
      tag: "div",
      classes: ["tox-dialog__footer"]
    },
    components: t
  }), ku = (t, a) => [
    qm.sketch({
      dom: {
        tag: "div",
        classes: ["tox-dialog__footer-start"]
      },
      components: t
    }),
    qm.sketch({
      dom: {
        tag: "div",
        classes: ["tox-dialog__footer-end"]
      },
      components: a
    })
  ], td = (t) => {
    const a = "tox-dialog", c = a + "-wrap", f = c + "__backdrop", g = a + "__disable-scroll";
    return Hi.sketch({
      lazySink: t.lazySink,
      onEscape: (x) => (t.onEscape(x), B.some(!0)),
      useTabstopAt: (x) => !Rx(x),
      firstTabstop: t.firstTabstop,
      dom: {
        tag: "div",
        classes: [a].concat(t.extraClasses),
        styles: {
          position: "relative",
          ...t.extraStyles
        }
      },
      components: [
        t.header,
        t.body,
        ...t.footer.toArray()
      ],
      parts: {
        blocker: {
          dom: jm(`<div class="${c}"></div>`),
          components: [{
            dom: {
              tag: "div",
              classes: zi ? [
                f,
                f + "--opaque"
              ] : [f]
            }
          }]
        }
      },
      dragBlockClass: c,
      modalBehaviours: Qt([
        Ao.config({}),
        Go("dialog-events", t.dialogEvents.concat([
          ib(Xd(), (x, w) => {
            Jm.isBlocked(x) ? G() : oo.focusIn(x);
          }),
          It(Uh(), (x, w) => {
            x.getSystem().broadcastOn([OS], { newFocus: w.event.newFocus });
          })
        ])),
        Go("scroll-lock", [
          Qs(() => {
            Us(Uo(), g);
          }),
          zf(() => {
            va(Uo(), g);
          })
        ]),
        ...t.extraBehaviours
      ]),
      eventOrder: {
        [zu()]: ["dialog-events"],
        [oc()]: [
          "scroll-lock",
          "dialog-events",
          "alloy.base.behaviour"
        ],
        [Vu()]: [
          "alloy.base.behaviour",
          "dialog-events",
          "scroll-lock"
        ],
        ...t.eventOrder
      }
    });
  }, _u = (t) => Rl.sketch({
    dom: {
      tag: "button",
      classes: [
        "tox-button",
        "tox-button--icon",
        "tox-button--naked"
      ],
      attributes: {
        type: "button",
        "aria-label": t.translate("Close"),
        "data-mce-name": "close"
      }
    },
    buttonBehaviours: Qt([
      Zs.config({}),
      gl.config(t.tooltips.getConfig({ tooltipText: t.translate("Close") }))
    ]),
    components: [xu("close", {
      tag: "span",
      classes: ["tox-icon"]
    }, t.icons)],
    action: (a) => {
      tr(a, tv);
    }
  }), Md = (t, a, c, f) => {
    const g = (x) => [Oa(f.translate(x.title))];
    return {
      dom: {
        tag: "h1",
        classes: ["tox-dialog__title"],
        attributes: { ...c.map((x) => ({ id: x })).getOr({}) }
      },
      components: [],
      behaviours: Qt([Z.config({
        channel: `${J6}-${a}`,
        initialData: t,
        renderComponents: g
      })])
    };
  }, uo = () => ({ dom: jm('<div class="tox-dialog__draghandle"></div>') }), $r = (t, a, c, f) => qm.sketch({
    dom: jm('<div class="tox-dialog__header"></div>'),
    components: [
      Md(t, a, B.some(c), f),
      uo(),
      _u(f)
    ],
    containerBehaviours: Qt([r0.config({
      mode: "mouse",
      blockerClass: "blocker",
      getTarget: (g) => cf(g, '[role="dialog"]').getOrDie(),
      snaps: {
        getSnapPoints: () => [],
        leftAttr: "data-drag-left",
        topAttr: "data-drag-top"
      }
    })])
  }), ya = (t, a, c) => {
    const f = Hi.parts.title(Md(t, a, B.none(), c)), g = Hi.parts.draghandle(uo()), x = Hi.parts.close(_u(c)), w = [f].concat(t.draggable ? [g] : []).concat([x]);
    return qm.sketch({
      dom: jm('<div class="tox-dialog__header"></div>'),
      components: w
    });
  }, Da = (t, a, c) => ya({
    title: c.shared.providers.translate(t),
    draggable: c.dialog.isDraggableModal()
  }, a, c.shared.providers), ri = (t, a, c, f) => ({
    dom: {
      tag: "div",
      classes: ["tox-dialog__busy-spinner"],
      attributes: { "aria-label": c.translate(t) },
      styles: {
        left: "0px",
        right: "0px",
        bottom: "0px",
        top: `${f.getOr(0)}px`,
        position: "absolute"
      }
    },
    behaviours: a,
    components: [{ dom: jm('<div class="tox-spinner"><div></div><div></div><div></div></div>') }]
  }), rl = (t, a, c) => ({
    onClose: () => c.closeWindow(),
    onBlock: (f) => {
      const g = ss(t().element, ".tox-dialog__header").map((x) => Bs(x));
      Hi.setBusy(t(), (x, w) => ri(f.message, w, a, g));
    },
    onUnblock: () => {
      Hi.setIdle(t());
    }
  }), Ua = "tox-dialog--fullscreen", Fa = "tox-dialog--width-lg", Ul = "tox-dialog--width-md", nd = (t) => {
    switch (t) {
      case "large":
        return B.some(Fa);
      case "medium":
        return B.some(Ul);
      default:
        return B.none();
    }
  }, Cf = (t, a) => {
    const c = He.fromDom(a.element.dom);
    Zc(c, Ua) || (Gc(c, [
      Fa,
      Ul
    ]), nd(t).each((f) => Us(c, f)));
  }, Sf = (t, a) => {
    const c = He.fromDom(t.element.dom), f = o4(c), g = At(f, (x) => x === Fa || x === Ul).or(nd(a));
    e4(c, [
      Ua,
      ...g.toArray()
    ]);
  }, Id = (t, a, c) => Al(td({
    ...t,
    firstTabstop: 1,
    lazySink: c.shared.getSink,
    extraBehaviours: [
      hO({}),
      ...t.extraBehaviours
    ],
    onEscape: (f) => {
      tr(f, tv);
    },
    dialogEvents: a,
    eventOrder: {
      [Hu()]: [
        Z.name(),
        Ac.name()
      ],
      [oc()]: [
        "scroll-lock",
        Z.name(),
        "messages",
        "dialog-events",
        "alloy.base.behaviour"
      ],
      [Vu()]: [
        "alloy.base.behaviour",
        "dialog-events",
        "messages",
        Z.name(),
        "scroll-lock"
      ]
    }
  })), mh = (t, a = {}) => {
    const c = (f) => {
      const g = tt(f.items, (x) => {
        const w = Ht(a, x.name).getOr(no(!1));
        return {
          ...x,
          storage: w
        };
      });
      return {
        ...f,
        items: g
      };
    };
    return tt(t, (f) => f.type === "menu" ? c(f) : f);
  }, l0 = (t) => Mt(t, (a, c) => c.type === "menu" ? Mt(c.items, (g, x) => (g[x.name] = x.storage, g), a) : a, {}), c0 = (t, a) => [
    Vw(Xd(), Eq),
    t(hS, (c, f, g, x) => {
      uf(le(x.element)).fold(G, Qv), a.onClose(), f.onClose();
    }),
    t(tv, (c, f, g, x) => {
      f.onCancel(c), tr(x, hS);
    }),
    It(BR, (c, f) => a.onUnblock()),
    It(eO, (c, f) => a.onBlock(f.event))
  ], iI = (t, a) => {
    const c = (g, x) => It(g, (w, T) => {
      f(w, (A, F) => {
        x(t(), A, T.event, w);
      });
    }), f = (g, x) => {
      Z.getState(g).get().each((w) => {
        x(w, g);
      });
    };
    return [
      ...c0(c, a),
      c(ah, (g, x, w) => {
        x.onAction(g, { name: w.name });
      })
    ];
  }, ph = (t, a, c) => {
    const f = (x, w) => It(x, (T, A) => {
      g(T, (F, H) => {
        w(t(), F, A.event, T);
      });
    }), g = (x, w) => {
      Z.getState(x).get().each((T) => {
        w(T.internalDialog, x);
      });
    };
    return [
      ...c0(f, a),
      f(_x, (x, w) => w.onSubmit(x)),
      f(wu, (x, w, T) => {
        w.onChange(x, { name: T.name });
      }),
      f(ah, (x, w, T, A) => {
        const F = () => A.getSystem().isConnected() ? oo.focusIn(A) : void 0, H = (ie) => ge(ie, "disabled") || K(ie, "aria-disabled").exists((fe) => fe === "true"), q = le(A.element), ne = uf(q);
        w.onAction(x, {
          name: T.name,
          value: T.value
        }), uf(q).fold(F, (ie) => {
          H(ie) || ne.exists((fe) => ka(ie, fe) && H(fe)) ? F() : c().toOptional().filter((fe) => !ka(fe.element, ie)).each(F);
        });
      }),
      f(XL, (x, w, T) => {
        w.onTabChange(x, {
          newTabName: T.name,
          oldTabName: T.oldName
        });
      }),
      zf((x) => {
        const w = t();
        Mn.setValue(x, w.getData());
      })
    ];
  }, FA = (t, a) => J1(t, t.type, a), o9 = (t, a, c) => At(a, (f) => f.name === c).bind((f) => f.memento.getOpt(t)), hc = (t, a) => {
    const c = a.map((T) => T.footerButtons).getOr([]), f = Wo(c, (T) => T.align === "start"), g = (T, A) => qm.sketch({
      dom: {
        tag: "div",
        classes: [`tox-dialog__footer-${T}`]
      },
      components: tt(A, (F) => F.memento.asSpec())
    }), x = g("start", f.pass), w = g("end", f.fail);
    return [
      x,
      w
    ];
  }, dv = (t, a, c) => {
    const f = (g, x) => {
      const w = tt(x.buttons, (A) => {
        const F = is(FA(A, c));
        return {
          name: A.name,
          align: A.align,
          memento: F
        };
      }), T = (A) => o9(g, w, A);
      return B.some({
        lookupByName: T,
        footerButtons: w
      });
    };
    return {
      dom: jm('<div class="tox-dialog__footer"></div>'),
      components: [],
      behaviours: Qt([Z.config({
        channel: `${t8}-${a}`,
        initialData: t,
        updateState: f,
        renderComponents: hc
      })])
    };
  }, r9 = (t, a, c) => dv(t, a, c), BA = (t, a, c) => Hi.parts.footer(dv(t, a, c)), kf = (t, a) => {
    if (t.getRoot().getSystem().isConnected()) {
      const f = Nr.getCurrent(t.getFormWrapper()).getOr(t.getFormWrapper());
      return Dx.getField(f, a).orThunk(() => t.getFooter().bind((w) => Z.getState(w).get()).bind((w) => w.lookupByName(a)));
    } else
      return B.none();
  }, ik = (t, a) => {
    const c = t.getRoot();
    return Z.getState(c).get().map((f) => Zt(ia("data", f.dataValidator, a))).getOr(a);
  }, ht = (t, a, c) => {
    const f = (fe) => {
      const _e = t.getRoot();
      _e.getSystem().isConnected() && fe(_e);
    }, ie = {
      getData: () => {
        const fe = t.getRoot(), _e = fe.getSystem().isConnected() ? t.getFormWrapper() : fe, st = Mn.getValue(_e), De = kt(c, (Je) => Je.get());
        return {
          ...st,
          ...De
        };
      },
      setData: (fe) => {
        f((_e) => {
          const st = ie.getData(), De = Fs(st, fe), Je = ik(t, De), Ge = t.getFormWrapper();
          Mn.setValue(Ge, Je), at(c, (Ft, gt) => {
            Ho(De, gt) && Ft.set(De[gt]);
          });
        });
      },
      setEnabled: (fe, _e) => {
        kf(t, fe).each(_e ? _o.enable : _o.disable);
      },
      focus: (fe) => {
        kf(t, fe).each(Ao.focus);
      },
      block: (fe) => {
        if (!_(fe))
          throw new Error("The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
        f((_e) => {
          po(_e, eO, { message: fe });
        });
      },
      unblock: () => {
        f((fe) => {
          tr(fe, BR);
        });
      },
      showTab: (fe) => {
        f((_e) => {
          const st = t.getBody();
          Z.getState(st).get().exists((Je) => Je.isTabPanel()) && Nr.getCurrent(st).each((Je) => {
            Xo.showTab(Je, fe);
          });
        });
      },
      redial: (fe) => {
        f((_e) => {
          const st = t.getId(), De = a(fe), Je = mh(De.internalDialog.buttons, c);
          _e.getSystem().broadcastOn([`${TS}-${st}`], De), _e.getSystem().broadcastOn([`${J6}-${st}`], De.internalDialog), _e.getSystem().broadcastOn([`${e8}-${st}`], De.internalDialog), _e.getSystem().broadcastOn([`${t8}-${st}`], {
            ...De.internalDialog,
            buttons: Je
          }), ie.setData(De.initialData);
        });
      },
      close: () => {
        f((fe) => {
          tr(fe, hS);
        });
      },
      toggleFullscreen: t.toggleFullscreen
    };
    return ie;
  }, xt = (t, a, c) => {
    const f = Nn("dialog"), g = t.internalDialog, x = Da(g.title, f, c), w = no(g.size), T = (Ge) => kf(De, Ge), A = nd(w.get()).toArray(), F = (Ge, Ft) => (w.set(Ft.internalDialog.size), Cf(Ft.internalDialog.size, Ge), B.some(Ft)), H = mr({
      body: g.body,
      initialData: g.initialData
    }, f, c, T), q = mh(g.buttons), ne = l0(q), ie = Xn(q.length !== 0, BA({ buttons: q }, f, c)), fe = ph(() => Je, rl(() => st, c.shared.providers, a), c.shared.getSink), _e = {
      id: f,
      header: x,
      body: H,
      footer: ie,
      extraClasses: A,
      extraBehaviours: [Z.config({
        channel: `${TS}-${f}`,
        updateState: F,
        initialData: t
      })],
      extraStyles: {}
    }, st = Id(_e, fe, c), De = (() => {
      const Ge = () => {
        const gt = Hi.getBody(st);
        return Nr.getCurrent(gt).getOr(gt);
      }, Ft = () => {
        Sf(st, w.get());
      };
      return {
        getId: te(f),
        getRoot: te(st),
        getBody: () => Hi.getBody(st),
        getFooter: () => Hi.getFooter(st),
        getFormWrapper: Ge,
        toggleFullscreen: Ft
      };
    })(), Je = ht(De, a.redial, ne);
    return {
      dialog: st,
      instanceApi: Je
    };
  }, fn = (t, a, c, f = !1, g) => {
    const x = Nn("dialog"), w = Nn("dialog-label"), T = Nn("dialog-content"), A = t.internalDialog, F = (Yn) => kf(vn, Yn), H = no(A.size), q = nd(H.get()).toArray(), ne = (Yn, In) => (H.set(In.internalDialog.size), Cf(In.internalDialog.size, Yn), g(), B.some(In)), ie = is($r({
      title: A.title,
      draggable: !0
    }, x, w, c.shared.providers)), fe = is(An({
      body: A.body,
      initialData: A.initialData
    }, x, T, c, f, F)), _e = mh(A.buttons), st = l0(_e), De = Xn(_e.length !== 0, is(r9({ buttons: _e }, x, c))), Je = ph(() => Nt, {
      onBlock: (Yn) => {
        Jm.block(gt, (In, xo) => {
          const fo = ie.getOpt(gt).map((Gr) => Bs(Gr.element));
          return ri(Yn.message, xo, c.shared.providers, fo);
        });
      },
      onUnblock: () => {
        Jm.unblock(gt);
      },
      onClose: () => a.closeWindow()
    }, c.shared.getSink), Ge = "tox-dialog-inline", Ft = Fl().os, gt = Al({
      dom: {
        tag: "div",
        classes: [
          "tox-dialog",
          Ge,
          ...q
        ],
        attributes: {
          role: "dialog",
          ...Ft.isMacOS() ? { "aria-label": A.title } : { "aria-labelledby": w }
        }
      },
      eventOrder: {
        [Hu()]: [
          Z.name(),
          Ac.name()
        ],
        [zu()]: ["execute-on-form"],
        [oc()]: [
          "reflecting",
          "execute-on-form"
        ]
      },
      behaviours: Qt([
        oo.config({
          mode: "cyclic",
          onEscape: (Yn) => (tr(Yn, hS), B.some(!0)),
          useTabstopAt: (Yn) => !Rx(Yn) && (Kr(Yn) !== "button" || os(Yn, "disabled") !== "disabled"),
          firstTabstop: 1
        }),
        Z.config({
          channel: `${TS}-${x}`,
          updateState: ne,
          initialData: t
        }),
        Ao.config({}),
        Go("execute-on-form", Je.concat([
          ib(Xd(), (Yn, In) => {
            oo.focusIn(Yn);
          }),
          It(Uh(), (Yn, In) => {
            Yn.getSystem().broadcastOn([OS], { newFocus: In.event.newFocus });
          })
        ])),
        Jm.config({ getRoot: () => B.some(gt) }),
        No.config({}),
        hO({})
      ]),
      components: [
        ie.asSpec(),
        fe.asSpec(),
        ...De.map((Yn) => Yn.asSpec()).toArray()
      ]
    }), Jt = () => {
      Sf(gt, H.get());
    }, vn = {
      getId: te(x),
      getRoot: te(gt),
      getFooter: () => De.map((Yn) => Yn.get(gt)),
      getBody: () => fe.get(gt),
      getFormWrapper: () => {
        const Yn = fe.get(gt);
        return Nr.getCurrent(Yn).getOr(Yn);
      },
      toggleFullscreen: Jt
    }, Nt = ht(vn, a.redial, st);
    return {
      dialog: gt,
      instanceApi: Nt
    };
  };
  var nn = tinymce.util.Tools.resolve("tinymce.util.URI");
  const Eo = (t) => {
    const a = (w) => {
      t.getSystem().isConnected() && w(t);
    };
    return {
      block: (w) => {
        if (!_(w))
          throw new Error("The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
        a((T) => {
          po(T, eO, { message: w });
        });
      },
      unblock: () => {
        a((w) => {
          tr(w, BR);
        });
      },
      close: () => {
        a((w) => {
          tr(w, hS);
        });
      },
      sendMessage: (w) => {
        a((T) => {
          T.getSystem().broadcastOn([n8], w);
        });
      }
    };
  }, Ar = [
    "insertContent",
    "setContent",
    "execCommand",
    "close",
    "block",
    "unblock"
  ], ha = (t) => D(t) && Ar.indexOf(t.mceAction) !== -1, dm = (t) => !ha(t) && D(t) && Ho(t, "mceAction"), $A = (t, a, c) => {
    switch (c.mceAction) {
      case "insertContent":
        t.insertContent(c.content);
        break;
      case "setContent":
        t.setContent(c.content);
        break;
      case "execCommand":
        const f = J(c.ui) ? c.ui : !1;
        t.execCommand(c.cmd, f, c.value);
        break;
      case "close":
        a.close();
        break;
      case "block":
        a.block(c.message);
        break;
      case "unblock":
        a.unblock();
        break;
    }
  }, Kee = (t, a, c, f) => {
    const g = Nn("dialog"), x = Da(t.title, g, f), w = _r(t), T = t.buttons.bind((Ge) => Ge.length === 0 ? B.none() : B.some(BA({ buttons: Ge }, g, f))), A = iI(() => Je, rl(() => De, f.shared.providers, a)), F = {
      ...t.height.fold(() => ({}), (Ge) => ({
        height: Ge + "px",
        "max-height": Ge + "px"
      })),
      ...t.width.fold(() => ({}), (Ge) => ({
        width: Ge + "px",
        "max-width": Ge + "px"
      }))
    }, H = t.width.isNone() && t.height.isNone() ? ["tox-dialog--width-lg"] : [], q = new nn(t.url, { base_uri: new nn(window.location.href) }), ne = `${q.protocol}://${q.host}${q.port ? ":" + q.port : ""}`, ie = za(), fe = (Ge, Ft) => B.some(Ft), _e = [
      Z.config({
        channel: `${TS}-${g}`,
        updateState: fe,
        initialData: t
      }),
      Go("messages", [
        Qs(() => {
          const Ge = lc(He.fromDom(window), "message", (Ft) => {
            if (q.isSameOrigin(new nn(Ft.raw.origin))) {
              const gt = Ft.raw.data;
              ha(gt) ? $A(c, Je, gt) : dm(gt) && t.onMessage(Je, gt);
            }
          });
          ie.set(Ge);
        }),
        zf(ie.clear)
      ]),
      Ac.config({
        channels: {
          [n8]: {
            onReceive: (Ge, Ft) => {
              ss(Ge.element, "iframe").each((gt) => {
                const Jt = gt.dom.contentWindow;
                Ce(Jt) && Jt.postMessage(Ft, ne);
              });
            }
          }
        }
      })
    ], De = Id({
      id: g,
      header: x,
      body: w,
      footer: T,
      extraClasses: H,
      extraBehaviours: _e,
      extraStyles: F
    }, A, f), Je = Eo(De);
    return {
      dialog: De,
      instanceApi: Je
    };
  }, LA = (t) => {
    const a = t.shared;
    return { open: (f, g) => {
      const x = () => {
        Hi.hide(F), g();
      }, w = is(J1({
        name: "close-alert",
        text: "OK",
        primary: !0,
        buttonType: B.some("primary"),
        align: "end",
        enabled: !0,
        icon: B.none()
      }, "cancel", t)), T = Nd(), A = pi(x, a.providers), F = Al(td({
        lazySink: () => a.getSink(),
        header: ls(T, A),
        body: um(f, a.providers),
        footer: B.some(pc(ku([], [w.asSpec()]))),
        onEscape: x,
        extraClasses: ["tox-alert-dialog"],
        extraBehaviours: [],
        extraStyles: {},
        dialogEvents: [It(tv, x)],
        eventOrder: {}
      }));
      Hi.show(F);
      const H = w.get(F);
      Ao.focus(H);
    } };
  }, $g = (t) => {
    const a = t.shared;
    return { open: (f, g) => {
      const x = (ne) => {
        Hi.hide(H), g(ne);
      }, w = is(J1({
        name: "yes",
        text: "Yes",
        primary: !0,
        buttonType: B.some("primary"),
        align: "end",
        enabled: !0,
        icon: B.none()
      }, "submit", t)), T = J1({
        name: "no",
        text: "No",
        primary: !1,
        buttonType: B.some("secondary"),
        align: "end",
        enabled: !0,
        icon: B.none()
      }, "cancel", t), A = Nd(), F = pi(() => x(!1), a.providers), H = Al(td({
        lazySink: () => a.getSink(),
        header: ls(A, F),
        body: um(f, a.providers),
        footer: B.some(pc(ku([], [
          T,
          w.asSpec()
        ]))),
        onEscape: () => x(!1),
        extraClasses: ["tox-confirm-dialog"],
        extraBehaviours: [],
        extraStyles: {},
        dialogEvents: [
          It(tv, () => x(!1)),
          It(_x, () => x(!0))
        ],
        eventOrder: {}
      }));
      Hi.show(H);
      const q = w.get(H);
      Ao.focus(q);
    } };
  }, lI = (t, a) => Zt(ia("data", a, t)), cI = (t) => mS(t, ".tox-alert-dialog") || mS(t, ".tox-confirm-dialog"), s9 = (t, a, c) => a && c ? [] : [pa.config({
    contextual: {
      lazyContext: () => B.some(aa(He.fromDom(t.getContentAreaContainer()))),
      fadeInClass: "tox-dialog-dock-fadein",
      fadeOutClass: "tox-dialog-dock-fadeout",
      transitionClass: "tox-dialog-dock-transition"
    },
    modes: ["top"],
    lazyViewport: (f) => Eg(t, f.element).map((x) => ({
      bounds: D1(x),
      optScrollEnv: B.some({
        currentScrollTop: x.element.dom.scrollTop,
        scrollElmTop: Ga(x.element).top
      })
    })).getOrThunk(() => ({
      bounds: Ra(),
      optScrollEnv: B.none()
    }))
  })], a9 = (t) => {
    const a = t.editor, c = dx(a), f = LA(t.backstages.dialog), g = $g(t.backstages.dialog), x = (fe, _e, st) => {
      if (!be(_e)) {
        if (_e.inline === "toolbar")
          return F(fe, t.backstages.popup.shared.anchors.inlineDialog(), st, _e);
        if (_e.inline === "bottom")
          return H(fe, t.backstages.popup.shared.anchors.inlineBottomDialog(), st, _e);
        if (_e.inline === "cursor")
          return F(fe, t.backstages.popup.shared.anchors.cursor(), st, _e);
      }
      return A(fe, st);
    }, w = (fe, _e) => T(fe, _e), T = (fe, _e) => {
      const st = (De) => {
        const Je = Kee(De, {
          closeWindow: () => {
            Hi.hide(Je.dialog), _e(Je.instanceApi);
          }
        }, a, t.backstages.dialog);
        return Hi.show(Je.dialog), Je.instanceApi;
      };
      return d.openUrl(st, fe);
    }, A = (fe, _e) => {
      const st = (De, Je, Ge) => {
        const Ft = Je, Jt = xt({
          dataValidator: Ge,
          initialData: Ft,
          internalDialog: De
        }, {
          redial: d.redial,
          closeWindow: () => {
            Hi.hide(Jt.dialog), _e(Jt.instanceApi);
          }
        }, t.backstages.dialog);
        return Hi.show(Jt.dialog), Jt.instanceApi.setData(Ft), Jt.instanceApi;
      };
      return d.open(st, fe);
    }, F = (fe, _e, st, De) => {
      const Je = (Ge, Ft, gt) => {
        const Jt = lI(Ft, gt), vn = ms(), Nt = t.backstages.popup.shared.header.isPositionedAtTop(), Yn = {
          dataValidator: gt,
          initialData: Jt,
          internalDialog: Ge
        }, In = () => vn.on((Hr) => {
          la.reposition(Hr), (!c || !Nt) && pa.refresh(Hr);
        }), xo = fn(Yn, {
          redial: d.redial,
          closeWindow: () => {
            vn.on(la.hide), a.off("ResizeEditor", In), vn.clear(), st(xo.instanceApi);
          }
        }, t.backstages.popup, De.ariaAttrs, In), fo = Al(la.sketch({
          lazySink: t.backstages.popup.shared.getSink,
          dom: {
            tag: "div",
            classes: []
          },
          fireDismissalEventInstead: De.persistent ? { event: "doNotDismissYet" } : {},
          ...Nt ? {} : { fireRepositionEventInstead: {} },
          inlineBehaviours: Qt([
            Go("window-manager-inline-events", [It(_p(), (Hr, br) => {
              tr(xo.dialog, tv);
            })]),
            ...s9(a, c, Nt)
          ]),
          isExtraPart: (Hr, br) => cI(br)
        }));
        vn.set(fo);
        const Gr = () => {
          const Hr = a.inline ? Uo() : He.fromDom(a.getContainer()), br = aa(Hr);
          return B.some(br);
        };
        return la.showWithinBounds(fo, Ll(xo.dialog), { anchor: _e }, Gr), (!c || !Nt) && (pa.refresh(fo), a.on("ResizeEditor", In)), xo.instanceApi.setData(Jt), oo.focusIn(xo.dialog), xo.instanceApi;
      };
      return d.open(Je, fe);
    }, H = (fe, _e, st, De) => {
      const Je = (Ge, Ft, gt) => {
        const Jt = lI(Ft, gt), vn = ms(), Nt = t.backstages.popup.shared.header.isPositionedAtTop(), Yn = {
          dataValidator: gt,
          initialData: Jt,
          internalDialog: Ge
        }, In = () => vn.on((Hr) => {
          la.reposition(Hr), pa.refresh(Hr);
        }), xo = fn(Yn, {
          redial: d.redial,
          closeWindow: () => {
            vn.on(la.hide), a.off("ResizeEditor ScrollWindow ElementScroll", In), vn.clear(), st(xo.instanceApi);
          }
        }, t.backstages.popup, De.ariaAttrs, In), fo = Al(la.sketch({
          lazySink: t.backstages.popup.shared.getSink,
          dom: {
            tag: "div",
            classes: []
          },
          fireDismissalEventInstead: De.persistent ? { event: "doNotDismissYet" } : {},
          ...Nt ? {} : { fireRepositionEventInstead: {} },
          inlineBehaviours: Qt([
            Go("window-manager-inline-events", [It(_p(), (Hr, br) => {
              tr(xo.dialog, tv);
            })]),
            pa.config({
              contextual: {
                lazyContext: () => B.some(aa(He.fromDom(a.getContentAreaContainer()))),
                fadeInClass: "tox-dialog-dock-fadein",
                fadeOutClass: "tox-dialog-dock-fadeout",
                transitionClass: "tox-dialog-dock-transition"
              },
              modes: [
                "top",
                "bottom"
              ],
              lazyViewport: (Hr) => Eg(a, Hr.element).map((cn) => ({
                bounds: D1(cn),
                optScrollEnv: B.some({
                  currentScrollTop: cn.element.dom.scrollTop,
                  scrollElmTop: Ga(cn.element).top
                })
              })).getOrThunk(() => ({
                bounds: Ra(),
                optScrollEnv: B.none()
              }))
            })
          ]),
          isExtraPart: (Hr, br) => cI(br)
        }));
        vn.set(fo);
        const Gr = () => t.backstages.popup.shared.getSink().toOptional().bind((Hr) => {
          const br = Eg(a, Hr.element), cn = 15, Un = br.map((go) => D1(go)).getOr(Ra()), jo = aa(He.fromDom(a.getContentAreaContainer())), So = Ih(jo, Un);
          return B.some(Is(So.x, So.y, So.width, So.height - cn));
        });
        return la.showWithinBounds(fo, Ll(xo.dialog), { anchor: _e }, Gr), pa.refresh(fo), a.on("ResizeEditor ScrollWindow ElementScroll ResizeWindow", In), xo.instanceApi.setData(Jt), oo.focusIn(xo.dialog), xo.instanceApi;
      };
      return d.open(Je, fe);
    };
    return {
      open: x,
      openUrl: w,
      alert: (fe, _e) => {
        f.open(fe, _e);
      },
      close: (fe) => {
        fe.close();
      },
      confirm: (fe, _e) => {
        g.open(fe, _e);
      }
    };
  }, Yee = (t) => {
    MB(t), hZ(t), nJ(t);
  };
  var Er = () => {
    qd.add("silver", (t) => {
      Yee(t);
      let a = () => Ra();
      const {
        dialogs: c,
        popups: f,
        renderUI: g
      } = tee(t, { getPopupSinkBounds: () => a() }), x = () => {
        const F = g();
        return Eg(t, f.getMothership().element).each((q) => {
          a = () => D1(q);
        }), F;
      };
      lG.register(t, f.backstage.shared);
      const w = a9({
        editor: t,
        backstages: {
          popup: f.backstage,
          dialog: c.backstage
        }
      }), T = ms(), A = () => bW(t, { backstage: f.backstage }, f.getMothership(), T);
      return {
        renderUI: x,
        getWindowManagerImpl: te(w),
        getNotificationManagerImpl: A
      };
    });
  };
  Er();
})();
tinymce.IconManager.add("default", {
  icons: {
    "accessibility-check": '<svg width="24" height="24"><path d="M12 2a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2c0-1.1.9-2 2-2Zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5c0-.6-.4-1-1-1a1 1 0 0 0-1 1v5c0 .6-.4 1-1 1a1 1 0 0 1-1-1V9H4a1 1 0 1 1 0-2h16c.6 0 1 .4 1 1s-.4 1-1 1Z" fill-rule="nonzero"/></svg>',
    "accordion-toggle": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 15c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1h-6a1 1 0 0 1-1-1Z"/><path opacity=".2" fill-rule="evenodd" clip-rule="evenodd" d="M4 15c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1-1-1Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12 19c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1h-6a1 1 0 0 1-1-1Z"/><path opacity=".2" fill-rule="evenodd" clip-rule="evenodd" d="M4 19c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1-1-1Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3 7.3a1 1 0 0 1 1.4 0L16 9.6l2.3-2.3a1 1 0 1 1 1.4 1.4L16 12.4l-3.7-3.7a1 1 0 0 1 0-1.4ZM4.3 11.7a1 1 0 0 1 0-1.4L6.6 8 4.3 5.7a1 1 0 0 1 1.4-1.4L9.4 8l-3.7 3.7a1 1 0 0 1-1.4 0Z"/></svg>',
    accordion: '<svg width="24" height="24"><rect x="12" y="7" width="10" height="2" rx="1"/><rect x="12" y="11" width="10" height="2" rx="1"/><rect x="12" y="15" width="6" height="2" rx="1"/><path fill-rule="evenodd" clip-rule="evenodd" d="M2.3 7.3a1 1 0 0 1 1.4 0L6 9.6l2.3-2.3a1 1 0 0 1 1.4 1.4L6 12.4 2.3 8.7a1 1 0 0 1 0-1.4Z"/></svg>',
    "action-next": '<svg width="24" height="24"><path fill-rule="nonzero" d="M5.7 7.3a1 1 0 0 0-1.4 1.4l7.7 7.7 7.7-7.7a1 1 0 1 0-1.4-1.4L12 13.6 5.7 7.3Z"/></svg>',
    "action-prev": '<svg width="24" height="24"><path fill-rule="nonzero" d="M18.3 15.7a1 1 0 0 0 1.4-1.4L12 6.6l-7.7 7.7a1 1 0 0 0 1.4 1.4L12 9.4l6.3 6.3Z"/></svg>',
    addtag: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 5a2 2 0 0 1 1.6.8L21 12l-4.4 6.2a2 2 0 0 1-1.6.8h-3v-2h3l3.5-5L15 7H5v3H3V7c0-1.1.9-2 2-2h10Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6 12a1 1 0 0 0-1 1v2H3a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2H7v-2c0-.6-.4-1-1-1Z"/></svg>',
    "ai-prompt": '<svg width="24" height="24"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 6.7a1 1 0 0 0-1.4 0l-9.9 10a1 1 0 0 0 0 1.3l2.1 2.1c.4.4 1 .4 1.4 0l10-9.9c.3-.3.3-1 0-1.4l-2.2-2Zm1.4 2.8-2-2-3 2.7 2.2 2.2 2.8-2.9Z"/><path d="m18.5 7.3-.7-1.5-1.5-.8 1.5-.7.7-1.5.7 1.5 1.5.7-1.5.8-.7 1.5ZM18.5 16.5l-.7-1.6-1.5-.7 1.5-.7.7-1.6.7 1.6 1.5.7-1.5.7-.7 1.6ZM9.7 7.3 9 5.8 7.5 5 9 4.3l.7-1.5.7 1.5L12 5l-1.5.8-.7 1.5Z"/></g><defs><clipPath id="a"><path d="M0 0h24v24H0z"/></clipPath></defs></svg>',
    ai: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M5 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3H5Zm6.8 11.5.5 1.2a68.3 68.3 0 0 0 .7 1.1l.4.1c.3 0 .5 0 .7-.3.2-.1.3-.3.3-.6l-.3-1-2.6-6.2a20.4 20.4 0 0 0-.5-1.3l-.5-.4-.7-.2c-.2 0-.5 0-.6.2-.2 0-.4.2-.5.4l-.3.6-.3.7L5.7 15l-.2.6-.1.4c0 .3 0 .5.3.7l.6.2c.3 0 .5 0 .7-.2l.4-1 .5-1.2h3.9ZM9.8 9l1.5 4h-3l1.5-4Zm5.6-.9v7.6c0 .4 0 .7.2 1l.7.2c.3 0 .6 0 .8-.3l.2-.9V8.1c0-.4 0-.7-.2-.9a1 1 0 0 0-.8-.3c-.2 0-.5.1-.7.3l-.2 1Z"/></svg>',
    "align-center": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "align-justify": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "align-left": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "align-none": '<svg width="24" height="24"><path d="M14.2 5 13 7H5a1 1 0 1 1 0-2h9.2Zm4 0h.8a1 1 0 0 1 0 2h-2l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h6.8Zm4 0H19a1 1 0 0 1 0 2h-4.4l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h4.4Zm4 0H19a1 1 0 0 1 0 2h-6.8l1.2-2ZM7 17l-1.2 2H5a1 1 0 0 1 0-2h2Zm4 0h8a1 1 0 0 1 0 2H9.8l1.2-2Zm5.2-13.5 1.3.7-9.7 16.3-1.3-.7 9.7-16.3Z" fill-rule="evenodd"/></svg>',
    "align-right": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "arrow-left": '<svg width="24" height="24"><path d="m5.6 13 12 6a1 1 0 0 0 1.4-1V6a1 1 0 0 0-1.4-.9l-12 6a1 1 0 0 0 0 1.8Z" fill-rule="evenodd"/></svg>',
    "arrow-right": '<svg width="24" height="24"><path d="m18.5 13-12 6A1 1 0 0 1 5 18V6a1 1 0 0 1 1.4-.9l12 6a1 1 0 0 1 0 1.8Z" fill-rule="evenodd"/></svg>',
    bold: '<svg width="24" height="24"><path d="M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 0 1-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8Zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4Zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4Z" fill-rule="evenodd"/></svg>',
    bookmark: '<svg width="24" height="24"><path d="M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 0 0-1 1Z" fill-rule="nonzero"/></svg>',
    "border-style": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="2" x="3" y="6" rx="1"/><rect width="2.8" height="2" x="3" y="16" rx="1"/><rect width="2.8" height="2" x="6.8" y="16" rx="1"/><rect width="2.8" height="2" x="10.6" y="16" rx="1"/><rect width="2.8" height="2" x="14.4" y="16" rx="1"/><rect width="2.8" height="2" x="18.2" y="16" rx="1"/><rect width="8" height="2" x="3" y="11" rx="1"/><rect width="8" height="2" x="13" y="11" rx="1"/></g></svg>',
    "border-width": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="5" x="3" y="5" rx="1"/><rect width="18" height="3.5" x="3" y="11.5" rx="1"/><rect width="18" height="2" x="3" y="17" rx="1"/></g></svg>',
    brightness: '<svg width="24" height="24"><path d="M12 17c.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7v-1c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3Zm0-10a1 1 0 0 1-.7-.3A1 1 0 0 1 11 6V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3Zm7 4c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-1a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1ZM7 12c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H5a1 1 0 0 1-.7-.3A1 1 0 0 1 4 12c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1c.3 0 .5.1.7.3.2.2.3.4.3.7Zm10 3.5.7.8c.2.1.3.4.3.6 0 .3-.1.6-.3.8a1 1 0 0 1-.8.3 1 1 0 0 1-.6-.3l-.8-.7a1 1 0 0 1-.3-.8c0-.2.1-.5.3-.7a1 1 0 0 1 1.4 0Zm-10-7-.7-.8a1 1 0 0 1-.3-.6c0-.3.1-.6.3-.8.2-.2.5-.3.8-.3.2 0 .5.1.7.3l.7.7c.2.2.3.5.3.8 0 .2-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.8-.3Zm10 0a1 1 0 0 1-.8.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.6.3-.8l.8-.7c.1-.2.4-.3.6-.3.3 0 .6.1.8.3.2.2.3.5.3.8 0 .2-.1.5-.3.7l-.7.7Zm-10 7c.2-.2.5-.3.8-.3.2 0 .5.1.7.3a1 1 0 0 1 0 1.4l-.8.8a1 1 0 0 1-.6.3 1 1 0 0 1-.8-.3 1 1 0 0 1-.3-.8c0-.2.1-.5.3-.6l.7-.8ZM12 8a4 4 0 0 1 3.7 2.4 4 4 0 0 1 0 3.2A4 4 0 0 1 12 16a4 4 0 0 1-3.7-2.4 4 4 0 0 1 0-3.2A4 4 0 0 1 12 8Zm0 6.5c.7 0 1.3-.2 1.8-.7.5-.5.7-1.1.7-1.8s-.2-1.3-.7-1.8c-.5-.5-1.1-.7-1.8-.7s-1.3.2-1.8.7c-.5.5-.7 1.1-.7 1.8s.2 1.3.7 1.8c.5.5 1.1.7 1.8.7Z" fill-rule="evenodd"/></svg>',
    browse: '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9.4-2.3 2.3a1 1 0 1 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1-1.4 1.4L13 13.4V20a1 1 0 0 1-2 0v-6.6Z" fill-rule="nonzero"/></svg>',
    cancel: '<svg width="24" height="24"><path d="M12 4.6a7.4 7.4 0 1 1 0 14.8 7.4 7.4 0 0 1 0-14.8ZM12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7Z" fill-rule="nonzero"/></svg>',
    "cell-background-color": '<svg width="24" height="24"><path d="m15.7 2 1.6 1.6-2.7 2.6 5.9 5.8c.7.7.7 1.7 0 2.4l-6.3 6.1a1.7 1.7 0 0 1-2.4 0l-6.3-6.1c-.7-.7-.7-1.7 0-2.4L15.7 2ZM18 12l-4.5-4L9 12h9ZM4 16s2 2.4 2 3.8C6 21 5.1 22 4 22s-2-1-2-2.2C2 18.4 4 16 4 16Z"/></svg>',
    "cell-border-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M5 13v5h2v2H5a2 2 0 0 1-2-2v-5h2zm8-7V4h6a2 2 0 0 1 2 2h-8z" opacity=".2"/><path fill-rule="nonzero" d="M13 4v2H5v7H3V6c0-1.1.9-2 2-2h8zm-2.6 14.1.1-.1.1.1.2.3.2.2.2.2c.4.6.8 1.2.8 1.7 0 .8-.7 1.5-1.5 1.5S9 21.3 9 20.5c0-.5.4-1.1.8-1.7l.2-.2.2-.2.2-.3z"/><path d="m13 11-2 2H5v-2h6V6h2z"/><path fill-rule="nonzero" d="m18.4 8 1 1-1.8 1.9 4 4c.5.4.5 1.1 0 1.6l-4.3 4.2a1.2 1.2 0 0 1-1.6 0l-4.4-4.2c-.4-.5-.4-1.2 0-1.7l7-6.8Zm1.6 7-3-3-3 3h6Z"/></g></svg>',
    "change-case": '<svg width="24" height="24"><path d="M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 0 1-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 0 1-1 .7h-.2a.7.7 0 0 1-.7-1l4-12a1 1 0 0 1 2 0l4 12a.7.7 0 0 1-.8 1h-.2a1 1 0 0 1-1-.7l-.8-2.6zm-.3-1.5-2-6.5-1.9 6.5h3.9z" fill-rule="evenodd"/></svg>',
    "character-count": '<svg width="24" height="24"><path d="M4 11.5h16v1H4v-1Zm4.8-6.8V10H7.7V5.8h-1v-1h2ZM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1Zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1ZM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2V18.7l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 0 1-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 0 0-.5-.1 1 1 0 0 0-.4 0l-.3.4h-1Zm2.3.8h-.2l-.2.1-.4.1a1 1 0 0 0-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6Zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4Zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 0 0 1.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 0 0-.6-.3l-.6.3-.2.8Zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 0 0-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 0 1-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 0 1-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1Z" fill-rule="evenodd"/></svg>',
    "checklist-rtl": '<svg width="24" height="24"><path d="M5 17h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm14.2 11c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 8c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>',
    checklist: '<svg width="24" height="24"><path d="M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2h-8a1 1 0 0 1 0-2ZM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Z" fill-rule="evenodd"/></svg>',
    checkmark: '<svg width="24" height="24"><path d="M18.2 5.4a1 1 0 0 1 1.6 1.2l-8 12a1 1 0 0 1-1.5.1l-5-5a1 1 0 1 1 1.4-1.4l4.1 4.1 7.4-11Z" fill-rule="nonzero"/></svg>',
    "chevron-down": '<svg width="10" height="10"><path d="M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 0 1 0-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8Z" fill-rule="nonzero"/></svg>',
    "chevron-left": '<svg width="10" height="10"><path d="M7.8 1.3 4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 0 1 0-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1Z" fill-rule="nonzero"/></svg>',
    "chevron-right": '<svg width="10" height="10"><path d="M2.2 1.3a.8.8 0 0 1 0-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 0 1 0-1.1L6 5 2.2 1.3Z" fill-rule="nonzero"/></svg>',
    "chevron-up": '<svg width="10" height="10"><path d="M8.7 7.8 5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 0 1 0-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0Z" fill-rule="nonzero"/></svg>',
    close: '<svg width="24" height="24"><path d="M17.3 8.2 13.4 12l3.9 3.8a1 1 0 0 1-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 0 1-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 0 1 1.5-1.5l3.8 3.9 3.8-3.9a1 1 0 0 1 1.5 1.5Z" fill-rule="evenodd"/></svg>',
    "code-sample": '<svg width="24" height="26"><path d="M7.1 11a2.8 2.8 0 0 1-.8 2 2.8 2.8 0 0 1 .8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11Zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 0 1-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 0 1 .8-2 2.8 2.8 0 0 1-.8-2Zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2ZM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 0 1-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 0 1-.5-.5V17a3 3 0 0 0 1-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5Z" fill-rule="evenodd"/></svg>',
    "color-levels": '<svg width="24" height="24"><path d="M17.5 11.4A9 9 0 0 1 18 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 0 1-3.7 3 5.7 5.7 0 0 1-3.2 0A5.9 5.9 0 0 1 7.6 18a6.2 6.2 0 0 1-1.4-2.6 6.7 6.7 0 0 1 0-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 0 1 2.3-4A20 20 0 0 1 12 4a26.4 26.4 0 0 1 3.2 3.4 18.2 18.2 0 0 1 2.3 4Zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 0 0-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 0 1-1.3 3 5.3 5.3 0 0 1-2.3 1.5 4.9 4.9 0 0 1-2 .1 4.3 4.3 0 0 0 2.4.8 4 4 0 0 0 2-.6 4 4 0 0 0 1.5-1.5Z" fill-rule="evenodd"/></svg>',
    "color-picker": '<svg width="24" height="24"><path d="M12 3a9 9 0 0 0 0 18 1.5 1.5 0 0 0 1.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 0 0 5-5c0-4.4-4-8-9-8Zm-5.5 9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3-4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3 4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Z" fill-rule="nonzero"/></svg>',
    "color-swatch-remove-color": '<svg width="24" height="24"><path stroke="#000" stroke-width="2" d="M21 3 3 21" fill-rule="evenodd"/></svg>',
    "color-swatch": '<svg width="24" height="24"><rect x="3" y="3" width="18" height="18" rx="1" fill-rule="evenodd"/></svg>',
    "comment-add": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/><path d="M13 10h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 0v-2H9a1 1 0 0 1 0-2h2V8a1 1 0 0 1 2 0v2Z"/></g></svg>',
    comment: '<svg width="24" height="24"><path fill-rule="nonzero" d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/></svg>',
    contrast: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-6 8a6 6 0 0 0 6 6V6a6 6 0 0 0-6 6Z" fill-rule="evenodd"/></svg>',
    copy: '<svg width="24" height="24"><path d="M16 3H6a2 2 0 0 0-2 2v11h2V5h10V3Zm1 4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7Zm0 12V9h-7v10h7Z" fill-rule="nonzero"/></svg>',
    crop: '<svg width="24" height="24"><path d="M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-2H7V9H5a1 1 0 1 1 0-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3ZM9 9v5l5-5H9Zm1 6h5v-5l-5 5Z" fill-rule="evenodd"/></svg>',
    "cut-column": '<svg width="24" height="24"><path fill-rule="evenodd" d="M7.2 4.5c.9 0 1.6.4 2.2 1A3.7 3.7 0 0 1 10.5 8v.5l1 1 4-4 1-.5a3.3 3.3 0 0 1 2 0c.4 0 .7.3 1 .5L17 8h4v13h-6V10l-1.5 1.5.5.5v4l-2.5-2.5-1 1v.5c0 .4 0 .8-.3 1.2-.2.5-.4.9-.8 1.2-.6.7-1.3 1-2.2 1-.8.2-1.5 0-2-.6l-.5-.8-.2-1c0-.4 0-.8.3-1.2A3.9 3.9 0 0 1 7 12.7c.5-.2 1-.3 1.5-.2l1-1-1-1c-.5 0-1 0-1.5-.2-.5-.1-1-.4-1.4-.9-.4-.3-.6-.7-.8-1.2L4.5 7c0-.4 0-.7.2-1 0-.3.3-.6.5-.8.5-.5 1.2-.8 2-.7Zm12.3 5h-3v10h3v-10ZM8 13.8h-.3l-.4.2a2.8 2.8 0 0 0-.7.4v.1a2.8 2.8 0 0 0-.6.8l-.1.4v.7l.2.5.5.2h.7a2.6 2.6 0 0 0 .8-.3 2.4 2.4 0 0 0 .7-.7 2.5 2.5 0 0 0 .3-.8 1.5 1.5 0 0 0 0-.8 1 1 0 0 0-.2-.4 1 1 0 0 0-.5-.2H8Zm3.5-3.7c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4ZM7 5.8h-.4a1 1 0 0 0-.5.3 1 1 0 0 0-.2.5v.7a2.5 2.5 0 0 0 .3.8l.2.3h.1l.4.4.4.2.4.1h.7L9 9l.2-.4a1.6 1.6 0 0 0 0-.8 2.6 2.6 0 0 0-.3-.8A2.5 2.5 0 0 0 7.7 6l-.4-.1H7Z"/></svg>',
    "cut-row": '<svg width="24" height="24"><path fill-rule="evenodd" d="M22 3v5H9l3 3 2-2h4l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8.7.6 1 1.3 1 2.2.2.8 0 1.5-.6 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l2 2V3h14ZM8.5 15.3h-.3a2.6 2.6 0 0 0-.8.4 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3L9 18V18l.4-.4.2-.4.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2h-.5Zm7 0H15a1 1 0 0 0-.4.3 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4a2.8 2.8 0 0 0 .5.7h.1a2.8 2.8 0 0 0 .8.6l.4.1h.7l.5-.2.2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3h-.3ZM12 11.6c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4Zm8.5-7.1h-11v2h11v-2Z"/></svg>',
    cut: '<svg width="24" height="24"><path d="M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 0 1 0 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8Zm-8.5 2.2.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2 1.6 1.6 0 0 0-.8 0 2.6 2.6 0 0 0-.8.3 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3 2.8 2.8 0 0 0 1-1Zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4Zm5.4 4 .2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3 1.5 1.5 0 0 0-.8 0 1 1 0 0 0-.4.2 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4l.3.4.3.4a2.8 2.8 0 0 0 .8.5l.4.1h.7l.5-.2Z" fill-rule="evenodd"/></svg>',
    "document-properties": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>',
    drag: '<svg width="24" height="24"><path d="M13 5h2v2h-2V5Zm0 4h2v2h-2V9ZM9 9h2v2H9V9Zm4 4h2v2h-2v-2Zm-4 0h2v2H9v-2Zm0 4h2v2H9v-2Zm4 0h2v2h-2v-2ZM9 5h2v2H9V5Z" fill-rule="evenodd"/></svg>',
    "duplicate-column": '<svg width="24" height="24"><path d="M17 6v16h-7V6h7Zm-2 2h-3v12h3V8Zm-2-6v2H8v15H6V2h7Z"/></svg>',
    "duplicate-row": '<svg width="24" height="24"><path d="M22 11v7H6v-7h16Zm-2 2H8v3h12v-3Zm-1-6v2H4v5H2V7h17Z"/></svg>',
    duplicate: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10Zm3 8h-2V9h-7v10h9a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7a2 2 0 0 1 2 2v2Z"/><path d="M17 14h1a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1h-1a1 1 0 0 1 0-2h1v-1a1 1 0 0 1 2 0v1Z"/></g></svg>',
    "edit-block": '<svg width="24" height="24"><path fill-rule="nonzero" d="m19.8 8.8-9.4 9.4c-.2.2-.5.4-.9.4l-5.4 1.2 1.2-5.4.5-.8 9.4-9.4c.7-.7 1.8-.7 2.5 0l2.1 2.1c.7.7.7 1.8 0 2.5Zm-2-.2 1-.9v-.3l-2.2-2.2a.3.3 0 0 0-.3 0l-1 1L18 8.5Zm-1 1-2.5-2.4-6 6 2.5 2.5 6-6Zm-7 7.1-2.6-2.4-.3.3-.1.2-.7 3 3.1-.6h.1l.4-.5Z"/></svg>',
    "edit-image": '<svg width="24" height="24"><path d="M18 16h2V7a2 2 0 0 0-2-2H7v2h11v9ZM6 17h15a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1H6a2 2 0 0 1-2-2V7H3a1 1 0 1 1 0-2h1V4a1 1 0 1 1 2 0v13Zm3-5.3 1.3 2 3-4.7 3.7 6H7l2-3.3Z" fill-rule="nonzero"/></svg>',
    "embed-page": '<svg width="24" height="24"><path d="M19 6V5H5v14h2A13 13 0 0 1 19 6Zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4Zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6Zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3Zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 0 0 8 19h3ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 0 0-4 4.5h2.2Zm-3.4 0a12 12 0 0 1 2.8-4 12 12 0 0 0-5 4h2.2Z" fill-rule="nonzero"/></svg>',
    embed: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm4.8 2.6 5.6 4a.5.5 0 0 1 0 .8l-5.6 4A.5.5 0 0 1 9 16V8a.5.5 0 0 1 .8-.4Z" fill-rule="nonzero"/></svg>',
    emoji: '<svg width="24" height="24"><path d="M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5ZM12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16Zm0 14.5a6.5 6.5 0 1 1 0-13 6.5 6.5 0 0 1 0 13Z" fill-rule="nonzero"/></svg>',
    export: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M14.4 3 18 7v1h-5V5H7v14h9a1 1 0 0 1 2 0c0 1-.8 2-1.9 2H7c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2h7.5Z"/><path d="M18.1 12c.5 0 .9.4.9 1 0 .5-.3 1-.8 1h-7.3c-.5 0-.9-.4-.9-1 0-.5.3-1 .8-1h7.3Z"/><path d="M16.4 9.2a1 1 0 0 1 1.4.2l2.4 3.6-2.4 3.6a1 1 0 0 1-1.7-1v-.2l1.7-2.4-1.6-2.4a1 1 0 0 1 .2-1.4Z"/></g></svg>',
    fill: '<svg width="24" height="26"><path d="m16.6 12-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 0 0 2.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2ZM5.2 13 10 8.2l4.8 4.8H5.2ZM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.3-2-3.5-2-3.5Z" fill-rule="nonzero"/></svg>',
    "flip-horizontally": '<svg width="24" height="24"><path d="M14 19h2v-2h-2v2Zm4-8h2V9h-2v2ZM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 0 0-2 2Zm14-2v2h2a2 2 0 0 0-2-2Zm-7 16h2V3h-2v18Zm7-6h2v-2h-2v2Zm-4-8h2V5h-2v2Zm4 12a2 2 0 0 0 2-2h-2v2Z" fill-rule="nonzero"/></svg>',
    "flip-vertically": '<svg width="24" height="24"><path d="M5 14v2h2v-2H5Zm8 4v2h2v-2h-2Zm4-14H7a2 2 0 0 0-2 2v3h2V6h10v3h2V6a2 2 0 0 0-2-2Zm2 14h-2v2a2 2 0 0 0 2-2ZM3 11v2h18v-2H3Zm6 7v2h2v-2H9Zm8-4v2h2v-2h-2ZM5 18c0 1.1.9 2 2 2v-2H5Z" fill-rule="nonzero"/></svg>',
    footnote: '<svg width="24" height="24"><path d="M19 13c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h14Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M19 4v6h-1V5h-1.5V4h2.6Z"/><path d="M12 18c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h7ZM14 8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2h9Z"/></svg>',
    "format-painter": '<svg width="24" height="24"><path d="M18 5V4c0-.5-.4-1-1-1H5a1 1 0 0 0-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3Z" fill-rule="nonzero"/></svg>',
    format: '<svg width="24" height="24"><path fill-rule="evenodd" d="M17 5a1 1 0 0 1 0 2h-4v11a1 1 0 0 1-2 0V7H7a1 1 0 1 1 0-2h10Z"/></svg>',
    fullscreen: '<svg width="24" height="24"><path d="m15.3 10-1.2-1.3 2.9-3h-2.3a.9.9 0 1 1 0-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 1 1-1.8 0V7l-2.9 3Zm0 4 3 3v-2.3a.9.9 0 1 1 1.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 1 1 0-1.8H17l-3-2.9 1.3-1.2ZM10 15.4l-2.9 3h2.3a.9.9 0 1 1 0 1.7H5a.9.9 0 0 1-.9-.9v-4.4a.9.9 0 1 1 1.8 0V17l2.9-3 1.2 1.3ZM8.7 10 5.7 7v2.3a.9.9 0 0 1-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 0 1 0 1.8H7l3 2.9-1.3 1.2Z" fill-rule="nonzero"/></svg>',
    gallery: '<svg width="24" height="24"><path fill-rule="nonzero" d="m5 15.7 2.3-2.2c.3-.3.7-.3 1 0L11 16l5.1-5c.3-.4.8-.4 1 0l2 1.9V8H5v7.7ZM5 18V19h3l1.8-1.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 6h16c.6 0 1 .4 1 1v13c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V7c0-.6.4-1 1-1Zm6 7a2 2 0 1 1 0-4 2 2 0 0 1 0 4ZM4.5 4h15a.5.5 0 1 1 0 1h-15a.5.5 0 0 1 0-1Zm2-2h11a.5.5 0 1 1 0 1h-11a.5.5 0 0 1 0-1Z"/></svg>',
    gamma: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm6.5 11.8V14L9.2 8.7a5.1 5.1 0 0 0-.4-.8l-.1-.2H8v-1l.3-.1.3-.1h.7a1 1 0 0 1 .6.5l.1.3a8.5 8.5 0 0 1 .3.6l1.9 4.6 2-5.2a1 1 0 0 1 1-.6.5.5 0 0 1 .5.6L13 14v2.8a.7.7 0 0 1-1.4 0Z" fill-rule="nonzero"/></svg>',
    help: '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M12 5.5a6.5 6.5 0 0 0-6 9 6.3 6.3 0 0 0 1.4 2l1 1a6.3 6.3 0 0 0 3.6 1 6.5 6.5 0 0 0 6-9 6.3 6.3 0 0 0-1.4-2l-1-1a6.3 6.3 0 0 0-3.6-1ZM12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Z"/><path d="M9.6 9.7a.7.7 0 0 1-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 0 0-.8.8.8.8 0 0 1-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8Z" fill-rule="nonzero"/><circle cx="12" cy="16" r="1"/></g></svg>',
    "highlight-bg-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path class="tox-icon-highlight-bg-color__color" d="M3 18h18v3H3z"/><path fill-rule="nonzero" d="M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 0 1 2.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6"/></g></svg>',
    home: '<svg width="24" height="24"><path fill-rule="nonzero" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>',
    "horizontal-rule": '<svg width="24" height="24"><path d="M4 11h16v2H4z" fill-rule="evenodd"/></svg>',
    "image-options": '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>',
    image: '<svg width="24" height="24"><path d="m5 15.7 3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7ZM5 18V19h3l2.8-2.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm6 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z" fill-rule="nonzero"/></svg>',
    indent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>',
    info: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-1 3v2h2V7h-2Zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4Z" fill-rule="evenodd"/></svg>',
    "insert-character": '<svg width="24" height="24"><path d="M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 0 0 1.8-2.9 6.3 6.3 0 0 0-.1-4.1 5.8 5.8 0 0 0-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 0 0-3.9 1.8 6.3 6.3 0 0 0-1.3 6 6.2 6.2 0 0 0 1.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 0 1 4 11c0-1 .2-1.9.6-2.7A7 7 0 0 1 6.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 0 1 5.7 2 7 7 0 0 1 1.7 2.3 6 6 0 0 1 .2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 0 1-3.6 2.5v.5Z" fill-rule="evenodd"/></svg>',
    "insert-time": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M12 19a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm0 2a9 9 0 1 1 0-18 9 9 0 0 1 0 18Z"/><path d="M16 12h-3V7c0-.6-.4-1-1-1a1 1 0 0 0-1 1v7h5c.6 0 1-.4 1-1s-.4-1-1-1Z"/></g></svg>',
    invert: '<svg width="24" height="24"><path d="M18 19.3 16.5 18a5.8 5.8 0 0 1-3.1 1.9 6.1 6.1 0 0 1-5.5-1.6A5.8 5.8 0 0 1 6 14v-.3l.1-1.2A13.9 13.9 0 0 1 7.7 9l-3-3 .7-.8 2.8 2.9 9 8.9 1.5 1.6-.7.6Zm0-5.5v.3l-.1 1.1-.4 1-1.2-1.2a4.3 4.3 0 0 0 .2-1v-.2c0-.4 0-.8-.2-1.3l-.5-1.4a14.8 14.8 0 0 0-3-4.2L12 6a26.1 26.1 0 0 0-2.2 2.5l-1-1a20.9 20.9 0 0 1 2.9-3.3L12 4l1 .8a22.2 22.2 0 0 1 4 5.4c.6 1.2 1 2.4 1 3.6Z" fill-rule="evenodd"/></svg>',
    italic: '<svg width="24" height="24"><path d="m16.7 4.7-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8Z" fill-rule="evenodd"/></svg>',
    language: '<svg width="24" height="24"><path d="M12 3a9 9 0 1 1 0 18 9 9 0 0 1 0-18Zm4.3 13.3c-.5 1-1.2 2-2 2.9a7.5 7.5 0 0 0 3.2-2.1l-.2-.2a6 6 0 0 0-1-.6Zm-8.6 0c-.5.2-.9.5-1.2.8.9 1 2 1.7 3.2 2a10 10 0 0 1-2-2.8Zm3.6-.8c-.8 0-1.6.1-2.2.3.5 1 1.2 1.9 2.1 2.7Zm1.5 0v3c.9-.8 1.6-1.7 2.1-2.7-.6-.2-1.4-.3-2.1-.3Zm-6-2.7H4.5c.2 1 .5 2.1 1 3h.3l1.3-1a10 10 0 0 1-.3-2Zm12.7 0h-2.3c0 .7-.1 1.4-.3 2l1.6 1.1c.5-1 .9-2 1-3.1Zm-3.8 0h-3V14c1 0 2 .1 2.7.4.2-.5.3-1 .3-1.6Zm-4.4 0h-3l.3 1.6c.8-.3 1.7-.4 2.7-.4v-1.3Zm-5.5-5c-.7 1-1.1 2.2-1.3 3.5h2.3c0-1 .2-1.8.5-2.6l-1.5-1Zm2.9 1.4v.1c-.2.6-.4 1.3-.4 2h3V9.4c-1 0-1.8-.1-2.6-.3Zm6.6 0h-.1l-2.4.3v1.8h3l-.5-2.1Zm3-1.4-.3.1-1.3.8c.3.8.5 1.6.5 2.6h2.3a7.5 7.5 0 0 0-1.3-3.5Zm-9 0 2 .2V5.5a9 9 0 0 0-2 2.2Zm3.5-2.3V8c.6 0 1.3 0 1.9-.2a9 9 0 0 0-2-2.3Zm-3-.7h-.1c-1.1.4-2.1 1-3 1.8l1.2.7a10 10 0 0 1 1.9-2.5Zm4.4 0 .1.1a10 10 0 0 1 1.8 2.4l1.1-.7a7.5 7.5 0 0 0-3-1.8Z"/></svg>',
    "line-height": '<svg width="24" height="24"><path d="M21 5a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zM7 3.6l3.7 3.7a1 1 0 0 1-1.3 1.5h-.1L8 7.3v9.2l1.3-1.3a1 1 0 0 1 1.3 0h.1c.4.4.4 1 0 1.3v.1L7 20.4l-3.7-3.7a1 1 0 0 1 1.3-1.5h.1L6 16.7V7.4L4.7 8.7a1 1 0 0 1-1.3 0h-.1a1 1 0 0 1 0-1.3v-.1L7 3.6z"/></svg>',
    line: '<svg width="24" height="24"><path d="m15 9-8 8H4v-3l8-8 3 3Zm1-1-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1ZM4 18h16v2H4v-2Z" fill-rule="evenodd"/></svg>',
    link: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2-2a2 2 0 1 0-2.6-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2Z" fill-rule="nonzero"/></svg>',
    "list-bull-circle": '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M11 16a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 26a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 36a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6Z" fill-rule="nonzero"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
    "list-bull-default": '<svg width="48" height="48"><g fill-rule="evenodd"><circle cx="11" cy="14" r="3"/><circle cx="11" cy="24" r="3"/><circle cx="11" cy="34" r="3"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
    "list-bull-square": '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M8 11h6v6H8zM8 21h6v6H8zM8 31h6v6H8z"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
    "list-num-default-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 17v-4.8h-.1l-1.5 1v-1.1l1.6-1.1h1.2v6zM33.3 17.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm1.7 5.7c0-1.2 1-2 2.2-2 1.3 0 2.1.8 2.1 1.8 0 .7-.3 1.2-1.3 2.2l-1.2 1v.2h2.6v1h-4.3v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H35zm-1.7 4.3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm3.2 7.3v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H35c0-1.1 1-1.8 2.2-1.8 1.2 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.7.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .6 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm-3.3 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>',
    "list-num-default": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2Zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5Zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7Zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Z"/></g></svg>',
    "list-num-lower-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M36.5 16c-.9 0-1.5-.5-1.5-1.3s.6-1.3 1.8-1.4h1v-.4c0-.4-.2-.6-.7-.6-.4 0-.7.1-.8.4h-1.1c0-.8.8-1.4 2-1.4S39 12 39 13V16h-1.2v-.6c-.3.4-.8.7-1.4.7Zm.4-.8c.6 0 1-.4 1-.9V14h-1c-.5.1-.7.3-.7.6 0 .4.3.6.7.6ZM33.1 16.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7ZM37.7 26c-.7 0-1.2-.2-1.5-.7v.7H35v-6.3h1.2v2.5c.3-.5.8-.9 1.5-.9 1.1 0 1.8 1 1.8 2.4 0 1.5-.7 2.4-1.8 2.4Zm-.5-3.6c-.6 0-1 .5-1 1.3s.4 1.4 1 1.4c.7 0 1-.6 1-1.4 0-.8-.3-1.3-1-1.3ZM33.2 26.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm6 7h-1c-.1-.5-.4-.8-1-.8s-1 .5-1 1.4c0 1 .4 1.4 1 1.4.5 0 .9-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm-6.1 3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
    "list-num-lower-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6Zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7Zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4Zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3Zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7Zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-lower-greek-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 16c-1.2 0-2-.8-2-2.3 0-1.5.8-2.4 2-2.4.6 0 1 .4 1.3 1v-.9H40v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1-.7h-.2c-.2.4-.7.8-1.3.8Zm.3-1c.6 0 1-.5 1-1.3s-.4-1.3-1-1.3-1 .5-1 1.3.4 1.4 1 1.4ZM33.3 16.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM36 21.9c0-1.5.8-2.3 2.1-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.9 1.3.9.3 1.3.8 1.3 1.7 0 1.2-.7 1.9-1.8 1.9-.6 0-1.1-.3-1.4-.8v2.2H36V22Zm1.8 1.2v-1h.3c.5 0 .9-.2.9-.7 0-.5-.3-.8-.9-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1 1.3s1-.4 1-1-.4-1-1.2-1h-.3ZM33.3 26.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM37.1 34.6 34.8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.2.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1ZM33.3 36.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-lower-greek": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4Zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8Zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3ZM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22Zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1Zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-lower-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M32.9 16v-1.2h-1.3V16H33Zm0 10v-1.2h-1.3V26H33Zm0 10v-1.2h-1.3V36H33Z"/><path fill-rule="nonzero" d="M36 21h-1.5v5H36zM36 31h-1.5v5H36zM39 21h-1.5v5H39zM39 31h-1.5v5H39zM42 31h-1.5v5H42zM36 11h-1.5v5H36zM36 19h-1.5v1H36zM36 29h-1.5v1H36zM39 19h-1.5v1H39zM39 29h-1.5v1H39zM42 29h-1.5v1H42zM36 9h-1.5v1H36z"/></g></svg>',
    "list-num-lower-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 16v-1.2h1.3V16H15Zm0 10v-1.2h1.3V26H15Zm0 10v-1.2h1.3V36H15Z"/><path fill-rule="nonzero" d="M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z"/></g></svg>',
    "list-num-upper-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="m39.3 17-.5-1.4h-2l-.5 1.4H35l2-6h1.6l2 6h-1.3Zm-1.6-4.7-.7 2.3h1.6l-.8-2.3ZM33.4 17c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm4.7 9.9h-2.7v-6H38c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7Zm-1.4-5v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4h1.1c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9h-1.1V26ZM33 27.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm4.9 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm-4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-upper-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="m12.6 17-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3ZM11 12.3l-.7 2.3h1.6l-.8-2.3Zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7ZM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7ZM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26Zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-upper-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M31.6 17v-1.2H33V17h-1.3Zm0 10v-1.2H33V27h-1.3Zm0 10v-1.2H33V37h-1.3Z"/><path fill-rule="nonzero" d="M34.5 20H36v7h-1.5zM34.5 30H36v7h-1.5zM37.5 20H39v7h-1.5zM37.5 30H39v7h-1.5zM40.5 30H42v7h-1.5zM34.5 10H36v7h-1.5z"/></g></svg>',
    "list-num-upper-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 17v-1.2h1.3V17H15Zm0 10v-1.2h1.3V27H15Zm0 10v-1.2h1.3V37H15Z"/><path fill-rule="nonzero" d="M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z"/></g></svg>',
    lock: '<svg width="24" height="24"><path d="M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3ZM10 8v3h4V8a1 1 0 0 0-.3-.7A1 1 0 0 0 13 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7Z" fill-rule="evenodd"/></svg>',
    ltr: '<svg width="24" height="24"><path d="M11 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 7.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L11 5ZM4.4 16.2 6.2 15l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>',
    "math-equation": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 4.8c.1-.5.5-.8 1-.8h10a1 1 0 1 1 0 2h-9.2L8.3 19.2a1 1 0 0 1-1.7.4l-3.4-4.2a1 1 0 0 1 1.6-1.2l2 2.5L9 4.8Zm9.7 5.5c.4.4.4 1 0 1.4L17 13.5l1.8 1.8a1 1 0 1 1-1.4 1.4L15.5 15l-1.8 1.8a1 1 0 0 1-1.4-1.4l1.8-1.8-1.8-1.8a1 1 0 0 1 1.4-1.4l1.8 1.8 1.8-1.8a1 1 0 0 1 1.4 0Z"/></svg>',
    minus: '<svg width="24" height="24"><path d="M19 11a1 1 0 0 1 .1 2H5a1 1 0 0 1-.1-2H19Z"/></svg>',
    "more-drawer": '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>',
    "new-document": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>',
    "new-tab": '<svg width="24" height="24"><path d="m15 13 2-2v8H5V7h8l-2 2H7v8h8v-4Zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19Z" fill-rule="evenodd"/></svg>',
    "non-breaking": '<svg width="24" height="24"><path d="M11 11H8a1 1 0 1 1 0-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-3Zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1Z" fill-rule="evenodd"/></svg>',
    notice: '<svg width="24" height="24"><path d="M15.5 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7ZM13 17v-2h-2v2h2Zm0-4V7h-2v6h2Z" fill-rule="evenodd" clip-rule="evenodd"/></svg>',
    "ordered-list-rtl": '<svg width="24" height="24"><path d="M6 17h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 1 1 0-2Zm13-1v3.5a.5.5 0 1 1-1 0V5h-.5a.5.5 0 1 1 0-1H19Zm-1 8.8.2.2h1.3a.5.5 0 1 1 0 1h-1.6a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2h-1.3a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3Zm2 4.2v2c0 .6-.4 1-1 1h-1.5a.5.5 0 0 1 0-1h1.2a.3.3 0 1 0 0-.6h-1.3a.4.4 0 1 1 0-.8h1.3a.3.3 0 0 0 0-.6h-1.2a.5.5 0 1 1 0-1H19c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>',
    "ordered-list": '<svg width="24" height="24"><path d="M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 1 1 0-2ZM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 0 1-.5-.5V5h-.5a.5.5 0 0 1 0-1H6Zm-1 8.8.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2H4.5a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3ZM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 0 1 0-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 1 1 0-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 1 1 0-1H6c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>',
    orientation: '<svg width="24" height="24"><path d="M7.3 6.4 1 13l6.4 6.5 6.5-6.5-6.5-6.5ZM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7ZM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 0 1 0-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 1 1-4.3 16.9l1.5-1.5A7 7 0 1 0 13 6h-1Z" fill-rule="nonzero"/></svg>',
    outdent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm1.6-3.8a1 1 0 0 1-1.2 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 0 1 1.2 1.6L6.8 12l1.8 1.2Z" fill-rule="evenodd"/></svg>',
    "page-break": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2ZM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1ZM6 22a1 1 0 0 1-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5H7v5c0 .6-.4 1-1 1Z"/></g></svg>',
    paragraph: '<svg width="24" height="24"><path fill-rule="evenodd" d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z"/></svg>',
    "paste-column-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h7v2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm8 7v12h-6V8h6Zm-1.5 1.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-column-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V18c0 1-.8 2-1.9 2H11v-2h7V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v2H4V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm-2 7v12H4V8h6ZM8.5 9.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-row-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V11h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h14c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 11v5H8v-5h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-row-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h12v-4h2v4c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 7v5H8V8h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-text": '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2Z" fill-rule="nonzero"/></svg>',
    paste: '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Z" fill-rule="nonzero"/></svg>',
    "permanent-pen": '<svg width="24" height="24"><path d="M10.5 17.5 8 20H3v-3l3.5-3.5a2 2 0 0 1 0-3L14 3l1 1-7.3 7.3a1 1 0 0 0 0 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 0 1-2.8 0l-.1-.1Z" fill-rule="nonzero"/></svg>',
    plus: '<svg width="24" height="24"><path d="M12 4c.5 0 1 .4 1 .9V11h6a1 1 0 0 1 .1 2H13v6a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H11V5c0-.6.4-1 1-1Z"/></svg>',
    preferences: '<svg width="24" height="24"><path d="m20.1 13.5-1.9.2a5.8 5.8 0 0 1-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 0 1-1.4 0l-1.5-1.2a6.2 6.2 0 0 1-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 0 1-1-.9l-.2-1.9a5.8 5.8 0 0 1-1.5-.6l-1.5 1.2a1 1 0 0 1-1.4 0l-.7-.7a1 1 0 0 1 0-1.4l1.2-1.5a6.2 6.2 0 0 1-.6-1.5l-1.9-.2a1 1 0 0 1-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 0 1 .6-1.5L5.2 7.3a1 1 0 0 1 0-1.4l.7-.7a1 1 0 0 1 1.4 0l1.5 1.2a6.2 6.2 0 0 1 1.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 0 1 1.5.6l1.5-1.2a1 1 0 0 1 1.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 0 1 .6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1ZM12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" fill-rule="evenodd"/></svg>',
    preview: '<svg width="24" height="24"><path d="M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 0 0 2.1-2.8 15.7 15.7 0 0 0-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 0 0-6.7 3.2A16.2 16.2 0 0 0 3.2 12c0 .2.2.3.3.5Zm-2.4-1 .7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 0 1 2.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 0 1-2.8-3.7 1 1 0 0 1 0-1Zm12-3.3a2 2 0 1 0 2.7 2.6 4 4 0 1 1-2.6-2.6Z" fill-rule="nonzero"/></svg>',
    print: '<svg width="24" height="24"><path d="M18 8H6a3 3 0 0 0-3 3v6h2v3h14v-3h2v-6a3 3 0 0 0-3-3Zm-1 10H7v-4h10v4Zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5Zm.5-8H6v2h12V5Z" fill-rule="nonzero"/></svg>',
    quote: '<svg width="24" height="24"><path d="M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Z" fill-rule="nonzero"/></svg>',
    redo: '<svg width="24" height="24"><path d="M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 1 1-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 1 1 1.4-1.4l5 5a1 1 0 0 1 0 1.4l-5 5a1 1 0 0 1-1.4-1.4l3.3-3.3Z" fill-rule="nonzero"/></svg>',
    reload: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m5 22.1-1.2-4.7v-.2a1 1 0 0 1 1-1l5 .4a1 1 0 1 1-.2 2l-2.2-.2a7.8 7.8 0 0 0 8.4.2 7.5 7.5 0 0 0 3.5-6.4 1 1 0 1 1 2 0 9.5 9.5 0 0 1-4.5 8 9.9 9.9 0 0 1-10.2 0l.4 1.4a1 1 0 1 1-2 .5ZM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 0 0-9.5-1 7.5 7.5 0 0 0-3.6 7 1 1 0 0 1-2 0 9.5 9.5 0 0 1 4.5-8.6 10 10 0 0 1 10.9.3l-.3-1a1 1 0 0 1 2-.5l1.1 4.8a1 1 0 0 1-1 1.2l-5-.4a1 1 0 0 1-.9-1Z"/></g></svg>',
    "remove-formatting": '<svg width="24" height="24"><path d="M13.2 6a1 1 0 0 1 0 .2l-2.6 10a1 1 0 0 1-1 .8h-.2a.8.8 0 0 1-.8-1l2.6-10H8a1 1 0 1 1 0-2h9a1 1 0 0 1 0 2h-3.8ZM5 18h7a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Zm13 1.5L16.5 18 15 19.5a.7.7 0 0 1-1-1l1.5-1.5-1.5-1.5a.7.7 0 0 1 1-1l1.5 1.5 1.5-1.5a.7.7 0 0 1 1 1L17.5 17l1.5 1.5a.7.7 0 0 1-1 1Z" fill-rule="evenodd"/></svg>',
    remove: '<svg width="24" height="24"><path d="M16 7h3a1 1 0 0 1 0 2h-1v9a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V9H5a1 1 0 1 1 0-2h3V6a3 3 0 0 1 3-3h2a3 3 0 0 1 3 3v1Zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 0 0-1 1v1h4Zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9Zm-7 3a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Zm4 0a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Z" fill-rule="nonzero"/></svg>',
    "resize-handle": '<svg width="10" height="10"><g fill-rule="nonzero"><path d="M8.1 1.1A.5.5 0 1 1 9 2l-7 7A.5.5 0 1 1 1 8l7-7ZM8.1 5.1A.5.5 0 1 1 9 6l-3 3A.5.5 0 1 1 5 8l3-3Z"/></g></svg>',
    resize: '<svg width="24" height="24"><path d="M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-6a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3A1 1 0 0 1 4 11V5Z" fill-rule="evenodd"/></svg>',
    "restore-draft": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1Z"/><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></g></svg>',
    "revision-history": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1Z"/><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></g></svg>',
    "rotate-left": '<svg width="24" height="24"><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></svg>',
    "rotate-right": '<svg width="24" height="24"><path d="M20 8V5a1 1 0 0 1 2 0v6c0 .6-.4 1-1 1h-6a1 1 0 0 1 0-2h4.3L16 7A7.2 7.2 0 0 0 7.7 6a7 7 0 0 0 3 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 0 1 1.4 1.5A9.2 9.2 0 0 1 2.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8Z" fill-rule="nonzero"/></svg>',
    rtl: '<svg width="24" height="24"><path d="M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 4.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L8 5Zm12 11.2a1 1 0 1 1-1 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 1 1 1 1.6L18.4 15l1.8 1.2Z" fill-rule="evenodd"/></svg>',
    save: '<svg width="24" height="24"><path d="M5 16h14a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2c0-1.1.9-2 2-2Zm0 2v2h14v-2H5Zm10 0h2v2h-2v-2Zm-4-6.4L8.7 9.3a1 1 0 1 0-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 1 0-1.4-1.4L13 11.6V4a1 1 0 0 0-2 0v7.6Z" fill-rule="nonzero"/></svg>',
    search: '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z" fill-rule="nonzero"/></svg>',
    "select-all": '<svg width="24" height="24"><path d="M3 5h2V3a2 2 0 0 0-2 2Zm0 8h2v-2H3v2Zm4 8h2v-2H7v2ZM3 9h2V7H3v2Zm10-6h-2v2h2V3Zm6 0v2h2a2 2 0 0 0-2-2ZM5 21v-2H3c0 1.1.9 2 2 2Zm-2-4h2v-2H3v2ZM9 3H7v2h2V3Zm2 18h2v-2h-2v2Zm8-8h2v-2h-2v2Zm0 8a2 2 0 0 0 2-2h-2v2Zm0-12h2V7h-2v2Zm0 8h2v-2h-2v2Zm-4 4h2v-2h-2v2Zm0-16h2V3h-2v2ZM7 17h10V7H7v10Zm2-8h6v6H9V9Z" fill-rule="nonzero"/></svg>',
    selected: '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm3.6 10.9L7 12.3a.7.7 0 0 0-1 1L9.6 17 18 8.6a.7.7 0 0 0 0-1 .7.7 0 0 0-1 0l-7.4 7.3Z"/></svg>',
    send: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="m13.3 22 7-18.3-18.3 7L9 15l4.3 7ZM18 6.8l-.7-.7L9.4 14l.7.7L18 6.8Z"/></svg>',
    settings: '<svg width="24" height="24"><path d="M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V8H5a1 1 0 1 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6ZM8 8h2V6H8v2Zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V13H5a1 1 0 0 1 0-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6ZM14 13h2v-2h-2v2Zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V18H5a1 1 0 0 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6ZM8 18h2v-2H8v2Z" fill-rule="evenodd"/></svg>',
    sharpen: '<svg width="24" height="24"><path d="m16 6 4 4-8 9-8-9 4-4h8Zm-4 10.2 5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2Z" fill-rule="evenodd"/></svg>',
    sourcecode: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 0 1 0-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7ZM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 0 0-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7Z"/></g></svg>',
    "spell-check": '<svg width="24" height="24"><path d="M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6Zm0-3v2h2V5H6Zm13 0h-3v5h3v1h-3a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1Zm-5 1.5-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5ZM13 10V8h-2v2h2Zm0-3V5h-2v2h2Zm3 5 1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12Z" fill-rule="evenodd"/></svg>',
    "strike-through": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 0 1 7 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1Z"/><path d="M5 11h14a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Z" fill-rule="nonzero"/></g></svg>',
    subscript: '<svg width="24" height="24"><path d="m10.4 10 4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10ZM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 0 0-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 0 1-1.3 1.3l-.6.6h2.6V19Z" fill-rule="nonzero"/></svg>',
    superscript: '<svg width="24" height="24"><path d="M15 9.4 10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4Zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11Z" fill-rule="nonzero"/></svg>',
    "table-caption": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="12" height="2" x="3" y="4" rx="1"/><path d="M19 8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-8c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></g></svg>',
    "table-cell-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M13 4v9H3V6c0-1.1.9-2 2-2h8Zm-2 2H5v5h6V6Z"/><path fill-rule="nonzero" d="M13 4h6a2 2 0 0 1 2 2v7h-8v-2h6V6h-6V4Z" opacity=".2"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/><path fill-rule="nonzero" d="M3 13v5c0 1.1.9 2 2 2h8v-7h-2v5H5v-5H3Z" opacity=".2"/></g></svg>',
    "table-cell-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8 0h-6v5h6v-5Zm-8-7H5v5h6V6Z"/></svg>',
    "table-cell-select-all": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z" opacity=".2"/></g></svg>',
    "table-cell-select-inner": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z" opacity=".2"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z"/></g></svg>',
    "table-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v7h-8v7H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8-7h-6v5h6V6Zm-8 0H5v5h6V6Z"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/></g></svg>',
    "table-delete-column": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-4 4h-2V6h-2v2H9V6H5v12h4v-2h2v2h2v-2h2v2h4V6h-4v2Zm.3.5 1 1.2-3 2.3 3 2.3-1 1.2L12 13l-3.3 2.6-1-1.2 3-2.3-3-2.3 1-1.2L12 11l3.3-2.5Z"/></svg>',
    "table-delete-row": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v3h2.5v2H5v2h2.5v2H5v3h14v-3h-2.5v-2H19v-2h-2.5V9H19V6Zm-4.7 1.8 1.2 1L13 12l2.6 3.3-1.2 1-2.3-3-2.3 3-1.2-1L11 12 8.5 8.7l1.2-1 2.3 3 2.3-3Z"/></svg>',
    "table-delete-table": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 6v12h14V6H5Z"/><path d="m14.4 8.6 1.1 1-2.4 2.4 2.4 2.4-1.1 1.1-2.4-2.4-2.4 2.4-1-1.1 2.3-2.4-2.3-2.4 1-1 2.4 2.3z"/></g></svg>',
    "table-insert-column-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M20 4c.6 0 1 .4 1 1v2a1 1 0 0 1-2 0V6h-8v12h8v-1a1 1 0 0 1 2 0v2c0 .5-.4 1-.9 1H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h15ZM9 13H5v5h4v-5Zm7-5c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H17v2a1 1 0 0 1-2 .1V13h-2a1 1 0 0 1-.1-2H15V9c0-.6.4-1 1-1ZM9 6H5v5h4V6Z"/></svg>',
    "table-insert-column-before": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a1 1 0 0 1-1-1v-2a1 1 0 0 1 2 0v1h8V6H5v1a1 1 0 1 1-2 0V5c0-.6.4-1 1-1h15Zm0 9h-4v5h4v-5ZM8 8c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H9v2a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H7V9c0-.6.4-1 1-1Zm11-2h-4v5h4V6Z"/></svg>',
    "table-insert-row-above": '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4a1 1 0 1 1 0 2H5v6h14V6h-1a1 1 0 0 1 0-2h2c.6 0 1 .4 1 1v13a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5c0-.6.4-1 1-1h2Zm5 10H5v4h6v-4Zm8 0h-6v4h6v-4ZM12 3c.5 0 1 .4 1 .9V6h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 .1V8H9a1 1 0 0 1 0-2h2V4c0-.6.4-1 1-1Z"/></svg>',
    "table-insert-row-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M12 13c.5 0 1 .4 1 .9V16h2a1 1 0 0 1 .1 2H13v2a1 1 0 0 1-2 .1V18H9a1 1 0 0 1-.1-2H11v-2c0-.6.4-1 1-1Zm6 7a1 1 0 0 1 0-2h1v-6H5v6h1a1 1 0 0 1 0 2H4a1 1 0 0 1-1-1V6c0-1.1.9-2 2-2h14a2 2 0 0 1 2 2v13c0 .5-.4 1-.9 1H18ZM11 6H5v4h6V6Zm8 0h-6v4h6V6Z"/></svg>',
    "table-left-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 9h-4v5h4v-5Zm-6 0H9v5h4v-5Zm0-7H9v5h4V6Zm6 0h-4v5h4V6Z"/></svg>',
    "table-merge-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15.5V18h3v-2.5H5Zm14-5h-9V18h9v-7.5ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Zm-8 7.5h3v-3H5v3Z"/></svg>',
    "table-row-numbering-rtl": '<svg width="24" height="24"><path d="M6 4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H6Zm0 12h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 11h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 6h8v3H6V6Zm11 0c.6 0 1 .4 1 1v1a1 1 0 1 1-2 0V7c0-.6.4-1 1-1Z"/></svg>',
    "table-row-numbering": '<svg width="24" height="24"><path d="M18 4a2 2 0 0 1 2 2v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h12Zm0 12h-8v3h8v-3ZM7 16a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8v-3ZM7 11a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8V6ZM7 6a1 1 0 0 0-1 1v1a1 1 0 1 0 2 0V7c0-.6-.4-1-1-1Z"/></svg>',
    "table-row-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-9h-6v3h6V6ZM5 9h6V6H5v3Z"/></svg>',
    "table-split-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM8 15.5H5V18h3v-2.5Zm11-5h-9V18h9v-7.5Zm-2.5 1 1 1-2 2 2 2-1 1-2-2-2 2-1-1 2-2-2-2 1-1 2 2 2-2Zm-8.5-1H5v3h3v-3ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Z"/></svg>',
    "table-top-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 11H5v3h6v-3Zm8 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></svg>',
    table: '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 14v4h6v-4H5Zm14 0h-6v4h6v-4Zm0-6h-6v4h6V8ZM5 12h6V8H5v4Z"/></svg>',
    "template-add": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 12v4H5a2 2 0 0 0-2 2v3h9.3a6 6 0 0 1-.3-2H5v-1h7a6 6 0 0 1 .8-2H11v-5l-.8-.6a3 3 0 1 1 3.6 0l-.8.6v4.7a6 6 0 0 1 2-1.9V12a5 5 0 1 0-6 0Z"/><path d="M18 15c.5 0 1 .4 1 .9V18h2a1 1 0 0 1 .1 2H19v2a1 1 0 0 1-2 .1V20h-2a1 1 0 0 1-.1-2H17v-2c0-.6.4-1 1-1Z"/></svg>',
    template: '<svg width="24" height="24"><path d="M19 19v-1H5v1h14ZM9 16v-4a5 5 0 1 1 6 0v4h4a2 2 0 0 1 2 2v3H3v-3c0-1.1.9-2 2-2h4Zm4 0v-5l.8-.6a3 3 0 1 0-3.6 0l.8.6v5h2Z" fill-rule="nonzero"/></svg>',
    "temporary-placeholder": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M9 7.6V6h2.5V4.5a.5.5 0 1 1 1 0V6H15v1.6a8 8 0 1 1-6 0Zm-2.6 5.3a.5.5 0 0 0 .3.6c.3 0 .6 0 .6-.3l.1-.2a5 5 0 0 1 3.3-2.8c.3-.1.4-.4.4-.6-.1-.3-.4-.5-.6-.4a6 6 0 0 0-4.1 3.7Z"/><circle cx="14" cy="4" r="1"/><circle cx="12" cy="2" r="1"/><circle cx="10" cy="4" r="1"/></g></svg>',
    "text-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path class="tox-icon-text-color__color" d="M3 18h18v3H3z"/><path d="M8.7 16h-.8a.5.5 0 0 1-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 0 1-.5.6h-.8a.5.5 0 0 1-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4Zm2.6-7.6-.6 2a.5.5 0 0 0 .5.6h1.6a.5.5 0 0 0 .5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4Z"/></g></svg>',
    "text-size-decrease": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM14 12a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-6Z"/></svg>',
    "text-size-increase": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM17 9a1 1 0 0 0-1 1v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2h-2v-2c0-.6-.4-1-1-1Z"/></svg>',
    toc: '<svg width="24" height="24"><path d="M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    translate: '<svg width="24" height="24"><path d="m12.7 14.3-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 0 1 0-1l3.1-3A12.4 12.4 0 0 1 6.7 9H8a10.1 10.1 0 0 0 1.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 1 1 0-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 0 1-1 2.4 13.5 13.5 0 0 1-1.7 2.3l1.9 1.8Zm4.3-3 2.7 7.3a.5.5 0 0 1-.4.7 1 1 0 0 1-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 0 1-1 .7.5.5 0 0 1-.4-.7l2.7-7.4a1 1 0 0 1 2 0Zm-2.2 4.4h2.4L16 12.5l-1.2 3.2Z" fill-rule="evenodd"/></svg>',
    typography: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M17 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H7a1 1 0 0 1 0-2h10Z"/><path d="m17.5 14 .8-1.7 1.7-.8-1.7-.8-.8-1.7-.8 1.7-1.7.8 1.7.8.8 1.7ZM7 14l1 2 2 1-2 1-1 2-1-2-2-1 2-1 1-2Z"/></svg>',
    underline: '<svg width="24" height="24"><path d="M16 5c.6 0 1 .4 1 1v5.5a4 4 0 0 1-.4 1.8l-1 1.4a5.3 5.3 0 0 1-5.5 1 5 5 0 0 1-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 0 1-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 0 0 2.2.8 3.4 3.4 0 0 0 2.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1ZM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    undo: '<svg width="24" height="24"><path d="M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 0 1-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 1 1-1.4 1.4l-5-5a1 1 0 0 1 0-1.4l5-5a1 1 0 0 1 1.4 1.4L6.4 8Z" fill-rule="nonzero"/></svg>',
    unlink: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2.1-2a2 2 0 1 0-2.7-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2ZM7.6 6.3a.8.8 0 0 1-1 1.1L3.3 4.2a.7.7 0 1 1 1-1l3.2 3.1ZM5.1 8.6a.8.8 0 0 1 0 1.5H3a.8.8 0 0 1 0-1.5H5Zm5-3.5a.8.8 0 0 1-1.5 0V3a.8.8 0 0 1 1.5 0V5Zm6 11.8a.8.8 0 0 1 1-1l3.2 3.2a.8.8 0 0 1-1 1L16 17Zm-2.2 2a.8.8 0 0 1 1.5 0V21a.8.8 0 0 1-1.5 0V19Zm5-3.5a.7.7 0 1 1 0-1.5H21a.8.8 0 0 1 0 1.5H19Z" fill-rule="nonzero"/></svg>',
    unlock: '<svg width="24" height="24"><path d="M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 0 0-.3-.7A1 1 0 0 0 16 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2Z" fill-rule="evenodd"/></svg>',
    "unordered-list": '<svg width="24" height="24"><path d="M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2ZM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Z" fill-rule="evenodd"/></svg>',
    unselected: '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm0 1a1 1 0 0 0-1 1v12c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H6Z"/></svg>',
    upload: '<svg width="24" height="24"><path d="M18 19v-2a1 1 0 0 1 2 0v3c0 .6-.4 1-1 1H5a1 1 0 0 1-1-1v-3a1 1 0 0 1 2 0v2h12ZM11 6.4 8.7 8.7a1 1 0 0 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 1 1-1.4 1.4L13 6.4V16a1 1 0 0 1-2 0V6.4Z" fill-rule="nonzero"/></svg>',
    user: '<svg width="24" height="24"><path d="M12 24a12 12 0 1 1 0-24 12 12 0 0 1 0 24Zm-8.7-5.3a11 11 0 0 0 17.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7ZM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13Z" fill-rule="nonzero"/></svg>',
    "vertical-align": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="18" height="2" x="3" y="11" rx="1"/><path d="M12 2c.6 0 1 .4 1 1v4l2-1.3a1 1 0 0 1 1.2 1.5l-.1.1-4.1 3-4-3a1 1 0 0 1 1-1.7l2 1.5V3c0-.6.4-1 1-1zm0 11.8 4 2.9a1 1 0 0 1-1 1.7l-2-1.5V21c0 .5-.4 1-.9 1H12a1 1 0 0 1-1-1v-4l-2 1.3a1 1 0 0 1-1.2-.1l-.1-.1a1 1 0 0 1 .1-1.3l.1-.1 4.1-3z"/></g></svg>',
    visualblocks: '<svg width="24" height="24"><path d="M9 19v2H7v-2h2Zm-4 0v2a2 2 0 0 1-2-2h2Zm8 0v2h-2v-2h2Zm8 0a2 2 0 0 1-2 2v-2h2Zm-4 0v2h-2v-2h2ZM15 7a1 1 0 0 1 0 2v7a1 1 0 0 1-2 0V9h-1v7a1 1 0 0 1-2 0v-4a2.5 2.5 0 0 1-.2-5H15ZM5 15v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 11v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 7v2H3V7h2Zm16 0v2h-2V7h2ZM5 3v2H3c0-1.1.9-2 2-2Zm8 0v2h-2V3h2Zm6 0a2 2 0 0 1 2 2h-2V3ZM9 3v2H7V3h2Zm8 0v2h-2V3h2Z" fill-rule="evenodd"/></svg>',
    visualchars: '<svg width="24" height="24"><path d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z" fill-rule="evenodd"/></svg>',
    warning: '<svg width="24" height="24"><path d="M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6ZM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3Zm.7-3 .3-4a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7l.3 4h1.4Z" fill-rule="evenodd"/></svg>',
    "zoom-in": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-1-9a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0V8Zm-2 4a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>',
    "zoom-out": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-3-5a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>',
    "export-pdf": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 3h7.4L19 7.6V17h-2V9h-4V5H7v3H5V5c0-1.1.9-2 2-2Z"/><path d="M2.6 15.2v-1.9h1c.6 0 1-.2 1.4-.5.3-.3.5-.7.5-1.2s-.2-.9-.5-1.2a2 2 0 0 0-1.3-.4H1v5.2h1.6Zm.4-3h-.4v-1.1h.5l.6.1.2.5c0 .1 0 .3-.2.4l-.7.1Zm5.7 3 1-.1c.3 0 .5-.2.7-.4l.5-.8c.2-.3.2-.7.2-1.3v-1l-.5-.8c-.2-.3-.4-.5-.7-.6L8.7 10H6.3v5.2h2.4Zm-.4-1.1H8v-3h.4c.5 0 .8.2 1 .4l.2 1.1-.1 1-.3.3-.8.2Zm5.3 1.2V13h2v-1h-2v-1H16V10h-4v5.2h1.6Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M15 17a1 1 0 1 0-2 0v3.1l-1.4-1a1 1 0 1 0-1.2 1.7l3.6 2.4 3.6-2.4a1 1 0 0 0-1.2-1.6l-1.4 1V17Z"/></svg>',
    "export-word": '<svg width="24" height="24"><path d="M9.5 7A1.5 1.5 0 0 1 11 8.4v7.1A1.5 1.5 0 0 1 9.6 17H2.5A1.5 1.5 0 0 1 1 15.6V8.5A1.5 1.5 0 0 1 2.4 7h7.1Zm-1 2.8-1 2.6-1-2.5v-.1a.6.6 0 0 0-1 0l-.1.1-.9 2.5-1-2.5v-.1a.6.6 0 0 0-1 .4v.1l1.5 4v.1a.6.6 0 0 0 1 0v-.1l1-2.5.9 2.5v.1a.6.6 0 0 0 1 0H8l1.6-4v-.2a.6.6 0 0 0-1.1-.4Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M7 3h7.4L19 7.6V17h-2V9h-4V5H5c0-1.1.9-2 2-2ZM15 17a1 1 0 1 0-2 0v3.1l-1.4-1a1 1 0 1 0-1.2 1.7l3.6 2.4 3.6-2.4a1 1 0 0 0-1.2-1.6l-1.4 1V17Z"/></svg>',
    "import-word": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 3h7.4L19 7.6V15h-2V9h-4V5H5c0-1.1.9-2 2-2Z"/><path d="M9.5 7A1.5 1.5 0 0 1 11 8.4v7.1A1.5 1.5 0 0 1 9.6 17H2.5A1.5 1.5 0 0 1 1 15.6V8.5A1.5 1.5 0 0 1 2.4 7h7.1Zm-1 2.8-1 2.6-1-2.5v-.1a.6.6 0 0 0-1 0l-.1.1-.9 2.5-1-2.5v-.1a.6.6 0 0 0-1 .4v.1l1.5 4v.1a.6.6 0 0 0 1 0v-.1l1-2.5.9 2.5v.1a.6.6 0 0 0 1 0H8l1.6-4v-.2a.6.6 0 0 0-1.1-.4Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M11.4 18.2a1 1 0 0 0 1.2 1.6l1.4-1V22a1 1 0 1 0 2 0v-3.1l1.4 1a1 1 0 0 0 1.2-1.7L15 15.8l-3.6 2.4Z"/></svg>'
  }
});
tinymce.Resource.add("ui/default/skin.css", `.tox{box-shadow:none;box-sizing:content-box;color:#222f3e;cursor:auto;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:16px;font-style:normal;font-weight:400;line-height:normal;-webkit-tap-highlight-color:transparent;text-decoration:none;text-shadow:none;text-transform:none;vertical-align:initial;white-space:normal}.tox :not(svg):not(rect){box-sizing:inherit;color:inherit;cursor:inherit;direction:inherit;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;line-height:inherit;-webkit-tap-highlight-color:inherit;text-align:inherit;text-decoration:inherit;text-shadow:inherit;text-transform:inherit;vertical-align:inherit;white-space:inherit}.tox :not(svg):not(rect){background:0 0;border:0;box-shadow:none;float:none;height:auto;margin:0;max-width:none;outline:0;padding:0;position:static;width:auto}.tox:not([dir=rtl]){direction:ltr;text-align:left}.tox[dir=rtl]{direction:rtl;text-align:right}.tox-tinymce{border:2px solid #eee;border-radius:10px;box-shadow:none;box-sizing:border-box;display:flex;flex-direction:column;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;overflow:hidden;position:relative;visibility:inherit!important}.tox.tox-tinymce-inline{border:none;box-shadow:none;overflow:initial}.tox.tox-tinymce-inline .tox-editor-container{overflow:initial}.tox.tox-tinymce-inline .tox-editor-header{background-color:#fff;border:2px solid #eee;border-radius:10px;box-shadow:none;overflow:hidden}.tox-tinymce-aux{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;z-index:1300}.tox-tinymce :focus,.tox-tinymce-aux :focus{outline:0}button::-moz-focus-inner{border:0}.tox[dir=rtl] .tox-icon--flip svg{transform:rotateY(180deg)}.tox .accessibility-issue__header{align-items:center;display:flex;margin-bottom:4px}.tox .accessibility-issue__description{align-items:stretch;border-radius:6px;display:flex;justify-content:space-between}.tox .accessibility-issue__description>div{padding-bottom:4px}.tox .accessibility-issue__description>div>div{align-items:center;display:flex;margin-bottom:4px}.tox .accessibility-issue__description>div>div .tox-icon svg{display:block}.tox .accessibility-issue__repair{margin-top:16px}.tox .tox-dialog__body-content .accessibility-issue--info .accessibility-issue__description{background-color:rgba(0,101,216,.1);color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--info .tox-form__group h2{color:#006ce7}.tox .tox-dialog__body-content .accessibility-issue--info .tox-icon svg{fill:#006ce7}.tox .tox-dialog__body-content .accessibility-issue--info a.tox-button--naked.tox-button--icon{background-color:#006ce7;color:#fff}.tox .tox-dialog__body-content .accessibility-issue--info a.tox-button--naked.tox-button--icon:focus,.tox .tox-dialog__body-content .accessibility-issue--info a.tox-button--naked.tox-button--icon:hover{background-color:#0060ce}.tox .tox-dialog__body-content .accessibility-issue--info a.tox-button--naked.tox-button--icon:active{background-color:#0054b4}.tox .tox-dialog__body-content .accessibility-issue--warn .accessibility-issue__description{background-color:rgba(255,165,0,.08);color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--warn .tox-form__group h2{color:#8f5d00}.tox .tox-dialog__body-content .accessibility-issue--warn .tox-icon svg{fill:#8f5d00}.tox .tox-dialog__body-content .accessibility-issue--warn a.tox-button--naked.tox-button--icon{background-color:#ffe89d;color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--warn a.tox-button--naked.tox-button--icon:focus,.tox .tox-dialog__body-content .accessibility-issue--warn a.tox-button--naked.tox-button--icon:hover{background-color:#f2d574;color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--warn a.tox-button--naked.tox-button--icon:active{background-color:#e8c657;color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--error .accessibility-issue__description{background-color:rgba(204,0,0,.1);color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--error .tox-form__group h2{color:#c00}.tox .tox-dialog__body-content .accessibility-issue--error .tox-icon svg{fill:#c00}.tox .tox-dialog__body-content .accessibility-issue--error a.tox-button--naked.tox-button--icon{background-color:#f2bfbf;color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--error a.tox-button--naked.tox-button--icon:focus,.tox .tox-dialog__body-content .accessibility-issue--error a.tox-button--naked.tox-button--icon:hover{background-color:#e9a4a4;color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--error a.tox-button--naked.tox-button--icon:active{background-color:#ee9494;color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--success .accessibility-issue__description{background-color:rgba(120,171,70,.1);color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--success .accessibility-issue__description>:last-child{display:none}.tox .tox-dialog__body-content .accessibility-issue--success .tox-form__group h2{color:#527530}.tox .tox-dialog__body-content .accessibility-issue--success .tox-icon svg{fill:#527530}.tox .tox-dialog__body-content .accessibility-issue__header .tox-form__group h1,.tox .tox-dialog__body-content .tox-form__group .accessibility-issue__description h2{font-size:14px;margin-top:0}.tox:not([dir=rtl]) .tox-dialog__body-content .accessibility-issue__header .tox-button{margin-left:4px}.tox:not([dir=rtl]) .tox-dialog__body-content .accessibility-issue__header>:nth-last-child(2){margin-left:auto}.tox:not([dir=rtl]) .tox-dialog__body-content .accessibility-issue__description{padding:4px 4px 4px 8px}.tox[dir=rtl] .tox-dialog__body-content .accessibility-issue__header .tox-button{margin-right:4px}.tox[dir=rtl] .tox-dialog__body-content .accessibility-issue__header>:nth-last-child(2){margin-right:auto}.tox[dir=rtl] .tox-dialog__body-content .accessibility-issue__description{padding:4px 8px 4px 4px}.tox .mce-codemirror{background:#fff;bottom:0;font-size:13px;left:0;position:absolute;right:0;top:0;z-index:1}.tox .mce-codemirror.tox-inline-codemirror{margin:8px;position:absolute}.tox .tox-advtemplate .tox-form__grid{flex:1}.tox .tox-advtemplate .tox-form__grid>div:first-child{display:flex;flex-direction:column;width:30%}.tox .tox-advtemplate .tox-form__grid>div:first-child>div:nth-child(2){flex-basis:0;flex-grow:1;overflow:auto}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox .tox-advtemplate .tox-form__grid>div:first-child{width:100%}}.tox .tox-advtemplate iframe{border-color:#eee;border-radius:10px;border-style:solid;border-width:1px;margin:0 10px}.tox .tox-anchorbar{display:flex;flex:0 0 auto}.tox .tox-bottom-anchorbar{display:flex;flex:0 0 auto}.tox .tox-bar{display:flex;flex:0 0 auto}.tox .tox-button{background-color:#006ce7;background-image:none;background-position:0 0;background-repeat:repeat;border-color:#006ce7;border-radius:6px;border-style:solid;border-width:1px;box-shadow:none;box-sizing:border-box;color:#fff;cursor:pointer;display:inline-block;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:14px;font-style:normal;font-weight:700;letter-spacing:normal;line-height:24px;margin:0;outline:0;padding:4px 16px;position:relative;text-align:center;text-decoration:none;text-transform:none;white-space:nowrap}.tox .tox-button::before{border-radius:6px;bottom:-1px;box-shadow:inset 0 0 0 1px #fff,0 0 0 2px #006ce7;content:'';left:-1px;opacity:0;pointer-events:none;position:absolute;right:-1px;top:-1px}.tox .tox-button[disabled]{background-color:#006ce7;background-image:none;border-color:#006ce7;box-shadow:none;color:rgba(255,255,255,.5);cursor:not-allowed}.tox .tox-button:focus:not(:disabled){background-color:#0060ce;background-image:none;border-color:#0060ce;box-shadow:none;color:#fff}.tox .tox-button:focus:not(:disabled)::before{opacity:1}.tox .tox-button:hover:not(:disabled){background-color:#0060ce;background-image:none;border-color:#0060ce;box-shadow:none;color:#fff}.tox .tox-button:active:not(:disabled){background-color:#0054b4;background-image:none;border-color:#0054b4;box-shadow:none;color:#fff}.tox .tox-button.tox-button--enabled{background-color:#0054b4;background-image:none;border-color:#0054b4;box-shadow:none;color:#fff}.tox .tox-button.tox-button--enabled[disabled]{background-color:#0054b4;background-image:none;border-color:#0054b4;box-shadow:none;color:rgba(255,255,255,.5);cursor:not-allowed}.tox .tox-button.tox-button--enabled:focus:not(:disabled){background-color:#00489b;background-image:none;border-color:#00489b;box-shadow:none;color:#fff}.tox .tox-button.tox-button--enabled:hover:not(:disabled){background-color:#00489b;background-image:none;border-color:#00489b;box-shadow:none;color:#fff}.tox .tox-button.tox-button--enabled:active:not(:disabled){background-color:#003c81;background-image:none;border-color:#003c81;box-shadow:none;color:#fff}.tox .tox-button--icon-and-text,.tox .tox-button.tox-button--icon-and-text,.tox .tox-button.tox-button--secondary.tox-button--icon-and-text{display:flex;padding:5px 4px}.tox .tox-button--icon-and-text .tox-icon svg,.tox .tox-button.tox-button--icon-and-text .tox-icon svg,.tox .tox-button.tox-button--secondary.tox-button--icon-and-text .tox-icon svg{display:block;fill:currentColor}.tox .tox-button--secondary{background-color:#f0f0f0;background-image:none;background-position:0 0;background-repeat:repeat;border-color:#f0f0f0;border-radius:6px;border-style:solid;border-width:1px;box-shadow:none;color:#222f3e;font-size:14px;font-style:normal;font-weight:700;letter-spacing:normal;outline:0;padding:4px 16px;text-decoration:none;text-transform:none}.tox .tox-button--secondary[disabled]{background-color:#f0f0f0;background-image:none;border-color:#f0f0f0;box-shadow:none;color:rgba(34,47,62,.5)}.tox .tox-button--secondary:focus:not(:disabled){background-color:#e3e3e3;background-image:none;border-color:#e3e3e3;box-shadow:none;color:#222f3e}.tox .tox-button--secondary:hover:not(:disabled){background-color:#e3e3e3;background-image:none;border-color:#e3e3e3;box-shadow:none;color:#222f3e}.tox .tox-button--secondary:active:not(:disabled){background-color:#d6d6d6;background-image:none;border-color:#d6d6d6;box-shadow:none;color:#222f3e}.tox .tox-button--secondary.tox-button--enabled{background-color:#a8c8ed;background-image:none;border-color:#a8c8ed;box-shadow:none;color:#222f3e}.tox .tox-button--secondary.tox-button--enabled[disabled]{background-color:#a8c8ed;background-image:none;border-color:#a8c8ed;box-shadow:none;color:rgba(34,47,62,.5)}.tox .tox-button--secondary.tox-button--enabled:focus:not(:disabled){background-color:#93bbe9;background-image:none;border-color:#93bbe9;box-shadow:none;color:#222f3e}.tox .tox-button--secondary.tox-button--enabled:hover:not(:disabled){background-color:#93bbe9;background-image:none;border-color:#93bbe9;box-shadow:none;color:#222f3e}.tox .tox-button--secondary.tox-button--enabled:active:not(:disabled){background-color:#7daee4;background-image:none;border-color:#7daee4;box-shadow:none;color:#222f3e}.tox .tox-button--icon,.tox .tox-button.tox-button--icon,.tox .tox-button.tox-button--secondary.tox-button--icon{padding:4px}.tox .tox-button--icon .tox-icon svg,.tox .tox-button.tox-button--icon .tox-icon svg,.tox .tox-button.tox-button--secondary.tox-button--icon .tox-icon svg{display:block;fill:currentColor}.tox .tox-button-link{background:0;border:none;box-sizing:border-box;cursor:pointer;display:inline-block;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:16px;font-weight:400;line-height:1.3;margin:0;padding:0;white-space:nowrap}.tox .tox-button-link--sm{font-size:14px}.tox .tox-button--naked{background-color:transparent;border-color:transparent;box-shadow:unset;color:#222f3e}.tox .tox-button--naked[disabled]{background-color:rgba(34,47,62,.12);border-color:transparent;box-shadow:unset;color:rgba(34,47,62,.5)}.tox .tox-button--naked:hover:not(:disabled){background-color:rgba(34,47,62,.12);border-color:transparent;box-shadow:unset;color:#222f3e}.tox .tox-button--naked:focus:not(:disabled){background-color:rgba(34,47,62,.12);border-color:transparent;box-shadow:unset;color:#222f3e}.tox .tox-button--naked:active:not(:disabled){background-color:rgba(34,47,62,.18);border-color:transparent;box-shadow:unset;color:#222f3e}.tox .tox-button--naked .tox-icon svg{fill:currentColor}.tox .tox-button--naked.tox-button--icon:hover:not(:disabled){color:#222f3e}.tox .tox-checkbox{align-items:center;border-radius:6px;cursor:pointer;display:flex;height:36px;min-width:36px}.tox .tox-checkbox__input{height:1px;overflow:hidden;position:absolute;top:auto;width:1px}.tox .tox-checkbox__icons{align-items:center;border-radius:6px;box-shadow:0 0 0 2px transparent;box-sizing:content-box;display:flex;height:24px;justify-content:center;padding:calc(4px - 1px);width:24px}.tox .tox-checkbox__icons .tox-checkbox-icon__unchecked svg{display:block;fill:rgba(34,47,62,.3)}@media (forced-colors:active){.tox .tox-checkbox__icons .tox-checkbox-icon__unchecked svg{fill:currentColor!important}}.tox .tox-checkbox__icons .tox-checkbox-icon__indeterminate svg{display:none;fill:#006ce7}.tox .tox-checkbox__icons .tox-checkbox-icon__checked svg{display:none;fill:#006ce7}.tox .tox-checkbox--disabled{color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-checkbox--disabled .tox-checkbox__icons .tox-checkbox-icon__checked svg{fill:rgba(34,47,62,.5)}.tox .tox-checkbox--disabled .tox-checkbox__icons .tox-checkbox-icon__unchecked svg{fill:rgba(34,47,62,.5)}.tox .tox-checkbox--disabled .tox-checkbox__icons .tox-checkbox-icon__indeterminate svg{fill:rgba(34,47,62,.5)}.tox input.tox-checkbox__input:checked+.tox-checkbox__icons .tox-checkbox-icon__unchecked svg{display:none}.tox input.tox-checkbox__input:checked+.tox-checkbox__icons .tox-checkbox-icon__checked svg{display:block}.tox input.tox-checkbox__input:indeterminate+.tox-checkbox__icons .tox-checkbox-icon__unchecked svg{display:none}.tox input.tox-checkbox__input:indeterminate+.tox-checkbox__icons .tox-checkbox-icon__indeterminate svg{display:block}.tox input.tox-checkbox__input:focus+.tox-checkbox__icons{border-radius:6px;box-shadow:inset 0 0 0 1px #006ce7;padding:calc(4px - 1px)}.tox:not([dir=rtl]) .tox-checkbox__label{margin-left:4px}.tox:not([dir=rtl]) .tox-checkbox__input{left:-10000px}.tox:not([dir=rtl]) .tox-bar .tox-checkbox{margin-left:4px}.tox[dir=rtl] .tox-checkbox__label{margin-right:4px}.tox[dir=rtl] .tox-checkbox__input{right:-10000px}.tox[dir=rtl] .tox-bar .tox-checkbox{margin-right:4px}.tox .tox-collection--toolbar .tox-collection__group{display:flex;padding:0}.tox .tox-collection--grid .tox-collection__group{display:flex;flex-wrap:wrap;max-height:208px;overflow-x:hidden;overflow-y:auto;padding:0}.tox .tox-collection--list .tox-collection__group{border-bottom-width:0;border-color:#e3e3e3;border-left-width:0;border-right-width:0;border-style:solid;border-top-width:1px;padding:4px 0}.tox .tox-collection--list .tox-collection__group:first-child{border-top-width:0}.tox .tox-collection__group-heading{background-color:#fcfcfc;color:rgba(34,47,62,.7);cursor:default;font-size:12px;font-style:normal;font-weight:400;margin-bottom:4px;margin-top:-4px;padding:4px 8px;text-transform:none;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.tox .tox-collection__item{align-items:center;border-radius:3px;color:#222f3e;display:flex;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.tox .tox-collection--list .tox-collection__item{padding:4px 8px}.tox .tox-collection--toolbar .tox-collection__item{border-radius:3px;padding:4px}.tox .tox-collection--grid .tox-collection__item{border-radius:3px;padding:4px}.tox .tox-collection--list .tox-collection__item--enabled{background-color:#fff;color:#222f3e}.tox .tox-collection--list .tox-collection__item--active{background-color:#006ce7}.tox .tox-collection--toolbar .tox-collection__item--enabled,.tox .tox-collection--toolbar .tox-collection__item--enabled.tox-collection__item--active,.tox .tox-collection--toolbar .tox-collection__item--enabled.tox-collection__item--active:hover{background-color:#a6ccf7;color:#222f3e}@media (forced-colors:active){.tox .tox-collection--toolbar .tox-collection__item--enabled,.tox .tox-collection--toolbar .tox-collection__item--enabled.tox-collection__item--active,.tox .tox-collection--toolbar .tox-collection__item--enabled.tox-collection__item--active:hover{border-radius:3px;outline:solid 1px}}.tox .tox-collection--toolbar .tox-collection__item--active{background-color:#fff;position:relative}.tox .tox-collection--toolbar .tox-collection__item--active:hover{background-color:#f0f0f0;color:#222f3e}.tox .tox-collection--toolbar .tox-collection__item--active:focus{background-color:#f0f0f0;color:#222f3e}.tox .tox-collection--toolbar .tox-collection__item--active:focus::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-collection--toolbar .tox-collection__item--active:focus::after{border:2px solid highlight}}.tox .tox-collection--grid .tox-collection__item--enabled{background-color:#a6ccf7;color:#222f3e}.tox .tox-collection--grid .tox-collection__item--active:not(.tox-collection__item--state-disabled){background-color:#f0f0f0;color:#222f3e;position:relative;z-index:1}.tox .tox-collection--grid .tox-collection__item--active:not(.tox-collection__item--state-disabled):focus::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7 inset;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-collection--grid .tox-collection__item--active:not(.tox-collection__item--state-disabled):focus::after{border:2px solid highlight}}.tox .tox-collection--list .tox-collection__item--active:not(.tox-collection__item--state-disabled){color:#fff}@media (forced-colors:active){.tox .tox-collection--list .tox-collection__item--active:not(.tox-collection__item--state-disabled){border:solid 1px}}.tox .tox-collection--toolbar .tox-collection__item--active:not(.tox-collection__item--state-disabled){color:#222f3e}@media (forced-colors:active){.tox .tox-collection--toolbar .tox-collection__item--active:not(.tox-collection__item--state-disabled):hover{border-radius:3px;outline:solid 1px}}.tox .tox-collection__item-checkmark,.tox .tox-collection__item-icon{align-items:center;display:flex;height:24px;justify-content:center;width:24px}.tox .tox-collection__item-checkmark svg,.tox .tox-collection__item-icon svg{fill:currentColor}.tox .tox-collection--toolbar-lg .tox-collection__item-icon{height:48px;width:48px}.tox .tox-collection__item-label{color:currentColor;display:inline-block;flex:1;font-size:14px;font-style:normal;font-weight:400;line-height:24px;max-width:100%;text-transform:none;word-break:break-all}.tox .tox-collection__item-accessory{color:currentColor;display:inline-block;font-size:14px;height:24px;line-height:24px;text-transform:none}.tox .tox-collection__item-caret{align-items:center;display:flex;min-height:24px}.tox .tox-collection__item-caret::after{content:'';font-size:0;min-height:inherit}.tox .tox-collection__item-caret svg{fill:currentColor}.tox .tox-collection__item--state-disabled{background-color:transparent;color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-collection__item--state-disabled .tox-collection__item-caret svg{fill:rgba(34,47,62,.5)}.tox .tox-collection--list .tox-collection__item:not(.tox-collection__item--enabled) .tox-collection__item-checkmark svg{display:none}.tox .tox-collection--list .tox-collection__item:not(.tox-collection__item--enabled) .tox-collection__item-accessory+.tox-collection__item-checkmark{display:none}.tox .tox-collection--horizontal{background-color:#fff;border:1px solid #e3e3e3;border-radius:6px;box-shadow:0 0 2px 0 rgba(34,47,62,.2),0 4px 8px 0 rgba(34,47,62,.15);display:flex;flex:0 0 auto;flex-shrink:0;flex-wrap:nowrap;margin-bottom:0;overflow-x:auto;padding:0}.tox .tox-collection--horizontal .tox-collection__group{align-items:center;display:flex;flex-wrap:nowrap;margin:0;padding:0 4px}.tox .tox-collection--horizontal .tox-collection__item{height:28px;margin:6px 1px 5px 0;padding:0 4px}.tox .tox-collection--horizontal .tox-collection__item-label{white-space:nowrap}.tox .tox-collection--horizontal .tox-collection__item-caret{margin-left:4px}.tox .tox-collection__item-container{display:flex}.tox .tox-collection__item-container--row{align-items:center;flex:1 1 auto;flex-direction:row}.tox .tox-collection__item-container--row.tox-collection__item-container--align-left{margin-right:auto}.tox .tox-collection__item-container--row.tox-collection__item-container--align-right{justify-content:flex-end;margin-left:auto}.tox .tox-collection__item-container--row.tox-collection__item-container--valign-top{align-items:flex-start;margin-bottom:auto}.tox .tox-collection__item-container--row.tox-collection__item-container--valign-middle{align-items:center}.tox .tox-collection__item-container--row.tox-collection__item-container--valign-bottom{align-items:flex-end;margin-top:auto}.tox .tox-collection__item-container--column{align-self:center;flex:1 1 auto;flex-direction:column}.tox .tox-collection__item-container--column.tox-collection__item-container--align-left{align-items:flex-start}.tox .tox-collection__item-container--column.tox-collection__item-container--align-right{align-items:flex-end}.tox .tox-collection__item-container--column.tox-collection__item-container--valign-top{align-self:flex-start}.tox .tox-collection__item-container--column.tox-collection__item-container--valign-middle{align-self:center}.tox .tox-collection__item-container--column.tox-collection__item-container--valign-bottom{align-self:flex-end}.tox:not([dir=rtl]) .tox-collection--horizontal .tox-collection__group:not(:last-of-type){border-right:1px solid transparent}.tox:not([dir=rtl]) .tox-collection--list .tox-collection__item>:not(:first-child){margin-left:8px}.tox:not([dir=rtl]) .tox-collection--list .tox-collection__item>.tox-collection__item-label:first-child{margin-left:4px}.tox:not([dir=rtl]) .tox-collection__item-accessory{margin-left:16px;text-align:right}.tox:not([dir=rtl]) .tox-collection .tox-collection__item-caret{margin-left:16px}.tox[dir=rtl] .tox-collection--horizontal .tox-collection__group:not(:last-of-type){border-left:1px solid transparent}.tox[dir=rtl] .tox-collection--list .tox-collection__item>:not(:first-child){margin-right:8px}.tox[dir=rtl] .tox-collection--list .tox-collection__item>.tox-collection__item-label:first-child{margin-right:4px}.tox[dir=rtl] .tox-collection__item-accessory{margin-right:16px;text-align:left}.tox[dir=rtl] .tox-collection .tox-collection__item-caret{margin-right:16px;transform:rotateY(180deg)}.tox[dir=rtl] .tox-collection--horizontal .tox-collection__item-caret{margin-right:4px}@media (forced-colors:active){.tox .tox-hue-slider,.tox .tox-rgb-form .tox-rgba-preview{background-color:currentColor!important;border:1px solid highlight!important;forced-color-adjust:none}}.tox .tox-color-picker-container{display:flex;flex-direction:row;height:225px;margin:0}.tox .tox-sv-palette{box-sizing:border-box;display:flex;height:100%}.tox .tox-sv-palette-spectrum{height:100%}.tox .tox-sv-palette,.tox .tox-sv-palette-spectrum{width:225px}.tox .tox-sv-palette-thumb{background:0 0;border:1px solid #000;border-radius:50%;box-sizing:content-box;height:12px;position:absolute;width:12px}.tox .tox-sv-palette-inner-thumb{border:1px solid #fff;border-radius:50%;height:10px;position:absolute;width:10px}.tox .tox-hue-slider{box-sizing:border-box;height:100%;width:25px}.tox .tox-hue-slider-spectrum{background:linear-gradient(to bottom,red,#ff0080,#f0f,#8000ff,#00f,#0080ff,#0ff,#00ff80,#0f0,#80ff00,#ff0,#ff8000,red);height:100%;width:100%}.tox .tox-hue-slider,.tox .tox-hue-slider-spectrum{width:20px}.tox .tox-hue-slider-spectrum:focus,.tox .tox-sv-palette-spectrum:focus{outline:#08f solid}.tox .tox-hue-slider-thumb{background:#fff;border:1px solid #000;box-sizing:content-box;height:4px;width:100%}.tox .tox-rgb-form{display:flex;flex-direction:column;justify-content:space-between}.tox .tox-rgb-form div{align-items:center;display:flex;justify-content:space-between;margin-bottom:5px;width:inherit}.tox .tox-rgb-form input{width:6em}.tox .tox-rgb-form input.tox-invalid{border:1px solid red!important}.tox .tox-rgb-form .tox-rgba-preview{border:1px solid #000;flex-grow:2;margin-bottom:0}.tox:not([dir=rtl]) .tox-sv-palette{margin-right:15px}.tox:not([dir=rtl]) .tox-hue-slider{margin-right:15px}.tox:not([dir=rtl]) .tox-hue-slider-thumb{margin-left:-1px}.tox:not([dir=rtl]) .tox-rgb-form label{margin-right:.5em}.tox[dir=rtl] .tox-sv-palette{margin-left:15px}.tox[dir=rtl] .tox-hue-slider{margin-left:15px}.tox[dir=rtl] .tox-hue-slider-thumb{margin-right:-1px}.tox[dir=rtl] .tox-rgb-form label{margin-left:.5em}.tox .tox-toolbar .tox-swatches,.tox .tox-toolbar__overflow .tox-swatches,.tox .tox-toolbar__primary .tox-swatches{margin:5px 0 6px 11px}.tox .tox-collection--list .tox-collection__group .tox-swatches-menu{border:0;margin:-4px -4px}.tox .tox-swatches__row{display:flex}@media (forced-colors:active){.tox .tox-swatches__row{forced-color-adjust:none}}.tox .tox-swatch{height:30px;transition:transform .15s,box-shadow .15s;width:30px}.tox .tox-swatch:focus,.tox .tox-swatch:hover{box-shadow:0 0 0 1px rgba(127,127,127,.3) inset;transform:scale(.8)}.tox .tox-swatch--remove{align-items:center;display:flex;justify-content:center}.tox .tox-swatch--remove svg path{stroke:#e74c3c}.tox .tox-swatches__picker-btn{align-items:center;background-color:transparent;border:0;cursor:pointer;display:flex;height:30px;justify-content:center;outline:0;padding:0;width:30px}.tox .tox-swatches__picker-btn svg{fill:#222f3e;height:24px;width:24px}.tox .tox-swatches__picker-btn:hover{background:#f0f0f0}.tox div.tox-swatch:not(.tox-swatch--remove) svg{display:none;fill:#222f3e;height:24px;margin:calc((30px - 24px)/ 2) calc((30px - 24px)/ 2);width:24px}.tox div.tox-swatch:not(.tox-swatch--remove) svg path{fill:#fff;paint-order:stroke;stroke:#222f3e;stroke-width:2px}.tox div.tox-swatch:not(.tox-swatch--remove).tox-collection__item--enabled svg{display:block}.tox:not([dir=rtl]) .tox-swatches__picker-btn{margin-left:auto}.tox[dir=rtl] .tox-swatches__picker-btn{margin-right:auto}.tox .tox-comment-thread{background:#fff;position:relative}.tox .tox-comment-thread>:not(:first-child){margin-top:8px}.tox .tox-comment{background:#fff;border:1px solid #eee;border-radius:6px;box-shadow:0 4px 8px 0 rgba(34,47,62,.1);padding:8px 8px 16px 8px;position:relative}.tox .tox-comment__header{align-items:center;color:#222f3e;display:flex;justify-content:space-between}.tox .tox-comment__date{color:#222f3e;font-size:12px;line-height:18px}.tox .tox-comment__body{color:#222f3e;font-size:14px;font-style:normal;font-weight:400;line-height:1.3;margin-top:8px;position:relative;text-transform:initial}.tox .tox-comment__body textarea{resize:none;white-space:normal;width:100%}.tox .tox-comment__expander{padding-top:8px}.tox .tox-comment__expander p{color:rgba(34,47,62,.7);font-size:14px;font-style:normal}.tox .tox-comment__body p{margin:0}.tox .tox-comment__buttonspacing{padding-top:16px;text-align:center}.tox .tox-comment-thread__overlay::after{background:#fff;bottom:0;content:"";display:flex;left:0;opacity:.9;position:absolute;right:0;top:0;z-index:5}.tox .tox-comment__reply{display:flex;flex-shrink:0;flex-wrap:wrap;justify-content:flex-end;margin-top:8px}.tox .tox-comment__reply>:first-child{margin-bottom:8px;width:100%}.tox .tox-comment__edit{display:flex;flex-wrap:wrap;justify-content:flex-end;margin-top:16px}.tox .tox-comment__gradient::after{background:linear-gradient(rgba(255,255,255,0),#fff);bottom:0;content:"";display:block;height:5em;margin-top:-40px;position:absolute;width:100%}.tox .tox-comment__overlay{background:#fff;bottom:0;display:flex;flex-direction:column;flex-grow:1;left:0;opacity:.9;position:absolute;right:0;text-align:center;top:0;z-index:5}.tox .tox-comment__loading-text{align-items:center;color:#222f3e;display:flex;flex-direction:column;position:relative}.tox .tox-comment__loading-text>div{padding-bottom:16px}.tox .tox-comment__overlaytext{bottom:0;flex-direction:column;font-size:14px;left:0;padding:1em;position:absolute;right:0;top:0;z-index:10}.tox .tox-comment__overlaytext p{background-color:#fff;box-shadow:0 0 8px 8px #fff;color:#222f3e;text-align:center}.tox .tox-comment__overlaytext div:nth-of-type(2){font-size:.8em}.tox .tox-comment__busy-spinner{align-items:center;background-color:#fff;bottom:0;display:flex;justify-content:center;left:0;position:absolute;right:0;top:0;z-index:20}.tox .tox-comment__scroll{display:flex;flex-direction:column;flex-shrink:1;overflow:auto}.tox .tox-conversations{margin:8px}.tox:not([dir=rtl]) .tox-comment__edit{margin-left:8px}.tox:not([dir=rtl]) .tox-comment__buttonspacing>:last-child,.tox:not([dir=rtl]) .tox-comment__edit>:last-child,.tox:not([dir=rtl]) .tox-comment__reply>:last-child{margin-left:8px}.tox[dir=rtl] .tox-comment__edit{margin-right:8px}.tox[dir=rtl] .tox-comment__buttonspacing>:last-child,.tox[dir=rtl] .tox-comment__edit>:last-child,.tox[dir=rtl] .tox-comment__reply>:last-child{margin-right:8px}.tox .tox-user{align-items:center;display:flex}.tox .tox-user__avatar svg{fill:rgba(34,47,62,.7)}.tox .tox-user__avatar img{border-radius:50%;height:36px;object-fit:cover;vertical-align:middle;width:36px}.tox .tox-user__name{color:#222f3e;font-size:14px;font-style:normal;font-weight:700;line-height:18px;text-transform:none}.tox:not([dir=rtl]) .tox-user__avatar img,.tox:not([dir=rtl]) .tox-user__avatar svg{margin-right:8px}.tox:not([dir=rtl]) .tox-user__avatar+.tox-user__name{margin-left:8px}.tox[dir=rtl] .tox-user__avatar img,.tox[dir=rtl] .tox-user__avatar svg{margin-left:8px}.tox[dir=rtl] .tox-user__avatar+.tox-user__name{margin-right:8px}.tox .tox-dialog-wrap{align-items:center;bottom:0;display:flex;justify-content:center;left:0;position:fixed;right:0;top:0;z-index:1100}.tox .tox-dialog-wrap__backdrop{background-color:rgba(255,255,255,.75);bottom:0;left:0;position:absolute;right:0;top:0;z-index:1}.tox .tox-dialog-wrap__backdrop--opaque{background-color:#fff}.tox .tox-dialog{background-color:#fff;border-color:#eee;border-radius:10px;border-style:solid;border-width:0;box-shadow:0 16px 16px -10px rgba(34,47,62,.15),0 0 40px 1px rgba(34,47,62,.15);display:flex;flex-direction:column;max-height:100%;max-width:480px;overflow:hidden;position:relative;width:95vw;z-index:2}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox .tox-dialog{align-self:flex-start;margin:8px auto;max-height:calc(100vh - 8px * 2);width:calc(100vw - 16px)}}.tox .tox-dialog-inline{z-index:1100}.tox .tox-dialog__header{align-items:center;background-color:#fff;border-bottom:none;color:#222f3e;display:flex;font-size:16px;justify-content:space-between;padding:8px 16px 0 16px;position:relative}.tox .tox-dialog__header .tox-button{z-index:1}.tox .tox-dialog__draghandle{cursor:grab;height:100%;left:0;position:absolute;top:0;width:100%}.tox .tox-dialog__draghandle:active{cursor:grabbing}.tox .tox-dialog__dismiss{margin-left:auto}.tox .tox-dialog__title{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:20px;font-style:normal;font-weight:400;line-height:1.3;margin:0;text-transform:none}.tox .tox-dialog__body{color:#222f3e;display:flex;flex:1;font-size:16px;font-style:normal;font-weight:400;line-height:1.3;min-width:0;text-align:left;text-transform:none}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox .tox-dialog__body{flex-direction:column}}.tox .tox-dialog__body-nav{align-items:flex-start;display:flex;flex-direction:column;flex-shrink:0;padding:16px 16px}@media only screen and (min-width:768px){.tox .tox-dialog__body-nav{max-width:11em}}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox .tox-dialog__body-nav{flex-direction:row;-webkit-overflow-scrolling:touch;overflow-x:auto;padding-bottom:0}}.tox .tox-dialog__body-nav-item{border-bottom:2px solid transparent;color:rgba(34,47,62,.7);display:inline-block;flex-shrink:0;font-size:14px;line-height:1.3;margin-bottom:8px;max-width:13em;text-decoration:none}.tox .tox-dialog__body-nav-item:focus{background-color:rgba(0,108,231,.1)}.tox .tox-dialog__body-nav-item--active{border-bottom:2px solid #006ce7;color:#006ce7}@media (forced-colors:active){.tox .tox-dialog__body-nav-item--active{border-bottom:2px solid highlight;color:highlight}}.tox .tox-dialog__body-content{box-sizing:border-box;display:flex;flex:1;flex-direction:column;max-height:min(650px,calc(100vh - 110px));overflow:auto;-webkit-overflow-scrolling:touch;padding:16px 16px}.tox .tox-dialog__body-content>*{margin-bottom:0;margin-top:16px}.tox .tox-dialog__body-content>:first-child{margin-top:0}.tox .tox-dialog__body-content>:last-child{margin-bottom:0}.tox .tox-dialog__body-content>:only-child{margin-bottom:0;margin-top:0}.tox .tox-dialog__body-content a{color:#006ce7;cursor:pointer;text-decoration:underline}.tox .tox-dialog__body-content a:focus,.tox .tox-dialog__body-content a:hover{color:#003c81;text-decoration:underline}.tox .tox-dialog__body-content a:focus-visible{border-radius:1px;outline:2px solid #006ce7;outline-offset:2px}.tox .tox-dialog__body-content a:active{color:#00244e;text-decoration:underline}.tox .tox-dialog__body-content svg{fill:#222f3e}.tox .tox-dialog__body-content strong{font-weight:700}.tox .tox-dialog__body-content ul{list-style-type:disc}.tox .tox-dialog__body-content dd,.tox .tox-dialog__body-content ol,.tox .tox-dialog__body-content ul{padding-inline-start:2.5rem}.tox .tox-dialog__body-content dl,.tox .tox-dialog__body-content ol,.tox .tox-dialog__body-content ul{margin-bottom:16px}.tox .tox-dialog__body-content dd,.tox .tox-dialog__body-content dl,.tox .tox-dialog__body-content dt,.tox .tox-dialog__body-content ol,.tox .tox-dialog__body-content ul{display:block;margin-inline-end:0;margin-inline-start:0}.tox .tox-dialog__body-content .tox-form__group h1{color:#222f3e;font-size:20px;font-style:normal;font-weight:700;letter-spacing:normal;margin-bottom:16px;margin-top:2rem;text-transform:none}.tox .tox-dialog__body-content .tox-form__group h2{color:#222f3e;font-size:16px;font-style:normal;font-weight:700;letter-spacing:normal;margin-bottom:16px;margin-top:2rem;text-transform:none}.tox .tox-dialog__body-content .tox-form__group p{margin-bottom:16px}.tox .tox-dialog__body-content .tox-form__group h1:first-child,.tox .tox-dialog__body-content .tox-form__group h2:first-child,.tox .tox-dialog__body-content .tox-form__group p:first-child{margin-top:0}.tox .tox-dialog__body-content .tox-form__group h1:last-child,.tox .tox-dialog__body-content .tox-form__group h2:last-child,.tox .tox-dialog__body-content .tox-form__group p:last-child{margin-bottom:0}.tox .tox-dialog__body-content .tox-form__group h1:only-child,.tox .tox-dialog__body-content .tox-form__group h2:only-child,.tox .tox-dialog__body-content .tox-form__group p:only-child{margin-bottom:0;margin-top:0}.tox .tox-dialog__body-content .tox-form__group .tox-label.tox-label--center{text-align:center}.tox .tox-dialog__body-content .tox-form__group .tox-label.tox-label--end{text-align:end}.tox .tox-dialog--width-lg{height:650px;max-width:1200px}.tox .tox-dialog--fullscreen{height:100%;max-width:100%}.tox .tox-dialog--fullscreen .tox-dialog__body-content{max-height:100%}.tox .tox-dialog--width-md{max-width:800px}.tox .tox-dialog--width-md .tox-dialog__body-content{overflow:auto}.tox .tox-dialog__body-content--centered{text-align:center}.tox .tox-dialog__footer{align-items:center;background-color:#fff;border-top:none;display:flex;justify-content:space-between;padding:8px 16px}.tox .tox-dialog__footer-end,.tox .tox-dialog__footer-start{display:flex}.tox .tox-dialog__busy-spinner{align-items:center;background-color:rgba(255,255,255,.75);bottom:0;display:flex;justify-content:center;left:0;position:absolute;right:0;top:0;z-index:3}.tox .tox-dialog__table{border-collapse:collapse;width:100%}.tox .tox-dialog__table thead th{font-weight:700;padding-bottom:8px}.tox .tox-dialog__table thead th:first-child{padding-right:8px}.tox .tox-dialog__table tbody tr{border-bottom:1px solid #626262}.tox .tox-dialog__table tbody tr:last-child{border-bottom:none}.tox .tox-dialog__table td{padding-bottom:8px;padding-top:8px}.tox .tox-dialog__table td:first-child{padding-right:8px}.tox .tox-dialog__iframe{min-height:200px}.tox .tox-dialog__iframe.tox-dialog__iframe--opaque{background:#fff}.tox .tox-navobj-bordered{position:relative}.tox .tox-navobj-bordered::before{border:1px solid #eee;border-radius:6px;content:'';inset:0;opacity:1;pointer-events:none;position:absolute;z-index:1}.tox .tox-navobj-bordered iframe{border-radius:6px}.tox .tox-navobj-bordered-focus.tox-navobj-bordered::before{border-color:#006ce7;box-shadow:0 0 0 1px #006ce7;outline:0}.tox .tox-dialog__popups{position:absolute;width:100%;z-index:1100}.tox .tox-dialog__body-iframe{display:flex;flex:1;flex-direction:column}.tox .tox-dialog__body-iframe .tox-navobj{display:flex;flex:1}.tox .tox-dialog__body-iframe .tox-navobj :nth-child(2){flex:1;height:100%}.tox .tox-dialog-dock-fadeout{opacity:0;visibility:hidden}.tox .tox-dialog-dock-fadein{opacity:1;visibility:visible}.tox .tox-dialog-dock-transition{transition:visibility 0s linear .3s,opacity .3s ease}.tox .tox-dialog-dock-transition.tox-dialog-dock-fadein{transition-delay:0s}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox:not([dir=rtl]) .tox-dialog__body-nav{margin-right:0}}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox:not([dir=rtl]) .tox-dialog__body-nav-item:not(:first-child){margin-left:8px}}.tox:not([dir=rtl]) .tox-dialog__footer .tox-dialog__footer-end>*,.tox:not([dir=rtl]) .tox-dialog__footer .tox-dialog__footer-start>*{margin-left:8px}.tox[dir=rtl] .tox-dialog__body{text-align:right}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox[dir=rtl] .tox-dialog__body-nav{margin-left:0}}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox[dir=rtl] .tox-dialog__body-nav-item:not(:first-child){margin-right:8px}}.tox[dir=rtl] .tox-dialog__footer .tox-dialog__footer-end>*,.tox[dir=rtl] .tox-dialog__footer .tox-dialog__footer-start>*{margin-right:8px}body.tox-dialog__disable-scroll{overflow:hidden}.tox .tox-dropzone-container{display:flex;flex:1}.tox .tox-dropzone{align-items:center;background:#fff;border:2px dashed #eee;box-sizing:border-box;display:flex;flex-direction:column;flex-grow:1;justify-content:center;min-height:100px;padding:10px}.tox .tox-dropzone p{color:rgba(34,47,62,.7);margin:0 0 16px 0}.tox .tox-edit-area{display:flex;flex:1;overflow:hidden;position:relative}.tox .tox-edit-area::before{border:2px solid #006ce7;border-radius:4px;content:'';inset:0;opacity:0;pointer-events:none;position:absolute;transition:opacity .15s;z-index:1}@media (forced-colors:active){.tox .tox-edit-area::before{border:2px solid highlight}}.tox .tox-edit-area__iframe{background-color:#fff;border:0;box-sizing:border-box;flex:1;height:100%;position:absolute;width:100%}.tox.tox-edit-focus .tox-edit-area::before{opacity:1}.tox.tox-inline-edit-area{border:1px dotted #eee}.tox .tox-editor-container{display:flex;flex:1 1 auto;flex-direction:column;overflow:hidden}.tox .tox-editor-header{display:grid;grid-template-columns:1fr min-content;z-index:2}.tox:not(.tox-tinymce-inline) .tox-editor-header{background-color:#fff;border-bottom:none;box-shadow:0 2px 2px -2px rgba(34,47,62,.1),0 8px 8px -4px rgba(34,47,62,.07);padding:4px 0}.tox:not(.tox-tinymce-inline) .tox-editor-header:not(.tox-editor-dock-transition){transition:box-shadow .5s}.tox:not(.tox-tinymce-inline).tox-tinymce--toolbar-bottom .tox-editor-header{border-top:1px solid #e3e3e3;box-shadow:none}.tox:not(.tox-tinymce-inline).tox-tinymce--toolbar-sticky-on .tox-editor-header{background-color:#fff;box-shadow:0 2px 2px -2px rgba(34,47,62,.2),0 8px 8px -4px rgba(34,47,62,.15);padding:4px 0}.tox:not(.tox-tinymce-inline).tox-tinymce--toolbar-sticky-on.tox-tinymce--toolbar-bottom .tox-editor-header{box-shadow:0 2px 2px -2px rgba(34,47,62,.2),0 8px 8px -4px rgba(34,47,62,.15)}.tox.tox:not(.tox-tinymce-inline) .tox-editor-header.tox-editor-header--empty{background:0 0;border:none;box-shadow:none;padding:0}.tox-editor-dock-fadeout{opacity:0;visibility:hidden}.tox-editor-dock-fadein{opacity:1;visibility:visible}.tox-editor-dock-transition{transition:visibility 0s linear .25s,opacity .25s ease}.tox-editor-dock-transition.tox-editor-dock-fadein{transition-delay:0s}.tox .tox-control-wrap{flex:1;position:relative}.tox .tox-control-wrap:not(.tox-control-wrap--status-invalid) .tox-control-wrap__status-icon-invalid,.tox .tox-control-wrap:not(.tox-control-wrap--status-unknown) .tox-control-wrap__status-icon-unknown,.tox .tox-control-wrap:not(.tox-control-wrap--status-valid) .tox-control-wrap__status-icon-valid{display:none}.tox .tox-control-wrap svg{display:block}.tox .tox-control-wrap__status-icon-wrap{position:absolute;top:50%;transform:translateY(-50%)}.tox .tox-control-wrap__status-icon-invalid svg{fill:#c00}.tox .tox-control-wrap__status-icon-unknown svg{fill:orange}.tox .tox-control-wrap__status-icon-valid svg{fill:green}.tox:not([dir=rtl]) .tox-control-wrap--status-invalid .tox-textfield,.tox:not([dir=rtl]) .tox-control-wrap--status-unknown .tox-textfield,.tox:not([dir=rtl]) .tox-control-wrap--status-valid .tox-textfield{padding-right:32px}.tox:not([dir=rtl]) .tox-control-wrap__status-icon-wrap{right:4px}.tox[dir=rtl] .tox-control-wrap--status-invalid .tox-textfield,.tox[dir=rtl] .tox-control-wrap--status-unknown .tox-textfield,.tox[dir=rtl] .tox-control-wrap--status-valid .tox-textfield{padding-left:32px}.tox[dir=rtl] .tox-control-wrap__status-icon-wrap{left:4px}.tox .tox-custom-preview{border-color:#eee;border-radius:6px;border-style:solid;border-width:1px;flex:1;padding:8px}.tox .tox-autocompleter{max-width:25em}.tox .tox-autocompleter .tox-menu{box-sizing:border-box;max-width:25em}.tox .tox-autocompleter .tox-autocompleter-highlight{font-weight:700}.tox .tox-color-input{display:flex;position:relative;z-index:1}.tox .tox-color-input .tox-textfield{z-index:-1}.tox .tox-color-input span{border-color:rgba(34,47,62,.2);border-radius:6px;border-style:solid;border-width:1px;box-shadow:none;box-sizing:border-box;height:24px;position:absolute;top:6px;width:24px}@media (forced-colors:active){.tox .tox-color-input span{border-color:currentColor;border-width:2px!important;forced-color-adjust:none}}.tox .tox-color-input span:focus:not([aria-disabled=true]),.tox .tox-color-input span:hover:not([aria-disabled=true]){border-color:#006ce7;cursor:pointer}.tox .tox-color-input span::before{background-image:linear-gradient(45deg,rgba(0,0,0,.25) 25%,transparent 25%),linear-gradient(-45deg,rgba(0,0,0,.25) 25%,transparent 25%),linear-gradient(45deg,transparent 75%,rgba(0,0,0,.25) 75%),linear-gradient(-45deg,transparent 75%,rgba(0,0,0,.25) 75%);background-position:0 0,0 6px,6px -6px,-6px 0;background-size:12px 12px;border:1px solid #fff;border-radius:6px;box-sizing:border-box;content:'';height:24px;left:-1px;position:absolute;top:-1px;width:24px;z-index:-1}@media (forced-colors:active){.tox .tox-color-input span::before{border:none}}.tox .tox-color-input span[aria-disabled=true]{cursor:not-allowed}.tox:not([dir=rtl]) .tox-color-input .tox-textfield{padding-left:36px}.tox:not([dir=rtl]) .tox-color-input span{left:6px}.tox[dir=rtl] .tox-color-input .tox-textfield{padding-right:36px}.tox[dir=rtl] .tox-color-input span{right:6px}.tox .tox-label,.tox .tox-toolbar-label{color:rgba(34,47,62,.7);display:block;font-size:14px;font-style:normal;font-weight:400;line-height:1.3;padding:0 8px 0 0;text-transform:none;white-space:nowrap}.tox .tox-toolbar-label{padding:0 8px}.tox[dir=rtl] .tox-label{padding:0 0 0 8px}.tox .tox-form{display:flex;flex:1;flex-direction:column}.tox .tox-form__group{box-sizing:border-box;margin-bottom:4px}.tox .tox-form-group--maximize{flex:1}.tox .tox-form__group--error{color:#c00}.tox .tox-form__group--collection{display:flex}.tox .tox-form__grid{display:flex;flex-direction:row;flex-wrap:wrap;justify-content:space-between}.tox .tox-form__grid--2col>.tox-form__group{width:calc(50% - (8px / 2))}.tox .tox-form__grid--3col>.tox-form__group{width:calc(100% / 3 - (8px / 2))}.tox .tox-form__grid--4col>.tox-form__group{width:calc(25% - (8px / 2))}.tox .tox-form__controls-h-stack{align-items:center;display:flex}.tox .tox-form__group--inline{align-items:center;display:flex}.tox .tox-form__group--stretched{display:flex;flex:1;flex-direction:column}.tox .tox-form__group--stretched .tox-textarea{flex:1}.tox .tox-form__group--stretched .tox-navobj{display:flex;flex:1}.tox .tox-form__group--stretched .tox-navobj :nth-child(2){flex:1;height:100%}.tox:not([dir=rtl]) .tox-form__controls-h-stack>:not(:first-child){margin-left:4px}.tox[dir=rtl] .tox-form__controls-h-stack>:not(:first-child){margin-right:4px}.tox .tox-lock.tox-locked .tox-lock-icon__unlock,.tox .tox-lock:not(.tox-locked) .tox-lock-icon__lock{display:none}.tox .tox-listboxfield .tox-listbox--select,.tox .tox-textarea,.tox .tox-textarea-wrap .tox-textarea:focus,.tox .tox-textfield,.tox .tox-toolbar-textfield{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:#fff;border-color:#eee;border-radius:6px;border-style:solid;border-width:1px;box-shadow:none;box-sizing:border-box;color:#222f3e;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:16px;line-height:24px;margin:0;min-height:34px;outline:0;padding:5px 5.5px;resize:none;width:100%}.tox .tox-textarea[disabled],.tox .tox-textfield[disabled]{background-color:#f2f2f2;color:rgba(34,47,62,.85);cursor:not-allowed}.tox .tox-custom-editor:focus-within,.tox .tox-listboxfield .tox-listbox--select:focus,.tox .tox-textarea-wrap:focus-within,.tox .tox-textarea:focus,.tox .tox-textfield:focus{background-color:#fff;border-color:#006ce7;box-shadow:0 0 0 1px #006ce7;outline:0}.tox .tox-toolbar-textfield{border-width:0;margin-bottom:3px;margin-top:2px;max-width:250px}.tox .tox-naked-btn{background-color:transparent;border:0;border-color:transparent;box-shadow:unset;color:#006ce7;cursor:pointer;display:block;margin:0;padding:0}.tox .tox-naked-btn svg{display:block;fill:#222f3e}.tox:not([dir=rtl]) .tox-toolbar-textfield+*{margin-left:4px}.tox[dir=rtl] .tox-toolbar-textfield+*{margin-right:4px}.tox .tox-listboxfield{cursor:pointer;position:relative}.tox .tox-listboxfield .tox-listbox--select[disabled]{background-color:#f2f2f2;color:rgba(34,47,62,.85);cursor:not-allowed}.tox .tox-listbox__select-label{cursor:default;flex:1;margin:0 4px}.tox .tox-listbox__select-chevron{align-items:center;display:flex;justify-content:center;width:16px}.tox .tox-listbox__select-chevron svg{fill:#222f3e}@media (forced-colors:active){.tox .tox-listbox__select-chevron svg{fill:currentColor!important}}.tox .tox-listboxfield .tox-listbox--select{align-items:center;display:flex}.tox:not([dir=rtl]) .tox-listboxfield svg{right:8px}.tox[dir=rtl] .tox-listboxfield svg{left:8px}.tox .tox-selectfield{cursor:pointer;position:relative}.tox .tox-selectfield select{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:#fff;border-color:#eee;border-radius:6px;border-style:solid;border-width:1px;box-shadow:none;box-sizing:border-box;color:#222f3e;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:16px;line-height:24px;margin:0;min-height:34px;outline:0;padding:5px 5.5px;resize:none;width:100%}.tox .tox-selectfield select[disabled]{background-color:#f2f2f2;color:rgba(34,47,62,.85);cursor:not-allowed}.tox .tox-selectfield select::-ms-expand{display:none}.tox .tox-selectfield select:focus{background-color:#fff;border-color:#006ce7;box-shadow:0 0 0 1px #006ce7;outline:0}.tox .tox-selectfield svg{pointer-events:none;position:absolute;top:50%;transform:translateY(-50%)}.tox:not([dir=rtl]) .tox-selectfield select[size="0"],.tox:not([dir=rtl]) .tox-selectfield select[size="1"]{padding-right:24px}.tox:not([dir=rtl]) .tox-selectfield svg{right:8px}.tox[dir=rtl] .tox-selectfield select[size="0"],.tox[dir=rtl] .tox-selectfield select[size="1"]{padding-left:24px}.tox[dir=rtl] .tox-selectfield svg{left:8px}.tox .tox-textarea-wrap{border-color:#eee;border-radius:6px;border-style:solid;border-width:1px;display:flex;flex:1;overflow:hidden}.tox .tox-textarea{-webkit-appearance:textarea;-moz-appearance:textarea;appearance:textarea;white-space:pre-wrap}.tox .tox-textarea-wrap .tox-textarea{border:none}.tox .tox-textarea-wrap .tox-textarea:focus{border:none}.tox-fullscreen{border:0;height:100%;margin:0;overflow:hidden;overscroll-behavior:none;padding:0;touch-action:pinch-zoom;width:100%}.tox.tox-tinymce.tox-fullscreen .tox-statusbar__resize-handle{display:none}.tox-shadowhost.tox-fullscreen,.tox.tox-tinymce.tox-fullscreen{left:0;position:fixed;top:0;z-index:1200}.tox.tox-tinymce.tox-fullscreen{background-color:transparent}.tox-fullscreen .tox.tox-tinymce-aux,.tox-fullscreen~.tox.tox-tinymce-aux{z-index:1201}.tox .tox-help__more-link{list-style:none;margin-top:1em}.tox .tox-imagepreview{background-color:#666;height:380px;overflow:hidden;position:relative;width:100%}.tox .tox-imagepreview.tox-imagepreview__loaded{overflow:auto}.tox .tox-imagepreview__container{display:flex;left:100vw;position:absolute;top:100vw}.tox .tox-imagepreview__image{background:url(data:image/gif;base64,R0lGODdhDAAMAIABAMzMzP///ywAAAAADAAMAAACFoQfqYeabNyDMkBQb81Uat85nxguUAEAOw==)}.tox .tox-image-tools .tox-spacer{flex:1}.tox .tox-image-tools .tox-bar{align-items:center;display:flex;height:60px;justify-content:center}.tox .tox-image-tools .tox-imagepreview,.tox .tox-image-tools .tox-imagepreview+.tox-bar{margin-top:8px}.tox .tox-image-tools .tox-croprect-block{background:#000;opacity:.5;position:absolute;zoom:1}.tox .tox-image-tools .tox-croprect-handle{border:2px solid #fff;height:20px;left:0;position:absolute;top:0;width:20px}.tox .tox-image-tools .tox-croprect-handle-move{border:0;cursor:move;position:absolute}.tox .tox-image-tools .tox-croprect-handle-nw{border-width:2px 0 0 2px;cursor:nw-resize;left:100px;margin:-2px 0 0 -2px;top:100px}.tox .tox-image-tools .tox-croprect-handle-ne{border-width:2px 2px 0 0;cursor:ne-resize;left:200px;margin:-2px 0 0 -20px;top:100px}.tox .tox-image-tools .tox-croprect-handle-sw{border-width:0 0 2px 2px;cursor:sw-resize;left:100px;margin:-20px 2px 0 -2px;top:200px}.tox .tox-image-tools .tox-croprect-handle-se{border-width:0 2px 2px 0;cursor:se-resize;left:200px;margin:-20px 0 0 -20px;top:200px}.tox .tox-insert-table-picker{background-color:#fff;display:flex;flex-wrap:wrap;width:170px}.tox .tox-insert-table-picker>div{border-color:#eee;border-style:solid;border-width:0 1px 1px 0;box-sizing:border-box;height:17px;width:17px}.tox .tox-collection--list .tox-collection__group .tox-insert-table-picker{margin:-4px -4px}.tox .tox-insert-table-picker .tox-insert-table-picker__selected{background-color:#006ce7;border-color:#eee}@media (forced-colors:active){.tox .tox-insert-table-picker .tox-insert-table-picker__selected{border-color:Highlight;filter:contrast(50%)}}.tox .tox-insert-table-picker__label{color:rgba(34,47,62,.7);display:block;font-size:14px;padding:4px;text-align:center;width:100%}.tox:not([dir=rtl]) .tox-insert-table-picker>div:nth-child(10n){border-right:0}.tox[dir=rtl] .tox-insert-table-picker>div:nth-child(10n+1){border-right:0}.tox .tox-menu{background-color:#fff;border:1px solid transparent;border-radius:6px;box-shadow:0 0 2px 0 rgba(34,47,62,.2),0 4px 8px 0 rgba(34,47,62,.15);display:inline-block;overflow:hidden;vertical-align:top;z-index:1150}.tox .tox-menu.tox-collection.tox-collection--list{padding:0 4px}.tox .tox-menu.tox-collection.tox-collection--toolbar{padding:8px}.tox .tox-menu.tox-collection.tox-collection--grid{padding:8px}@media only screen and (min-width:768px){.tox .tox-menu .tox-collection__item-label{overflow-wrap:break-word;word-break:normal}.tox .tox-dialog__popups .tox-menu .tox-collection__item-label{word-break:break-all}}.tox .tox-menu__label blockquote,.tox .tox-menu__label code,.tox .tox-menu__label h1,.tox .tox-menu__label h2,.tox .tox-menu__label h3,.tox .tox-menu__label h4,.tox .tox-menu__label h5,.tox .tox-menu__label h6,.tox .tox-menu__label p{margin:0}.tox .tox-menubar{background:repeating-linear-gradient(transparent 0 1px,transparent 1px 39px) center top 39px/100% calc(100% - 39px) no-repeat;background-color:#fff;display:flex;flex:0 0 auto;flex-shrink:0;flex-wrap:wrap;grid-column:1/-1;grid-row:1;padding:0 11px 0 12px}.tox .tox-promotion+.tox-menubar{grid-column:1}.tox .tox-promotion{background:repeating-linear-gradient(transparent 0 1px,transparent 1px 39px) center top 39px/100% calc(100% - 39px) no-repeat;background-color:#fff;grid-column:2;grid-row:1;padding-inline-end:8px;padding-inline-start:4px;padding-top:5px}.tox .tox-promotion-link{align-items:unsafe center;background-color:#e8f1f8;border-radius:5px;color:#086be6;cursor:pointer;display:flex;font-size:14px;height:26.6px;padding:4px 8px;white-space:nowrap}.tox .tox-promotion-link:hover{background-color:#b4d7ff}.tox .tox-promotion-link:focus{background-color:#d9edf7}.tox .tox-mbtn{align-items:center;background:#fff;border:0;border-radius:3px;box-shadow:none;color:#222f3e;display:flex;flex:0 0 auto;font-size:14px;font-style:normal;font-weight:400;height:28px;justify-content:center;margin:5px 1px 6px 0;outline:0;padding:0 4px;text-transform:none;width:auto}.tox .tox-mbtn[disabled]{background-color:#fff;border:0;box-shadow:none;color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-mbtn:focus:not(:disabled){background:#fff;border:0;box-shadow:none;color:#222f3e;position:relative;z-index:1}.tox .tox-mbtn:focus:not(:disabled)::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-mbtn:focus:not(:disabled)::after{border:2px solid highlight}}.tox .tox-mbtn--active,.tox .tox-mbtn:not(:disabled).tox-mbtn--active:focus{background:#a6ccf7;border:0;box-shadow:none;color:#222f3e}.tox .tox-mbtn:hover:not(:disabled):not(.tox-mbtn--active){background:#f0f0f0;border:0;box-shadow:none;color:#222f3e}.tox .tox-mbtn__select-label{cursor:default;font-weight:400;margin:0 4px}.tox .tox-mbtn[disabled] .tox-mbtn__select-label{cursor:not-allowed}.tox .tox-mbtn__select-chevron{align-items:center;display:flex;justify-content:center;width:16px;display:none}.tox .tox-notification{border-radius:6px;border-style:solid;border-width:1px;box-shadow:none;box-sizing:border-box;display:grid;font-size:14px;font-weight:400;grid-template-columns:minmax(40px,1fr) auto minmax(40px,1fr);margin-left:auto;margin-right:auto;margin-top:4px;opacity:0;padding:4px;transition:transform .1s ease-in,opacity 150ms ease-in;width:-moz-max-content;width:max-content}.tox .tox-notification a{cursor:pointer;text-decoration:underline}.tox .tox-notification p{font-size:14px;font-weight:400}.tox .tox-notification:focus{border-color:#006ce7;box-shadow:0 0 0 1px #006ce7}.tox .tox-notification--in{opacity:1}.tox .tox-notification--success{background-color:#e4eeda;border-color:#d7e6c8;color:#222f3e}.tox .tox-notification--success p{color:#222f3e}.tox .tox-notification--success a{color:#517342}.tox .tox-notification--success a:focus,.tox .tox-notification--success a:hover{color:#24321d;text-decoration:underline}.tox .tox-notification--success a:focus-visible{border-radius:1px;outline:2px solid #517342;outline-offset:2px}.tox .tox-notification--success a:active{color:#0d120a;text-decoration:underline}.tox .tox-notification--success svg{fill:#222f3e}.tox .tox-notification--error{background-color:#f5cccc;border-color:#f0b3b3;color:#222f3e}.tox .tox-notification--error p{color:#222f3e}.tox .tox-notification--error a{color:#77181f}.tox .tox-notification--error a:focus,.tox .tox-notification--error a:hover{color:#220709;text-decoration:underline}.tox .tox-notification--error a:focus-visible{border-radius:1px;outline:2px solid #77181f;outline-offset:2px}.tox .tox-notification--error a:active{color:#000;text-decoration:underline}.tox .tox-notification--error svg{fill:#222f3e}.tox .tox-notification--warn,.tox .tox-notification--warning{background-color:#fff5cc;border-color:#fff0b3;color:#222f3e}.tox .tox-notification--warn p,.tox .tox-notification--warning p{color:#222f3e}.tox .tox-notification--warn a,.tox .tox-notification--warning a{color:#7a6e25}.tox .tox-notification--warn a:focus,.tox .tox-notification--warn a:hover,.tox .tox-notification--warning a:focus,.tox .tox-notification--warning a:hover{color:#2c280d;text-decoration:underline}.tox .tox-notification--warn a:focus-visible,.tox .tox-notification--warning a:focus-visible{border-radius:1px;outline:2px solid #7a6e25;outline-offset:2px}.tox .tox-notification--warn a:active,.tox .tox-notification--warning a:active{color:#050502;text-decoration:underline}.tox .tox-notification--warn svg,.tox .tox-notification--warning svg{fill:#222f3e}.tox .tox-notification--info{background-color:#d6e7fb;border-color:#c1dbf9;color:#222f3e}.tox .tox-notification--info p{color:#222f3e}.tox .tox-notification--info a{color:#2a64a6}.tox .tox-notification--info a:focus,.tox .tox-notification--info a:hover{color:#163355;text-decoration:underline}.tox .tox-notification--info a:focus-visible{border-radius:1px;outline:2px solid #2a64a6;outline-offset:2px}.tox .tox-notification--info a:active{color:#0b1a2c;text-decoration:underline}.tox .tox-notification--info svg{fill:#222f3e}.tox .tox-notification__body{align-self:center;color:#222f3e;font-size:14px;grid-column-end:3;grid-column-start:2;grid-row-end:2;grid-row-start:1;text-align:center;white-space:normal;word-break:break-all;word-break:break-word}.tox .tox-notification__body>*{margin:0}.tox .tox-notification__body>*+*{margin-top:1rem}.tox .tox-notification__icon{align-self:center;grid-column-end:2;grid-column-start:1;grid-row-end:2;grid-row-start:1;justify-self:end}.tox .tox-notification__icon svg{display:block}.tox .tox-notification__dismiss{align-self:start;grid-column-end:4;grid-column-start:3;grid-row-end:2;grid-row-start:1;justify-self:end}.tox .tox-notification .tox-progress-bar{grid-column-end:4;grid-column-start:1;grid-row-end:3;grid-row-start:2;justify-self:center}.tox .tox-notification-container-dock-fadeout{opacity:0;visibility:hidden}.tox .tox-notification-container-dock-fadein{opacity:1;visibility:visible}.tox .tox-notification-container-dock-transition{transition:visibility 0s linear .3s,opacity .3s ease}.tox .tox-notification-container-dock-transition.tox-notification-container-dock-fadein{transition-delay:0s}.tox .tox-pop{display:inline-block;position:relative}.tox .tox-pop--resizing{transition:width .1s ease}.tox .tox-pop--resizing .tox-toolbar,.tox .tox-pop--resizing .tox-toolbar__group{flex-wrap:nowrap}.tox .tox-pop--transition{transition:.15s ease;transition-property:left,right,top,bottom}.tox .tox-pop--transition::after,.tox .tox-pop--transition::before{transition:all .15s,visibility 0s,opacity 75ms ease 75ms}.tox .tox-pop__dialog{background-color:#fff;border:1px solid #eee;border-radius:6px;box-shadow:0 0 2px 0 rgba(34,47,62,.2),0 4px 8px 0 rgba(34,47,62,.15);min-width:0;overflow:hidden}.tox .tox-pop__dialog>:not(.tox-toolbar){margin:4px 4px 4px 8px}.tox .tox-pop__dialog .tox-toolbar{background-color:transparent;margin-bottom:-1px}.tox .tox-pop::after,.tox .tox-pop::before{border-style:solid;content:'';display:block;height:0;opacity:1;position:absolute;width:0}@media (forced-colors:active){.tox .tox-pop::after,.tox .tox-pop::before{content:none}}.tox .tox-pop.tox-pop--inset::after,.tox .tox-pop.tox-pop--inset::before{opacity:0;transition:all 0s .15s,visibility 0s,opacity 75ms ease}.tox .tox-pop.tox-pop--bottom::after,.tox .tox-pop.tox-pop--bottom::before{left:50%;top:100%}.tox .tox-pop.tox-pop--bottom::after{border-color:#fff transparent transparent transparent;border-width:8px;margin-left:-8px;margin-top:-1px}.tox .tox-pop.tox-pop--bottom::before{border-color:#eee transparent transparent transparent;border-width:9px;margin-left:-9px}.tox .tox-pop.tox-pop--top::after,.tox .tox-pop.tox-pop--top::before{left:50%;top:0;transform:translateY(-100%)}.tox .tox-pop.tox-pop--top::after{border-color:transparent transparent #fff transparent;border-width:8px;margin-left:-8px;margin-top:1px}.tox .tox-pop.tox-pop--top::before{border-color:transparent transparent #eee transparent;border-width:9px;margin-left:-9px}.tox .tox-pop.tox-pop--left::after,.tox .tox-pop.tox-pop--left::before{left:0;top:calc(50% - 1px);transform:translateY(-50%)}.tox .tox-pop.tox-pop--left::after{border-color:transparent #fff transparent transparent;border-width:8px;margin-left:-15px}.tox .tox-pop.tox-pop--left::before{border-color:transparent #eee transparent transparent;border-width:10px;margin-left:-19px}.tox .tox-pop.tox-pop--right::after,.tox .tox-pop.tox-pop--right::before{left:100%;top:calc(50% + 1px);transform:translateY(-50%)}.tox .tox-pop.tox-pop--right::after{border-color:transparent transparent transparent #fff;border-width:8px;margin-left:-1px}.tox .tox-pop.tox-pop--right::before{border-color:transparent transparent transparent #eee;border-width:10px;margin-left:-1px}.tox .tox-pop.tox-pop--align-left::after,.tox .tox-pop.tox-pop--align-left::before{left:20px}.tox .tox-pop.tox-pop--align-right::after,.tox .tox-pop.tox-pop--align-right::before{left:calc(100% - 20px)}.tox .tox-sidebar-wrap{display:flex;flex-direction:row;flex-grow:1;min-height:0}.tox .tox-sidebar{background-color:#fff;display:flex;flex-direction:row;justify-content:flex-end}.tox .tox-sidebar__slider{display:flex;overflow:hidden}.tox .tox-sidebar__pane-container{display:flex}.tox .tox-sidebar__pane{display:flex}.tox .tox-sidebar--sliding-closed{opacity:0}.tox .tox-sidebar--sliding-open{opacity:1}.tox .tox-sidebar--sliding-growing,.tox .tox-sidebar--sliding-shrinking{transition:width .5s ease,opacity .5s ease}.tox .tox-selector{background-color:#4099ff;border-color:#4099ff;border-style:solid;border-width:1px;box-sizing:border-box;display:inline-block;height:10px;position:absolute;width:10px}.tox.tox-platform-touch .tox-selector{height:12px;width:12px}.tox .tox-slider{align-items:center;display:flex;flex:1;height:24px;justify-content:center;position:relative}.tox .tox-slider__rail{background-color:transparent;border:1px solid #eee;border-radius:6px;height:10px;min-width:120px;width:100%}.tox .tox-slider__handle{background-color:#006ce7;border:2px solid #0054b4;border-radius:6px;box-shadow:none;height:24px;left:50%;position:absolute;top:50%;transform:translateX(-50%) translateY(-50%);width:14px}.tox .tox-form__controls-h-stack>.tox-slider:not(:first-of-type){margin-inline-start:8px}.tox .tox-form__controls-h-stack>.tox-form__group+.tox-slider{margin-inline-start:32px}.tox .tox-form__controls-h-stack>.tox-slider+.tox-form__group{margin-inline-start:32px}.tox .tox-source-code{overflow:auto}.tox .tox-spinner{display:flex}.tox .tox-spinner>div{animation:tam-bouncing-dots 1.5s ease-in-out 0s infinite both;background-color:rgba(34,47,62,.7);border-radius:100%;height:8px;width:8px}.tox .tox-spinner>div:nth-child(1){animation-delay:-.32s}.tox .tox-spinner>div:nth-child(2){animation-delay:-.16s}@keyframes tam-bouncing-dots{0%,100%,80%{transform:scale(0)}40%{transform:scale(1)}}.tox:not([dir=rtl]) .tox-spinner>div:not(:first-child){margin-left:4px}.tox[dir=rtl] .tox-spinner>div:not(:first-child){margin-right:4px}.tox .tox-statusbar{align-items:center;background-color:#fff;border-top:1px solid #e3e3e3;color:rgba(34,47,62,.7);display:flex;flex:0 0 auto;font-size:14px;font-weight:400;height:25px;overflow:hidden;padding:0 8px;position:relative;text-transform:none}.tox .tox-statusbar__path{display:flex;flex:1 1 auto;text-overflow:ellipsis;white-space:nowrap}.tox .tox-statusbar__right-container{display:flex;justify-content:flex-end;white-space:nowrap}.tox .tox-statusbar__help-text{text-align:center}.tox .tox-statusbar__text-container{align-items:flex-start;display:flex;flex:1 1 auto;height:16px;justify-content:space-between;overflow:hidden}@media only screen and (min-width:768px){.tox .tox-statusbar__text-container.tox-statusbar__text-container-3-cols>.tox-statusbar__help-text,.tox .tox-statusbar__text-container.tox-statusbar__text-container-3-cols>.tox-statusbar__path,.tox .tox-statusbar__text-container.tox-statusbar__text-container-3-cols>.tox-statusbar__right-container{flex:0 0 calc(100% / 3)}}.tox .tox-statusbar__text-container.tox-statusbar__text-container--flex-end{justify-content:flex-end}.tox .tox-statusbar__text-container.tox-statusbar__text-container--flex-start{justify-content:flex-start}.tox .tox-statusbar__text-container.tox-statusbar__text-container--space-around{justify-content:space-around}.tox .tox-statusbar__path>*{display:inline;white-space:nowrap}.tox .tox-statusbar__wordcount{flex:0 0 auto;margin-left:1ch}@media only screen and (max-width:767px){.tox .tox-statusbar__text-container .tox-statusbar__help-text{display:none}.tox .tox-statusbar__text-container .tox-statusbar__help-text:only-child{display:block}}.tox .tox-statusbar a,.tox .tox-statusbar__path-item,.tox .tox-statusbar__wordcount{color:rgba(34,47,62,.7);position:relative;text-decoration:none}.tox .tox-statusbar a:focus:not(:disabled):not([aria-disabled=true]),.tox .tox-statusbar a:hover:not(:disabled):not([aria-disabled=true]),.tox .tox-statusbar__path-item:focus:not(:disabled):not([aria-disabled=true]),.tox .tox-statusbar__path-item:hover:not(:disabled):not([aria-disabled=true]),.tox .tox-statusbar__wordcount:focus:not(:disabled):not([aria-disabled=true]),.tox .tox-statusbar__wordcount:hover:not(:disabled):not([aria-disabled=true]){color:#222f3e;cursor:pointer}.tox .tox-statusbar a:focus-visible::after,.tox .tox-statusbar__path-item:focus-visible::after,.tox .tox-statusbar__wordcount:focus-visible::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-statusbar a:focus-visible::after,.tox .tox-statusbar__path-item:focus-visible::after,.tox .tox-statusbar__wordcount:focus-visible::after{border:2px solid highlight}}.tox .tox-statusbar__branding svg{fill:rgba(34,47,62,.8);height:1em;margin-left:.3em;width:auto}@media (forced-colors:active){.tox .tox-statusbar__branding svg{fill:currentColor}}.tox .tox-statusbar__branding a{align-items:center;display:inline-flex}.tox .tox-statusbar__branding a:focus:not(:disabled):not([aria-disabled=true]) svg,.tox .tox-statusbar__branding a:hover:not(:disabled):not([aria-disabled=true]) svg{fill:#222f3e}.tox .tox-statusbar__resize-handle{align-items:flex-end;align-self:stretch;cursor:nwse-resize;display:flex;flex:0 0 auto;justify-content:flex-end;margin-bottom:3px;margin-left:4px;margin-right:calc(3px - 8px);margin-top:3px;padding-bottom:0;padding-left:0;padding-right:0;position:relative}.tox .tox-statusbar__resize-handle svg{display:block;fill:rgba(34,47,62,.5)}.tox .tox-statusbar__resize-handle:focus svg,.tox .tox-statusbar__resize-handle:hover svg{fill:#222f3e}.tox .tox-statusbar__resize-handle:focus-visible{background-color:transparent;border-radius:1px 1px 5px 1px;box-shadow:0 0 0 2px transparent}.tox .tox-statusbar__resize-handle:focus-visible::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-statusbar__resize-handle:focus-visible::after{border:2px solid highlight}}.tox:not([dir=rtl]) .tox-statusbar__path>*{margin-right:4px}.tox:not([dir=rtl]) .tox-statusbar__branding{margin-left:2ch}.tox[dir=rtl] .tox-statusbar{flex-direction:row-reverse}.tox[dir=rtl] .tox-statusbar__path>*{margin-left:4px}.tox[dir=rtl] .tox-statusbar__branding svg{margin-left:0;margin-right:.3em}.tox .tox-throbber{z-index:1299}.tox .tox-throbber__busy-spinner{align-items:center;background-color:rgba(255,255,255,.6);bottom:0;display:flex;justify-content:center;left:0;position:absolute;right:0;top:0}.tox .tox-tbtn{align-items:center;background:#fff;border:0;border-radius:3px;box-shadow:none;color:#222f3e;display:flex;flex:0 0 auto;font-size:14px;font-style:normal;font-weight:400;height:28px;justify-content:center;margin:6px 1px 5px 0;outline:0;padding:0;text-transform:none;width:34px}@media (forced-colors:active){.tox .tox-tbtn.tox-tbtn:hover,.tox .tox-tbtn:hover{outline:1px dashed currentColor}.tox .tox-tbtn.tox-tbtn--active,.tox .tox-tbtn.tox-tbtn--enabled,.tox .tox-tbtn.tox-tbtn--enabled:focus,.tox .tox-tbtn.tox-tbtn--enabled:hover,.tox .tox-tbtn:focus:not(.tox-tbtn--disabled){outline:1px solid currentColor;position:relative}}.tox .tox-tbtn svg{display:block;fill:#222f3e}@media (forced-colors:active){.tox .tox-tbtn svg{fill:currentColor!important}.tox .tox-tbtn svg.tox-tbtn--enabled,.tox .tox-tbtn svg:focus:not(.tox-tbtn--disabled){fill:currentColor!important}.tox .tox-tbtn svg .tox-tbtn:disabled,.tox .tox-tbtn svg .tox-tbtn:disabled:hover,.tox .tox-tbtn svg.tox-tbtn--disabled,.tox .tox-tbtn svg.tox-tbtn--disabled:hover{filter:contrast(0)}}.tox .tox-tbtn.tox-tbtn-more{padding-left:5px;padding-right:5px;width:inherit}.tox .tox-tbtn:focus{background:#fff;border:0;box-shadow:none;position:relative;z-index:1}.tox .tox-tbtn:focus::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-tbtn:focus::after{border:2px solid highlight}}.tox .tox-tbtn:hover{background:#f0f0f0;border:0;box-shadow:none;color:#222f3e}.tox .tox-tbtn:hover svg{fill:#222f3e}.tox .tox-tbtn:active{background:#a6ccf7;border:0;box-shadow:none;color:#222f3e}.tox .tox-tbtn:active svg{fill:#222f3e}.tox .tox-tbtn--disabled .tox-tbtn--enabled svg{fill:rgba(34,47,62,.5)}.tox .tox-tbtn--disabled,.tox .tox-tbtn--disabled:hover,.tox .tox-tbtn:disabled,.tox .tox-tbtn:disabled:hover{background:#fff;border:0;box-shadow:none;color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-tbtn--disabled svg,.tox .tox-tbtn--disabled:hover svg,.tox .tox-tbtn:disabled svg,.tox .tox-tbtn:disabled:hover svg{fill:rgba(34,47,62,.5)}.tox .tox-tbtn--active,.tox .tox-tbtn--enabled,.tox .tox-tbtn--enabled:focus,.tox .tox-tbtn--enabled:hover{background:#a6ccf7;border:0;box-shadow:none;color:#222f3e;position:relative}.tox .tox-tbtn--active>*,.tox .tox-tbtn--enabled:focus>*,.tox .tox-tbtn--enabled:hover>*,.tox .tox-tbtn--enabled>*{transform:none}.tox .tox-tbtn--active svg,.tox .tox-tbtn--enabled svg,.tox .tox-tbtn--enabled:focus svg,.tox .tox-tbtn--enabled:hover svg{fill:#222f3e}.tox .tox-tbtn--active.tox-tbtn--disabled svg,.tox .tox-tbtn--enabled.tox-tbtn--disabled svg,.tox .tox-tbtn--enabled:focus.tox-tbtn--disabled svg,.tox .tox-tbtn--enabled:hover.tox-tbtn--disabled svg{fill:rgba(34,47,62,.5)}.tox .tox-tbtn--enabled:focus::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-tbtn--enabled:focus::after{border:2px solid highlight}}.tox .tox-tbtn:focus:not(.tox-tbtn--disabled){color:#222f3e}.tox .tox-tbtn:focus:not(.tox-tbtn--disabled) svg{fill:#222f3e}.tox .tox-tbtn:active>*{transform:none}.tox .tox-tbtn--md{height:42px;width:51px}.tox .tox-tbtn--lg{flex-direction:column;height:56px;width:68px}.tox .tox-tbtn--return{align-self:stretch;height:unset;width:16px}.tox .tox-tbtn--labeled{padding:0 4px;width:unset}.tox .tox-tbtn__vlabel{display:block;font-size:10px;font-weight:400;letter-spacing:-.025em;margin-bottom:4px;white-space:nowrap}.tox .tox-number-input{background:#f7f7f7;border-radius:3px;display:flex;margin:6px 1px 5px 0;position:relative;width:auto}.tox .tox-number-input:focus{background:#f7f7f7}.tox .tox-number-input:focus::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-number-input:focus::after{border:2px solid highlight}}.tox .tox-number-input .tox-input-wrapper{display:flex;pointer-events:none;position:relative;text-align:center}.tox .tox-number-input .tox-input-wrapper:focus{background-color:#f7f7f7;z-index:1}.tox .tox-number-input .tox-input-wrapper:focus::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-number-input .tox-input-wrapper:focus::after{border:2px solid highlight}}.tox .tox-number-input .tox-input-wrapper:has(input:focus)::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-number-input .tox-input-wrapper:has(input:focus)::after{border:2px solid highlight}}.tox .tox-number-input input{border-radius:3px;color:#222f3e;font-size:14px;margin:2px 0;pointer-events:all;position:relative;width:60px}.tox .tox-number-input input:hover{background:#f0f0f0;color:#222f3e}.tox .tox-number-input input:focus{background-color:#f7f7f7}.tox .tox-number-input input:disabled{background:#fff;border:0;box-shadow:none;color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-number-input button{color:#222f3e;height:28px;position:relative;text-align:center;width:24px}@media (forced-colors:active){.tox .tox-number-input button:active,.tox .tox-number-input button:focus,.tox .tox-number-input button:hover{outline:1px solid currentColor!important}}.tox .tox-number-input button svg{display:block;fill:#222f3e;margin:0 auto;transform:scale(.67)}@media (forced-colors:active){.tox .tox-number-input button svg,.tox .tox-number-input button svg:active,.tox .tox-number-input button svg:hover{fill:currentColor!important}.tox .tox-number-input button svg:disabled{filter:contrast(0)}}.tox .tox-number-input button:focus{background:#f7f7f7;z-index:1}.tox .tox-number-input button:focus::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-number-input button:focus::after{border:2px solid highlight}}.tox .tox-number-input button:hover{background:#f0f0f0;border:0;box-shadow:none;color:#222f3e}.tox .tox-number-input button:hover svg{fill:#222f3e}.tox .tox-number-input button:active{background:#a6ccf7;border:0;box-shadow:none;color:#222f3e}.tox .tox-number-input button:active svg{fill:#222f3e}.tox .tox-number-input button:disabled{background:#fff;border:0;box-shadow:none;color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-number-input button:disabled svg{fill:rgba(34,47,62,.5)}.tox .tox-number-input button.minus{border-radius:3px 0 0 3px}.tox .tox-number-input button.plus{border-radius:0 3px 3px 0}.tox .tox-number-input:focus:not(:active)>.tox-input-wrapper,.tox .tox-number-input:focus:not(:active)>button{background:#f7f7f7}.tox .tox-tbtn--select{margin:6px 1px 5px 0;padding:0 4px;width:auto}.tox .tox-tbtn__select-label{cursor:default;font-weight:400;height:initial;margin:0 4px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tox .tox-tbtn__select-chevron{align-items:center;display:flex;justify-content:center;width:16px}.tox .tox-tbtn__select-chevron svg{fill:rgba(34,47,62,.5)}@media (forced-colors:active){.tox .tox-tbtn__select-chevron svg{fill:currentColor}}.tox .tox-tbtn--bespoke{background:#f7f7f7}.tox .tox-tbtn--bespoke:focus{background:#f7f7f7}.tox .tox-tbtn--bespoke+.tox-tbtn--bespoke{margin-inline-start:4px}.tox .tox-tbtn--bespoke .tox-tbtn__select-label{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:7em}.tox .tox-tbtn--disabled .tox-tbtn__select-label,.tox .tox-tbtn--select:disabled .tox-tbtn__select-label{cursor:not-allowed}.tox .tox-split-button{border:0;border-radius:3px;box-sizing:border-box;display:flex;margin:6px 1px 5px 0}.tox .tox-split-button:hover{box-shadow:0 0 0 1px #f0f0f0 inset}.tox .tox-split-button:focus{background:#fff;box-shadow:none;color:#222f3e;position:relative;z-index:1}.tox .tox-split-button:focus::after{pointer-events:none;border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-split-button:focus::after{border:2px solid highlight}}.tox .tox-split-button>*{border-radius:0}.tox .tox-split-button>:nth-child(1){border-bottom-left-radius:3px;border-top-left-radius:3px}.tox .tox-split-button>:nth-child(2){border-bottom-right-radius:3px;border-top-right-radius:3px}.tox .tox-split-button__chevron{width:16px}.tox .tox-split-button__chevron svg{fill:rgba(34,47,62,.5)}@media (forced-colors:active){.tox .tox-split-button__chevron svg{fill:currentColor}}.tox .tox-split-button .tox-tbtn{margin:0}.tox .tox-split-button:focus .tox-tbtn{background-color:transparent}.tox .tox-split-button.tox-tbtn--disabled .tox-tbtn:focus,.tox .tox-split-button.tox-tbtn--disabled .tox-tbtn:hover,.tox .tox-split-button.tox-tbtn--disabled:focus,.tox .tox-split-button.tox-tbtn--disabled:hover{background:#fff;box-shadow:none;color:rgba(34,47,62,.5)}.tox.tox-platform-touch .tox-split-button .tox-tbtn--select{padding:0 0}.tox.tox-platform-touch .tox-split-button .tox-tbtn:not(.tox-tbtn--select):first-child{width:30px}.tox.tox-platform-touch .tox-split-button__chevron{width:20px}.tox .tox-split-button.tox-tbtn--disabled svg #tox-icon-highlight-bg-color__color,.tox .tox-split-button.tox-tbtn--disabled svg #tox-icon-text-color__color{opacity:.6}.tox .tox-toolbar-overlord{background-color:#fff}.tox .tox-toolbar,.tox .tox-toolbar__overflow,.tox .tox-toolbar__primary{background-attachment:local;background-color:#fff;background-image:repeating-linear-gradient(#e3e3e3 0 1px,transparent 1px 39px);background-position:center top 40px;background-repeat:no-repeat;background-size:calc(100% - 11px * 2) calc(100% - 41px);display:flex;flex:0 0 auto;flex-shrink:0;flex-wrap:wrap;padding:0 0;transform:perspective(1px)}.tox .tox-toolbar-overlord>.tox-toolbar,.tox .tox-toolbar-overlord>.tox-toolbar__overflow,.tox .tox-toolbar-overlord>.tox-toolbar__primary{background-position:center top 0;background-size:calc(100% - 11px * 2) calc(100% - 0px)}.tox .tox-toolbar__overflow.tox-toolbar__overflow--closed{height:0;opacity:0;padding-bottom:0;padding-top:0;visibility:hidden}.tox .tox-toolbar__overflow--growing{transition:height .3s ease,opacity .2s linear .1s}.tox .tox-toolbar__overflow--shrinking{transition:opacity .3s ease,height .2s linear .1s,visibility 0s linear .3s}.tox .tox-anchorbar,.tox .tox-toolbar-overlord{grid-column:1/-1}.tox .tox-menubar+.tox-toolbar,.tox .tox-menubar+.tox-toolbar-overlord{border-top:1px solid transparent;margin-top:-1px;padding-bottom:1px;padding-top:1px}@media (forced-colors:active){.tox .tox-menubar+.tox-toolbar,.tox .tox-menubar+.tox-toolbar-overlord{outline:1px solid currentColor}}.tox .tox-toolbar--scrolling{flex-wrap:nowrap;overflow-x:auto}.tox .tox-pop .tox-toolbar{border-width:0}.tox .tox-toolbar--no-divider{background-image:none}.tox .tox-toolbar-overlord .tox-toolbar:not(.tox-toolbar--scrolling):first-child,.tox .tox-toolbar-overlord .tox-toolbar__primary{background-position:center top 39px}.tox .tox-editor-header>.tox-toolbar--scrolling,.tox .tox-toolbar-overlord .tox-toolbar--scrolling:first-child{background-image:none}.tox.tox-tinymce-aux .tox-toolbar__overflow{background-color:#fff;background-position:center top 43px;background-size:calc(100% - 8px * 2) calc(100% - 51px);border:none;border-radius:6px;box-shadow:0 0 2px 0 rgba(34,47,62,.2),0 4px 8px 0 rgba(34,47,62,.15);overscroll-behavior:none;padding:4px 0}@media (forced-colors:active){.tox.tox-tinymce-aux .tox-toolbar__overflow{border:solid}}.tox-pop .tox-pop__dialog .tox-toolbar{background-position:center top 43px;background-size:calc(100% - 11px * 2) calc(100% - 51px);padding:4px 0}.tox .tox-toolbar__group{align-items:center;display:flex;flex-wrap:wrap;margin:0 0;padding:0 11px 0 12px}.tox .tox-toolbar__group--pull-right{margin-left:auto}.tox .tox-toolbar--scrolling .tox-toolbar__group{flex-shrink:0;flex-wrap:nowrap}.tox:not([dir=rtl]) .tox-toolbar__group:not(:last-of-type){border-right:1px solid transparent}.tox[dir=rtl] .tox-toolbar__group:not(:last-of-type){border-left:1px solid transparent}.tox .tox-tooltip{display:inline-block;max-width:15em;padding:8px;pointer-events:none;position:relative;width:-moz-max-content;width:max-content;z-index:1150}.tox .tox-tooltip__body{background-color:#222f3e;border-radius:6px;box-shadow:none;color:#fff;font-size:12px;font-style:normal;font-weight:600;overflow-wrap:break-word;padding:4px 6px;text-transform:none}@media (forced-colors:active){.tox .tox-tooltip__body{outline:outset 1px}}.tox .tox-tooltip__arrow{position:absolute}.tox .tox-tooltip--down .tox-tooltip__arrow{border-left:8px solid transparent;border-right:8px solid transparent;border-top:8px solid #222f3e;bottom:0;left:50%;position:absolute;transform:translateX(-50%)}.tox .tox-tooltip--up .tox-tooltip__arrow{border-bottom:8px solid #222f3e;border-left:8px solid transparent;border-right:8px solid transparent;left:50%;position:absolute;top:0;transform:translateX(-50%)}.tox .tox-tooltip--right .tox-tooltip__arrow{border-bottom:8px solid transparent;border-left:8px solid #222f3e;border-top:8px solid transparent;position:absolute;right:0;top:50%;transform:translateY(-50%)}.tox .tox-tooltip--left .tox-tooltip__arrow{border-bottom:8px solid transparent;border-right:8px solid #222f3e;border-top:8px solid transparent;left:0;position:absolute;top:50%;transform:translateY(-50%)}.tox .tox-tree{display:flex;flex-direction:column}.tox .tox-tree .tox-trbtn{align-items:center;background:0 0;border:0;border-radius:4px;box-shadow:none;color:#222f3e;display:flex;flex:0 0 auto;font-size:14px;font-style:normal;font-weight:400;height:28px;margin-bottom:4px;margin-top:4px;outline:0;overflow:hidden;padding:0;padding-left:8px;text-transform:none}.tox .tox-tree .tox-trbtn .tox-tree__label{cursor:default;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tox .tox-tree .tox-trbtn svg{display:block;fill:#222f3e}.tox .tox-tree .tox-trbtn:focus{background:#f0f0f0;border:0;box-shadow:none}.tox .tox-tree .tox-trbtn:hover{background:#f0f0f0;border:0;box-shadow:none;color:#222f3e}.tox .tox-tree .tox-trbtn:hover svg{fill:#222f3e}.tox .tox-tree .tox-trbtn:active{background:#a6ccf7;border:0;box-shadow:none;color:#222f3e}.tox .tox-tree .tox-trbtn:active svg{fill:#222f3e}.tox .tox-tree .tox-trbtn--disabled,.tox .tox-tree .tox-trbtn--disabled:hover,.tox .tox-tree .tox-trbtn:disabled,.tox .tox-tree .tox-trbtn:disabled:hover{background:0 0;border:0;box-shadow:none;color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-tree .tox-trbtn--disabled svg,.tox .tox-tree .tox-trbtn--disabled:hover svg,.tox .tox-tree .tox-trbtn:disabled svg,.tox .tox-tree .tox-trbtn:disabled:hover svg{fill:rgba(34,47,62,.5)}.tox .tox-tree .tox-trbtn--enabled,.tox .tox-tree .tox-trbtn--enabled:hover{background:#a6ccf7;border:0;box-shadow:none;color:#222f3e}.tox .tox-tree .tox-trbtn--enabled:hover>*,.tox .tox-tree .tox-trbtn--enabled>*{transform:none}.tox .tox-tree .tox-trbtn--enabled svg,.tox .tox-tree .tox-trbtn--enabled:hover svg{fill:#222f3e}.tox .tox-tree .tox-trbtn:focus:not(.tox-trbtn--disabled){color:#222f3e}.tox .tox-tree .tox-trbtn:focus:not(.tox-trbtn--disabled) svg{fill:#222f3e}.tox .tox-tree .tox-trbtn:active>*{transform:none}.tox .tox-tree .tox-trbtn--return{align-self:stretch;height:unset;width:16px}.tox .tox-tree .tox-trbtn--labeled{padding:0 4px;width:unset}.tox .tox-tree .tox-trbtn__vlabel{display:block;font-size:10px;font-weight:400;letter-spacing:-.025em;margin-bottom:4px;white-space:nowrap}.tox .tox-tree .tox-tree--directory{display:flex;flex-direction:column}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label{font-weight:700}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label .tox-mbtn{margin-left:auto}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label .tox-mbtn svg{fill:transparent}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label .tox-mbtn.tox-mbtn--active svg,.tox .tox-tree .tox-tree--directory .tox-tree--directory__label .tox-mbtn:focus svg{fill:#222f3e}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:focus .tox-mbtn svg,.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:hover .tox-mbtn svg{fill:#222f3e}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:hover:has(.tox-mbtn:hover){background-color:transparent;color:#222f3e}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:hover:has(.tox-mbtn:hover) .tox-chevron svg{fill:#222f3e}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label .tox-chevron{margin-right:6px}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:has(+.tox-tree--directory__children--growing) .tox-chevron,.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:has(+.tox-tree--directory__children--shrinking) .tox-chevron{transition:transform .5s ease-in-out}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:has(+.tox-tree--directory__children--growing) .tox-chevron,.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:has(+.tox-tree--directory__children--open) .tox-chevron{transform:rotate(90deg)}.tox .tox-tree .tox-tree--leaf__label{font-weight:400}.tox .tox-tree .tox-tree--leaf__label .tox-mbtn{margin-left:auto}.tox .tox-tree .tox-tree--leaf__label .tox-mbtn svg{fill:transparent}.tox .tox-tree .tox-tree--leaf__label .tox-mbtn.tox-mbtn--active svg,.tox .tox-tree .tox-tree--leaf__label .tox-mbtn:focus svg{fill:#222f3e}.tox .tox-tree .tox-tree--leaf__label:hover .tox-mbtn svg{fill:#222f3e}.tox .tox-tree .tox-tree--leaf__label:hover:has(.tox-mbtn:hover){background-color:transparent;color:#222f3e}.tox .tox-tree .tox-tree--leaf__label:hover:has(.tox-mbtn:hover) .tox-chevron svg{fill:#222f3e}.tox .tox-tree .tox-tree--directory__children{overflow:hidden;padding-left:16px}.tox .tox-tree .tox-tree--directory__children.tox-tree--directory__children--growing,.tox .tox-tree .tox-tree--directory__children.tox-tree--directory__children--shrinking{transition:height .5s ease-in-out}.tox .tox-tree .tox-trbtn.tox-tree--leaf__label{display:flex;justify-content:space-between}.tox .tox-revisionhistory__pane{padding:0!important}.tox .tox-revisionhistory__container{display:flex;flex-direction:column;height:100%}.tox .tox-revisionhistory{background-color:#fff;border-radius:4px;border-top:1px solid #eee;display:flex;flex:1;height:100%;margin-top:8px;overflow-x:auto;overflow-y:hidden;position:relative;width:100%}.tox .tox-revisionhistory--align-right{margin-left:auto}.tox .tox-revisionhistory__iframe{flex:1}.tox .tox-revisionhistory__sidebar{border-left:1px solid #eee;height:100%;max-width:360px}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__sidebar-title{border-bottom:1px solid #eee;color:#222f3e;font-size:20px;font-weight:400;height:60px;min-width:192px;padding:16px}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions{flex-direction:column;max-height:calc(100% - 60px);min-width:192px;overflow-y:auto;padding:8px}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions:focus{height:100%;position:relative;z-index:1}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions:focus::after{border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0;border-radius:6px;bottom:1px;left:1px;right:1px;top:1px}@media (forced-colors:active){.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions:focus::after{border:2px solid highlight}}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions .tox-revisionhistory__card{border:1px solid #eee;border-radius:6px;color:#222f3e;cursor:pointer;font-size:14px;margin-bottom:8px;padding:8px;text-overflow:ellipsis;text-wrap:nowrap;width:100%}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions .tox-revisionhistory__card:hover{background-color:#f0f0f0;box-shadow:none;color:#222f3e}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions .tox-revisionhistory__card:focus{position:relative;z-index:1}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions .tox-revisionhistory__card:focus::after{border-radius:6px!important;border-radius:3px;bottom:0;box-shadow:0 0 0 2px #006ce7;content:'';left:0;position:absolute;right:0;top:0}@media (forced-colors:active){.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions .tox-revisionhistory__card:focus::after{border:2px solid highlight}}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions .tox-revisionhistory__card.tox-revisionhistory__card--selected{background-color:#a6ccf7;box-shadow:none;color:#222f3e}.tox .tox-revisionhistory__sidebar .tox-revisionhistory__revisions .tox-revisionhistory__norevision{color:rgba(34,47,62,.7);font-size:16px;line-height:24px;padding:5px 5.5px}.tox .tox-view-wrap,.tox .tox-view-wrap__slot-container{background-color:#fff;display:flex;flex:1;flex-direction:column;height:100%}.tox .tox-view{display:flex;flex:1 1 auto;flex-direction:column;overflow:hidden}.tox .tox-view__header{align-items:center;display:flex;font-size:16px;justify-content:space-between;padding:10px 10px 2px 10px;position:relative}.tox .tox-view__label{color:#222f3e;font-weight:700;line-height:24px;padding:4px 16px;text-align:center;white-space:nowrap}.tox .tox-view__label--normal{font-size:16px}.tox .tox-view__label--large{font-size:20px}.tox .tox-view--mobile.tox-view__header,.tox .tox-view--mobile.tox-view__toolbar{padding:8px}.tox .tox-view--scrolling{flex-wrap:nowrap;overflow-x:auto}.tox .tox-view__toolbar{display:flex;flex-direction:row;gap:8px;justify-content:space-between;overflow-x:auto;padding:10px 10px 2px 10px}.tox .tox-view__toolbar__group{display:flex;flex-direction:row;gap:12px}.tox .tox-view__header-end,.tox .tox-view__header-start{display:flex}.tox .tox-view__pane{height:100%;padding:8px;position:relative;width:100%}.tox .tox-view__pane_panel{border:1px solid #eee;border-radius:6px}.tox:not([dir=rtl]) .tox-view__header .tox-view__header-end>*,.tox:not([dir=rtl]) .tox-view__header .tox-view__header-start>*{margin-left:8px}.tox[dir=rtl] .tox-view__header .tox-view__header-end>*,.tox[dir=rtl] .tox-view__header .tox-view__header-start>*{margin-right:8px}.tox .tox-well{border:1px solid #eee;border-radius:6px;padding:8px;width:100%}.tox .tox-well>:first-child{margin-top:0}.tox .tox-well>:last-child{margin-bottom:0}.tox .tox-well>:only-child{margin:0}.tox .tox-custom-editor{border:1px solid #eee;border-radius:6px;display:flex;flex:1;overflow:hidden;position:relative}.tox .tox-dialog-loading::before{background-color:rgba(0,0,0,.5);content:"";height:100%;position:absolute;width:100%;z-index:1000}.tox .tox-tab{cursor:pointer}.tox .tox-dialog__content-js{display:flex;flex:1}.tox .tox-dialog__body-content .tox-collection{display:flex;flex:1}`);
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const r = (wt, qe, B) => {
    const mn = qe === "UL" ? "InsertUnorderedList" : "InsertOrderedList";
    wt.execCommand(mn, !1, B === !1 ? null : { "list-style-type": B });
  }, i = (wt) => {
    wt.addCommand("ApplyUnorderedListStyle", (qe, B) => {
      r(wt, "UL", B["list-style-type"]);
    }), wt.addCommand("ApplyOrderedListStyle", (qe, B) => {
      r(wt, "OL", B["list-style-type"]);
    });
  }, u = (wt) => (qe) => qe.options.get(wt), h = (wt) => {
    const qe = wt.options.register;
    qe("advlist_number_styles", {
      processor: "string[]",
      default: "default,lower-alpha,lower-greek,lower-roman,upper-alpha,upper-roman".split(",")
    }), qe("advlist_bullet_styles", {
      processor: "string[]",
      default: "default,circle,square".split(",")
    });
  }, y = u("advlist_number_styles"), k = u("advlist_bullet_styles"), _ = (wt) => wt == null, D = (wt) => !_(wt);
  var L = tinymce.util.Tools.resolve("tinymce.util.Tools");
  class W {
    constructor(qe, B) {
      this.tag = qe, this.value = B;
    }
    static some(qe) {
      return new W(!0, qe);
    }
    static none() {
      return W.singletonNone;
    }
    fold(qe, B) {
      return this.tag ? B(this.value) : qe();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(qe) {
      return this.tag ? W.some(qe(this.value)) : W.none();
    }
    bind(qe) {
      return this.tag ? qe(this.value) : W.none();
    }
    exists(qe) {
      return this.tag && qe(this.value);
    }
    forall(qe) {
      return !this.tag || qe(this.value);
    }
    filter(qe) {
      return !this.tag || qe(this.value) ? this : W.none();
    }
    getOr(qe) {
      return this.tag ? this.value : qe;
    }
    or(qe) {
      return this.tag ? this : qe;
    }
    getOrThunk(qe) {
      return this.tag ? this.value : qe();
    }
    orThunk(qe) {
      return this.tag ? this : qe();
    }
    getOrDie(qe) {
      if (this.tag)
        return this.value;
      throw new Error(qe ?? "Called getOrDie on None");
    }
    static from(qe) {
      return D(qe) ? W.some(qe) : W.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(qe) {
      this.tag && qe(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  W.singletonNone = new W(!1);
  const se = (wt, qe, B) => {
    for (let mn = 0, dt = wt.length; mn < dt; mn++) {
      const En = wt[mn];
      if (qe(En, mn))
        return W.some(En);
      if (B(En, mn))
        break;
    }
    return W.none();
  }, J = (wt) => /\btox\-/.test(wt.className), be = (wt, qe) => wt.dom.isChildOf(qe, wt.getBody()), ke = (wt) => (qe) => D(qe) && wt.test(qe.nodeName), Ce = ke(/^(OL|UL|DL)$/), Q = ke(/^(TH|TD)$/), oe = (wt, qe, B) => se(qe, (mn) => Ce(mn) && !J(mn), Q).exists((mn) => mn.nodeName === B && be(wt, mn)), ae = (wt) => {
    const qe = wt.dom.getParent(wt.selection.getNode(), "ol,ul"), B = wt.dom.getStyle(qe, "listStyleType");
    return W.from(B);
  }, G = (wt, qe) => qe !== null && !wt.dom.isEditable(qe), ve = (wt, qe) => {
    const B = wt.dom.getParent(qe, "ol,ul,dl");
    return G(wt, B) && wt.selection.isEditable();
  }, nt = (wt, qe) => {
    const B = wt.selection.getNode();
    return qe({
      parents: wt.dom.getParents(B),
      element: B
    }), wt.on("NodeChange", qe), () => wt.off("NodeChange", qe);
  }, Xe = (wt) => wt.replace(/\-/g, " ").replace(/\b\w/g, (qe) => qe.toUpperCase()), te = (wt) => _(wt) || wt === "default" ? "" : wt, lt = (wt, qe) => (B) => {
    const mn = (En, tn) => {
      const Le = En.selection.getStart(!0);
      B.setActive(oe(En, tn, qe)), B.setEnabled(!ve(En, Le) && En.selection.isEditable());
    };
    return nt(wt, (En) => mn(wt, En.parents));
  }, ot = (wt, qe, B, mn, dt, En) => {
    wt.ui.registry.addSplitButton(qe, {
      tooltip: B,
      icon: dt === "OL" ? "ordered-list" : "unordered-list",
      presets: "listpreview",
      columns: 3,
      fetch: (tn) => {
        const Le = L.map(En, (jt) => {
          const Fn = dt === "OL" ? "num" : "bull", St = jt === "disc" || jt === "decimal" ? "default" : jt, on = te(jt), tt = Xe(jt);
          return {
            type: "choiceitem",
            value: on,
            icon: "list-" + Fn + "-" + St,
            text: tt
          };
        });
        tn(Le);
      },
      onAction: () => wt.execCommand(mn),
      onItemAction: (tn, Le) => {
        r(wt, dt, Le);
      },
      select: (tn) => ae(wt).map((jt) => tn === jt).getOr(!1),
      onSetup: lt(wt, dt)
    });
  }, Kt = (wt, qe, B, mn, dt, En) => {
    wt.ui.registry.addToggleButton(qe, {
      active: !1,
      tooltip: B,
      icon: dt === "OL" ? "ordered-list" : "unordered-list",
      onSetup: lt(wt, dt),
      onAction: () => wt.queryCommandState(mn) || En === "" ? wt.execCommand(mn) : r(wt, dt, En)
    });
  }, je = (wt, qe, B, mn, dt, En) => {
    En.length > 1 ? ot(wt, qe, B, mn, dt, En) : Kt(wt, qe, B, mn, dt, te(En[0]));
  }, ye = (wt) => {
    je(wt, "numlist", "Numbered list", "InsertOrderedList", "OL", y(wt)), je(wt, "bullist", "Bullet list", "InsertUnorderedList", "UL", k(wt));
  };
  var dn = () => {
    o.add("advlist", (wt) => {
      wt.hasPlugin("lists") ? (h(wt), ye(wt), i(wt)) : console.error("Please use the Lists plugin together with the List Styles plugin.");
    });
  };
  dn();
})();
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const r = () => /(?:[A-Za-z][A-Za-z\d.+-]{0,14}:\/\/(?:[-.~*+=!&;:'%@?^${}(),\w]+@)?|www\.|[-;:&=+$,.\w]+@)[A-Za-z\d-]+(?:\.[A-Za-z\d-]+)*(?::\d+)?(?:\/(?:[-.~*+=!;:'%@$(),\/\w]*[-~*+=%@$()\/\w])?)?(?:\?(?:[-.~*+=!&;:'%@?^${}(),\/\w]+))?(?:#(?:[-.~*+=!&;:'%@?^${}(),\/\w]+))?/g, i = (St) => (on) => on.options.get(St), u = (St) => {
    const on = St.options.register;
    on("autolink_pattern", {
      processor: "regexp",
      default: new RegExp("^" + r().source + "$", "i")
    }), on("link_default_target", { processor: "string" }), on("link_default_protocol", {
      processor: "string",
      default: "https"
    });
  }, h = i("autolink_pattern"), y = i("link_default_target"), k = i("link_default_protocol"), _ = i("allow_unsafe_link_target"), D = (St, on, tt) => {
    var mt;
    return tt(St, on.prototype) ? !0 : ((mt = St.constructor) === null || mt === void 0 ? void 0 : mt.name) === on.name;
  }, L = (St) => {
    const on = typeof St;
    return St === null ? "null" : on === "object" && Array.isArray(St) ? "array" : on === "object" && D(St, String, (tt, mt) => mt.isPrototypeOf(tt)) ? "string" : on;
  }, W = (St) => (on) => L(on) === St, se = (St) => (on) => St === on, J = W("string"), be = se(void 0), ke = (St) => St == null, Ce = (St) => !ke(St), Q = (St) => (on) => !St(on), oe = Object.hasOwnProperty, ae = (St, on) => oe.call(St, on), G = (St, on, tt) => St.length >= on.length && St.substr(tt, tt + on.length) === on, ve = (St, on, tt = 0, mt) => {
    const Y = St.indexOf(on, tt);
    return Y !== -1 ? be(mt) ? !0 : Y + on.length <= mt : !1;
  }, nt = (St, on) => G(St, on, 0), Xe = "\uFEFF", te = (St) => St === Xe, lt = (St) => St.replace(/\uFEFF/g, "");
  var ot = tinymce.util.Tools.resolve("tinymce.dom.TextSeeker");
  const Kt = (St) => St.nodeType === 3, je = (St) => St.nodeType === 1, ye = (St) => /^[(\[{ \u00a0]$/.test(St), dn = (St) => /^([A-Za-z][A-Za-z\d.+-]*:\/\/)|mailto:/.test(St), wt = (St) => /[?!,.;:]/.test(St), qe = (St, on, tt) => {
    for (let mt = on - 1; mt >= 0; mt--) {
      const Y = St.charAt(mt);
      if (!te(Y) && tt(Y))
        return mt;
    }
    return -1;
  }, B = (St, on) => {
    let tt = St, mt = on;
    for (; je(tt) && tt.childNodes[mt]; )
      tt = tt.childNodes[mt], mt = Kt(tt) ? tt.data.length : tt.childNodes.length;
    return {
      container: tt,
      offset: mt
    };
  }, mn = (St, on) => {
    var tt;
    const mt = St.schema.getVoidElements(), Y = h(St), { dom: Wo, selection: To } = St;
    if (Wo.getParent(To.getNode(), "a[href]") !== null)
      return null;
    const Ot = To.getRng(), Mt = ot(Wo, (Ct) => Wo.isBlock(Ct) || ae(mt, Ct.nodeName.toLowerCase()) || Wo.getContentEditable(Ct) === "false"), {
      container: zn,
      offset: At
    } = B(Ot.endContainer, Ot.endOffset), $n = (tt = Wo.getParent(zn, Wo.isBlock)) !== null && tt !== void 0 ? tt : Wo.getRoot(), en = Mt.backwards(zn, At + on, (Ct, Jn) => {
      const Pn = Ct.data, so = qe(Pn, Jn, Q(ye));
      return so === -1 || wt(Pn[so]) ? so : so + 1;
    }, $n);
    if (!en)
      return null;
    let Ue = en.container;
    const jn = Mt.backwards(en.container, en.offset, (Ct, Jn) => {
      Ue = Ct;
      const Pn = qe(Ct.data, Jn, ye);
      return Pn === -1 ? Pn : Pn + 1;
    }, $n), mo = Wo.createRng();
    jn ? mo.setStart(jn.container, jn.offset) : mo.setStart(Ue, 0), mo.setEnd(en.container, en.offset);
    const Vt = lt(mo.toString()).match(Y);
    if (Vt) {
      let Ct = Vt[0];
      return nt(Ct, "www.") ? Ct = k(St) + "://" + Ct : ve(Ct, "@") && !dn(Ct) && (Ct = "mailto:" + Ct), {
        rng: mo,
        url: Ct
      };
    } else
      return null;
  }, dt = (St, on) => {
    const { dom: tt, selection: mt } = St, { rng: Y, url: Wo } = on, To = mt.getBookmark();
    mt.setRng(Y);
    const Ot = "createlink", Mt = {
      command: Ot,
      ui: !1,
      value: Wo
    };
    if (!St.dispatch("BeforeExecCommand", Mt).isDefaultPrevented()) {
      St.getDoc().execCommand(Ot, !1, Wo), St.dispatch("ExecCommand", Mt);
      const At = y(St);
      if (J(At)) {
        const $n = mt.getNode();
        tt.setAttrib($n, "target", At), At === "_blank" && !_(St) && tt.setAttrib($n, "rel", "noopener");
      }
    }
    mt.moveToBookmark(To), St.nodeChanged();
  }, En = (St) => {
    const on = mn(St, -1);
    Ce(on) && dt(St, on);
  }, tn = En, Le = (St) => {
    const on = mn(St, 0);
    Ce(on) && dt(St, on);
  }, jt = (St) => {
    St.on("keydown", (on) => {
      on.keyCode === 13 && !on.isDefaultPrevented() && Le(St);
    }), St.on("keyup", (on) => {
      on.keyCode === 32 ? En(St) : (on.keyCode === 48 && on.shiftKey || on.keyCode === 221) && tn(St);
    });
  };
  var Fn = () => {
    o.add("autolink", (St) => {
      u(St), jt(St);
    });
  };
  Fn();
})();
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const r = (_, D) => {
    _.focus(), _.undoManager.transact(() => {
      _.setContent(D);
    }), _.selection.setCursorLocation(), _.nodeChanged();
  }, i = (_) => _.getContent({ source_view: !0 }), u = (_) => {
    const D = i(_);
    _.windowManager.open({
      title: "Source Code",
      size: "large",
      body: {
        type: "panel",
        items: [{
          type: "textarea",
          name: "code"
        }]
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: { code: D },
      onSubmit: (L) => {
        r(_, L.getData().code), L.close();
      }
    });
  }, h = (_) => {
    _.addCommand("mceCodeEditor", () => {
      u(_);
    });
  }, y = (_) => {
    const D = () => _.execCommand("mceCodeEditor");
    _.ui.registry.addButton("code", {
      icon: "sourcecode",
      tooltip: "Source code",
      onAction: D
    }), _.ui.registry.addMenuItem("code", {
      icon: "sourcecode",
      text: "Source code",
      onAction: D
    });
  };
  var k = () => {
    o.add("code", (_) => (h(_), y(_), {}));
  };
  k();
})();
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const r = (at, kt, yn) => {
    var pn;
    return yn(at, kt.prototype) ? !0 : ((pn = at.constructor) === null || pn === void 0 ? void 0 : pn.name) === kt.name;
  }, i = (at) => {
    const kt = typeof at;
    return at === null ? "null" : kt === "object" && Array.isArray(at) ? "array" : kt === "object" && r(at, String, (yn, pn) => pn.isPrototypeOf(yn)) ? "string" : kt;
  }, u = (at) => (kt) => i(kt) === at, h = (at) => (kt) => typeof kt === at, y = u("string"), k = h("boolean"), _ = (at) => at == null, D = (at) => !_(at), L = h("function"), W = h("number"), se = (at, kt) => (yn) => at(kt(yn)), be = ((at) => () => at)(!1);
  class ke {
    constructor(kt, yn) {
      this.tag = kt, this.value = yn;
    }
    static some(kt) {
      return new ke(!0, kt);
    }
    static none() {
      return ke.singletonNone;
    }
    fold(kt, yn) {
      return this.tag ? yn(this.value) : kt();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(kt) {
      return this.tag ? ke.some(kt(this.value)) : ke.none();
    }
    bind(kt) {
      return this.tag ? kt(this.value) : ke.none();
    }
    exists(kt) {
      return this.tag && kt(this.value);
    }
    forall(kt) {
      return !this.tag || kt(this.value);
    }
    filter(kt) {
      return !this.tag || kt(this.value) ? this : ke.none();
    }
    getOr(kt) {
      return this.tag ? this.value : kt;
    }
    or(kt) {
      return this.tag ? this : kt;
    }
    getOrThunk(kt) {
      return this.tag ? this.value : kt();
    }
    orThunk(kt) {
      return this.tag ? this : kt();
    }
    getOrDie(kt) {
      if (this.tag)
        return this.value;
      throw new Error(kt ?? "Called getOrDie on None");
    }
    static from(kt) {
      return D(kt) ? ke.some(kt) : ke.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(kt) {
      this.tag && kt(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  ke.singletonNone = new ke(!1);
  const Ce = (at, kt) => {
    const yn = at.length, pn = new Array(yn);
    for (let Oo = 0; Oo < yn; Oo++) {
      const hr = at[Oo];
      pn[Oo] = kt(hr, Oo);
    }
    return pn;
  }, Q = (at, kt) => {
    for (let yn = 0, pn = at.length; yn < pn; yn++) {
      const Oo = at[yn];
      kt(Oo, yn);
    }
  }, oe = (at, kt) => {
    const yn = [];
    for (let pn = 0, Oo = at.length; pn < Oo; pn++) {
      const hr = at[pn];
      kt(hr, pn) && yn.push(hr);
    }
    return yn;
  }, ae = 9, G = 11, ve = 1, nt = 3, Xe = (at, kt) => {
    const pn = (kt || document).createElement("div");
    if (pn.innerHTML = at, !pn.hasChildNodes() || pn.childNodes.length > 1) {
      const Oo = "HTML does not have a single root node";
      throw console.error(Oo, at), new Error(Oo);
    }
    return ot(pn.childNodes[0]);
  }, te = (at, kt) => {
    const pn = (kt || document).createElement(at);
    return ot(pn);
  }, lt = (at, kt) => {
    const pn = (kt || document).createTextNode(at);
    return ot(pn);
  }, ot = (at) => {
    if (at == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: at };
  }, je = {
    fromHtml: Xe,
    fromTag: te,
    fromText: lt,
    fromDom: ot,
    fromPoint: (at, kt, yn) => ke.from(at.dom.elementFromPoint(kt, yn)).map(ot)
  }, ye = (at, kt) => {
    const yn = at.dom;
    if (yn.nodeType !== ve)
      return !1;
    {
      const pn = yn;
      if (pn.matches !== void 0)
        return pn.matches(kt);
      if (pn.msMatchesSelector !== void 0)
        return pn.msMatchesSelector(kt);
      if (pn.webkitMatchesSelector !== void 0)
        return pn.webkitMatchesSelector(kt);
      if (pn.mozMatchesSelector !== void 0)
        return pn.mozMatchesSelector(kt);
      throw new Error("Browser lacks native selectors");
    }
  };
  typeof window < "u" || Function("return this;")();
  const dn = (at) => at.dom.nodeName.toLowerCase(), wt = (at) => at.dom.nodeType, qe = (at) => (kt) => wt(kt) === at, B = qe(ve), mn = qe(nt), dt = qe(ae), En = qe(G), tn = (at) => (kt) => B(kt) && dn(kt) === at, Le = (at) => je.fromDom(at.dom.ownerDocument), jt = (at) => dt(at) ? at : Le(at), Fn = (at) => ke.from(at.dom.parentNode).map(je.fromDom), St = (at) => Ce(at.dom.childNodes, je.fromDom), on = (at, kt, yn) => {
    if (y(yn) || k(yn) || W(yn))
      at.setAttribute(kt, yn + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", kt, ":: Value ", yn, ":: Element ", at), new Error("Attribute value was not simple");
  }, tt = (at, kt, yn) => {
    on(at.dom, kt, yn);
  }, mt = (at, kt) => {
    at.dom.removeAttribute(kt);
  }, Y = (at) => En(at) && D(at.dom.host), To = L(Element.prototype.attachShadow) && L(Node.prototype.getRootNode) ? (at) => je.fromDom(at.dom.getRootNode()) : jt, Ot = (at) => {
    const kt = To(at);
    return Y(kt) ? ke.some(kt) : ke.none();
  }, Mt = (at) => je.fromDom(at.dom.host), zn = (at) => {
    const kt = mn(at) ? at.dom.parentNode : at.dom;
    if (kt == null || kt.ownerDocument === null)
      return !1;
    const yn = kt.ownerDocument;
    return Ot(je.fromDom(kt)).fold(() => yn.body.contains(kt), se(zn, Mt));
  }, At = (at, kt, yn) => {
    let pn = at.dom;
    const Oo = L(yn) ? yn : be;
    for (; pn.parentNode; ) {
      pn = pn.parentNode;
      const hr = je.fromDom(pn);
      if (kt(hr))
        return ke.some(hr);
      if (Oo(hr))
        break;
    }
    return ke.none();
  }, $n = (at, kt, yn) => At(at, (pn) => ye(pn, kt), yn), en = (at) => at.style !== void 0 && L(at.style.getPropertyValue), Ue = (at, kt) => {
    const yn = at.dom, Oo = window.getComputedStyle(yn).getPropertyValue(kt);
    return Oo === "" && !zn(at) ? jn(yn, kt) : Oo;
  }, jn = (at, kt) => en(at) ? at.style.getPropertyValue(kt) : "", mo = (at) => Ue(at, "direction") === "rtl" ? "rtl" : "ltr", xn = (at, kt) => oe(St(at), kt), Vt = (at, kt) => xn(at, (yn) => ye(yn, kt)), Ct = (at) => Fn(at).filter(B), Jn = (at, kt) => (kt ? $n(at, "ol,ul") : ke.some(at)).getOr(at), Pn = tn("li"), so = (at, kt, yn) => {
    Q(kt, (pn) => {
      const Oo = je.fromDom(pn), hr = Pn(Oo), or = Jn(Oo, hr);
      Ct(or).each((Zo) => {
        if (at.setStyle(or.dom, "direction", null), mo(Zo) === yn ? mt(or, "dir") : tt(or, "dir", yn), mo(or) !== yn && at.setStyle(or.dom, "direction", yn), hr) {
          const Ht = Vt(or, "li[dir],li[style]");
          Q(Ht, (Ho) => {
            mt(Ho, "dir"), at.setStyle(Ho.dom, "direction", null);
          });
        }
      });
    });
  }, pr = (at, kt) => {
    at.selection.isEditable() && (so(at.dom, at.selection.getSelectedBlocks(), kt), at.nodeChanged());
  }, nr = (at) => {
    at.addCommand("mceDirectionLTR", () => {
      pr(at, "ltr");
    }), at.addCommand("mceDirectionRTL", () => {
      pr(at, "rtl");
    });
  }, Ko = (at, kt) => (yn) => {
    const pn = (Oo) => {
      const hr = je.fromDom(Oo.element);
      yn.setActive(mo(hr) === kt), yn.setEnabled(at.selection.isEditable());
    };
    return at.on("NodeChange", pn), yn.setEnabled(at.selection.isEditable()), () => at.off("NodeChange", pn);
  }, Qo = (at) => {
    at.ui.registry.addToggleButton("ltr", {
      tooltip: "Left to right",
      icon: "ltr",
      onAction: () => at.execCommand("mceDirectionLTR"),
      onSetup: Ko(at, "ltr")
    }), at.ui.registry.addToggleButton("rtl", {
      tooltip: "Right to left",
      icon: "rtl",
      onAction: () => at.execCommand("mceDirectionRTL"),
      onSetup: Ko(at, "rtl")
    });
  };
  var Mr = () => {
    o.add("directionality", (at) => {
      nr(at), Qo(at);
    });
  };
  Mr();
})();
(function() {
  const o = (pe) => {
    let Te = pe;
    return {
      get: () => Te,
      set: (to) => {
        Te = to;
      }
    };
  };
  var r = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const i = (pe) => ({ isFullscreen: () => pe.get() !== null }), u = (pe, Te, rt) => {
    var pt;
    return rt(pe, Te.prototype) ? !0 : ((pt = pe.constructor) === null || pt === void 0 ? void 0 : pt.name) === Te.name;
  }, h = (pe) => {
    const Te = typeof pe;
    return pe === null ? "null" : Te === "object" && Array.isArray(pe) ? "array" : Te === "object" && u(pe, String, (rt, pt) => pt.isPrototypeOf(rt)) ? "string" : Te;
  }, y = (pe) => (Te) => h(Te) === pe, k = (pe) => (Te) => typeof Te === pe, _ = (pe) => (Te) => pe === Te, D = y("string"), L = y("object"), W = y("array"), se = _(null), J = k("boolean"), be = _(void 0), ke = (pe) => pe == null, Ce = (pe) => !ke(pe), Q = k("function"), oe = k("number"), ae = () => {
  }, G = (pe, Te) => (...rt) => pe(Te.apply(null, rt)), ve = (pe, Te) => (rt) => pe(Te(rt)), nt = (pe) => () => pe;
  function Xe(pe, ...Te) {
    return (...rt) => {
      const pt = Te.concat(rt);
      return pe.apply(null, pt);
    };
  }
  const te = nt(!1), lt = nt(!0);
  class ot {
    constructor(Te, rt) {
      this.tag = Te, this.value = rt;
    }
    static some(Te) {
      return new ot(!0, Te);
    }
    static none() {
      return ot.singletonNone;
    }
    fold(Te, rt) {
      return this.tag ? rt(this.value) : Te();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(Te) {
      return this.tag ? ot.some(Te(this.value)) : ot.none();
    }
    bind(Te) {
      return this.tag ? Te(this.value) : ot.none();
    }
    exists(Te) {
      return this.tag && Te(this.value);
    }
    forall(Te) {
      return !this.tag || Te(this.value);
    }
    filter(Te) {
      return !this.tag || Te(this.value) ? this : ot.none();
    }
    getOr(Te) {
      return this.tag ? this.value : Te;
    }
    or(Te) {
      return this.tag ? this : Te;
    }
    getOrThunk(Te) {
      return this.tag ? this.value : Te();
    }
    orThunk(Te) {
      return this.tag ? this : Te();
    }
    getOrDie(Te) {
      if (this.tag)
        return this.value;
      throw new Error(Te ?? "Called getOrDie on None");
    }
    static from(Te) {
      return Ce(Te) ? ot.some(Te) : ot.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(Te) {
      this.tag && Te(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  ot.singletonNone = new ot(!1);
  const Kt = Array.prototype.push, je = (pe, Te) => {
    const rt = pe.length, pt = new Array(rt);
    for (let to = 0; to < rt; to++) {
      const sr = pe[to];
      pt[to] = Te(sr, to);
    }
    return pt;
  }, ye = (pe, Te) => {
    for (let rt = 0, pt = pe.length; rt < pt; rt++) {
      const to = pe[rt];
      Te(to, rt);
    }
  }, dn = (pe, Te) => {
    const rt = [];
    for (let pt = 0, to = pe.length; pt < to; pt++) {
      const sr = pe[pt];
      Te(sr, pt) && rt.push(sr);
    }
    return rt;
  }, wt = (pe, Te, rt) => {
    for (let pt = 0, to = pe.length; pt < to; pt++) {
      const sr = pe[pt];
      if (Te(sr, pt))
        return ot.some(sr);
      if (rt(sr, pt))
        break;
    }
    return ot.none();
  }, qe = (pe, Te) => wt(pe, Te, te), B = (pe) => {
    const Te = [];
    for (let rt = 0, pt = pe.length; rt < pt; ++rt) {
      if (!W(pe[rt]))
        throw new Error("Arr.flatten item " + rt + " was not an array, input: " + pe);
      Kt.apply(Te, pe[rt]);
    }
    return Te;
  }, mn = (pe, Te) => B(je(pe, Te)), dt = (pe, Te) => Te >= 0 && Te < pe.length ? ot.some(pe[Te]) : ot.none(), En = (pe) => dt(pe, 0), tn = (pe, Te) => {
    for (let rt = 0; rt < pe.length; rt++) {
      const pt = Te(pe[rt], rt);
      if (pt.isSome())
        return pt;
    }
    return ot.none();
  }, Le = (pe, Te, rt) => pe.isSome() && Te.isSome() ? ot.some(rt(pe.getOrDie(), Te.getOrDie())) : ot.none(), jt = (pe) => {
    const Te = o(ot.none()), rt = () => Te.get().each(pe);
    return {
      clear: () => {
        rt(), Te.set(ot.none());
      },
      isSet: () => Te.get().isSome(),
      get: () => Te.get(),
      set: (Ha) => {
        rt(), Te.set(ot.some(Ha));
      }
    };
  }, Fn = () => jt((pe) => pe.unbind()), St = () => {
    const pe = jt(ae);
    return {
      ...pe,
      on: (rt) => pe.get().each(rt)
    };
  }, on = (pe, Te) => {
    let rt = null;
    return {
      cancel: () => {
        se(rt) || (clearTimeout(rt), rt = null);
      },
      throttle: (...sr) => {
        se(rt) && (rt = setTimeout(() => {
          rt = null, pe.apply(null, sr);
        }, Te));
      }
    };
  }, tt = Object.keys, mt = (pe, Te) => {
    const rt = tt(pe);
    for (let pt = 0, to = rt.length; pt < to; pt++) {
      const sr = rt[pt], _s = pe[sr];
      Te(_s, sr);
    }
  }, Y = typeof window < "u" ? window : Function("return this;")(), Wo = (pe, Te) => {
    let rt = Te ?? Y;
    for (let pt = 0; pt < pe.length && rt !== void 0 && rt !== null; ++pt)
      rt = rt[pe[pt]];
    return rt;
  }, To = (pe, Te) => {
    const rt = pe.split(".");
    return Wo(rt, Te);
  }, Ot = (pe, Te) => To(pe, Te), Mt = (pe, Te) => {
    const rt = Ot(pe, Te);
    if (rt == null)
      throw new Error(pe + " not available on this browser");
    return rt;
  }, zn = Object.getPrototypeOf, At = (pe) => Mt("HTMLElement", pe), $n = (pe) => {
    const Te = To("ownerDocument.defaultView", pe);
    return L(pe) && (At(Te).prototype.isPrototypeOf(pe) || /^HTML\w*Element$/.test(zn(pe).constructor.name));
  }, en = 9, Ue = 11, jn = 1, mo = 3, xn = (pe) => pe.dom.nodeType, Vt = (pe) => (Te) => xn(Te) === pe, Ct = (pe) => Jn(pe) && $n(pe.dom), Jn = Vt(jn), Pn = Vt(mo), so = Vt(en), pr = Vt(Ue), nr = (pe, Te, rt) => {
    if (D(rt) || J(rt) || oe(rt))
      pe.setAttribute(Te, rt + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", Te, ":: Value ", rt, ":: Element ", pe), new Error("Attribute value was not simple");
  }, Ko = (pe, Te, rt) => {
    nr(pe.dom, Te, rt);
  }, Qo = (pe, Te) => {
    const rt = pe.dom.getAttribute(Te);
    return rt === null ? void 0 : rt;
  }, Mr = (pe, Te) => {
    pe.dom.removeAttribute(Te);
  }, at = (pe) => pe.dom.classList !== void 0, kt = (pe, Te) => at(pe) && pe.dom.classList.contains(Te), yn = (pe, Te, rt = 0, pt) => {
    const to = pe.indexOf(Te, rt);
    return to !== -1 ? be(pt) ? !0 : to + Te.length <= pt : !1;
  }, pn = (pe) => pe.style !== void 0 && Q(pe.style.getPropertyValue), Oo = (pe, Te) => {
    const pt = (Te || document).createElement("div");
    if (pt.innerHTML = pe, !pt.hasChildNodes() || pt.childNodes.length > 1) {
      const to = "HTML does not have a single root node";
      throw console.error(to, pe), new Error(to);
    }
    return Ir(pt.childNodes[0]);
  }, hr = (pe, Te) => {
    const pt = (Te || document).createElement(pe);
    return Ir(pt);
  }, or = (pe, Te) => {
    const pt = (Te || document).createTextNode(pe);
    return Ir(pt);
  }, Ir = (pe) => {
    if (pe == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: pe };
  }, Tr = {
    fromHtml: Oo,
    fromTag: hr,
    fromText: or,
    fromDom: Ir,
    fromPoint: (pe, Te, rt) => ot.from(pe.dom.elementFromPoint(Te, rt)).map(Ir)
  }, Ht = (pe, Te) => {
    const rt = pe.dom;
    if (rt.nodeType !== jn)
      return !1;
    {
      const pt = rt;
      if (pt.matches !== void 0)
        return pt.matches(Te);
      if (pt.msMatchesSelector !== void 0)
        return pt.msMatchesSelector(Te);
      if (pt.webkitMatchesSelector !== void 0)
        return pt.webkitMatchesSelector(Te);
      if (pt.mozMatchesSelector !== void 0)
        return pt.mozMatchesSelector(Te);
      throw new Error("Browser lacks native selectors");
    }
  }, Ho = (pe) => pe.nodeType !== jn && pe.nodeType !== en && pe.nodeType !== Ue || pe.childElementCount === 0, As = (pe, Te) => {
    const rt = document;
    return Ho(rt) ? [] : je(rt.querySelectorAll(pe), Tr.fromDom);
  }, ra = (pe, Te) => pe.dom === Te.dom, qs = (pe) => Tr.fromDom(pe.dom.ownerDocument), Ks = (pe) => so(pe) ? pe : qs(pe), kr = (pe) => ot.from(pe.dom.parentNode).map(Tr.fromDom), xa = (pe, Te) => {
    const rt = Q(Te) ? Te : te;
    let pt = pe.dom;
    const to = [];
    for (; pt.parentNode !== null && pt.parentNode !== void 0; ) {
      const sr = pt.parentNode, _s = Tr.fromDom(sr);
      if (to.push(_s), rt(_s) === !0)
        break;
      pt = sr;
    }
    return to;
  }, ca = (pe) => {
    const Te = (rt) => dn(rt, (pt) => !ra(pe, pt));
    return kr(pe).map(Xn).map(Te).getOr([]);
  }, Or = (pe) => ot.from(pe.dom.nextSibling).map(Tr.fromDom), Xn = (pe) => je(pe.dom.childNodes, Tr.fromDom), Ss = (pe) => pr(pe) && Ce(pe.dom.host), Ke = Q(Element.prototype.attachShadow) && Q(Node.prototype.getRootNode), bt = nt(Ke), gn = Ke ? (pe) => Tr.fromDom(pe.dom.getRootNode()) : Ks, Tn = (pe) => {
    const Te = gn(pe);
    return Ss(Te) ? ot.some(Te) : ot.none();
  }, Po = (pe) => Tr.fromDom(pe.dom.host), cr = (pe) => {
    if (bt() && Ce(pe.target)) {
      const Te = Tr.fromDom(pe.target);
      if (Jn(Te) && ea(Te) && pe.composed && pe.composedPath) {
        const rt = pe.composedPath();
        if (rt)
          return En(rt);
      }
    }
    return ot.from(pe.target);
  }, ea = (pe) => Ce(pe.dom.shadowRoot), ta = (pe) => {
    const Te = Pn(pe) ? pe.dom.parentNode : pe.dom;
    if (Te == null || Te.ownerDocument === null)
      return !1;
    const rt = Te.ownerDocument;
    return Tn(Tr.fromDom(Te)).fold(() => rt.body.contains(Te), ve(ta, Po));
  }, Ps = (pe) => {
    const Te = pe.dom.body;
    if (Te == null)
      throw new Error("Body is not available yet");
    return Tr.fromDom(Te);
  }, Re = (pe, Te, rt) => {
    if (!D(rt))
      throw console.error("Invalid call to CSS.set. Property ", Te, ":: Value ", rt, ":: Element ", pe), new Error("CSS value must be a string: " + rt);
    pn(pe) && pe.style.setProperty(Te, rt);
  }, Oe = (pe, Te, rt) => {
    const pt = pe.dom;
    Re(pt, Te, rt);
  }, ct = (pe, Te) => {
    const rt = pe.dom;
    mt(Te, (pt, to) => {
      Re(rt, to, pt);
    });
  }, _t = (pe, Te) => {
    const rt = pe.dom, to = window.getComputedStyle(rt).getPropertyValue(Te);
    return to === "" && !ta(pe) ? Kn(rt, Te) : to;
  }, Kn = (pe, Te) => pn(pe) ? pe.style.getPropertyValue(Te) : "", io = (pe, Te, rt, pt, to, sr, _s) => ({
    target: pe,
    x: Te,
    y: rt,
    stop: pt,
    prevent: to,
    kill: sr,
    raw: _s
  }), Bo = (pe) => {
    const Te = Tr.fromDom(cr(pe).getOr(pe.target)), rt = () => pe.stopPropagation(), pt = () => pe.preventDefault(), to = G(pt, rt);
    return io(Te, pe.clientX, pe.clientY, rt, pt, to, pe);
  }, Jr = (pe, Te) => (rt) => {
    pe(rt) && Te(Bo(rt));
  }, He = (pe, Te, rt, pt, to) => {
    const sr = Jr(rt, pt);
    return pe.dom.addEventListener(Te, sr, to), { unbind: Xe(Ne, pe, Te, sr, to) };
  }, Do = (pe, Te, rt, pt) => He(pe, Te, rt, pt, !1), Ne = (pe, Te, rt, pt) => {
    pe.dom.removeEventListener(Te, rt, pt);
  }, Ie = lt, Bt = (pe, Te, rt) => Do(pe, Te, Ie, rt), Wt = (pe) => {
    let Te = !1, rt;
    return (...pt) => (Te || (Te = !0, rt = pe.apply(null, pt)), rt);
  }, kn = (pe, Te, rt, pt) => {
    const to = pe.isiOS() && /ipad/i.test(rt) === !0, sr = pe.isiOS() && !to, _s = pe.isiOS() || pe.isAndroid(), Ha = _s || pt("(pointer:coarse)"), ur = to || !sr && _s && pt("(min-device-width:768px)"), _a = sr || _s && !ur, Ms = Te.isSafari() && pe.isiOS() && /safari/i.test(rt) === !1, da = !_a && !ur && !Ms;
    return {
      isiPad: nt(to),
      isiPhone: nt(sr),
      isTablet: nt(ur),
      isPhone: nt(_a),
      isTouch: nt(Ha),
      isAndroid: pe.isAndroid,
      isiOS: pe.isiOS,
      isWebView: nt(Ms),
      isDesktop: nt(da)
    };
  }, eo = (pe, Te) => {
    for (let rt = 0; rt < pe.length; rt++) {
      const pt = pe[rt];
      if (pt.test(Te))
        return pt;
    }
  }, Gn = (pe, Te) => {
    const rt = eo(pe, Te);
    if (!rt)
      return {
        major: 0,
        minor: 0
      };
    const pt = (to) => Number(Te.replace(rt, "$" + to));
    return lo(pt(1), pt(2));
  }, qn = (pe, Te) => {
    const rt = String(Te).toLowerCase();
    return pe.length === 0 ? Qn() : Gn(pe, rt);
  }, Qn = () => lo(0, 0), lo = (pe, Te) => ({
    major: pe,
    minor: Te
  }), rr = {
    nu: lo,
    detect: qn,
    unknown: Qn
  }, Kr = (pe, Te) => tn(Te.brands, (rt) => {
    const pt = rt.brand.toLowerCase();
    return qe(pe, (to) => {
      var sr;
      return pt === ((sr = to.brand) === null || sr === void 0 ? void 0 : sr.toLowerCase());
    }).map((to) => ({
      current: to.name,
      version: rr.nu(parseInt(rt.version, 10), 0)
    }));
  }), Wa = (pe, Te) => {
    const rt = String(Te).toLowerCase();
    return qe(pe, (pt) => pt.search(rt));
  }, Ei = (pe, Te) => Wa(pe, Te).map((rt) => {
    const pt = rr.detect(rt.versionRegexes, Te);
    return {
      current: rt.name,
      version: pt
    };
  }), Ti = (pe, Te) => Wa(pe, Te).map((rt) => {
    const pt = rr.detect(rt.versionRegexes, Te);
    return {
      current: rt.name,
      version: pt
    };
  }), ko = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, Yo = (pe) => (Te) => yn(Te, pe), Fr = [
    {
      name: "Edge",
      versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
      search: (pe) => yn(pe, "edge/") && yn(pe, "chrome") && yn(pe, "safari") && yn(pe, "applewebkit")
    },
    {
      name: "Chromium",
      brand: "Chromium",
      versionRegexes: [
        /.*?chrome\/([0-9]+)\.([0-9]+).*/,
        ko
      ],
      search: (pe) => yn(pe, "chrome") && !yn(pe, "chromeframe")
    },
    {
      name: "IE",
      versionRegexes: [
        /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
        /.*?rv:([0-9]+)\.([0-9]+).*/
      ],
      search: (pe) => yn(pe, "msie") || yn(pe, "trident")
    },
    {
      name: "Opera",
      versionRegexes: [
        ko,
        /.*?opera\/([0-9]+)\.([0-9]+).*/
      ],
      search: Yo("opera")
    },
    {
      name: "Firefox",
      versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
      search: Yo("firefox")
    },
    {
      name: "Safari",
      versionRegexes: [
        ko,
        /.*?cpu os ([0-9]+)_([0-9]+).*/
      ],
      search: (pe) => (yn(pe, "safari") || yn(pe, "mobile/")) && yn(pe, "applewebkit")
    }
  ], Ba = [
    {
      name: "Windows",
      search: Yo("win"),
      versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "iOS",
      search: (pe) => yn(pe, "iphone") || yn(pe, "ipad"),
      versionRegexes: [
        /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
        /.*cpu os ([0-9]+)_([0-9]+).*/,
        /.*cpu iphone os ([0-9]+)_([0-9]+).*/
      ]
    },
    {
      name: "Android",
      search: Yo("android"),
      versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "macOS",
      search: Yo("mac os x"),
      versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    },
    {
      name: "Linux",
      search: Yo("linux"),
      versionRegexes: []
    },
    {
      name: "Solaris",
      search: Yo("sunos"),
      versionRegexes: []
    },
    {
      name: "FreeBSD",
      search: Yo("freebsd"),
      versionRegexes: []
    },
    {
      name: "ChromeOS",
      search: Yo("cros"),
      versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }
  ], ua = {
    browsers: nt(Fr),
    oses: nt(Ba)
  }, vs = "Edge", es = "Chromium", ai = "IE", vc = "Opera", Lr = "Firefox", ka = "Safari", ii = () => na({
    current: void 0,
    version: rr.unknown()
  }), na = (pe) => {
    const Te = pe.current, rt = pe.version, pt = (to) => () => Te === to;
    return {
      current: Te,
      version: rt,
      isEdge: pt(vs),
      isChromium: pt(es),
      isIE: pt(ai),
      isOpera: pt(vc),
      isFirefox: pt(Lr),
      isSafari: pt(ka)
    };
  }, Oi = {
    unknown: ii,
    nu: na,
    edge: nt(vs),
    chromium: nt(es),
    ie: nt(ai),
    opera: nt(vc),
    firefox: nt(Lr),
    safari: nt(ka)
  }, cl = "Windows", Za = "iOS", Ai = "Android", Ui = "Linux", au = "macOS", gi = "Solaris", Ml = "FreeBSD", $a = "ChromeOS", Wi = () => Kl({
    current: void 0,
    version: rr.unknown()
  }), Kl = (pe) => {
    const Te = pe.current, rt = pe.version, pt = (to) => () => Te === to;
    return {
      current: Te,
      version: rt,
      isWindows: pt(cl),
      isiOS: pt(Za),
      isAndroid: pt(Ai),
      isMacOS: pt(au),
      isLinux: pt(Ui),
      isSolaris: pt(gi),
      isFreeBSD: pt(Ml),
      isChromeOS: pt($a)
    };
  }, yc = {
    unknown: Wi,
    nu: Kl,
    windows: nt(cl),
    ios: nt(Za),
    android: nt(Ai),
    linux: nt(Ui),
    macos: nt(au),
    solaris: nt(gi),
    freebsd: nt(Ml),
    chromeos: nt($a)
  }, iu = { detect: (pe, Te, rt) => {
    const pt = ua.browsers(), to = ua.oses(), sr = Te.bind((ur) => Kr(pt, ur)).orThunk(() => Ei(pt, pe)).fold(Oi.unknown, Oi.nu), _s = Ti(to, pe).fold(yc.unknown, yc.nu), Ha = kn(_s, sr, pe, rt);
    return {
      browser: sr,
      os: _s,
      deviceType: Ha
    };
  } }, bi = (pe) => window.matchMedia(pe).matches;
  let Ru = Wt(() => iu.detect(navigator.userAgent, ot.from(navigator.userAgentData), bi));
  const le = () => Ru(), Ae = (pe, Te) => ({
    left: pe,
    top: Te,
    translate: (pt, to) => Ae(pe + pt, Te + to)
  }), Ze = Ae, Dt = (pe) => {
    const Te = pe !== void 0 ? pe.dom : document, rt = Te.body.scrollLeft || Te.documentElement.scrollLeft, pt = Te.body.scrollTop || Te.documentElement.scrollTop;
    return Ze(rt, pt);
  }, Yt = (pe) => {
    const Te = pe === void 0 ? window : pe;
    return le().browser.isFirefox() ? ot.none() : ot.from(Te.visualViewport);
  }, Wn = (pe, Te, rt, pt) => ({
    x: pe,
    y: Te,
    width: rt,
    height: pt,
    right: pe + rt,
    bottom: Te + pt
  }), lr = (pe) => {
    const Te = pe === void 0 ? window : pe, rt = Te.document, pt = Dt(Tr.fromDom(rt));
    return Yt(Te).fold(() => {
      const to = Te.document.documentElement, sr = to.clientWidth, _s = to.clientHeight;
      return Wn(pt.left, pt.top, sr, _s);
    }, (to) => Wn(Math.max(to.pageLeft, pt.left), Math.max(to.pageTop, pt.top), to.width, to.height));
  }, yr = (pe, Te, rt) => Yt(rt).map((pt) => {
    const to = (sr) => Te(Bo(sr));
    return pt.addEventListener(pe, to), { unbind: () => pt.removeEventListener(pe, to) };
  }).getOrThunk(() => ({ unbind: ae }));
  var Uo = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), Yr = tinymce.util.Tools.resolve("tinymce.Env");
  const Ds = (pe, Te) => {
    pe.dispatch("FullscreenStateChanged", { state: Te }), pe.dispatch("ResizeEditor");
  }, rn = (pe) => (Te) => Te.options.get(pe), cd = (pe) => {
    const Te = pe.options.register;
    Te("fullscreen_native", {
      processor: "boolean",
      default: !1
    });
  }, os = rn("fullscreen_native"), K = (pe) => {
    const Te = Tr.fromDom(pe.getElement());
    return Tn(Te).map(Po).getOrThunk(() => Ps(qs(Te)));
  }, ge = (pe) => pe.fullscreenElement !== void 0 ? pe.fullscreenElement : pe.msFullscreenElement !== void 0 ? pe.msFullscreenElement : pe.webkitFullscreenElement !== void 0 ? pe.webkitFullscreenElement : null, Ee = () => document.fullscreenElement !== void 0 ? "fullscreenchange" : document.msFullscreenElement !== void 0 ? "MSFullscreenChange" : document.webkitFullscreenElement !== void 0 ? "webkitfullscreenchange" : "fullscreenchange", ft = (pe) => {
    const Te = pe.dom;
    Te.requestFullscreen ? Te.requestFullscreen() : Te.msRequestFullscreen ? Te.msRequestFullscreen() : Te.webkitRequestFullScreen && Te.webkitRequestFullScreen();
  }, Cn = (pe) => {
    const Te = pe.dom;
    Te.exitFullscreen ? Te.exitFullscreen() : Te.msExitFullscreen ? Te.msExitFullscreen() : Te.webkitCancelFullScreen && Te.webkitCancelFullScreen();
  }, Jo = (pe) => pe.dom === ge(qs(pe).dom), Ln = (pe, Te, rt) => dn(xa(pe, rt), Te), Rs = (pe, Te) => dn(ca(pe), Te), Gt = (pe) => As(pe), fs = (pe, Te, rt) => Ln(pe, (pt) => Ht(pt, Te), rt), vi = (pe, Te) => Rs(pe, (rt) => Ht(rt, Te)), ks = "data-ephox-mobile-fullscreen-style", ga = "display:none!important;", Il = "position:absolute!important;", xr = "top:0!important;left:0!important;margin:0!important;padding:0!important;width:100%!important;height:100%!important;overflow:visible!important;", yi = "background-color:rgb(255,255,255)!important;", Ns = Yr.os.isAndroid(), xc = (pe) => {
    const Te = _t(pe, "background-color");
    return Te !== void 0 && Te !== "" ? "background-color:" + Te + "!important" : yi;
  }, Bs = (pe, Te, rt) => {
    const pt = (_a) => vi(_a, "*:not(.tox-silver-sink)"), to = (_a) => (Ms) => {
      const da = Qo(Ms, "style"), sa = da === void 0 ? "no-styles" : da.trim();
      sa !== _a && (Ko(Ms, ks, sa), ct(Ms, pe.parseStyle(_a)));
    }, sr = fs(Te, "*"), _s = mn(sr, pt), Ha = xc(rt);
    ye(_s, to(ga)), ye(sr, to(Il + xr + Ha)), to((Ns === !0 ? "" : Il) + xr + Ha)(Te);
  }, ud = (pe) => {
    const Te = Gt("[" + ks + "]");
    ye(Te, (rt) => {
      const pt = Qo(rt, ks);
      pt && pt !== "no-styles" ? ct(rt, pe.parseStyle(pt)) : Mr(rt, "style"), Mr(rt, ks);
    });
  }, vm = Uo.DOM, Oh = () => lr(window), zs = (pe) => window.scrollTo(pe.x, pe.y), Yl = Yt().fold(() => ({
    bind: ae,
    unbind: ae
  }), (pe) => {
    const Te = St(), rt = Fn(), pt = Fn(), to = () => {
      document.body.scrollTop = 0, document.documentElement.scrollTop = 0;
    }, sr = () => {
      window.requestAnimationFrame(() => {
        Te.on((_a) => ct(_a, {
          top: pe.offsetTop + "px",
          left: pe.offsetLeft + "px",
          height: pe.height + "px",
          width: pe.width + "px"
        }));
      });
    }, _s = on(() => {
      to(), sr();
    }, 50);
    return {
      bind: (_a) => {
        Te.set(_a), _s.throttle(), rt.set(yr("resize", _s.throttle)), pt.set(yr("scroll", _s.throttle));
      },
      unbind: () => {
        Te.on(() => {
          rt.clear(), pt.clear();
        }), Te.clear();
      }
    };
  }), La = (pe, Te) => {
    const rt = document.body, pt = document.documentElement, to = pe.getContainer(), sr = Tr.fromDom(to), _s = Or(sr).filter((qa) => Ct(qa) && kt(qa, "tox-silver-sink")), Ha = K(pe), ur = Te.get(), _a = Tr.fromDom(pe.getBody()), Ms = Yr.deviceType.isTouch(), da = to.style, sa = pe.iframeElement, oa = sa == null ? void 0 : sa.style, ul = (qa) => {
      qa(rt, "tox-fullscreen"), qa(pt, "tox-fullscreen"), qa(to, "tox-fullscreen"), Tn(sr).map((dl) => Po(dl).dom).each((dl) => {
        qa(dl, "tox-fullscreen"), qa(dl, "tox-shadowhost");
      });
    }, wc = () => {
      Ms && ud(pe.dom), ul(vm.removeClass), Yl.unbind(), ot.from(Te.get()).each((qa) => qa.fullscreenChangeHandler.unbind());
    };
    if (ur)
      ur.fullscreenChangeHandler.unbind(), os(pe) && Jo(Ha) && Cn(qs(Ha)), oa.width = ur.iframeWidth, oa.height = ur.iframeHeight, da.width = ur.containerWidth, da.height = ur.containerHeight, da.top = ur.containerTop, da.left = ur.containerLeft, Le(_s, ur.sinkCssPosition, (qa, dl) => {
        Oe(qa, "position", dl);
      }), wc(), zs(ur.scrollPos), Te.set(null), Ds(pe, !1), pe.off("remove", wc);
    else {
      const qa = Bt(qs(Ha), Ee(), (Mc) => {
        os(pe) && !Jo(Ha) && Te.get() !== null && La(pe, Te);
      }), dl = {
        scrollPos: Oh(),
        containerWidth: da.width,
        containerHeight: da.height,
        containerTop: da.top,
        containerLeft: da.left,
        iframeWidth: oa.width,
        iframeHeight: oa.height,
        fullscreenChangeHandler: qa,
        sinkCssPosition: _s.map((Mc) => _t(Mc, "position"))
      };
      Ms && Bs(pe.dom, sr, _a), oa.width = oa.height = "100%", da.width = da.height = "", ul(vm.addClass), _s.each((Mc) => {
        Oe(Mc, "position", "fixed");
      }), Yl.bind(sr), pe.on("remove", wc), Te.set(dl), os(pe) && ft(Ha), Ds(pe, !0);
    }
  }, Ga = (pe, Te) => {
    pe.addCommand("mceFullScreen", () => {
      La(pe, Te);
    });
  };
  var xi = tinymce.util.Tools.resolve("tinymce.util.VK");
  const Of = (pe, Te) => {
    pe.on("init", () => {
      pe.on("keydown", (rt) => {
        rt.keyCode === xi.TAB && !(rt.metaKey || rt.ctrlKey) && Te.get() && rt.preventDefault();
      });
    });
  }, gr = (pe, Te) => (rt) => {
    rt.setActive(Te.get() !== null);
    const pt = (to) => rt.setActive(to.state);
    return pe.on("FullscreenStateChanged", pt), () => pe.off("FullscreenStateChanged", pt);
  }, Pi = (pe, Te) => {
    const rt = () => pe.execCommand("mceFullScreen");
    pe.ui.registry.addToggleMenuItem("fullscreen", {
      text: "Fullscreen",
      icon: "fullscreen",
      shortcut: "Meta+Shift+F",
      onAction: rt,
      onSetup: gr(pe, Te)
    }), pe.ui.registry.addToggleButton("fullscreen", {
      tooltip: "Fullscreen",
      icon: "fullscreen",
      onAction: rt,
      onSetup: gr(pe, Te),
      shortcut: "Meta+Shift+F"
    });
  };
  var li = () => {
    r.add("fullscreen", (pe) => {
      const Te = o(null);
      return pe.inline || (cd(pe), Ga(pe, Te), Pi(pe, Te), Of(pe, Te), pe.addShortcut("Meta+Shift+F", "", "mceFullScreen")), i(Te);
    });
  };
  li();
})();
(function() {
  const o = (Vt) => {
    let Ct = Vt;
    return {
      get: () => Ct,
      set: (so) => {
        Ct = so;
      }
    };
  };
  var r = tinymce.util.Tools.resolve("tinymce.PluginManager");
  let i = 0;
  const u = (Vt) => {
    const Jn = (/* @__PURE__ */ new Date()).getTime(), Pn = Math.floor(Math.random() * 1e9);
    return i++, Vt + "_" + Pn + i + String(Jn);
  }, h = (Vt) => ({ addTab: (Jn) => {
    var Pn;
    const so = (Pn = Jn.name) !== null && Pn !== void 0 ? Pn : u("tab-name"), pr = Vt.get();
    pr[so] = Jn, Vt.set(pr);
  } }), y = (Vt, Ct) => {
    Vt.addCommand("mceHelp", Ct);
  }, k = (Vt) => (Ct) => Ct.options.get(Vt), _ = (Vt) => {
    const Ct = Vt.options.register;
    Ct("help_tabs", { processor: "array" });
  }, D = k("help_tabs"), L = k("forced_plugins"), W = (Vt, Ct) => {
    Vt.ui.registry.addButton("help", {
      icon: "help",
      tooltip: "Help",
      onAction: Ct
    }), Vt.ui.registry.addMenuItem("help", {
      text: "Help",
      icon: "help",
      shortcut: "Alt+0",
      onAction: Ct
    });
  }, se = (Vt, Ct, Jn) => {
    var Pn;
    return Jn(Vt, Ct.prototype) ? !0 : ((Pn = Vt.constructor) === null || Pn === void 0 ? void 0 : Pn.name) === Ct.name;
  }, J = (Vt) => {
    const Ct = typeof Vt;
    return Vt === null ? "null" : Ct === "object" && Array.isArray(Vt) ? "array" : Ct === "object" && se(Vt, String, (Jn, Pn) => Pn.isPrototypeOf(Jn)) ? "string" : Ct;
  }, be = (Vt) => (Ct) => J(Ct) === Vt, ke = (Vt) => (Ct) => typeof Ct === Vt, Ce = (Vt) => (Ct) => Vt === Ct, Q = be("string"), oe = Ce(void 0), ae = (Vt) => Vt == null, G = (Vt) => !ae(Vt), ve = ke("function"), Xe = ((Vt) => () => Vt)(!1);
  class te {
    constructor(Ct, Jn) {
      this.tag = Ct, this.value = Jn;
    }
    static some(Ct) {
      return new te(!0, Ct);
    }
    static none() {
      return te.singletonNone;
    }
    fold(Ct, Jn) {
      return this.tag ? Jn(this.value) : Ct();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(Ct) {
      return this.tag ? te.some(Ct(this.value)) : te.none();
    }
    bind(Ct) {
      return this.tag ? Ct(this.value) : te.none();
    }
    exists(Ct) {
      return this.tag && Ct(this.value);
    }
    forall(Ct) {
      return !this.tag || Ct(this.value);
    }
    filter(Ct) {
      return !this.tag || Ct(this.value) ? this : te.none();
    }
    getOr(Ct) {
      return this.tag ? this.value : Ct;
    }
    or(Ct) {
      return this.tag ? this : Ct;
    }
    getOrThunk(Ct) {
      return this.tag ? this.value : Ct();
    }
    orThunk(Ct) {
      return this.tag ? this : Ct();
    }
    getOrDie(Ct) {
      if (this.tag)
        return this.value;
      throw new Error(Ct ?? "Called getOrDie on None");
    }
    static from(Ct) {
      return G(Ct) ? te.some(Ct) : te.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(Ct) {
      this.tag && Ct(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  te.singletonNone = new te(!1);
  const lt = Array.prototype.slice, ot = Array.prototype.indexOf, Kt = (Vt, Ct) => ot.call(Vt, Ct), je = (Vt, Ct) => Kt(Vt, Ct) > -1, ye = (Vt, Ct) => {
    const Jn = Vt.length, Pn = new Array(Jn);
    for (let so = 0; so < Jn; so++) {
      const pr = Vt[so];
      Pn[so] = Ct(pr, so);
    }
    return Pn;
  }, dn = (Vt, Ct) => {
    const Jn = [];
    for (let Pn = 0, so = Vt.length; Pn < so; Pn++) {
      const pr = Vt[Pn];
      Ct(pr, Pn) && Jn.push(pr);
    }
    return Jn;
  }, wt = (Vt, Ct, Jn) => {
    for (let Pn = 0, so = Vt.length; Pn < so; Pn++) {
      const pr = Vt[Pn];
      if (Ct(pr, Pn))
        return te.some(pr);
      if (Jn(pr, Pn))
        break;
    }
    return te.none();
  }, qe = (Vt, Ct) => wt(Vt, Ct, Xe), B = (Vt, Ct) => {
    const Jn = lt.call(Vt, 0);
    return Jn.sort(Ct), Jn;
  }, mn = Object.keys, dt = Object.hasOwnProperty, En = (Vt, Ct) => tn(Vt, Ct) ? te.from(Vt[Ct]) : te.none(), tn = (Vt, Ct) => dt.call(Vt, Ct), Le = (Vt) => {
    const Ct = [], Jn = (Pn) => {
      Ct.push(Pn);
    };
    for (let Pn = 0; Pn < Vt.length; Pn++)
      Vt[Pn].each(Jn);
    return Ct;
  };
  var jt = tinymce.util.Tools.resolve("tinymce.Resource"), Fn = tinymce.util.Tools.resolve("tinymce.util.I18n");
  const St = (Vt, Ct) => jt.load(`tinymce.html-i18n.help-keynav.${Ct}`, `${Vt}/js/i18n/keynav/${Ct}.js`), on = (Vt) => St(Vt, Fn.getCode()).catch(() => St(Vt, "en")), tt = (Vt, Ct) => {
    Vt.on("init", () => {
      on(Ct);
    });
  }, mt = async (Vt) => ({
    name: "keyboardnav",
    title: "Keyboard Navigation",
    items: [{
      type: "htmlpanel",
      presets: "document",
      html: await on(Vt)
    }]
  });
  var Y = tinymce.util.Tools.resolve("tinymce.Env");
  const Wo = (Vt) => {
    const Ct = Y.os.isMacOS() || Y.os.isiOS(), so = Ct ? {
      alt: "&#x2325;",
      ctrl: "&#x2303;",
      shift: "&#x21E7;",
      meta: "&#x2318;",
      access: "&#x2303;&#x2325;"
    } : {
      meta: "Ctrl ",
      access: "Shift + Alt "
    }, pr = Vt.split("+"), nr = ye(pr, (Ko) => {
      const Qo = Ko.toLowerCase().trim();
      return tn(so, Qo) ? so[Qo] : Ko;
    });
    return Ct ? nr.join("").replace(/\s/, "") : nr.join("+");
  }, To = [
    {
      shortcuts: ["Meta + B"],
      action: "Bold"
    },
    {
      shortcuts: ["Meta + I"],
      action: "Italic"
    },
    {
      shortcuts: ["Meta + U"],
      action: "Underline"
    },
    {
      shortcuts: ["Meta + A"],
      action: "Select all"
    },
    {
      shortcuts: [
        "Meta + Y",
        "Meta + Shift + Z"
      ],
      action: "Redo"
    },
    {
      shortcuts: ["Meta + Z"],
      action: "Undo"
    },
    {
      shortcuts: ["Access + 1"],
      action: "Heading 1"
    },
    {
      shortcuts: ["Access + 2"],
      action: "Heading 2"
    },
    {
      shortcuts: ["Access + 3"],
      action: "Heading 3"
    },
    {
      shortcuts: ["Access + 4"],
      action: "Heading 4"
    },
    {
      shortcuts: ["Access + 5"],
      action: "Heading 5"
    },
    {
      shortcuts: ["Access + 6"],
      action: "Heading 6"
    },
    {
      shortcuts: ["Access + 7"],
      action: "Paragraph"
    },
    {
      shortcuts: ["Access + 8"],
      action: "Div"
    },
    {
      shortcuts: ["Access + 9"],
      action: "Address"
    },
    {
      shortcuts: ["Alt + 0"],
      action: "Open help dialog"
    },
    {
      shortcuts: ["Alt + F9"],
      action: "Focus to menubar"
    },
    {
      shortcuts: ["Alt + F10"],
      action: "Focus to toolbar"
    },
    {
      shortcuts: ["Alt + F11"],
      action: "Focus to element path"
    },
    {
      shortcuts: ["Alt + F12"],
      action: "Focus to notification"
    },
    {
      shortcuts: ["Ctrl + F9"],
      action: "Focus to contextual toolbar"
    },
    {
      shortcuts: ["Shift + Enter"],
      action: "Open popup menu for split buttons"
    },
    {
      shortcuts: ["Meta + K"],
      action: "Insert link (if link plugin activated)"
    },
    {
      shortcuts: ["Meta + S"],
      action: "Save (if save plugin activated)"
    },
    {
      shortcuts: ["Meta + F"],
      action: "Find (if searchreplace plugin activated)"
    },
    {
      shortcuts: ["Meta + Shift + F"],
      action: "Switch to or from fullscreen mode"
    }
  ], Ot = () => {
    const Vt = ye(To, (Jn) => {
      const Pn = ye(Jn.shortcuts, Wo).join(" or ");
      return [
        Jn.action,
        Pn
      ];
    });
    return {
      name: "shortcuts",
      title: "Handy Shortcuts",
      items: [{
        type: "table",
        header: [
          "Action",
          "Shortcut"
        ],
        cells: Vt
      }]
    };
  }, Mt = ye([
    {
      key: "accordion",
      name: "Accordion"
    },
    {
      key: "anchor",
      name: "Anchor"
    },
    {
      key: "autolink",
      name: "Autolink"
    },
    {
      key: "autoresize",
      name: "Autoresize"
    },
    {
      key: "autosave",
      name: "Autosave"
    },
    {
      key: "charmap",
      name: "Character Map"
    },
    {
      key: "code",
      name: "Code"
    },
    {
      key: "codesample",
      name: "Code Sample"
    },
    {
      key: "colorpicker",
      name: "Color Picker"
    },
    {
      key: "directionality",
      name: "Directionality"
    },
    {
      key: "emoticons",
      name: "Emoticons"
    },
    {
      key: "fullscreen",
      name: "Full Screen"
    },
    {
      key: "help",
      name: "Help"
    },
    {
      key: "image",
      name: "Image"
    },
    {
      key: "importcss",
      name: "Import CSS"
    },
    {
      key: "insertdatetime",
      name: "Insert Date/Time"
    },
    {
      key: "link",
      name: "Link"
    },
    {
      key: "lists",
      name: "Lists"
    },
    {
      key: "advlist",
      name: "List Styles"
    },
    {
      key: "media",
      name: "Media"
    },
    {
      key: "nonbreaking",
      name: "Nonbreaking"
    },
    {
      key: "pagebreak",
      name: "Page Break"
    },
    {
      key: "preview",
      name: "Preview"
    },
    {
      key: "quickbars",
      name: "Quick Toolbars"
    },
    {
      key: "save",
      name: "Save"
    },
    {
      key: "searchreplace",
      name: "Search and Replace"
    },
    {
      key: "table",
      name: "Table"
    },
    {
      key: "textcolor",
      name: "Text Color"
    },
    {
      key: "visualblocks",
      name: "Visual Blocks"
    },
    {
      key: "visualchars",
      name: "Visual Characters"
    },
    {
      key: "wordcount",
      name: "Word Count"
    },
    {
      key: "a11ychecker",
      name: "Accessibility Checker",
      type: "premium"
    },
    {
      key: "typography",
      name: "Advanced Typography",
      type: "premium",
      slug: "advanced-typography"
    },
    {
      key: "ai",
      name: "AI Assistant",
      type: "premium"
    },
    {
      key: "casechange",
      name: "Case Change",
      type: "premium"
    },
    {
      key: "checklist",
      name: "Checklist",
      type: "premium"
    },
    {
      key: "advcode",
      name: "Enhanced Code Editor",
      type: "premium"
    },
    {
      key: "mediaembed",
      name: "Enhanced Media Embed",
      type: "premium",
      slug: "introduction-to-mediaembed"
    },
    {
      key: "advtable",
      name: "Enhanced Tables",
      type: "premium"
    },
    {
      key: "exportpdf",
      name: "Export to PDF",
      type: "premium"
    },
    {
      key: "exportword",
      name: "Export to Word",
      type: "premium"
    },
    {
      key: "footnotes",
      name: "Footnotes",
      type: "premium"
    },
    {
      key: "formatpainter",
      name: "Format Painter",
      type: "premium"
    },
    {
      key: "editimage",
      name: "Image Editing",
      type: "premium"
    },
    {
      key: "importword",
      name: "Import from Word",
      type: "premium"
    },
    {
      key: "inlinecss",
      name: "Inline CSS",
      type: "premium",
      slug: "inline-css"
    },
    {
      key: "linkchecker",
      name: "Link Checker",
      type: "premium"
    },
    {
      key: "math",
      name: "Math",
      type: "premium"
    },
    {
      key: "markdown",
      name: "Markdown",
      type: "premium"
    },
    {
      key: "mentions",
      name: "Mentions",
      type: "premium"
    },
    {
      key: "mergetags",
      name: "Merge Tags",
      type: "premium"
    },
    {
      key: "pageembed",
      name: "Page Embed",
      type: "premium"
    },
    {
      key: "permanentpen",
      name: "Permanent Pen",
      type: "premium"
    },
    {
      key: "powerpaste",
      name: "PowerPaste",
      type: "premium",
      slug: "introduction-to-powerpaste"
    },
    {
      key: "revisionhistory",
      name: "Revision History",
      type: "premium"
    },
    {
      key: "tinymcespellchecker",
      name: "Spell Checker",
      type: "premium",
      slug: "introduction-to-tiny-spellchecker"
    },
    {
      key: "autocorrect",
      name: "Spelling Autocorrect",
      type: "premium"
    },
    {
      key: "tableofcontents",
      name: "Table of Contents",
      type: "premium"
    },
    {
      key: "advtemplate",
      name: "Templates",
      type: "premium",
      slug: "advanced-templates"
    },
    {
      key: "tinycomments",
      name: "Tiny Comments",
      type: "premium",
      slug: "introduction-to-tiny-comments"
    },
    {
      key: "tinydrive",
      name: "Tiny Drive",
      type: "premium",
      slug: "tinydrive-introduction"
    }
  ], (Vt) => ({
    ...Vt,
    type: Vt.type || "opensource",
    slug: Vt.slug || Vt.key
  })), zn = (Vt) => {
    const Ct = () => {
      const Mr = dn(Mt, ({ type: yn }) => yn === "premium"), at = B(ye(Mr, (yn) => yn.name), (yn, pn) => yn.localeCompare(pn)), kt = ye(at, (yn) => `<li>${yn}</li>`).join("");
      return "<div><p><b>" + Fn.translate("Premium plugins:") + "</b></p><ul>" + kt + '<li class="tox-help__more-link" "><a href="https://www.tiny.cloud/pricing/?utm_campaign=help_dialog_plugin_tab&utm_source=tiny&utm_medium=referral&utm_term=read_more&utm_content=premium_plugin_heading" rel="noopener" target="_blank" data-alloy-tabstop="true" tabindex="-1">' + Fn.translate("Learn more...") + "</a></li></ul></div>";
    }, Jn = (Mr) => `<a data-alloy-tabstop="true" tabindex="-1" href="${Mr.url}" target="_blank" rel="noopener">${Mr.name}</a>`, Pn = (Mr, at) => {
      const kt = Mr.plugins[at].getMetadata;
      if (ve(kt)) {
        const yn = kt();
        return {
          name: yn.name,
          html: Jn(yn)
        };
      } else
        return {
          name: at,
          html: at
        };
    }, so = (Mr, at) => qe(Mt, (kt) => kt.key === at).fold(() => Pn(Mr, at), (kt) => {
      const yn = kt.type === "premium" ? `${kt.name}*` : kt.name, pn = Jn({
        name: yn,
        url: `https://www.tiny.cloud/docs/tinymce/7/${kt.slug}/`
      });
      return {
        name: yn,
        html: pn
      };
    }), pr = (Mr) => {
      const at = mn(Mr.plugins), kt = L(Mr);
      return oe(kt) ? at : dn(at, (yn) => !je(kt, yn));
    }, nr = (Mr) => {
      const at = pr(Mr), kt = B(ye(at, (or) => so(Mr, or)), (or, Ir) => or.name.localeCompare(Ir.name)), yn = ye(kt, (or) => "<li>" + or.html + "</li>"), pn = yn.length, Oo = yn.join("");
      return "<p><b>" + Fn.translate([
        "Plugins installed ({0}):",
        pn
      ]) + "</b></p><ul>" + Oo + "</ul>";
    };
    return {
      name: "plugins",
      title: "Plugins",
      items: [{
        type: "htmlpanel",
        presets: "document",
        html: [
          ((Mr) => Mr == null ? "" : "<div>" + nr(Mr) + "</div>")(Vt),
          Ct()
        ].join("")
      }]
    };
  };
  var At = tinymce.util.Tools.resolve("tinymce.EditorManager");
  const $n = () => {
    const Jn = '<a data-alloy-tabstop="true" tabindex="-1" href="https://www.tiny.cloud/docs/tinymce/7/changelog/?utm_campaign=help_dialog_version_tab&utm_source=tiny&utm_medium=referral" rel="noopener" target="_blank">TinyMCE ' + ((so, pr) => so.indexOf("@") === 0 ? "X.X.X" : so + "." + pr)(At.majorVersion, At.minorVersion) + "</a>";
    return {
      name: "versions",
      title: "Version",
      items: [{
        type: "htmlpanel",
        html: "<p>" + Fn.translate([
          "You are using {0}",
          Jn
        ]) + "</p>",
        presets: "document"
      }]
    };
  }, en = (Vt, Ct) => {
    const Jn = {}, Pn = ye(Vt, (so) => {
      var pr;
      if (Q(so))
        return tn(Ct, so) && (Jn[so] = Ct[so]), so;
      {
        const nr = (pr = so.name) !== null && pr !== void 0 ? pr : u("tab-name");
        return Jn[nr] = so, nr;
      }
    });
    return {
      tabs: Jn,
      names: Pn
    };
  }, Ue = (Vt) => {
    const Ct = mn(Vt), Jn = Ct.indexOf("versions");
    return Jn !== -1 && (Ct.splice(Jn, 1), Ct.push("versions")), {
      tabs: Vt,
      names: Ct
    };
  }, jn = async (Vt, Ct, Jn) => {
    const Pn = Ot(), so = await mt(Jn), pr = zn(Vt), nr = $n(), Ko = {
      [Pn.name]: Pn,
      [so.name]: so,
      [pr.name]: pr,
      [nr.name]: nr,
      ...Ct.get()
    };
    return te.from(D(Vt)).fold(() => Ue(Ko), (Qo) => en(Qo, Ko));
  }, mo = (Vt, Ct, Jn) => () => {
    jn(Vt, Ct, Jn).then(({ tabs: Pn, names: so }) => {
      const pr = ye(so, (Qo) => En(Pn, Qo)), Ko = {
        type: "tabpanel",
        tabs: Le(pr)
      };
      Vt.windowManager.open({
        title: "Help",
        size: "medium",
        body: Ko,
        buttons: [{
          type: "cancel",
          name: "close",
          text: "Close",
          primary: !0
        }],
        initialData: {}
      });
    });
  };
  var xn = () => {
    r.add("help", (Vt, Ct) => {
      const Jn = o({}), Pn = h(Jn);
      _(Vt);
      const so = mo(Vt, Jn, Ct);
      return W(Vt, so), y(Vt, so), Vt.shortcuts.add("Alt+0", "Open help dialog", "mceHelp"), tt(Vt, Ct), Pn;
    });
  };
  xn();
})();
tinymce.Resource.add(
  "tinymce.html-i18n.help-keynav.en",
  `<h1>Begin keyboard navigation</h1>

<dl>
  <dt>Focus the Menu bar</dt>
  <dd>Windows or Linux: Alt+F9</dd>
  <dd>macOS: &#x2325;F9</dd>
  <dt>Focus the Toolbar</dt>
  <dd>Windows or Linux: Alt+F10</dd>
  <dd>macOS: &#x2325;F10</dd>
  <dt>Focus the footer</dt>
  <dd>Windows or Linux: Alt+F11</dd>
  <dd>macOS: &#x2325;F11</dd>
  <dt>Focus the notification</dt>
  <dd>Windows or Linux: Alt+F12</dd>
  <dd>macOS: &#x2325;F12</dd>
  <dt>Focus a contextual toolbar</dt>
  <dd>Windows, Linux or macOS: Ctrl+F9</dd>
</dl>

<p>Navigation will start at the first UI item, which will be highlighted, or underlined in the case of the first item in
  the Footer element path.</p>

<h1>Navigate between UI sections</h1>

<p>To move from one UI section to the next, press <strong>Tab</strong>.</p>

<p>To move from one UI section to the previous, press <strong>Shift+Tab</strong>.</p>

<p>The <strong>Tab</strong> order of these UI sections is:</p>

<ol>
  <li>Menu bar</li>
  <li>Each toolbar group</li>
  <li>Sidebar</li>
  <li>Element path in the footer</li>
  <li>Word count toggle button in the footer</li>
  <li>Branding link in the footer</li>
  <li>Editor resize handle in the footer</li>
</ol>

<p>If a UI section is not present, it is skipped.</p>

<p>If the footer has keyboard navigation focus, and there is no visible sidebar, pressing <strong>Shift+Tab</strong>
  moves focus to the first toolbar group, not the last.</p>

<h1>Navigate within UI sections</h1>

<p>To move from one UI element to the next, press the appropriate <strong>Arrow</strong> key.</p>

<p>The <strong>Left</strong> and <strong>Right</strong> arrow keys</p>

<ul>
  <li>move between menus in the menu bar.</li>
  <li>open a sub-menu in a menu.</li>
  <li>move between buttons in a toolbar group.</li>
  <li>move between items in the footers element path.</li>
</ul>

<p>The <strong>Down</strong> and <strong>Up</strong> arrow keys</p>

<ul>
  <li>move between menu items in a menu.</li>
  <li>move between items in a toolbar pop-up menu.</li>
</ul>

<p><strong>Arrow</strong> keys cycle within the focused UI section.</p>

<p>To close an open menu, an open sub-menu, or an open pop-up menu, press the <strong>Esc</strong> key.</p>

<p>If the current focus is at the top of a particular UI section, pressing the <strong>Esc</strong> key also exits
  keyboard navigation entirely.</p>

<h1>Execute a menu item or toolbar button</h1>

<p>When the desired menu item or toolbar button is highlighted, press <strong>Return</strong>, <strong>Enter</strong>,
  or the <strong>Space bar</strong> to execute the item.</p>

<h1>Navigate non-tabbed dialogs</h1>

<p>In non-tabbed dialogs, the first interactive component takes focus when the dialog opens.</p>

<p>Navigate between interactive dialog components by pressing <strong>Tab</strong> or <strong>Shift+Tab</strong>.</p>

<h1>Navigate tabbed dialogs</h1>

<p>In tabbed dialogs, the first button in the tab menu takes focus when the dialog opens.</p>

<p>Navigate between interactive components of this dialog tab by pressing <strong>Tab</strong> or
  <strong>Shift+Tab</strong>.</p>

<p>Switch to another dialog tab by giving the tab menu focus and then pressing the appropriate <strong>Arrow</strong>
  key to cycle through the available tabs.</p>
`
);
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const r = Object.getPrototypeOf, i = (K, ge, Ee) => {
    var ft;
    return Ee(K, ge.prototype) ? !0 : ((ft = K.constructor) === null || ft === void 0 ? void 0 : ft.name) === ge.name;
  }, u = (K) => {
    const ge = typeof K;
    return K === null ? "null" : ge === "object" && Array.isArray(K) ? "array" : ge === "object" && i(K, String, (Ee, ft) => ft.isPrototypeOf(Ee)) ? "string" : ge;
  }, h = (K) => (ge) => u(ge) === K, y = (K) => (ge) => typeof ge === K, k = (K) => (ge) => K === ge, _ = (K, ge) => L(K) && i(K, ge, (Ee, ft) => r(Ee) === ft), D = h("string"), L = h("object"), W = (K) => _(K, Object), se = h("array"), J = k(null), be = y("boolean"), ke = (K) => K == null, Ce = (K) => !ke(K), Q = y("function"), oe = y("number"), ae = (K, ge) => {
    if (se(K)) {
      for (let Ee = 0, ft = K.length; Ee < ft; ++Ee)
        if (!ge(K[Ee]))
          return !1;
      return !0;
    }
    return !1;
  }, G = () => {
  };
  class ve {
    constructor(ge, Ee) {
      this.tag = ge, this.value = Ee;
    }
    static some(ge) {
      return new ve(!0, ge);
    }
    static none() {
      return ve.singletonNone;
    }
    fold(ge, Ee) {
      return this.tag ? Ee(this.value) : ge();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(ge) {
      return this.tag ? ve.some(ge(this.value)) : ve.none();
    }
    bind(ge) {
      return this.tag ? ge(this.value) : ve.none();
    }
    exists(ge) {
      return this.tag && ge(this.value);
    }
    forall(ge) {
      return !this.tag || ge(this.value);
    }
    filter(ge) {
      return !this.tag || ge(this.value) ? this : ve.none();
    }
    getOr(ge) {
      return this.tag ? this.value : ge;
    }
    or(ge) {
      return this.tag ? this : ge;
    }
    getOrThunk(ge) {
      return this.tag ? this.value : ge();
    }
    orThunk(ge) {
      return this.tag ? this : ge();
    }
    getOrDie(ge) {
      if (this.tag)
        return this.value;
      throw new Error(ge ?? "Called getOrDie on None");
    }
    static from(ge) {
      return Ce(ge) ? ve.some(ge) : ve.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(ge) {
      this.tag && ge(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  ve.singletonNone = new ve(!1);
  const nt = Object.keys, Xe = Object.hasOwnProperty, te = (K, ge) => {
    const Ee = nt(K);
    for (let ft = 0, Cn = Ee.length; ft < Cn; ft++) {
      const Jo = Ee[ft], Ln = K[Jo];
      ge(Ln, Jo);
    }
  }, lt = (K) => (ge, Ee) => {
    K[Ee] = ge;
  }, ot = (K, ge, Ee, ft) => {
    te(K, (Cn, Jo) => {
      (ge(Cn, Jo) ? Ee : ft)(Cn, Jo);
    });
  }, Kt = (K, ge) => {
    const Ee = {};
    return ot(K, ge, lt(Ee), G), Ee;
  }, je = (K, ge) => Xe.call(K, ge), ye = (K, ge) => je(K, ge) && K[ge] !== void 0 && K[ge] !== null, dn = Array.prototype.push, wt = (K) => {
    const ge = [];
    for (let Ee = 0, ft = K.length; Ee < ft; ++Ee) {
      if (!se(K[Ee]))
        throw new Error("Arr.flatten item " + Ee + " was not an array, input: " + K);
      dn.apply(ge, K[Ee]);
    }
    return ge;
  }, qe = (K, ge) => ge >= 0 && ge < K.length ? ve.some(K[ge]) : ve.none(), B = (K) => qe(K, 0), mn = (K, ge) => {
    for (let Ee = 0; Ee < K.length; Ee++) {
      const ft = ge(K[Ee], Ee);
      if (ft.isSome())
        return ft;
    }
    return ve.none();
  };
  typeof window < "u" || Function("return this;")();
  const dt = (K, ge, Ee) => {
    if (D(Ee) || be(Ee) || oe(Ee))
      K.setAttribute(ge, Ee + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", ge, ":: Value ", Ee, ":: Element ", K), new Error("Attribute value was not simple");
  }, En = (K, ge, Ee) => {
    dt(K.dom, ge, Ee);
  }, tn = (K, ge) => {
    K.dom.removeAttribute(ge);
  }, Le = (K, ge) => {
    const ft = (ge || document).createElement("div");
    if (ft.innerHTML = K, !ft.hasChildNodes() || ft.childNodes.length > 1) {
      const Cn = "HTML does not have a single root node";
      throw console.error(Cn, K), new Error(Cn);
    }
    return St(ft.childNodes[0]);
  }, jt = (K, ge) => {
    const ft = (ge || document).createElement(K);
    return St(ft);
  }, Fn = (K, ge) => {
    const ft = (ge || document).createTextNode(K);
    return St(ft);
  }, St = (K) => {
    if (K == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: K };
  }, tt = {
    fromHtml: Le,
    fromTag: jt,
    fromText: Fn,
    fromDom: St,
    fromPoint: (K, ge, Ee) => ve.from(K.dom.elementFromPoint(ge, Ee)).map(St)
  };
  var mt = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), Y = tinymce.util.Tools.resolve("tinymce.util.URI");
  const Wo = (K) => K.length > 0, To = (K) => (ge) => ge.options.get(K), Ot = (K) => {
    const ge = K.options.register;
    ge("image_dimensions", {
      processor: "boolean",
      default: !0
    }), ge("image_advtab", {
      processor: "boolean",
      default: !1
    }), ge("image_uploadtab", {
      processor: "boolean",
      default: !0
    }), ge("image_prepend_url", {
      processor: "string",
      default: ""
    }), ge("image_class_list", { processor: "object[]" }), ge("image_description", {
      processor: "boolean",
      default: !0
    }), ge("image_title", {
      processor: "boolean",
      default: !1
    }), ge("image_caption", {
      processor: "boolean",
      default: !1
    }), ge("image_list", {
      processor: (Ee) => {
        const ft = Ee === !1 || D(Ee) || ae(Ee, L) || Q(Ee);
        return ft ? {
          value: Ee,
          valid: ft
        } : {
          valid: !1,
          message: "Must be false, a string, an array or a function."
        };
      },
      default: !1
    });
  }, Mt = To("image_dimensions"), zn = To("image_advtab"), At = To("image_uploadtab"), $n = To("image_prepend_url"), en = To("image_class_list"), Ue = To("image_description"), jn = To("image_title"), mo = To("image_caption"), xn = To("image_list"), Vt = To("a11y_advanced_options"), Ct = To("automatic_uploads"), Jn = (K) => Wo(K.options.get("images_upload_url")), Pn = (K) => Ce(K.options.get("images_upload_handler")), so = (K, ge) => Math.max(parseInt(K, 10), parseInt(ge, 10)), pr = (K) => new Promise((ge) => {
    const Ee = document.createElement("img"), ft = (Jo) => {
      Ee.onload = Ee.onerror = null, Ee.parentNode && Ee.parentNode.removeChild(Ee), ge(Jo);
    };
    Ee.onload = () => {
      const Jo = so(Ee.width, Ee.clientWidth), Ln = so(Ee.height, Ee.clientHeight), Rs = {
        width: Jo,
        height: Ln
      };
      ft(Promise.resolve(Rs));
    }, Ee.onerror = () => {
      ft(Promise.reject(`Failed to get image dimensions for: ${K}`));
    };
    const Cn = Ee.style;
    Cn.visibility = "hidden", Cn.position = "fixed", Cn.bottom = Cn.left = "0px", Cn.width = Cn.height = "auto", document.body.appendChild(Ee), Ee.src = K;
  }), nr = (K) => (K && (K = K.replace(/px$/, "")), K), Ko = (K) => (K.length > 0 && /^[0-9]+$/.test(K) && (K += "px"), K), Qo = (K) => {
    if (K.margin) {
      const ge = String(K.margin).split(" ");
      switch (ge.length) {
        case 1:
          K["margin-top"] = K["margin-top"] || ge[0], K["margin-right"] = K["margin-right"] || ge[0], K["margin-bottom"] = K["margin-bottom"] || ge[0], K["margin-left"] = K["margin-left"] || ge[0];
          break;
        case 2:
          K["margin-top"] = K["margin-top"] || ge[0], K["margin-right"] = K["margin-right"] || ge[1], K["margin-bottom"] = K["margin-bottom"] || ge[0], K["margin-left"] = K["margin-left"] || ge[1];
          break;
        case 3:
          K["margin-top"] = K["margin-top"] || ge[0], K["margin-right"] = K["margin-right"] || ge[1], K["margin-bottom"] = K["margin-bottom"] || ge[2], K["margin-left"] = K["margin-left"] || ge[1];
          break;
        case 4:
          K["margin-top"] = K["margin-top"] || ge[0], K["margin-right"] = K["margin-right"] || ge[1], K["margin-bottom"] = K["margin-bottom"] || ge[2], K["margin-left"] = K["margin-left"] || ge[3];
      }
      delete K.margin;
    }
    return K;
  }, Mr = (K, ge) => {
    const Ee = xn(K);
    D(Ee) ? fetch(Ee).then((ft) => {
      ft.ok && ft.json().then(ge);
    }) : Q(Ee) ? Ee(ge) : ge(Ee);
  }, at = (K, ge, Ee) => {
    const ft = () => {
      Ee.onload = Ee.onerror = null, K.selection && (K.selection.select(Ee), K.nodeChanged());
    };
    Ee.onload = () => {
      !ge.width && !ge.height && Mt(K) && K.dom.setAttribs(Ee, {
        width: String(Ee.clientWidth),
        height: String(Ee.clientHeight)
      }), ft();
    }, Ee.onerror = ft;
  }, kt = (K) => new Promise((ge, Ee) => {
    const ft = new FileReader();
    ft.onload = () => {
      ge(ft.result);
    }, ft.onerror = () => {
      var Cn;
      Ee((Cn = ft.error) === null || Cn === void 0 ? void 0 : Cn.message);
    }, ft.readAsDataURL(K);
  }), yn = (K) => K.nodeName === "IMG" && (K.hasAttribute("data-mce-object") || K.hasAttribute("data-mce-placeholder")), pn = (K, ge) => {
    const Ee = K.options.get;
    return Y.isDomSafe(ge, "img", {
      allow_html_data_urls: Ee("allow_html_data_urls"),
      allow_script_urls: Ee("allow_script_urls"),
      allow_svg_data_urls: Ee("allow_svg_data_urls")
    });
  }, Oo = mt.DOM, hr = (K) => K.style.marginLeft && K.style.marginRight && K.style.marginLeft === K.style.marginRight ? nr(K.style.marginLeft) : "", or = (K) => K.style.marginTop && K.style.marginBottom && K.style.marginTop === K.style.marginBottom ? nr(K.style.marginTop) : "", Ir = (K) => K.style.borderWidth ? nr(K.style.borderWidth) : "", Zo = (K, ge) => {
    var Ee;
    return K.hasAttribute(ge) && (Ee = K.getAttribute(ge)) !== null && Ee !== void 0 ? Ee : "";
  }, Tr = (K) => K.parentNode !== null && K.parentNode.nodeName === "FIGURE", Ht = (K, ge, Ee) => {
    Ee === "" || Ee === null ? K.removeAttribute(ge) : K.setAttribute(ge, Ee);
  }, Ho = (K) => {
    const ge = Oo.create("figure", { class: "image" });
    Oo.insertAfter(ge, K), ge.appendChild(K), ge.appendChild(Oo.create("figcaption", { contentEditable: "true" }, "Caption")), ge.contentEditable = "false";
  }, As = (K) => {
    const ge = K.parentNode;
    Ce(ge) && (Oo.insertAfter(K, ge), Oo.remove(ge));
  }, ra = (K) => {
    Tr(K) ? As(K) : Ho(K);
  }, qs = (K, ge) => {
    const Ee = K.getAttribute("style"), ft = ge(Ee !== null ? Ee : "");
    ft.length > 0 ? (K.setAttribute("style", ft), K.setAttribute("data-mce-style", ft)) : K.removeAttribute("style");
  }, Ks = (K, ge) => (Ee, ft, Cn) => {
    const Jo = Ee.style;
    Jo[ft] ? (Jo[ft] = Ko(Cn), qs(Ee, ge)) : Ht(Ee, ft, Cn);
  }, kr = (K, ge) => K.style[ge] ? nr(K.style[ge]) : Zo(K, ge), xa = (K, ge) => {
    const Ee = Ko(ge);
    K.style.marginLeft = Ee, K.style.marginRight = Ee;
  }, ca = (K, ge) => {
    const Ee = Ko(ge);
    K.style.marginTop = Ee, K.style.marginBottom = Ee;
  }, Or = (K, ge) => {
    const Ee = Ko(ge);
    K.style.borderWidth = Ee;
  }, Xn = (K, ge) => {
    K.style.borderStyle = ge;
  }, Ss = (K) => {
    var ge;
    return (ge = K.style.borderStyle) !== null && ge !== void 0 ? ge : "";
  }, Ke = (K) => Ce(K) && K.nodeName === "FIGURE", bt = (K) => K.nodeName === "IMG", gn = (K) => Oo.getAttrib(K, "alt").length === 0 && Oo.getAttrib(K, "role") === "presentation", Tn = (K) => gn(K) ? "" : Zo(K, "alt"), Po = () => ({
    src: "",
    alt: "",
    title: "",
    width: "",
    height: "",
    class: "",
    style: "",
    caption: !1,
    hspace: "",
    vspace: "",
    border: "",
    borderStyle: "",
    isDecorative: !1
  }), cr = (K, ge) => {
    var Ee;
    const ft = document.createElement("img");
    return Ht(ft, "style", ge.style), (hr(ft) || ge.hspace !== "") && xa(ft, ge.hspace), (or(ft) || ge.vspace !== "") && ca(ft, ge.vspace), (Ir(ft) || ge.border !== "") && Or(ft, ge.border), (Ss(ft) || ge.borderStyle !== "") && Xn(ft, ge.borderStyle), K((Ee = ft.getAttribute("style")) !== null && Ee !== void 0 ? Ee : "");
  }, ea = (K, ge) => {
    const Ee = document.createElement("img");
    if (_t(K, {
      ...ge,
      caption: !1
    }, Ee), Re(Ee, ge.alt, ge.isDecorative), ge.caption) {
      const ft = Oo.create("figure", { class: "image" });
      return ft.appendChild(Ee), ft.appendChild(Oo.create("figcaption", { contentEditable: "true" }, "Caption")), ft.contentEditable = "false", ft;
    } else
      return Ee;
  }, ta = (K, ge) => ({
    src: Zo(ge, "src"),
    alt: Tn(ge),
    title: Zo(ge, "title"),
    width: kr(ge, "width"),
    height: kr(ge, "height"),
    class: Zo(ge, "class"),
    style: K(Zo(ge, "style")),
    caption: Tr(ge),
    hspace: hr(ge),
    vspace: or(ge),
    border: Ir(ge),
    borderStyle: Ss(ge),
    isDecorative: gn(ge)
  }), Ps = (K, ge, Ee, ft, Cn) => {
    Ee[ft] !== ge[ft] && Cn(K, ft, String(Ee[ft]));
  }, Re = (K, ge, Ee) => {
    if (Ee) {
      Oo.setAttrib(K, "role", "presentation");
      const ft = tt.fromDom(K);
      En(ft, "alt", "");
    } else {
      if (J(ge)) {
        const ft = tt.fromDom(K);
        tn(ft, "alt");
      } else {
        const ft = tt.fromDom(K);
        En(ft, "alt", ge);
      }
      Oo.getAttrib(K, "role") === "presentation" && Oo.setAttrib(K, "role", "");
    }
  }, Oe = (K, ge, Ee) => {
    (Ee.alt !== ge.alt || Ee.isDecorative !== ge.isDecorative) && Re(K, Ee.alt, Ee.isDecorative);
  }, ct = (K, ge) => (Ee, ft, Cn) => {
    K(Ee, Cn), qs(Ee, ge);
  }, _t = (K, ge, Ee) => {
    const ft = ta(K, Ee);
    Ps(Ee, ft, ge, "caption", (Cn, Jo, Ln) => ra(Cn)), Ps(Ee, ft, ge, "src", Ht), Ps(Ee, ft, ge, "title", Ht), Ps(Ee, ft, ge, "width", Ks("width", K)), Ps(Ee, ft, ge, "height", Ks("height", K)), Ps(Ee, ft, ge, "class", Ht), Ps(Ee, ft, ge, "style", ct((Cn, Jo) => Ht(Cn, "style", Jo), K)), Ps(Ee, ft, ge, "hspace", ct(xa, K)), Ps(Ee, ft, ge, "vspace", ct(ca, K)), Ps(Ee, ft, ge, "border", ct(Or, K)), Ps(Ee, ft, ge, "borderStyle", ct(Xn, K)), Oe(Ee, ft, ge);
  }, Kn = (K, ge) => {
    const Ee = K.dom.styles.parse(ge), ft = Qo(Ee), Cn = K.dom.styles.parse(K.dom.styles.serialize(ft));
    return K.dom.styles.serialize(Cn);
  }, io = (K) => {
    const ge = K.selection.getNode(), Ee = K.dom.getParent(ge, "figure.image");
    return Ee ? K.dom.select("img", Ee)[0] : ge && (ge.nodeName !== "IMG" || yn(ge)) ? null : ge;
  }, Bo = (K, ge) => {
    var Ee;
    const ft = K.dom, Cn = Kt(K.schema.getTextBlockElements(), (Ln, Rs) => !K.schema.isValidChild(Rs, "figure")), Jo = ft.getParent(ge.parentNode, (Ln) => ye(Cn, Ln.nodeName), K.getBody());
    return Jo && (Ee = ft.split(Jo, ge)) !== null && Ee !== void 0 ? Ee : ge;
  }, Jr = (K) => {
    const ge = io(K);
    return ge ? ta((Ee) => Kn(K, Ee), ge) : Po();
  }, He = (K, ge) => {
    const Ee = ea((Cn) => Kn(K, Cn), ge);
    K.dom.setAttrib(Ee, "data-mce-id", "__mcenew"), K.focus(), K.selection.setContent(Ee.outerHTML);
    const ft = K.dom.select('*[data-mce-id="__mcenew"]')[0];
    if (K.dom.setAttrib(ft, "data-mce-id", null), Ke(ft)) {
      const Cn = Bo(K, ft);
      K.selection.select(Cn);
    } else
      K.selection.select(ft);
  }, Do = (K, ge) => {
    K.dom.setAttrib(ge, "src", ge.getAttribute("src"));
  }, Ne = (K, ge) => {
    if (ge) {
      const Ee = K.dom.is(ge.parentNode, "figure.image") ? ge.parentNode : ge;
      K.dom.remove(Ee), K.focus(), K.nodeChanged(), K.dom.isEmpty(K.getBody()) && (K.setContent(""), K.selection.setCursorLocation());
    }
  }, Ie = (K, ge) => {
    const Ee = io(K);
    if (Ee)
      if (_t((ft) => Kn(K, ft), ge, Ee), Do(K, Ee), Ke(Ee.parentNode)) {
        const ft = Ee.parentNode;
        Bo(K, ft), K.selection.select(Ee.parentNode);
      } else
        K.selection.select(Ee), at(K, ge, Ee);
  }, Bt = (K, ge) => {
    const Ee = ge.src;
    return {
      ...ge,
      src: pn(K, Ee) ? Ee : ""
    };
  }, Wt = (K, ge) => {
    const Ee = io(K);
    if (Ee) {
      const Cn = {
        ...ta((Ln) => Kn(K, Ln), Ee),
        ...ge
      }, Jo = Bt(K, Cn);
      Cn.src ? Ie(K, Jo) : Ne(K, Ee);
    } else ge.src && He(K, {
      ...Po(),
      ...ge
    });
  }, Gn = ((K) => (...ge) => {
    if (ge.length === 0)
      throw new Error("Can't merge zero objects");
    const Ee = {};
    for (let ft = 0; ft < ge.length; ft++) {
      const Cn = ge[ft];
      for (const Jo in Cn)
        je(Cn, Jo) && (Ee[Jo] = K(Ee[Jo], Cn[Jo]));
    }
    return Ee;
  })((K, ge) => W(K) && W(ge) ? Gn(K, ge) : ge);
  var qn = tinymce.util.Tools.resolve("tinymce.util.ImageUploader"), Qn = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const lo = (K) => D(K.value) ? K.value : "", rr = (K) => D(K.text) ? K.text : D(K.title) ? K.title : "", Kr = (K, ge) => {
    const Ee = [];
    return Qn.each(K, (ft) => {
      const Cn = rr(ft);
      if (ft.menu !== void 0) {
        const Jo = Kr(ft.menu, ge);
        Ee.push({
          text: Cn,
          items: Jo
        });
      } else {
        const Jo = ge(ft);
        Ee.push({
          text: Cn,
          value: Jo
        });
      }
    }), Ee;
  }, Wa = (K = lo) => (ge) => ge ? ve.from(ge).map((Ee) => Kr(Ee, K)) : ve.none(), Ei = (K) => Wa(lo)(K), Ti = (K) => je(K, "items"), ko = (K, ge) => mn(K, (Ee) => Ti(Ee) ? ko(Ee.items, ge) : Ee.value === ge ? ve.some(Ee) : ve.none()), Fr = {
    sanitizer: Wa,
    sanitize: Ei,
    findEntry: (K, ge) => K.bind((Ee) => ko(Ee, ge))
  }, ua = { makeTab: (K) => ({
    title: "Advanced",
    name: "advanced",
    items: [{
      type: "grid",
      columns: 2,
      items: [
        {
          type: "input",
          label: "Vertical space",
          name: "vspace",
          inputMode: "numeric"
        },
        {
          type: "input",
          label: "Horizontal space",
          name: "hspace",
          inputMode: "numeric"
        },
        {
          type: "input",
          label: "Border width",
          name: "border",
          inputMode: "numeric"
        },
        {
          type: "listbox",
          name: "borderstyle",
          label: "Border style",
          items: [
            {
              text: "Select...",
              value: ""
            },
            {
              text: "Solid",
              value: "solid"
            },
            {
              text: "Dotted",
              value: "dotted"
            },
            {
              text: "Dashed",
              value: "dashed"
            },
            {
              text: "Double",
              value: "double"
            },
            {
              text: "Groove",
              value: "groove"
            },
            {
              text: "Ridge",
              value: "ridge"
            },
            {
              text: "Inset",
              value: "inset"
            },
            {
              text: "Outset",
              value: "outset"
            },
            {
              text: "None",
              value: "none"
            },
            {
              text: "Hidden",
              value: "hidden"
            }
          ]
        }
      ]
    }]
  }) }, vs = (K) => {
    const ge = Fr.sanitizer((Ns) => K.convertURL(Ns.value || Ns.url || "", "src")), Ee = new Promise((Ns) => {
      Mr(K, (xc) => {
        Ns(ge(xc).map((Bs) => wt([
          [{
            text: "None",
            value: ""
          }],
          Bs
        ])));
      });
    }), ft = Fr.sanitize(en(K)), Cn = zn(K), Jo = At(K), Ln = Jn(K), Rs = Pn(K), Gt = Jr(K), fs = Ue(K), vi = jn(K), ks = Mt(K), ga = mo(K), Il = Vt(K), xr = Ct(K), yi = ve.some($n(K)).filter((Ns) => D(Ns) && Ns.length > 0);
    return Ee.then((Ns) => ({
      image: Gt,
      imageList: Ns,
      classList: ft,
      hasAdvTab: Cn,
      hasUploadTab: Jo,
      hasUploadUrl: Ln,
      hasUploadHandler: Rs,
      hasDescription: fs,
      hasImageTitle: vi,
      hasDimensions: ks,
      hasImageCaption: ga,
      prependURL: yi,
      hasAccessibilityOptions: Il,
      automaticUploads: xr
    }));
  }, es = (K) => {
    const ge = {
      name: "src",
      type: "urlinput",
      filetype: "image",
      label: "Source",
      picker_text: "Browse files"
    }, Ee = K.imageList.map((vi) => ({
      name: "images",
      type: "listbox",
      label: "Image list",
      items: vi
    })), ft = {
      name: "alt",
      type: "input",
      label: "Alternative description",
      enabled: !(K.hasAccessibilityOptions && K.image.isDecorative)
    }, Cn = {
      name: "title",
      type: "input",
      label: "Image title"
    }, Jo = {
      name: "dimensions",
      type: "sizeinput"
    }, Ln = {
      type: "label",
      label: "Accessibility",
      items: [{
        name: "isDecorative",
        type: "checkbox",
        label: "Image is decorative"
      }]
    }, Rs = K.classList.map((vi) => ({
      name: "classes",
      type: "listbox",
      label: "Class",
      items: vi
    })), Gt = {
      type: "label",
      label: "Caption",
      items: [{
        type: "checkbox",
        name: "caption",
        label: "Show caption"
      }]
    }, fs = (vi) => vi ? {
      type: "grid",
      columns: 2
    } : { type: "panel" };
    return wt([
      [ge],
      Ee.toArray(),
      K.hasAccessibilityOptions && K.hasDescription ? [Ln] : [],
      K.hasDescription ? [ft] : [],
      K.hasImageTitle ? [Cn] : [],
      K.hasDimensions ? [Jo] : [],
      [{
        ...fs(K.classList.isSome() && K.hasImageCaption),
        items: wt([
          Rs.toArray(),
          K.hasImageCaption ? [Gt] : []
        ])
      }]
    ]);
  }, vc = {
    makeTab: (K) => ({
      title: "General",
      name: "general",
      items: es(K)
    }),
    makeItems: es
  }, ka = { makeTab: (K) => ({
    title: "Upload",
    name: "upload",
    items: [{
      type: "dropzone",
      name: "fileinput"
    }]
  }) }, ii = (K) => ({
    prevImage: Fr.findEntry(K.imageList, K.image.src),
    prevAlt: K.image.alt,
    open: !0
  }), na = (K) => ({
    src: {
      value: K.src,
      meta: {}
    },
    images: K.src,
    alt: K.alt,
    title: K.title,
    dimensions: {
      width: K.width,
      height: K.height
    },
    classes: K.class,
    caption: K.caption,
    style: K.style,
    vspace: K.vspace,
    border: K.border,
    hspace: K.hspace,
    borderstyle: K.borderStyle,
    fileinput: [],
    isDecorative: K.isDecorative
  }), Oi = (K, ge) => ({
    src: K.src.value,
    alt: (K.alt === null || K.alt.length === 0) && ge ? null : K.alt,
    title: K.title,
    width: K.dimensions.width,
    height: K.dimensions.height,
    class: K.classes,
    style: K.style,
    caption: K.caption,
    hspace: K.hspace,
    vspace: K.vspace,
    border: K.border,
    borderStyle: K.borderstyle,
    isDecorative: K.isDecorative
  }), cl = (K, ge) => /^(?:[a-zA-Z]+:)?\/\//.test(ge) ? ve.none() : K.prependURL.bind((Ee) => ge.substring(0, Ee.length) !== Ee ? ve.some(Ee + ge) : ve.none()), Za = (K, ge) => {
    const Ee = ge.getData();
    cl(K, Ee.src.value).each((ft) => {
      ge.setData({
        src: {
          value: ft,
          meta: Ee.src.meta
        }
      });
    });
  }, Ai = (K, ge, Ee) => {
    K.hasDescription && D(Ee.alt) && (ge.alt = Ee.alt), K.hasAccessibilityOptions && (ge.isDecorative = Ee.isDecorative || ge.isDecorative || !1), K.hasImageTitle && D(Ee.title) && (ge.title = Ee.title), K.hasDimensions && (D(Ee.width) && (ge.dimensions.width = Ee.width), D(Ee.height) && (ge.dimensions.height = Ee.height)), D(Ee.class) && Fr.findEntry(K.classList, Ee.class).each((ft) => {
      ge.classes = ft.value;
    }), K.hasImageCaption && be(Ee.caption) && (ge.caption = Ee.caption), K.hasAdvTab && (D(Ee.style) && (ge.style = Ee.style), D(Ee.vspace) && (ge.vspace = Ee.vspace), D(Ee.border) && (ge.border = Ee.border), D(Ee.hspace) && (ge.hspace = Ee.hspace), D(Ee.borderstyle) && (ge.borderstyle = Ee.borderstyle));
  }, Ui = (K, ge) => {
    const Ee = ge.getData(), ft = Ee.src.meta;
    if (ft !== void 0) {
      const Cn = Gn({}, Ee);
      Ai(K, Cn, ft), ge.setData(Cn);
    }
  }, au = (K, ge, Ee, ft) => {
    const Cn = ft.getData(), Jo = Cn.src.value, Ln = Cn.src.meta || {};
    !Ln.width && !Ln.height && ge.hasDimensions && (Wo(Jo) ? K.imageSize(Jo).then((Rs) => {
      Ee.open && ft.setData({ dimensions: Rs });
    }).catch((Rs) => console.error(Rs)) : ft.setData({
      dimensions: {
        width: "",
        height: ""
      }
    }));
  }, gi = (K, ge, Ee) => {
    const ft = Ee.getData(), Cn = Fr.findEntry(K.imageList, ft.src.value);
    ge.prevImage = Cn, Ee.setData({ images: Cn.map((Jo) => Jo.value).getOr("") });
  }, Ml = (K, ge, Ee, ft) => {
    Za(ge, ft), Ui(ge, ft), au(K, ge, Ee, ft), gi(ge, Ee, ft);
  }, $a = (K, ge, Ee, ft) => {
    const Cn = ft.getData(), Jo = Fr.findEntry(ge.imageList, Cn.images);
    Jo.each((Ln) => {
      Cn.alt === "" || Ee.prevImage.map((Gt) => Gt.text === Cn.alt).getOr(!1) ? Ln.value === "" ? ft.setData({
        src: Ln,
        alt: Ee.prevAlt
      }) : ft.setData({
        src: Ln,
        alt: Ln.text
      }) : ft.setData({ src: Ln });
    }), Ee.prevImage = Jo, Ml(K, ge, Ee, ft);
  }, Wi = (K, ge, Ee, ft) => {
    const Cn = ft.getData();
    ft.block("Uploading image"), B(Cn.fileinput).fold(() => {
      ft.unblock();
    }, (Jo) => {
      const Ln = URL.createObjectURL(Jo), Rs = () => {
        ft.unblock(), URL.revokeObjectURL(Ln);
      }, Gt = (fs) => {
        ft.setData({
          src: {
            value: fs,
            meta: {}
          }
        }), ft.showTab("general"), Ml(K, ge, Ee, ft), ft.focus("src");
      };
      kt(Jo).then((fs) => {
        const vi = K.createBlobCache(Jo, Ln, fs);
        ge.automaticUploads ? K.uploadImage(vi).then((ks) => {
          Gt(ks.url), Rs();
        }).catch((ks) => {
          Rs(), K.alertErr(ks);
        }) : (K.addToBlobCache(vi), Gt(vi.blobUri()), ft.unblock());
      });
    });
  }, Kl = (K, ge, Ee) => (ft, Cn) => {
    Cn.name === "src" ? Ml(K, ge, Ee, ft) : Cn.name === "images" ? $a(K, ge, Ee, ft) : Cn.name === "alt" ? Ee.prevAlt = ft.getData().alt : Cn.name === "fileinput" ? Wi(K, ge, Ee, ft) : Cn.name === "isDecorative" && ft.setEnabled("alt", !ft.getData().isDecorative);
  }, yc = (K) => () => {
    K.open = !1;
  }, ld = (K) => K.hasAdvTab || K.hasUploadUrl || K.hasUploadHandler ? {
    type: "tabpanel",
    tabs: wt([
      [vc.makeTab(K)],
      K.hasAdvTab ? [ua.makeTab(K)] : [],
      K.hasUploadTab && (K.hasUploadUrl || K.hasUploadHandler) ? [ka.makeTab(K)] : []
    ])
  } : {
    type: "panel",
    items: vc.makeItems(K)
  }, iu = (K, ge, Ee) => (ft) => {
    const Cn = Gn(na(ge.image), ft.getData()), Jo = {
      ...Cn,
      style: cr(Ee.normalizeCss, Oi(Cn, !1))
    };
    K.execCommand("mceUpdateImage", !1, Oi(Jo, ge.hasAccessibilityOptions)), K.editorUpload.uploadImagesAuto(), ft.close();
  }, bi = (K) => (ge) => pn(K, ge) ? pr(K.documentBaseURI.toAbsolute(ge)).then((Ee) => ({
    width: String(Ee.width),
    height: String(Ee.height)
  })) : Promise.resolve({
    width: "",
    height: ""
  }), Ru = (K) => (ge, Ee, ft) => {
    var Cn;
    return K.editorUpload.blobCache.create({
      blob: ge,
      blobUri: Ee,
      name: (Cn = ge.name) === null || Cn === void 0 ? void 0 : Cn.replace(/\.[^\.]+$/, ""),
      filename: ge.name,
      base64: ft.split(",")[1]
    });
  }, le = (K) => (ge) => {
    K.editorUpload.blobCache.add(ge);
  }, Ae = (K) => (ge) => {
    K.windowManager.alert(ge);
  }, Ze = (K) => (ge) => Kn(K, ge), Dt = (K) => (ge) => K.dom.parseStyle(ge), Yt = (K) => (ge, Ee) => K.dom.serializeStyle(ge, Ee), Wn = (K) => (ge) => qn(K).upload([ge], !1).then((Ee) => {
    var ft;
    return Ee.length === 0 ? Promise.reject("Failed to upload image") : Ee[0].status === !1 ? Promise.reject((ft = Ee[0].error) === null || ft === void 0 ? void 0 : ft.message) : Ee[0];
  }), lr = (K) => {
    const ge = {
      imageSize: bi(K),
      addToBlobCache: le(K),
      createBlobCache: Ru(K),
      alertErr: Ae(K),
      normalizeCss: Ze(K),
      parseStyle: Dt(K),
      serializeStyle: Yt(K),
      uploadImage: Wn(K)
    };
    return { open: () => {
      vs(K).then((ft) => {
        const Cn = ii(ft);
        return {
          title: "Insert/Edit Image",
          size: "normal",
          body: ld(ft),
          buttons: [
            {
              type: "cancel",
              name: "cancel",
              text: "Cancel"
            },
            {
              type: "submit",
              name: "save",
              text: "Save",
              primary: !0
            }
          ],
          initialData: na(ft.image),
          onSubmit: iu(K, ft, ge),
          onChange: Kl(ge, ft, Cn),
          onClose: yc(Cn)
        };
      }).then(K.windowManager.open);
    } };
  }, yr = (K) => {
    K.addCommand("mceImage", lr(K).open), K.addCommand("mceUpdateImage", (ge, Ee) => {
      K.undoManager.transact(() => Wt(K, Ee));
    });
  }, Uo = (K) => {
    const ge = K.attr("class");
    return Ce(ge) && /\bimage\b/.test(ge);
  }, Yr = (K) => (ge) => {
    let Ee = ge.length;
    const ft = (Cn) => {
      Cn.attr("contenteditable", K ? "true" : null);
    };
    for (; Ee--; ) {
      const Cn = ge[Ee];
      Uo(Cn) && (Cn.attr("contenteditable", K ? "false" : null), Qn.each(Cn.getAll("figcaption"), ft));
    }
  }, Ds = (K) => {
    K.on("PreInit", () => {
      K.parser.addNodeFilter("figure", Yr(!0)), K.serializer.addNodeFilter("figure", Yr(!1));
    });
  }, rn = (K) => (ge) => {
    const Ee = () => {
      ge.setEnabled(K.selection.isEditable());
    };
    return K.on("NodeChange", Ee), Ee(), () => {
      K.off("NodeChange", Ee);
    };
  }, cd = (K) => {
    K.ui.registry.addToggleButton("image", {
      icon: "image",
      tooltip: "Insert/edit image",
      onAction: lr(K).open,
      onSetup: (ge) => {
        ge.setActive(Ce(io(K)));
        const Ee = K.selection.selectorChangedWithUnbind("img:not([data-mce-object]):not([data-mce-placeholder]),figure.image", ge.setActive).unbind, ft = rn(K)(ge);
        return () => {
          Ee(), ft();
        };
      }
    }), K.ui.registry.addMenuItem("image", {
      icon: "image",
      text: "Image...",
      onAction: lr(K).open,
      onSetup: rn(K)
    }), K.ui.registry.addContextMenu("image", { update: (ge) => K.selection.isEditable() && (Ke(ge) || bt(ge) && !yn(ge)) ? ["image"] : [] });
  };
  var os = () => {
    o.add("image", (K) => {
      Ot(K), Ds(K), cd(K), yr(K);
    });
  };
  os();
})();
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const r = (le, Ae, Ze) => {
    var Dt;
    return Ze(le, Ae.prototype) ? !0 : ((Dt = le.constructor) === null || Dt === void 0 ? void 0 : Dt.name) === Ae.name;
  }, i = (le) => {
    const Ae = typeof le;
    return le === null ? "null" : Ae === "object" && Array.isArray(le) ? "array" : Ae === "object" && r(le, String, (Ze, Dt) => Dt.isPrototypeOf(Ze)) ? "string" : Ae;
  }, u = (le) => (Ae) => i(Ae) === le, h = (le) => (Ae) => typeof Ae === le, y = (le) => (Ae) => le === Ae, k = u("string"), _ = u("object"), D = u("array"), L = y(null), W = h("boolean"), se = (le) => le == null, J = (le) => !se(le), be = h("function"), ke = (le, Ae) => {
    if (D(le)) {
      for (let Ze = 0, Dt = le.length; Ze < Dt; ++Ze)
        if (!Ae(le[Ze]))
          return !1;
      return !0;
    }
    return !1;
  }, Ce = () => {
  }, Q = (le) => () => le, oe = (le, Ae) => le === Ae;
  class ae {
    constructor(Ae, Ze) {
      this.tag = Ae, this.value = Ze;
    }
    static some(Ae) {
      return new ae(!0, Ae);
    }
    static none() {
      return ae.singletonNone;
    }
    fold(Ae, Ze) {
      return this.tag ? Ze(this.value) : Ae();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(Ae) {
      return this.tag ? ae.some(Ae(this.value)) : ae.none();
    }
    bind(Ae) {
      return this.tag ? Ae(this.value) : ae.none();
    }
    exists(Ae) {
      return this.tag && Ae(this.value);
    }
    forall(Ae) {
      return !this.tag || Ae(this.value);
    }
    filter(Ae) {
      return !this.tag || Ae(this.value) ? this : ae.none();
    }
    getOr(Ae) {
      return this.tag ? this.value : Ae;
    }
    or(Ae) {
      return this.tag ? this : Ae;
    }
    getOrThunk(Ae) {
      return this.tag ? this.value : Ae();
    }
    orThunk(Ae) {
      return this.tag ? this : Ae();
    }
    getOrDie(Ae) {
      if (this.tag)
        return this.value;
      throw new Error(Ae ?? "Called getOrDie on None");
    }
    static from(Ae) {
      return J(Ae) ? ae.some(Ae) : ae.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(Ae) {
      this.tag && Ae(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  ae.singletonNone = new ae(!1);
  const G = Array.prototype.indexOf, ve = Array.prototype.push, nt = (le, Ae) => G.call(le, Ae), Xe = (le, Ae) => nt(le, Ae) > -1, te = (le, Ae) => {
    const Ze = le.length, Dt = new Array(Ze);
    for (let Yt = 0; Yt < Ze; Yt++) {
      const Wn = le[Yt];
      Dt[Yt] = Ae(Wn, Yt);
    }
    return Dt;
  }, lt = (le, Ae) => {
    for (let Ze = 0, Dt = le.length; Ze < Dt; Ze++) {
      const Yt = le[Ze];
      Ae(Yt, Ze);
    }
  }, ot = (le, Ae, Ze) => (lt(le, (Dt, Yt) => {
    Ze = Ae(Ze, Dt, Yt);
  }), Ze), Kt = (le) => {
    const Ae = [];
    for (let Ze = 0, Dt = le.length; Ze < Dt; ++Ze) {
      if (!D(le[Ze]))
        throw new Error("Arr.flatten item " + Ze + " was not an array, input: " + le);
      ve.apply(Ae, le[Ze]);
    }
    return Ae;
  }, je = (le, Ae) => Kt(te(le, Ae)), ye = (le, Ae) => {
    for (let Ze = 0; Ze < le.length; Ze++) {
      const Dt = Ae(le[Ze], Ze);
      if (Dt.isSome())
        return Dt;
    }
    return ae.none();
  }, dn = (le, Ae, Ze = oe) => le.exists((Dt) => Ze(Dt, Ae)), wt = (le) => {
    const Ae = [], Ze = (Dt) => {
      Ae.push(Dt);
    };
    for (let Dt = 0; Dt < le.length; Dt++)
      le[Dt].each(Ze);
    return Ae;
  }, qe = (le, Ae) => le ? ae.some(Ae) : ae.none(), B = (le) => (Ae) => Ae.options.get(le), mn = (le) => {
    const Ae = le.options.register;
    Ae("link_assume_external_targets", {
      processor: (Ze) => {
        const Dt = k(Ze) || W(Ze);
        return Dt ? Ze === !0 ? {
          value: 1,
          valid: Dt
        } : Ze === "http" || Ze === "https" ? {
          value: Ze,
          valid: Dt
        } : {
          value: 0,
          valid: Dt
        } : {
          valid: !1,
          message: "Must be a string or a boolean."
        };
      },
      default: !1
    }), Ae("link_context_toolbar", {
      processor: "boolean",
      default: !1
    }), Ae("link_list", { processor: (Ze) => k(Ze) || be(Ze) || ke(Ze, _) }), Ae("link_default_target", { processor: "string" }), Ae("link_default_protocol", {
      processor: "string",
      default: "https"
    }), Ae("link_target_list", {
      processor: (Ze) => W(Ze) || ke(Ze, _),
      default: !0
    }), Ae("link_rel_list", {
      processor: "object[]",
      default: []
    }), Ae("link_class_list", {
      processor: "object[]",
      default: []
    }), Ae("link_title", {
      processor: "boolean",
      default: !0
    }), Ae("allow_unsafe_link_target", {
      processor: "boolean",
      default: !1
    }), Ae("link_quicklink", {
      processor: "boolean",
      default: !1
    });
  }, dt = B("link_assume_external_targets"), En = B("link_context_toolbar"), tn = B("link_list"), Le = B("link_default_target"), jt = B("link_default_protocol"), Fn = B("link_target_list"), St = B("link_rel_list"), on = B("link_class_list"), tt = B("link_title"), mt = B("allow_unsafe_link_target"), Y = B("link_quicklink"), Wo = Object.keys, To = Object.hasOwnProperty, Ot = (le, Ae) => {
    const Ze = Wo(le);
    for (let Dt = 0, Yt = Ze.length; Dt < Yt; Dt++) {
      const Wn = Ze[Dt], lr = le[Wn];
      Ae(lr, Wn);
    }
  }, Mt = (le) => (Ae, Ze) => {
    le[Ze] = Ae;
  }, zn = (le, Ae, Ze, Dt) => {
    Ot(le, (Yt, Wn) => {
      (Ae(Yt, Wn) ? Ze : Dt)(Yt, Wn);
    });
  }, At = (le, Ae) => {
    const Ze = {};
    return zn(le, Ae, Mt(Ze), Ce), Ze;
  }, $n = (le, Ae) => To.call(le, Ae), en = (le, Ae) => $n(le, Ae) && le[Ae] !== void 0 && le[Ae] !== null;
  var Ue = tinymce.util.Tools.resolve("tinymce.util.URI"), jn = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker"), mo = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const xn = (le) => J(le) && le.nodeName.toLowerCase() === "a", Vt = (le) => xn(le) && !!Pn(le), Ct = (le, Ae) => {
    if (le.collapsed)
      return [];
    {
      const Ze = le.cloneContents(), Dt = Ze.firstChild, Yt = new jn(Dt, Ze), Wn = [];
      let lr = Dt;
      do
        Ae(lr) && Wn.push(lr);
      while (lr = Yt.next());
      return Wn;
    }
  }, Jn = (le) => /^\w+:/i.test(le), Pn = (le) => {
    var Ae, Ze;
    return (Ze = (Ae = le.getAttribute("data-mce-href")) !== null && Ae !== void 0 ? Ae : le.getAttribute("href")) !== null && Ze !== void 0 ? Ze : "";
  }, so = (le, Ae) => {
    const Ze = ["noopener"], Dt = le ? le.split(/\s+/) : [], Yt = (Uo) => mo.trim(Uo.sort().join(" ")), Wn = (Uo) => (Uo = lr(Uo), Uo.length > 0 ? Uo.concat(Ze) : Ze), lr = (Uo) => Uo.filter((Yr) => mo.inArray(Ze, Yr) === -1), yr = Ae ? Wn(Dt) : lr(Dt);
    return yr.length > 0 ? Yt(yr) : "";
  }, pr = (le) => le.replace(/\uFEFF/g, ""), nr = (le, Ae) => (Ae = Ae || Mr(le.selection.getRng())[0] || le.selection.getNode(), Oo(Ae) ? ae.from(le.dom.select("a[href]", Ae)[0]) : ae.from(le.dom.getParent(Ae, "a[href]"))), Ko = (le, Ae) => nr(le, Ae).isSome(), Qo = (le, Ae) => {
    const Ze = Ae.fold(() => le.getContent({ format: "text" }), (Dt) => Dt.innerText || Dt.textContent || "");
    return pr(Ze);
  }, Mr = (le) => Ct(le, Vt), at = (le) => mo.grep(le, Vt), kt = (le) => at(le).length > 0, yn = (le) => Mr(le).length > 0, pn = (le) => {
    const Ae = le.schema.getTextInlineElements(), Ze = (Wn) => Wn.nodeType === 1 && !xn(Wn) && !$n(Ae, Wn.nodeName.toLowerCase());
    if (nr(le).exists((Wn) => Wn.hasAttribute("data-mce-block")))
      return !1;
    const Yt = le.selection.getRng();
    return Yt.collapsed ? !0 : Ct(Yt, Ze).length === 0;
  }, Oo = (le) => J(le) && le.nodeName === "FIGURE" && /\bimage\b/i.test(le.className), hr = (le) => ot([
    "title",
    "rel",
    "class",
    "target"
  ], (Ze, Dt) => (le[Dt].each((Yt) => {
    Ze[Dt] = Yt.length > 0 ? Yt : null;
  }), Ze), { href: le.href }), or = (le, Ae) => (Ae === "http" || Ae === "https") && !Jn(le) ? Ae + "://" + le : le, Ir = (le, Ae) => {
    const Ze = { ...Ae };
    if (St(le).length === 0 && !mt(le)) {
      const Dt = so(Ze.rel, Ze.target === "_blank");
      Ze.rel = Dt || null;
    }
    return ae.from(Ze.target).isNone() && Fn(le) === !1 && (Ze.target = Le(le)), Ze.href = or(Ze.href, dt(le)), Ze;
  }, Zo = (le, Ae, Ze, Dt) => {
    Ze.each((Yt) => {
      $n(Ae, "innerText") ? Ae.innerText = Yt : Ae.textContent = Yt;
    }), le.dom.setAttribs(Ae, Dt), le.selection.select(Ae);
  }, Tr = (le, Ae, Ze, Dt) => {
    const Yt = le.dom;
    Oo(Ae) ? ca(Yt, Ae, Dt) : Ze.fold(() => {
      le.execCommand("mceInsertLink", !1, Dt);
    }, (Wn) => {
      le.insertContent(Yt.createHTML("a", Dt, Yt.encode(Wn)));
    });
  }, Ht = (le, Ae, Ze) => {
    const Dt = le.selection.getNode(), Yt = nr(le, Dt), Wn = Ir(le, hr(Ze));
    le.undoManager.transact(() => {
      Ze.href === Ae.href && Ae.attach(), Yt.fold(() => {
        Tr(le, Dt, Ze.text, Wn);
      }, (lr) => {
        le.focus(), Zo(le, lr, Ze.text, Wn);
      });
    });
  }, Ho = (le) => {
    const Ae = le.dom, Ze = le.selection, Dt = Ze.getBookmark(), Yt = Ze.getRng().cloneRange(), Wn = Ae.getParent(Yt.startContainer, "a[href]", le.getBody()), lr = Ae.getParent(Yt.endContainer, "a[href]", le.getBody());
    Wn && Yt.setStartBefore(Wn), lr && Yt.setEndAfter(lr), Ze.setRng(Yt), le.execCommand("unlink"), Ze.moveToBookmark(Dt);
  }, As = (le) => {
    le.undoManager.transact(() => {
      const Ae = le.selection.getNode();
      Oo(Ae) ? xa(le, Ae) : Ho(le), le.focus();
    });
  }, ra = (le) => {
    const {
      class: Ae,
      href: Ze,
      rel: Dt,
      target: Yt,
      text: Wn,
      title: lr
    } = le;
    return At({
      class: Ae.getOrNull(),
      href: Ze,
      rel: Dt.getOrNull(),
      target: Yt.getOrNull(),
      text: Wn.getOrNull(),
      title: lr.getOrNull()
    }, (yr, Uo) => L(yr) === !1);
  }, qs = (le, Ae) => {
    const Ze = le.options.get, Dt = {
      allow_html_data_urls: Ze("allow_html_data_urls"),
      allow_script_urls: Ze("allow_script_urls"),
      allow_svg_data_urls: Ze("allow_svg_data_urls")
    }, Yt = Ae.href;
    return {
      ...Ae,
      href: Ue.isDomSafe(Yt, "a", Dt) ? Yt : ""
    };
  }, Ks = (le, Ae, Ze) => {
    const Dt = qs(le, Ze);
    le.hasPlugin("rtc", !0) ? le.execCommand("createlink", !1, ra(Dt)) : Ht(le, Ae, Dt);
  }, kr = (le) => {
    le.hasPlugin("rtc", !0) ? le.execCommand("unlink") : As(le);
  }, xa = (le, Ae) => {
    var Ze;
    const Dt = le.dom.select("img", Ae)[0];
    if (Dt) {
      const Yt = le.dom.getParents(Dt, "a[href]", Ae)[0];
      Yt && ((Ze = Yt.parentNode) === null || Ze === void 0 || Ze.insertBefore(Dt, Yt), le.dom.remove(Yt));
    }
  }, ca = (le, Ae, Ze) => {
    var Dt;
    const Yt = le.select("img", Ae)[0];
    if (Yt) {
      const Wn = le.create("a", Ze);
      (Dt = Yt.parentNode) === null || Dt === void 0 || Dt.insertBefore(Wn, Yt), Wn.appendChild(Yt);
    }
  }, Or = (le) => k(le.value) ? le.value : "", Xn = (le) => k(le.text) ? le.text : k(le.title) ? le.title : "", Ss = (le, Ae) => {
    const Ze = [];
    return mo.each(le, (Dt) => {
      const Yt = Xn(Dt);
      if (Dt.menu !== void 0) {
        const Wn = Ss(Dt.menu, Ae);
        Ze.push({
          text: Yt,
          items: Wn
        });
      } else {
        const Wn = Ae(Dt);
        Ze.push({
          text: Yt,
          value: Wn
        });
      }
    }), Ze;
  }, Ke = (le = Or) => (Ae) => ae.from(Ae).map((Ze) => Ss(Ze, le)), Tn = {
    sanitize: (le) => Ke(Or)(le),
    sanitizeWith: Ke,
    createUi: (le, Ae) => (Ze) => ({
      name: le,
      type: "listbox",
      label: Ae,
      items: Ze
    }),
    getValue: Or
  }, Po = (le) => en(le, "items"), cr = (le, Ae) => ye(Ae, (Ze) => Po(Ze) ? cr(le, Ze.items) : qe(Ze.value === le, Ze)), ea = (le, Ae, Ze, Dt) => {
    const Yt = Dt[Ae], Wn = le.length > 0;
    return Yt !== void 0 ? cr(Yt, Ze).map((lr) => ({
      url: {
        value: lr.value,
        meta: {
          text: Wn ? le : lr.text,
          attach: Ce
        }
      },
      text: Wn ? le : lr.text
    })) : ae.none();
  }, ta = (le, Ae) => Ae === "link" ? le.link : Ae === "anchor" ? le.anchor : ae.none(), Re = {
    init: (le, Ae) => {
      const Ze = {
        text: le.text,
        title: le.title
      }, Dt = (Uo) => {
        var Yr;
        return qe(Ze.title.length <= 0, ae.from((Yr = Uo.meta) === null || Yr === void 0 ? void 0 : Yr.title).getOr(""));
      }, Yt = (Uo) => {
        var Yr;
        return qe(Ze.text.length <= 0, ae.from((Yr = Uo.meta) === null || Yr === void 0 ? void 0 : Yr.text).getOr(Uo.value));
      }, Wn = (Uo) => {
        const Yr = Yt(Uo.url), Ds = Dt(Uo.url);
        return Yr.isSome() || Ds.isSome() ? ae.some({
          ...Yr.map((rn) => ({ text: rn })).getOr({}),
          ...Ds.map((rn) => ({ title: rn })).getOr({})
        }) : ae.none();
      }, lr = (Uo, Yr) => {
        const Ds = ta(Ae, Yr).getOr([]);
        return ea(Ze.text, Yr, Ds, Uo);
      };
      return { onChange: (Uo, Yr) => {
        const Ds = Yr.name;
        return Ds === "url" ? Wn(Uo()) : Xe([
          "anchor",
          "link"
        ], Ds) ? lr(Uo(), Ds) : ((Ds === "text" || Ds === "title") && (Ze[Ds] = Uo()[Ds]), ae.none());
      } };
    },
    getDelta: ea
  };
  var Oe = tinymce.util.Tools.resolve("tinymce.util.Delay");
  const ct = (le, Ae, Ze) => {
    const Dt = le.selection.getRng();
    Oe.setEditorTimeout(le, () => {
      le.windowManager.confirm(Ae, (Yt) => {
        le.selection.setRng(Dt), Ze(Yt);
      });
    });
  }, _t = (le) => {
    const Ae = le.href;
    return Ae.indexOf("@") > 0 && Ae.indexOf("/") === -1 && Ae.indexOf("mailto:") === -1 ? ae.some({
      message: "The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?",
      preprocess: (Dt) => ({
        ...Dt,
        href: "mailto:" + Ae
      })
    }) : ae.none();
  }, Kn = (le, Ae) => (Ze) => {
    const Dt = Ze.href;
    return le === 1 && !Jn(Dt) || le === 0 && /^\s*www(\.|\d\.)/i.test(Dt) ? ae.some({
      message: `The URL you entered seems to be an external link. Do you want to add the required ${Ae}:// prefix?`,
      preprocess: (Wn) => ({
        ...Wn,
        href: Ae + "://" + Dt
      })
    }) : ae.none();
  }, Bo = { preprocess: (le, Ae) => ye([
    _t,
    Kn(dt(le), jt(le))
  ], (Ze) => Ze(Ae)).fold(() => Promise.resolve(Ae), (Ze) => new Promise((Dt) => {
    ct(le, Ze.message, (Yt) => {
      Dt(Yt ? Ze.preprocess(Ae) : Ae);
    });
  })) }, He = { getAnchors: (le) => {
    const Ae = le.dom.select("a:not([href])"), Ze = je(Ae, (Dt) => {
      const Yt = Dt.name || Dt.id;
      return Yt ? [{
        text: Yt,
        value: "#" + Yt
      }] : [];
    });
    return Ze.length > 0 ? ae.some([{
      text: "None",
      value: ""
    }].concat(Ze)) : ae.none();
  } }, Ne = { getClasses: (le) => {
    const Ae = on(le);
    return Ae.length > 0 ? Tn.sanitize(Ae) : ae.none();
  } }, Ie = (le) => {
    try {
      return ae.some(JSON.parse(le));
    } catch {
      return ae.none();
    }
  }, Wt = { getLinks: (le) => {
    const Ae = (Dt) => le.convertURL(Dt.value || Dt.url || "", "href"), Ze = tn(le);
    return new Promise((Dt) => {
      k(Ze) ? fetch(Ze).then((Yt) => Yt.ok ? Yt.text().then(Ie) : Promise.reject()).then(Dt, () => Dt(ae.none())) : be(Ze) ? Ze((Yt) => Dt(ae.some(Yt))) : Dt(ae.from(Ze));
    }).then((Dt) => Dt.bind(Tn.sanitizeWith(Ae)).map((Yt) => Yt.length > 0 ? [{
      text: "None",
      value: ""
    }].concat(Yt) : Yt));
  } }, eo = { getRels: (le, Ae) => {
    const Ze = St(le);
    if (Ze.length > 0) {
      const Dt = dn(Ae, "_blank"), Yt = mt(le) === !1, Wn = (yr) => so(Tn.getValue(yr), Dt);
      return (Yt ? Tn.sanitizeWith(Wn) : Tn.sanitize)(Ze);
    }
    return ae.none();
  } }, Gn = [
    {
      text: "Current window",
      value: ""
    },
    {
      text: "New window",
      value: "_blank"
    }
  ], Qn = { getTargets: (le) => {
    const Ae = Fn(le);
    return D(Ae) ? Tn.sanitize(Ae).orThunk(() => ae.some(Gn)) : Ae === !1 ? ae.none() : ae.some(Gn);
  } }, lo = (le, Ae, Ze) => {
    const Dt = le.getAttrib(Ae, Ze);
    return Dt !== null && Dt.length > 0 ? ae.some(Dt) : ae.none();
  }, rr = (le, Ae) => {
    const Ze = le.dom, Yt = pn(le) ? ae.some(Qo(le.selection, Ae)) : ae.none(), Wn = Ae.bind((Ds) => ae.from(Ze.getAttrib(Ds, "href"))), lr = Ae.bind((Ds) => ae.from(Ze.getAttrib(Ds, "target"))), yr = Ae.bind((Ds) => lo(Ze, Ds, "rel")), Uo = Ae.bind((Ds) => lo(Ze, Ds, "class")), Yr = Ae.bind((Ds) => lo(Ze, Ds, "title"));
    return {
      url: Wn,
      text: Yt,
      title: Yr,
      target: lr,
      rel: yr,
      linkClass: Uo
    };
  }, Wa = { collect: (le, Ae) => Wt.getLinks(le).then((Ze) => {
    const Dt = rr(le, Ae);
    return {
      anchor: Dt,
      catalogs: {
        targets: Qn.getTargets(le),
        rels: eo.getRels(le, Dt.target),
        classes: Ne.getClasses(le),
        anchor: He.getAnchors(le),
        link: Ze
      },
      optNode: Ae,
      flags: { titleEnabled: tt(le) }
    };
  }) }, Ei = (le, Ae) => (Ze) => {
    const Dt = Ze.getData();
    if (!Dt.url.value) {
      kr(le), Ze.close();
      return;
    }
    const Yt = (yr) => ae.from(Dt[yr]).filter((Uo) => !dn(Ae.anchor[yr], Uo)), Wn = {
      href: Dt.url.value,
      text: Yt("text"),
      target: Yt("target"),
      rel: Yt("rel"),
      class: Yt("linkClass"),
      title: Yt("title")
    }, lr = {
      href: Dt.url.value,
      attach: Dt.url.meta !== void 0 && Dt.url.meta.attach ? Dt.url.meta.attach : Ce
    };
    Bo.preprocess(le, Wn).then((yr) => {
      Ks(le, lr, yr);
    }), Ze.close();
  }, Ti = (le) => {
    const Ae = nr(le);
    return Wa.collect(le, Ae);
  }, ko = (le, Ae) => {
    const Ze = le.anchor, Dt = Ze.url.getOr("");
    return {
      url: {
        value: Dt,
        meta: { original: { value: Dt } }
      },
      text: Ze.text.getOr(""),
      title: Ze.title.getOr(""),
      anchor: Dt,
      link: Dt,
      rel: Ze.rel.getOr(""),
      target: Ze.target.or(Ae).getOr(""),
      linkClass: Ze.linkClass.getOr("")
    };
  }, Yo = (le, Ae, Ze) => {
    const Dt = [{
      name: "url",
      type: "urlinput",
      filetype: "file",
      label: "URL",
      picker_text: "Browse links"
    }], Yt = le.anchor.text.map(() => ({
      name: "text",
      type: "input",
      label: "Text to display"
    })).toArray(), Wn = le.flags.titleEnabled ? [{
      name: "title",
      type: "input",
      label: "Title"
    }] : [], lr = ae.from(Le(Ze)), yr = ko(le, lr), Uo = le.catalogs, Yr = Re.init(yr, Uo);
    return {
      title: "Insert/Edit Link",
      size: "normal",
      body: {
        type: "panel",
        items: Kt([
          Dt,
          Yt,
          Wn,
          wt([
            Uo.anchor.map(Tn.createUi("anchor", "Anchors")),
            Uo.rels.map(Tn.createUi("rel", "Rel")),
            Uo.targets.map(Tn.createUi("target", "Open link in...")),
            Uo.link.map(Tn.createUi("link", "Link list")),
            Uo.classes.map(Tn.createUi("linkClass", "Class"))
          ])
        ])
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: yr,
      onChange: (rn, { name: cd }) => {
        Yr.onChange(rn.getData, { name: cd }).each((os) => {
          rn.setData(os);
        });
      },
      onSubmit: Ae
    };
  }, Fr = (le) => {
    Ti(le).then((Ze) => {
      const Dt = Ei(le, Ze);
      return Yo(Ze, Dt, le);
    }).then((Ze) => {
      le.windowManager.open(Ze);
    });
  }, Ba = (le) => {
    le.addCommand("mceLink", (Ae, Ze) => {
      (Ze == null ? void 0 : Ze.dialog) === !0 || !Y(le) ? Fr(le) : le.dispatch("contexttoolbar-show", { toolbarKey: "quicklink" });
    });
  }, ua = (le) => {
    le.addShortcut("Meta+K", "", () => {
      le.execCommand("mceLink");
    });
  }, vs = (le) => {
    let Ae = le;
    return {
      get: () => Ae,
      set: (Yt) => {
        Ae = Yt;
      }
    };
  }, es = (le) => {
    const Ae = vs(ae.none()), Ze = () => Ae.get().each(le);
    return {
      clear: () => {
        Ze(), Ae.set(ae.none());
      },
      isSet: () => Ae.get().isSome(),
      get: () => Ae.get(),
      set: (yr) => {
        Ze(), Ae.set(ae.some(yr));
      }
    };
  }, ai = () => {
    const le = es(Ce);
    return {
      ...le,
      on: (Ze) => le.get().each(Ze)
    };
  };
  var vc = tinymce.util.Tools.resolve("tinymce.util.VK");
  const Lr = (le, Ae) => {
    document.body.appendChild(le), le.dispatchEvent(Ae), document.body.removeChild(le);
  }, ka = (le) => {
    const Ae = document.createElement("a");
    Ae.target = "_blank", Ae.href = le, Ae.rel = "noreferrer noopener";
    const Ze = new MouseEvent("click", {
      bubbles: !0,
      cancelable: !0,
      view: window
    });
    document.dispatchEvent(Ze), Lr(Ae, Ze);
  }, ii = (le) => le.altKey === !0 && le.shiftKey === !1 && le.ctrlKey === !1 && le.metaKey === !1, na = (le, Ae) => {
    if (Ae) {
      const Ze = Pn(Ae);
      if (/^#/.test(Ze)) {
        const Dt = le.dom.select(Ze);
        Dt.length && le.selection.scrollIntoView(Dt[0], !0);
      } else
        ka(Ae.href);
    }
  }, Oi = (le) => {
    const Ae = le.selection.getRng(), Ze = Ae.startContainer;
    return Vt(Ze) && Ae.startContainer === Ae.endContainer && le.dom.select("img", Ze).length === 1;
  }, cl = (le, Ae) => {
    const Ze = at(le.dom.getParents(Ae));
    return qe(Ze.length === 1, Ze[0]);
  }, Za = (le) => {
    const Ae = Mr(le.selection.getRng());
    return qe(Ae.length > 0, Ae[0]).or(cl(le, le.selection.getNode()));
  }, Ai = (le) => le.selection.isCollapsed() || Oi(le) ? cl(le, le.selection.getStart()) : Za(le), Ui = (le) => {
    const Ae = ai(), Ze = () => Ae.get().or(Ai(le)), Dt = () => Ze().each((Yt) => na(le, Yt));
    return le.on("contextmenu", (Yt) => {
      cl(le, Yt.target).each(Ae.set);
    }), le.on("SelectionChange", () => {
      Ae.isSet() || Ai(le).each(Ae.set);
    }), le.on("click", (Yt) => {
      Ae.clear();
      const Wn = at(le.dom.getParents(Yt.target));
      Wn.length === 1 && vc.metaKeyPressed(Yt) && (Yt.preventDefault(), na(le, Wn[0]));
    }), le.on("keydown", (Yt) => {
      Ae.clear(), !Yt.isDefaultPrevented() && Yt.keyCode === 13 && ii(Yt) && Ze().each((Wn) => {
        Yt.preventDefault(), na(le, Wn);
      });
    }), { gotoSelectedLink: Dt };
  }, au = (le) => () => {
    le.execCommand("mceLink", !1, { dialog: !0 });
  }, gi = (le, Ae) => (le.on("NodeChange", Ae), () => le.off("NodeChange", Ae)), Ml = (le) => (Ae) => {
    const Ze = () => {
      Ae.setActive(!le.mode.isReadOnly() && Ko(le, le.selection.getNode())), Ae.setEnabled(le.selection.isEditable());
    };
    return Ze(), gi(le, Ze);
  }, $a = (le) => (Ae) => {
    const Ze = () => {
      Ae.setEnabled(le.selection.isEditable());
    };
    return Ze(), gi(le, Ze);
  }, Wi = (le) => (Ae) => {
    const Ze = (Wn) => kt(Wn) || yn(le.selection.getRng()), Dt = le.dom.getParents(le.selection.getStart()), Yt = (Wn) => {
      Ae.setEnabled(Ze(Wn) && le.selection.isEditable());
    };
    return Yt(Dt), gi(le, (Wn) => Yt(Wn.parents));
  }, Kl = (le, Ae) => {
    le.ui.registry.addToggleButton("link", {
      icon: "link",
      tooltip: "Insert/edit link",
      shortcut: "Meta+K",
      onAction: au(le),
      onSetup: Ml(le)
    }), le.ui.registry.addButton("openlink", {
      icon: "new-tab",
      tooltip: "Open link",
      onAction: Ae.gotoSelectedLink,
      onSetup: Wi(le)
    }), le.ui.registry.addButton("unlink", {
      icon: "unlink",
      tooltip: "Remove link",
      onAction: () => kr(le),
      onSetup: Wi(le)
    });
  }, yc = (le, Ae) => {
    le.ui.registry.addMenuItem("openlink", {
      text: "Open link",
      icon: "new-tab",
      onAction: Ae.gotoSelectedLink,
      onSetup: Wi(le)
    }), le.ui.registry.addMenuItem("link", {
      icon: "link",
      text: "Link...",
      shortcut: "Meta+K",
      onAction: au(le),
      onSetup: $a(le)
    }), le.ui.registry.addMenuItem("unlink", {
      icon: "unlink",
      text: "Remove link",
      onAction: () => kr(le),
      onSetup: Wi(le)
    });
  }, ld = (le) => {
    const Ae = "link unlink openlink", Ze = "link";
    le.ui.registry.addContextMenu("link", {
      update: (Dt) => le.dom.isEditable(Dt) ? kt(le.dom.getParents(Dt, "a")) ? Ae : Ze : ""
    });
  }, iu = (le, Ae) => {
    const Ze = (Wn) => {
      Wn.selection.collapse(!1);
    }, Dt = (Wn) => {
      const lr = le.selection.getNode();
      return Wn.setEnabled(Ko(le, lr)), Ce;
    }, Yt = (Wn) => {
      const lr = nr(le), yr = pn(le);
      if (lr.isNone() && yr) {
        const Uo = Qo(le.selection, lr);
        return qe(Uo.length === 0, Wn);
      } else
        return ae.none();
    };
    le.ui.registry.addContextForm("quicklink", {
      launch: {
        type: "contextformtogglebutton",
        icon: "link",
        tooltip: "Link",
        onSetup: Ml(le)
      },
      label: "Link",
      predicate: (Wn) => En(le) && Ko(le, Wn),
      initValue: () => nr(le).fold(Q(""), Pn),
      commands: [
        {
          type: "contextformtogglebutton",
          icon: "link",
          tooltip: "Link",
          primary: !0,
          onSetup: (Wn) => {
            const lr = le.selection.getNode();
            return Wn.setActive(Ko(le, lr)), Ml(le)(Wn);
          },
          onAction: (Wn) => {
            const lr = Wn.getValue(), yr = Yt(lr);
            Ks(le, {
              href: lr,
              attach: Ce
            }, {
              href: lr,
              text: yr,
              title: ae.none(),
              rel: ae.none(),
              target: ae.from(Le(le)),
              class: ae.none()
            }), Ze(le), Wn.hide();
          }
        },
        {
          type: "contextformbutton",
          icon: "unlink",
          tooltip: "Remove link",
          onSetup: Dt,
          onAction: (Wn) => {
            kr(le), Wn.hide();
          }
        },
        {
          type: "contextformbutton",
          icon: "new-tab",
          tooltip: "Open link",
          onSetup: Dt,
          onAction: (Wn) => {
            Ae.gotoSelectedLink(), Wn.hide();
          }
        }
      ]
    });
  }, bi = (le) => {
    const Ae = Ui(le);
    Kl(le, Ae), yc(le, Ae), ld(le), iu(le, Ae);
  };
  var Ru = () => {
    o.add("link", (le) => {
      mn(le), Ba(le), bi(le), ua(le);
    });
  };
  Ru();
})();
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const r = (R, V, re) => {
    var Pe;
    return re(R, V.prototype) ? !0 : ((Pe = R.constructor) === null || Pe === void 0 ? void 0 : Pe.name) === V.name;
  }, i = (R) => {
    const V = typeof R;
    return R === null ? "null" : V === "object" && Array.isArray(R) ? "array" : V === "object" && r(R, String, (re, Pe) => Pe.isPrototypeOf(re)) ? "string" : V;
  }, u = (R) => (V) => i(V) === R, h = (R) => (V) => typeof V === R, y = u("string"), k = u("object"), _ = u("array"), D = h("boolean"), L = (R) => R == null, W = (R) => !L(R), se = h("function"), J = h("number"), be = () => {
  }, ke = (R, V) => (re) => R(V(re)), Ce = (R) => () => R, Q = (R, V) => R === V;
  function oe(R, ...V) {
    return (...re) => {
      const Pe = V.concat(re);
      return R.apply(null, Pe);
    };
  }
  const ae = (R) => (V) => !R(V), G = Ce(!1);
  class ve {
    constructor(V, re) {
      this.tag = V, this.value = re;
    }
    static some(V) {
      return new ve(!0, V);
    }
    static none() {
      return ve.singletonNone;
    }
    fold(V, re) {
      return this.tag ? re(this.value) : V();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(V) {
      return this.tag ? ve.some(V(this.value)) : ve.none();
    }
    bind(V) {
      return this.tag ? V(this.value) : ve.none();
    }
    exists(V) {
      return this.tag && V(this.value);
    }
    forall(V) {
      return !this.tag || V(this.value);
    }
    filter(V) {
      return !this.tag || V(this.value) ? this : ve.none();
    }
    getOr(V) {
      return this.tag ? this.value : V;
    }
    or(V) {
      return this.tag ? this : V;
    }
    getOrThunk(V) {
      return this.tag ? this.value : V();
    }
    orThunk(V) {
      return this.tag ? this : V();
    }
    getOrDie(V) {
      if (this.tag)
        return this.value;
      throw new Error(V ?? "Called getOrDie on None");
    }
    static from(V) {
      return W(V) ? ve.some(V) : ve.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(V) {
      this.tag && V(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  ve.singletonNone = new ve(!1);
  const nt = Array.prototype.slice, Xe = Array.prototype.indexOf, te = Array.prototype.push, lt = (R, V) => Xe.call(R, V), ot = (R, V) => lt(R, V) > -1, Kt = (R, V) => {
    for (let re = 0, Pe = R.length; re < Pe; re++) {
      const $e = R[re];
      if (V($e, re))
        return !0;
    }
    return !1;
  }, je = (R, V) => {
    const re = R.length, Pe = new Array(re);
    for (let $e = 0; $e < re; $e++) {
      const $t = R[$e];
      Pe[$e] = V($t, $e);
    }
    return Pe;
  }, ye = (R, V) => {
    for (let re = 0, Pe = R.length; re < Pe; re++) {
      const $e = R[re];
      V($e, re);
    }
  }, dn = (R, V) => {
    const re = [];
    for (let Pe = 0, $e = R.length; Pe < $e; Pe++) {
      const $t = R[Pe];
      V($t, Pe) && re.push($t);
    }
    return re;
  }, wt = (R, V) => {
    if (R.length === 0)
      return [];
    {
      let re = V(R[0]);
      const Pe = [];
      let $e = [];
      for (let $t = 0, vo = R.length; $t < vo; $t++) {
        const $o = R[$t], Mo = V($o);
        Mo !== re && (Pe.push($e), $e = []), re = Mo, $e.push($o);
      }
      return $e.length !== 0 && Pe.push($e), Pe;
    }
  }, qe = (R, V, re) => (ye(R, (Pe, $e) => {
    re = V(re, Pe, $e);
  }), re), B = (R, V, re) => {
    for (let Pe = 0, $e = R.length; Pe < $e; Pe++) {
      const $t = R[Pe];
      if (V($t, Pe))
        return ve.some($t);
      if (re($t, Pe))
        break;
    }
    return ve.none();
  }, mn = (R, V) => B(R, V, G), dt = (R) => {
    const V = [];
    for (let re = 0, Pe = R.length; re < Pe; ++re) {
      if (!_(R[re]))
        throw new Error("Arr.flatten item " + re + " was not an array, input: " + R);
      te.apply(V, R[re]);
    }
    return V;
  }, En = (R, V) => dt(je(R, V)), tn = (R) => {
    const V = nt.call(R, 0);
    return V.reverse(), V;
  }, Le = (R, V) => V >= 0 && V < R.length ? ve.some(R[V]) : ve.none(), jt = (R) => Le(R, 0), Fn = (R) => Le(R, R.length - 1), St = (R, V) => {
    const re = [], Pe = se(V) ? ($e) => Kt(re, ($t) => V($t, $e)) : ($e) => ot(re, $e);
    for (let $e = 0, $t = R.length; $e < $t; $e++) {
      const vo = R[$e];
      Pe(vo) || re.push(vo);
    }
    return re;
  }, on = (R, V, re = Q) => R.exists((Pe) => re(Pe, V)), tt = (R, V, re = Q) => mt(R, V, re).getOr(R.isNone() && V.isNone()), mt = (R, V, re) => R.isSome() && V.isSome() ? ve.some(re(R.getOrDie(), V.getOrDie())) : ve.none(), Y = 8, Wo = 9, To = 11, Ot = 1, Mt = 3, zn = (R, V) => {
    const Pe = (V || document).createElement("div");
    if (Pe.innerHTML = R, !Pe.hasChildNodes() || Pe.childNodes.length > 1) {
      const $e = "HTML does not have a single root node";
      throw console.error($e, R), new Error($e);
    }
    return en(Pe.childNodes[0]);
  }, At = (R, V) => {
    const Pe = (V || document).createElement(R);
    return en(Pe);
  }, $n = (R, V) => {
    const Pe = (V || document).createTextNode(R);
    return en(Pe);
  }, en = (R) => {
    if (R == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: R };
  }, jn = {
    fromHtml: zn,
    fromTag: At,
    fromText: $n,
    fromDom: en,
    fromPoint: (R, V, re) => ve.from(R.dom.elementFromPoint(V, re)).map(en)
  }, mo = (R, V) => {
    const re = R.dom;
    if (re.nodeType !== Ot)
      return !1;
    {
      const Pe = re;
      if (Pe.matches !== void 0)
        return Pe.matches(V);
      if (Pe.msMatchesSelector !== void 0)
        return Pe.msMatchesSelector(V);
      if (Pe.webkitMatchesSelector !== void 0)
        return Pe.webkitMatchesSelector(V);
      if (Pe.mozMatchesSelector !== void 0)
        return Pe.mozMatchesSelector(V);
      throw new Error("Browser lacks native selectors");
    }
  }, xn = (R, V) => R.dom === V.dom, Vt = (R, V) => {
    const re = R.dom, Pe = V.dom;
    return re === Pe ? !1 : re.contains(Pe);
  }, Ct = mo, Jn = typeof window < "u" ? window : Function("return this;")(), Pn = (R, V) => {
    let re = V ?? Jn;
    for (let Pe = 0; Pe < R.length && re !== void 0 && re !== null; ++Pe)
      re = re[R[Pe]];
    return re;
  }, so = (R, V) => {
    const re = R.split(".");
    return Pn(re, V);
  }, pr = (R, V) => so(R, V), nr = (R, V) => {
    const re = pr(R, V);
    if (re == null)
      throw new Error(R + " not available on this browser");
    return re;
  }, Ko = Object.getPrototypeOf, Qo = (R) => nr("HTMLElement", R), Mr = (R) => {
    const V = so("ownerDocument.defaultView", R);
    return k(R) && (Qo(V).prototype.isPrototypeOf(R) || /^HTML\w*Element$/.test(Ko(R).constructor.name));
  }, at = (R) => R.dom.nodeName.toLowerCase(), kt = (R) => R.dom.nodeType, yn = (R) => (V) => kt(V) === R, pn = (R) => kt(R) === Y || at(R) === "#comment", Oo = (R) => hr(R) && Mr(R.dom), hr = yn(Ot), or = yn(Mt), Ir = yn(Wo), Zo = yn(To), Tr = (R) => (V) => hr(V) && at(V) === R, Ht = (R) => jn.fromDom(R.dom.ownerDocument), Ho = (R) => Ir(R) ? R : Ht(R), As = (R) => ve.from(R.dom.parentNode).map(jn.fromDom), ra = (R) => ve.from(R.dom.parentElement).map(jn.fromDom), qs = (R) => ve.from(R.dom.nextSibling).map(jn.fromDom), Ks = (R) => je(R.dom.childNodes, jn.fromDom), kr = (R, V) => {
    const re = R.dom.childNodes;
    return ve.from(re[V]).map(jn.fromDom);
  }, xa = (R) => kr(R, 0), ca = (R) => kr(R, R.dom.childNodes.length - 1), Or = (R) => Zo(R) && W(R.dom.host), Ss = se(Element.prototype.attachShadow) && se(Node.prototype.getRootNode) ? (R) => jn.fromDom(R.dom.getRootNode()) : Ho, Ke = (R) => {
    const V = Ss(R);
    return Or(V) ? ve.some(V) : ve.none();
  }, bt = (R) => jn.fromDom(R.dom.host), gn = (R) => {
    const V = or(R) ? R.dom.parentNode : R.dom;
    if (V == null || V.ownerDocument === null)
      return !1;
    const re = V.ownerDocument;
    return Ke(jn.fromDom(V)).fold(() => re.body.contains(V), ke(gn, bt));
  };
  var Tn = (R, V, re, Pe, $e) => R(re, Pe) ? ve.some(re) : se($e) && $e(re) ? ve.none() : V(re, Pe, $e);
  const Po = (R, V, re) => {
    let Pe = R.dom;
    const $e = se(re) ? re : G;
    for (; Pe.parentNode; ) {
      Pe = Pe.parentNode;
      const $t = jn.fromDom(Pe);
      if (V($t))
        return ve.some($t);
      if ($e($t))
        break;
    }
    return ve.none();
  }, cr = (R, V, re) => Tn(($e, $t) => $t($e), Po, R, V, re), ea = (R, V, re) => Po(R, (Pe) => mo(Pe, V), re), ta = (R, V, re) => Tn(($e, $t) => mo($e, $t), ea, R, V, re), Ps = (R) => ta(R, "[contenteditable]"), Re = (R, V = !1) => gn(R) ? R.dom.isContentEditable : Ps(R).fold(Ce(V), (re) => Oe(re) === "true"), Oe = (R) => R.dom.contentEditable, ct = (R, V) => {
    As(R).each((Pe) => {
      Pe.dom.insertBefore(V.dom, R.dom);
    });
  }, _t = (R, V) => {
    qs(R).fold(() => {
      As(R).each(($e) => {
        io($e, V);
      });
    }, (Pe) => {
      ct(Pe, V);
    });
  }, Kn = (R, V) => {
    xa(R).fold(() => {
      io(R, V);
    }, (Pe) => {
      R.dom.insertBefore(V.dom, Pe.dom);
    });
  }, io = (R, V) => {
    R.dom.appendChild(V.dom);
  }, Bo = (R, V) => {
    ye(V, (re) => {
      ct(R, re);
    });
  }, Jr = (R, V) => {
    ye(V, (re) => {
      io(R, re);
    });
  }, He = (R) => {
    R.dom.textContent = "", ye(Ks(R), (V) => {
      Do(V);
    });
  }, Do = (R) => {
    const V = R.dom;
    V.parentNode !== null && V.parentNode.removeChild(V);
  };
  var Ne = tinymce.util.Tools.resolve("tinymce.dom.RangeUtils"), Ie = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker"), Bt = tinymce.util.Tools.resolve("tinymce.util.VK");
  const Wt = (R) => je(R, jn.fromDom), kn = Object.keys, eo = (R, V) => {
    const re = kn(R);
    for (let Pe = 0, $e = re.length; Pe < $e; Pe++) {
      const $t = re[Pe], vo = R[$t];
      V(vo, $t);
    }
  }, Gn = (R) => (V, re) => {
    R[re] = V;
  }, qn = (R, V, re, Pe) => {
    eo(R, ($e, $t) => {
      (V($e, $t) ? re : Pe)($e, $t);
    });
  }, Qn = (R, V) => {
    const re = {};
    return qn(R, V, Gn(re), be), re;
  }, lo = (R, V, re) => {
    if (y(re) || D(re) || J(re))
      R.setAttribute(V, re + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", V, ":: Value ", re, ":: Element ", R), new Error("Attribute value was not simple");
  }, rr = (R, V) => {
    const re = R.dom;
    eo(V, (Pe, $e) => {
      lo(re, $e, Pe);
    });
  }, Kr = (R) => qe(R.dom.attributes, (V, re) => (V[re.name] = re.value, V), {}), Wa = (R, V) => jn.fromDom(R.dom.cloneNode(V)), Ei = (R) => Wa(R, !0), Ti = (R, V) => {
    const re = jn.fromTag(V), Pe = Kr(R);
    return rr(re, Pe), re;
  }, ko = (R, V) => {
    const re = Ti(R, V);
    _t(R, re);
    const Pe = Ks(R);
    return Jr(re, Pe), Do(R), re;
  };
  var Yo = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), Fr = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const Ba = (R) => (V) => W(V) && V.nodeName.toLowerCase() === R, ua = (R) => (V) => W(V) && R.test(V.nodeName), vs = (R) => W(R) && R.nodeType === 3, es = (R) => W(R) && R.nodeType === 1, ai = ua(/^(OL|UL|DL)$/), vc = ua(/^(OL|UL)$/), Lr = Ba("ol"), ka = ua(/^(LI|DT|DD)$/), ii = ua(/^(DT|DD)$/), na = ua(/^(TH|TD)$/), Oi = Ba("br"), cl = (R) => {
    var V;
    return ((V = R.parentNode) === null || V === void 0 ? void 0 : V.firstChild) === R;
  }, Za = (R, V) => W(V) && V.nodeName in R.schema.getTextBlockElements(), Ai = (R, V) => W(R) && R.nodeName in V, Ui = (R, V) => W(V) && V.nodeName in R.schema.getVoidElements(), au = (R, V) => Oi(V) ? R.isBlock(V.nextSibling) && !Oi(V.previousSibling) : !1, gi = (R, V, re) => {
    const Pe = R.isEmpty(V);
    return re && R.select("span[data-mce-type=bookmark]", V).length > 0 ? !1 : Pe;
  }, Ml = (R, V) => R.isChildOf(V, R.getRoot()), $a = (R) => (V) => V.options.get(R), Wi = (R) => {
    const V = R.options.register;
    V("lists_indent_on_tab", {
      processor: "boolean",
      default: !0
    });
  }, Kl = $a("lists_indent_on_tab"), yc = $a("forced_root_block"), ld = $a("forced_root_block_attrs"), iu = (R, V, re = {}) => {
    const Pe = R.dom, $e = R.schema.getBlockElements(), $t = Pe.createFragment(), vo = yc(R), $o = ld(R);
    let Mo, bo, Vs = !1;
    for (bo = Pe.create(vo, {
      ...$o,
      ...re.style ? { style: re.style } : {}
    }), Ai(V.firstChild, $e) || $t.appendChild(bo); Mo = V.firstChild; ) {
      const ma = Mo.nodeName;
      !Vs && (ma !== "SPAN" || Mo.getAttribute("data-mce-type") !== "bookmark") && (Vs = !0), Ai(Mo, $e) ? ($t.appendChild(Mo), bo = null) : (bo || (bo = Pe.create(vo, $o), $t.appendChild(bo)), bo.appendChild(Mo));
    }
    return !Vs && bo && bo.appendChild(Pe.create("br", { "data-mce-bogus": "1" })), $t;
  }, bi = Yo.DOM, Ru = (R, V, re) => {
    const Pe = (bo) => {
      const Vs = bo.parentNode;
      Vs && Fr.each($e, (ma) => {
        Vs.insertBefore(ma, re.parentNode);
      }), bi.remove(bo);
    }, $e = bi.select('span[data-mce-type="bookmark"]', V), $t = iu(R, re), vo = bi.createRng();
    vo.setStartAfter(re), vo.setEndAfter(V);
    const $o = vo.extractContents();
    for (let bo = $o.firstChild; bo; bo = bo.firstChild)
      if (bo.nodeName === "LI" && R.dom.isEmpty(bo)) {
        bi.remove(bo);
        break;
      }
    R.dom.isEmpty($o) || bi.insertAfter($o, V), bi.insertAfter($t, V);
    const Mo = re.parentElement;
    Mo && gi(R.dom, Mo) && Pe(Mo), bi.remove(re), gi(R.dom, V) && bi.remove(V);
  }, le = Tr("dd"), Ae = Tr("dt"), Ze = (R, V) => {
    le(V) ? ko(V, "dt") : Ae(V) && ra(V).each((re) => Ru(R, re.dom, V.dom));
  }, Dt = (R) => {
    Ae(R) && ko(R, "dd");
  }, Yt = (R, V, re) => {
    V === "Indent" ? ye(re, Dt) : ye(re, (Pe) => Ze(R, Pe));
  }, Wn = (R, V) => {
    if (vs(R))
      return {
        container: R,
        offset: V
      };
    const re = Ne.getNode(R, V);
    return vs(re) ? {
      container: re,
      offset: V >= R.childNodes.length ? re.data.length : 0
    } : re.previousSibling && vs(re.previousSibling) ? {
      container: re.previousSibling,
      offset: re.previousSibling.data.length
    } : re.nextSibling && vs(re.nextSibling) ? {
      container: re.nextSibling,
      offset: 0
    } : {
      container: R,
      offset: V
    };
  }, lr = (R) => {
    const V = R.cloneRange(), re = Wn(R.startContainer, R.startOffset);
    V.setStart(re.container, re.offset);
    const Pe = Wn(R.endContainer, R.endOffset);
    return V.setEnd(Pe.container, Pe.offset), V;
  }, yr = [
    "OL",
    "UL",
    "DL"
  ], Uo = yr.join(","), Yr = (R, V) => {
    const re = V || R.selection.getStart(!0);
    return R.dom.getParent(re, Uo, Cn(R, re));
  }, Ds = (R, V) => W(R) && V.length === 1 && V[0] === R, rn = (R) => dn(R.querySelectorAll(Uo), ai), cd = (R) => {
    const V = Yr(R), re = R.selection.getSelectedBlocks();
    return Ds(V, re) ? rn(V) : dn(re, (Pe) => ai(Pe) && V !== Pe);
  }, os = (R, V) => {
    const re = Fr.map(V, (Pe) => {
      const $e = R.dom.getParent(Pe, "li,dd,dt", Cn(R, Pe));
      return $e || Pe;
    });
    return St(re);
  }, K = (R) => {
    const V = R.selection.getSelectedBlocks();
    return dn(os(R, V), ka);
  }, ge = (R) => dn(K(R), ii), Ee = (R, V) => {
    const re = R.dom.getParents(V, "TD,TH");
    return re.length > 0 ? re[0] : R.getBody();
  }, ft = (R, V) => !ai(V) && !ka(V) && Kt(yr, (re) => R.isValidChild(V.nodeName, re)), Cn = (R, V) => {
    const re = R.dom.getParents(V, R.dom.isBlock), Pe = ($t) => $t.nodeName.toLowerCase() !== yc(R);
    return mn(re, ($t) => Pe($t) && ft(R.schema, $t)).getOr(R.getBody());
  }, Jo = (R) => As(R).exists((V) => ka(V.dom) && xa(V).exists((re) => !ai(re.dom)) && ca(V).exists((re) => !ai(re.dom))), Ln = (R, V) => {
    const re = R.dom.getParents(V, "ol,ul", Cn(R, V));
    return Fn(re);
  }, Rs = (R) => {
    const V = Ln(R, R.selection.getStart()), re = dn(R.selection.getSelectedBlocks(), vc);
    return V.toArray().concat(re);
  }, Gt = (R) => {
    const V = R.selection.getStart();
    return R.dom.getParents(V, "ol,ul", Cn(R, V));
  }, fs = (R) => {
    const V = Rs(R), re = Gt(R);
    return mn(re, (Pe) => Jo(jn.fromDom(Pe))).fold(() => vi(R, V), (Pe) => [Pe]);
  }, vi = (R, V) => {
    const re = je(V, (Pe) => Ln(R, Pe).getOr(Pe));
    return St(re);
  }, ks = (R) => /\btox\-/.test(R.className), ga = (R, V) => B(R, ai, na).exists((re) => re.nodeName === V && !ks(re)), Il = (R, V) => V !== null && !R.dom.isEditable(V), xr = (R) => {
    const V = Yr(R);
    return Il(R, V);
  }, yi = (R, V) => {
    const re = R.dom.getParent(V, "ol,ul,dl");
    return Il(R, re);
  }, Ns = (R, V) => {
    const re = R.selection.getNode();
    return V({
      parents: R.dom.getParents(re),
      element: re
    }), R.on("NodeChange", V), () => R.off("NodeChange", V);
  }, xc = (R, V) => {
    const Pe = document.createDocumentFragment();
    return ye(R, ($e) => {
      Pe.appendChild($e.dom);
    }), jn.fromDom(Pe);
  }, Bs = (R, V, re) => R.dispatch("ListMutation", {
    action: V,
    element: re
  }), vm = ((R) => (V) => V.replace(R, ""))(/^\s+|\s+$/g), Oh = (R) => R.length > 0, zs = (R) => !Oh(R), Yl = (R) => R.style !== void 0 && se(R.style.getPropertyValue), La = (R, V, re) => {
    if (!y(re))
      throw console.error("Invalid call to CSS.set. Property ", V, ":: Value ", re, ":: Element ", R), new Error("CSS value must be a string: " + re);
    Yl(R) && R.style.setProperty(V, re);
  }, Ga = (R, V, re) => {
    const Pe = R.dom;
    La(Pe, V, re);
  }, xi = (R) => Ct(R, "OL,UL"), Of = (R) => Ct(R, "LI"), gr = (R) => xa(R).exists(xi), Pi = (R) => ca(R).exists(xi), li = (R) => "listAttributes" in R, pe = (R) => "isComment" in R, Te = (R) => "isFragment" in R, rt = (R) => R.depth > 0, pt = (R) => R.isSelected, to = (R) => {
    const V = Ks(R), re = Pi(R) ? V.slice(0, -1) : V;
    return je(re, Ei);
  }, sr = (R, V, re) => As(R).filter(hr).map((Pe) => ({
    depth: V,
    dirty: !1,
    isSelected: re,
    content: to(R),
    itemAttributes: Kr(R),
    listAttributes: Kr(Pe),
    listType: at(Pe),
    isInPreviousLi: !1
  })), _s = (R, V) => {
    io(R.item, V.list);
  }, Ha = (R) => {
    for (let V = 1; V < R.length; V++)
      _s(R[V - 1], R[V]);
  }, ur = (R, V) => {
    mt(Fn(R), jt(V), _s);
  }, _a = (R, V) => {
    const re = {
      list: jn.fromTag(V, R),
      item: jn.fromTag("li", R)
    };
    return io(re.list, re.item), re;
  }, Ms = (R, V, re) => {
    const Pe = [];
    for (let $e = 0; $e < re; $e++)
      Pe.push(_a(R, li(V) ? V.listType : V.parentListType));
    return Pe;
  }, da = (R, V) => {
    for (let re = 0; re < R.length - 1; re++)
      Ga(R[re].item, "list-style-type", "none");
    Fn(R).each((re) => {
      li(V) && (rr(re.list, V.listAttributes), rr(re.item, V.itemAttributes)), Jr(re.item, V.content);
    });
  }, sa = (R, V) => {
    at(R.list) !== V.listType && (R.list = ko(R.list, V.listType)), rr(R.list, V.listAttributes);
  }, oa = (R, V, re) => {
    const Pe = jn.fromTag("li", R);
    return rr(Pe, V), Jr(Pe, re), Pe;
  }, ul = (R, V) => {
    io(R.list, V), R.item = V;
  }, wc = (R, V, re) => {
    const Pe = V.slice(0, re.depth);
    return Fn(Pe).each(($e) => {
      if (li(re)) {
        const $t = oa(R, re.itemAttributes, re.content);
        ul($e, $t), sa($e, re);
      } else if (Te(re))
        Jr($e.item, re.content);
      else {
        const $t = jn.fromHtml(`<!--${re.content}-->`);
        io($e.list, $t);
      }
    }), Pe;
  }, qa = (R, V, re) => {
    const Pe = Ms(R, re, re.depth - V.length);
    return Ha(Pe), da(Pe, re), ur(V, Pe), V.concat(Pe);
  }, dl = (R, V) => {
    let re = ve.none();
    const Pe = qe(V, ($e, $t, vo) => pe($t) ? vo === 0 ? (re = ve.some($t), $e) : wc(R, $e, $t) : $t.depth > $e.length ? qa(R, $e, $t) : wc(R, $e, $t), []);
    return re.each(($e) => {
      const $t = jn.fromHtml(`<!--${$e.content}-->`);
      jt(Pe).each((vo) => {
        Kn(vo.list, $t);
      });
    }), jt(Pe).map(($e) => $e.list);
  }, Mc = (R, V) => {
    switch (R) {
      case "Indent":
        V.depth++;
        break;
      case "Outdent":
        V.depth--;
        break;
      case "Flatten":
        V.depth = 0;
    }
    V.dirty = !0;
  }, Ic = (R, V) => {
    li(R) && li(V) && (R.listType = V.listType, R.listAttributes = { ...V.listAttributes });
  }, ip = (R) => {
    R.listAttributes = Qn(R.listAttributes, (V, re) => re !== "start");
  }, dd = (R, V) => {
    const re = R[V].depth, Pe = ($t) => $t.depth === re && !$t.dirty, $e = ($t) => $t.depth < re;
    return B(tn(R.slice(0, V)), Pe, $e).orThunk(() => B(R.slice(V + 1), Pe, $e));
  }, Cc = (R) => (ye(R, (V, re) => {
    dd(R, re).fold(() => {
      V.dirty && li(V) && ip(V);
    }, (Pe) => Ic(V, Pe));
  }), R), Zi = (R) => {
    let V = R;
    return {
      get: () => V,
      set: ($e) => {
        V = $e;
      }
    };
  }, fd = (R, V, re, Pe) => {
    var $e;
    if (pn(Pe))
      return [{
        depth: R + 1,
        content: ($e = Pe.dom.nodeValue) !== null && $e !== void 0 ? $e : "",
        dirty: !1,
        isSelected: !1,
        isComment: !0
      }];
    V.each(($o) => {
      xn($o.start, Pe) && re.set(!0);
    });
    const $t = sr(Pe, R, re.get());
    V.each(($o) => {
      xn($o.end, Pe) && re.set(!1);
    });
    const vo = ca(Pe).filter(xi).map(($o) => lu(R, V, re, $o)).getOr([]);
    return $t.toArray().concat(vo);
  }, Af = (R, V, re, Pe) => xa(Pe).filter(xi).fold(() => fd(R, V, re, Pe), ($e) => {
    const $t = qe(Ks(Pe), (vo, $o, Mo) => {
      if (Mo === 0)
        return vo;
      if (Of($o))
        return vo.concat(fd(R, V, re, $o));
      {
        const bo = {
          isFragment: !0,
          depth: R,
          content: [$o],
          isSelected: !1,
          dirty: !1,
          parentListType: at($e)
        };
        return vo.concat(bo);
      }
    }, []);
    return lu(R, V, re, $e).concat($t);
  }), lu = (R, V, re, Pe) => En(Ks(Pe), ($e) => {
    const $t = xi($e) ? lu : Af, vo = R + 1;
    return $t(vo, V, re, $e);
  }), Ah = (R, V) => {
    const re = Zi(!1), Pe = 0;
    return je(R, ($e) => ({
      sourceList: $e,
      entries: lu(Pe, V, re, $e)
    }));
  }, Pf = (R, V) => {
    const re = Cc(V);
    return je(re, (Pe) => {
      const $e = pe(Pe) ? xc([jn.fromHtml(`<!--${Pe.content}-->`)]) : xc(Pe.content), $t = li(Pe) ? Pe.itemAttributes : {};
      return jn.fromDom(iu(R, $e.dom, $t));
    });
  }, Ph = (R, V) => {
    const re = Cc(V);
    return dl(R.contentDocument, re).toArray();
  }, Wd = (R, V) => En(wt(V, rt), (re) => jt(re).exists(rt) ? Ph(R, re) : Pf(R, re)), Dh = (R, V) => {
    ye(dn(R, pt), (re) => Mc(V, re));
  }, Zd = (R) => {
    const V = je(K(R), jn.fromDom);
    return mt(mn(V, ae(gr)), mn(tn(V), ae(gr)), (re, Pe) => ({
      start: re,
      end: Pe
    }));
  }, Sv = (R, V, re) => {
    const Pe = Ah(V, Zd(R));
    ye(Pe, ($e) => {
      Dh($e.entries, re);
      const $t = Wd(R, $e.entries);
      ye($t, (vo) => {
        Bs(R, re === "Indent" ? "IndentList" : "OutdentList", vo.dom);
      }), Bo($e.sourceList, $t), Do($e.sourceList);
    });
  }, Me = (R, V) => {
    const re = Wt(fs(R)), Pe = Wt(ge(R));
    let $e = !1;
    if (re.length || Pe.length) {
      const $t = R.selection.getBookmark();
      Sv(R, re, V), Yt(R, V, Pe), R.selection.moveToBookmark($t), R.selection.setRng(lr(R.selection.getRng())), R.nodeChanged(), $e = !0;
    }
    return $e;
  }, ym = (R, V) => !xr(R) && Me(R, V), wl = (R) => ym(R, "Indent"), Nu = (R) => ym(R, "Outdent"), Rh = (R) => ym(R, "Flatten"), Wg = "\uFEFF", zr = (R) => R === Wg, Gi = (R, V, re) => Po(R, V, re).isSome(), Fl = (R, V) => Gi(R, oe(xn, V));
  var Ka = tinymce.util.Tools.resolve("tinymce.dom.BookmarkManager");
  const Gd = Yo.DOM, Fc = (R) => {
    const V = {}, re = (Pe) => {
      let $e = R[Pe ? "startContainer" : "endContainer"], $t = R[Pe ? "startOffset" : "endOffset"];
      if (es($e)) {
        const vo = Gd.create("span", { "data-mce-type": "bookmark" });
        $e.hasChildNodes() ? ($t = Math.min($t, $e.childNodes.length - 1), Pe ? $e.insertBefore(vo, $e.childNodes[$t]) : Gd.insertAfter(vo, $e.childNodes[$t])) : $e.appendChild(vo), $e = vo, $t = 0;
      }
      V[Pe ? "startContainer" : "endContainer"] = $e, V[Pe ? "startOffset" : "endOffset"] = $t;
    };
    return re(!0), R.collapsed || re(), V;
  }, Di = (R) => {
    const V = (Pe) => {
      const $e = ($o) => {
        var Mo;
        let bo = (Mo = $o.parentNode) === null || Mo === void 0 ? void 0 : Mo.firstChild, Vs = 0;
        for (; bo; ) {
          if (bo === $o)
            return Vs;
          (!es(bo) || bo.getAttribute("data-mce-type") !== "bookmark") && Vs++, bo = bo.nextSibling;
        }
        return -1;
      };
      let $t = R[Pe ? "startContainer" : "endContainer"], vo = R[Pe ? "startOffset" : "endOffset"];
      if ($t) {
        if (es($t) && $t.parentNode) {
          const $o = $t;
          vo = $e($t), $t = $t.parentNode, Gd.remove($o), !$t.hasChildNodes() && Gd.isBlock($t) && $t.appendChild(Gd.create("br"));
        }
        R[Pe ? "startContainer" : "endContainer"] = $t, R[Pe ? "startOffset" : "endOffset"] = vo;
      }
    };
    V(!0), V();
    const re = Gd.createRng();
    return re.setStart(R.startContainer, R.startOffset), R.endContainer && re.setEnd(R.endContainer, R.endOffset), lr(re);
  }, Bc = (R) => {
    switch (R) {
      case "UL":
        return "ToggleUlList";
      case "OL":
        return "ToggleOlList";
      case "DL":
        return "ToggleDLList";
    }
  }, Nh = (R, V, re) => {
    const Pe = re["list-style-type"] ? re["list-style-type"] : null;
    R.setStyle(V, "list-style-type", Pe);
  }, Zg = (R, V) => {
    Fr.each(V, (re, Pe) => {
      R.setAttribute(Pe, re);
    });
  }, Xl = (R, V, re) => {
    Zg(V, re["list-attributes"]), Fr.each(R.select("li", V), (Pe) => {
      Zg(Pe, re["list-item-attributes"]);
    });
  }, $c = (R, V, re) => {
    Nh(R, V, re), Xl(R, V, re);
  }, lp = (R, V, re) => {
    Fr.each(re, (Pe) => R.setStyle(V, Pe, ""));
  }, qi = (R, V) => W(V) && !Ai(V, R.schema.getBlockElements()), Ya = (R, V, re, Pe) => {
    let $e = V[re ? "startContainer" : "endContainer"];
    const $t = V[re ? "startOffset" : "endOffset"];
    es($e) && ($e = $e.childNodes[Math.min($t, $e.childNodes.length - 1)] || $e), !re && Oi($e.nextSibling) && ($e = $e.nextSibling);
    const vo = (Mo) => {
      for (; !R.dom.isBlock(Mo) && Mo.parentNode && Pe !== Mo; )
        Mo = Mo.parentNode;
      return Mo;
    }, $o = (Mo, bo) => {
      var Vs;
      const ma = new Ie(Mo, vo(Mo)), _l = bo ? "next" : "prev";
      let ba;
      for (; ba = ma[_l](); )
        if (!(Ui(R, ba) || zr(ba.textContent) || ((Vs = ba.textContent) === null || Vs === void 0 ? void 0 : Vs.length) === 0))
          return ve.some(ba);
      return ve.none();
    };
    if (re && vs($e))
      if (zr($e.textContent))
        $e = $o($e, !1).getOr($e);
      else
        for ($e.parentNode !== null && qi(R, $e.parentNode) && ($e = $e.parentNode); $e.previousSibling !== null && (qi(R, $e.previousSibling) || vs($e.previousSibling)); )
          $e = $e.previousSibling;
    if (!re && vs($e))
      if (zr($e.textContent))
        $e = $o($e, !0).getOr($e);
      else
        for ($e.parentNode !== null && qi(R, $e.parentNode) && ($e = $e.parentNode); $e.nextSibling !== null && (qi(R, $e.nextSibling) || vs($e.nextSibling)); )
          $e = $e.nextSibling;
    for (; $e.parentNode !== Pe; ) {
      const Mo = $e.parentNode;
      if (Za(R, $e) || /^(TD|TH)$/.test(Mo.nodeName))
        return $e;
      $e = Mo;
    }
    return $e;
  }, md = (R, V, re) => {
    const Pe = [], $e = R.dom, $t = Ya(R, V, !0, re), vo = Ya(R, V, !1, re);
    let $o;
    const Mo = [];
    for (let bo = $t; bo && (Mo.push(bo), bo !== vo); bo = bo.nextSibling)
      ;
    return Fr.each(Mo, (bo) => {
      var Vs;
      if (Za(R, bo)) {
        Pe.push(bo), $o = null;
        return;
      }
      if ($e.isBlock(bo) || Oi(bo)) {
        Oi(bo) && $e.remove(bo), $o = null;
        return;
      }
      const ma = bo.nextSibling;
      if (Ka.isBookmarkNode(bo) && (ai(ma) || Za(R, ma) || !ma && bo.parentNode === re)) {
        $o = null;
        return;
      }
      $o || ($o = $e.create("p"), (Vs = bo.parentNode) === null || Vs === void 0 || Vs.insertBefore($o, bo), Pe.push($o)), $o.appendChild(bo);
    }), Pe;
  }, Df = (R, V, re) => {
    const Pe = R.getStyle(V, "list-style-type");
    let $e = re ? re["list-style-type"] : "";
    return $e = $e === null ? "" : $e, Pe === $e;
  }, Sc = (R, V) => {
    const re = R.selection.getStart(!0), Pe = Ya(R, V, !0, R.getBody());
    return Fl(jn.fromDom(Pe), jn.fromDom(V.commonAncestorContainer)) ? V.commonAncestorContainer : re;
  }, wi = (R, V, re) => {
    const Pe = R.selection.getRng();
    let $e = "LI";
    const $t = Cn(R, Sc(R, Pe)), vo = R.dom;
    if (vo.getContentEditable(R.selection.getNode()) === "false")
      return;
    V = V.toUpperCase(), V === "DL" && ($e = "DT");
    const $o = Fc(Pe), Mo = dn(md(R, Pe, $t), R.dom.isEditable);
    Fr.each(Mo, (bo) => {
      let Vs;
      const ma = bo.previousSibling, _l = bo.parentNode;
      ka(_l) || (ma && ai(ma) && ma.nodeName === V && Df(vo, ma, re) ? (Vs = ma, bo = vo.rename(bo, $e), ma.appendChild(bo)) : (Vs = vo.create(V), _l.insertBefore(Vs, bo), Vs.appendChild(bo), bo = vo.rename(bo, $e)), lp(vo, bo, [
        "margin",
        "margin-right",
        "margin-bottom",
        "margin-left",
        "margin-top",
        "padding",
        "padding-right",
        "padding-bottom",
        "padding-left",
        "padding-top"
      ]), $c(vo, Vs, re), Ql(R.dom, Vs));
    }), R.selection.setRng(Di($o));
  }, cp = (R, V) => ai(R) && R.nodeName === (V == null ? void 0 : V.nodeName), up = (R, V, re) => {
    const Pe = R.getStyle(V, "list-style-type", !0), $e = R.getStyle(re, "list-style-type", !0);
    return Pe === $e;
  }, dp = (R, V) => R.className === V.className, xm = (R, V, re) => cp(V, re) && up(R, V, re) && dp(V, re), Ql = (R, V) => {
    let re, Pe = V.nextSibling;
    if (xm(R, V, Pe)) {
      const $e = Pe;
      for (; re = $e.firstChild; )
        V.appendChild(re);
      R.remove($e);
    }
    if (Pe = V.previousSibling, xm(R, V, Pe)) {
      const $e = Pe;
      for (; re = $e.lastChild; )
        V.insertBefore(re, V.firstChild);
      R.remove($e);
    }
  }, fp = (R, V, re, Pe) => {
    if (V.nodeName !== re) {
      const $e = R.dom.rename(V, re);
      $c(R.dom, $e, Pe), Bs(R, Bc(re), $e);
    } else
      $c(R.dom, V, Pe), Bs(R, Bc(re), V);
  }, Gg = (R, V, re, Pe) => {
    if (V.classList.forEach(($e, $t, vo) => {
      $e.startsWith("tox-") && (vo.remove($e), vo.length === 0 && V.removeAttribute("class"));
    }), V.nodeName !== re) {
      const $e = R.dom.rename(V, re);
      $c(R.dom, $e, Pe), Bs(R, Bc(re), $e);
    } else
      $c(R.dom, V, Pe), Bs(R, Bc(re), V);
  }, kv = (R, V, re, Pe, $e) => {
    const $t = ai(V);
    if ($t && V.nodeName === Pe && !qg($e) && !ks(V))
      Rh(R);
    else {
      wi(R, Pe, $e);
      const vo = Fc(R.selection.getRng()), $o = $t ? [
        V,
        ...re
      ] : re, Mo = $t && ks(V) ? Gg : fp;
      Fr.each($o, (bo) => {
        Mo(R, bo, Pe, $e);
      }), R.selection.setRng(Di(vo));
    }
  }, qg = (R) => "list-style-type" in R, mp = (R, V, re, Pe) => {
    if (V !== R.getBody())
      if (V)
        if (V.nodeName === re && !qg(Pe) && !ks(V))
          Rh(R);
        else {
          const $e = Fc(R.selection.getRng());
          ks(V) && V.classList.forEach((vo, $o, Mo) => {
            vo.startsWith("tox-") && (Mo.remove(vo), Mo.length === 0 && V.removeAttribute("class"));
          }), $c(R.dom, V, Pe);
          const $t = R.dom.rename(V, re);
          Ql(R.dom, $t), R.selection.setRng(Di($e)), wi(R, re, Pe), Bs(R, Bc(re), $t);
        }
      else
        wi(R, re, Pe), Bs(R, Bc(re), V);
  }, wm = (R, V, re) => {
    const Pe = Yr(R);
    if (yi(R, Pe))
      return;
    const $e = cd(R), $t = k(re) ? re : {};
    $e.length > 0 ? kv(R, Pe, $e, V, $t) : mp(R, Pe, V, $t);
  }, Mu = Yo.DOM, Mh = (R, V) => {
    const re = V.parentElement;
    if (re && re.nodeName === "LI" && re.firstChild === V) {
      const Pe = re.previousSibling;
      Pe && Pe.nodeName === "LI" ? (Pe.appendChild(V), gi(R, re) && Mu.remove(re)) : Mu.setStyle(re, "listStyleType", "none");
    }
    if (ai(re)) {
      const Pe = re.previousSibling;
      Pe && Pe.nodeName === "LI" && Pe.appendChild(V);
    }
  }, Is = (R, V) => {
    const re = Fr.grep(R.select("ol,ul", V));
    Fr.each(re, (Pe) => {
      Mh(R, Pe);
    });
  }, aa = (R, V, re, Pe) => {
    let $e = V.startContainer;
    const $t = V.startOffset;
    if (vs($e) && (re ? $t < $e.data.length : $t > 0))
      return $e;
    const vo = R.schema.getNonEmptyElements();
    es($e) && ($e = Ne.getNode($e, $t));
    const $o = new Ie($e, Pe);
    re && au(R.dom, $e) && $o.next();
    const Mo = re ? $o.next.bind($o) : $o.prev2.bind($o);
    for (; $e = Mo(); )
      if ($e.nodeName === "LI" && !$e.hasChildNodes() || vo[$e.nodeName] || vs($e) && $e.data.length > 0)
        return $e;
    return null;
  }, Cl = (R, V) => {
    const re = V.childNodes;
    return re.length === 1 && !ai(re[0]) && R.isBlock(re[0]);
  }, Ih = (R) => ve.from(R).map(jn.fromDom).filter(Oo).exists((V) => Re(V) && !ot(["details"], at(V))), Fh = (R, V) => {
    Cl(R, V) && Ih(V.firstChild) && R.remove(V.firstChild, !0);
  }, Ra = (R, V, re) => {
    let Pe;
    const $e = Cl(R, re) ? re.firstChild : re;
    if (Fh(R, V), !gi(R, V, !0))
      for (; Pe = V.firstChild; )
        $e.appendChild(Pe);
  }, no = (R, V, re) => {
    let Pe;
    const $e = V.parentNode;
    if (!Ml(R, V) || !Ml(R, re))
      return;
    ai(re.lastChild) && (Pe = re.lastChild), $e === re.lastChild && Oi($e.previousSibling) && R.remove($e.previousSibling);
    const $t = re.lastChild;
    $t && Oi($t) && V.hasChildNodes() && R.remove($t), gi(R, re, !0) && He(jn.fromDom(re)), Ra(R, V, re), Pe && re.appendChild(Pe);
    const $o = Vt(jn.fromDom(re), jn.fromDom(V)) ? R.getParents(V, ai, re) : [];
    R.remove(V), ye($o, (Mo) => {
      gi(R, Mo) && Mo !== R.getRoot() && R.remove(Mo);
    });
  }, cu = (R, V, re) => {
    He(jn.fromDom(re)), no(R.dom, V, re), R.selection.setCursorLocation(re, 0);
  }, Kg = (R, V, re, Pe) => {
    const $e = R.dom;
    if ($e.isEmpty(Pe))
      cu(R, re, Pe);
    else {
      const $t = Fc(V);
      no($e, re, Pe), R.selection.setRng(Di($t));
    }
  }, za = (R, V, re, Pe) => {
    const $e = Fc(V);
    no(R.dom, re, Pe);
    const $t = Di($e);
    R.selection.setRng($t);
  }, ms = (R, V) => {
    const re = R.dom, Pe = R.selection, $e = Pe.getStart(), $t = Ee(R, $e), vo = re.getParent(Pe.getStart(), "LI", $t);
    if (vo) {
      const $o = vo.parentElement;
      if ($o === R.getBody() && gi(re, $o))
        return !0;
      const Mo = lr(Pe.getRng()), bo = re.getParent(aa(R, Mo, V, $t), "LI", $t), Vs = bo && (V ? re.isChildOf(vo, bo) : re.isChildOf(bo, vo));
      if (bo && bo !== vo && !Vs)
        return R.undoManager.transact(() => {
          V ? Kg(R, Mo, bo, vo) : cl(vo) ? Nu(R) : za(R, Mo, vo, bo);
        }), !0;
      if (Vs && !V && bo !== vo)
        return R.undoManager.transact(() => {
          if (Mo.commonAncestorContainer.parentElement) {
            const ma = Fc(Mo), _l = Mo.commonAncestorContainer.parentElement;
            Ra(re, Mo.commonAncestorContainer.parentElement, bo), _l.remove();
            const ba = Di(ma);
            R.selection.setRng(ba);
          }
        }), !0;
      if (!bo && !V && Mo.startOffset === 0 && Mo.endOffset === 0)
        return R.undoManager.transact(() => {
          Rh(R);
        }), !0;
    }
    return !1;
  }, qd = (R, V, re) => {
    const Pe = R.getParent(V.parentNode, R.isBlock, re);
    R.remove(V), Pe && R.isEmpty(Pe) && R.remove(Pe);
  }, Bh = (R, V) => {
    const re = R.dom, Pe = R.selection.getStart(), $e = Ee(R, Pe), $t = re.getParent(Pe, re.isBlock, $e);
    if ($t && re.isEmpty($t, void 0, { checkRootAsContent: !0 })) {
      const vo = lr(R.selection.getRng()), $o = re.getParent(aa(R, vo, V, $e), "LI", $e);
      if ($o) {
        const Mo = (_l) => ot([
          "td",
          "th",
          "caption"
        ], at(_l)), bo = (_l) => _l.dom === $e, Vs = cr(jn.fromDom($o), Mo, bo), ma = cr(jn.fromDom(vo.startContainer), Mo, bo);
        return tt(Vs, ma, xn) ? (R.undoManager.transact(() => {
          const _l = $o.parentNode;
          qd(re, $t, $e), Ql(re, _l), R.selection.select($o, !0), R.selection.collapse(V);
        }), !0) : !1;
      }
    }
    return !1;
  }, pp = (R, V) => ms(R, V) || Bh(R, V), hp = (R) => {
    const V = R.selection.getStart(), re = Ee(R, V);
    return R.dom.getParent(V, "LI,DT,DD", re) || K(R).length > 0;
  }, zo = (R) => hp(R) ? (R.undoManager.transact(() => {
    R.execCommand("Delete"), Is(R.dom, R.getBody());
  }), !0) : !1, fa = (R, V) => {
    const re = R.selection;
    return !yi(R, re.getNode()) && (re.isCollapsed() ? pp(R, V) : zo(R));
  }, Rf = (R) => {
    R.on("ExecCommand", (V) => {
      const re = V.command.toLowerCase();
      (re === "delete" || re === "forwarddelete") && hp(R) && Is(R.dom, R.getBody());
    }), R.on("keydown", (V) => {
      V.keyCode === Bt.BACKSPACE ? fa(R, !1) && V.preventDefault() : V.keyCode === Bt.DELETE && fa(R, !0) && V.preventDefault();
    });
  }, Sl = (R) => ({
    backspaceDelete: (V) => {
      fa(R, V);
    }
  }), fl = (R, V) => {
    const re = Yr(R);
    re === null || yi(R, re) || R.undoManager.transact(() => {
      k(V.styles) && R.dom.setStyles(re, V.styles), k(V.attrs) && eo(V.attrs, (Pe, $e) => R.dom.setAttrib(re, $e, Pe));
    });
  }, kl = (R) => {
    const V = tn(vm(R).split("")), re = je(V, (Pe, $e) => {
      const $t = Pe.toUpperCase().charCodeAt(0) - 65 + 1;
      return Math.pow(26, $e) * $t;
    });
    return qe(re, (Pe, $e) => Pe + $e, 0);
  }, Na = (R) => {
    if (R--, R < 0)
      return "";
    {
      const V = R % 26, re = Math.floor(R / 26), Pe = Na(re), $e = String.fromCharCode(65 + V);
      return Pe + $e;
    }
  }, Ki = (R) => /^[A-Z]+$/.test(R), Jl = (R) => /^[a-z]+$/.test(R), Cm = (R) => /^[0-9]+$/.test(R), Ys = (R) => Cm(R) ? 2 : Ki(R) ? 0 : Jl(R) ? 1 : zs(R) ? 3 : 4, $h = (R) => {
    switch (Ys(R)) {
      case 2:
        return ve.some({
          listStyleType: ve.none(),
          start: R
        });
      case 0:
        return ve.some({
          listStyleType: ve.some("upper-alpha"),
          start: kl(R).toString()
        });
      case 1:
        return ve.some({
          listStyleType: ve.some("lower-alpha"),
          start: kl(R).toString()
        });
      case 3:
        return ve.some({
          listStyleType: ve.none(),
          start: ""
        });
      case 4:
        return ve.none();
    }
  }, wa = (R) => {
    const V = parseInt(R.start, 10);
    return on(R.listStyleType, "upper-alpha") ? Na(V) : on(R.listStyleType, "lower-alpha") ? Na(V).toLowerCase() : R.start;
  }, pd = (R) => {
    const V = Yr(R);
    !Lr(V) || yi(R, V) || R.windowManager.open({
      title: "List Properties",
      body: {
        type: "panel",
        items: [{
          type: "input",
          name: "start",
          label: "Start list at number",
          inputMode: "numeric"
        }]
      },
      initialData: {
        start: wa({
          start: R.dom.getAttrib(V, "start", "1"),
          listStyleType: ve.from(R.dom.getStyle(V, "list-style-type"))
        })
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      onSubmit: (re) => {
        const Pe = re.getData();
        $h(Pe.start).each(($e) => {
          R.execCommand("mceListUpdate", !1, {
            attrs: { start: $e.start === "1" ? "" : $e.start },
            styles: { "list-style-type": $e.listStyleType.getOr("") }
          });
        }), re.close();
      }
    });
  }, Lc = (R, V) => () => {
    const re = Yr(R);
    return W(re) && re.nodeName === V;
  }, ys = (R) => {
    R.addCommand("mceListProps", () => {
      pd(R);
    });
  }, Hc = (R) => {
    R.on("BeforeExecCommand", (V) => {
      const re = V.command.toLowerCase();
      re === "indent" ? wl(R) : re === "outdent" && Nu(R);
    }), R.addCommand("InsertUnorderedList", (V, re) => {
      wm(R, "UL", re);
    }), R.addCommand("InsertOrderedList", (V, re) => {
      wm(R, "OL", re);
    }), R.addCommand("InsertDefinitionList", (V, re) => {
      wm(R, "DL", re);
    }), R.addCommand("RemoveList", () => {
      Rh(R);
    }), ys(R), R.addCommand("mceListUpdate", (V, re) => {
      k(re) && fl(R, re);
    }), R.addQueryStateHandler("InsertUnorderedList", Lc(R, "UL")), R.addQueryStateHandler("InsertOrderedList", Lc(R, "OL")), R.addQueryStateHandler("InsertDefinitionList", Lc(R, "DL"));
  };
  var Nf = tinymce.util.Tools.resolve("tinymce.html.Node");
  const Iu = (R) => R.type === 3, Fs = (R) => R.length === 0, hd = (R) => {
    const V = ($e, $t) => {
      const vo = Nf.create("li");
      ye($e, ($o) => vo.append($o)), $t ? R.insert(vo, $t, !0) : R.append(vo);
    }, re = ($e, $t) => Iu($t) ? [
      ...$e,
      $t
    ] : !Fs($e) && !Iu($t) ? (V($e, $t), []) : $e, Pe = qe(R.children(), re, []);
    Fs(Pe) || V(Pe);
  }, ec = (R) => {
    R.on("PreInit", () => {
      const { parser: V } = R;
      V.addNodeFilter("ul,ol", (re) => ye(re, hd));
    });
  }, dr = (R) => {
    R.on("keydown", (V) => {
      V.keyCode !== Bt.TAB || Bt.metaKeyPressed(V) || R.undoManager.transact(() => {
        (V.shiftKey ? Nu(R) : wl(R)) && V.preventDefault();
      });
    });
  }, Kd = (R) => {
    Kl(R) && dr(R), Rf(R);
  }, Sm = (R, V) => (re) => {
    const Pe = ($e) => {
      re.setActive(ga($e.parents, V)), re.setEnabled(!yi(R, $e.element) && R.selection.isEditable());
    };
    return re.setEnabled(R.selection.isEditable()), Ns(R, Pe);
  }, gp = (R) => {
    const V = (re) => () => R.execCommand(re);
    R.hasPlugin("advlist") || (R.ui.registry.addToggleButton("numlist", {
      icon: "ordered-list",
      active: !1,
      tooltip: "Numbered list",
      onAction: V("InsertOrderedList"),
      onSetup: Sm(R, "OL")
    }), R.ui.registry.addToggleButton("bullist", {
      icon: "unordered-list",
      active: !1,
      tooltip: "Bullet list",
      onAction: V("InsertUnorderedList"),
      onSetup: Sm(R, "UL")
    }));
  }, Yg = (R, V) => (re) => Ns(R, ($e) => re.setEnabled(ga($e.parents, V) && !yi(R, $e.element))), bp = (R) => {
    const V = {
      text: "List properties...",
      icon: "ordered-list",
      onAction: () => R.execCommand("mceListProps"),
      onSetup: Yg(R, "OL")
    };
    R.ui.registry.addMenuItem("listprops", V), R.ui.registry.addContextMenu("lists", {
      update: (re) => {
        const Pe = Yr(R, re);
        return Lr(Pe) ? ["listprops"] : [];
      }
    });
  };
  var Xg = () => {
    o.add("lists", (R) => (Wi(R), ec(R), R.hasPlugin("rtc", !0) ? ys(R) : (Kd(R), Hc(R)), gp(R), bp(R), Sl(R)));
  };
  Xg();
})();
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const r = (Re, Oe, ct) => {
    var _t;
    return ct(Re, Oe.prototype) ? !0 : ((_t = Re.constructor) === null || _t === void 0 ? void 0 : _t.name) === Oe.name;
  }, i = (Re) => {
    const Oe = typeof Re;
    return Re === null ? "null" : Oe === "object" && Array.isArray(Re) ? "array" : Oe === "object" && r(Re, String, (ct, _t) => _t.isPrototypeOf(ct)) ? "string" : Oe;
  }, u = (Re) => (Oe) => i(Oe) === Re, h = u("string"), y = u("object"), k = u("array"), _ = (Re) => Re == null, D = (Re) => !_(Re);
  class L {
    constructor(Oe, ct) {
      this.tag = Oe, this.value = ct;
    }
    static some(Oe) {
      return new L(!0, Oe);
    }
    static none() {
      return L.singletonNone;
    }
    fold(Oe, ct) {
      return this.tag ? ct(this.value) : Oe();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(Oe) {
      return this.tag ? L.some(Oe(this.value)) : L.none();
    }
    bind(Oe) {
      return this.tag ? Oe(this.value) : L.none();
    }
    exists(Oe) {
      return this.tag && Oe(this.value);
    }
    forall(Oe) {
      return !this.tag || Oe(this.value);
    }
    filter(Oe) {
      return !this.tag || Oe(this.value) ? this : L.none();
    }
    getOr(Oe) {
      return this.tag ? this.value : Oe;
    }
    or(Oe) {
      return this.tag ? this : Oe;
    }
    getOrThunk(Oe) {
      return this.tag ? this.value : Oe();
    }
    orThunk(Oe) {
      return this.tag ? this : Oe();
    }
    getOrDie(Oe) {
      if (this.tag)
        return this.value;
      throw new Error(Oe ?? "Called getOrDie on None");
    }
    static from(Oe) {
      return D(Oe) ? L.some(Oe) : L.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(Oe) {
      this.tag && Oe(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  L.singletonNone = new L(!1);
  const W = Array.prototype.push, se = (Re, Oe) => {
    for (let ct = 0, _t = Re.length; ct < _t; ct++) {
      const Kn = Re[ct];
      Oe(Kn, ct);
    }
  }, J = (Re) => {
    const Oe = [];
    for (let ct = 0, _t = Re.length; ct < _t; ++ct) {
      if (!k(Re[ct]))
        throw new Error("Arr.flatten item " + ct + " was not an array, input: " + Re);
      W.apply(Oe, Re[ct]);
    }
    return Oe;
  }, be = (Re) => {
    let Oe = Re;
    return {
      get: () => Oe,
      set: (Kn) => {
        Oe = Kn;
      }
    };
  }, ke = Object.keys, Ce = Object.hasOwnProperty, Q = (Re, Oe) => {
    const ct = ke(Re);
    for (let _t = 0, Kn = ct.length; _t < Kn; _t++) {
      const io = ct[_t], Bo = Re[io];
      Oe(Bo, io);
    }
  }, oe = (Re, Oe) => ae(Re, Oe) ? L.from(Re[Oe]) : L.none(), ae = (Re, Oe) => Ce.call(Re, Oe), G = (Re) => (Oe) => Oe.options.get(Re), ve = (Re) => {
    const Oe = Re.options.register;
    Oe("audio_template_callback", { processor: "function" }), Oe("video_template_callback", { processor: "function" }), Oe("iframe_template_callback", { processor: "function" }), Oe("media_live_embeds", {
      processor: "boolean",
      default: !0
    }), Oe("media_filter_html", {
      processor: "boolean",
      default: !0
    }), Oe("media_url_resolver", { processor: "function" }), Oe("media_alt_source", {
      processor: "boolean",
      default: !0
    }), Oe("media_poster", {
      processor: "boolean",
      default: !0
    }), Oe("media_dimensions", {
      processor: "boolean",
      default: !0
    });
  }, nt = G("audio_template_callback"), Xe = G("video_template_callback"), te = G("iframe_template_callback"), lt = G("media_live_embeds"), ot = G("media_filter_html"), Kt = G("media_url_resolver"), je = G("media_alt_source"), ye = G("media_poster"), dn = G("media_dimensions");
  var wt = tinymce.util.Tools.resolve("tinymce.util.Tools"), qe = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), B = tinymce.util.Tools.resolve("tinymce.html.DomParser");
  const mn = qe.DOM, dt = (Re) => Re.replace(/px$/, ""), En = (Re) => {
    const Oe = Re.attr("style"), ct = Oe ? mn.parseStyle(Oe) : {};
    return {
      type: "ephox-embed-iri",
      source: Re.attr("data-ephox-embed-iri"),
      altsource: "",
      poster: "",
      width: oe(ct, "max-width").map(dt).getOr(""),
      height: oe(ct, "max-height").map(dt).getOr("")
    };
  }, tn = (Re, Oe) => {
    let ct = {};
    const Kn = B({
      validate: !1,
      forced_root_block: !1
    }, Oe).parse(Re);
    for (let io = Kn; io; io = io.walk())
      if (io.type === 1) {
        const Bo = io.name;
        if (io.attr("data-ephox-embed-iri")) {
          ct = En(io);
          break;
        } else
          !ct.source && Bo === "param" && (ct.source = io.attr("movie")), (Bo === "iframe" || Bo === "object" || Bo === "embed" || Bo === "video" || Bo === "audio") && (ct.type || (ct.type = Bo), ct = wt.extend(io.attributes.map, ct)), Bo === "source" && (ct.source ? ct.altsource || (ct.altsource = io.attr("src")) : ct.source = io.attr("src")), Bo === "img" && !ct.poster && (ct.poster = io.attr("src"));
      }
    return ct.source = ct.source || ct.src || "", ct.altsource = ct.altsource || "", ct.poster = ct.poster || "", ct;
  }, Le = (Re) => {
    var Oe;
    const ct = {
      mp3: "audio/mpeg",
      m4a: "audio/x-m4a",
      wav: "audio/wav",
      mp4: "video/mp4",
      webm: "video/webm",
      ogg: "video/ogg",
      swf: "application/x-shockwave-flash"
    }, _t = (Oe = Re.toLowerCase().split(".").pop()) !== null && Oe !== void 0 ? Oe : "";
    return oe(ct, _t).getOr("");
  };
  var jt = tinymce.util.Tools.resolve("tinymce.html.Node"), Fn = tinymce.util.Tools.resolve("tinymce.html.Serializer");
  const St = (Re, Oe = {}) => B({
    forced_root_block: !1,
    validate: !1,
    allow_conditional_comments: !0,
    ...Oe
  }, Re), on = qe.DOM, tt = (Re) => /^[0-9.]+$/.test(Re) ? Re + "px" : Re, mt = (Re, Oe) => {
    const ct = Oe.attr("style"), _t = ct ? on.parseStyle(ct) : {};
    D(Re.width) && (_t["max-width"] = tt(Re.width)), D(Re.height) && (_t["max-height"] = tt(Re.height)), Oe.attr("style", on.serializeStyle(_t));
  }, Y = [
    "source",
    "altsource"
  ], Wo = (Re, Oe, ct, _t) => {
    let Kn = 0, io = 0;
    const Bo = St(_t);
    Bo.addNodeFilter("source", (He) => Kn = He.length);
    const Jr = Bo.parse(Re);
    for (let He = Jr; He; He = He.walk())
      if (He.type === 1) {
        const Do = He.name;
        if (He.attr("data-ephox-embed-iri")) {
          mt(Oe, He);
          break;
        } else {
          switch (Do) {
            case "video":
            case "object":
            case "embed":
            case "img":
            case "iframe":
              Oe.height !== void 0 && Oe.width !== void 0 && (He.attr("width", Oe.width), He.attr("height", Oe.height));
              break;
          }
          if (ct)
            switch (Do) {
              case "video":
                He.attr("poster", Oe.poster), He.attr("src", null);
                for (let Ie = Kn; Ie < 2; Ie++)
                  if (Oe[Y[Ie]]) {
                    const Bt = new jt("source", 1);
                    Bt.attr("src", Oe[Y[Ie]]), Bt.attr("type", Oe[Y[Ie] + "mime"] || null), He.append(Bt);
                  }
                break;
              case "iframe":
                He.attr("src", Oe.source);
                break;
              case "object":
                const Ne = He.getAll("img").length > 0;
                if (Oe.poster && !Ne) {
                  He.attr("src", Oe.poster);
                  const Ie = new jt("img", 1);
                  Ie.attr("src", Oe.poster), Ie.attr("width", Oe.width), Ie.attr("height", Oe.height), He.append(Ie);
                }
                break;
              case "source":
                if (io < 2 && (He.attr("src", Oe[Y[io]]), He.attr("type", Oe[Y[io] + "mime"] || null), !Oe[Y[io]])) {
                  He.remove();
                  continue;
                }
                io++;
                break;
              case "img":
                Oe.poster || He.remove();
                break;
            }
        }
      }
    return Fn({}, _t).serialize(Jr);
  }, To = [
    {
      regex: /youtu\.be\/([\w\-_\?&=.]+)/i,
      type: "iframe",
      w: 560,
      h: 314,
      url: "www.youtube.com/embed/$1",
      allowFullscreen: !0
    },
    {
      regex: /youtube\.com(.+)v=([^&]+)(&([a-z0-9&=\-_]+))?/i,
      type: "iframe",
      w: 560,
      h: 314,
      url: "www.youtube.com/embed/$2?$4",
      allowFullscreen: !0
    },
    {
      regex: /youtube.com\/embed\/([a-z0-9\?&=\-_]+)/i,
      type: "iframe",
      w: 560,
      h: 314,
      url: "www.youtube.com/embed/$1",
      allowFullscreen: !0
    },
    {
      regex: /vimeo\.com\/([0-9]+)\?h=(\w+)/,
      type: "iframe",
      w: 425,
      h: 350,
      url: "player.vimeo.com/video/$1?h=$2&title=0&byline=0&portrait=0&color=8dc7dc",
      allowFullscreen: !0
    },
    {
      regex: /vimeo\.com\/(.*)\/([0-9]+)\?h=(\w+)/,
      type: "iframe",
      w: 425,
      h: 350,
      url: "player.vimeo.com/video/$2?h=$3&title=0&amp;byline=0",
      allowFullscreen: !0
    },
    {
      regex: /vimeo\.com\/([0-9]+)/,
      type: "iframe",
      w: 425,
      h: 350,
      url: "player.vimeo.com/video/$1?title=0&byline=0&portrait=0&color=8dc7dc",
      allowFullscreen: !0
    },
    {
      regex: /vimeo\.com\/(.*)\/([0-9]+)/,
      type: "iframe",
      w: 425,
      h: 350,
      url: "player.vimeo.com/video/$2?title=0&amp;byline=0",
      allowFullscreen: !0
    },
    {
      regex: /maps\.google\.([a-z]{2,3})\/maps\/(.+)msid=(.+)/,
      type: "iframe",
      w: 425,
      h: 350,
      url: 'maps.google.com/maps/ms?msid=$2&output=embed"',
      allowFullscreen: !1
    },
    {
      regex: /dailymotion\.com\/video\/([^_]+)/,
      type: "iframe",
      w: 480,
      h: 270,
      url: "www.dailymotion.com/embed/video/$1",
      allowFullscreen: !0
    },
    {
      regex: /dai\.ly\/([^_]+)/,
      type: "iframe",
      w: 480,
      h: 270,
      url: "www.dailymotion.com/embed/video/$1",
      allowFullscreen: !0
    }
  ], Ot = (Re) => {
    const Oe = Re.match(/^(https?:\/\/|www\.)(.+)$/i);
    return Oe && Oe.length > 1 ? Oe[1] === "www." ? "https://" : Oe[1] : "https://";
  }, Mt = (Re, Oe) => {
    const ct = Ot(Oe), _t = Re.regex.exec(Oe);
    let Kn = ct + Re.url;
    if (D(_t))
      for (let io = 0; io < _t.length; io++)
        Kn = Kn.replace("$" + io, () => _t[io] ? _t[io] : "");
    return Kn.replace(/\?$/, "");
  }, zn = (Re) => {
    const Oe = To.filter((ct) => ct.regex.test(Re));
    return Oe.length > 0 ? wt.extend({}, Oe[0], { url: Mt(Oe[0], Re) }) : null;
  }, At = (Re, Oe) => {
    if (Oe)
      return Oe(Re);
    {
      const ct = Re.allowfullscreen ? ' allowFullscreen="1"' : "";
      return '<iframe src="' + Re.source + '" width="' + Re.width + '" height="' + Re.height + '"' + ct + "></iframe>";
    }
  }, $n = (Re) => {
    let Oe = '<object data="' + Re.source + '" width="' + Re.width + '" height="' + Re.height + '" type="application/x-shockwave-flash">';
    return Re.poster && (Oe += '<img src="' + Re.poster + '" width="' + Re.width + '" height="' + Re.height + '" />'), Oe += "</object>", Oe;
  }, en = (Re, Oe) => Oe ? Oe(Re) : '<audio controls="controls" src="' + Re.source + '">' + (Re.altsource ? `
<source src="` + Re.altsource + '"' + (Re.altsourcemime ? ' type="' + Re.altsourcemime + '"' : "") + ` />
` : "") + "</audio>", Ue = (Re, Oe) => Oe ? Oe(Re) : '<video width="' + Re.width + '" height="' + Re.height + '"' + (Re.poster ? ' poster="' + Re.poster + '"' : "") + ` controls="controls">
<source src="` + Re.source + '"' + (Re.sourcemime ? ' type="' + Re.sourcemime + '"' : "") + ` />
` + (Re.altsource ? '<source src="' + Re.altsource + '"' + (Re.altsourcemime ? ' type="' + Re.altsourcemime + '"' : "") + ` />
` : "") + "</video>", jn = (Re, Oe) => {
    var ct;
    const _t = wt.extend({}, Oe);
    if (!_t.source && (wt.extend(_t, tn((ct = _t.embed) !== null && ct !== void 0 ? ct : "", Re.schema)), !_t.source))
      return "";
    _t.altsource || (_t.altsource = ""), _t.poster || (_t.poster = ""), _t.source = Re.convertURL(_t.source, "source"), _t.altsource = Re.convertURL(_t.altsource, "source"), _t.sourcemime = Le(_t.source), _t.altsourcemime = Le(_t.altsource), _t.poster = Re.convertURL(_t.poster, "poster");
    const Kn = zn(_t.source);
    if (Kn && (_t.source = Kn.url, _t.type = Kn.type, _t.allowfullscreen = Kn.allowFullscreen, _t.width = _t.width || String(Kn.w), _t.height = _t.height || String(Kn.h)), _t.embed)
      return Wo(_t.embed, _t, !0, Re.schema);
    {
      const io = nt(Re), Bo = Xe(Re), Jr = te(Re);
      return _t.width = _t.width || "300", _t.height = _t.height || "150", wt.each(_t, (He, Do) => {
        _t[Do] = Re.dom.encode("" + He);
      }), _t.type === "iframe" ? At(_t, Jr) : _t.sourcemime === "application/x-shockwave-flash" ? $n(_t) : _t.sourcemime.indexOf("audio") !== -1 ? en(_t, io) : Ue(_t, Bo);
    }
  }, mo = (Re) => Re.hasAttribute("data-mce-object") || Re.hasAttribute("data-ephox-embed-iri"), xn = (Re) => {
    Re.on("mousedown", (Oe) => {
      const ct = Re.dom.getParent(Oe.target, ".mce-preview-object");
      ct && Re.dom.getAttrib(ct, "data-mce-selected") === "2" && Oe.stopImmediatePropagation();
    }), Re.on("click keyup touchend", () => {
      const Oe = Re.selection.getNode();
      Oe && Re.dom.hasClass(Oe, "mce-preview-object") && Re.dom.getAttrib(Oe, "data-mce-selected") && Oe.setAttribute("data-mce-selected", "2");
    }), Re.on("ObjectResized", (Oe) => {
      const ct = Oe.target;
      if (ct.getAttribute("data-mce-object")) {
        let _t = ct.getAttribute("data-mce-html");
        _t && (_t = unescape(_t), ct.setAttribute("data-mce-html", escape(Wo(_t, {
          width: String(Oe.width),
          height: String(Oe.height)
        }, !1, Re.schema))));
      }
    });
  }, Vt = {}, Ct = (Re, Oe, ct) => new Promise((_t, Kn) => {
    const io = (Bo) => (Bo.html && (Vt[Re.source] = Bo), _t({
      url: Re.source,
      html: Bo.html ? Bo.html : Oe(Re)
    }));
    Vt[Re.source] ? io(Vt[Re.source]) : ct({ url: Re.source }).then(io).catch(Kn);
  }), Jn = (Re, Oe) => Promise.resolve({
    html: Oe(Re),
    url: Re.source
  }), Pn = (Re) => (Oe) => jn(Re, Oe), so = (Re, Oe) => {
    const ct = Kt(Re);
    return ct ? Ct(Oe, Pn(Re), ct) : Jn(Oe, Pn(Re));
  }, pr = (Re) => ae(Vt, Re), nr = (Re, Oe) => oe(Oe, Re).bind((ct) => oe(ct, "meta")), Ko = (Re, Oe, ct) => (_t) => {
    const Kn = () => oe(Re, _t), io = () => oe(Oe, _t), Bo = (Do) => oe(Do, "value").bind((Ne) => Ne.length > 0 ? L.some(Ne) : L.none()), Jr = () => Kn().bind((Do) => y(Do) ? Bo(Do).orThunk(io) : io().orThunk(() => L.from(Do))), He = () => io().orThunk(() => Kn().bind((Do) => y(Do) ? Bo(Do) : L.from(Do)));
    return { [_t]: (_t === ct ? Jr() : He()).getOr("") };
  }, Qo = (Re, Oe) => {
    const ct = {};
    return oe(Re, "dimensions").each((_t) => {
      se([
        "width",
        "height"
      ], (Kn) => {
        oe(Oe, Kn).orThunk(() => oe(_t, Kn)).each((io) => ct[Kn] = io);
      });
    }), ct;
  }, Mr = (Re, Oe) => {
    const ct = Oe && Oe !== "dimensions" ? nr(Oe, Re).getOr({}) : {}, _t = Ko(Re, ct, Oe);
    return {
      ..._t("source"),
      ..._t("altsource"),
      ..._t("poster"),
      ..._t("embed"),
      ...Qo(Re, ct)
    };
  }, at = (Re) => {
    const Oe = {
      ...Re,
      source: { value: oe(Re, "source").getOr("") },
      altsource: { value: oe(Re, "altsource").getOr("") },
      poster: { value: oe(Re, "poster").getOr("") }
    };
    return se([
      "width",
      "height"
    ], (ct) => {
      oe(Re, ct).each((_t) => {
        const Kn = Oe.dimensions || {};
        Kn[ct] = _t, Oe.dimensions = Kn;
      });
    }), Oe;
  }, kt = (Re) => (Oe) => {
    const ct = Oe && Oe.msg ? "Media embed handler error: " + Oe.msg : "Media embed handler threw unknown error.";
    Re.notificationManager.open({
      type: "error",
      text: ct
    });
  }, yn = (Re) => {
    const Oe = Re.selection.getNode(), ct = mo(Oe) ? Re.serializer.serialize(Oe, { selection: !0 }) : "", _t = tn(ct, Re.schema), io = (() => {
      if (or(_t.source, _t.type)) {
        const Bo = Re.dom.getRect(Oe);
        return {
          width: Bo.w.toString().replace(/px$/, ""),
          height: Bo.h.toString().replace(/px$/, "")
        };
      } else
        return {};
    })();
    return {
      embed: ct,
      ..._t,
      ...io
    };
  }, pn = (Re, Oe) => (ct) => {
    if (h(ct.url) && ct.url.trim().length > 0) {
      const _t = ct.html, io = {
        ...tn(_t, Oe.schema),
        source: ct.url,
        embed: _t
      };
      Re.setData(at(io));
    }
  }, Oo = (Re, Oe) => {
    const ct = Re.dom.select("*[data-mce-object]");
    for (let _t = 0; _t < Oe.length; _t++)
      for (let Kn = ct.length - 1; Kn >= 0; Kn--)
        Oe[_t] === ct[Kn] && ct.splice(Kn, 1);
    Re.selection.select(ct[0]);
  }, hr = (Re, Oe) => {
    const ct = Re.dom.select("*[data-mce-object]");
    Re.insertContent(Oe), Oo(Re, ct), Re.nodeChanged();
  }, or = (Re, Oe) => D(Oe) && Oe === "ephox-embed-iri" && D(zn(Re)), Ir = (Re, Oe) => ((_t, Kn) => _t.width !== Kn.width || _t.height !== Kn.height)(Re, Oe) && or(Oe.source, Re.type), Zo = (Re, Oe, ct) => {
    var _t;
    Oe.embed = Ir(Re, Oe) && dn(ct) ? jn(ct, {
      ...Oe,
      embed: ""
    }) : Wo((_t = Oe.embed) !== null && _t !== void 0 ? _t : "", Oe, !1, ct.schema), Oe.embed && (Re.source === Oe.source || pr(Oe.source)) ? hr(ct, Oe.embed) : so(ct, Oe).then((Kn) => {
      hr(ct, Kn.html);
    }).catch(kt(ct));
  }, Tr = (Re) => {
    const Oe = yn(Re), ct = be(Oe), _t = at(Oe), Kn = (qn, Qn) => {
      const lo = Mr(Qn.getData(), "source");
      qn.source !== lo.source && (pn(Gn, Re)({
        url: lo.source,
        html: ""
      }), so(Re, lo).then(pn(Gn, Re)).catch(kt(Re)));
    }, io = (qn) => {
      var Qn;
      const lo = Mr(qn.getData()), rr = tn((Qn = lo.embed) !== null && Qn !== void 0 ? Qn : "", Re.schema);
      qn.setData(at(rr));
    }, Bo = (qn, Qn, lo) => {
      const rr = Mr(qn.getData(), Qn), Kr = Ir(lo, rr) && dn(Re) ? {
        ...rr,
        embed: ""
      } : rr, Wa = jn(Re, Kr);
      qn.setData(at({
        ...Kr,
        embed: Wa
      }));
    }, Jr = [{
      name: "source",
      type: "urlinput",
      filetype: "media",
      label: "Source",
      picker_text: "Browse files"
    }], He = dn(Re) ? [{
      type: "sizeinput",
      name: "dimensions",
      label: "Constrain proportions",
      constrain: !0
    }] : [], Do = {
      title: "General",
      name: "general",
      items: J([
        Jr,
        He
      ])
    }, Ie = {
      title: "Embed",
      items: [{
        type: "textarea",
        name: "embed",
        label: "Paste your embed code below:"
      }]
    }, Bt = [];
    je(Re) && Bt.push({
      name: "altsource",
      type: "urlinput",
      filetype: "media",
      label: "Alternative source URL"
    }), ye(Re) && Bt.push({
      name: "poster",
      type: "urlinput",
      filetype: "image",
      label: "Media poster (Image URL)"
    });
    const Wt = {
      title: "Advanced",
      name: "advanced",
      items: Bt
    }, kn = [
      Do,
      Ie
    ];
    Bt.length > 0 && kn.push(Wt);
    const eo = {
      type: "tabpanel",
      tabs: kn
    }, Gn = Re.windowManager.open({
      title: "Insert/Edit Media",
      size: "normal",
      body: eo,
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      onSubmit: (qn) => {
        const Qn = Mr(qn.getData());
        Zo(ct.get(), Qn, Re), qn.close();
      },
      onChange: (qn, Qn) => {
        switch (Qn.name) {
          case "source":
            Kn(ct.get(), qn);
            break;
          case "embed":
            io(qn);
            break;
          case "dimensions":
          case "altsource":
          case "poster":
            Bo(qn, Qn.name, ct.get());
            break;
        }
        ct.set(Mr(qn.getData()));
      },
      initialData: _t
    });
  }, Ht = (Re) => ({ showDialog: () => {
    Tr(Re);
  } }), Ho = (Re) => {
    const Oe = () => {
      Tr(Re);
    };
    Re.addCommand("mceMedia", Oe);
  }, As = (Re, Oe, ct) => Re.length >= Oe.length && Re.substr(ct, ct + Oe.length) === Oe, ra = (Re, Oe) => As(Re, Oe, 0);
  var qs = tinymce.util.Tools.resolve("tinymce.Env");
  const Ks = (Re) => {
    const Oe = Re.name;
    return Oe === "iframe" || Oe === "video" || Oe === "audio";
  }, kr = (Re, Oe, ct, _t = null) => {
    const Kn = Re.attr(ct);
    return D(Kn) ? Kn : ae(Oe, ct) ? null : _t;
  }, xa = (Re, Oe, ct) => {
    const _t = Oe.name === "img" || Re.name === "video", Kn = _t ? "300" : null, io = Re.name === "audio" ? "30" : "150", Bo = _t ? io : null;
    Oe.attr({
      width: kr(Re, ct, "width", Kn),
      height: kr(Re, ct, "height", Bo)
    });
  }, ca = (Re, Oe, ct, _t) => {
    const Kn = St(Re.schema).parse(_t, { context: Oe });
    for (; Kn.firstChild; )
      ct.append(Kn.firstChild);
  }, Or = (Re, Oe) => {
    const ct = Oe.name, _t = new jt("img", 1);
    return Ss(Re, Oe, _t), xa(Oe, _t, {}), _t.attr({
      style: Oe.attr("style"),
      src: qs.transparentSrc,
      "data-mce-object": ct,
      class: "mce-object mce-object-" + ct
    }), _t;
  }, Xn = (Re, Oe) => {
    var ct;
    const _t = Oe.name, Kn = new jt("span", 1);
    Kn.attr({
      contentEditable: "false",
      style: Oe.attr("style"),
      "data-mce-object": _t,
      class: "mce-preview-object mce-object-" + _t
    }), Ss(Re, Oe, Kn);
    const io = Re.dom.parseStyle((ct = Oe.attr("style")) !== null && ct !== void 0 ? ct : ""), Bo = new jt(_t, 1);
    if (xa(Oe, Bo, io), Bo.attr({
      src: Oe.attr("src"),
      style: Oe.attr("style"),
      class: Oe.attr("class")
    }), _t === "iframe")
      Bo.attr({
        allowfullscreen: Oe.attr("allowfullscreen"),
        frameborder: "0",
        sandbox: Oe.attr("sandbox"),
        referrerpolicy: Oe.attr("referrerpolicy")
      });
    else {
      se([
        "controls",
        "crossorigin",
        "currentTime",
        "loop",
        "muted",
        "poster",
        "preload"
      ], (Ne) => {
        Bo.attr(Ne, Oe.attr(Ne));
      });
      const Do = Kn.attr("data-mce-html");
      D(Do) && ca(Re, _t, Bo, unescape(Do));
    }
    const Jr = new jt("span", 1);
    return Jr.attr("class", "mce-shim"), Kn.append(Bo), Kn.append(Jr), Kn;
  }, Ss = (Re, Oe, ct) => {
    var _t;
    const Kn = (_t = Oe.attributes) !== null && _t !== void 0 ? _t : [];
    let io = Kn.length;
    for (; io--; ) {
      const Do = Kn[io].name;
      let Ne = Kn[io].value;
      Do !== "width" && Do !== "height" && Do !== "style" && !ra(Do, "data-mce-") && ((Do === "data" || Do === "src") && (Ne = Re.convertURL(Ne, Do)), ct.attr("data-mce-p-" + Do, Ne));
    }
    const Bo = Fn({ inner: !0 }, Re.schema), Jr = new jt("div", 1);
    se(Oe.children(), (Do) => Jr.append(Do));
    const He = Bo.serialize(Jr);
    He && (ct.attr("data-mce-html", escape(He)), ct.empty());
  }, Ke = (Re) => {
    const Oe = Re.attr("class");
    return h(Oe) && /\btiny-pageembed\b/.test(Oe);
  }, bt = (Re) => {
    let Oe = Re;
    for (; Oe = Oe.parent; )
      if (Oe.attr("data-ephox-embed-iri") || Ke(Oe))
        return !0;
    return !1;
  }, gn = (Re) => (Oe) => {
    let ct = Oe.length, _t;
    for (; ct--; )
      _t = Oe[ct], _t.parent && (_t.parent.attr("data-mce-object") || (Ks(_t) && lt(Re) ? bt(_t) || _t.replace(Xn(Re, _t)) : bt(_t) || _t.replace(Or(Re, _t))));
  }, Tn = (Re, Oe, ct) => {
    const _t = Re.options.get, Kn = _t("xss_sanitization"), io = ot(Re);
    return St(Re.schema, {
      sanitize: Kn,
      validate: io
    }).parse(ct, { context: Oe });
  }, Po = (Re) => {
    Re.on("PreInit", () => {
      const { schema: Oe, serializer: ct, parser: _t } = Re, Kn = Oe.getBoolAttrs();
      se("webkitallowfullscreen mozallowfullscreen".split(" "), (io) => {
        Kn[io] = {};
      }), Q({ embed: ["wmode"] }, (io, Bo) => {
        const Jr = Oe.getElementRule(Bo);
        Jr && se(io, (He) => {
          Jr.attributes[He] = {}, Jr.attributesOrder.push(He);
        });
      }), _t.addNodeFilter("iframe,video,audio,object,embed", gn(Re)), ct.addAttributeFilter("data-mce-object", (io, Bo) => {
        var Jr;
        let He = io.length;
        for (; He--; ) {
          const Do = io[He];
          if (!Do.parent)
            continue;
          const Ne = Do.attr(Bo), Ie = new jt(Ne, 1);
          if (Ne !== "audio") {
            const eo = Do.attr("class");
            eo && eo.indexOf("mce-preview-object") !== -1 && Do.firstChild ? Ie.attr({
              width: Do.firstChild.attr("width"),
              height: Do.firstChild.attr("height")
            }) : Ie.attr({
              width: Do.attr("width"),
              height: Do.attr("height")
            });
          }
          Ie.attr({ style: Do.attr("style") });
          const Bt = (Jr = Do.attributes) !== null && Jr !== void 0 ? Jr : [];
          let Wt = Bt.length;
          for (; Wt--; ) {
            const eo = Bt[Wt].name;
            eo.indexOf("data-mce-p-") === 0 && Ie.attr(eo.substr(11), Bt[Wt].value);
          }
          const kn = Do.attr("data-mce-html");
          if (kn) {
            const eo = Tn(Re, Ne, unescape(kn));
            se(eo.children(), (Gn) => Ie.append(Gn));
          }
          Do.replace(Ie);
        }
      });
    }), Re.on("SetContent", () => {
      const Oe = Re.dom;
      se(Oe.select("span.mce-preview-object"), (ct) => {
        Oe.select("span.mce-shim", ct).length === 0 && Oe.add(ct, "span", { class: "mce-shim" });
      });
    });
  }, cr = (Re) => {
    Re.on("ResolveName", (Oe) => {
      let ct;
      Oe.target.nodeType === 1 && (ct = Oe.target.getAttribute("data-mce-object")) && (Oe.name = ct);
    });
  }, ea = (Re) => (Oe) => {
    const ct = () => {
      Oe.setEnabled(Re.selection.isEditable());
    };
    return Re.on("NodeChange", ct), ct(), () => {
      Re.off("NodeChange", ct);
    };
  }, ta = (Re) => {
    const Oe = () => Re.execCommand("mceMedia");
    Re.ui.registry.addToggleButton("media", {
      tooltip: "Insert/edit media",
      icon: "embed",
      onAction: Oe,
      onSetup: (ct) => {
        const _t = Re.selection;
        ct.setActive(mo(_t.getNode()));
        const Kn = _t.selectorChangedWithUnbind("img[data-mce-object],span[data-mce-object],div[data-ephox-embed-iri]", ct.setActive).unbind, io = ea(Re)(ct);
        return () => {
          Kn(), io();
        };
      }
    }), Re.ui.registry.addMenuItem("media", {
      icon: "embed",
      text: "Media...",
      onAction: Oe,
      onSetup: ea(Re)
    });
  };
  var Ps = () => {
    o.add("media", (Re) => (ve(Re), Ho(Re), ta(Re), cr(Re), Po(Re), xn(Re), Ht(Re)));
  };
  Ps();
})();
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const r = (oe) => (ae) => typeof ae === oe, i = r("boolean"), u = r("number"), h = (oe) => (ae) => ae.options.get(oe), y = (oe) => {
    const ae = oe.options.register;
    ae("nonbreaking_force_tab", {
      processor: (G) => i(G) ? {
        value: G ? 3 : 0,
        valid: !0
      } : u(G) ? {
        value: G,
        valid: !0
      } : {
        valid: !1,
        message: "Must be a boolean or number."
      },
      default: !1
    }), ae("nonbreaking_wrap", {
      processor: "boolean",
      default: !0
    });
  }, k = h("nonbreaking_force_tab"), _ = h("nonbreaking_wrap"), D = (oe, ae) => {
    let G = "";
    for (let ve = 0; ve < ae; ve++)
      G += oe;
    return G;
  }, L = (oe) => oe.plugins.visualchars ? oe.plugins.visualchars.isEnabled() : !1, W = (oe, ae) => {
    const G = () => L(oe) ? "mce-nbsp-wrap mce-nbsp" : "mce-nbsp-wrap", ve = () => `<span class="${G()}" contenteditable="false">${D("&nbsp;", ae)}</span>`, Xe = _(oe) || oe.plugins.visualchars ? ve() : D("&nbsp;", ae);
    oe.undoManager.transact(() => oe.insertContent(Xe));
  }, se = (oe) => {
    oe.addCommand("mceNonBreaking", () => {
      W(oe, 1);
    });
  };
  var J = tinymce.util.Tools.resolve("tinymce.util.VK");
  const be = (oe) => {
    const ae = k(oe);
    ae > 0 && oe.on("keydown", (G) => {
      if (G.keyCode === J.TAB && !G.isDefaultPrevented()) {
        if (G.shiftKey)
          return;
        G.preventDefault(), G.stopImmediatePropagation(), W(oe, ae);
      }
    });
  }, ke = (oe) => (ae) => {
    const G = () => {
      ae.setEnabled(oe.selection.isEditable());
    };
    return oe.on("NodeChange", G), G(), () => {
      oe.off("NodeChange", G);
    };
  }, Ce = (oe) => {
    const ae = () => oe.execCommand("mceNonBreaking");
    oe.ui.registry.addButton("nonbreaking", {
      icon: "non-breaking",
      tooltip: "Nonbreaking space",
      onAction: ae,
      onSetup: ke(oe)
    }), oe.ui.registry.addMenuItem("nonbreaking", {
      icon: "non-breaking",
      text: "Nonbreaking space",
      onAction: ae,
      onSetup: ke(oe)
    });
  };
  var Q = () => {
    o.add("nonbreaking", (oe) => {
      y(oe), se(oe), Ce(oe), be(oe);
    });
  };
  Q();
})();
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const r = (Ot, Mt, zn) => {
    var At;
    return zn(Ot, Mt.prototype) ? !0 : ((At = Ot.constructor) === null || At === void 0 ? void 0 : At.name) === Mt.name;
  }, i = (Ot) => {
    const Mt = typeof Ot;
    return Ot === null ? "null" : Mt === "object" && Array.isArray(Ot) ? "array" : Mt === "object" && r(Ot, String, (zn, At) => At.isPrototypeOf(zn)) ? "string" : Mt;
  }, u = (Ot) => (Mt) => i(Mt) === Ot, h = (Ot) => (Mt) => typeof Mt === Ot, y = u("string"), k = h("boolean"), _ = (Ot) => Ot == null, D = (Ot) => !_(Ot), L = h("function"), W = (Ot) => (Mt) => Mt.options.get(Ot), se = (Ot) => {
    const Mt = Ot.options.register, zn = (Ue) => (jn) => {
      const mo = k(jn) || y(jn);
      return mo ? k(jn) ? {
        value: jn ? Ue : "",
        valid: mo
      } : {
        value: jn.trim(),
        valid: mo
      } : {
        valid: !1,
        message: "Must be a boolean or string."
      };
    }, At = "bold italic | quicklink h2 h3 blockquote";
    Mt("quickbars_selection_toolbar", {
      processor: zn(At),
      default: At
    });
    const $n = "quickimage quicktable";
    Mt("quickbars_insert_toolbar", {
      processor: zn($n),
      default: $n
    });
    const en = "alignleft aligncenter alignright";
    Mt("quickbars_image_toolbar", {
      processor: zn(en),
      default: en
    });
  }, J = W("quickbars_selection_toolbar"), be = W("quickbars_insert_toolbar"), ke = W("quickbars_image_toolbar");
  let Ce = 0;
  const Q = (Ot) => {
    const zn = (/* @__PURE__ */ new Date()).getTime(), At = Math.floor(Math.random() * 1e9);
    return Ce++, Ot + "_" + At + Ce + String(zn);
  }, oe = (Ot, Mt, zn) => {
    Ot.execCommand("mceInsertTable", !1, {
      rows: zn,
      columns: Mt
    });
  }, ae = (Ot, Mt, zn) => {
    const At = Ot.editorUpload.blobCache, $n = At.create(Q("mceu"), zn, Mt);
    At.add($n), Ot.insertContent(Ot.dom.createHTML("img", { src: $n.blobUri() }));
  }, G = (Ot) => new Promise((Mt) => {
    const zn = new FileReader();
    zn.onloadend = () => {
      Mt(zn.result.split(",")[1]);
    }, zn.readAsDataURL(Ot);
  });
  var ve = tinymce.util.Tools.resolve("tinymce.util.Delay");
  const nt = (Ot) => new Promise((Mt) => {
    let zn = !1;
    const At = document.createElement("input");
    At.type = "file", At.accept = "image/*", At.style.position = "fixed", At.style.left = "0", At.style.top = "0", At.style.opacity = "0.001", document.body.appendChild(At);
    const $n = (jn) => {
      var mo;
      zn || ((mo = At.parentNode) === null || mo === void 0 || mo.removeChild(At), zn = !0, Mt(jn));
    }, en = (jn) => {
      $n(Array.prototype.slice.call(jn.target.files));
    };
    At.addEventListener("input", en), At.addEventListener("change", en);
    const Ue = (jn) => {
      const mo = () => {
        $n([]);
      };
      zn || (jn.type === "focusin" ? ve.setEditorTimeout(Ot, mo, 1e3) : mo()), Ot.off("focusin remove", Ue);
    };
    Ot.on("focusin remove", Ue), At.click();
  }), Xe = (Ot) => {
    Ot.ui.registry.addButton("quickimage", {
      icon: "image",
      tooltip: "Insert image",
      onAction: () => {
        nt(Ot).then((Mt) => {
          if (Mt.length > 0) {
            const zn = Mt[0];
            G(zn).then((At) => {
              ae(Ot, At, zn);
            });
          }
        });
      }
    }), Ot.ui.registry.addButton("quicktable", {
      icon: "table",
      tooltip: "Insert table",
      onAction: () => {
        oe(Ot, 2, 2);
      }
    });
  }, lt = ((Ot) => () => Ot)(!1);
  class ot {
    constructor(Mt, zn) {
      this.tag = Mt, this.value = zn;
    }
    static some(Mt) {
      return new ot(!0, Mt);
    }
    static none() {
      return ot.singletonNone;
    }
    fold(Mt, zn) {
      return this.tag ? zn(this.value) : Mt();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(Mt) {
      return this.tag ? ot.some(Mt(this.value)) : ot.none();
    }
    bind(Mt) {
      return this.tag ? Mt(this.value) : ot.none();
    }
    exists(Mt) {
      return this.tag && Mt(this.value);
    }
    forall(Mt) {
      return !this.tag || Mt(this.value);
    }
    filter(Mt) {
      return !this.tag || Mt(this.value) ? this : ot.none();
    }
    getOr(Mt) {
      return this.tag ? this.value : Mt;
    }
    or(Mt) {
      return this.tag ? this : Mt;
    }
    getOrThunk(Mt) {
      return this.tag ? this.value : Mt();
    }
    orThunk(Mt) {
      return this.tag ? this : Mt();
    }
    getOrDie(Mt) {
      if (this.tag)
        return this.value;
      throw new Error(Mt ?? "Called getOrDie on None");
    }
    static from(Mt) {
      return D(Mt) ? ot.some(Mt) : ot.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(Mt) {
      this.tag && Mt(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  ot.singletonNone = new ot(!1), typeof window < "u" || Function("return this;")();
  const Kt = 1, je = (Ot) => Ot.dom.nodeName.toLowerCase(), ye = (Ot, Mt) => {
    const zn = Ot.dom;
    return zn && zn.hasAttribute ? zn.hasAttribute(Mt) : !1;
  };
  var dn = (Ot, Mt, zn, At, $n) => Ot(zn, At) ? ot.some(zn) : L($n) && $n(zn) ? ot.none() : Mt(zn, At, $n);
  const wt = (Ot, Mt) => {
    const At = (Mt || document).createElement("div");
    if (At.innerHTML = Ot, !At.hasChildNodes() || At.childNodes.length > 1) {
      const $n = "HTML does not have a single root node";
      throw console.error($n, Ot), new Error($n);
    }
    return mn(At.childNodes[0]);
  }, qe = (Ot, Mt) => {
    const At = (Mt || document).createElement(Ot);
    return mn(At);
  }, B = (Ot, Mt) => {
    const At = (Mt || document).createTextNode(Ot);
    return mn(At);
  }, mn = (Ot) => {
    if (Ot == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: Ot };
  }, En = {
    fromHtml: wt,
    fromTag: qe,
    fromText: B,
    fromDom: mn,
    fromPoint: (Ot, Mt, zn) => ot.from(Ot.dom.elementFromPoint(Mt, zn)).map(mn)
  }, tn = (Ot, Mt) => {
    const zn = Ot.dom;
    if (zn.nodeType !== Kt)
      return !1;
    {
      const At = zn;
      if (At.matches !== void 0)
        return At.matches(Mt);
      if (At.msMatchesSelector !== void 0)
        return At.msMatchesSelector(Mt);
      if (At.webkitMatchesSelector !== void 0)
        return At.webkitMatchesSelector(Mt);
      if (At.mozMatchesSelector !== void 0)
        return At.mozMatchesSelector(Mt);
      throw new Error("Browser lacks native selectors");
    }
  }, Le = (Ot, Mt, zn) => {
    let At = Ot.dom;
    const $n = L(zn) ? zn : lt;
    for (; At.parentNode; ) {
      At = At.parentNode;
      const en = En.fromDom(At);
      if (Mt(en))
        return ot.some(en);
      if ($n(en))
        break;
    }
    return ot.none();
  }, jt = (Ot, Mt, zn) => dn(($n, en) => en($n), Le, Ot, Mt, zn), Fn = (Ot, Mt, zn) => jt(Ot, Mt, zn).isSome(), St = (Ot, Mt, zn) => Le(Ot, (At) => tn(At, Mt), zn), on = (Ot, Mt, zn) => dn(($n, en) => tn($n, en), St, Ot, Mt, zn), tt = (Ot) => {
    const Mt = be(Ot);
    Mt.length > 0 && Ot.ui.registry.addContextToolbar("quickblock", {
      predicate: (zn) => {
        const At = En.fromDom(zn), $n = Ot.schema.getTextBlockElements(), en = (Ue) => Ue.dom === Ot.getBody();
        return !ye(At, "data-mce-bogus") && on(At, 'table,[data-mce-bogus="all"]', en).fold(() => Fn(At, (Ue) => je(Ue) in $n && Ot.dom.isEmpty(Ue.dom), en), lt);
      },
      items: Mt,
      position: "line",
      scope: "editor"
    });
  }, mt = (Ot) => Ot.dom.classList !== void 0, Y = (Ot, Mt) => mt(Ot) && Ot.dom.classList.contains(Mt), Wo = (Ot) => {
    const Mt = (Ue) => Ot.dom.isEditable(Ue), zn = (Ue) => Mt(Ue.parentElement), At = (Ue) => {
      const jn = Ue.nodeName === "FIGURE" && /image/i.test(Ue.className), mo = Ue.nodeName === "IMG" || jn, xn = Y(En.fromDom(Ue), "mce-pagebreak");
      return mo && zn(Ue) && !xn;
    }, $n = ke(Ot);
    $n.length > 0 && Ot.ui.registry.addContextToolbar("imageselection", {
      predicate: At,
      items: $n,
      position: "node"
    });
    const en = J(Ot);
    en.length > 0 && Ot.ui.registry.addContextToolbar("textselection", {
      predicate: (Ue) => !At(Ue) && !Ot.selection.isCollapsed() && Mt(Ue),
      items: en,
      position: "selection",
      scope: "editor"
    });
  };
  var To = () => {
    o.add("quickbars", (Ot) => {
      se(Ot), Xe(Ot), tt(Ot), Wo(Ot);
    });
  };
  To();
})();
(function() {
  const o = (Ne) => {
    let Ie = Ne;
    return {
      get: () => Ie,
      set: (kn) => {
        Ie = kn;
      }
    };
  };
  var r = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const i = (Ne, Ie, Bt) => {
    var Wt;
    return Bt(Ne, Ie.prototype) ? !0 : ((Wt = Ne.constructor) === null || Wt === void 0 ? void 0 : Wt.name) === Ie.name;
  }, u = (Ne) => {
    const Ie = typeof Ne;
    return Ne === null ? "null" : Ie === "object" && Array.isArray(Ne) ? "array" : Ie === "object" && i(Ne, String, (Bt, Wt) => Wt.isPrototypeOf(Bt)) ? "string" : Ie;
  }, h = (Ne) => (Ie) => u(Ie) === Ne, y = (Ne) => (Ie) => typeof Ie === Ne, k = h("string"), _ = h("array"), D = y("boolean"), L = (Ne) => Ne == null, W = (Ne) => !L(Ne), se = y("number"), J = () => {
  }, be = (Ne) => () => Ne, ke = be(!0), Q = be("[~|!-*+-\\/:;?@\\[-`{};----------------------------------------------]");
  class oe {
    constructor(Ie, Bt) {
      this.tag = Ie, this.value = Bt;
    }
    static some(Ie) {
      return new oe(!0, Ie);
    }
    static none() {
      return oe.singletonNone;
    }
    fold(Ie, Bt) {
      return this.tag ? Bt(this.value) : Ie();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(Ie) {
      return this.tag ? oe.some(Ie(this.value)) : oe.none();
    }
    bind(Ie) {
      return this.tag ? Ie(this.value) : oe.none();
    }
    exists(Ie) {
      return this.tag && Ie(this.value);
    }
    forall(Ie) {
      return !this.tag || Ie(this.value);
    }
    filter(Ie) {
      return !this.tag || Ie(this.value) ? this : oe.none();
    }
    getOr(Ie) {
      return this.tag ? this.value : Ie;
    }
    or(Ie) {
      return this.tag ? this : Ie;
    }
    getOrThunk(Ie) {
      return this.tag ? this.value : Ie();
    }
    orThunk(Ie) {
      return this.tag ? this : Ie();
    }
    getOrDie(Ie) {
      if (this.tag)
        return this.value;
      throw new Error(Ie ?? "Called getOrDie on None");
    }
    static from(Ie) {
      return W(Ie) ? oe.some(Ie) : oe.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(Ie) {
      this.tag && Ie(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  oe.singletonNone = new oe(!1);
  const ae = Q;
  var G = tinymce.util.Tools.resolve("tinymce.Env"), ve = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const nt = Array.prototype.slice, Xe = Array.prototype.push, te = (Ne, Ie) => {
    const Bt = Ne.length, Wt = new Array(Bt);
    for (let kn = 0; kn < Bt; kn++) {
      const eo = Ne[kn];
      Wt[kn] = Ie(eo, kn);
    }
    return Wt;
  }, lt = (Ne, Ie) => {
    for (let Bt = 0, Wt = Ne.length; Bt < Wt; Bt++) {
      const kn = Ne[Bt];
      Ie(kn, Bt);
    }
  }, ot = (Ne, Ie) => {
    for (let Bt = Ne.length - 1; Bt >= 0; Bt--) {
      const Wt = Ne[Bt];
      Ie(Wt, Bt);
    }
  }, Kt = (Ne, Ie) => {
    if (Ne.length === 0)
      return [];
    {
      let Bt = Ie(Ne[0]);
      const Wt = [];
      let kn = [];
      for (let eo = 0, Gn = Ne.length; eo < Gn; eo++) {
        const qn = Ne[eo], Qn = Ie(qn);
        Qn !== Bt && (Wt.push(kn), kn = []), Bt = Qn, kn.push(qn);
      }
      return kn.length !== 0 && Wt.push(kn), Wt;
    }
  }, je = (Ne, Ie, Bt) => (lt(Ne, (Wt, kn) => {
    Bt = Ie(Bt, Wt, kn);
  }), Bt), ye = (Ne) => {
    const Ie = [];
    for (let Bt = 0, Wt = Ne.length; Bt < Wt; ++Bt) {
      if (!_(Ne[Bt]))
        throw new Error("Arr.flatten item " + Bt + " was not an array, input: " + Ne);
      Xe.apply(Ie, Ne[Bt]);
    }
    return Ie;
  }, dn = (Ne, Ie) => ye(te(Ne, Ie)), wt = (Ne, Ie) => {
    const Bt = nt.call(Ne, 0);
    return Bt.sort(Ie), Bt;
  }, qe = Object.hasOwnProperty, B = (Ne, Ie) => qe.call(Ne, Ie);
  typeof window < "u" || Function("return this;")();
  const mn = 9, dt = 11, En = 1, tn = 3, Le = (Ne) => Ne.dom.nodeType, Fn = ((Ne) => (Ie) => Le(Ie) === Ne)(tn), St = (Ne, Ie, Bt) => {
    if (k(Bt) || D(Bt) || se(Bt))
      Ne.setAttribute(Ie, Bt + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", Ie, ":: Value ", Bt, ":: Element ", Ne), new Error("Attribute value was not simple");
  }, on = (Ne, Ie, Bt) => {
    St(Ne.dom, Ie, Bt);
  }, tt = (Ne, Ie) => {
    const Wt = (Ie || document).createElement("div");
    if (Wt.innerHTML = Ne, !Wt.hasChildNodes() || Wt.childNodes.length > 1) {
      const kn = "HTML does not have a single root node";
      throw console.error(kn, Ne), new Error(kn);
    }
    return Wo(Wt.childNodes[0]);
  }, mt = (Ne, Ie) => {
    const Wt = (Ie || document).createElement(Ne);
    return Wo(Wt);
  }, Y = (Ne, Ie) => {
    const Wt = (Ie || document).createTextNode(Ne);
    return Wo(Wt);
  }, Wo = (Ne) => {
    if (Ne == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: Ne };
  }, Ot = {
    fromHtml: tt,
    fromTag: mt,
    fromText: Y,
    fromDom: Wo,
    fromPoint: (Ne, Ie, Bt) => oe.from(Ne.dom.elementFromPoint(Ie, Bt)).map(Wo)
  }, Mt = (Ne) => Ne.nodeType !== En && Ne.nodeType !== mn && Ne.nodeType !== dt || Ne.childElementCount === 0, zn = (Ne, Ie) => {
    const Bt = Ie === void 0 ? document : Ie.dom;
    return Mt(Bt) ? [] : te(Bt.querySelectorAll(Ne), Ot.fromDom);
  }, At = (Ne) => oe.from(Ne.dom.parentNode).map(Ot.fromDom), $n = (Ne) => te(Ne.dom.childNodes, Ot.fromDom), en = (Ne, Ie) => ({
    element: Ne,
    offset: Ie
  }), Ue = (Ne, Ie) => {
    const Bt = $n(Ne);
    return Bt.length > 0 && Ie < Bt.length ? en(Bt[Ie], 0) : en(Ne, Ie);
  }, jn = (Ne, Ie) => {
    At(Ne).each((Wt) => {
      Wt.dom.insertBefore(Ie.dom, Ne.dom);
    });
  }, mo = (Ne, Ie) => {
    Ne.dom.appendChild(Ie.dom);
  }, xn = (Ne, Ie) => {
    jn(Ne, Ie), mo(Ie, Ne);
  }, Ct = ((Ne, Ie) => {
    const Bt = (eo) => {
      if (!Ne(eo))
        throw new Error("Can only get " + Ie + " value of a " + Ie + " node");
      return Wt(eo).getOr("");
    }, Wt = (eo) => Ne(eo) ? oe.from(eo.dom.nodeValue) : oe.none();
    return {
      get: Bt,
      getOption: Wt,
      set: (eo, Gn) => {
        if (!Ne(eo))
          throw new Error("Can only set raw " + Ie + " value of a " + Ie + " node");
        eo.dom.nodeValue = Gn;
      }
    };
  })(Fn, "text"), Jn = (Ne) => Ct.get(Ne), Pn = (Ne, Ie, Bt) => (Ne.compareDocumentPosition(Ie) & Bt) !== 0, so = (Ne, Ie) => Pn(Ne, Ie, Node.DOCUMENT_POSITION_PRECEDING), pr = (Ne, Ie) => zn(Ie, Ne);
  var nr = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker");
  const Ko = (Ne, Ie) => Ne.isBlock(Ie) || B(Ne.schema.getVoidElements(), Ie.nodeName), Qo = (Ne, Ie) => !Ne.isEditable(Ie), Mr = (Ne, Ie) => Ne.getContentEditable(Ie) === "true" && Ie.parentNode && !Ne.isEditable(Ie.parentNode), at = (Ne, Ie) => !Ne.isBlock(Ie) && B(Ne.schema.getWhitespaceElements(), Ie.nodeName), kt = (Ne, Ie) => Ko(Ne, Ie) || Qo(Ne, Ie) || at(Ne, Ie) || Mr(Ne, Ie), yn = (Ne) => Ne.nodeType === 3, pn = () => ({
    sOffset: 0,
    fOffset: 0,
    elements: []
  }), Oo = (Ne, Ie) => Ue(Ot.fromDom(Ne), Ie), hr = (Ne, Ie, Bt, Wt, kn, eo = !0) => {
    let Gn = eo ? Ie(!1) : Bt;
    for (; Gn; ) {
      const qn = Qo(Ne, Gn);
      if (qn || at(Ne, Gn)) {
        if (qn ? Wt.cef(Gn) : Wt.boundary(Gn))
          break;
        Gn = Ie(!0);
        continue;
      } else if (Ko(Ne, Gn)) {
        if (Wt.boundary(Gn))
          break;
      } else yn(Gn) && Wt.text(Gn);
      if (Gn === kn)
        break;
      Gn = Ie(!1);
    }
  }, or = (Ne, Ie, Bt, Wt, kn) => {
    var eo;
    if (kt(Ne, Bt))
      return;
    const Gn = (eo = Ne.getParent(Wt, Ne.isBlock)) !== null && eo !== void 0 ? eo : Ne.getRoot(), qn = new nr(Bt, Gn), Qn = kn ? qn.next.bind(qn) : qn.prev.bind(qn);
    hr(Ne, Qn, Bt, {
      boundary: ke,
      cef: ke,
      text: (lo) => {
        kn ? Ie.fOffset += lo.length : Ie.sOffset += lo.length, Ie.elements.push(Ot.fromDom(lo));
      }
    });
  }, Ir = (Ne, Ie, Bt, Wt, kn, eo = !0) => {
    const Gn = new nr(Bt, Ie), qn = [];
    let Qn = pn();
    or(Ne, Qn, Bt, Ie, !1);
    const lo = () => (Qn.elements.length > 0 && (qn.push(Qn), Qn = pn()), !1);
    return hr(Ne, Gn.next.bind(Gn), Bt, {
      boundary: lo,
      cef: (rr) => (lo(), kn && qn.push(...kn.cef(rr)), !1),
      text: (rr) => {
        Qn.elements.push(Ot.fromDom(rr)), kn && kn.text(rr, Qn);
      }
    }, Wt, eo), Wt && or(Ne, Qn, Wt, Ie, !0), lo(), qn;
  }, Zo = (Ne, Ie) => {
    const Bt = Oo(Ie.startContainer, Ie.startOffset), Wt = Bt.element.dom, kn = Oo(Ie.endContainer, Ie.endOffset), eo = kn.element.dom;
    return Ir(Ne, Ie.commonAncestorContainer, Wt, eo, {
      text: (Gn, qn) => {
        Gn === eo ? qn.fOffset += Gn.length - kn.offset : Gn === Wt && (qn.sOffset += Bt.offset);
      },
      cef: (Gn) => {
        const qn = dn(pr(Ot.fromDom(Gn), "*[contenteditable=true]"), (Qn) => {
          const lo = Qn.dom;
          return Ir(Ne, lo, lo);
        });
        return wt(qn, (Qn, lo) => so(Qn.elements[0].dom, lo.elements[0].dom) ? 1 : -1);
      }
    }, !1);
  }, Tr = (Ne, Ie) => Ie.collapsed ? [] : Zo(Ne, Ie), Ht = (Ne, Ie) => {
    const Bt = Ne.createRng();
    return Bt.selectNode(Ie), Tr(Ne, Bt);
  }, Ho = (Ne, Ie) => dn(Ie, (Bt) => Ht(Ne, Bt)), As = (Ne, Ie, Bt = 0, Wt = Ne.length) => {
    const kn = Ie.regex;
    kn.lastIndex = Bt;
    const eo = [];
    let Gn;
    for (; Gn = kn.exec(Ne); ) {
      const qn = Gn[Ie.matchIndex], Qn = Gn.index + Gn[0].indexOf(qn), lo = Qn + qn.length;
      if (lo > Wt)
        break;
      eo.push({
        start: Qn,
        finish: lo
      }), kn.lastIndex = lo;
    }
    return eo;
  }, ra = (Ne, Ie) => {
    const Bt = je(Ne, (Wt, kn) => {
      const eo = Jn(kn), Gn = Wt.last, qn = Gn + eo.length, Qn = dn(Ie, (lo, rr) => lo.start < qn && lo.finish > Gn ? [{
        element: kn,
        start: Math.max(Gn, lo.start) - Gn,
        finish: Math.min(qn, lo.finish) - Gn,
        matchId: rr
      }] : []);
      return {
        results: Wt.results.concat(Qn),
        last: qn
      };
    }, {
      results: [],
      last: 0
    }).results;
    return Kt(Bt, (Wt) => Wt.matchId);
  }, qs = (Ne, Ie) => dn(Ie, (Bt) => {
    const Wt = Bt.elements, kn = te(Wt, Jn).join(""), eo = As(kn, Ne, Bt.sOffset, kn.length - Bt.fOffset);
    return ra(Wt, eo);
  }), Ks = (Ne, Ie) => {
    ot(Ne, (Bt, Wt) => {
      ot(Bt, (kn) => {
        const eo = Ot.fromDom(Ie.cloneNode(!1));
        on(eo, "data-mce-index", Wt);
        const Gn = kn.element.dom;
        if (Gn.length === kn.finish && kn.start === 0)
          xn(kn.element, eo);
        else {
          Gn.length !== kn.finish && Gn.splitText(kn.finish);
          const qn = Gn.splitText(kn.start);
          xn(Ot.fromDom(qn), eo);
        }
      });
    });
  }, kr = (Ne, Ie, Bt, Wt) => {
    const kn = Ht(Ne, Bt), eo = qs(Ie, kn);
    return Ks(eo, Wt), eo.length;
  }, xa = (Ne, Ie, Bt, Wt) => {
    const kn = Bt.getBookmark(), eo = Ne.select("td[data-mce-selected],th[data-mce-selected]"), Gn = eo.length > 0 ? Ho(Ne, eo) : Tr(Ne, Bt.getRng()), qn = qs(Ie, Gn);
    return Ks(qn, Wt), Bt.moveToBookmark(kn), qn.length;
  }, ca = (Ne) => Ne.getAttribute("data-mce-index"), Or = (Ne, Ie, Bt, Wt) => {
    const kn = Ne.dom.create("span", { "data-mce-bogus": 1 });
    kn.className = "mce-match-marker";
    const eo = Ne.getBody();
    return Ps(Ne, Ie, !1), Wt ? xa(Ne.dom, Bt, Ne.selection, kn) : kr(Ne.dom, Bt, eo, kn);
  }, Xn = (Ne) => {
    var Ie;
    const Bt = Ne.parentNode;
    Ne.firstChild && Bt.insertBefore(Ne.firstChild, Ne), (Ie = Ne.parentNode) === null || Ie === void 0 || Ie.removeChild(Ne);
  }, Ss = (Ne, Ie) => {
    const Bt = [], Wt = ve.toArray(Ne.getBody().getElementsByTagName("span"));
    if (Wt.length)
      for (let kn = 0; kn < Wt.length; kn++) {
        const eo = ca(Wt[kn]);
        eo === null || !eo.length || eo === Ie.toString() && Bt.push(Wt[kn]);
      }
    return Bt;
  }, Ke = (Ne, Ie, Bt) => {
    const Wt = Ie.get();
    let kn = Wt.index;
    const eo = Ne.dom;
    Bt ? kn + 1 === Wt.count ? kn = 0 : kn++ : kn - 1 === -1 ? kn = Wt.count - 1 : kn--, eo.removeClass(Ss(Ne, Wt.index), "mce-match-marker-selected");
    const Gn = Ss(Ne, kn);
    return Gn.length ? (eo.addClass(Ss(Ne, kn), "mce-match-marker-selected"), Ne.selection.scrollIntoView(Gn[0]), kn) : -1;
  }, bt = (Ne, Ie) => {
    const Bt = Ie.parentNode;
    Ne.remove(Ie), Bt && Ne.isEmpty(Bt) && Ne.remove(Bt);
  }, gn = (Ne, Ie) => {
    const Wt = "(" + Ne.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&").replace(/\s/g, "[^\\S\\r\\n\\uFEFF]") + ")";
    return Ie ? `(?:^|\\s|${ae()})` + Wt + `(?=$|\\s|${ae()})` : Wt;
  }, Tn = (Ne, Ie, Bt, Wt, kn, eo) => {
    const Gn = Ne.selection, qn = gn(Bt, kn), Qn = Gn.isForward(), lo = {
      regex: new RegExp(qn, Wt ? "g" : "gi"),
      matchIndex: 1
    }, rr = Or(Ne, Ie, lo, eo);
    if (G.browser.isSafari() && Gn.setRng(Gn.getRng(), Qn), rr) {
      const Kr = Ke(Ne, Ie, !0);
      Ie.set({
        index: Kr,
        count: rr,
        text: Bt,
        matchCase: Wt,
        wholeWord: kn,
        inSelection: eo
      });
    }
    return rr;
  }, Po = (Ne, Ie) => {
    const Bt = Ke(Ne, Ie, !0);
    Ie.set({
      ...Ie.get(),
      index: Bt
    });
  }, cr = (Ne, Ie) => {
    const Bt = Ke(Ne, Ie, !1);
    Ie.set({
      ...Ie.get(),
      index: Bt
    });
  }, ea = (Ne) => {
    const Ie = ca(Ne);
    return Ie !== null && Ie.length > 0;
  }, ta = (Ne, Ie, Bt, Wt, kn) => {
    const eo = Ie.get(), Gn = eo.index;
    let qn, Qn = Gn;
    Wt = Wt !== !1;
    const lo = Ne.getBody(), rr = ve.grep(ve.toArray(lo.getElementsByTagName("span")), ea);
    for (let Kr = 0; Kr < rr.length; Kr++) {
      const Wa = ca(rr[Kr]);
      let Ei = qn = parseInt(Wa, 10);
      if (kn || Ei === eo.index) {
        for (Bt.length ? (rr[Kr].innerText = Bt, Xn(rr[Kr])) : bt(Ne.dom, rr[Kr]); rr[++Kr]; )
          if (Ei = parseInt(ca(rr[Kr]), 10), Ei === qn)
            bt(Ne.dom, rr[Kr]);
          else {
            Kr--;
            break;
          }
        Wt && Qn--;
      } else qn > Gn && rr[Kr].setAttribute("data-mce-index", String(qn - 1));
    }
    return Ie.set({
      ...eo,
      count: kn ? 0 : eo.count - 1,
      index: Qn
    }), Wt ? Po(Ne, Ie) : cr(Ne, Ie), !kn && Ie.get().count > 0;
  }, Ps = (Ne, Ie, Bt) => {
    let Wt, kn;
    const eo = Ie.get(), Gn = ve.toArray(Ne.getBody().getElementsByTagName("span"));
    for (let qn = 0; qn < Gn.length; qn++) {
      const Qn = ca(Gn[qn]);
      Qn !== null && Qn.length && (Qn === eo.index.toString() && (Wt || (Wt = Gn[qn].firstChild), kn = Gn[qn].firstChild), Xn(Gn[qn]));
    }
    if (Ie.set({
      ...eo,
      index: -1,
      count: 0,
      text: ""
    }), Wt && kn) {
      const qn = Ne.dom.createRng();
      return qn.setStart(Wt, 0), qn.setEnd(kn, kn.data.length), Bt !== !1 && Ne.selection.setRng(qn), qn;
    } else
      return;
  }, Re = (Ne, Ie) => Ie.get().count > 1, Oe = (Ne, Ie) => Ie.get().count > 1, ct = (Ne, Ie) => ({
    done: (qn) => Ps(Ne, Ie, qn),
    find: (qn, Qn, lo, rr = !1) => Tn(Ne, Ie, qn, Qn, lo, rr),
    next: () => Po(Ne, Ie),
    prev: () => cr(Ne, Ie),
    replace: (qn, Qn, lo) => ta(Ne, Ie, qn, Qn, lo)
  }), _t = (Ne) => {
    const Ie = o(oe.none()), Bt = () => Ie.get().each(Ne);
    return {
      clear: () => {
        Bt(), Ie.set(oe.none());
      },
      isSet: () => Ie.get().isSome(),
      get: () => Ie.get(),
      set: (qn) => {
        Bt(), Ie.set(oe.some(qn));
      }
    };
  }, Kn = () => {
    const Ne = _t(J);
    return {
      ...Ne,
      on: (Bt) => Ne.get().each(Bt)
    };
  }, io = (Ne, Ie) => {
    const Bt = Kn();
    Ne.undoManager.add();
    const Wt = ve.trim(Ne.selection.getContent({ format: "text" })), kn = (ko) => {
      ko.setEnabled("next", Re(Ne, Ie)), ko.setEnabled("prev", Oe(Ne, Ie));
    }, eo = (ko) => {
      const Yo = ko.getData(), Fr = Ie.get();
      Ie.set({
        ...Fr,
        matchCase: Yo.matchcase,
        wholeWord: Yo.wholewords,
        inSelection: Yo.inselection
      });
    }, Gn = (ko, Yo) => {
      lt([
        "replace",
        "replaceall",
        "prev",
        "next"
      ], (ua) => ko.setEnabled(ua, !Yo));
    }, qn = (ko, Yo) => {
      Yo.redial(Ti(ko, Yo.getData()));
    }, Qn = (ko, Yo) => {
      G.browser.isSafari() && G.deviceType.isTouch() && (Yo === "find" || Yo === "replace" || Yo === "replaceall") && ko.focus(Yo);
    }, lo = (ko) => {
      Ps(Ne, Ie, !1), Gn(ko, !0), kn(ko);
    }, rr = (ko) => {
      const Yo = ko.getData(), Fr = Ie.get();
      if (!Yo.findtext.length) {
        lo(ko);
        return;
      }
      if (Fr.text === Yo.findtext && Fr.matchCase === Yo.matchcase && Fr.wholeWord === Yo.wholewords)
        Po(Ne, Ie);
      else {
        const Ba = Tn(Ne, Ie, Yo.findtext, Yo.matchcase, Yo.wholewords, Yo.inselection);
        Ba <= 0 && qn(!0, ko), Gn(ko, Ba === 0);
      }
      kn(ko);
    }, Kr = Ie.get(), Wa = {
      findtext: Wt,
      replacetext: "",
      wholewords: Kr.wholeWord,
      matchcase: Kr.matchCase,
      inselection: Kr.inSelection
    }, Ei = (ko) => {
      const Yo = [
        {
          type: "label",
          label: "Find",
          for: "findtext",
          items: [{
            type: "bar",
            items: [
              {
                type: "input",
                name: "findtext",
                maximized: !0,
                inputMode: "search"
              },
              {
                type: "button",
                name: "prev",
                text: "Previous",
                icon: "action-prev",
                enabled: !1,
                borderless: !0
              },
              {
                type: "button",
                name: "next",
                text: "Next",
                icon: "action-next",
                enabled: !1,
                borderless: !0
              }
            ]
          }]
        },
        {
          type: "input",
          name: "replacetext",
          label: "Replace with",
          inputMode: "search"
        }
      ];
      return ko && Yo.push({
        type: "alertbanner",
        level: "error",
        text: "Could not find the specified string.",
        icon: "warning"
      }), Yo;
    }, Ti = (ko, Yo) => ({
      title: "Find and Replace",
      size: "normal",
      body: {
        type: "panel",
        items: Ei(ko)
      },
      buttons: [
        {
          type: "menu",
          name: "options",
          icon: "preferences",
          tooltip: "Preferences",
          align: "start",
          items: [
            {
              type: "togglemenuitem",
              name: "matchcase",
              text: "Match case"
            },
            {
              type: "togglemenuitem",
              name: "wholewords",
              text: "Find whole words only"
            },
            {
              type: "togglemenuitem",
              name: "inselection",
              text: "Find in selection"
            }
          ]
        },
        {
          type: "custom",
          name: "find",
          text: "Find",
          primary: !0
        },
        {
          type: "custom",
          name: "replace",
          text: "Replace",
          enabled: !1
        },
        {
          type: "custom",
          name: "replaceall",
          text: "Replace all",
          enabled: !1
        }
      ],
      initialData: Yo,
      onChange: (Fr, Ba) => {
        ko && qn(!1, Fr), Ba.name === "findtext" && Ie.get().count > 0 && lo(Fr);
      },
      onAction: (Fr, Ba) => {
        const ua = Fr.getData();
        switch (Ba.name) {
          case "find":
            rr(Fr);
            break;
          case "replace":
            ta(Ne, Ie, ua.replacetext) ? kn(Fr) : lo(Fr);
            break;
          case "replaceall":
            ta(Ne, Ie, ua.replacetext, !0, !0), lo(Fr);
            break;
          case "prev":
            cr(Ne, Ie), kn(Fr);
            break;
          case "next":
            Po(Ne, Ie), kn(Fr);
            break;
          case "matchcase":
          case "wholewords":
          case "inselection":
            qn(!1, Fr), eo(Fr), lo(Fr);
            break;
        }
        Qn(Fr, Ba.name);
      },
      onSubmit: (Fr) => {
        rr(Fr), Qn(Fr, "find");
      },
      onClose: () => {
        Ne.focus(), Ps(Ne, Ie), Ne.undoManager.add();
      }
    });
    Bt.set(Ne.windowManager.open(Ti(!1, Wa), { inline: "toolbar" }));
  }, Bo = (Ne, Ie) => {
    Ne.addCommand("SearchReplace", () => {
      io(Ne, Ie);
    });
  }, Jr = (Ne, Ie) => () => {
    io(Ne, Ie);
  }, He = (Ne, Ie) => {
    Ne.ui.registry.addMenuItem("searchreplace", {
      text: "Find and replace...",
      shortcut: "Meta+F",
      onAction: Jr(Ne, Ie),
      icon: "search"
    }), Ne.ui.registry.addButton("searchreplace", {
      tooltip: "Find and replace",
      onAction: Jr(Ne, Ie),
      icon: "search",
      shortcut: "Meta+F"
    }), Ne.shortcuts.add("Meta+F", "", Jr(Ne, Ie));
  };
  var Do = () => {
    r.add("searchreplace", (Ne) => {
      const Ie = o({
        index: -1,
        count: 0,
        text: "",
        matchCase: !1,
        wholeWord: !1,
        inSelection: !1
      });
      return Bo(Ne, Ie), He(Ne, Ie), ct(Ne, Ie);
    });
  };
  Do();
})();
(function() {
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const r = (P, I, ee) => {
    var he;
    return ee(P, I.prototype) ? !0 : ((he = P.constructor) === null || he === void 0 ? void 0 : he.name) === I.name;
  }, i = (P) => {
    const I = typeof P;
    return P === null ? "null" : I === "object" && Array.isArray(P) ? "array" : I === "object" && r(P, String, (ee, he) => he.isPrototypeOf(ee)) ? "string" : I;
  }, u = (P) => (I) => i(I) === P, h = (P) => (I) => typeof I === P, y = (P) => (I) => P === I, k = u("string"), _ = u("array"), D = h("boolean"), L = y(void 0), W = (P) => P == null, se = (P) => !W(P), J = h("function"), be = h("number"), ke = () => {
  }, Ce = (P, I) => (ee) => P(I(ee)), Q = (P) => () => P, oe = (P) => P, ae = (P, I) => P === I;
  function G(P, ...I) {
    return (...ee) => {
      const he = I.concat(ee);
      return P.apply(null, he);
    };
  }
  const ve = (P) => {
    P();
  }, nt = Q(!1), Xe = Q(!0);
  class te {
    constructor(I, ee) {
      this.tag = I, this.value = ee;
    }
    static some(I) {
      return new te(!0, I);
    }
    static none() {
      return te.singletonNone;
    }
    fold(I, ee) {
      return this.tag ? ee(this.value) : I();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(I) {
      return this.tag ? te.some(I(this.value)) : te.none();
    }
    bind(I) {
      return this.tag ? I(this.value) : te.none();
    }
    exists(I) {
      return this.tag && I(this.value);
    }
    forall(I) {
      return !this.tag || I(this.value);
    }
    filter(I) {
      return !this.tag || I(this.value) ? this : te.none();
    }
    getOr(I) {
      return this.tag ? this.value : I;
    }
    or(I) {
      return this.tag ? this : I;
    }
    getOrThunk(I) {
      return this.tag ? this.value : I();
    }
    orThunk(I) {
      return this.tag ? this : I();
    }
    getOrDie(I) {
      if (this.tag)
        return this.value;
      throw new Error(I ?? "Called getOrDie on None");
    }
    static from(I) {
      return se(I) ? te.some(I) : te.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(I) {
      this.tag && I(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  te.singletonNone = new te(!1);
  const lt = Object.keys, ot = Object.hasOwnProperty, Kt = (P, I) => {
    const ee = lt(P);
    for (let he = 0, Be = ee.length; he < Be; he++) {
      const Pt = ee[he], sn = P[Pt];
      I(sn, Pt);
    }
  }, je = (P) => (I, ee) => {
    P[ee] = I;
  }, ye = (P, I, ee, he) => {
    Kt(P, (Be, Pt) => {
      (I(Be, Pt) ? ee : he)(Be, Pt);
    });
  }, dn = (P, I) => {
    const ee = {};
    return ye(P, I, je(ee), ke), ee;
  }, wt = (P, I) => {
    const ee = [];
    return Kt(P, (he, Be) => {
      ee.push(I(he, Be));
    }), ee;
  }, qe = (P) => wt(P, oe), B = (P) => lt(P).length, mn = (P, I) => dt(P, I) ? te.from(P[I]) : te.none(), dt = (P, I) => ot.call(P, I), En = (P, I) => dt(P, I) && P[I] !== void 0 && P[I] !== null, tn = (P) => {
    for (const I in P)
      if (ot.call(P, I))
        return !1;
    return !0;
  }, Le = Array.prototype.indexOf, jt = Array.prototype.push, Fn = (P, I) => Le.call(P, I), St = (P, I) => Fn(P, I) > -1, on = (P, I) => {
    for (let ee = 0, he = P.length; ee < he; ee++) {
      const Be = P[ee];
      if (I(Be, ee))
        return !0;
    }
    return !1;
  }, tt = (P, I) => {
    const ee = [];
    for (let he = 0; he < P; he++)
      ee.push(I(he));
    return ee;
  }, mt = (P, I) => {
    const ee = P.length, he = new Array(ee);
    for (let Be = 0; Be < ee; Be++) {
      const Pt = P[Be];
      he[Be] = I(Pt, Be);
    }
    return he;
  }, Y = (P, I) => {
    for (let ee = 0, he = P.length; ee < he; ee++) {
      const Be = P[ee];
      I(Be, ee);
    }
  }, Wo = (P, I) => {
    for (let ee = P.length - 1; ee >= 0; ee--) {
      const he = P[ee];
      I(he, ee);
    }
  }, To = (P, I) => {
    const ee = [], he = [];
    for (let Be = 0, Pt = P.length; Be < Pt; Be++) {
      const sn = P[Be];
      (I(sn, Be) ? ee : he).push(sn);
    }
    return {
      pass: ee,
      fail: he
    };
  }, Ot = (P, I) => {
    const ee = [];
    for (let he = 0, Be = P.length; he < Be; he++) {
      const Pt = P[he];
      I(Pt, he) && ee.push(Pt);
    }
    return ee;
  }, Mt = (P, I, ee) => (Wo(P, (he, Be) => {
    ee = I(ee, he, Be);
  }), ee), zn = (P, I, ee) => (Y(P, (he, Be) => {
    ee = I(ee, he, Be);
  }), ee), At = (P, I, ee) => {
    for (let he = 0, Be = P.length; he < Be; he++) {
      const Pt = P[he];
      if (I(Pt, he))
        return te.some(Pt);
      if (ee(Pt, he))
        break;
    }
    return te.none();
  }, $n = (P, I) => At(P, I, nt), en = (P) => {
    const I = [];
    for (let ee = 0, he = P.length; ee < he; ++ee) {
      if (!_(P[ee]))
        throw new Error("Arr.flatten item " + ee + " was not an array, input: " + P);
      jt.apply(I, P[ee]);
    }
    return I;
  }, Ue = (P, I) => en(mt(P, I)), jn = (P, I) => {
    for (let ee = 0, he = P.length; ee < he; ++ee) {
      const Be = P[ee];
      if (I(Be, ee) !== !0)
        return !1;
    }
    return !0;
  }, mo = (P, I) => {
    const ee = {};
    for (let he = 0, Be = P.length; he < Be; he++) {
      const Pt = P[he];
      ee[String(Pt)] = I(Pt, he);
    }
    return ee;
  }, xn = (P, I) => I >= 0 && I < P.length ? te.some(P[I]) : te.none(), Vt = (P) => xn(P, 0), Ct = (P) => xn(P, P.length - 1), Jn = (P, I) => {
    for (let ee = 0; ee < P.length; ee++) {
      const he = I(P[ee], ee);
      if (he.isSome())
        return he;
    }
    return te.none();
  }, Pn = 8, so = 9, pr = 11, nr = 1, Ko = 3, Qo = (P, I) => {
    const he = (I || document).createElement("div");
    if (he.innerHTML = P, !he.hasChildNodes() || he.childNodes.length > 1) {
      const Be = "HTML does not have a single root node";
      throw console.error(Be, P), new Error(Be);
    }
    return kt(he.childNodes[0]);
  }, Mr = (P, I) => {
    const he = (I || document).createElement(P);
    return kt(he);
  }, at = (P, I) => {
    const he = (I || document).createTextNode(P);
    return kt(he);
  }, kt = (P) => {
    if (P == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: P };
  }, pn = {
    fromHtml: Qo,
    fromTag: Mr,
    fromText: at,
    fromDom: kt,
    fromPoint: (P, I, ee) => te.from(P.dom.elementFromPoint(I, ee)).map(kt)
  }, Oo = (P, I) => {
    const ee = P.dom;
    if (ee.nodeType !== nr)
      return !1;
    {
      const he = ee;
      if (he.matches !== void 0)
        return he.matches(I);
      if (he.msMatchesSelector !== void 0)
        return he.msMatchesSelector(I);
      if (he.webkitMatchesSelector !== void 0)
        return he.webkitMatchesSelector(I);
      if (he.mozMatchesSelector !== void 0)
        return he.mozMatchesSelector(I);
      throw new Error("Browser lacks native selectors");
    }
  }, hr = (P) => P.nodeType !== nr && P.nodeType !== so && P.nodeType !== pr || P.childElementCount === 0, or = (P, I) => {
    const ee = I === void 0 ? document : I.dom;
    return hr(ee) ? [] : mt(ee.querySelectorAll(P), pn.fromDom);
  }, Ir = (P, I) => {
    const ee = I === void 0 ? document : I.dom;
    return hr(ee) ? te.none() : te.from(ee.querySelector(P)).map(pn.fromDom);
  }, Zo = (P, I) => P.dom === I.dom, Tr = Oo;
  typeof window < "u" || Function("return this;")();
  const Ht = (P) => P.dom.nodeName.toLowerCase(), Ho = (P) => P.dom.nodeType, As = (P) => (I) => Ho(I) === P, ra = (P) => Ho(P) === Pn || Ht(P) === "#comment", qs = As(nr), Ks = As(Ko), kr = As(so), xa = As(pr), ca = (P) => (I) => qs(I) && Ht(I) === P, Or = (P) => pn.fromDom(P.dom.ownerDocument), Xn = (P) => kr(P) ? P : Or(P), Ss = (P) => te.from(P.dom.parentNode).map(pn.fromDom), Ke = (P, I) => {
    const ee = J(I) ? I : nt;
    let he = P.dom;
    const Be = [];
    for (; he.parentNode !== null && he.parentNode !== void 0; ) {
      const Pt = he.parentNode, sn = pn.fromDom(Pt);
      if (Be.push(sn), ee(sn) === !0)
        break;
      he = Pt;
    }
    return Be;
  }, bt = (P) => te.from(P.dom.previousSibling).map(pn.fromDom), gn = (P) => te.from(P.dom.nextSibling).map(pn.fromDom), Tn = (P) => mt(P.dom.childNodes, pn.fromDom), Po = (P, I) => {
    const ee = P.dom.childNodes;
    return te.from(ee[I]).map(pn.fromDom);
  }, cr = (P) => Po(P, 0), ea = (P) => xa(P) && se(P.dom.host), Ps = J(Element.prototype.attachShadow) && J(Node.prototype.getRootNode) ? (P) => pn.fromDom(P.dom.getRootNode()) : Xn, Re = (P) => {
    const I = Ps(P);
    return ea(I) ? te.some(I) : te.none();
  }, Oe = (P) => pn.fromDom(P.dom.host), ct = (P) => {
    const I = Ks(P) ? P.dom.parentNode : P.dom;
    if (I == null || I.ownerDocument === null)
      return !1;
    const ee = I.ownerDocument;
    return Re(pn.fromDom(I)).fold(() => ee.body.contains(I), Ce(ct, Oe));
  };
  var _t = (P, I, ee, he, Be) => P(ee, he) ? te.some(ee) : J(Be) && Be(ee) ? te.none() : I(ee, he, Be);
  const Kn = (P, I, ee) => {
    let he = P.dom;
    const Be = J(ee) ? ee : nt;
    for (; he.parentNode; ) {
      he = he.parentNode;
      const Pt = pn.fromDom(he);
      if (I(Pt))
        return te.some(Pt);
      if (Be(Pt))
        break;
    }
    return te.none();
  }, io = (P, I, ee) => _t((Be, Pt) => Pt(Be), Kn, P, I, ee), Bo = (P, I) => {
    const ee = (Be) => I(pn.fromDom(Be));
    return $n(P.dom.childNodes, ee).map(pn.fromDom);
  }, Jr = (P, I, ee) => Kn(P, (he) => Oo(he, I), ee), He = (P, I) => Bo(P, (ee) => Oo(ee, I)), Do = (P, I) => Ir(I, P), Ne = (P, I, ee) => _t((Be, Pt) => Oo(Be, Pt), Jr, P, I, ee), Ie = (P) => Ne(P, "[contenteditable]"), Bt = (P, I = !1) => ct(P) ? P.dom.isContentEditable : Ie(P).fold(Q(I), (ee) => Wt(ee) === "true"), Wt = (P) => P.dom.contentEditable, kn = (P) => P.nodeName.toLowerCase(), eo = (P) => pn.fromDom(P.getBody()), Gn = (P) => (I) => Zo(I, eo(P)), qn = (P) => P ? P.replace(/px$/, "") : "", Qn = (P) => /^\d+(\.\d+)?$/.test(P) ? P + "px" : P, lo = (P) => pn.fromDom(P.selection.getStart()), rr = (P) => pn.fromDom(P.selection.getEnd()), Kr = (P) => io(P, ca("table")).forall(Bt), Wa = (P, I) => Ot(Tn(P), I), Ei = (P, I) => {
    let ee = [];
    return Y(Tn(P), (he) => {
      I(he) && (ee = ee.concat([he])), ee = ee.concat(Ei(he, I));
    }), ee;
  }, Ti = (P, I) => Wa(P, (ee) => Oo(ee, I)), ko = (P, I) => or(I, P), Yo = (P, I, ee) => {
    if (k(ee) || D(ee) || be(ee))
      P.setAttribute(I, ee + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", I, ":: Value ", ee, ":: Element ", P), new Error("Attribute value was not simple");
  }, Fr = (P, I, ee) => {
    Yo(P.dom, I, ee);
  }, Ba = (P, I) => {
    const ee = P.dom;
    Kt(I, (he, Be) => {
      Yo(ee, Be, he);
    });
  }, ua = (P, I) => {
    const ee = P.dom.getAttribute(I);
    return ee === null ? void 0 : ee;
  }, vs = (P, I) => te.from(ua(P, I)), es = (P, I) => {
    P.dom.removeAttribute(I);
  }, ai = (P) => zn(P.dom.attributes, (I, ee) => (I[ee.name] = ee.value, I), {}), vc = (P, I, ee = ae) => P.exists((he) => ee(he, I)), Lr = (P) => {
    const I = [], ee = (he) => {
      I.push(he);
    };
    for (let he = 0; he < P.length; he++)
      P[he].each(ee);
    return I;
  }, ka = (P, I, ee) => P.isSome() && I.isSome() ? te.some(ee(P.getOrDie(), I.getOrDie())) : te.none(), ii = (P) => P.bind(oe), na = (P, I) => P ? te.some(I) : te.none(), Oi = (P, I) => P.substring(I), cl = (P, I, ee) => I === "" || P.length >= I.length && P.substr(ee, ee + I.length) === I, Za = (P, I) => Ai(P, I) ? Oi(P, I.length) : P, Ai = (P, I) => cl(P, I, 0), au = ((P) => (I) => I.replace(P, ""))(/^\s+|\s+$/g), gi = (P) => P.length > 0, Ml = (P) => !gi(P), $a = (P, I = 10) => {
    const ee = parseInt(P, I);
    return isNaN(ee) ? te.none() : te.some(ee);
  }, Wi = (P) => {
    const I = parseFloat(P);
    return isNaN(I) ? te.none() : te.some(I);
  }, Kl = (P) => P.style !== void 0 && J(P.style.getPropertyValue), yc = (P, I, ee) => {
    if (!k(ee))
      throw console.error("Invalid call to CSS.set. Property ", I, ":: Value ", ee, ":: Element ", P), new Error("CSS value must be a string: " + ee);
    Kl(P) && P.style.setProperty(I, ee);
  }, ld = (P, I) => {
    Kl(P) && P.style.removeProperty(I);
  }, iu = (P, I, ee) => {
    const he = P.dom;
    yc(he, I, ee);
  }, bi = (P, I) => {
    const ee = P.dom, Be = window.getComputedStyle(ee).getPropertyValue(I);
    return Be === "" && !ct(P) ? Ru(ee, I) : Be;
  }, Ru = (P, I) => Kl(P) ? P.style.getPropertyValue(I) : "", le = (P, I) => {
    const ee = P.dom, he = Ru(ee, I);
    return te.from(he).filter((Be) => Be.length > 0);
  }, Ae = (P, I) => {
    const ee = P.dom;
    ld(ee, I), vc(vs(P, "style").map(au), "") && es(P, "style");
  }, Ze = (P, I, ee = 0) => vs(P, I).map((he) => parseInt(he, 10)).getOr(ee), Dt = (P, I) => Yt(P, I, Xe), Yt = (P, I, ee) => Ue(Tn(P), (he) => Oo(he, I) ? ee(he) ? [he] : [] : Yt(he, I, ee)), Wn = [
    "tfoot",
    "thead",
    "tbody",
    "colgroup"
  ], lr = (P) => St(Wn, P), yr = (P, I) => ({
    rows: P,
    columns: I
  }), Uo = (P, I, ee) => ({
    element: P,
    rowspan: I,
    colspan: ee
  }), Yr = (P, I, ee, he, Be, Pt) => ({
    element: P,
    rowspan: I,
    colspan: ee,
    row: he,
    column: Be,
    isLocked: Pt
  }), Ds = (P, I, ee) => ({
    element: P,
    cells: I,
    section: ee
  }), rn = (P, I, ee, he) => ({
    startRow: P,
    startCol: I,
    finishRow: ee,
    finishCol: he
  }), cd = (P, I, ee) => ({
    element: P,
    colspan: I,
    column: ee
  }), os = (P, I) => ({
    element: P,
    columns: I
  }), K = (P, I, ee = nt) => {
    if (ee(I))
      return te.none();
    if (St(P, Ht(I)))
      return te.some(I);
    const he = (Be) => Oo(Be, "table") || ee(Be);
    return Jr(I, P.join(","), he);
  }, ge = (P, I) => K([
    "td",
    "th"
  ], P, I), Ee = (P) => Dt(P, "th,td"), ft = (P) => Oo(P, "colgroup") ? Ti(P, "col") : Ue(Ln(P), (I) => Ti(I, "col")), Cn = (P, I) => Ne(P, "table", I), Jo = (P) => Dt(P, "tr"), Ln = (P) => Cn(P).fold(Q([]), (I) => Ti(I, "colgroup")), Rs = (P, I) => mt(P, (ee) => {
    if (Ht(ee) === "colgroup") {
      const he = mt(ft(ee), (Be) => {
        const Pt = Ze(Be, "span", 1);
        return Uo(Be, 1, Pt);
      });
      return Ds(ee, he, "colgroup");
    } else {
      const he = mt(Ee(ee), (Be) => {
        const Pt = Ze(Be, "rowspan", 1), sn = Ze(Be, "colspan", 1);
        return Uo(Be, Pt, sn);
      });
      return Ds(ee, he, I(ee));
    }
  }), Gt = (P) => Ss(P).map((I) => {
    const ee = Ht(I);
    return lr(ee) ? ee : "tbody";
  }).getOr("tbody"), fs = (P) => {
    const I = Jo(P), he = [
      ...Ln(P),
      ...I
    ];
    return Rs(he, Gt);
  }, vi = "data-snooker-locked-cols", ks = (P) => vs(P, vi).bind((I) => te.from(I.match(/\d+/g))).map((I) => mo(I, Xe)), ga = (P, I) => P + "," + I, Il = (P, I, ee) => te.from(P.access[ga(I, ee)]), xr = (P, I, ee) => {
    const he = yi(P, (Be) => ee(I, Be.element));
    return he.length > 0 ? te.some(he[0]) : te.none();
  }, yi = (P, I) => {
    const ee = Ue(P.all, (he) => he.cells);
    return Ot(ee, I);
  }, Ns = (P) => {
    const I = {};
    let ee = 0;
    return Y(P.cells, (he) => {
      const Be = he.colspan;
      tt(Be, (Pt) => {
        const sn = ee + Pt;
        I[sn] = cd(he.element, Be, sn);
      }), ee += Be;
    }), I;
  }, xc = (P) => {
    const I = {}, ee = [], Be = Vt(P).map((tc) => tc.element).bind(Cn).bind(ks).getOr({});
    let Pt = 0, sn = 0, Hn = 0;
    const {
      pass: Ro,
      fail: ar
    } = To(P, (tc) => tc.section === "colgroup");
    Y(ar, (tc) => {
      const yd = [];
      Y(tc.cells, (ml) => {
        let xd = 0;
        for (; I[ga(Hn, xd)] !== void 0; )
          xd++;
        const Ff = En(Be, xd.toString()), Lu = Yr(ml.element, ml.rowspan, ml.colspan, Hn, xd, Ff);
        for (let Sp = 0; Sp < ml.colspan; Sp++)
          for (let jc = 0; jc < ml.rowspan; jc++) {
            const nb = Hn + jc, zh = xd + Sp, ob = ga(nb, zh);
            I[ob] = Lu, sn = Math.max(sn, zh + 1);
          }
        yd.push(Lu);
      }), Pt++, ee.push(Ds(tc.element, yd, tc.section)), Hn++;
    });
    const { columns: rs, colgroups: Zr } = Ct(Ro).map((tc) => {
      const yd = Ns(tc);
      return {
        colgroups: [os(tc.element, qe(yd))],
        columns: yd
      };
    }).getOrThunk(() => ({
      colgroups: [],
      columns: {}
    }));
    return {
      grid: yr(Pt, sn),
      access: I,
      all: ee,
      columns: rs,
      colgroups: Zr
    };
  }, Yl = {
    fromTable: (P) => {
      const I = fs(P);
      return xc(I);
    },
    generate: xc,
    getAt: Il,
    findItem: xr,
    filterItems: yi,
    justCells: (P) => Ue(P.all, (I) => I.cells),
    justColumns: (P) => qe(P.columns),
    hasColumns: (P) => lt(P.columns).length > 0,
    getColumnAt: (P, I) => te.from(P.columns[I])
  };
  var La = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const Ga = (P, I, ee) => {
    const he = P.select("td,th", I);
    let Be;
    for (let Pt = 0; Pt < he.length; Pt++) {
      const sn = P.getStyle(he[Pt], ee);
      if (L(Be) && (Be = sn), Be !== sn)
        return "";
    }
    return Be;
  }, xi = (P, I, ee) => {
    La.each("left center right".split(" "), (he) => {
      he !== ee && P.formatter.remove("align" + he, {}, I);
    }), ee && P.formatter.apply("align" + ee, {}, I);
  }, Of = (P, I, ee) => {
    La.each("top middle bottom".split(" "), (he) => {
      he !== ee && P.formatter.remove("valign" + he, {}, I);
    }), ee && P.formatter.apply("valign" + ee, {}, I);
  }, gr = (P, I, ee) => {
    P.dispatch("TableModified", {
      ...ee,
      table: I
    });
  }, Pi = (P, I) => Wi(P).getOr(I), li = (P, I, ee) => Pi(bi(P, I), ee), pe = (P, I, ee, he) => {
    const Be = li(P, `padding-${ee}`, 0), Pt = li(P, `padding-${he}`, 0), sn = li(P, `border-${ee}-width`, 0), Hn = li(P, `border-${he}-width`, 0);
    return I - Be - Pt - sn - Hn;
  }, Te = (P, I) => {
    const ee = P.dom, he = ee.getBoundingClientRect().width || ee.offsetWidth;
    return I === "border-box" ? he : pe(P, he, "left", "right");
  }, pt = (P) => Te(P, "content-box");
  var to = tinymce.util.Tools.resolve("tinymce.Env");
  const sr = "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol", _s = tt(5, (P) => {
    const I = `${P + 1}px`;
    return {
      title: I,
      value: I
    };
  }), Ha = mt([
    "Solid",
    "Dotted",
    "Dashed",
    "Double",
    "Groove",
    "Ridge",
    "Inset",
    "Outset",
    "None",
    "Hidden"
  ], (P) => ({
    title: P,
    value: P.toLowerCase()
  })), ur = "100%", _a = (P) => {
    var I;
    const ee = P.dom, he = (I = ee.getParent(P.selection.getStart(), ee.isBlock)) !== null && I !== void 0 ? I : P.getBody();
    return pt(pn.fromDom(he)) + "px";
  }, Ms = (P, I) => Wd(P) || !Cc(P) ? I : Ph(P) ? {
    ...I,
    width: _a(P)
  } : {
    ...I,
    width: ur
  }, da = (P, I) => Wd(P) || Cc(P) ? I : Ph(P) ? {
    ...I,
    width: _a(P)
  } : {
    ...I,
    width: ur
  }, sa = (P) => (I) => I.options.get(P), oa = (P) => {
    const I = P.options.register;
    I("table_border_widths", {
      processor: "object[]",
      default: _s
    }), I("table_border_styles", {
      processor: "object[]",
      default: Ha
    }), I("table_cell_advtab", {
      processor: "boolean",
      default: !0
    }), I("table_row_advtab", {
      processor: "boolean",
      default: !0
    }), I("table_advtab", {
      processor: "boolean",
      default: !0
    }), I("table_appearance_options", {
      processor: "boolean",
      default: !0
    }), I("table_grid", {
      processor: "boolean",
      default: !to.deviceType.isTouch()
    }), I("table_cell_class_list", {
      processor: "object[]",
      default: []
    }), I("table_row_class_list", {
      processor: "object[]",
      default: []
    }), I("table_class_list", {
      processor: "object[]",
      default: []
    }), I("table_toolbar", {
      processor: "string",
      default: sr
    }), I("table_background_color_map", {
      processor: "object[]",
      default: []
    }), I("table_border_color_map", {
      processor: "object[]",
      default: []
    });
  }, ul = sa("table_sizing_mode"), wc = sa("table_border_widths"), qa = sa("table_border_styles"), dl = sa("table_cell_advtab"), Mc = sa("table_row_advtab"), Ic = sa("table_advtab"), ip = sa("table_appearance_options"), dd = sa("table_grid"), Cc = sa("table_style_by_css"), Zi = sa("table_cell_class_list"), fd = sa("table_row_class_list"), Af = sa("table_class_list"), lu = sa("table_toolbar"), Ah = sa("table_background_color_map"), Pf = sa("table_border_color_map"), Ph = (P) => ul(P) === "fixed", Wd = (P) => ul(P) === "responsive", Dh = (P) => {
    const I = P.options, ee = I.get("table_default_styles");
    return I.isSet("table_default_styles") ? ee : Ms(P, ee);
  }, Zd = (P) => {
    const I = P.options, ee = I.get("table_default_attributes");
    return I.isSet("table_default_attributes") ? ee : da(P, ee);
  }, Sv = (P, I) => I.column >= P.startCol && I.column + I.colspan - 1 <= P.finishCol && I.row >= P.startRow && I.row + I.rowspan - 1 <= P.finishRow, Me = (P, I) => {
    let ee = !0;
    const he = G(Sv, I);
    for (let Be = I.startRow; Be <= I.finishRow; Be++)
      for (let Pt = I.startCol; Pt <= I.finishCol; Pt++)
        ee = ee && Yl.getAt(P, Be, Pt).exists(he);
    return ee ? te.some(I) : te.none();
  }, ym = (P, I) => rn(Math.min(P.row, I.row), Math.min(P.column, I.column), Math.max(P.row + P.rowspan - 1, I.row + I.rowspan - 1), Math.max(P.column + P.colspan - 1, I.column + I.colspan - 1)), wl = (P, I, ee) => {
    const he = Yl.findItem(P, I, Zo), Be = Yl.findItem(P, ee, Zo);
    return he.bind((Pt) => Be.map((sn) => ym(Pt, sn)));
  }, Nu = (P, I, ee) => wl(P, I, ee).bind((he) => Me(P, he)), Rh = (P, I, ee) => {
    const he = Wg(P);
    return Nu(he, I, ee);
  }, Wg = Yl.fromTable, zr = (P, I) => {
    Ss(P).each((he) => {
      he.dom.insertBefore(I.dom, P.dom);
    });
  }, Gi = (P, I) => {
    gn(P).fold(() => {
      Ss(P).each((Be) => {
        Ka(Be, I);
      });
    }, (he) => {
      zr(he, I);
    });
  }, Fl = (P, I) => {
    cr(P).fold(() => {
      Ka(P, I);
    }, (he) => {
      P.dom.insertBefore(I.dom, he.dom);
    });
  }, Ka = (P, I) => {
    P.dom.appendChild(I.dom);
  }, Gd = (P, I) => {
    zr(P, I), Ka(I, P);
  }, Fc = (P, I) => {
    Y(I, (ee, he) => {
      const Be = he === 0 ? P : I[he - 1];
      Gi(Be, ee);
    });
  }, Di = (P, I) => {
    Y(I, (ee) => {
      Ka(P, ee);
    });
  }, Bc = (P) => {
    const I = P.dom;
    I.parentNode !== null && I.parentNode.removeChild(I);
  }, Nh = (P) => {
    const I = Tn(P);
    I.length > 0 && Fc(P, I), Bc(P);
  }, Xl = ((P, I) => {
    const ee = (Pt) => {
      if (!P(Pt))
        throw new Error("Can only get " + I + " value of a " + I + " node");
      return he(Pt).getOr("");
    }, he = (Pt) => P(Pt) ? te.from(Pt.dom.nodeValue) : te.none();
    return {
      get: ee,
      getOption: he,
      set: (Pt, sn) => {
        if (!P(Pt))
          throw new Error("Can only set raw " + I + " value of a " + I + " node");
        Pt.dom.nodeValue = sn;
      }
    };
  })(Ks, "text"), $c = (P) => Xl.get(P), lp = (P, I) => Xl.set(P, I);
  var qi = [
    "body",
    "p",
    "div",
    "article",
    "aside",
    "figcaption",
    "figure",
    "footer",
    "header",
    "nav",
    "section",
    "ol",
    "ul",
    "li",
    "table",
    "thead",
    "tbody",
    "tfoot",
    "caption",
    "tr",
    "td",
    "th",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "blockquote",
    "pre",
    "address"
  ], Ya = () => {
    const P = (ar) => pn.fromDom(ar.dom.cloneNode(!1)), I = (ar) => Xn(ar).dom, ee = (ar) => qs(ar) ? Ht(ar) === "body" ? !0 : St(qi, Ht(ar)) : !1, he = (ar) => qs(ar) ? St([
      "br",
      "img",
      "hr",
      "input"
    ], Ht(ar)) : !1, Be = (ar) => qs(ar) && ua(ar, "contenteditable") === "false", Pt = (ar, rs) => ar.dom.compareDocumentPosition(rs.dom), sn = (ar, rs) => {
      const Zr = ai(ar);
      Ba(rs, Zr);
    }, Hn = (ar) => {
      const rs = Ht(ar);
      return St([
        "script",
        "noscript",
        "iframe",
        "noframes",
        "noembed",
        "title",
        "style",
        "textarea",
        "xmp"
      ], rs);
    }, Ro = (ar) => qs(ar) ? vs(ar, "lang") : te.none();
    return {
      up: Q({
        selector: Jr,
        closest: Ne,
        predicate: Kn,
        all: Ke
      }),
      down: Q({
        selector: ko,
        predicate: Ei
      }),
      styles: Q({
        get: bi,
        getRaw: le,
        set: iu,
        remove: Ae
      }),
      attrs: Q({
        get: ua,
        set: Fr,
        remove: es,
        copyTo: sn
      }),
      insert: Q({
        before: zr,
        after: Gi,
        afterAll: Fc,
        append: Ka,
        appendAll: Di,
        prepend: Fl,
        wrap: Gd
      }),
      remove: Q({
        unwrap: Nh,
        remove: Bc
      }),
      create: Q({
        nu: pn.fromTag,
        clone: P,
        text: pn.fromText
      }),
      query: Q({
        comparePosition: Pt,
        prevSibling: bt,
        nextSibling: gn
      }),
      property: Q({
        children: Tn,
        name: Ht,
        parent: Ss,
        document: I,
        isText: Ks,
        isComment: ra,
        isElement: qs,
        isSpecial: Hn,
        getLanguage: Ro,
        getText: $c,
        setText: lp,
        isBoundary: ee,
        isEmptyTag: he,
        isNonEditable: Be
      }),
      eq: Zo,
      is: Tr
    };
  };
  const md = (P, I, ee, he) => {
    const Be = ee[0], Pt = ee.slice(1);
    return he(P, I, Be, Pt);
  }, Df = (P, I, ee) => ee.length > 0 ? md(P, I, ee, Sc) : te.none(), Sc = (P, I, ee, he) => {
    const Be = I(P, ee);
    return Mt(he, (Pt, sn) => {
      const Hn = I(P, sn);
      return wi(P, Pt, Hn);
    }, Be);
  }, wi = (P, I, ee) => I.bind((he) => ee.filter(G(P.eq, he))), cp = Df, up = Ya(), dp = (P, I) => cp(up, (ee, he) => P(he), I), xm = (P) => Jr(P, "table"), Ql = (P, I) => {
    const ee = ko(P, I);
    return ee.length > 0 ? te.some(ee) : te.none();
  }, fp = (P, I, ee) => Do(P, I).bind((he) => Do(P, ee).bind((Be) => dp(xm, [
    he,
    Be
  ]).map((Pt) => ({
    first: he,
    last: Be,
    table: Pt
  })))), Gg = (P, I) => Ql(P, I), kv = (P, I, ee) => fp(P, I, ee).bind((he) => {
    const Be = (Ro) => Zo(P, Ro), Pt = "thead,tfoot,tbody,table", sn = Jr(he.first, Pt, Be), Hn = Jr(he.last, Pt, Be);
    return sn.bind((Ro) => Hn.bind((ar) => Zo(Ro, ar) ? Rh(he.table, he.first, he.last) : te.none()));
  }), qg = (P) => mt(P, pn.fromDom), mp = "data-mce-selected", wm = "td[" + mp + "],th[" + mp + "]", Mu = "data-mce-first-selected", Mh = "td[" + Mu + "],th[" + Mu + "]", Is = "data-mce-last-selected", aa = "td[" + Is + "],th[" + Is + "]", Cl = {
    selected: mp,
    selectedSelector: wm,
    firstSelected: Mu,
    firstSelectedSelector: Mh,
    lastSelected: Is,
    lastSelectedSelector: aa
  }, Ih = (P) => Cn(P).bind((I) => Gg(I, Cl.firstSelectedSelector)).fold(Q(P), (I) => I[0]), Fh = (P) => (I, ee) => {
    const he = Ht(I), Be = he === "col" || he === "colgroup" ? Ih(I) : I;
    return Ne(Be, P, ee);
  }, Ra = Fh("th,td,caption"), no = Fh("th,td"), cu = (P) => qg(P.model.table.getSelectedCells()), Kg = (P, I) => {
    const ee = no(P), he = ee.bind((Be) => Cn(Be)).map((Be) => Jo(Be));
    return ka(ee, he, (Be, Pt) => Ot(Pt, (sn) => on(qg(sn.dom.cells), (Hn) => ua(Hn, I) === "1" || Zo(Hn, Be)))).getOr([]);
  }, za = [
    {
      text: "None",
      value: ""
    },
    {
      text: "Top",
      value: "top"
    },
    {
      text: "Middle",
      value: "middle"
    },
    {
      text: "Bottom",
      value: "bottom"
    }
  ], ms = (P) => ({ value: hp(P) }), qd = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, Bh = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, pp = (P) => qd.test(P) || Bh.test(P), hp = (P) => Za(P, "#").toUpperCase(), zo = (P) => pp(P) ? te.some({ value: hp(P) }) : te.none(), fa = (P) => {
    const I = P.toString(16);
    return (I.length === 1 ? "0" + I : I).toUpperCase();
  }, Rf = (P) => {
    const I = fa(P.red) + fa(P.green) + fa(P.blue);
    return ms(I);
  }, Sl = /^\s*rgb\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*\)\s*$/i, fl = /^\s*rgba\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*((?:\d?\.\d+|\d+)%?)\s*\)\s*$/i, kl = (P, I, ee, he) => ({
    red: P,
    green: I,
    blue: ee,
    alpha: he
  }), Na = (P, I, ee, he) => {
    const Be = parseInt(P, 10), Pt = parseInt(I, 10), sn = parseInt(ee, 10), Hn = parseFloat(he);
    return kl(Be, Pt, sn, Hn);
  }, Ki = (P) => {
    const I = Sl.exec(P);
    if (I !== null)
      return te.some(Na(I[1], I[2], I[3], "1"));
    const ee = fl.exec(P);
    return ee !== null ? te.some(Na(ee[1], ee[2], ee[3], ee[4])) : te.none();
  }, Jl = (P) => zo(P).orThunk(() => Ki(P).map(Rf)).getOrThunk(() => {
    const I = document.createElement("canvas");
    I.height = 1, I.width = 1;
    const ee = I.getContext("2d");
    ee.clearRect(0, 0, I.width, I.height), ee.fillStyle = "#FFFFFF", ee.fillStyle = P, ee.fillRect(0, 0, 1, 1);
    const he = ee.getImageData(0, 0, 1, 1).data, Be = he[0], Pt = he[1], sn = he[2], Hn = he[3];
    return Rf(kl(Be, Pt, sn, Hn));
  }), Cm = (P) => Ki(P).map(Rf).map((I) => "#" + I.value).getOr(P), Ys = (P) => {
    let I = P;
    return {
      get: () => I,
      set: (Be) => {
        I = Be;
      }
    };
  }, $h = (P) => {
    const I = Ys(te.none()), ee = () => I.get().each(P);
    return {
      clear: () => {
        ee(), I.set(te.none());
      },
      isSet: () => I.get().isSome(),
      get: () => I.get(),
      set: (Hn) => {
        ee(), I.set(te.some(Hn));
      }
    };
  }, wa = () => $h((P) => P.unbind()), pd = (P, I, ee) => (he) => {
    const Be = wa(), Pt = Ml(ee), sn = () => {
      const Hn = cu(P), Ro = (ar) => P.formatter.match(I, { value: ee }, ar.dom, Pt);
      Pt ? (he.setActive(!on(Hn, Ro)), Be.set(P.formatter.formatChanged(I, (ar) => he.setActive(!ar), !0))) : (he.setActive(jn(Hn, Ro)), Be.set(P.formatter.formatChanged(I, he.setActive, !1, { value: ee })));
    };
    return P.initialized ? sn() : P.on("init", sn), Be.clear;
  }, Lc = (P) => En(P, "menu"), ys = (P) => mt(P, (I) => {
    const ee = I.text || I.title || "";
    return Lc(I) ? {
      text: ee,
      items: ys(I.menu)
    } : {
      text: ee,
      value: I.value
    };
  }), Hc = (P) => P.length ? te.some(ys([
    {
      text: "Select...",
      value: "mce-no-match"
    },
    ...P
  ])) : te.none(), Nf = (P, I, ee, he) => mt(I, (Be) => {
    const Pt = Be.text || Be.title;
    return Lc(Be) ? {
      type: "nestedmenuitem",
      text: Pt,
      getSubmenuItems: () => Nf(P, Be.menu, ee, he)
    } : {
      text: Pt,
      type: "togglemenuitem",
      onAction: () => he(Be.value),
      onSetup: pd(P, ee, Be.value)
    };
  }), Iu = (P, I) => (ee) => {
    P.execCommand("mceTableApplyCellStyle", !1, { [I]: ee });
  }, Fs = (P) => Ue(P, (I) => Lc(I) ? [{
    ...I,
    menu: Fs(I.menu)
  }] : gi(I.value) ? [I] : []), hd = (P, I, ee, he) => (Be) => Be(Nf(P, I, ee, he)), ec = (P, I, ee) => {
    const he = mt(I, (Be) => ({
      text: Be.title,
      value: "#" + Jl(Be.value).value,
      type: "choiceitem"
    }));
    return [{
      type: "fancymenuitem",
      fancytype: "colorswatch",
      initData: {
        colors: he.length > 0 ? he : void 0,
        allowCustomColors: !1
      },
      onAction: (Be) => {
        const Pt = Be.value === "remove" ? "" : Be.value;
        P.execCommand("mceTableApplyCellStyle", !1, { [ee]: Pt });
      }
    }];
  }, dr = (P) => () => {
    const ee = P.queryCommandValue("mceTableRowType") === "header" ? "body" : "header";
    P.execCommand("mceTableRowType", !1, { type: ee });
  }, Kd = (P) => () => {
    const ee = P.queryCommandValue("mceTableColType") === "th" ? "td" : "th";
    P.execCommand("mceTableColType", !1, { type: ee });
  }, Sm = (P) => Hc(Zi(P)).map((I) => ({
    name: "class",
    type: "listbox",
    label: "Class",
    items: I
  })), gp = [
    {
      name: "width",
      type: "input",
      label: "Width"
    },
    {
      name: "celltype",
      type: "listbox",
      label: "Cell type",
      items: [
        {
          text: "Cell",
          value: "td"
        },
        {
          text: "Header cell",
          value: "th"
        }
      ]
    },
    {
      name: "scope",
      type: "listbox",
      label: "Scope",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Row",
          value: "row"
        },
        {
          text: "Column",
          value: "col"
        },
        {
          text: "Row group",
          value: "rowgroup"
        },
        {
          text: "Column group",
          value: "colgroup"
        }
      ]
    },
    {
      name: "halign",
      type: "listbox",
      label: "Horizontal align",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Left",
          value: "left"
        },
        {
          text: "Center",
          value: "center"
        },
        {
          text: "Right",
          value: "right"
        }
      ]
    },
    {
      name: "valign",
      type: "listbox",
      label: "Vertical align",
      items: za
    }
  ], Yg = (P) => gp.concat(Sm(P).toArray()), bp = (P, I) => {
    const he = [
      {
        name: "borderstyle",
        type: "listbox",
        label: "Border style",
        items: [{
          text: "Select...",
          value: ""
        }].concat(ys(qa(P)))
      },
      {
        name: "bordercolor",
        type: "colorinput",
        label: "Border color"
      },
      {
        name: "backgroundcolor",
        type: "colorinput",
        label: "Background color"
      }
    ];
    return {
      title: "Advanced",
      name: "advanced",
      items: I === "cell" ? [{
        name: "borderwidth",
        type: "input",
        label: "Border width"
      }].concat(he) : he
    };
  }, R = { normal: (P, I) => {
    const ee = P.dom;
    return {
      setAttrib: (sn, Hn) => {
        ee.setAttrib(I, sn, Hn);
      },
      setStyle: (sn, Hn) => {
        ee.setStyle(I, sn, Hn);
      },
      setFormat: (sn, Hn) => {
        Hn === "" ? P.formatter.remove(sn, { value: null }, I, !0) : P.formatter.apply(sn, { value: Hn }, I);
      }
    };
  } }, V = ca("th"), re = (P, I) => P && I ? "sectionCells" : P ? "section" : "cells", Pe = (P) => {
    const I = P.section === "thead", ee = vc($e(P.cells), "th");
    return P.section === "tfoot" ? { type: "footer" } : I || ee ? {
      type: "header",
      subType: re(I, ee)
    } : { type: "body" };
  }, $e = (P) => {
    const I = Ot(P, (ee) => V(ee.element));
    return I.length === 0 ? te.some("td") : I.length === P.length ? te.some("th") : te.none();
  }, $t = (P) => {
    const I = mt(P, (Be) => Pe(Be).type), ee = St(I, "header"), he = St(I, "footer");
    if (!ee && !he)
      return te.some("body");
    {
      const Be = St(I, "body");
      return ee && !Be && !he ? te.some("header") : !ee && !Be && he ? te.some("footer") : te.none();
    }
  }, vo = (P) => {
    let I = !1, ee;
    return (...he) => (I || (I = !0, ee = P.apply(null, he)), ee);
  }, $o = (P, I) => Jn(P.all, (ee) => $n(ee.cells, (he) => Zo(I, he.element))), Mo = (P, I, ee) => {
    const he = mt(I.selection, (Pt) => ge(Pt).bind((sn) => $o(P, sn)).filter(ee)), Be = Lr(he);
    return na(Be.length > 0, Be);
  }, bo = (P, I) => I.mergable, Vs = (P, I) => I.unmergable, ma = (P, I) => Mo(P, I, Xe), _l = (P, I) => $o(P, I).exists((ee) => !ee.isLocked), ba = (P, I) => jn(I, (ee) => _l(P, ee)), Qg = (P, I) => bo(P, I).filter((ee) => ba(P, ee.cells)), P0 = (P, I) => Vs(P, I).filter((ee) => ba(P, ee));
  ({ ...{ generate: (P) => {
    if (!_(P))
      throw new Error("cases must be an array");
    if (P.length === 0)
      throw new Error("there must be at least one case");
    const I = [], ee = {};
    return Y(P, (he, Be) => {
      const Pt = lt(he);
      if (Pt.length !== 1)
        throw new Error("one and only one name per case");
      const sn = Pt[0], Hn = he[sn];
      if (ee[sn] !== void 0)
        throw new Error("duplicate key detected:" + sn);
      if (sn === "cata")
        throw new Error("cannot have a case named cata (sorry)");
      if (!_(Hn))
        throw new Error("case arguments must be an array");
      I.push(sn), ee[sn] = (...Ro) => {
        const ar = Ro.length;
        if (ar !== Hn.length)
          throw new Error("Wrong number of arguments to case " + sn + ". Expected " + Hn.length + " (" + Hn + "), got " + ar);
        return {
          fold: (...Zr) => {
            if (Zr.length !== P.length)
              throw new Error("Wrong number of arguments to fold. Expected " + P.length + ", got " + Zr.length);
            return Zr[Be].apply(null, Ro);
          },
          match: (Zr) => {
            const $s = lt(Zr);
            if (I.length !== $s.length)
              throw new Error("Wrong number of arguments to match. Expected: " + I.join(",") + `
Actual: ` + $s.join(","));
            if (!jn(I, (yd) => St($s, yd)))
              throw new Error("Not all branches were specified when using match. Specified: " + $s.join(", ") + `
Required: ` + I.join(", "));
            return Zr[sn].apply(null, Ro);
          },
          log: (Zr) => {
            console.log(Zr, {
              constructors: I,
              constructor: sn,
              params: Ro
            });
          }
        };
      };
    }), ee;
  } }.generate([
    { none: [] },
    { only: ["index"] },
    {
      left: [
        "index",
        "next"
      ]
    },
    {
      middle: [
        "prev",
        "index",
        "next"
      ]
    },
    {
      right: [
        "prev",
        "index"
      ]
    }
  ]) });
  const Ev = (P, I) => {
    const ee = Yl.fromTable(P);
    return ma(ee, I).bind((Be) => {
      const Pt = Be[Be.length - 1], sn = Be[0].row, Hn = Pt.row + Pt.rowspan, Ro = ee.all.slice(sn, Hn);
      return $t(Ro);
    }).getOr("");
  }, Ni = (P) => Ai(P, "rgb") ? Cm(P) : P, wo = (P) => {
    const I = pn.fromDom(P);
    return {
      borderwidth: le(I, "border-width").getOr(""),
      borderstyle: le(I, "border-style").getOr(""),
      bordercolor: le(I, "border-color").map(Ni).getOr(""),
      backgroundcolor: le(I, "background-color").map(Ni).getOr("")
    };
  }, zc = (P) => {
    const I = P[0], ee = P.slice(1);
    return Y(ee, (he) => {
      Y(lt(I), (Be) => {
        Kt(he, (Pt, sn) => {
          const Hn = I[Be];
          Hn !== "" && Be === sn && Hn !== Pt && (I[Be] = Be === "class" ? "mce-no-match" : "");
        });
      });
    }), I;
  }, vp = (P, I, ee, he) => $n(P, (Be) => !L(ee.formatter.matchNode(he, I + Be))).getOr(""), yp = G(vp, [
    "left",
    "center",
    "right"
  ], "align"), D0 = G(vp, [
    "top",
    "middle",
    "bottom"
  ], "valign"), Tv = (P, I) => {
    const ee = Dh(P), he = Zd(P), Be = () => ({
      borderstyle: mn(ee, "border-style").getOr(""),
      bordercolor: Ni(mn(ee, "border-color").getOr("")),
      backgroundcolor: Ni(mn(ee, "background-color").getOr(""))
    }), Pt = {
      height: "",
      width: "100%",
      cellspacing: "",
      cellpadding: "",
      caption: !1,
      class: "",
      align: "",
      border: ""
    }, sn = () => {
      const rs = ee["border-width"];
      return Cc(P) && rs ? { border: rs } : mn(he, "border").fold(() => ({}), (Zr) => ({ border: Zr }));
    }, Hn = I ? Be() : {}, Ro = () => {
      const rs = mn(ee, "border-spacing").or(mn(he, "cellspacing")).fold(() => ({}), ($s) => ({ cellspacing: $s })), Zr = mn(ee, "border-padding").or(mn(he, "cellpadding")).fold(() => ({}), ($s) => ({ cellpadding: $s }));
      return {
        ...rs,
        ...Zr
      };
    };
    return {
      ...Pt,
      ...ee,
      ...he,
      ...Hn,
      ...sn(),
      ...Ro()
    };
  }, uu = (P) => Cn(pn.fromDom(P)).map((I) => {
    const ee = { selection: qg(P.cells) };
    return Ev(I, ee);
  }).getOr(""), gd = (P, I, ee) => {
    const he = (Hn, Ro) => {
      const ar = le(pn.fromDom(Ro), "border-width");
      return Cc(P) && ar.isSome() ? ar.getOr("") : Hn.getAttrib(Ro, "border") || Ga(P.dom, Ro, "border-width") || Ga(P.dom, Ro, "border") || "";
    }, Be = P.dom, Pt = Cc(P) ? Be.getStyle(I, "border-spacing") || Be.getAttrib(I, "cellspacing") : Be.getAttrib(I, "cellspacing") || Be.getStyle(I, "border-spacing"), sn = Cc(P) ? Ga(Be, I, "padding") || Be.getAttrib(I, "cellpadding") : Be.getAttrib(I, "cellpadding") || Ga(Be, I, "padding");
    return {
      width: Be.getStyle(I, "width") || Be.getAttrib(I, "width"),
      height: Be.getStyle(I, "height") || Be.getAttrib(I, "height"),
      cellspacing: Pt ?? "",
      cellpadding: sn ?? "",
      border: he(Be, I),
      caption: !!Be.select("caption", I)[0],
      class: Be.getAttrib(I, "class", ""),
      align: yp(P, I),
      ...ee ? wo(I) : {}
    };
  }, Mf = (P, I, ee) => {
    const he = P.dom;
    return {
      height: he.getStyle(I, "height") || he.getAttrib(I, "height"),
      class: he.getAttrib(I, "class", ""),
      type: uu(I),
      align: yp(P, I),
      ...ee ? wo(I) : {}
    };
  }, On = (P, I, ee, he) => {
    const Be = P.dom, Pt = he.getOr(I);
    return {
      width: ((Hn, Ro) => Be.getStyle(Hn, Ro) || Be.getAttrib(Hn, Ro))(Pt, "width"),
      scope: Be.getAttrib(I, "scope"),
      celltype: kn(I),
      class: Be.getAttrib(I, "class", ""),
      halign: yp(P, I),
      valign: D0(P, I),
      ...ee ? wo(I) : {}
    };
  }, kc = (P, I) => {
    const ee = Yl.fromTable(P), he = Yl.justCells(ee), Be = Ot(he, (Pt) => on(I, (sn) => Zo(Pt.element, sn)));
    return mt(Be, (Pt) => ({
      element: Pt.element.dom,
      column: Yl.getColumnAt(ee, Pt.column).map((sn) => sn.element.dom)
    }));
  }, Ov = (P, I, ee, he) => {
    he("scope") && P.setAttrib("scope", ee.scope), he("class") && ee.class !== "mce-no-match" && P.setAttrib("class", ee.class), he("width") && I.setStyle("width", Qn(ee.width));
  }, km = (P, I, ee) => {
    ee("backgroundcolor") && P.setFormat("tablecellbackgroundcolor", I.backgroundcolor), ee("bordercolor") && P.setFormat("tablecellbordercolor", I.bordercolor), ee("borderstyle") && P.setFormat("tablecellborderstyle", I.borderstyle), ee("borderwidth") && P.setFormat("tablecellborderwidth", Qn(I.borderwidth));
  }, du = (P, I, ee, he) => {
    const Be = I.length === 1;
    Y(I, (Pt) => {
      const sn = Pt.element, Hn = Be ? Xe : he, Ro = R.normal(P, sn), ar = Pt.column.map((rs) => R.normal(P, rs)).getOr(Ro);
      Ov(Ro, ar, ee, Hn), dl(P) && km(Ro, ee, Hn), he("halign") && xi(P, sn, ee.halign), he("valign") && Of(P, sn, ee.valign);
    });
  }, Lh = (P, I) => {
    P.execCommand("mceTableCellType", !1, {
      type: I.celltype,
      no_events: !0
    });
  }, If = (P, I, ee, he) => {
    const Be = dn(he, (Pt, sn) => ee[sn] !== Pt);
    B(Be) > 0 && I.length >= 1 && Cn(I[0]).each((Pt) => {
      const sn = kc(Pt, I), Hn = B(dn(Be, (ar, rs) => rs !== "scope" && rs !== "celltype")) > 0, Ro = dt(Be, "celltype");
      (Hn || dt(Be, "scope")) && du(P, sn, he, G(dt, Be)), Ro && Lh(P, he), gr(P, Pt.dom, {
        structure: Ro,
        style: Hn
      });
    });
  }, _m = (P, I, ee, he) => {
    const Be = he.getData();
    he.close(), P.undoManager.transact(() => {
      If(P, I, ee, Be), P.focus();
    });
  }, Hh = (P, I) => {
    const ee = Cn(I[0]).map((he) => mt(kc(he, I), (Be) => On(P, Be.element, dl(P), Be.column)));
    return zc(ee.getOrDie());
  }, Fu = (P) => {
    const I = cu(P);
    if (I.length === 0)
      return;
    const ee = Hh(P, I), he = {
      type: "tabpanel",
      tabs: [
        {
          title: "General",
          name: "general",
          items: Yg(P)
        },
        bp(P, "cell")
      ]
    }, Be = {
      type: "panel",
      items: [{
        type: "grid",
        columns: 2,
        items: Yg(P)
      }]
    };
    P.windowManager.open({
      title: "Cell Properties",
      size: "normal",
      body: dl(P) ? he : Be,
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: ee,
      onSubmit: G(_m, P, I, ee)
    });
  }, R0 = (P) => Hc(fd(P)).map((I) => ({
    name: "class",
    type: "listbox",
    label: "Class",
    items: I
  })), ia = [
    {
      type: "listbox",
      name: "type",
      label: "Row type",
      items: [
        {
          text: "Header",
          value: "header"
        },
        {
          text: "Body",
          value: "body"
        },
        {
          text: "Footer",
          value: "footer"
        }
      ]
    },
    {
      type: "listbox",
      name: "align",
      label: "Alignment",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Left",
          value: "left"
        },
        {
          text: "Center",
          value: "center"
        },
        {
          text: "Right",
          value: "right"
        }
      ]
    },
    {
      label: "Height",
      name: "height",
      type: "input"
    }
  ], Zt = (P) => ia.concat(R0(P).toArray()), El = (P, I, ee) => {
    ee("class") && I.class !== "mce-no-match" && P.setAttrib("class", I.class), ee("height") && P.setStyle("height", Qn(I.height));
  }, Bu = (P, I, ee) => {
    ee("backgroundcolor") && P.setStyle("background-color", I.backgroundcolor), ee("bordercolor") && P.setStyle("border-color", I.bordercolor), ee("borderstyle") && P.setStyle("border-style", I.borderstyle);
  }, ci = (P, I, ee, he) => {
    const Pt = I.length === 1 ? Xe : he;
    Y(I, (sn) => {
      const Hn = Ti(pn.fromDom(sn), "td,th"), Ro = R.normal(P, sn);
      El(Ro, ee, Pt), Mc(P) && Bu(Ro, ee, Pt), he("height") && Y(Hn, (ar) => {
        P.dom.setStyle(ar.dom, "height", null);
      }), he("align") && xi(P, sn, ee.align);
    });
  }, xp = (P, I) => {
    P.execCommand("mceTableRowType", !1, {
      type: I.type,
      no_events: !0
    });
  }, Qa = (P, I, ee, he) => {
    const Be = dn(he, (Pt, sn) => ee[sn] !== Pt);
    if (B(Be) > 0) {
      const Pt = dt(Be, "type"), sn = Pt ? B(Be) > 1 : !0;
      sn && ci(P, I, he, G(dt, Be)), Pt && xp(P, he), Cn(pn.fromDom(I[0])).each((Hn) => gr(P, Hn.dom, {
        structure: Pt,
        style: sn
      }));
    }
  }, Wr = (P, I, ee, he) => {
    const Be = he.getData();
    he.close(), P.undoManager.transact(() => {
      Qa(P, I, ee, Be), P.focus();
    });
  }, eb = (P) => {
    const I = Kg(lo(P), Cl.selected);
    if (I.length === 0)
      return;
    const ee = mt(I, (sn) => Mf(P, sn.dom, Mc(P))), he = zc(ee), Be = {
      type: "tabpanel",
      tabs: [
        {
          title: "General",
          name: "general",
          items: Zt(P)
        },
        bp(P, "row")
      ]
    }, Pt = {
      type: "panel",
      items: [{
        type: "grid",
        columns: 2,
        items: Zt(P)
      }]
    };
    P.windowManager.open({
      title: "Row Properties",
      size: "normal",
      body: Mc(P) ? Be : Pt,
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: he,
      onSubmit: G(Wr, P, mt(I, (sn) => sn.dom), he)
    });
  }, Rt = (P, I, ee) => {
    const he = ee ? [
      {
        type: "input",
        name: "cols",
        label: "Cols",
        inputMode: "numeric"
      },
      {
        type: "input",
        name: "rows",
        label: "Rows",
        inputMode: "numeric"
      }
    ] : [], Be = [
      {
        type: "input",
        name: "width",
        label: "Width"
      },
      {
        type: "input",
        name: "height",
        label: "Height"
      }
    ], Pt = ip(P) ? [
      {
        type: "input",
        name: "cellspacing",
        label: "Cell spacing",
        inputMode: "numeric"
      },
      {
        type: "input",
        name: "cellpadding",
        label: "Cell padding",
        inputMode: "numeric"
      },
      {
        type: "input",
        name: "border",
        label: "Border width"
      },
      {
        type: "label",
        label: "Caption",
        items: [{
          type: "checkbox",
          name: "caption",
          label: "Show caption"
        }]
      }
    ] : [], sn = [{
      type: "listbox",
      name: "align",
      label: "Alignment",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Left",
          value: "left"
        },
        {
          text: "Center",
          value: "center"
        },
        {
          text: "Right",
          value: "right"
        }
      ]
    }], Hn = I.length > 0 ? [{
      name: "class",
      type: "listbox",
      label: "Class",
      items: I
    }] : [];
    return he.concat(Be).concat(Pt).concat(sn).concat(Hn);
  }, Vr = (P, I, ee, he) => {
    if (I.tagName === "TD" || I.tagName === "TH")
      k(ee) && se(he) ? P.setStyle(I, ee, he) : P.setStyles(I, ee);
    else if (I.children)
      for (let Be = 0; Be < I.children.length; Be++)
        Vr(P, I.children[Be], ee, he);
  }, tb = (P, I, ee, he) => {
    const Be = P.dom, Pt = {}, sn = {}, Hn = Cc(P), Ro = Ic(P), ar = parseFloat(ee.border) === 0;
    if (!L(ee.class) && ee.class !== "mce-no-match" && (Pt.class = ee.class), sn.height = Qn(ee.height), Hn ? sn.width = Qn(ee.width) : Be.getAttrib(I, "width") && (Pt.width = qn(ee.width)), Hn ? (ar ? (Pt.border = 0, sn["border-width"] = "") : (sn["border-width"] = Qn(ee.border), Pt.border = 1), sn["border-spacing"] = Qn(ee.cellspacing)) : (Pt.border = ar ? 0 : ee.border, Pt.cellpadding = ee.cellpadding, Pt.cellspacing = ee.cellspacing), Hn && I.children) {
      const rs = {};
      if (ar ? rs["border-width"] = "" : he.border && (rs["border-width"] = Qn(ee.border)), he.cellpadding && (rs.padding = Qn(ee.cellpadding)), Ro && he.bordercolor && (rs["border-color"] = ee.bordercolor), !tn(rs))
        for (let Zr = 0; Zr < I.children.length; Zr++)
          Vr(Be, I.children[Zr], rs);
    }
    if (Ro) {
      const rs = ee;
      sn["background-color"] = rs.backgroundcolor, sn["border-color"] = rs.bordercolor, sn["border-style"] = rs.borderstyle;
    }
    Be.setStyles(I, {
      ...Dh(P),
      ...sn
    }), Be.setAttribs(I, {
      ...Zd(P),
      ...Pt
    });
  }, Va = (P, I, ee, he) => {
    const Be = P.dom, Pt = he.getData(), sn = dn(Pt, (Hn, Ro) => ee[Ro] !== Hn);
    he.close(), P.undoManager.transact(() => {
      if (!I) {
        const Hn = $a(Pt.cols).getOr(1), Ro = $a(Pt.rows).getOr(1);
        P.execCommand("mceInsertTable", !1, {
          rows: Ro,
          columns: Hn
        }), I = no(lo(P), Gn(P)).bind((ar) => Cn(ar, Gn(P))).map((ar) => ar.dom).getOrDie();
      }
      if (B(sn) > 0) {
        const Hn = {
          border: dt(sn, "border"),
          bordercolor: dt(sn, "bordercolor"),
          cellpadding: dt(sn, "cellpadding")
        };
        tb(P, I, Pt, Hn);
        const Ro = Be.select("caption", I)[0];
        (Ro && !Pt.caption || !Ro && Pt.caption) && P.execCommand("mceTableToggleCaption"), xi(P, I, Pt.align);
      }
      if (P.focus(), P.addVisual(), B(sn) > 0) {
        const Hn = dt(sn, "caption"), Ro = Hn ? B(sn) > 1 : !0;
        gr(P, I, {
          structure: Hn,
          style: Ro
        });
      }
    });
  }, Yi = (P, I) => {
    const ee = P.dom;
    let he, Be = Tv(P, Ic(P));
    I ? (Be.cols = "1", Be.rows = "1", Ic(P) && (Be.borderstyle = "", Be.bordercolor = "", Be.backgroundcolor = "")) : (he = ee.getParent(P.selection.getStart(), "table", P.getBody()), he ? Be = gd(P, he, Ic(P)) : Ic(P) && (Be.borderstyle = "", Be.bordercolor = "", Be.backgroundcolor = ""));
    const Pt = Hc(Af(P));
    Pt.isSome() && Be.class && (Be.class = Be.class.replace(/\s*mce\-item\-table\s*/g, ""));
    const sn = {
      type: "grid",
      columns: 2,
      items: Rt(P, Pt.getOr([]), I)
    }, Hn = () => ({
      type: "panel",
      items: [sn]
    }), Ro = () => ({
      type: "tabpanel",
      tabs: [
        {
          title: "General",
          name: "general",
          items: [sn]
        },
        bp(P, "table")
      ]
    }), ar = Ic(P) ? Ro() : Hn();
    P.windowManager.open({
      title: "Table Properties",
      size: "normal",
      body: ar,
      onSubmit: G(Va, P, he, Be),
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: Be
    });
  }, Nw = (P) => {
    const I = (ee) => {
      Kr(lo(P)) && ee();
    };
    Kt({
      mceTableProps: G(Yi, P, !1),
      mceTableRowProps: G(eb, P),
      mceTableCellProps: G(Fu, P),
      mceInsertTableDialog: G(Yi, P, !0)
    }, (ee, he) => P.addCommand(he, () => I(ee)));
  }, _c = (P, I) => He(P, I).isSome(), Mw = oe, Yd = (P) => {
    const I = (he, Be) => vs(he, Be).exists((Pt) => parseInt(Pt, 10) > 1), ee = (he) => I(he, "rowspan") || I(he, "colspan");
    return P.length > 0 && jn(P, ee) ? te.some(P) : te.none();
  }, N0 = (P, I, ee) => I.length <= 1 ? te.none() : kv(P, ee.firstSelectedSelector, ee.lastSelectedSelector).map((he) => ({
    bounds: he,
    cells: I
  })), Ec = (P) => ({
    element: P,
    mergable: te.none(),
    unmergable: te.none(),
    selection: [P]
  }), jr = (P, I, ee) => ({
    element: ee,
    mergable: N0(I, P, Cl),
    unmergable: Yd(P),
    selection: Mw(P)
  }), bd = (P) => {
    const I = Ys(te.none()), ee = Ys([]);
    let he = te.none();
    const Be = ca("caption"), Pt = (wr) => he.forall((Xs) => !Xs[wr]), sn = () => Ra(lo(P), Gn(P)), Hn = () => Ra(rr(P), Gn(P)), Ro = () => sn().bind((wr) => ii(ka(Cn(wr), Hn().bind(Cn), (Xs, Ja) => Zo(Xs, Ja) ? Be(wr) ? te.some(Ec(wr)) : te.some(jr(cu(P), Xs, wr)) : te.none()))), ar = (wr) => Cn(wr.element).map((Ja) => {
      const Tc = Yl.fromTable(Ja), nc = ma(Tc, wr).getOr([]), sb = zn(nc, (wd, Tm) => (Tm.isLocked && (wd.onAny = !0, Tm.column === 0 ? wd.onFirst = !0 : Tm.column + Tm.colspan >= Tc.grid.columns && (wd.onLast = !0)), wd), {
        onAny: !1,
        onFirst: !1,
        onLast: !1
      });
      return {
        mergeable: Qg(Tc, wr).isSome(),
        unmergeable: P0(Tc, wr).isSome(),
        locked: sb
      };
    }), rs = () => {
      I.set(vo(Ro)()), he = I.get().bind(ar), Y(ee.get(), ve);
    }, Zr = (wr) => (wr(), ee.set(ee.get().concat([wr])), () => {
      ee.set(Ot(ee.get(), (Xs) => Xs !== wr));
    }), $s = (wr, Xs) => Zr(() => I.get().fold(() => {
      wr.setEnabled(!1);
    }, (Ja) => {
      wr.setEnabled(!Xs(Ja) && P.selection.isEditable());
    })), tc = (wr, Xs, Ja) => Zr(() => I.get().fold(() => {
      wr.setEnabled(!1), wr.setActive(!1);
    }, (Tc) => {
      wr.setEnabled(!Xs(Tc) && P.selection.isEditable()), wr.setActive(Ja(Tc));
    })), yd = (wr) => he.exists((Xs) => Xs.locked[wr]), ml = (wr) => $s(wr, (Xs) => !1), xd = (wr) => $s(wr, (Xs) => Be(Xs.element)), Ff = (wr) => (Xs) => $s(Xs, (Ja) => Be(Ja.element) || yd(wr)), Lu = (wr) => (Xs) => $s(Xs, (Ja) => Be(Ja.element) || wr().isNone()), Sp = (wr, Xs) => (Ja) => $s(Ja, (Tc) => Be(Tc.element) || wr().isNone() || yd(Xs)), jc = (wr) => $s(wr, (Xs) => Pt("mergeable")), nb = (wr) => $s(wr, (Xs) => Pt("unmergeable")), zh = (wr) => tc(wr, nt, (Xs) => Cn(Xs.element, Gn(P)).exists((Tc) => _c(Tc, "caption"))), ob = (wr, Xs) => (Ja) => tc(Ja, (Tc) => Be(Tc.element), () => P.queryCommandValue(wr) === Xs), rb = ob("mceTableRowType", "header"), ui = ob("mceTableColType", "th");
    return P.on("NodeChange ExecCommand TableSelectorChange", rs), {
      onSetupTable: ml,
      onSetupCellOrRow: xd,
      onSetupColumn: Ff,
      onSetupPasteable: Lu,
      onSetupPasteableColumn: Sp,
      onSetupMergeable: jc,
      onSetupUnmergeable: nb,
      resetTargets: rs,
      onSetupTableWithCaption: zh,
      onSetupTableRowHeaders: rb,
      onSetupTableColumnHeaders: ui,
      targets: I.get
    };
  };
  var Em = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
  const ja = "x-tinymce/dom-table-", Av = ja + "rows", vd = ja + "columns", $u = (P) => {
    var I;
    const ee = (I = Em.read()) !== null && I !== void 0 ? I : [];
    return Jn(ee, (he) => te.from(he.getType(P)));
  }, Es = () => $u(Av), wp = () => $u(vd), Qe = (P) => (I) => {
    const ee = () => {
      I.setEnabled(P.selection.isEditable());
    };
    return P.on("NodeChange", ee), ee(), () => {
      P.off("NodeChange", ee);
    };
  }, Vc = (P, I) => {
    P.ui.registry.addMenuButton("table", {
      tooltip: "Table",
      icon: "table",
      onSetup: Qe(P),
      fetch: (Hn) => Hn("inserttable | cell row column | advtablesort | tableprops deletetable")
    });
    const ee = (Hn) => () => P.execCommand(Hn), he = (Hn, Ro) => {
      P.queryCommandSupported(Ro.command) && P.ui.registry.addButton(Hn, {
        ...Ro,
        onAction: J(Ro.onAction) ? Ro.onAction : ee(Ro.command)
      });
    }, Be = (Hn, Ro) => {
      P.queryCommandSupported(Ro.command) && P.ui.registry.addToggleButton(Hn, {
        ...Ro,
        onAction: J(Ro.onAction) ? Ro.onAction : ee(Ro.command)
      });
    };
    he("tableprops", {
      tooltip: "Table properties",
      command: "mceTableProps",
      icon: "table",
      onSetup: I.onSetupTable
    }), he("tabledelete", {
      tooltip: "Delete table",
      command: "mceTableDelete",
      icon: "table-delete-table",
      onSetup: I.onSetupTable
    }), he("tablecellprops", {
      tooltip: "Cell properties",
      command: "mceTableCellProps",
      icon: "table-cell-properties",
      onSetup: I.onSetupCellOrRow
    }), he("tablemergecells", {
      tooltip: "Merge cells",
      command: "mceTableMergeCells",
      icon: "table-merge-cells",
      onSetup: I.onSetupMergeable
    }), he("tablesplitcells", {
      tooltip: "Split cell",
      command: "mceTableSplitCells",
      icon: "table-split-cells",
      onSetup: I.onSetupUnmergeable
    }), he("tableinsertrowbefore", {
      tooltip: "Insert row before",
      command: "mceTableInsertRowBefore",
      icon: "table-insert-row-above",
      onSetup: I.onSetupCellOrRow
    }), he("tableinsertrowafter", {
      tooltip: "Insert row after",
      command: "mceTableInsertRowAfter",
      icon: "table-insert-row-after",
      onSetup: I.onSetupCellOrRow
    }), he("tabledeleterow", {
      tooltip: "Delete row",
      command: "mceTableDeleteRow",
      icon: "table-delete-row",
      onSetup: I.onSetupCellOrRow
    }), he("tablerowprops", {
      tooltip: "Row properties",
      command: "mceTableRowProps",
      icon: "table-row-properties",
      onSetup: I.onSetupCellOrRow
    }), he("tableinsertcolbefore", {
      tooltip: "Insert column before",
      command: "mceTableInsertColBefore",
      icon: "table-insert-column-before",
      onSetup: I.onSetupColumn("onFirst")
    }), he("tableinsertcolafter", {
      tooltip: "Insert column after",
      command: "mceTableInsertColAfter",
      icon: "table-insert-column-after",
      onSetup: I.onSetupColumn("onLast")
    }), he("tabledeletecol", {
      tooltip: "Delete column",
      command: "mceTableDeleteCol",
      icon: "table-delete-column",
      onSetup: I.onSetupColumn("onAny")
    }), he("tablecutrow", {
      tooltip: "Cut row",
      command: "mceTableCutRow",
      icon: "cut-row",
      onSetup: I.onSetupCellOrRow
    }), he("tablecopyrow", {
      tooltip: "Copy row",
      command: "mceTableCopyRow",
      icon: "duplicate-row",
      onSetup: I.onSetupCellOrRow
    }), he("tablepasterowbefore", {
      tooltip: "Paste row before",
      command: "mceTablePasteRowBefore",
      icon: "paste-row-before",
      onSetup: I.onSetupPasteable(Es)
    }), he("tablepasterowafter", {
      tooltip: "Paste row after",
      command: "mceTablePasteRowAfter",
      icon: "paste-row-after",
      onSetup: I.onSetupPasteable(Es)
    }), he("tablecutcol", {
      tooltip: "Cut column",
      command: "mceTableCutCol",
      icon: "cut-column",
      onSetup: I.onSetupColumn("onAny")
    }), he("tablecopycol", {
      tooltip: "Copy column",
      command: "mceTableCopyCol",
      icon: "duplicate-column",
      onSetup: I.onSetupColumn("onAny")
    }), he("tablepastecolbefore", {
      tooltip: "Paste column before",
      command: "mceTablePasteColBefore",
      icon: "paste-column-before",
      onSetup: I.onSetupPasteableColumn(wp, "onFirst")
    }), he("tablepastecolafter", {
      tooltip: "Paste column after",
      command: "mceTablePasteColAfter",
      icon: "paste-column-after",
      onSetup: I.onSetupPasteableColumn(wp, "onLast")
    }), he("tableinsertdialog", {
      tooltip: "Insert table",
      command: "mceInsertTableDialog",
      icon: "table",
      onSetup: Qe(P)
    });
    const Pt = Fs(Af(P));
    Pt.length !== 0 && P.queryCommandSupported("mceTableToggleClass") && P.ui.registry.addMenuButton("tableclass", {
      icon: "table-classes",
      tooltip: "Table styles",
      fetch: hd(P, Pt, "tableclass", (Hn) => P.execCommand("mceTableToggleClass", !1, Hn)),
      onSetup: I.onSetupTable
    });
    const sn = Fs(Zi(P));
    sn.length !== 0 && P.queryCommandSupported("mceTableCellToggleClass") && P.ui.registry.addMenuButton("tablecellclass", {
      icon: "table-cell-classes",
      tooltip: "Cell styles",
      fetch: hd(P, sn, "tablecellclass", (Hn) => P.execCommand("mceTableCellToggleClass", !1, Hn)),
      onSetup: I.onSetupCellOrRow
    }), P.queryCommandSupported("mceTableApplyCellStyle") && (P.ui.registry.addMenuButton("tablecellvalign", {
      icon: "vertical-align",
      tooltip: "Vertical align",
      fetch: hd(P, za, "tablecellverticalalign", Iu(P, "vertical-align")),
      onSetup: I.onSetupCellOrRow
    }), P.ui.registry.addMenuButton("tablecellborderwidth", {
      icon: "border-width",
      tooltip: "Border width",
      fetch: hd(P, wc(P), "tablecellborderwidth", Iu(P, "border-width")),
      onSetup: I.onSetupCellOrRow
    }), P.ui.registry.addMenuButton("tablecellborderstyle", {
      icon: "border-style",
      tooltip: "Border style",
      fetch: hd(P, qa(P), "tablecellborderstyle", Iu(P, "border-style")),
      onSetup: I.onSetupCellOrRow
    }), P.ui.registry.addMenuButton("tablecellbackgroundcolor", {
      icon: "cell-background-color",
      tooltip: "Background color",
      fetch: (Hn) => Hn(ec(P, Ah(P), "background-color")),
      onSetup: I.onSetupCellOrRow
    }), P.ui.registry.addMenuButton("tablecellbordercolor", {
      icon: "cell-border-color",
      tooltip: "Border color",
      fetch: (Hn) => Hn(ec(P, Pf(P), "border-color")),
      onSetup: I.onSetupCellOrRow
    })), Be("tablecaption", {
      tooltip: "Table caption",
      icon: "table-caption",
      command: "mceTableToggleCaption",
      onSetup: I.onSetupTableWithCaption
    }), Be("tablerowheader", {
      tooltip: "Row header",
      icon: "table-top-header",
      command: "mceTableRowType",
      onAction: dr(P),
      onSetup: I.onSetupTableRowHeaders
    }), Be("tablecolheader", {
      tooltip: "Column header",
      icon: "table-left-header",
      command: "mceTableColType",
      onAction: Kd(P),
      onSetup: I.onSetupTableColumnHeaders
    });
  }, Cp = (P) => {
    const I = (he) => P.dom.is(he, "table") && P.getBody().contains(he) && P.dom.isEditable(he.parentNode), ee = lu(P);
    ee.length > 0 && P.ui.registry.addContextToolbar("table", {
      predicate: I,
      items: ee,
      scope: "node",
      position: "node"
    });
  }, Mi = (P) => (I) => {
    const ee = () => {
      I.setEnabled(P.selection.isEditable());
    };
    return P.on("NodeChange", ee), ee(), () => {
      P.off("NodeChange", ee);
    };
  }, fu = (P, I) => {
    const ee = (Zr) => () => P.execCommand(Zr), he = (Zr, $s) => P.queryCommandSupported($s.command) ? (P.ui.registry.addMenuItem(Zr, {
      ...$s,
      onAction: J($s.onAction) ? $s.onAction : ee($s.command)
    }), !0) : !1, Be = (Zr, $s) => {
      P.queryCommandSupported($s.command) && P.ui.registry.addToggleMenuItem(Zr, {
        ...$s,
        onAction: J($s.onAction) ? $s.onAction : ee($s.command)
      });
    }, Pt = (Zr) => {
      P.execCommand("mceInsertTable", !1, {
        rows: Zr.numRows,
        columns: Zr.numColumns
      });
    }, sn = [
      he("tableinsertrowbefore", {
        text: "Insert row before",
        icon: "table-insert-row-above",
        command: "mceTableInsertRowBefore",
        onSetup: I.onSetupCellOrRow
      }),
      he("tableinsertrowafter", {
        text: "Insert row after",
        icon: "table-insert-row-after",
        command: "mceTableInsertRowAfter",
        onSetup: I.onSetupCellOrRow
      }),
      he("tabledeleterow", {
        text: "Delete row",
        icon: "table-delete-row",
        command: "mceTableDeleteRow",
        onSetup: I.onSetupCellOrRow
      }),
      he("tablerowprops", {
        text: "Row properties",
        icon: "table-row-properties",
        command: "mceTableRowProps",
        onSetup: I.onSetupCellOrRow
      }),
      he("tablecutrow", {
        text: "Cut row",
        icon: "cut-row",
        command: "mceTableCutRow",
        onSetup: I.onSetupCellOrRow
      }),
      he("tablecopyrow", {
        text: "Copy row",
        icon: "duplicate-row",
        command: "mceTableCopyRow",
        onSetup: I.onSetupCellOrRow
      }),
      he("tablepasterowbefore", {
        text: "Paste row before",
        icon: "paste-row-before",
        command: "mceTablePasteRowBefore",
        onSetup: I.onSetupPasteable(Es)
      }),
      he("tablepasterowafter", {
        text: "Paste row after",
        icon: "paste-row-after",
        command: "mceTablePasteRowAfter",
        onSetup: I.onSetupPasteable(Es)
      })
    ], Hn = [
      he("tableinsertcolumnbefore", {
        text: "Insert column before",
        icon: "table-insert-column-before",
        command: "mceTableInsertColBefore",
        onSetup: I.onSetupColumn("onFirst")
      }),
      he("tableinsertcolumnafter", {
        text: "Insert column after",
        icon: "table-insert-column-after",
        command: "mceTableInsertColAfter",
        onSetup: I.onSetupColumn("onLast")
      }),
      he("tabledeletecolumn", {
        text: "Delete column",
        icon: "table-delete-column",
        command: "mceTableDeleteCol",
        onSetup: I.onSetupColumn("onAny")
      }),
      he("tablecutcolumn", {
        text: "Cut column",
        icon: "cut-column",
        command: "mceTableCutCol",
        onSetup: I.onSetupColumn("onAny")
      }),
      he("tablecopycolumn", {
        text: "Copy column",
        icon: "duplicate-column",
        command: "mceTableCopyCol",
        onSetup: I.onSetupColumn("onAny")
      }),
      he("tablepastecolumnbefore", {
        text: "Paste column before",
        icon: "paste-column-before",
        command: "mceTablePasteColBefore",
        onSetup: I.onSetupPasteableColumn(wp, "onFirst")
      }),
      he("tablepastecolumnafter", {
        text: "Paste column after",
        icon: "paste-column-after",
        command: "mceTablePasteColAfter",
        onSetup: I.onSetupPasteableColumn(wp, "onLast")
      })
    ], Ro = [
      he("tablecellprops", {
        text: "Cell properties",
        icon: "table-cell-properties",
        command: "mceTableCellProps",
        onSetup: I.onSetupCellOrRow
      }),
      he("tablemergecells", {
        text: "Merge cells",
        icon: "table-merge-cells",
        command: "mceTableMergeCells",
        onSetup: I.onSetupMergeable
      }),
      he("tablesplitcells", {
        text: "Split cell",
        icon: "table-split-cells",
        command: "mceTableSplitCells",
        onSetup: I.onSetupUnmergeable
      })
    ];
    dd(P) ? P.ui.registry.addNestedMenuItem("inserttable", {
      text: "Table",
      icon: "table",
      getSubmenuItems: () => [{
        type: "fancymenuitem",
        fancytype: "inserttable",
        onAction: Pt
      }],
      onSetup: Mi(P)
    }) : P.ui.registry.addMenuItem("inserttable", {
      text: "Table",
      icon: "table",
      onAction: ee("mceInsertTableDialog"),
      onSetup: Mi(P)
    }), P.ui.registry.addMenuItem("inserttabledialog", {
      text: "Insert table",
      icon: "table",
      onAction: ee("mceInsertTableDialog"),
      onSetup: Mi(P)
    }), he("tableprops", {
      text: "Table properties",
      onSetup: I.onSetupTable,
      command: "mceTableProps"
    }), he("deletetable", {
      text: "Delete table",
      icon: "table-delete-table",
      onSetup: I.onSetupTable,
      command: "mceTableDelete"
    }), St(sn, !0) && P.ui.registry.addNestedMenuItem("row", {
      type: "nestedmenuitem",
      text: "Row",
      getSubmenuItems: Q("tableinsertrowbefore tableinsertrowafter tabledeleterow tablerowprops | tablecutrow tablecopyrow tablepasterowbefore tablepasterowafter")
    }), St(Hn, !0) && P.ui.registry.addNestedMenuItem("column", {
      type: "nestedmenuitem",
      text: "Column",
      getSubmenuItems: Q("tableinsertcolumnbefore tableinsertcolumnafter tabledeletecolumn | tablecutcolumn tablecopycolumn tablepastecolumnbefore tablepastecolumnafter")
    }), St(Ro, !0) && P.ui.registry.addNestedMenuItem("cell", {
      type: "nestedmenuitem",
      text: "Cell",
      getSubmenuItems: Q("tablecellprops tablemergecells tablesplitcells")
    }), P.ui.registry.addContextMenu("table", {
      update: () => (I.resetTargets(), I.targets().fold(Q(""), (Zr) => Ht(Zr.element) === "caption" ? "tableprops deletetable" : "cell row column | advtablesort | tableprops deletetable"))
    });
    const ar = Fs(Af(P));
    ar.length !== 0 && P.queryCommandSupported("mceTableToggleClass") && P.ui.registry.addNestedMenuItem("tableclass", {
      icon: "table-classes",
      text: "Table styles",
      getSubmenuItems: () => Nf(P, ar, "tableclass", (Zr) => P.execCommand("mceTableToggleClass", !1, Zr)),
      onSetup: I.onSetupTable
    });
    const rs = Fs(Zi(P));
    rs.length !== 0 && P.queryCommandSupported("mceTableCellToggleClass") && P.ui.registry.addNestedMenuItem("tablecellclass", {
      icon: "table-cell-classes",
      text: "Cell styles",
      getSubmenuItems: () => Nf(P, rs, "tablecellclass", (Zr) => P.execCommand("mceTableCellToggleClass", !1, Zr)),
      onSetup: I.onSetupCellOrRow
    }), P.queryCommandSupported("mceTableApplyCellStyle") && (P.ui.registry.addNestedMenuItem("tablecellvalign", {
      icon: "vertical-align",
      text: "Vertical align",
      getSubmenuItems: () => Nf(P, za, "tablecellverticalalign", Iu(P, "vertical-align")),
      onSetup: I.onSetupCellOrRow
    }), P.ui.registry.addNestedMenuItem("tablecellborderwidth", {
      icon: "border-width",
      text: "Border width",
      getSubmenuItems: () => Nf(P, wc(P), "tablecellborderwidth", Iu(P, "border-width")),
      onSetup: I.onSetupCellOrRow
    }), P.ui.registry.addNestedMenuItem("tablecellborderstyle", {
      icon: "border-style",
      text: "Border style",
      getSubmenuItems: () => Nf(P, qa(P), "tablecellborderstyle", Iu(P, "border-style")),
      onSetup: I.onSetupCellOrRow
    }), P.ui.registry.addNestedMenuItem("tablecellbackgroundcolor", {
      icon: "cell-background-color",
      text: "Background color",
      getSubmenuItems: () => ec(P, Ah(P), "background-color"),
      onSetup: I.onSetupCellOrRow
    }), P.ui.registry.addNestedMenuItem("tablecellbordercolor", {
      icon: "cell-border-color",
      text: "Border color",
      getSubmenuItems: () => ec(P, Pf(P), "border-color"),
      onSetup: I.onSetupCellOrRow
    })), Be("tablecaption", {
      icon: "table-caption",
      text: "Table caption",
      command: "mceTableToggleCaption",
      onSetup: I.onSetupTableWithCaption
    }), Be("tablerowheader", {
      text: "Row header",
      icon: "table-top-header",
      command: "mceTableRowType",
      onAction: dr(P),
      onSetup: I.onSetupTableRowHeaders
    }), Be("tablecolheader", {
      text: "Column header",
      icon: "table-left-header",
      command: "mceTableColType",
      onAction: Kd(P),
      onSetup: I.onSetupTableRowHeaders
    });
  }, Ea = (P) => {
    const I = bd(P);
    oa(P), Nw(P), fu(P, I), Vc(P, I), Cp(P);
  };
  var Ca = () => {
    o.add("table", Ea);
  };
  Ca();
})();
(function() {
  const o = (J) => {
    let be = J;
    return {
      get: () => be,
      set: (Q) => {
        be = Q;
      }
    };
  };
  var r = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const i = (J, be) => {
    J.dispatch("VisualBlocks", { state: be });
  }, u = (J, be, ke) => {
    J.dom.toggleClass(J.getBody(), "mce-visualblocks"), ke.set(!ke.get()), i(J, ke.get());
  }, h = (J, be, ke) => {
    J.addCommand("mceVisualBlocks", () => {
      u(J, be, ke);
    });
  }, y = (J) => (be) => be.options.get(J), k = (J) => {
    const be = J.options.register;
    be("visualblocks_default_state", {
      processor: "boolean",
      default: !1
    });
  }, _ = y("visualblocks_default_state"), D = (J, be, ke) => {
    J.on("PreviewFormats AfterPreviewFormats", (Ce) => {
      ke.get() && J.dom.toggleClass(J.getBody(), "mce-visualblocks", Ce.type === "afterpreviewformats");
    }), J.on("init", () => {
      _(J) && u(J, be, ke);
    });
  }, L = (J, be) => (ke) => {
    ke.setActive(be.get());
    const Ce = (Q) => ke.setActive(Q.state);
    return J.on("VisualBlocks", Ce), () => J.off("VisualBlocks", Ce);
  }, W = (J, be) => {
    const ke = () => J.execCommand("mceVisualBlocks");
    J.ui.registry.addToggleButton("visualblocks", {
      icon: "visualblocks",
      tooltip: "Show blocks",
      onAction: ke,
      onSetup: L(J, be)
    }), J.ui.registry.addToggleMenuItem("visualblocks", {
      text: "Show blocks",
      icon: "visualblocks",
      onAction: ke,
      onSetup: L(J, be)
    });
  };
  var se = () => {
    r.add("visualblocks", (J, be) => {
      k(J);
      const ke = o(!1);
      h(J, be, ke), W(J, ke), D(J, be, ke);
    });
  };
  se();
})();
(function() {
  const o = (Ke) => {
    let bt = Ke;
    return {
      get: () => bt,
      set: (Po) => {
        bt = Po;
      }
    };
  };
  var r = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const i = (Ke) => ({ isEnabled: () => Ke.get() }), u = (Ke, bt) => Ke.dispatch("VisualChars", { state: bt }), h = (Ke, bt, gn) => {
    var Tn;
    return gn(Ke, bt.prototype) ? !0 : ((Tn = Ke.constructor) === null || Tn === void 0 ? void 0 : Tn.name) === bt.name;
  }, y = (Ke) => {
    const bt = typeof Ke;
    return Ke === null ? "null" : bt === "object" && Array.isArray(Ke) ? "array" : bt === "object" && h(Ke, String, (gn, Tn) => Tn.isPrototypeOf(gn)) ? "string" : bt;
  }, k = (Ke) => (bt) => y(bt) === Ke, _ = (Ke) => (bt) => typeof bt === Ke, D = (Ke) => (bt) => Ke === bt, L = k("string"), W = k("object"), se = D(null), J = _("boolean"), be = (Ke) => Ke == null, ke = (Ke) => !be(Ke), Ce = _("number");
  class Q {
    constructor(bt, gn) {
      this.tag = bt, this.value = gn;
    }
    static some(bt) {
      return new Q(!0, bt);
    }
    static none() {
      return Q.singletonNone;
    }
    fold(bt, gn) {
      return this.tag ? gn(this.value) : bt();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(bt) {
      return this.tag ? Q.some(bt(this.value)) : Q.none();
    }
    bind(bt) {
      return this.tag ? bt(this.value) : Q.none();
    }
    exists(bt) {
      return this.tag && bt(this.value);
    }
    forall(bt) {
      return !this.tag || bt(this.value);
    }
    filter(bt) {
      return !this.tag || bt(this.value) ? this : Q.none();
    }
    getOr(bt) {
      return this.tag ? this.value : bt;
    }
    or(bt) {
      return this.tag ? this : bt;
    }
    getOrThunk(bt) {
      return this.tag ? this.value : bt();
    }
    orThunk(bt) {
      return this.tag ? this : bt();
    }
    getOrDie(bt) {
      if (this.tag)
        return this.value;
      throw new Error(bt ?? "Called getOrDie on None");
    }
    static from(bt) {
      return ke(bt) ? Q.some(bt) : Q.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(bt) {
      this.tag && bt(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Q.singletonNone = new Q(!1);
  const oe = (Ke, bt) => {
    const gn = Ke.length, Tn = new Array(gn);
    for (let Po = 0; Po < gn; Po++) {
      const cr = Ke[Po];
      Tn[Po] = bt(cr, Po);
    }
    return Tn;
  }, ae = (Ke, bt) => {
    for (let gn = 0, Tn = Ke.length; gn < Tn; gn++) {
      const Po = Ke[gn];
      bt(Po, gn);
    }
  }, G = (Ke, bt) => {
    const gn = [];
    for (let Tn = 0, Po = Ke.length; Tn < Po; Tn++) {
      const cr = Ke[Tn];
      bt(cr, Tn) && gn.push(cr);
    }
    return gn;
  }, ve = Object.keys, nt = (Ke, bt) => {
    const gn = ve(Ke);
    for (let Tn = 0, Po = gn.length; Tn < Po; Tn++) {
      const cr = gn[Tn], ea = Ke[cr];
      bt(ea, cr);
    }
  }, Xe = typeof window < "u" ? window : Function("return this;")(), te = (Ke, bt) => {
    let gn = bt ?? Xe;
    for (let Tn = 0; Tn < Ke.length && gn !== void 0 && gn !== null; ++Tn)
      gn = gn[Ke[Tn]];
    return gn;
  }, lt = (Ke, bt) => {
    const gn = Ke.split(".");
    return te(gn, bt);
  }, ot = (Ke, bt) => lt(Ke, bt), Kt = (Ke, bt) => {
    const gn = ot(Ke, bt);
    if (gn == null)
      throw new Error(Ke + " not available on this browser");
    return gn;
  }, je = Object.getPrototypeOf, ye = (Ke) => Kt("HTMLElement", Ke), dn = (Ke) => {
    const bt = lt("ownerDocument.defaultView", Ke);
    return W(Ke) && (ye(bt).prototype.isPrototypeOf(Ke) || /^HTML\w*Element$/.test(je(Ke).constructor.name));
  }, wt = 1, qe = 3, B = (Ke) => Ke.dom.nodeType, mn = (Ke) => Ke.dom.nodeValue, dt = (Ke) => (bt) => B(bt) === Ke, En = (Ke) => tn(Ke) && dn(Ke.dom), tn = dt(wt), Le = dt(qe), jt = (Ke, bt, gn) => {
    if (L(gn) || J(gn) || Ce(gn))
      Ke.setAttribute(bt, gn + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", bt, ":: Value ", gn, ":: Element ", Ke), new Error("Attribute value was not simple");
  }, Fn = (Ke, bt, gn) => {
    jt(Ke.dom, bt, gn);
  }, St = (Ke, bt) => {
    const gn = Ke.dom.getAttribute(bt);
    return gn === null ? void 0 : gn;
  }, on = (Ke, bt) => {
    Ke.dom.removeAttribute(bt);
  }, tt = (Ke, bt) => {
    const gn = St(Ke, bt);
    return gn === void 0 || gn === "" ? [] : gn.split(" ");
  }, mt = (Ke, bt, gn) => {
    const Po = tt(Ke, bt).concat([gn]);
    return Fn(Ke, bt, Po.join(" ")), !0;
  }, Y = (Ke, bt, gn) => {
    const Tn = G(tt(Ke, bt), (Po) => Po !== gn);
    return Tn.length > 0 ? Fn(Ke, bt, Tn.join(" ")) : on(Ke, bt), !1;
  }, Wo = (Ke) => Ke.dom.classList !== void 0, To = (Ke) => tt(Ke, "class"), Ot = (Ke, bt) => mt(Ke, "class", bt), Mt = (Ke, bt) => Y(Ke, "class", bt), zn = (Ke, bt) => {
    Wo(Ke) ? Ke.dom.classList.add(bt) : Ot(Ke, bt);
  }, At = (Ke) => {
    (Wo(Ke) ? Ke.dom.classList : To(Ke)).length === 0 && on(Ke, "class");
  }, $n = (Ke, bt) => {
    Wo(Ke) ? Ke.dom.classList.remove(bt) : Mt(Ke, bt), At(Ke);
  }, en = (Ke, bt) => {
    const Tn = (bt || document).createElement("div");
    if (Tn.innerHTML = Ke, !Tn.hasChildNodes() || Tn.childNodes.length > 1) {
      const Po = "HTML does not have a single root node";
      throw console.error(Po, Ke), new Error(Po);
    }
    return mo(Tn.childNodes[0]);
  }, Ue = (Ke, bt) => {
    const Tn = (bt || document).createElement(Ke);
    return mo(Tn);
  }, jn = (Ke, bt) => {
    const Tn = (bt || document).createTextNode(Ke);
    return mo(Tn);
  }, mo = (Ke) => {
    if (Ke == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: Ke };
  }, Vt = {
    fromHtml: en,
    fromTag: Ue,
    fromText: jn,
    fromDom: mo,
    fromPoint: (Ke, bt, gn) => Q.from(Ke.dom.elementFromPoint(bt, gn)).map(mo)
  }, Ct = {
    "": "nbsp",
    "": "shy"
  }, Jn = (Ke, bt) => {
    let gn = "";
    return nt(Ke, (Tn, Po) => {
      gn += Po;
    }), new RegExp("[" + gn + "]", bt ? "g" : "");
  }, Pn = (Ke) => {
    let bt = "";
    return nt(Ke, (gn) => {
      bt && (bt += ","), bt += "span.mce-" + gn;
    }), bt;
  }, so = Jn(Ct), pr = Jn(Ct, !0), nr = Pn(Ct), Ko = "mce-nbsp", Qo = (Ke) => Ke.dom.contentEditable, Mr = (Ke) => '<span data-mce-bogus="1" class="mce-' + Ct[Ke] + '">' + Ke + "</span>", at = (Ke) => Ke.nodeName.toLowerCase() === "span" && Ke.classList.contains("mce-nbsp-wrap"), kt = (Ke) => {
    const bt = mn(Ke);
    return Le(Ke) && L(bt) && so.test(bt);
  }, yn = (Ke) => En(Ke) && Qo(Ke) === "false", pn = (Ke, bt) => {
    if (En(Ke) && !at(Ke.dom)) {
      const gn = Qo(Ke);
      if (gn === "true")
        return !0;
      if (gn === "false")
        return !1;
    }
    return bt;
  }, Oo = (Ke, bt, gn) => {
    let Tn = [];
    const Po = Ke.dom, cr = oe(Po.childNodes, Vt.fromDom), ea = (ta) => at(ta.dom) || !yn(ta);
    return ae(cr, (ta) => {
      gn && ea(ta) && bt(ta) && (Tn = Tn.concat([ta])), Tn = Tn.concat(Oo(ta, bt, pn(ta, gn)));
    }), Tn;
  }, hr = (Ke, bt) => {
    for (; Ke.parentNode; ) {
      if (Ke.parentNode === bt)
        return bt;
      Ke = Ke.parentNode;
    }
  }, or = (Ke) => Ke.replace(pr, Mr), Ir = (Ke, bt) => {
    const gn = Ke.dom, Tn = Oo(Vt.fromDom(bt), kt, Ke.dom.isEditable(bt));
    ae(Tn, (Po) => {
      var cr;
      const ea = Po.dom.parentNode;
      if (at(ea))
        zn(Vt.fromDom(ea), Ko);
      else {
        const ta = or(gn.encode((cr = mn(Po)) !== null && cr !== void 0 ? cr : "")), Ps = gn.create("div", {}, ta);
        let Re;
        for (; Re = Ps.lastChild; )
          gn.insertAfter(Re, Po.dom);
        Ke.dom.remove(Po.dom);
      }
    });
  }, Zo = (Ke, bt) => {
    const gn = Ke.dom.select(nr, bt);
    ae(gn, (Tn) => {
      at(Tn) ? $n(Vt.fromDom(Tn), Ko) : Ke.dom.remove(Tn, !0);
    });
  }, Tr = (Ke) => {
    const bt = Ke.getBody(), gn = Ke.selection.getBookmark();
    let Tn = hr(Ke.selection.getNode(), bt);
    Tn = Tn !== void 0 ? Tn : bt, Zo(Ke, Tn), Ir(Ke, Tn), Ke.selection.moveToBookmark(gn);
  }, Ht = (Ke, bt) => {
    u(Ke, bt.get());
    const gn = Ke.getBody();
    bt.get() === !0 ? Ir(Ke, gn) : Zo(Ke, gn);
  }, Ho = (Ke, bt) => {
    bt.set(!bt.get());
    const gn = Ke.selection.getBookmark();
    Ht(Ke, bt), Ke.selection.moveToBookmark(gn);
  }, As = (Ke, bt) => {
    Ke.addCommand("mceVisualChars", () => {
      Ho(Ke, bt);
    });
  }, ra = (Ke) => (bt) => bt.options.get(Ke), qs = (Ke) => {
    const bt = Ke.options.register;
    bt("visualchars_default_state", {
      processor: "boolean",
      default: !1
    });
  }, Ks = ra("visualchars_default_state"), kr = (Ke, bt) => {
    Ke.on("init", () => {
      Ht(Ke, bt);
    });
  }, xa = (Ke, bt) => {
    let gn = null;
    return {
      cancel: () => {
        se(gn) || (clearTimeout(gn), gn = null);
      },
      throttle: (...cr) => {
        se(gn) && (gn = setTimeout(() => {
          gn = null, Ke.apply(null, cr);
        }, bt));
      }
    };
  }, ca = (Ke, bt) => {
    const gn = xa(() => {
      Tr(Ke);
    }, 300);
    Ke.on("keydown", (Tn) => {
      bt.get() === !0 && (Tn.keyCode === 13 ? Tr(Ke) : gn.throttle());
    }), Ke.on("remove", gn.cancel);
  }, Or = (Ke, bt) => (gn) => {
    gn.setActive(bt.get());
    const Tn = (Po) => gn.setActive(Po.state);
    return Ke.on("VisualChars", Tn), () => Ke.off("VisualChars", Tn);
  }, Xn = (Ke, bt) => {
    const gn = () => Ke.execCommand("mceVisualChars");
    Ke.ui.registry.addToggleButton("visualchars", {
      tooltip: "Show invisible characters",
      icon: "visualchars",
      onAction: gn,
      onSetup: Or(Ke, bt)
    }), Ke.ui.registry.addToggleMenuItem("visualchars", {
      text: "Show invisible characters",
      icon: "visualchars",
      onAction: gn,
      onSetup: Or(Ke, bt)
    });
  };
  var Ss = () => {
    r.add("visualchars", (Ke) => {
      qs(Ke);
      const bt = o(Ks(Ke));
      return As(Ke, bt), Xn(Ke, bt), ca(Ke, bt), kr(Ke, bt), i(bt);
    });
  };
  Ss();
})();
tinymce.Resource.add("content/default/content.css", `body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Open Sans','Helvetica Neue',sans-serif;line-height:1.4;margin:1rem}table{border-collapse:collapse}table:not([cellpadding]) td,table:not([cellpadding]) th{padding:.4rem}table[border]:not([border="0"]):not([style*=border-width]) td,table[border]:not([border="0"]):not([style*=border-width]) th{border-width:1px}table[border]:not([border="0"]):not([style*=border-style]) td,table[border]:not([border="0"]):not([style*=border-style]) th{border-style:solid}table[border]:not([border="0"]):not([style*=border-color]) td,table[border]:not([border="0"]):not([style*=border-color]) th{border-color:#ccc}figure{display:table;margin:1rem auto}figure figcaption{color:#999;display:block;margin-top:.25rem;text-align:center}hr{border-color:#ccc;border-style:solid;border-width:1px 0 0 0}code{background-color:#e8e8e8;border-radius:3px;padding:.1rem .2rem}.mce-content-body:not([dir=rtl]) blockquote{border-left:2px solid #ccc;margin-left:1.5rem;padding-left:1rem}.mce-content-body[dir=rtl] blockquote{border-right:2px solid #ccc;margin-right:1.5rem;padding-right:1rem}`);
tinymce.Resource.add("ui/default/content.css", `.mce-content-body .mce-item-anchor{background:transparent url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D'8'%20height%3D'12'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%3E%3Cpath%20d%3D'M0%200L8%200%208%2012%204.09117821%209%200%2012z'%2F%3E%3C%2Fsvg%3E%0A") no-repeat center}.mce-content-body .mce-item-anchor:empty{cursor:default;display:inline-block;height:12px!important;padding:0 2px;-webkit-user-modify:read-only;-moz-user-modify:read-only;-webkit-user-select:all;-moz-user-select:all;user-select:all;width:8px!important}.mce-content-body .mce-item-anchor:not(:empty){background-position-x:2px;display:inline-block;padding-left:12px}.mce-content-body .mce-item-anchor[data-mce-selected]{outline-offset:1px}.tox-comments-visible .tox-comment[contenteditable=false]:not([data-mce-selected]),.tox-comments-visible span.tox-comment img:not([data-mce-selected]),.tox-comments-visible span.tox-comment span.mce-preview-object:not([data-mce-selected]),.tox-comments-visible span.tox-comment>audio:not([data-mce-selected]),.tox-comments-visible span.tox-comment>video:not([data-mce-selected]){outline:3px solid #ffe89d}.tox-comments-visible .tox-comment[contenteditable=false][data-mce-annotation-active=true]:not([data-mce-selected]){outline:3px solid #fed635}.tox-comments-visible span.tox-comment[data-mce-annotation-active=true] img:not([data-mce-selected]),.tox-comments-visible span.tox-comment[data-mce-annotation-active=true] span.mce-preview-object:not([data-mce-selected]),.tox-comments-visible span.tox-comment[data-mce-annotation-active=true]>audio:not([data-mce-selected]),.tox-comments-visible span.tox-comment[data-mce-annotation-active=true]>video:not([data-mce-selected]){outline:3px solid #fed635}.tox-comments-visible span.tox-comment:not([data-mce-selected]){background-color:#ffe89d;outline:0}.tox-comments-visible span.tox-comment[data-mce-annotation-active=true]:not([data-mce-selected=inline-boundary]){background-color:#fed635}.tox-checklist>li:not(.tox-checklist--hidden){list-style:none;margin:.25em 0}.tox-checklist>li:not(.tox-checklist--hidden)::before{content:url("data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cg%20id%3D%22checklist-unchecked%22%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%3E%3Crect%20id%3D%22Rectangle%22%20width%3D%2215%22%20height%3D%2215%22%20x%3D%22.5%22%20y%3D%22.5%22%20fill-rule%3D%22nonzero%22%20stroke%3D%22%234C4C4C%22%20rx%3D%222%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%0A");cursor:pointer;height:1em;margin-left:-1.5em;margin-top:.125em;position:absolute;width:1em}.tox-checklist li:not(.tox-checklist--hidden).tox-checklist--checked::before{content:url("data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cg%20id%3D%22checklist-checked%22%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%3E%3Crect%20id%3D%22Rectangle%22%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%234099FF%22%20fill-rule%3D%22nonzero%22%20rx%3D%222%22%2F%3E%3Cpath%20id%3D%22Path%22%20fill%3D%22%23FFF%22%20fill-rule%3D%22nonzero%22%20d%3D%22M11.5703186%2C3.14417309%20C11.8516238%2C2.73724603%2012.4164781%2C2.62829933%2012.83558%2C2.89774797%20C13.260121%2C3.17069355%2013.3759736%2C3.72932262%2013.0909105%2C4.14168582%20L7.7580587%2C11.8560195%20C7.43776896%2C12.3193404%206.76483983%2C12.3852142%206.35607322%2C11.9948725%20L3.02491697%2C8.8138662%20C2.66090143%2C8.46625845%202.65798871%2C7.89594698%203.01850234%2C7.54483354%20C3.373942%2C7.19866177%203.94940006%2C7.19592841%204.30829608%2C7.5386474%20L6.85276923%2C9.9684299%20L11.5703186%2C3.14417309%20Z%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%0A")}[dir=rtl] .tox-checklist>li:not(.tox-checklist--hidden)::before{margin-left:0;margin-right:-1.5em}code[class*=language-],pre[class*=language-]{color:#000;background:0 0;text-shadow:0 1px #fff;font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;tab-size:4;-webkit-hyphens:none;hyphens:none}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{text-shadow:none;background:#b3d4fc}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{text-shadow:none;background:#b3d4fc}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#f5f2f0}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#999}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{color:#9a6e3a;background:hsla(0,0%,100%,.5)}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.class-name,.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.mce-content-body{overflow-wrap:break-word;word-wrap:break-word}.mce-content-body .mce-visual-caret{background-color:#000;background-color:currentColor;position:absolute}.mce-content-body .mce-visual-caret-hidden{display:none}.mce-content-body [data-mce-caret]{left:-1000px;margin:0;padding:0;position:absolute;right:auto;top:0}.mce-content-body .mce-offscreen-selection{left:-2000000px;max-width:1000000px;position:absolute}.mce-content-body [contentEditable=false]{cursor:default}.mce-content-body [contentEditable=true]{cursor:text}.tox-cursor-format-painter{cursor:url("data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2224%22%20height%3D%2224%22%20viewBox%3D%220%200%2024%2024%22%3E%0A%20%20%3Cg%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%3E%0A%20%20%20%20%3Cpath%20fill%3D%22%23000%22%20fill-rule%3D%22nonzero%22%20d%3D%22M15%2C6%20C15%2C5.45%2014.55%2C5%2014%2C5%20L6%2C5%20C5.45%2C5%205%2C5.45%205%2C6%20L5%2C10%20C5%2C10.55%205.45%2C11%206%2C11%20L14%2C11%20C14.55%2C11%2015%2C10.55%2015%2C10%20L15%2C9%20L16%2C9%20L16%2C12%20L9%2C12%20L9%2C19%20C9%2C19.55%209.45%2C20%2010%2C20%20L11%2C20%20C11.55%2C20%2012%2C19.55%2012%2C19%20L12%2C14%20L18%2C14%20L18%2C7%20L15%2C7%20L15%2C6%20Z%22%2F%3E%0A%20%20%20%20%3Cpath%20fill%3D%22%23000%22%20fill-rule%3D%22nonzero%22%20d%3D%22M1%2C1%20L8.25%2C1%20C8.66421356%2C1%209%2C1.33578644%209%2C1.75%20L9%2C1.75%20C9%2C2.16421356%208.66421356%2C2.5%208.25%2C2.5%20L2.5%2C2.5%20L2.5%2C8.25%20C2.5%2C8.66421356%202.16421356%2C9%201.75%2C9%20L1.75%2C9%20C1.33578644%2C9%201%2C8.66421356%201%2C8.25%20L1%2C1%20Z%22%2F%3E%0A%20%20%3C%2Fg%3E%0A%3C%2Fsvg%3E%0A"),default}div.mce-footnotes hr{margin-inline-end:auto;margin-inline-start:0;width:25%}div.mce-footnotes li>a.mce-footnotes-backlink{text-decoration:none}@media print{sup.mce-footnote a{color:#000;text-decoration:none}div.mce-footnotes{break-inside:avoid;width:100%}div.mce-footnotes li>a.mce-footnotes-backlink{display:none}}tiny-math-block{display:flex;justify-content:center;margin:16px 0 16px 0}tiny-math-inline{display:inline-block}.mce-content-body figure.align-left{float:left}.mce-content-body figure.align-right{float:right}.mce-content-body figure.image.align-center{display:table;margin-left:auto;margin-right:auto}.mce-preview-object{border:1px solid gray;display:inline-block;line-height:0;margin:0 2px 0 2px;position:relative}.mce-preview-object .mce-shim{background:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7);height:100%;left:0;position:absolute;top:0;width:100%}.mce-preview-object[data-mce-selected="2"] .mce-shim{display:none}.mce-content-body .mce-mergetag{cursor:default!important;-webkit-user-select:none;-moz-user-select:none;user-select:none}.mce-content-body .mce-mergetag:hover{background-color:rgba(0,108,231,.1)}.mce-content-body .mce-mergetag-affix{background-color:rgba(0,108,231,.1);color:#006ce7}.mce-object{background:transparent url("data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2224%22%20height%3D%2224%22%3E%3Cpath%20d%3D%22M4%203h16a1%201%200%200%201%201%201v16a1%201%200%200%201-1%201H4a1%201%200%200%201-1-1V4a1%201%200%200%201%201-1zm1%202v14h14V5H5zm4.79%202.565l5.64%204.028a.5.5%200%200%201%200%20.814l-5.64%204.028a.5.5%200%200%201-.79-.407V7.972a.5.5%200%200%201%20.79-.407z%22%2F%3E%3C%2Fsvg%3E%0A") no-repeat center;border:1px dashed #aaa}.mce-pagebreak{border:1px dashed #aaa;cursor:default;display:block;height:5px;margin-top:15px;page-break-before:always;width:100%}@media print{.mce-pagebreak{border:0}}.tiny-pageembed .mce-shim{background:url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7);height:100%;left:0;position:absolute;top:0;width:100%}.tiny-pageembed[data-mce-selected="2"] .mce-shim{display:none}.tiny-pageembed{display:inline-block;position:relative}.tiny-pageembed--16by9,.tiny-pageembed--1by1,.tiny-pageembed--21by9,.tiny-pageembed--4by3{display:block;overflow:hidden;padding:0;position:relative;width:100%}.tiny-pageembed--21by9{padding-top:42.857143%}.tiny-pageembed--16by9{padding-top:56.25%}.tiny-pageembed--4by3{padding-top:75%}.tiny-pageembed--1by1{padding-top:100%}.tiny-pageembed--16by9 iframe,.tiny-pageembed--1by1 iframe,.tiny-pageembed--21by9 iframe,.tiny-pageembed--4by3 iframe{border:0;height:100%;left:0;position:absolute;top:0;width:100%}.mce-content-body[data-mce-placeholder]{position:relative}.mce-content-body[data-mce-placeholder]:not(.mce-visualblocks)::before{color:rgba(34,47,62,.7);content:attr(data-mce-placeholder);position:absolute}@media (forced-colors:active){.mce-content-body[data-mce-placeholder]:not(.mce-visualblocks)::before{color:highlight;filter:brightness(30%);z-index:-1}}.mce-content-body:not([dir=rtl])[data-mce-placeholder]:not(.mce-visualblocks)::before{left:1px}.mce-content-body[dir=rtl][data-mce-placeholder]:not(.mce-visualblocks)::before{right:1px}.mce-content-body div.mce-resizehandle{background-color:#4099ff;border-color:#4099ff;border-style:solid;border-width:1px;box-sizing:border-box;height:10px;position:absolute;width:10px;z-index:1298}.mce-content-body div.mce-resizehandle:hover{background-color:#4099ff}.mce-content-body div.mce-resizehandle:nth-of-type(1){cursor:nwse-resize}.mce-content-body div.mce-resizehandle:nth-of-type(2){cursor:nesw-resize}.mce-content-body div.mce-resizehandle:nth-of-type(3){cursor:nwse-resize}.mce-content-body div.mce-resizehandle:nth-of-type(4){cursor:nesw-resize}.mce-content-body .mce-resize-backdrop{z-index:10000}.mce-content-body .mce-clonedresizable{cursor:default;opacity:.5;outline:1px dashed #000;position:absolute;z-index:10001}.mce-content-body .mce-clonedresizable.mce-resizetable-columns td,.mce-content-body .mce-clonedresizable.mce-resizetable-columns th{border:0}.mce-content-body .mce-resize-helper{background:#555;background:rgba(0,0,0,.75);border:1px;border-radius:3px;color:#fff;display:none;font-family:sans-serif;font-size:12px;line-height:14px;margin:5px 10px;padding:5px;position:absolute;white-space:nowrap;z-index:10002}.tox-rtc-user-selection{position:relative}.tox-rtc-user-cursor{bottom:0;cursor:default;position:absolute;top:0;width:2px}.tox-rtc-user-cursor::before{background-color:inherit;border-radius:50%;content:'';display:block;height:8px;position:absolute;right:-3px;top:-3px;width:8px}.tox-rtc-user-cursor:hover::after{background-color:inherit;border-radius:100px;box-sizing:border-box;color:#fff;content:attr(data-user);display:block;font-size:12px;font-weight:700;left:-5px;min-height:8px;min-width:8px;padding:0 12px;position:absolute;top:-11px;white-space:nowrap;z-index:1000}.tox-rtc-user-selection--1 .tox-rtc-user-cursor{background-color:#2dc26b}.tox-rtc-user-selection--2 .tox-rtc-user-cursor{background-color:#e03e2d}.tox-rtc-user-selection--3 .tox-rtc-user-cursor{background-color:#f1c40f}.tox-rtc-user-selection--4 .tox-rtc-user-cursor{background-color:#3598db}.tox-rtc-user-selection--5 .tox-rtc-user-cursor{background-color:#b96ad9}.tox-rtc-user-selection--6 .tox-rtc-user-cursor{background-color:#e67e23}.tox-rtc-user-selection--7 .tox-rtc-user-cursor{background-color:#aaa69d}.tox-rtc-user-selection--8 .tox-rtc-user-cursor{background-color:#f368e0}.tox-rtc-remote-image{background:#eaeaea url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2236%22%20height%3D%2212%22%20viewBox%3D%220%200%2036%2012%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%20%20%3Ccircle%20cx%3D%226%22%20cy%3D%226%22%20r%3D%223%22%20fill%3D%22rgba(0%2C%200%2C%200%2C%20.2)%22%3E%0A%20%20%20%20%3Canimate%20attributeName%3D%22r%22%20values%3D%223%3B5%3B3%22%20calcMode%3D%22linear%22%20dur%3D%221s%22%20repeatCount%3D%22indefinite%22%20%2F%3E%0A%20%20%3C%2Fcircle%3E%0A%20%20%3Ccircle%20cx%3D%2218%22%20cy%3D%226%22%20r%3D%223%22%20fill%3D%22rgba(0%2C%200%2C%200%2C%20.2)%22%3E%0A%20%20%20%20%3Canimate%20attributeName%3D%22r%22%20values%3D%223%3B5%3B3%22%20calcMode%3D%22linear%22%20begin%3D%22.33s%22%20dur%3D%221s%22%20repeatCount%3D%22indefinite%22%20%2F%3E%0A%20%20%3C%2Fcircle%3E%0A%20%20%3Ccircle%20cx%3D%2230%22%20cy%3D%226%22%20r%3D%223%22%20fill%3D%22rgba(0%2C%200%2C%200%2C%20.2)%22%3E%0A%20%20%20%20%3Canimate%20attributeName%3D%22r%22%20values%3D%223%3B5%3B3%22%20calcMode%3D%22linear%22%20begin%3D%22.66s%22%20dur%3D%221s%22%20repeatCount%3D%22indefinite%22%20%2F%3E%0A%20%20%3C%2Fcircle%3E%0A%3C%2Fsvg%3E%0A") no-repeat center center;border:1px solid #ccc;min-height:240px;min-width:320px}.mce-match-marker{background:#aaa;color:#fff}.mce-match-marker-selected{background:#39f;color:#fff}.mce-match-marker-selected::-moz-selection{background:#39f;color:#fff}.mce-match-marker-selected::selection{background:#39f;color:#fff}.mce-content-body audio[data-mce-selected],.mce-content-body details[data-mce-selected],.mce-content-body embed[data-mce-selected],.mce-content-body img[data-mce-selected],.mce-content-body object[data-mce-selected],.mce-content-body table[data-mce-selected],.mce-content-body video[data-mce-selected]{outline:3px solid #b4d7ff}.mce-content-body hr[data-mce-selected]{outline:3px solid #b4d7ff;outline-offset:1px}.mce-content-body [contentEditable=false] [contentEditable=true]:focus{outline:3px solid #b4d7ff}.mce-content-body [contentEditable=false] [contentEditable=true]:hover{outline:3px solid #b4d7ff}.mce-content-body [contentEditable=false][data-mce-selected]{cursor:not-allowed;outline:3px solid #b4d7ff}.mce-content-body.mce-content-readonly [contentEditable=true]:focus,.mce-content-body.mce-content-readonly [contentEditable=true]:hover{outline:0}.mce-content-body [data-mce-selected=inline-boundary]{background-color:#b4d7ff}.mce-content-body .mce-edit-focus{outline:3px solid #b4d7ff}.mce-content-body td[data-mce-selected],.mce-content-body th[data-mce-selected]{position:relative}.mce-content-body td[data-mce-selected]::-moz-selection,.mce-content-body th[data-mce-selected]::-moz-selection{background:0 0}.mce-content-body td[data-mce-selected]::selection,.mce-content-body th[data-mce-selected]::selection{background:0 0}.mce-content-body td[data-mce-selected] *,.mce-content-body th[data-mce-selected] *{outline:0;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.mce-content-body td[data-mce-selected]::after,.mce-content-body th[data-mce-selected]::after{background-color:rgba(180,215,255,.7);border:1px solid rgba(180,215,255,.7);bottom:-1px;content:'';left:-1px;mix-blend-mode:multiply;position:absolute;right:-1px;top:-1px}@media screen and (-ms-high-contrast:active),(-ms-high-contrast:none){.mce-content-body td[data-mce-selected]::after,.mce-content-body th[data-mce-selected]::after{border-color:rgba(0,84,180,.7)}}.mce-content-body img[data-mce-selected]::-moz-selection{background:0 0}.mce-content-body img[data-mce-selected]::selection{background:0 0}.ephox-snooker-resizer-bar{background-color:#b4d7ff;opacity:0;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ephox-snooker-resizer-cols{cursor:col-resize}.ephox-snooker-resizer-rows{cursor:row-resize}.ephox-snooker-resizer-bar.ephox-snooker-resizer-bar-dragging{opacity:1}.mce-spellchecker-word{background-image:url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D'4'%20height%3D'4'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%3E%3Cpath%20stroke%3D'%23ff0000'%20fill%3D'none'%20stroke-linecap%3D'round'%20stroke-opacity%3D'.75'%20d%3D'M0%203L2%201%204%203'%2F%3E%3C%2Fsvg%3E%0A");background-position:0 calc(100% + 1px);background-repeat:repeat-x;background-size:auto 6px;cursor:default;height:2rem}.mce-spellchecker-grammar{background-image:url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D'4'%20height%3D'4'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%3E%3Cpath%20stroke%3D'%2300A835'%20fill%3D'none'%20stroke-linecap%3D'round'%20d%3D'M0%203L2%201%204%203'%2F%3E%3C%2Fsvg%3E%0A");background-position:0 calc(100% + 1px);background-repeat:repeat-x;background-size:auto 6px;cursor:default}.mce-toc{border:1px solid gray}.mce-toc h2{margin:4px}.mce-toc ul>li{list-style-type:none}[data-mce-block]{display:block}.mce-item-table:not([border]),.mce-item-table:not([border]) caption,.mce-item-table:not([border]) td,.mce-item-table:not([border]) th,.mce-item-table[border="0"],.mce-item-table[border="0"] caption,.mce-item-table[border="0"] td,.mce-item-table[border="0"] th,table[style*="border-width: 0px"],table[style*="border-width: 0px"] caption,table[style*="border-width: 0px"] td,table[style*="border-width: 0px"] th{border:1px dashed #bbb}.mce-visualblocks address,.mce-visualblocks article,.mce-visualblocks aside,.mce-visualblocks blockquote,.mce-visualblocks div:not([data-mce-bogus]),.mce-visualblocks dl,.mce-visualblocks figcaption,.mce-visualblocks figure,.mce-visualblocks h1,.mce-visualblocks h2,.mce-visualblocks h3,.mce-visualblocks h4,.mce-visualblocks h5,.mce-visualblocks h6,.mce-visualblocks hgroup,.mce-visualblocks ol,.mce-visualblocks p,.mce-visualblocks pre,.mce-visualblocks section,.mce-visualblocks ul{background-repeat:no-repeat;border:1px dashed #bbb;margin-left:3px;padding-top:10px}.mce-visualblocks p{background-image:url(data:image/gif;base64,R0lGODlhCQAJAJEAAAAAAP///7u7u////yH5BAEAAAMALAAAAAAJAAkAAAIQnG+CqCN/mlyvsRUpThG6AgA7)}.mce-visualblocks h1{background-image:url(data:image/gif;base64,R0lGODlhDQAKAIABALu7u////yH5BAEAAAEALAAAAAANAAoAAAIXjI8GybGu1JuxHoAfRNRW3TWXyF2YiRUAOw==)}.mce-visualblocks h2{background-image:url(data:image/gif;base64,R0lGODlhDgAKAIABALu7u////yH5BAEAAAEALAAAAAAOAAoAAAIajI8Hybbx4oOuqgTynJd6bGlWg3DkJzoaUAAAOw==)}.mce-visualblocks h3{background-image:url(data:image/gif;base64,R0lGODlhDgAKAIABALu7u////yH5BAEAAAEALAAAAAAOAAoAAAIZjI8Hybbx4oOuqgTynJf2Ln2NOHpQpmhAAQA7)}.mce-visualblocks h4{background-image:url(data:image/gif;base64,R0lGODlhDgAKAIABALu7u////yH5BAEAAAEALAAAAAAOAAoAAAIajI8HybbxInR0zqeAdhtJlXwV1oCll2HaWgAAOw==)}.mce-visualblocks h5{background-image:url(data:image/gif;base64,R0lGODlhDgAKAIABALu7u////yH5BAEAAAEALAAAAAAOAAoAAAIajI8HybbxIoiuwjane4iq5GlW05GgIkIZUAAAOw==)}.mce-visualblocks h6{background-image:url(data:image/gif;base64,R0lGODlhDgAKAIABALu7u////yH5BAEAAAEALAAAAAAOAAoAAAIajI8HybbxIoiuwjan04jep1iZ1XRlAo5bVgAAOw==)}.mce-visualblocks div:not([data-mce-bogus]){background-image:url(data:image/gif;base64,R0lGODlhEgAKAIABALu7u////yH5BAEAAAEALAAAAAASAAoAAAIfjI9poI0cgDywrhuxfbrzDEbQM2Ei5aRjmoySW4pAAQA7)}.mce-visualblocks section{background-image:url(data:image/gif;base64,R0lGODlhKAAKAIABALu7u////yH5BAEAAAEALAAAAAAoAAoAAAI5jI+pywcNY3sBWHdNrplytD2ellDeSVbp+GmWqaDqDMepc8t17Y4vBsK5hDyJMcI6KkuYU+jpjLoKADs=)}.mce-visualblocks article{background-image:url(data:image/gif;base64,R0lGODlhKgAKAIABALu7u////yH5BAEAAAEALAAAAAAqAAoAAAI6jI+pywkNY3wG0GBvrsd2tXGYSGnfiF7ikpXemTpOiJScasYoDJJrjsG9gkCJ0ag6KhmaIe3pjDYBBQA7)}.mce-visualblocks blockquote{background-image:url(data:image/gif;base64,R0lGODlhPgAKAIABALu7u////yH5BAEAAAEALAAAAAA+AAoAAAJPjI+py+0Knpz0xQDyuUhvfoGgIX5iSKZYgq5uNL5q69asZ8s5rrf0yZmpNkJZzFesBTu8TOlDVAabUyatguVhWduud3EyiUk45xhTTgMBBQA7)}.mce-visualblocks address{background-image:url(data:image/gif;base64,R0lGODlhLQAKAIABALu7u////yH5BAEAAAEALAAAAAAtAAoAAAI/jI+pywwNozSP1gDyyZcjb3UaRpXkWaXmZW4OqKLhBmLs+K263DkJK7OJeifh7FicKD9A1/IpGdKkyFpNmCkAADs=)}.mce-visualblocks pre{background-image:url(data:image/gif;base64,R0lGODlhFQAKAIABALu7uwAAACH5BAEAAAEALAAAAAAVAAoAAAIjjI+ZoN0cgDwSmnpz1NCueYERhnibZVKLNnbOq8IvKpJtVQAAOw==)}.mce-visualblocks figure{background-image:url(data:image/gif;base64,R0lGODlhJAAKAIAAALu7u////yH5BAEAAAEALAAAAAAkAAoAAAI0jI+py+2fwAHUSFvD3RlvG4HIp4nX5JFSpnZUJ6LlrM52OE7uSWosBHScgkSZj7dDKnWAAgA7)}.mce-visualblocks figcaption{border:1px dashed #bbb}.mce-visualblocks hgroup{background-image:url(data:image/gif;base64,R0lGODlhJwAKAIABALu7uwAAACH5BAEAAAEALAAAAAAnAAoAAAI3jI+pywYNI3uB0gpsRtt5fFnfNZaVSYJil4Wo03Hv6Z62uOCgiXH1kZIIJ8NiIxRrAZNMZAtQAAA7)}.mce-visualblocks aside{background-image:url(data:image/gif;base64,R0lGODlhHgAKAIABAKqqqv///yH5BAEAAAEALAAAAAAeAAoAAAItjI+pG8APjZOTzgtqy7I3f1yehmQcFY4WKZbqByutmW4aHUd6vfcVbgudgpYCADs=)}.mce-visualblocks ul{background-image:url(data:image/gif;base64,R0lGODlhDQAKAIAAALu7u////yH5BAEAAAEALAAAAAANAAoAAAIXjI8GybGuYnqUVSjvw26DzzXiqIDlVwAAOw==)}.mce-visualblocks ol{background-image:url(data:image/gif;base64,R0lGODlhDQAKAIABALu7u////yH5BAEAAAEALAAAAAANAAoAAAIXjI8GybH6HHt0qourxC6CvzXieHyeWQAAOw==)}.mce-visualblocks dl{background-image:url(data:image/gif;base64,R0lGODlhDQAKAIABALu7u////yH5BAEAAAEALAAAAAANAAoAAAIXjI8GybEOnmOvUoWznTqeuEjNSCqeGRUAOw==)}.mce-visualblocks:not([dir=rtl]) address,.mce-visualblocks:not([dir=rtl]) article,.mce-visualblocks:not([dir=rtl]) aside,.mce-visualblocks:not([dir=rtl]) blockquote,.mce-visualblocks:not([dir=rtl]) div:not([data-mce-bogus]),.mce-visualblocks:not([dir=rtl]) dl,.mce-visualblocks:not([dir=rtl]) figcaption,.mce-visualblocks:not([dir=rtl]) figure,.mce-visualblocks:not([dir=rtl]) h1,.mce-visualblocks:not([dir=rtl]) h2,.mce-visualblocks:not([dir=rtl]) h3,.mce-visualblocks:not([dir=rtl]) h4,.mce-visualblocks:not([dir=rtl]) h5,.mce-visualblocks:not([dir=rtl]) h6,.mce-visualblocks:not([dir=rtl]) hgroup,.mce-visualblocks:not([dir=rtl]) ol,.mce-visualblocks:not([dir=rtl]) p,.mce-visualblocks:not([dir=rtl]) pre,.mce-visualblocks:not([dir=rtl]) section,.mce-visualblocks:not([dir=rtl]) ul{margin-left:3px}.mce-visualblocks[dir=rtl] address,.mce-visualblocks[dir=rtl] article,.mce-visualblocks[dir=rtl] aside,.mce-visualblocks[dir=rtl] blockquote,.mce-visualblocks[dir=rtl] div:not([data-mce-bogus]),.mce-visualblocks[dir=rtl] dl,.mce-visualblocks[dir=rtl] figcaption,.mce-visualblocks[dir=rtl] figure,.mce-visualblocks[dir=rtl] h1,.mce-visualblocks[dir=rtl] h2,.mce-visualblocks[dir=rtl] h3,.mce-visualblocks[dir=rtl] h4,.mce-visualblocks[dir=rtl] h5,.mce-visualblocks[dir=rtl] h6,.mce-visualblocks[dir=rtl] hgroup,.mce-visualblocks[dir=rtl] ol,.mce-visualblocks[dir=rtl] p,.mce-visualblocks[dir=rtl] pre,.mce-visualblocks[dir=rtl] section,.mce-visualblocks[dir=rtl] ul{background-position-x:right;margin-right:3px}.mce-nbsp,.mce-shy{background:#aaa}.mce-shy::after{content:'-'}body{font-family:sans-serif}table{border-collapse:collapse}`);
function YEe({ value: o, onChange: r }) {
  return /* @__PURE__ */ cs.jsx(
    qEe,
    {
      licenseKey: "gpl",
      value: o,
      onEditorChange: (i) => r(i),
      init: {
        promotion: !1,
        menubar: !1,
        plugins: [
          "advlist",
          "autolink",
          "lists",
          "link",
          "image",
          "searchreplace",
          "visualblocks",
          "code",
          "fullscreen",
          "media",
          "table",
          "code",
          "help"
        ],
        toolbar: [
          "undo redo | blocks | bold italic forecolor | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | ",
          "link unlink | image media | table | removeformat | code | fullscreen | help"
        ]
      }
    }
  );
}
function XEe({ panels: o, setPanels: r }) {
  const [i, u] = et.useState(0), h = () => {
    r([...o, { title: null, contents: "" }]), u(o.length);
  }, y = (k, _) => {
    const D = [...o];
    Object.assign(D[k], _), r(D);
  };
  return /* @__PURE__ */ cs.jsxs(cs.Fragment, { children: [
    /* @__PURE__ */ cs.jsx("div", { className: "d-flex justify-content-end", children: /* @__PURE__ */ cs.jsx(Dk, { iconBefore: mwe, onClick: h, children: "Add Accordion" }) }),
    /* @__PURE__ */ cs.jsxs("div", { className: "d-flex flex-row mx-2", children: [
      /* @__PURE__ */ cs.jsx("div", { className: "d-flex flex-column mr-2", style: { flexGrow: 1, width: "25%" }, children: o.map((k, _) => /* @__PURE__ */ cs.jsx(
        Dk,
        {
          className: "justify-content-start font-weight-bold p-2 rounded-0",
          variant: i === _ ? "light" : "outline",
          onClick: () => u(_),
          size: "lg",
          children: k.title || "Untitled accordion item"
        },
        `${k.title}-${_}`
      )) }),
      /* @__PURE__ */ cs.jsx("div", { className: "d-flex flex-column", style: { flexGrow: 3 }, children: i !== null && o[i] && /* @__PURE__ */ cs.jsxs(cs.Fragment, { children: [
        /* @__PURE__ */ cs.jsxs("div", { className: "mb-2 d-flex flex-column", children: [
          /* @__PURE__ */ cs.jsx("label", { className: "mb-2", htmlFor: "accordion-title", children: "Title" }),
          /* @__PURE__ */ cs.jsx(
            "input",
            {
              id: "accordion-title",
              className: "px-2 py-0",
              value: o[i].title || "",
              onChange: (k) => y(i, { title: k.target.value })
            }
          )
        ] }),
        /* @__PURE__ */ cs.jsxs("div", { children: [
          /* @__PURE__ */ cs.jsx("span", { className: "mb-2", children: "Content" }),
          /* @__PURE__ */ cs.jsx(
            YEe,
            {
              value: o[i].contents,
              onChange: (k) => y(i, { contents: k })
            }
          )
        ] })
      ] }) })
    ] })
  ] });
}
function Xte({ className: o, onClick: r, label: i }) {
  return /* @__PURE__ */ cs.jsx("li", { className: "action-item", children: /* @__PURE__ */ cs.jsx(
    "a",
    {
      href: "#",
      className: `button action-primary ${o}`,
      onClick: r,
      children: i
    }
  ) });
}
function QEe({
  initialPanels: o,
  initialStyling: r,
  studioSaveUrl: i,
  runtime: u
}) {
  const [h, y] = et.useState(
    0
    /* Styling */
  ), [k, _] = et.useState(r), [D, L] = et.useState(o), W = () => {
    u.notify("save", { state: "start" }), $.post(i, JSON.stringify({ styling: k, panels: D })), u.notify("save", { state: "end" });
  };
  return /* @__PURE__ */ cs.jsx("div", { className: "xblock-accordion xblock--accordion--editor editor-with-buttons", children: /* @__PURE__ */ cs.jsxs("div", { className: "d-flex flex-column", style: { height: "375px" }, children: [
    /* @__PURE__ */ cs.jsxs("div", { className: "d-flex flex-column overflow-auto m-2.5", children: [
      h === 0 && /* @__PURE__ */ cs.jsx(FEe, { styling: k, setStyling: _ }),
      h === 1 && /* @__PURE__ */ cs.jsx(XEe, { panels: D, setPanels: L })
    ] }),
    /* @__PURE__ */ cs.jsx("div", { className: "xblock-actions", children: /* @__PURE__ */ cs.jsxs("ul", { className: "action-buttons", children: [
      h === 0 ? /* @__PURE__ */ cs.jsx(
        Xte,
        {
          onClick: () => y(
            1
            /* Editing */
          ),
          className: "continue-button",
          label: "Continue"
        }
      ) : /* @__PURE__ */ cs.jsx(
        Xte,
        {
          onClick: () => y(
            0
            /* Styling */
          ),
          className: "continue-button",
          label: "Back"
        }
      ),
      /* @__PURE__ */ cs.jsx(
        Xte,
        {
          onClick: W,
          className: "save-button",
          label: "Save"
        }
      ),
      /* @__PURE__ */ cs.jsx("li", { className: "action-item", children: /* @__PURE__ */ cs.jsx(
        "a",
        {
          href: "#",
          className: "button cancel-button",
          onClick: () => u.notify("cancel", {}),
          children: "Cancel"
        }
      ) })
    ] }) })
  ] }) });
}
const tTe = (o, r, {
  panels: i,
  styling: u
}) => {
  const h = o.handlerUrl(r, "studio_save");
  zre.render(
    /* @__PURE__ */ cs.jsx(et.StrictMode, { children: /* @__PURE__ */ cs.jsx(
      QEe,
      {
        initialPanels: i,
        initialStyling: u,
        studioSaveUrl: h,
        runtime: o
      }
    ) }),
    r
  );
};
export {
  tTe as renderEditor
};
